[
  {
    "title": "isSupportedForBrowseDescriptor:parameters:",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/dddevicepickerviewcontroller/4018379-issupportedforbrowsedescriptor",
    "html": "Parameters\nbrowseDescriptor\n\nA descriptor for your application service. To create an application service descriptor, call NWBrowser.Descriptor.applicationService(name:options:) and provide a name for the service.\n\nparameters\n\nParameters for your network connection. Use applicationService to create a default set of parameters that create an encrypted connection with the other devices. You can also add a NWProtocolFramer to provide an application-level messaging protocol.\n\nSee Also\nCreating device picker view controllers\n- initWithBrowseDescriptor:parameters:\nCreates a view controller that displays the other, available devices on your local network."
  },
  {
    "title": "initWithBrowseDescriptor:parameters:",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/dddevicepickerviewcontroller/4013366-initwithbrowsedescriptor",
    "html": "Parameters\nbrowseDescriptor\n\nA descriptor for your application service. To create an application service descriptor, call NWBrowser.Descriptor.applicationService(name:options:) and provide a name for the service.\n\nparameters\n\nParameters for your network connection. Use applicationService to create a default set of parameters that create an encrypted connection with the other devices. You can also add a NWProtocolFramer to provide an application-level messaging protocol.\n\nSee Also\nCreating device picker view controllers\n+ isSupportedForBrowseDescriptor:parameters:\nReturns a Boolean value that indicates whether the current device supports device discovery."
  },
  {
    "title": "init(_:onSelect:label:fallback:parameters:)",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/devicepicker/4019839-init",
    "html": "Parameters\nbrowseDescriptor\n\nA descriptor for your application service. To create an application service descriptor, call NWBrowser.Descriptor.applicationService(name:options:) and provide a name for the service.\n\nonSelect\n\nA closure that the system calls when the user selects a device in the picker view, or cancels the view.\n\nlabel\n\nA label displayed by the network device picker.\n\nfallback\n\nA view that the system displays if the current device doesn’t support device discovery.\n\nparameters\n\nParameters for your network connection. Use applicationService to create a default set of parameters that create an encrypted connection with the other devices. You can also add a NWProtocolFramer to provide an application-level messaging protocol."
  },
  {
    "title": "isSupported(_:using:)",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/dddevicepickerviewcontroller/4019628-issupported",
    "html": "Parameters\nbrowseDescriptor\n\nA descriptor for your application service. To create an application service descriptor, call NWBrowser.Descriptor.applicationService(name:options:) and provide a name for the service.\n\nparameters\n\nParameters for your network connection. Use applicationService to create a default set of parameters that create an encrypted connection with the other devices. You can also add a NWProtocolFramer to provide an application-level messaging protocol.\n\nSee Also\nCreating device picker view controllers\ninit?(browseDescriptor: NWBrowser.Descriptor, parameters: NWParameters?)\nCreates a view controller that displays the other, available devices on your local network."
  },
  {
    "title": "setDevicePickerCompletionHandler:",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/dddevicepickerviewcontroller/4013367-setdevicepickercompletionhandler",
    "html": "Parameters\nendpointPickerCompletionHandler\n\nA block that the system calls after the user selects a device.\n\nDiscussion\n\nThe system calls this block after the user selects a device from the endpoint picker view. If the user cancels the view, the picker silently closes.\n\n// This example uses the default application services parameters;\n// however, you can add a NWProtocolFramer to provide application-level\n// messaging.\nnw_browse_descriptor_t browseDescriptor = nw_browse_descriptor_create_application_service(\"MyAppService\");\n\n\nnw_parameters_t parameters = nw_parameters_create();\n\n\n// Create the view controller for the endpoint picker.\nNWEndpointPickerViewController *endpointPickerViewController = [[NWEndpointPickerViewController alloc] initWithBrowseDescriptor:browseDescriptor parameters: parameters];\n\n\n// Set the endpoint picker handler.\n[endpointPickerViewController setEndpointPickerCompletionHandler:^(nw_endpoint_t  _Nullable endpoint, nw_error_t  _Nullable error) {\n    // Connect to the endpoint here.\n    [self.myConnectionController connectToEndpoint: endpoint];\n}];\n\n\n // Show the network device picker as a full-screen, modal view.\n[self presentViewController:endpointPickerViewController animated:YES completion:nil];\n"
  },
  {
    "title": "callAsFunction(_:parameters:)",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/devicepickersupportedaction/4020013-callasfunction",
    "html": "Parameters\nbrowseDescriptor\n\nA descriptor for your application service. To create an application service descriptor, call NWBrowser.Descriptor.applicationService(name:options:) and provide a name for the service.\n\nparameters\n\nParameters for your network connection. Use applicationService to create a default set of parameters that create an encrypted connection with the other devices. You can also add a NWProtocolFramer to provide an application-level messaging protocol."
  },
  {
    "title": "init(browseDescriptor:parameters:)",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/dddevicepickerviewcontroller/4019627-init",
    "html": "Parameters\nbrowseDescriptor\n\nA descriptor for your application service. To create an application service descriptor, call NWBrowser.Descriptor.applicationService(name:options:) and provide a name for the service.\n\nparameters\n\nParameters for your network connection. Use applicationService to create a default set of parameters that create an encrypted connection with the other devices. You can also add a NWProtocolFramer to provide an application-level messaging protocol.\n\nSee Also\nCreating device picker view controllers\nstatic func isSupported(NWBrowser.Descriptor, using: NWParameters?) -> Bool\nReturns a Boolean value that indicates whether the current device supports device discovery."
  },
  {
    "title": "endpoint",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/dddevicepickerviewcontroller/4013376-endpoint",
    "html": "Discussion\n\nYour app can asynchronously read from this property. The system populates this property when the user selects a device from the endpoint picker. If the user cancels the picker, the system throws an error.\n\nlet endpoint: NWEndpoint\ndo {\n    endpoint = try await myEndpointPickerHandler.endpoint\n} catch {\n    // The user canceled the endpoint picker view.\n    return\n}\n\n\n// Use the endpoint here.\nmyDeviceConnectionManager.connectTo(endpoint: endpoint)\n"
  },
  {
    "title": "DevicePicker",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/devicepicker",
    "html": "Overview\n\nAlways display the picker as a full-screen, modal view. If the user selects a device, the system calls the closure you passed as the onSelect parameter. If the user cancels the picker, it silently closes.\n\nDevicePicker(\n    .applicationService(name: \"MyAppService\")) { endpoint in\n        myDeviceManager.connectTo(endpoint: endpoint)\n    } label: {\n        Text(\"Connect to a local device.\")\n    } fallback: {\n        Text(\"Not supported.\")\n    } parameters: {\n        // This example uses the default application services parameters;\n        // however, you can add a NWProtocolFramer to provide application-level\n        // messaging.\n        .applicationService\n    }\n\n\nIf the current device doesn’t support device discovery, the system displays the fallback view instead of the device picker. Use the DevicePickerSupportedAction environment value to check whether the current device supports device discovery.\n\nstruct SettingsView: View {\n\n\n    @Environment{\\.devicePickerSupports} var myDevicePickerSupports\n    @Binding var showDevicePicker: Bool\n\n\n    var body: some View {\n        if myDevicePickerSupports(.applicationService(\"MyAppService\"),\n                                  parameters: { .applicationService }) {\n            Button(\"Select A Device\") {\n                // Display a device picker.\n                showDevicePicker = true\n            }\n        }\n    }\n}\n\n\nTopics\nCreating a device picker\ninit(NWBrowser.Descriptor, onSelect: (NWEndpoint) -> Void, label: () -> Label, fallback: () -> Fallback, parameters: (() -> NWParameters)?)\nCreates a view that displays the other, available devices on your local network.\nInstance Methods\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<DevicePicker<Label, Fallback>, AccessibilityAttachmentModifier>\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<DevicePicker<Label, Fallback>, AccessibilityAttachmentModifier>\nfunc allowedDynamicRange(Image.DynamicRange?) -> View\nfunc animation<V>(Animation?, body: (PlaceholderContentView<DevicePicker<Label, Fallback>>) -> V) -> View\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> View\nfunc colorEffect(Shader, isEnabled: Bool) -> View\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> View\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> View\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> View\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> View\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> View\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> View\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> View\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> View\nfunc controlGroupStyle<S>(S) -> View\nfunc coordinateSpace(NamedCoordinateSpace) -> View\nfunc defaultHoverEffect(HoverEffect?) -> View\nfunc defaultScrollAnchor(UnitPoint?) -> View\nfunc dialogIcon(Image?) -> View\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> View\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> View\nfunc environment<T>(T?) -> View\nfunc focusEffectDisabled(Bool) -> View\nfunc focusable(Bool, interactions: FocusInteractions) -> View\nfunc focusedObject<T>(T) -> View\nfunc focusedObject<T>(T?) -> View\nfunc focusedSceneObject<T>(T) -> View\nfunc focusedSceneObject<T>(T?) -> View\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> View\nfunc focusedValue<T>(T?) -> View\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> View\nfunc fontDesign(Font.Design?) -> View\nfunc fontWidth(Font.Width?) -> View\nfunc geometryGroup() -> View\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> View\nfunc hoverEffectDisabled(Bool) -> View\nfunc invalidatableContent(Bool) -> View\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<DevicePicker<Label, Fallback>>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> View\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<DevicePicker<Label, Fallback>>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> View\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> View\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> View\nfunc menuActionDismissBehavior(MenuActionDismissBehavior) -> View\nfunc menuIndicator(Visibility) -> View\nfunc menuStyle<S>(S) -> View\nfunc monospaced(Bool) -> View\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> View\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> View\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> View\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> View\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> View\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<DevicePicker<Label, Fallback>>, Phase) -> some View, animation: (Phase) -> Animation?) -> View\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<DevicePicker<Label, Fallback>>, Phase) -> some View, animation: (Phase) -> Animation?) -> View\nfunc presentationBackground<S>(S) -> View\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> View\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> View\nfunc presentationCompactAdaptation(PresentationAdaptation) -> View\nfunc presentationCompactAdaptation(horizontal: PresentationAdaptation, vertical: PresentationAdaptation) -> View\nfunc presentationContentInteraction(PresentationContentInteraction) -> View\nfunc presentationCornerRadius(CGFloat?) -> View\nfunc safeAreaPadding(CGFloat) -> View\nfunc safeAreaPadding(EdgeInsets) -> View\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> View\nfunc scrollBounceBehavior(ScrollBounceBehavior, axes: Axis.Set) -> View\nfunc scrollClipDisabled(Bool) -> View\nfunc scrollIndicatorsFlash(onAppear: Bool) -> View\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> View\nfunc scrollPosition(id: Binding<(some Hashable)?>, anchor: UnitPoint?) -> View\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> View\nfunc scrollTargetLayout(isEnabled: Bool) -> View\nfunc scrollTransition(ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> View\nfunc scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> View\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> View\nfunc searchSuggestions<S>(() -> S) -> View\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> View\nfunc selectionDisabled(Bool) -> View\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> View\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> View\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> View\nfunc springLoadingBehavior(SpringLoadingBehavior) -> View\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> View\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> View\nfunc symbolEffectsRemoved(Bool) -> View\nfunc textScale(Text.Scale, isEnabled: Bool) -> View\nfunc toolbar(Visibility, for: ToolbarPlacement...) -> View\nfunc toolbar(removing: ToolbarDefaultItemKind?) -> View\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> View\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> View\nfunc toolbarTitleDisplayMode(ToolbarTitleDisplayMode) -> View\nfunc toolbarTitleMenu<C>(content: () -> C) -> View\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<DevicePicker<Label, Fallback>>) -> V) -> View\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> View\nfunc typeSelectEquivalent(LocalizedStringKey) -> View\nfunc typeSelectEquivalent(Text?) -> View\nfunc typeSelectEquivalent<S>(S) -> View\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> View\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> View\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> View\nRelationships\nConforms To\nView\nSee Also\nSelecting nearby devices\nConnecting a tvOS app to other devices over the local network\nDisplay a view in your tvOS app that lists available iOS, iPadOS, and watchOS devices that the user can connect to over their local network.\nclass DDDevicePickerViewController\nA UIKit view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nstruct DevicePickerSupportedAction\nAn environment value that indicates whether the current device supports device discovery.\nproperty list key NSApplicationServices\nA list of service providers and the devices that they support."
  },
  {
    "title": "Connecting a tvOS app to other devices over the local network",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/connecting_a_tvos_app_to_other_devices_over_the_local_network",
    "html": "Overview\n\nThe DeviceDiscoveryUI framework provides a view that shows all the available iOS, iPadOS, and watchOS devices on your local network. Present this view in your tvOS app, to let the user select a device. The framework then creates an encrypted connection between your tvOS app and the selected device. This lets user’s enhance the tvOS experience. For example, they could control a tvOS game from their iPad, or send heart rate data from their watchOS app to the tvOS workout app. It also lets your app connect to devices across the local network, without giving your app access to the entire network.\n\nTo create a network connection, start by defining which devices your app can connect with. Your app defines one or more application services. Each application service represents a different type of connection that can support a different subset of devices. Next display the list of available devices in a device picker view in your tvOS app using one of the application services. If the user selects a device, the device picker view returns an NWEndpoint for the selected device. Use this endpoint to create a connection, and then use the connection to communicate with the device.\n\nIn your iOS, iPadOS, or watchOS app, declare that your app listens for DeviceDiscoveryUI connections. Then, as soon as your app launches, create an NWListener. When the tvOS app connects to the listener, the listener returns a connection that your app can use to communicate with the tvOS app.\n\nYou use DeviceDiscoveryUI to present the device picker view, and then use the Network framework to create the listeners, create the connections, and send and receive messages.\n\nDefine the supported devices in tvOS\n\nStart by defining the application service identifiers that your apps use to establish their connections. Use the NSApplicationServices key to define the application services for your app. You provide a service identifier, a usage description, and a list of supported devices for each service. You can define more than one application service for your apps. Each service has it’s own identifier, and can connect to a different subset of devices.\n\nDeclare the application services in your app target’s Info tab, or in its Info.plist file.\n\n<key>NSApplicationServices</key>\n<dict>\n    <key>Browses</key>\n    <array>\n        <dict>\n            <key>NSApplicationServiceIdentifier</key>\n            <string>MyApp-Controller</string>\n            <key>NSApplicationServiceUsageDescription</key>\n            <string>You can control this app using an iOS device.</string>\n            <key>NSApplicationServicePlatformSupport</key>\n            <array>\n                <string>iOS</string>\n                <string>iPadOS</string>\n            </array>\n        </dict>\n        <dict>\n            <key>NSApplicationServiceIdentifier</key>\n            <string>MyApp-Workout</string>\n            <key>NSApplicationServiceUsageDescription</key>\n            <string>Connects to a watchOS app to read heart-rate and active calories burned from a workout session.</string>\n            <key>NSApplicationServicePlatformSupport</key>\n            <array>\n                <string>watchOS</string>\n            </array>\n        </dict>\n    </array>\n</dict>\n\n\nYou can use the human-readable key names in Xcode’s property list editor.\n\nDisplay the list of available devices\n\nNext, create and display the device picker view in your tvOS app. The following code creates and displays a DevicePicker view using SwiftUI.\n\n@State var showDevicePicker = false\n\n\nvar body: some View {\n    VStack {\n        Text(deviceName)\n        Button(\"Connect\") {\n            showDevicePicker = true\n        }\n    }\n    .padding()\n    .fullScreenCover(isPresented: $showDevicePicker) {\n        // Display the device picker view.\n        DevicePicker(\n            .applicationService(name: \"MyAppService\")) { endpoint in\n                myDeviceManager.connectTo(endpoint: endpoint)\n            } label: {\n                Text(\"Connect to a local device.\")\n            } parameters: {\n                // This example uses the default application services parameters;\n                // however, you can add an NWProtocolFramer to provide application-level\n                // messaging.\n                .applicationService\n            }\n    }\n}\n\n\nDisplay the DevicePicker as a modal view that covers the full screen. This example uses fullScreenCover(isPresented:onDismiss:content:) to display the device picker view when the user clicks the Connect button.\n\nTo create the device picker view, pass an NWBrowser.Descriptor that you created using the NWBrowser.Descriptor.applicationService(name:options:) method. Use the identifier that you defined in your app’s Info.plist file for the descriptor’s name.\n\nNext, provide an onSelect closure that takes a single NWEndpoint value. The system calls this closure after the user selects a device to connect to. Use the closure to set up a connection to the endpoint.\n\nThen include a Label view to represent your app in the device picker view, and pass the default application service parameters using the applicationService property. The default parameters create an encrypted, optimized connection between two devices on your local network. You can also add protocols defined with an NWProtocolFramer to these defaults to support application-level messaging in your app.\n\nWhen presented, the view shows all the supported devices on the local network.\n\nThese devices:\n\nAre logged into your local network.\n\nAre logged into the iCloud account (or another account in the iCloud family) of the default user on Apple TV.\n\nMatch the device type specified in your NSApplicationServicePlatformSupport key.\n\nIf the user selects a device, the system calls your onSelect closure. If they dismiss the device picker view, control returns to the view that displayed the device picker view.\n\nNote\n\nWhile you can display the DevicePicker view in Simulator, it won’t show any devices on the local network. To test connections, run your code on a test device instead.\n\nIf you’re using UIKit, use a DDDevicePickerViewController to present the device picker view.\n\n// This example uses the default application services parameters;\n// however, you can add a NWProtocolFramer to provide application-level\n// messaging.\nlet parameters = NWParameters.applicationService\n\n\n// Create the view controller for the endpoint picker.\nlet myEndpointPickerHandler =\nNWEndpointPickerViewController(browseDescriptor: NWBrowser.Descriptor.applicationService(name: \"MyAppService\"),\n                               parameters: parameters)\n\n\n// Show the network device picker as a full-screen, modal view.\nmyEndpointPickerHandler.modalTransitionStyle = .coverVertical\nshow(myEndpointPickerHandler, sender: nil)\n\n\nlet endpoint: NWEndpoint\ndo {\n    endpoint = try await myEndpointPickerHandler.endpoint\n} catch {\n    // The user canceled the endpoint picker view.\n    return\n}\n\n\n// Use the endpoint here.\nmyDeviceConnectionManager.connectTo(endpoint: endpoint)\n\n\nThis view controller works similarly to the DevicePicker view. The biggest difference is how your app receives the selected endpoint. In this sample, your app awaits a read on the controller’s endpoint property. This causes execution to pause at that point. When the user selects a device, the system returns an endpoint for that device, and execution continues. If the user dismisses the view, the controller throws an error.\n\nAlternatively, you can pass a block to the DDDevicePickerViewController object’s setDevicePickerCompletionHandler: method, and the system calls this block when the user selects a device from the device picker view.\n\nConnect to the provided endpoint\n\nAs soon as the user selects a device, the system passes you an NWEndpoint. Use this endpoint to connect to the selected device. Create an NWConnection, passing it both the endpoint and the parameters that you used to create the device picker view.\n\nfunc connectTo(endpoint: NWEndpoint) {\n    \n    // This example uses the default application services parameters;\n    // however, you can add a NWProtocolFramer to provide application-level\n    // messaging.\n    connection = NWConnection(to: endpoint,\n                              using: .applicationService)\n}\n\n\nYou can then use this connection to send or receive messages to the connected device.\n\nDeclare that other devices listen for connections\n\nBefore a device can appear in the picker view, declare that the iOS, iPadOS, or watchOS version of your app listens for connections.\n\nStart by defining the application service in your app target’s Info tab, or in its Info.plist file. Make sure the NSApplicationServiceIdentifier matches the value specified in your tvOS app. The following example shows setting up the MyApp-Workout identifier on a watchOS app.\n\n<key>NSApplicationServices</key>\n<dict>\n    <key>Advertises</key>\n    <array>\n        <dict>\n            <key>NSApplicationServiceIdentifier</key>\n            <string>MyApp-Workout</string>\n        </dict>\n    </array>\n</dict>\n\n\nYou can use the human-readable key names in Xcode’s property list editor.\n\nSet up the listeners on iOS, iPadOS, or watchOS\n\nNext, to connect to your tvOS app, other versions of your app must set up a listener as soon as the app launches. The network picker can then connect to this listener.\n\nTo create a listener, use the init(applicationService:) initializer, and pass the same application service name that you used in your tvOS app.\n\n// Set up the listener.\ndo {\n    // This example uses the default application services parameters;\n    // however, you can add a NWProtocolFramer to provide application-level\n    // messaging.\n    myListener = try NWListener(using: .applicationService)\n    \n    // Add your application service.\n    myListener?.service = NWListener.Service(applicationService: \"MyAppService\")\n}\ncatch {\n    fatalError(\"*** An error occurred: \\(error.localizedDescription) ***\")\n}\n\n\nThen, create a connection handler for the listener. The system calls this closure when it creates the connection to your tvOS app. You can use this connection to read and write messages.\n\n// Respond to new connections.\nmyListener?.newConnectionHandler = { connection in\n    myConnectionManager.set(connection: connection)\n}\n\n\nYou can also define a state change update handler to track changes to the listener’s state.\n\n// Respond to listener state changes.\nmyListener?.stateUpdateHandler = { listenerState in\n    switch(listenerState) {\n    case .setup:\n        myLogger.debug(\"Listener switched to the Setup state.\")\n    case .waiting(let error):\n        myLogger.debug(\"Listener switched to the Waiting state. error \\(error.localizedDescription)\")\n    case .ready:\n        myLogger.debug(\"Listener switched to the Ready state.\")\n    case .failed(let error):\n        myLogger.debug(\"Listener switched to the Failed state. error: \\(error.localizedDescription)\")\n    case .cancelled:\n        myLogger.debug(\"Listener switched to the Cancelled state.\")\n    @unknown default:\n        myLogger.debug(\"Listener switched to an unknown state.\")\n    }\n}\n\n\nFinally, start the listener.\n\n// Start the listener.\nmyListener?.start(queue: myBackgroundQueue)\n\n\nStart the listener as quickly as possible after your app launches. This ensures that the listener is ready and waiting when the tvOS app attempts to connect.\n\nSee Also\nSelecting nearby devices\nstruct DevicePicker\nA SwiftUI view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nclass DDDevicePickerViewController\nA UIKit view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nstruct DevicePickerSupportedAction\nAn environment value that indicates whether the current device supports device discovery.\nproperty list key NSApplicationServices\nA list of service providers and the devices that they support."
  },
  {
    "title": "DevicePickerSupportedAction",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/devicepickersupportedaction",
    "html": "Overview\n\nAccess the action using the .devicePickerSupports key. Then call it as a function, passing the same browse descriptor and parameters you use to search for devices.\n\nstruct SettingsView: View {\n\n\n    @Environment{\\.devicePickerSupports} var myDevicePickerSupports\n    @Binding var showDevicePicker: Bool\n\n\n    var body: some View {\n        if myDevicePickerSupports(.applicationService(\"MyAppService\"),\n                                  parameters: { .applicationService }) {\n            Button(\"Select A Device\") {\n                // Display a device picker.\n                showDevicePicker = true\n            }\n        }\n    }\n}\n\n\nTopics\nChecking for support\nfunc callAsFunction(NWBrowser.Descriptor, parameters: (() -> NWParameters)?) -> Bool\nReturns a Boolean value that indicates whether the current device supports device discovery.\nSee Also\nSelecting nearby devices\nConnecting a tvOS app to other devices over the local network\nDisplay a view in your tvOS app that lists available iOS, iPadOS, and watchOS devices that the user can connect to over their local network.\nstruct DevicePicker\nA SwiftUI view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nclass DDDevicePickerViewController\nA UIKit view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nproperty list key NSApplicationServices\nA list of service providers and the devices that they support."
  },
  {
    "title": "DDDevicePickerViewController",
    "url": "https://developer.apple.com/documentation/devicediscoveryui/dddevicepickerviewcontroller",
    "html": "Overview\n\nAlways display the device picker as a full-screen, modal view. If the user selects a device, the system sets the endpoint property and calls the endpointPickedHandler.\n\n// This example uses the default application services parameters;\n// however, you can add a NWProtocolFramer to provide application-level\n// messaging.\nlet parameters = NWParameters.applicationService\n\n\n// Create the view controller for the endpoint picker.\nlet devicePickerController =\nDDDevicePickerViewController(browseDescriptor: NWBrowser.Descriptor.applicationService(name: \"MyAppService\"),\n                               parameters: parameters)\n\n\n// Show the network device picker as a full-screen, modal view.\ndevicePickerController.modalTransitionStyle = .coverVertical\nshow(devicePickerController, sender: nil)\n\n\nlet endpoint: NWEndpoint\ndo {\n    endpoint = try await devicePickerController.endpoint\n} catch {\n    // The user canceled the endpoint picker view.\n    return\n}\n\n\n// Use the endpoint here.\nmyDeviceConnectionManager.connectTo(endpoint: endpoint)\n\n\nTopics\nCreating device picker view controllers\nstatic func isSupported(NWBrowser.Descriptor, using: NWParameters?) -> Bool\nReturns a Boolean value that indicates whether the current device supports device discovery.\ninit?(browseDescriptor: NWBrowser.Descriptor, parameters: NWParameters?)\nCreates a view controller that displays the other, available devices on your local network.\nAccessing the selected endpoint\nvar endpoint: NWEndpoint\nA network connection endpoint for the device selected by the user.\nRelationships\nInherits From\nUIViewController\nConforms To\nSendable\nSee Also\nSelecting nearby devices\nConnecting a tvOS app to other devices over the local network\nDisplay a view in your tvOS app that lists available iOS, iPadOS, and watchOS devices that the user can connect to over their local network.\nstruct DevicePicker\nA SwiftUI view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nstruct DevicePickerSupportedAction\nAn environment value that indicates whether the current device supports device discovery.\nproperty list key NSApplicationServices\nA list of service providers and the devices that they support."
  },
  {
    "title": "DeviceDiscoveryUI",
    "url": "https://developer.apple.com/documentation/devicediscoveryui",
    "html": "Overview\n\nThe DeviceDiscoveryUI framework provides an encrypted connection between your tvOS app and your iOS, iPadOS, or watchOS app using the local network. For example, users could control a tvOS game from their iPad. Or, a fitness tvOS app could connect to the watchOS version, which records the workout session and passes heart rate and calorie data back to the tvOS app.\n\nOn Apple TV, you start by presenting a DevicePicker view or a DDDevicePickerViewController. This view displays a list of all the devices your tvOS app can connect to on the local network. When the user selects a device, the system attempts to launch your app on that device. If your app is already installed, the system asks the user if they want to connect to Apple TV. If your app isn’t installed, the system prompts the user to install it.\n\nYou use DeviceDiscoveryUI to present a view that lists available devices, and then use the Network framework to create the listeners, create the connections, and send and receive messages.\n\nDeviceDiscoveryUI provides several advantages over creating a connection using the Network framework directly. It automatically sets up an optimized, encrypted connection between versions of your app running on different local devices. It helps preserve the user’s privacy by only providing access to iOS, iPadOS, and watchOS devices on the local network. Also, because the system securely manages the connection, your users don’t need to authorize full access to their local network.\n\nThe following requirements apply:\n\nDeviceDiscoveryUI is supported only on Apple TV 4K.\n\nYour tvOS app can only connect to one device at a time.\n\nYour tvOS app can only connect to other copies of your app running on iOS, iPadOS, or watchOS.\n\nYou must distribute your app as a universal purchase, so that all copies of your app share the same bundle ID. For more information, see Offering Universal Purchase.\n\nDeviceDiscoveryUI uses the iCloud account of the default user on Apple TV. If Apple TV has more than one user, the user who manages Family Sharing is the default user. DeviceDiscoveryUI only shows devices logged into that user’s iCloud account, or accounts from the user’s Family Sharing group.\n\nTopics\nSelecting nearby devices\nConnecting a tvOS app to other devices over the local network\nDisplay a view in your tvOS app that lists available iOS, iPadOS, and watchOS devices that the user can connect to over their local network.\nstruct DevicePicker\nA SwiftUI view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nclass DDDevicePickerViewController\nA UIKit view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nstruct DevicePickerSupportedAction\nAn environment value that indicates whether the current device supports device discovery.\nproperty list key NSApplicationServices\nA list of service providers and the devices that they support."
  }
]