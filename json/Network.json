[
    {
        "title": "nw_connection_state_waiting",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_t/nw_connection_state_waiting",
        "html": "See Also\nConnection States\nnw_connection_state_invalid\nThe connection is not valid.\nnw_connection_state_preparing\nThe connection in the process of being established.\nnw_connection_state_ready\nThe connection is established, and ready to send and receive data.\nnw_connection_state_failed\nThe connection has disconnected or encountered an error.\nnw_connection_state_cancelled\nThe connection has been canceled."
    },
    {
        "title": "nw_connection_state_ready",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_t/nw_connection_state_ready",
        "html": "See Also\nConnection States\nnw_connection_state_invalid\nThe connection is not valid.\nnw_connection_state_waiting\nThe connection is waiting for a network path change.\nnw_connection_state_preparing\nThe connection in the process of being established.\nnw_connection_state_failed\nThe connection has disconnected or encountered an error.\nnw_connection_state_cancelled\nThe connection has been canceled."
    },
    {
        "title": "nw_connection_state_preparing",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_t/nw_connection_state_preparing",
        "html": "See Also\nConnection States\nnw_connection_state_invalid\nThe connection is not valid.\nnw_connection_state_waiting\nThe connection is waiting for a network path change.\nnw_connection_state_ready\nThe connection is established, and ready to send and receive data.\nnw_connection_state_failed\nThe connection has disconnected or encountered an error.\nnw_connection_state_cancelled\nThe connection has been canceled."
    },
    {
        "title": "nw_connection_state_failed",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_t/nw_connection_state_failed",
        "html": "See Also\nConnection States\nnw_connection_state_invalid\nThe connection is not valid.\nnw_connection_state_waiting\nThe connection is waiting for a network path change.\nnw_connection_state_preparing\nThe connection in the process of being established.\nnw_connection_state_ready\nThe connection is established, and ready to send and receive data.\nnw_connection_state_cancelled\nThe connection has been canceled."
    },
    {
        "title": "nw_connection_state_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_t/nw_connection_state_invalid",
        "html": "See Also\nConnection States\nnw_connection_state_waiting\nThe connection is waiting for a network path change.\nnw_connection_state_preparing\nThe connection in the process of being established.\nnw_connection_state_ready\nThe connection is established, and ready to send and receive data.\nnw_connection_state_failed\nThe connection has disconnected or encountered an error.\nnw_connection_state_cancelled\nThe connection has been canceled."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200580",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": ">=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200598",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
    },
    {
        "title": "...(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200587",
        "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from \u201ca\u201d up to, and including, \u201cz\u201d.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition: minimum <= maximum."
    },
    {
        "title": "..<(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200592",
        "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition: minimum <= maximum."
    },
    {
        "title": "..<(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200589",
        "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection\u2019s indices to represent the range from the start of the collection up to, but not including, the partial range\u2019s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition: maximum must compare equal to itself (i.e. cannot be NaN)."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry/3200574",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "formUnion(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200331-formunion",
        "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets\u2019 raw values."
    },
    {
        "title": "nw_relay_hop_add_additional_http_header_field(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/4155644-nw_relay_hop_add_additional_http",
        "html": "Parameters\nrelay_hop\n\nThe relay hop to modify.\n\nfield_name\n\nThe HTTP header name.\n\nfield_value\n\nThe HTTP header value.\n\nSee Also\nConfiguring Relay Hops\nfunc nw_relay_hop_create(nw_endpoint_t?, nw_endpoint_t?, nw_protocol_options_t?) -> nw_relay_hop_t\nCreates a configuration for a secure relay accessible using HTTP/3, with an optional HTTP/2 fallback."
    },
    {
        "title": "nw_relay_hop_create(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/4155645-nw_relay_hop_create",
        "html": "Parameters\nhttp3_relay_endpoint\n\nA URL or host endpoint identifying the relay server accessible using HTTP/3.\n\nhttp2_relay_endpoint\n\nAn optional URL or host endpoint identifying the relay server accessible using HTTP/2. This can be the same endpoint as http3_relay_endpoint.\n\nrelay_tls_options\n\nThe TLS options to use for the TLS handshake to the relay.\n\nReturn Value\n\nAn initialized relay hop object.\n\nSee Also\nConfiguring Relay Hops\nfunc nw_relay_hop_add_additional_http_header_field(nw_relay_hop_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an HTTP header name and value pair to send as part of CONNECT requests to the relay."
    },
    {
        "title": "NWTXTRecord.Entry.empty",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry/empty",
        "html": "See Also\nEntry Types\ncase none\nThe key is not mapped to any value.\ncase string(String)\nThe key is mapped to a string."
    },
    {
        "title": "nw_protocol_stack_prepend_application_protocol(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976871-nw_protocol_stack_prepend_applic",
        "html": "See Also\nModifying Application Protocols\nfunc nw_protocol_stack_clear_application_protocols(nw_protocol_stack_t)\nRemoves all application protocols from the protocol stack.\nfunc nw_protocol_stack_iterate_application_protocols(nw_protocol_stack_t, (nw_protocol_options_t) -> Void)\nIterates through the array of application protocol options that will be used by connections and listeners.\ntypealias nw_protocol_stack_iterate_protocols_block_t\nA block that allows you to inspect or modify a single protocol's options."
    },
    {
        "title": "nw_protocol_stack_set_transport_protocol(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976872-nw_protocol_stack_set_transport_",
        "html": "See Also\nConfiguring Lower Protocols\nfunc nw_protocol_stack_copy_transport_protocol(nw_protocol_stack_t) -> nw_protocol_options_t?\nAccesses the options for the protocol stack's transport protocol.\nfunc nw_protocol_stack_copy_internet_protocol(nw_protocol_stack_t) -> nw_protocol_options_t?\nAccesses the protocol stack's Internet Protocol options."
    },
    {
        "title": "init(http2RelayEndpoint:tlsOptions:additionalHTTPHeaderFields:)",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/relayhop/4156646-init",
        "html": "Parameters\nhttp2RelayEndpoint\n\nA URL or host endpoint identifying the relay server accessible using HTTP/2.\n\ntlsOptions\n\nThe TLS options to use for the TLS handshake to the relay.\n\nadditionalHTTPHeaderFields\n\nA dictionary of additional HTTP headers to send as part of CONNECT requests to the relay.\n\nSee Also\nCreating Relay Hops\ninit(http3RelayEndpoint: NWEndpoint, http2RelayEndpoint: NWEndpoint?, tlsOptions: NWProtocolTLS.Options, additionalHTTPHeaderFields: [String : String])\nCreates a configuration for a secure relay accessible using HTTP/3, with an optional HTTP/2 fallback."
    },
    {
        "title": "nw_connection_state_cancelled",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_t/nw_connection_state_cancelled",
        "html": "See Also\nConnection States\nnw_connection_state_invalid\nThe connection is not valid.\nnw_connection_state_waiting\nThe connection is waiting for a network path change.\nnw_connection_state_preparing\nThe connection in the process of being established.\nnw_connection_state_ready\nThe connection is established, and ready to send and receive data.\nnw_connection_state_failed\nThe connection has disconnected or encountered an error."
    },
    {
        "title": "identical",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200334-identical",
        "html": "See Also\nChange Flags\nstatic let interfaceAdded: NWBrowser.Result.Change.Flags\nThe service was discovered over a new interface.\nstatic let interfaceRemoved: NWBrowser.Result.Change.Flags\nThe service was no longer discovered over a certain interface.\nstatic let metadataChanged: NWBrowser.Result.Change.Flags\nThe service's associated metadata changed."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200335-init",
        "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
    },
    {
        "title": "contains(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200327-contains",
        "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
    },
    {
        "title": "formSymmetricDifference(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200330-formsymmetricdifference",
        "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets\u2019 raw values."
    },
    {
        "title": "...(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200584",
        "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection\u2019s indices to represent the range from the start of the collection up to, and including, the partial range\u2019s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition: maximum must compare equal to itself (i.e. cannot be NaN)."
    },
    {
        "title": "union(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200368-union",
        "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
    },
    {
        "title": "...(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200581",
        "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection\u2019s indices to represent the range from the partial range\u2019s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition: minimum must compare equal to itself (i.e. cannot be NaN)."
    },
    {
        "title": "isDisjoint(with:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200347-isdisjoint",
        "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
    },
    {
        "title": "init(http3RelayEndpoint:http2RelayEndpoint:tlsOptions:additionalHTTPHeaderFields:)",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/relayhop/4156647-init",
        "html": "Parameters\nhttp3RelayEndpoint\n\nA URL or host endpoint identifying the relay server accessible using HTTP/3.\n\nhttp2RelayEndpoint\n\nAn optional URL or host endpoint identifying the relay server accessible using HTTP/2. This can be the same endpoint as http3RelayEndpoint.\n\ntlsOptions\n\nThe TLS options to use for the TLS handshake to the relay.\n\nadditionalHTTPHeaderFields\n\nA dictionary of additional HTTP headers to send as part of CONNECT requests to the relay.\n\nSee Also\nCreating Relay Hops\ninit(http2RelayEndpoint: NWEndpoint, tlsOptions: NWProtocolTLS.Options, additionalHTTPHeaderFields: [String : String])\nCreates a configuration for a secure relay accessible only using HTTP/2."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry/3236870-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry/3236869-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry/3200575-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
    },
    {
        "title": ">(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200597",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
    },
    {
        "title": "remove(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200360-remove",
        "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
    },
    {
        "title": "symmetricDifference(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200367-symmetricdifference",
        "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200336-init",
        "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
    },
    {
        "title": "subtracting(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200365-subtracting",
        "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200340-init",
        "html": "Relationships\nFrom Protocol\nOptionSet\nRawRepresentable"
    },
    {
        "title": "<(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200594",
        "html": "Relationships\nFrom Protocol\nComparable"
    },
    {
        "title": "formIntersection(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200329-formintersection",
        "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets\u2019 raw values."
    },
    {
        "title": "<=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index/3200595",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
    },
    {
        "title": "insert(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200341-insert",
        "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
    },
    {
        "title": "init(arrayLiteral:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200338-init",
        "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/3236818-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/3200323",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nCalculating Result Changes\ninit(between: NWBrowser.Result?, NWBrowser.Result?)\nInitializes a change between two results.\nfunc hash(into: inout Hasher)\nstatic func == (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool"
    },
    {
        "title": "nw_proxy_config_set_username_and_password(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/4155642-nw_proxy_config_set_username_and",
        "html": "Parameters\nproxy_config\n\nThe proxy configuration to modify.\n\nusername\n\nA proxy authentication username.\n\npassword\n\nA proxy authentication password.\n\nSee Also\nCustomizing Proxy Behavior\nfunc nw_proxy_config_set_failover_allowed(nw_proxy_config_t, Bool)\nConfigures whether or not a proxy configuration allows failover to non-proxied connections. Failover isn\u2019t allowed by default."
    },
    {
        "title": "nw_proxy_config_get_failover_allowed(_:)",
        "url": "https://developer.apple.com/documentation/network/4155640-nw_proxy_config_get_failover_all",
        "html": "Parameters\nproxy_config\n\nThe proxy configuration to check.\n\nReturn Value\n\nA Boolean that indicates whether or not a proxy configuration allows failover to non-proxied connections."
    },
    {
        "title": "subscript(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200695-subscript",
        "html": "Parameters\nbounds\n\nA range of the collection\u2019s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice\u2019s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice\u2019s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity: O(1)"
    },
    {
        "title": "subscript(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200700-subscript",
        "html": "Parameters\nbounds\n\nA range of the collection\u2019s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice\u2019s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity: O(1)"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/3200515-hash",
        "html": "See Also\nClose Codes Comparison Functions\nstatic func != (NWProtocolWebSocket.CloseCode.Defined, NWProtocolWebSocket.CloseCode.Defined) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int"
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/3200516-hashvalue",
        "html": "See Also\nClose Codes Comparison Functions\nstatic func != (NWProtocolWebSocket.CloseCode.Defined, NWProtocolWebSocket.CloseCode.Defined) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "nw_proxy_config_set_failover_allowed(_:_:)",
        "url": "https://developer.apple.com/documentation/network/4155641-nw_proxy_config_set_failover_all",
        "html": "Parameters\nproxy_config\n\nThe proxy configuration to modify.\n\nfailover_allowed\n\nA Boolean that indicates whether or not a proxy configuration allows failover to non-proxied connections.\n\nSee Also\nCustomizing Proxy Behavior\nfunc nw_proxy_config_set_username_and_password(nw_proxy_config_t, UnsafePointer<CChar>, UnsafePointer<CChar>?)\nSets a username and password to use as authentication for a proxy configuration."
    },
    {
        "title": "nw_proxy_config_create_oblivious_http(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/4172961-nw_proxy_config_create_oblivious",
        "html": "Parameters\nrelay\n\nThe Oblivious HTTP relay hop.\n\nrelay_resource_path\n\nThe HTTP path to use for requests to the Oblivious HTTP relay that will forward requests to the gateway.\n\ngateway_key_config\n\nThe key configuration for the Oblivious HTTP gateway.\n\ngateway_key_config_length\n\nThe length of the key configuration buffer in gateway_key_config.\n\nReturn Value\n\nAn initialized proxy configuration object.\n\nDiscussion\n\nOblivious HTTP provides per-message encryption to a gateway through a relay.\n\nSee Also\nCreating Proxy Configurations\nfunc nw_proxy_config_create_relay(nw_relay_hop_t, nw_relay_hop_t?) -> nw_proxy_config_t\nInitializes a proxy configuration with one or two relay hops.\ntypealias nw_relay_hop_t\nA single relay server you can chain together with other servers.\nfunc nw_proxy_config_create_http_connect(nw_endpoint_t, nw_protocol_options_t?) -> nw_proxy_config_t\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1.\nfunc nw_proxy_config_create_socksv5(nw_endpoint_t) -> nw_proxy_config_t\nInitializes a SOCKSv5 proxy configuration."
    },
    {
        "title": "nw_proxy_config_create_socksv5(_:)",
        "url": "https://developer.apple.com/documentation/network/4155639-nw_proxy_config_create_socksv5",
        "html": "Parameters\nproxy_endpoint\n\nA host endpoint identifying the SOCKS proxy server.\n\nReturn Value\n\nAn initialized proxy configuration object.\n\nSee Also\nCreating Proxy Configurations\nfunc nw_proxy_config_create_relay(nw_relay_hop_t, nw_relay_hop_t?) -> nw_proxy_config_t\nInitializes a proxy configuration with one or two relay hops.\ntypealias nw_relay_hop_t\nA single relay server you can chain together with other servers.\nfunc nw_proxy_config_create_oblivious_http(nw_relay_hop_t, UnsafePointer<CChar>, UnsafePointer<UInt8>, Int) -> nw_proxy_config_t\nInitializes an Oblivious HTTP proxy configuration using a relay and a gateway.\nfunc nw_proxy_config_create_http_connect(nw_endpoint_t, nw_protocol_options_t?) -> nw_proxy_config_t\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1."
    },
    {
        "title": "nw_proxy_config_create_http_connect(_:_:)",
        "url": "https://developer.apple.com/documentation/network/4155637-nw_proxy_config_create_http_conn",
        "html": "Parameters\nproxy_endpoint\n\nA host endpoint identifying the proxy server accessible using HTTP/1.1.\n\nproxy_tls_options\n\nOptional TLS options to use for a TLS handshake to the relay. If no TLS options are provided, the proxy will be accessed using cleartext HTTP.\n\nReturn Value\n\nAn initialized proxy configuration object.\n\nSee Also\nCreating Proxy Configurations\nfunc nw_proxy_config_create_relay(nw_relay_hop_t, nw_relay_hop_t?) -> nw_proxy_config_t\nInitializes a proxy configuration with one or two relay hops.\ntypealias nw_relay_hop_t\nA single relay server you can chain together with other servers.\nfunc nw_proxy_config_create_oblivious_http(nw_relay_hop_t, UnsafePointer<CChar>, UnsafePointer<UInt8>, Int) -> nw_proxy_config_t\nInitializes an Oblivious HTTP proxy configuration using a relay and a gateway.\nfunc nw_proxy_config_create_socksv5(nw_endpoint_t) -> nw_proxy_config_t\nInitializes a SOCKSv5 proxy configuration."
    },
    {
        "title": "nw_proxy_config_create_relay(_:_:)",
        "url": "https://developer.apple.com/documentation/network/4155638-nw_proxy_config_create_relay",
        "html": "Parameters\nfirst_hop\n\nA relay hop, which is either the first of two hops, or the only hop.\n\nsecond_hop\n\nAn optional second relay hop.\n\nReturn Value\n\nAn initialized proxy configuration object.\n\nSee Also\nCreating Proxy Configurations\ntypealias nw_relay_hop_t\nA single relay server you can chain together with other servers.\nfunc nw_proxy_config_create_oblivious_http(nw_relay_hop_t, UnsafePointer<CChar>, UnsafePointer<UInt8>, Int) -> nw_proxy_config_t\nInitializes an Oblivious HTTP proxy configuration using a relay and a gateway.\nfunc nw_proxy_config_create_http_connect(nw_endpoint_t, nw_protocol_options_t?) -> nw_proxy_config_t\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1.\nfunc nw_proxy_config_create_socksv5(nw_endpoint_t) -> nw_proxy_config_t\nInitializes a SOCKSv5 proxy configuration."
    },
    {
        "title": "nw_relay_hop_t",
        "url": "https://developer.apple.com/documentation/network/nw_relay_hop_t",
        "html": "Discussion\n\nRelay servers are secure HTTP proxies that allow proxying TCP traffic using the CONNECT method and UDP traffic using the connect-udp protocol defined in RFC 9298.\n\nTopics\nConfiguring Relay Hops\nfunc nw_relay_hop_create(nw_endpoint_t?, nw_endpoint_t?, nw_protocol_options_t?) -> nw_relay_hop_t\nCreates a configuration for a secure relay accessible using HTTP/3, with an optional HTTP/2 fallback.\nfunc nw_relay_hop_add_additional_http_header_field(nw_relay_hop_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an HTTP header name and value pair to send as part of CONNECT requests to the relay.\nSee Also\nCreating Proxy Configurations\nfunc nw_proxy_config_create_relay(nw_relay_hop_t, nw_relay_hop_t?) -> nw_proxy_config_t\nInitializes a proxy configuration with one or two relay hops.\nfunc nw_proxy_config_create_oblivious_http(nw_relay_hop_t, UnsafePointer<CChar>, UnsafePointer<UInt8>, Int) -> nw_proxy_config_t\nInitializes an Oblivious HTTP proxy configuration using a relay and a gateway.\nfunc nw_proxy_config_create_http_connect(nw_endpoint_t, nw_protocol_options_t?) -> nw_proxy_config_t\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1.\nfunc nw_proxy_config_create_socksv5(nw_endpoint_t) -> nw_proxy_config_t\nInitializes a SOCKSv5 proxy configuration."
    },
    {
        "title": "nw_release",
        "url": "https://developer.apple.com/documentation/network/2976819-nw_release",
        "html": "See Also\nMemory Management\nnw_retain\nAdds a reference count to a Network.framework object.\nnw_object_t\nThe generic type for objects in the Network framework.\nRelated Documentation\nos_release"
    },
    {
        "title": "nw_protocol_stack_copy_internet_protocol(_:)",
        "url": "https://developer.apple.com/documentation/network/2976867-nw_protocol_stack_copy_internet_",
        "html": "See Also\nConfiguring Lower Protocols\nfunc nw_protocol_stack_copy_transport_protocol(nw_protocol_stack_t) -> nw_protocol_options_t?\nAccesses the options for the protocol stack's transport protocol.\nfunc nw_protocol_stack_set_transport_protocol(nw_protocol_stack_t, nw_protocol_options_t)\nReplaces the protocol stack's transport protocol with a new set of options."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200326",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "update(with:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200370-update",
        "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
    },
    {
        "title": "nw_protocol_stack_copy_transport_protocol(_:)",
        "url": "https://developer.apple.com/documentation/network/2976868-nw_protocol_stack_copy_transport",
        "html": "See Also\nConfiguring Lower Protocols\nfunc nw_protocol_stack_set_transport_protocol(nw_protocol_stack_t, nw_protocol_options_t)\nReplaces the protocol stack's transport protocol with a new set of options.\nfunc nw_protocol_stack_copy_internet_protocol(nw_protocol_stack_t) -> nw_protocol_options_t?\nAccesses the protocol stack's Internet Protocol options."
    },
    {
        "title": "nw_protocol_stack_clear_application_protocols(_:)",
        "url": "https://developer.apple.com/documentation/network/2976866-nw_protocol_stack_clear_applicat",
        "html": "See Also\nModifying Application Protocols\nfunc nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t, nw_protocol_options_t)\nAdds a protocol onto the top of the protocol stack.\nfunc nw_protocol_stack_iterate_application_protocols(nw_protocol_stack_t, (nw_protocol_options_t) -> Void)\nIterates through the array of application protocol options that will be used by connections and listeners.\ntypealias nw_protocol_stack_iterate_protocols_block_t\nA block that allows you to inspect or modify a single protocol's options."
    },
    {
        "title": "nw_protocol_stack_iterate_application_protocols(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976869-nw_protocol_stack_iterate_applic",
        "html": "See Also\nModifying Application Protocols\nfunc nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t, nw_protocol_options_t)\nAdds a protocol onto the top of the protocol stack.\nfunc nw_protocol_stack_clear_application_protocols(nw_protocol_stack_t)\nRemoves all application protocols from the protocol stack.\ntypealias nw_protocol_stack_iterate_protocols_block_t\nA block that allows you to inspect or modify a single protocol's options."
    },
    {
        "title": "nw_protocol_stack_iterate_protocols_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_protocol_stack_iterate_protocols_block_t",
        "html": "See Also\nModifying Application Protocols\nfunc nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t, nw_protocol_options_t)\nAdds a protocol onto the top of the protocol stack.\nfunc nw_protocol_stack_clear_application_protocols(nw_protocol_stack_t)\nRemoves all application protocols from the protocol stack.\nfunc nw_protocol_stack_iterate_application_protocols(nw_protocol_stack_t, (nw_protocol_options_t) -> Void)\nIterates through the array of application protocol options that will be used by connections and listeners."
    },
    {
        "title": "shuffled()",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200679-shuffled",
        "html": "Return Value\n\nA shuffled array of this sequence\u2019s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system\u2019s default random generator.\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "interfaceRemoved",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200344-interfaceremoved",
        "html": "See Also\nChange Flags\nstatic let identical: NWBrowser.Result.Change.Flags\nThe results are identical.\nstatic let interfaceAdded: NWBrowser.Result.Change.Flags\nThe service was discovered over a new interface.\nstatic let metadataChanged: NWBrowser.Result.Change.Flags\nThe service's associated metadata changed."
    },
    {
        "title": "metadataChanged",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200358-metadatachanged",
        "html": "See Also\nChange Flags\nstatic let identical: NWBrowser.Result.Change.Flags\nThe results are identical.\nstatic let interfaceAdded: NWBrowser.Result.Change.Flags\nThe service was discovered over a new interface.\nstatic let interfaceRemoved: NWBrowser.Result.Change.Flags\nThe service was no longer discovered over a certain interface."
    },
    {
        "title": "interfaceAdded",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200343-interfaceadded",
        "html": "See Also\nChange Flags\nstatic let identical: NWBrowser.Result.Change.Flags\nThe results are identical.\nstatic let interfaceRemoved: NWBrowser.Result.Change.Flags\nThe service was no longer discovered over a certain interface.\nstatic let metadataChanged: NWBrowser.Result.Change.Flags\nThe service's associated metadata changed."
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200359-rawvalue",
        "html": "Relationships\nFrom Protocol\nRawRepresentable"
    },
    {
        "title": "isStrictSuperset(of:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200352-isstrictsuperset",
        "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
    },
    {
        "title": "isStrictSubset(of:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200350-isstrictsubset",
        "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
    },
    {
        "title": "intersection(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200345-intersection",
        "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
    },
    {
        "title": "isSuperset(of:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200356-issuperset",
        "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
    },
    {
        "title": "isSubset(of:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200354-issubset",
        "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
    },
    {
        "title": "subtract(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags/3200363-subtract",
        "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/3236858-rawvalue",
        "html": "Relationships\nFrom Protocol\nRawRepresentable"
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/3236857-init",
        "html": "Relationships\nFrom Protocol\nRawRepresentable"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/3200512",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nClose Codes Comparison Functions\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.tlsHandshake",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/tlshandshake",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.internalServerError",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/internalservererror",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.messageTooBig",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/messagetoobig",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.mandatoryExtension",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/mandatoryextension",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.normalClosure",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/normalclosure",
        "html": "See Also\nDefined Close Codes\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.Response.Status.accept",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/status/accept",
        "html": "See Also\nHandshake Status Values\ncase reject\nThe client request is being rejected."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/status/3236864-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "NWTXTRecord.Entry.string(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry/string",
        "html": "See Also\nEntry Types\ncase none\nThe key is not mapped to any value.\ncase empty\nThe key is mapped to an empty value."
    },
    {
        "title": "NWTXTRecord.Entry.none",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry/none",
        "html": "See Also\nEntry Types\ncase empty\nThe key is mapped to an empty value.\ncase string(String)\nThe key is mapped to a string."
    },
    {
        "title": "NWProtocolWebSocket.Response.Status.reject",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/status/reject",
        "html": "See Also\nHandshake Status Values\ncase accept\nThe client request is being accepted."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/status/3200558",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "nw_resolver_config_create_tls(_:)",
        "url": "https://developer.apple.com/documentation/network/3548055-nw_resolver_config_create_tls",
        "html": "Parameters\nserver_endpoint\n\nThe hostname of the provided endpoint will be used to validate the TLS certificate of the server. See RFC 7858 for more details.\n\nSee Also\nRequiring Encrypted DNS\nfunc nw_privacy_context_require_encrypted_name_resolution(nw_privacy_context_t, Bool, nw_resolver_config_t?)\nRequires that any DNS name resolution for connections associated with this context use encrypted transports, such as TLS or HTTPS.\ntypealias nw_resolver_config_t\nA DNS server configuration that uses TLS or HTTPS.\nfunc nw_resolver_config_create_https(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-HTTPS resolver configuration.\nfunc nw_resolver_config_add_server_address(nw_resolver_config_t, nw_endpoint_t)\nProvides a well-known DNS server address to use instead of looking up the address dynamically."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/status/3236863-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/relayhop/4156645-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
    },
    {
        "title": "nw_privacy_context_require_encrypted_name_resolution(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3548042-nw_privacy_context_require_encry",
        "html": "See Also\nRequiring Encrypted DNS\ntypealias nw_resolver_config_t\nA DNS server configuration that uses TLS or HTTPS.\nfunc nw_resolver_config_create_https(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-HTTPS resolver configuration.\nfunc nw_resolver_config_create_tls(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-TLS resolver configuration.\nfunc nw_resolver_config_add_server_address(nw_resolver_config_t, nw_endpoint_t)\nProvides a well-known DNS server address to use instead of looking up the address dynamically."
    },
    {
        "title": "nw_resolver_config_create_https(_:)",
        "url": "https://developer.apple.com/documentation/network/3548054-nw_resolver_config_create_https",
        "html": "Parameters\nurl_endpoint\n\nThe URL describes the location of the DNS server, such as \u201chttps://dnsserver.example.net/dns-query\u201d. See RFC 8484 for more details.\n\nSee Also\nRequiring Encrypted DNS\nfunc nw_privacy_context_require_encrypted_name_resolution(nw_privacy_context_t, Bool, nw_resolver_config_t?)\nRequires that any DNS name resolution for connections associated with this context use encrypted transports, such as TLS or HTTPS.\ntypealias nw_resolver_config_t\nA DNS server configuration that uses TLS or HTTPS.\nfunc nw_resolver_config_create_tls(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-TLS resolver configuration.\nfunc nw_resolver_config_add_server_address(nw_resolver_config_t, nw_endpoint_t)\nProvides a well-known DNS server address to use instead of looking up the address dynamically."
    },
    {
        "title": "nw_privacy_context_add_proxy(_:_:)",
        "url": "https://developer.apple.com/documentation/network/4155633-nw_privacy_context_add_proxy",
        "html": "Parameters\nprivacy_context\n\nA privacy context to modify. This can include the default privacy context.\n\nproxy_config\n\nA proxy configuration object to apply to all connections that use this context.\n\nDiscussion\n\nIf set on NW_DEFAULT_PRIVACY_CONTEXT, this proxy will additionally apply to other networking APIs used by the calling process.\n\nSee Also\nConfiguring Proxies\nfunc nw_privacy_context_clear_proxies(nw_privacy_context_t)\nClears out any proxies added using nw_privacy_context_add_proxy(_:_:)\ntypealias nw_proxy_config_t\nA proxy configuration for Relays, Oblivious HTTP, HTTP CONNECT, or SOCKSv5."
    },
    {
        "title": "prefix(upTo:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200663-prefix",
        "html": "Parameters\nend\n\nThe \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection\u2019s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection\u2019s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity: O(1)"
    },
    {
        "title": "randomElement()",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200668-randomelement",
        "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system\u2019s default random generator.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
    },
    {
        "title": "nw_resolver_config_add_server_address(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3548053-nw_resolver_config_add_server_ad",
        "html": "See Also\nRequiring Encrypted DNS\nfunc nw_privacy_context_require_encrypted_name_resolution(nw_privacy_context_t, Bool, nw_resolver_config_t?)\nRequires that any DNS name resolution for connections associated with this context use encrypted transports, such as TLS or HTTPS.\ntypealias nw_resolver_config_t\nA DNS server configuration that uses TLS or HTTPS.\nfunc nw_resolver_config_create_https(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-HTTPS resolver configuration.\nfunc nw_resolver_config_create_tls(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-TLS resolver configuration."
    },
    {
        "title": "nw_privacy_context_create(_:)",
        "url": "https://developer.apple.com/documentation/network/3548039-nw_privacy_context_create",
        "html": "See Also\nConfiguring Custom Privacy Settings\nfunc nw_privacy_context_disable_logging(nw_privacy_context_t)\nDisables system logging of connection activity.\nfunc nw_privacy_context_flush_cache(nw_privacy_context_t)\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context."
    },
    {
        "title": "prefix(while:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200667-prefix",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection."
    },
    {
        "title": "min(by:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200656-min",
        "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "prefix(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200658-prefix",
        "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
    },
    {
        "title": "max(by:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200654-max",
        "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence\u2019s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "lexicographicallyPrecedes(_:by:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200650-lexicographicallyprecedes",
        "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)"
    },
    {
        "title": "map(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200652-map",
        "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/cellular/newradio5gvariant/3856617-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/cellular/newradio5gvariant/3856618-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "NWBrowser.Result.Change.Flags",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/flags",
        "html": "Topics\nChange Flags\nstatic let identical: NWBrowser.Result.Change.Flags\nThe results are identical.\nstatic let interfaceAdded: NWBrowser.Result.Change.Flags\nThe service was discovered over a new interface.\nstatic let interfaceRemoved: NWBrowser.Result.Change.Flags\nThe service was no longer discovered over a certain interface.\nstatic let metadataChanged: NWBrowser.Result.Change.Flags\nThe service's associated metadata changed.\nType Aliases\ntypealias NWBrowser.Result.Change.Flags.ArrayLiteralElement\ntypealias NWBrowser.Result.Change.Flags.Element\ntypealias NWBrowser.Result.Change.Flags.RawValue\nInitializers\ninit()\nCreates an empty option set.\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: NWBrowser.Result.Change.Flags...)\nCreates a set containing the elements of the given array literal.\ninit(rawValue: UInt8)\nInstance Properties\nvar hashValue: Int\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nlet rawValue: UInt8\nInstance Methods\nfunc contains(NWBrowser.Result.Change.Flags) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nfunc formIntersection(NWBrowser.Result.Change.Flags)\nRemoves all elements of this option set that are not also present in the given set.\nfunc formSymmetricDifference(NWBrowser.Result.Change.Flags)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nfunc formUnion(NWBrowser.Result.Change.Flags)\nInserts the elements of another set into this option set.\nfunc hash(into: inout Hasher)\nfunc insert(NWBrowser.Result.Change.Flags) -> (inserted: Bool, memberAfterInsert: NWBrowser.Result.Change.Flags)\nAdds the given element to the option set if it is not already a member.\nfunc intersection(NWBrowser.Result.Change.Flags) -> NWBrowser.Result.Change.Flags\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc isDisjoint(with: NWBrowser.Result.Change.Flags) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: NWBrowser.Result.Change.Flags) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: NWBrowser.Result.Change.Flags) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: NWBrowser.Result.Change.Flags) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: NWBrowser.Result.Change.Flags) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc remove(NWBrowser.Result.Change.Flags) -> NWBrowser.Result.Change.Flags?\nRemoves the given element and all elements subsumed by it.\nfunc subtract(NWBrowser.Result.Change.Flags)\nRemoves the elements of the given set from this set.\nfunc subtracting(NWBrowser.Result.Change.Flags) -> NWBrowser.Result.Change.Flags\nReturns a new set containing the elements of this set that do not occur in the given set.\nfunc symmetricDifference(NWBrowser.Result.Change.Flags) -> NWBrowser.Result.Change.Flags\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(NWBrowser.Result.Change.Flags) -> NWBrowser.Result.Change.Flags\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: NWBrowser.Result.Change.Flags) -> NWBrowser.Result.Change.Flags?\nInserts the given element into the set.\nOperator Functions\nstatic func != (NWBrowser.Result.Change.Flags, NWBrowser.Result.Change.Flags) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nRelationships\nConforms To\nHashable\nOptionSet\nSendable\nSee Also\nInspecting Change Types\ncase identical\nNo change was detected for the result.\ncase added(NWBrowser.Result)\nA new result was discovered.\ncase removed(NWBrowser.Result)\nA previously discovered result was removed.\ncase changed(old: NWBrowser.Result, new: NWBrowser.Result, flags: NWBrowser.Result.Change.Flags)\nA result changed properties but was not removed."
    },
    {
        "title": "NWBrowser.Result.Change.changed(old:new:flags:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/changed_old_new_flags",
        "html": "See Also\nInspecting Change Types\ncase identical\nNo change was detected for the result.\ncase added(NWBrowser.Result)\nA new result was discovered.\ncase removed(NWBrowser.Result)\nA previously discovered result was removed.\nstruct NWBrowser.Result.Change.Flags\nFlags providing details about a change in a discovered service."
    },
    {
        "title": "NWTXTRecord.Index",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/index",
        "html": "Topics\nOperator Functions\nstatic func != (NWTXTRecord.Index, NWTXTRecord.Index) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func ... (NWTXTRecord.Index) -> PartialRangeFrom<NWTXTRecord.Index>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (NWTXTRecord.Index) -> PartialRangeThrough<NWTXTRecord.Index>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (NWTXTRecord.Index, NWTXTRecord.Index) -> ClosedRange<NWTXTRecord.Index>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (NWTXTRecord.Index) -> PartialRangeUpTo<NWTXTRecord.Index>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (NWTXTRecord.Index, NWTXTRecord.Index) -> Range<NWTXTRecord.Index>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (NWTXTRecord.Index, NWTXTRecord.Index) -> Bool\nstatic func <= (NWTXTRecord.Index, NWTXTRecord.Index) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func == (NWTXTRecord.Index, NWTXTRecord.Index) -> Bool\nstatic func > (NWTXTRecord.Index, NWTXTRecord.Index) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (NWTXTRecord.Index, NWTXTRecord.Index) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.\nRelationships\nFrom Protocol\nCollection\nConforms To\nComparable"
    },
    {
        "title": "suffix(from:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200704-suffix",
        "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection\u2019s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection\u2019s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity: O(1)"
    },
    {
        "title": "NWBrowser.Result.Change.identical",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/identical",
        "html": "See Also\nInspecting Change Types\ncase added(NWBrowser.Result)\nA new result was discovered.\ncase removed(NWBrowser.Result)\nA previously discovered result was removed.\ncase changed(old: NWBrowser.Result, new: NWBrowser.Result, flags: NWBrowser.Result.Change.Flags)\nA result changed properties but was not removed.\nstruct NWBrowser.Result.Change.Flags\nFlags providing details about a change in a discovered service."
    },
    {
        "title": "NWBrowser.Result.Change.removed(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/removed",
        "html": "See Also\nInspecting Change Types\ncase identical\nNo change was detected for the result.\ncase added(NWBrowser.Result)\nA new result was discovered.\ncase changed(old: NWBrowser.Result, new: NWBrowser.Result, flags: NWBrowser.Result.Change.Flags)\nA result changed properties but was not removed.\nstruct NWBrowser.Result.Change.Flags\nFlags providing details about a change in a discovered service."
    },
    {
        "title": "suffix(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200702-suffix",
        "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.policyViolation",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/policyviolation",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.invalidFramePayloadData",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/invalidframepayloaddata",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "nw_proxy_config_t",
        "url": "https://developer.apple.com/documentation/network/nw_proxy_config_t",
        "html": "Topics\nCreating Proxy Configurations\nfunc nw_proxy_config_create_relay(nw_relay_hop_t, nw_relay_hop_t?) -> nw_proxy_config_t\nInitializes a proxy configuration with one or two relay hops.\ntypealias nw_relay_hop_t\nA single relay server you can chain together with other servers.\nfunc nw_proxy_config_create_oblivious_http(nw_relay_hop_t, UnsafePointer<CChar>, UnsafePointer<UInt8>, Int) -> nw_proxy_config_t\nInitializes an Oblivious HTTP proxy configuration using a relay and a gateway.\nfunc nw_proxy_config_create_http_connect(nw_endpoint_t, nw_protocol_options_t?) -> nw_proxy_config_t\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1.\nfunc nw_proxy_config_create_socksv5(nw_endpoint_t) -> nw_proxy_config_t\nInitializes a SOCKSv5 proxy configuration.\nCustomizing Proxy Behavior\nfunc nw_proxy_config_set_failover_allowed(nw_proxy_config_t, Bool)\nConfigures whether or not a proxy configuration allows failover to non-proxied connections. Failover isn\u2019t allowed by default.\nfunc nw_proxy_config_set_username_and_password(nw_proxy_config_t, UnsafePointer<CChar>, UnsafePointer<CChar>?)\nSets a username and password to use as authentication for a proxy configuration.\nInspecting Proxies\nfunc nw_proxy_config_get_failover_allowed(nw_proxy_config_t) -> Bool\nChecks if a proxy configuration allows failover to non-proxied connections.\nSee Also\nConfiguring Proxies\nfunc nw_privacy_context_add_proxy(nw_privacy_context_t, nw_proxy_config_t)\nApplies a proxy configuration to all connections associated with this context.\nfunc nw_privacy_context_clear_proxies(nw_privacy_context_t)\nClears out any proxies added using nw_privacy_context_add_proxy(_:_:)"
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.noStatusReceived",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/nostatusreceived",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.goingAway",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/goingaway",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.protocolError",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/protocolerror",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.unsupportedData",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/unsupporteddata",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined.abnormalClosure",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined/abnormalclosure",
        "html": "See Also\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed."
    },
    {
        "title": "nw_retain",
        "url": "https://developer.apple.com/documentation/network/2976820-nw_retain",
        "html": "See Also\nMemory Management\nnw_release\nReleases a reference count on a Network.framework object.\nnw_object_t\nThe generic type for objects in the Network framework.\nRelated Documentation\nos_retain"
    },
    {
        "title": "nw_privacy_context_clear_proxies(_:)",
        "url": "https://developer.apple.com/documentation/network/4155634-nw_privacy_context_clear_proxies",
        "html": "Parameters\nprivacy_context\n\nA privacy context to modify. This can include the default privacy context.\n\nSee Also\nConfiguring Proxies\nfunc nw_privacy_context_add_proxy(nw_privacy_context_t, nw_proxy_config_t)\nApplies a proxy configuration to all connections associated with this context.\ntypealias nw_proxy_config_t\nA proxy configuration for Relays, Oblivious HTTP, HTTP CONNECT, or SOCKSv5."
    },
    {
        "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200687-split",
        "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection\u2019s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity: O(n), where n is the length of the collection."
    },
    {
        "title": "starts(with:by:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200692-starts",
        "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of possiblePrefix.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)"
    },
    {
        "title": "reversed()",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200677-reversed",
        "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "NWTXTRecord.Element",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/element",
        "html": "Relationships\nFrom Protocol\nCollection\nSequence\nSee Also\nExamining TXT Records\nfunc getEntry(for: String) -> NWTXTRecord.Entry?\nAccesses an entry in a TXT record dictionary.\nsubscript(String) -> String?\nGet and set values in a TXT record dictionary, by keys.\nvar dictionary: [String : String]\nThe TXT record as a dictionary of strings.\nsubscript(NWTXTRecord.Index) -> NWTXTRecord.Element\nGet and set values in a TXT record dictionary, by index."
    },
    {
        "title": "setEntry(_:for:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200678-setentry",
        "html": "See Also\nCreating TXT Records\ninit([String : String])\nInitializes a TXT record with a dictionary of strings.\nfunc removeEntry(key: String) -> Bool\nRemoves an entry from a TXT record dictionary.\nenum NWTXTRecord.Entry\nA type of entry in a TXT record dictionary."
    },
    {
        "title": "NWTXTRecord.Entry",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/entry",
        "html": "Topics\nEntry Types\ncase none\nThe key is not mapped to any value.\ncase empty\nThe key is mapped to an empty value.\ncase string(String)\nThe key is mapped to a string.\nEnumeration Cases\ncase data(Data)\nInitializers\ninit(Data?)\nInstance Properties\nvar data: Data?\nvar debugDescription: String\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWTXTRecord.Entry, NWTXTRecord.Entry) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWTXTRecord.Entry, NWTXTRecord.Entry) -> Bool\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSendable\nSee Also\nCreating TXT Records\ninit([String : String])\nInitializes a TXT record with a dictionary of strings.\nfunc removeEntry(key: String) -> Bool\nRemoves an entry from a TXT record dictionary.\nfunc setEntry(NWTXTRecord.Entry, for: String) -> Bool\nSets an entry in a TXT record dictionary."
    },
    {
        "title": "nw_privacy_context_flush_cache(_:)",
        "url": "https://developer.apple.com/documentation/network/3548041-nw_privacy_context_flush_cache",
        "html": "Discussion\n\nFlushing the cache may be asynchronous, which means that it will take effect shortly after you invoke the function.\n\nSee Also\nConfiguring Custom Privacy Settings\nfunc nw_privacy_context_create(UnsafePointer<CChar>) -> nw_privacy_context_t\nInitializes a privacy context with a description string.\nfunc nw_privacy_context_disable_logging(nw_privacy_context_t)\nDisables system logging of connection activity."
    },
    {
        "title": "nw_privacy_context_disable_logging(_:)",
        "url": "https://developer.apple.com/documentation/network/3548040-nw_privacy_context_disable_loggi",
        "html": "See Also\nConfiguring Custom Privacy Settings\nfunc nw_privacy_context_create(UnsafePointer<CChar>) -> nw_privacy_context_t\nInitializes a privacy context with a description string.\nfunc nw_privacy_context_flush_cache(nw_privacy_context_t)\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context."
    },
    {
        "title": "TLS Options",
        "url": "https://developer.apple.com/documentation/network/tls_options",
        "html": "Topics\nCreating TLS Connections\nnw_protocol_copy_tls_definition\nAccesses the system definition of the Transport Layer Security protocol.\nnw_tls_create_options\nInitializes a default set of TLS connection options.\nnw_tls_copy_sec_protocol_options\nAccesses the handshake security options TLS will use.\nInspecting TLS State\nnw_protocol_metadata_is_tls\nChecks whether a metadata object contains TLS connection state.\nnw_tls_copy_sec_protocol_metadata\nAccesses the result of the TLS handshake.\nSee Also\nNetwork Protocols\nTCP Options\nConfigure options for connections that use the Transmission Control Protocol.\nQUIC Options\nConfigure options for connections that use the QUIC transport protocol.\nUDP Options\nConfigure options for connections that use the User Datagram Protocol.\nIP Options\nConfigure Internet Protocol options on connections.\nWebSocket Options\nConfigure options for connections that use WebSocket.\nFramer Protocol Options\nCreate custom protocols to frame applications messages over a connection."
    },
    {
        "title": "reduce(into:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200674-reduce",
        "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value\u2014[:] in this case\u2014and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "index(_:offsetBy:limitedBy:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200640-index",
        "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string\u2019s starting index and then prints the character at that position. The operation doesn\u2019t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
    },
    {
        "title": "index(after:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200643-index",
        "html": "Relationships\nFrom Protocol\nCollection"
    },
    {
        "title": "formIndex(_:offsetBy:limitedBy:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200635-formindex",
        "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
    },
    {
        "title": "index(_:offsetBy:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200638-index",
        "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string\u2019s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
    },
    {
        "title": "formIndex(after:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200636-formindex",
        "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
    },
    {
        "title": "reason",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/applicationerror/3802948-reason",
        "html": "See Also\nInspecting Application Errors\nlet code: UInt64\nThe QUIC application error code.\ntypealias NWProtocolQUIC.ApplicationError.IntegerLiteralType\nThe QUIC application error code as an integer literal."
    },
    {
        "title": "code",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/applicationerror/3802945-code",
        "html": "See Also\nInspecting Application Errors\nlet reason: String?\nThe QUIC application error reason.\ntypealias NWProtocolQUIC.ApplicationError.IntegerLiteralType\nThe QUIC application error code as an integer literal."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/cellular/newradio5gvariant/3856615",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "init(between:_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/3200376-init",
        "html": "See Also\nCalculating Result Changes\nfunc hash(into: inout Hasher)\nstatic func == (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool\nstatic func != (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/3200374-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nCalculating Result Changes\ninit(between: NWBrowser.Result?, NWBrowser.Result?)\nInitializes a change between two results.\nstatic func == (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool\nstatic func != (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/3200324",
        "html": "See Also\nCalculating Result Changes\ninit(between: NWBrowser.Result?, NWBrowser.Result?)\nInitializes a change between two results.\nfunc hash(into: inout Hasher)\nstatic func != (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200570",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "withContiguousStorageIfAvailable(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200709-withcontiguousstorageifavailable",
        "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence\u2019s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn\u2019t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection\u2019s contiguous storage. If the contiguous storage doesn\u2019t exist, the collection creates it. If the collection doesn\u2019t support an internal representation in a form of contiguous storage, the method doesn\u2019t call body \u2014 it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don\u2019t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it\u2019s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence\u2019s startIndex and endIndex, respectively.\n\nNote\n\nThis documentation comment was inherited from Sequence."
    },
    {
        "title": "NWBrowser.Result.Change.added(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change/added",
        "html": "See Also\nInspecting Change Types\ncase identical\nNo change was detected for the result.\ncase removed(NWBrowser.Result)\nA previously discovered result was removed.\ncase changed(old: NWBrowser.Result, new: NWBrowser.Result, flags: NWBrowser.Result.Change.Flags)\nA result changed properties but was not removed.\nstruct NWBrowser.Result.Change.Flags\nFlags providing details about a change in a discovered service."
    },
    {
        "title": "formIndex(_:offsetBy:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200634-formindex",
        "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
    },
    {
        "title": "firstIndex(where:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200627-firstindex",
        "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn\u2019t conform to the Equatable protocol or to find an element that matches particular criteria. Here\u2019s an example that finds a student name that begins with the letter \u201cA\u201d:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity: O(n), where n is the length of the collection."
    },
    {
        "title": "flatMap(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200629-flatmap",
        "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity: O(m + n), where n is the length of this sequence and m is the length of the result."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/3129509-hashvalue",
        "html": "See Also\nComparison Functions\nstatic func != (IPv6Address.Scope, IPv6Address.Scope) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "count",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200606-count",
        "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
    },
    {
        "title": "forEach(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200632-foreach",
        "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won\u2019t skip subsequent calls."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/2998509",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparison Functions\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "first(where:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200625-first",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "elementsEqual(_:by:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200615-elementsequal",
        "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)"
    },
    {
        "title": "filter(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200621-filter",
        "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "enumerated()",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200617-enumerated",
        "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string \u201cSwift\u201d and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicol\u00e1s\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity: O(1)"
    },
    {
        "title": "contains(where:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200603-contains",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn\u2019t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "drop(while:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200610-drop",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection."
    },
    {
        "title": "dropLast(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200613-droplast",
        "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off the specified number of elements at the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
    },
    {
        "title": "allSatisfy(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200599-allsatisfy",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicol\u00e1s\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "dropFirst(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200611-dropfirst",
        "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
    },
    {
        "title": "distance(from:to:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200609-distance",
        "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
    },
    {
        "title": "underestimatedCount",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200708-underestimatedcount",
        "html": "Discussion\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
    },
    {
        "title": "compactMap(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200601-compactmap",
        "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity: O(n), where n is the length of this sequence."
    },
    {
        "title": "sorted(by:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200683-sorted",
        "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence\u2019s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don\u2019t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity: O(n log n), where n is the length of the sequence."
    },
    {
        "title": "shuffled(using:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200681-shuffled",
        "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence\u2019s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you\u2019re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
    },
    {
        "title": "dictionary",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200608-dictionary",
        "html": "See Also\nExamining TXT Records\nfunc getEntry(for: String) -> NWTXTRecord.Entry?\nAccesses an entry in a TXT record dictionary.\nsubscript(String) -> String?\nGet and set values in a TXT record dictionary, by keys.\nsubscript(NWTXTRecord.Index) -> NWTXTRecord.Element\nGet and set values in a TXT record dictionary, by index.\ntypealias NWTXTRecord.Element\nA container for a TXT record key and entry value."
    },
    {
        "title": "subscript(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200694-subscript",
        "html": "See Also\nExamining TXT Records\nfunc getEntry(for: String) -> NWTXTRecord.Entry?\nAccesses an entry in a TXT record dictionary.\nvar dictionary: [String : String]\nThe TXT record as a dictionary of strings.\nsubscript(NWTXTRecord.Index) -> NWTXTRecord.Element\nGet and set values in a TXT record dictionary, by index.\ntypealias NWTXTRecord.Element\nA container for a TXT record key and entry value."
    },
    {
        "title": "subscript(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200693-subscript",
        "html": "Relationships\nFrom Protocol\nCollection\nSee Also\nExamining TXT Records\nfunc getEntry(for: String) -> NWTXTRecord.Entry?\nAccesses an entry in a TXT record dictionary.\nsubscript(String) -> String?\nGet and set values in a TXT record dictionary, by keys.\nvar dictionary: [String : String]\nThe TXT record as a dictionary of strings.\ntypealias NWTXTRecord.Element\nA container for a TXT record key and entry value."
    },
    {
        "title": "prefix(through:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200660-prefix",
        "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection\u2019s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity: O(1)"
    },
    {
        "title": "reduce(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200672-reduce",
        "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult\u20140 in this case\u2014and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call\u2019s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity: O(n), where n is the length of the sequence."
    },
    {
        "title": "NWProtocolWebSocket.Opcode.cont",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/cont",
        "html": "Discussion\n\nContinuations are handled automatically, and should not be manually sent."
    },
    {
        "title": "NWConnection.EstablishmentReport.Resolution.DNSProtocol.tls",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/tls",
        "html": "See Also\nResolution Transports\ncase unknown\nThe DNS response protocol is unknown or not applicable.\ncase udp\nThe connection used cleartext UDP for DNS resolution.\ncase tcp\nThe connection used cleartext TCP for DNS resolution.\ncase https\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/3548831",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Transports\nstatic func == (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nvar hashValue: Int\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "NWConnection.EstablishmentReport.Resolution.DNSProtocol.udp",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/udp",
        "html": "See Also\nResolution Transports\ncase unknown\nThe DNS response protocol is unknown or not applicable.\ncase tcp\nThe connection used cleartext TCP for DNS resolution.\ncase tls\nThe connection used TLS for DNS resolution.\ncase https\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200607-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
    },
    {
        "title": "endIndex",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200616-endindex",
        "html": "Relationships\nFrom Protocol\nCollection"
    },
    {
        "title": "NWConnection.EstablishmentReport.Resolution.DNSProtocol.unknown",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/unknown",
        "html": "See Also\nResolution Transports\ncase udp\nThe connection used cleartext UDP for DNS resolution.\ncase tcp\nThe connection used cleartext TCP for DNS resolution.\ncase tls\nThe connection used TLS for DNS resolution.\ncase https\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "securityProtocolMetadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltls/metadata/2998792-securityprotocolmetadata",
        "html": "See Also\nRelated Documentation\nSecurity Options\nConfigure security options for TLS handshakes."
    },
    {
        "title": "nw_parameters_get_required_interface_type(_:)",
        "url": "https://developer.apple.com/documentation/network/2976846-nw_parameters_get_required_inter",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_protocol_stack_t",
        "url": "https://developer.apple.com/documentation/network/nw_protocol_stack_t",
        "html": "Topics\nModifying Application Protocols\nfunc nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t, nw_protocol_options_t)\nAdds a protocol onto the top of the protocol stack.\nfunc nw_protocol_stack_clear_application_protocols(nw_protocol_stack_t)\nRemoves all application protocols from the protocol stack.\nfunc nw_protocol_stack_iterate_application_protocols(nw_protocol_stack_t, (nw_protocol_options_t) -> Void)\nIterates through the array of application protocol options that will be used by connections and listeners.\ntypealias nw_protocol_stack_iterate_protocols_block_t\nA block that allows you to inspect or modify a single protocol's options.\nConfiguring Lower Protocols\nfunc nw_protocol_stack_copy_transport_protocol(nw_protocol_stack_t) -> nw_protocol_options_t?\nAccesses the options for the protocol stack's transport protocol.\nfunc nw_protocol_stack_set_transport_protocol(nw_protocol_stack_t, nw_protocol_options_t)\nReplaces the protocol stack's transport protocol with a new set of options.\nfunc nw_protocol_stack_copy_internet_protocol(nw_protocol_stack_t) -> nw_protocol_options_t?\nAccesses the protocol stack's Internet Protocol options.\nSee Also\nModifying Protocol Stacks\nfunc nw_parameters_copy_default_protocol_stack(nw_parameters_t) -> nw_protocol_stack_t\nAccesses the protocol stack used by connections and listeners.\ntypealias nw_protocol_definition_t\nThe abstract superclass for identifying a network protocol.\ntypealias nw_protocol_options_t\nThe abstract superclass for configuring the options of a network protocol."
    },
    {
        "title": "startIndex",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200691-startindex",
        "html": "Relationships\nFrom Protocol\nCollection"
    },
    {
        "title": "removeEntry(key:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200676-removeentry",
        "html": "See Also\nCreating TXT Records\ninit([String : String])\nInitializes a TXT record with a dictionary of strings.\nfunc setEntry(NWTXTRecord.Entry, for: String) -> Bool\nSets an entry in a TXT record dictionary.\nenum NWTXTRecord.Entry\nA type of entry in a TXT record dictionary."
    },
    {
        "title": "getEntry(for:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200637-getentry",
        "html": "See Also\nExamining TXT Records\nsubscript(String) -> String?\nGet and set values in a TXT record dictionary, by keys.\nvar dictionary: [String : String]\nThe TXT record as a dictionary of strings.\nsubscript(NWTXTRecord.Index) -> NWTXTRecord.Element\nGet and set values in a TXT record dictionary, by index.\ntypealias NWTXTRecord.Element\nA container for a TXT record key and entry value."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/3548833-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Transports\nstatic func != (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nvar hashValue: Int"
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200646-init",
        "html": "See Also\nCreating TXT Records\nfunc removeEntry(key: String) -> Bool\nRemoves an entry from a TXT record dictionary.\nfunc setEntry(NWTXTRecord.Entry, for: String) -> Bool\nSets an entry in a TXT record dictionary.\nenum NWTXTRecord.Entry\nA type of entry in a TXT record dictionary."
    },
    {
        "title": "ProxyConfiguration.RelayHop",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/relayhop",
        "html": "Overview\n\nRelay servers are secure HTTP proxies that allow proxying TCP traffic using the CONNECT method and UDP traffic using the connect-udp protocol defined in RFC 9298.\n\nTopics\nCreating Relay Hops\ninit(http3RelayEndpoint: NWEndpoint, http2RelayEndpoint: NWEndpoint?, tlsOptions: NWProtocolTLS.Options, additionalHTTPHeaderFields: [String : String])\nCreates a configuration for a secure relay accessible using HTTP/3, with an optional HTTP/2 fallback.\ninit(http2RelayEndpoint: NWEndpoint, tlsOptions: NWProtocolTLS.Options, additionalHTTPHeaderFields: [String : String])\nCreates a configuration for a secure relay accessible only using HTTP/2.\nInspecting Relay Hops\nvar debugDescription: String\nThe description of the relay hop.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nCreating Proxy Configurations\ninit(relayHops: [ProxyConfiguration.RelayHop])\nInitializes a proxy configuration with one or two relay hops.\ninit(httpCONNECTProxy: NWEndpoint, tlsOptions: NWProtocolTLS.Options?)\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1.\ninit(socksv5Proxy: NWEndpoint)\nInitializes a SOCKSv5 proxy configuration."
    },
    {
        "title": "IP Options",
        "url": "https://developer.apple.com/documentation/network/ip_options",
        "html": "Topics\nHandling IP Packets\nnw_ip_create_metadata\nInitializes an IP packet configuration with default settings.\nnw_protocol_metadata_is_ip\nChecks whether a metadata object represents an IP packet.\nnw_ip_metadata_set_ecn_flag\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nnw_ip_metadata_get_ecn_flag\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nnw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nnw_ip_metadata_set_service_class\nSets a specific service class to mark on an IP packet.\nnw_ip_metadata_get_service_class\nAccesses a specific service class to mark on an IP packet.\nnw_ip_metadata_get_receive_time\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW.\nConfiguring IP Connections\nnw_protocol_copy_ip_definition\nAccesses the system definition of the Internet Protocol.\nnw_ip_options_set_version\nSets a required IP version to disable all other versions for a connection.\nnw_ip_version_t\nIP versions to require on connections and listeners.\nnw_ip_options_set_calculate_receive_time\nConfigures a connection to deliver receive timestamps for IP packets.\nnw_ip_options_set_hop_limit\nConfigures the default hop limit for packets generated by a connection.\nnw_ip_options_set_use_minimum_mtu\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nnw_ip_options_set_disable_fragmentation\nConfigures a connection to disable fragmentation on outbound packets.\nnw_ip_options_set_local_address_preference\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nnw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nSee Also\nNetwork Protocols\nTCP Options\nConfigure options for connections that use the Transmission Control Protocol.\nTLS Options\nConfigure options for connections that use Transport Layer Security.\nQUIC Options\nConfigure options for connections that use the QUIC transport protocol.\nUDP Options\nConfigure options for connections that use the User Datagram Protocol.\nWebSocket Options\nConfigure options for connections that use WebSocket.\nFramer Protocol Options\nCreate custom protocols to frame applications messages over a connection."
    },
    {
        "title": "Implementing netcat with Network Framework",
        "url": "https://developer.apple.com/documentation/network/implementing_netcat_with_network_framework",
        "html": "Overview\n\nThe netcat tool (abbreviated nc on macOS) is a UNIX tool that lets you:\n\nEstablish outbound TCP and UDP connections.\n\nListen for inbound TCP and UDP connections.\n\nTransfer data between a network connection and stdin and stdout.\n\nThis sample code shows how you can build nwcat, which provides this functionality and also adds TLS and Bonjour support.\n\nThe nwcat tool supports two modes: one that makes an outbound connection and one that listens for an inbound connection. You select the mode using command-line arguments. To make an outbound connection to port 80 on example.com, you run:\n\n$ nwcat example.com 80\n\n\nTo listen for an inbound connection, you supply the -l option and the port number to listen on:\n\n$ nwcat -l 12345\n\n\nBy default, nwcat uses TCP. The -u argument switches to UDP, and the -t argument adds TLS to TCP connections and DTLS to UDP connections. The -b argument enables use of Bonjour service names rather than host names.\n\nCreate an Outbound Connection\n\nIn the Network framework, a bidirectional flow of data is represented as a connection object (nw_connection_t). If you\u2019re using TCP, there\u2019s a direct mapping between the connection object and the underlying TCP connection. If you\u2019re using UDP, a connection object represents a bidirectional flow of datagrams between a local port and a port on a specific remote peer.\n\nTo create an outbound connection object, you must supply a parameters object (nw_parameters_t) and an endpoint (nw_endpoint_type_t).\n\nCreate a Parameters Object. A parameters object, of type nw_parameters_t, holds all the parameters necessary to configure a network connection. These include:\n\nThe protocols involved, like TCP or UDP, or whether to enable TLS.\n\nAny options for those protocols.\n\nAny constraints on the connection, like whether or not to use the cellular interface.\n\nTo create a parameters object, call either the nw_parameters_create_secure_tcp or the nw_parameters_create_secure_udp convenience function, depending on whether you want to use TCP or UDP.\n\nnw_parameters_configure_protocol_block_t configure_tls = NW_PARAMETERS_DISABLE_PROTOCOL;\nif (g_use_udp) {\n    parameters = nw_parameters_create_secure_udp(\n        configure_tls,\n        NW_PARAMETERS_DEFAULT_CONFIGURATION\n    );\n} else {\n    parameters = nw_parameters_create_secure_tcp(\n        configure_tls,\n        NW_PARAMETERS_DEFAULT_CONFIGURATION\n    );\n}\n\n\nThese functions take two arguments:\n\nThe first configures the security protocol for the connection. Pass NW_PARAMETERS_DISABLE_PROTOCOL to use no security.\n\nThe second configures the transport protocol for the connection. Pass NW_PARAMETERS_DEFAULT_CONFIGURATION to get a default configuration.\n\nNote\n\nIf you\u2019re curious about enabling TLS or configuring protocol options, look at the create_outbound_connection function for examples of these more advanced features. For example, nwcat supports setting a TLS pre-shared key for both TLS listeners and clients.\n\nCreate an Endpoint. An endpoint, of type nw_endpoint_type_t, holds a network host or service name. For an outbound connection, the endpoint determines the remote host to which you want to connect. In most cases this consists of a host name and a port number, but there are other options. For example, you can also create endpoints that target a Bonjour service.\n\nIn the nwcat tool, the user supplies a host name and a port number via command-line arguments, and you will need to create an endpoint from those two strings. You do this by calling nw_endpoint_create_host.\n\nnw_endpoint_t endpoint = nw_endpoint_create_host(name, port);\n\n\nThese strings support both symbolic and numeric values:\n\nThe host name can be a DNS name, like example.com, or the string representation of an IP address, like \"203.0.113.7\" for IPv4 or \"2606:2800:220:1:248:1893:25c8:1946\" for IPv6.\n\nThe port can be a numeric value, like \"80\", or a service name, like \"https\".\n\nImportant\n\nIf you pass in a DNS name, the connection object takes care of DNS resolution for you, handling the complex issue of deciding what IP address to connect to. For outbound connections there\u2019s no need to do your own DNS resolution, and in most cases doing so will result in a worse user experience.\n\nCreate the Connection Object. Once you have your parameters object and endpoint, you can create a connection object by calling nw_connection_create.\n\nnw_connection_t connection = nw_connection_create(endpoint, parameters);\n\n\nStart the Connection. To start the connection establishment process:\n\nCall nw_connection_set_queue to set the dispatch_queue_t on which all callbacks will be scheduled. For a simple application like nwcat, you can use the main queue for your callbacks. A more complex application would typically use a custom serial queue instead.\n\nInstall any update handler blocks. The most important of these is the state changed handler, discussed below.\n\nStart the connection by calling nw_connection_start.\n\nYou must set your queue before starting the connection, and you cannot change the queue after that.\n\nvoid\nstart_connection(nw_connection_t connection)\n{\n    nw_connection_set_queue(connection, dispatch_get_main_queue());\n    nw_retain(connection);\n    nw_connection_set_state_changed_handler(connection, ^(nw_connection_state_t state, nw_error_t error) {\n        \u2026 your state changed handler \u2026\n    });\n    nw_connection_start(connection);\n}\n\n\nImportant\n\nThe connection object closes the underlying network connection when its last reference is released. Thus, you must retain the connection object, by calling nw_retain, until you\u2019re done with the connection.\n\nA state changed handler is a block that\u2019s called by the connection object whenever the connection state changes. For a simple application, like nwcat, you can use a very simple state changed handler.\n\nif (state == nw_connection_state_waiting) {\n    \u2026 tell the user that a connection couldn\u2019t be opened but will retry when conditions are favourable \u2026\n} else if (state == nw_connection_state_failed) {\n    \u2026 tell the user that the connection has failed irrecoverably \u2026\n} else if (state == nw_connection_state_ready) {\n    \u2026 tell the user that you are connected \u2026\n} else if (state == nw_connection_state_cancelled) {\n    nw_release(connection);\n}\n\n\nMake sure you handle the nw_connection_state_cancelled state. Once the connection is no longer needed, you have to release the reference you took when you started the connection.\n\nListen for an Inbound Connection\n\nA listener object, of type nw_listener_t, listens for inbound connections and creates a new connection object for each one. To create a listener object you must supply a parameters object (nw_parameters_t) to indicate what protocols to use and information about the local endpoint on which you want to listen.\n\nCreate a Parameters Object. Creating a parameters object for a listener object is very similar to creating a parameters object for an outbound connection. Use the nw_parameters_create_secure_tcp and nw_parameters_create_secure_udp convenience functions to define which protocols you want your listener to use. These parameters will be applied to any inbound connections your listener accepts. For example, if you enable TLS in the parameters object, all inbound connections will negotiate TLS once you call nw_connection_start.\n\nSet a Local Endpoint. A listener object must know what local endpoint to listen on, that is, the endpoint to which clients must connect. The local endpoint can include a port number and an interface address, both of which are optional. If you don\u2019t specify a port number, the system chooses a port for you. If you don\u2019t specify an interface address, the system listens on all interfaces and addresses.\n\nMost applications don\u2019t need to listen on a specific interface address and thus can create a listener using the nw_listener_create_with_port convenience function. However, nwcat allows the user to specify an interface address (via a command line argument) and thus you have to use a slightly more complex technique. If the user has specified an interface address or a port, you can call nw_endpoint_create_host to create an endpoint representing the address to listen on, and then call nw_parameters_set_local_endpoint to apply that to your parameters object.\n\nif (address || port) {\n    nw_endpoint_t local_endpoint = nw_endpoint_create_host(address ? address : \"::\", port ? port : \"0\");\n    nw_parameters_set_local_endpoint(parameters, local_endpoint);\n    nw_release(local_endpoint);\n}\n\n\nWhen calling nw_endpoint_create_host to create an endpoint for the local address, keep the following in mind:\n\nThe port parameter can either be a numeric string, like \"443\", or a service name, like \"https\".\n\nIf you pass \"0\" to the port parameter the system will choose a port on your behalf.\n\nCreate the Listener Object. Once you\u2019ve set up your parameters object, you can create a listener object by calling nw_listener_create.\n\nnw_listener_t listener = nw_listener_create(parameters);\n\n\nStart the Listener. Starting a listener object is much like starting a connection object, with one significant difference: in addition to setting a state changed handler, you must also set a new connection handler, which is called whenever the listener object receives a new inbound connection.\n\nnw_listener_set_queue(listener, dispatch_get_main_queue());\nnw_retain(listener);\nnw_listener_set_state_changed_handler(listener, ^(nw_listener_state_t state, nw_error_t error) {\n    \u2026 your state changed handler \u2026\n});\nnw_listener_set_new_connection_handler(listener, ^(nw_connection_t connection) {\n    \u2026 your new connection handler \u2026\n});\nnw_listener_start(listener);\n\n\nAccept or Reject Inbound Connections. Your new connection handler is responsible for either starting the network connection or rejecting it. The nwcat command can only handle one connection at a time, so if there\u2019s already a network connection in place, call nw_connection_cancel to reject the new connection. If not, retain the network connection and then run the connection using the same start_connection function you used in the outbound case.\n\nif (g_inbound_connection != NULL) {\n    nw_connection_cancel(connection);\n} else {\n    g_inbound_connection = connection;\n    nw_retain(g_inbound_connection);\n\n\n    start_connection(g_inbound_connection);\n}\n\nTransfer Data\n\nOnce you have created and started a connection, either outbound or inbound, you\u2019ll need code to transfer data on that connection. Each connection has two directions:\n\nInbound data is received from the network connection and written to stdout.\n\nOutbound data is read from stdin and sent to the network connection.\n\nBoth directions are asynchronous. When receiving data from the network, you supply a completion handler that\u2019s called when data is available. Similarly, when writing data to the network, you supply a completion handler that\u2019s called when the data has been accepted for transmission.\n\nWhen working with asynchronous networking, you need to consider flow control. For example, if you receive data from the network faster than you can write it to stdout, you\u2019ll waste a lot of memory buffering that data. You\u2019ll have similar problems if you read data from stdin faster than you can send it over the network. You can solve this problem by using asynchronous routines for reading from stdin and writing to stdout. The basic strategy is this:\n\nStart an asynchronous read.\n\nWhen the read completes, start an asynchronous write.\n\nWhen the write completes, set up the next asynchronous read, which starts again at step 1.\n\nYou use a similar strategy for both inbound and outbound data, but there are some subtle differences, discussed in the sections that follow.\n\nReceive Data. You can receive data with code like this.\n\nvoid\nreceive_loop(nw_connection_t connection)\n{\n    nw_connection_receive(connection, 1, UINT32_MAX, ^(dispatch_data_t content, nw_content_context_t context, bool is_complete, nw_error_t receive_error) {\n\n\n        nw_retain(context);\n        dispatch_block_t schedule_next_receive = ^{\n            \u2026 discussed below \u2026\n            nw_release(context);\n        };\n\n\n        if (content != NULL) {\n            schedule_next_receive = Block_copy(schedule_next_receive);\n            dispatch_write(STDOUT_FILENO, content, dispatch_get_main_queue(), ^(__unused dispatch_data_t _Nullable data, int stdout_error) {\n                if (stdout_error != 0) {\n                    \u2026 error logging \u2026\n                } else {\n                    schedule_next_receive();\n                }\n                Block_release(schedule_next_receive);\n            });\n        } else {\n            // No content, so directly schedule the next receive\n            schedule_next_receive();\n        }\n    });\n}\n\n\nNote\n\nWhile this function is called receive_loop, it\u2019s not actually a loop. Rather, it\u2019s the asynchronous equivalent of a loop, bouncing between an asynchronous receive from the network and an asynchronous write to stdout.\n\nThe function starts by calling nw_connection_receive, which is an asynchronous function that receives data from the connection object. nw_connection_receive takes two parameters that control the minimum and maximum amount of data to be received. The exact amount of data received isn\u2019t relevant here, so pass 1 and UINT32_MAX respectively.\n\nNote\n\nThe minimum and maximum receive parameters are useful when you\u2019re implementing a record-oriented protocol. Many network protocols transfer records over a TCP stream by sending a record length followed by the record. If you\u2019re working with such a protocol, you can perform an initial receive for the length field and then, once you know the length of the record, do a second receive for the full record body.\n\nWhen the receive is complete, nw_connection_receive calls the completion handler that you pass it. The completion handler has four parameters:\n\nA dispatch_data_t which, if not NULL, contains the data received.\n\nA content context, discussed below.\n\nAn is_complete parameter that is true if the data received is the last part of a logical unit of data.\n\nA receive_error parameter, which is not NULL if an error occurred during the receive process.\n\nA content context, of type nw_content_context_t, holds extra information about the data received. A typical application that uses only TCP can often ignore this value entirely. However, a netcat implementation must work equally well with TCP and UDP, and you need the content context to do that.\n\nThe completion handler you pass to nw_connection_receive does the following:\n\nIt processes any data that was received by starting an asynchronous write to stdout.\n\nWhen that asynchronous write completes\u2014or immediately if there was no content\u2014it calls schedule_next_receive to continue the receive.\n\nIn schedule_next_receive you must handle three cases:\n\nIf you just received the end of the data stream, call exit to terminate the program. This is how the program stops when the remote peer closes the network connection.\n\nIf the receive failed with an error, handle that error.\n\nOtherwise, start the next asynchronous receive by calling receive_loop.\n\nnw_retain(context);\ndispatch_block_t schedule_next_receive = ^{\n    if (is_complete &&\n        (context == NULL || nw_content_context_get_is_final(context))) {\n        exit(0);\n    }\n    if (receive_error == NULL) {\n        receive_loop(connection);\n    } else {\n        \u2026 error logging \u2026\n    }\n    nw_release(context);\n};\n\n\nImportant\n\nYou must process any received data before checking for the other states (end of data stream or error) because it\u2019s possible for your completion handler to be called with both data and one of the other states.\n\nTo check for the end of the data stream:\n\nGenerally, you can use the technique shown by schedule_next_receive, that is, check both the is_complete flag and that the context is marked as final or is not present. This technique works correctly for both TCP and UDP, and thus is necessary for a netcat implementation.\n\nIf you only handle TCP, you can simply test the is_complete flag.\n\nSend Data. Your send code should have the same basic structure as your receive code.\n\nvoid\nsend_loop(nw_connection_t connection)\n{\n    dispatch_read(STDIN_FILENO, 8192, dispatch_get_main_queue(), ^(dispatch_data_t _Nonnull read_data, int stdin_error) {\n        if (stdin_error != 0) {\n            \u2026 error logging \u2026\n        } else if (read_data == NULL) {\n            \u2026 handle end of file \u2026\n        } else {\n            nw_connection_send(connection, read_data, NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT, true, ^(nw_error_t  _Nullable error) {\n                if (error != NULL) {\n                    \u2026 error logging \u2026\n                } else {\n                    send_loop(connection);\n                }\n            });\n        }\n    });\n}\n\n\nThere are, however, some subtle differences:\n\nIf, as in this case, you support UDP, you must limit the amount of data you read from stdin. If you read more than 64 Kibibytes (KiB), the resulting read won\u2019t fit in a single UDP datagram. This code use a 8 KiB limit.\n\nYou must tell the network connection to send the data as a single message by calling nw_connection_send with NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT and passing true to the is_complete parameter. This approach is appropriate for both TCP and UDP connections. For TCP connections, message boundaries don\u2019t affect how the protocol sends data, but the boundaries are required for sending UDP datagrams.\n\nFinally, when you receive an end of file from stdin, you must close the send side of your connection. The code for this is shown below.\n\nnw_connection_send(connection, NULL, NW_CONNECTION_FINAL_MESSAGE_CONTEXT, true, ^(nw_error_t  _Nullable error) {\n    if (error != NULL) {\n        \u2026 handle error \u2026\n    }\n    // Stop reading from stdin, so don't schedule another send_loop\n});\n\n\nThis passes a special context, NW_CONNECTION_FINAL_MESSAGE_CONTEXT, and passes true to the is_complete. Together, these actions indicate that no more data will be sent, allowing the network connection to close the sending side of the connection.\n\nSee Also\nConnections and Listeners\nnw_connection_t\nA bidirectional data connection between a local endpoint and a remote endpoint.\nnw_listener_t\nAn object you use to listen for incoming network connections.\nnw_browser_t\nAn object you use to browse for available network services.\nnw_connection_group_t\nAn object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.\nnw_ethernet_channel_t\nAn object you use to send and receive custom Ethernet frames."
    },
    {
        "title": "TCP Options",
        "url": "https://developer.apple.com/documentation/network/tcp_options",
        "html": "Topics\nCreating TCP Connections\nnw_protocol_copy_tcp_definition\nAccesses the system definition of the Transport Control Protocol.\nnw_tcp_create_options\nInitializes a default set of TCP connection options.\nCustomizing TCP Options\nnw_tcp_options_set_enable_fast_open\nEnables TCP Fast Open on a connection.\nnw_tcp_options_set_maximum_segment_size\nSets TCP's maximum segment size in bytes.\nnw_tcp_options_set_no_delay\nDisables Nagle's algorithm for TCP.\nnw_tcp_options_set_no_options\nSets TCP into no-options mode.\nnw_tcp_options_set_no_push\nSets TCP into no-push mode.\nnw_tcp_options_set_retransmit_fin_drop\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nnw_tcp_options_set_disable_ack_stretching\nDisables TCP acknowledgment stretching.\nnw_tcp_options_set_disable_ecn\nDisables negotiation of Explicit Congestion Notification markings.\nConfiguring Keepalives\nnw_tcp_options_set_enable_keepalive\nEnables TCP keepalives.\nnw_tcp_options_set_keepalive_idle_time\nSets the number of seconds of idleness that TCP waits before sending keepalive probes.\nnw_tcp_options_set_keepalive_count\nSets the number of keepalive probes that TCP sends before terminating the connection.\nnw_tcp_options_set_keepalive_interval\nSets the number of seconds that TCP waits between sending keepalive probes.\nSetting Timeouts\nnw_tcp_options_set_connection_timeout\nSets the number of seconds that TCP waits before timing out its handshake.\nnw_tcp_options_set_retransmit_connection_drop_time\nSets the number of seconds that TCP waits between retransmission attempts.\nnw_tcp_options_set_persist_timeout\nSets the TCP persist timeout in seconds, as defined by RFC 6429.\nInspecting TCP State\nnw_protocol_metadata_is_tcp\nChecks whether a metadata object contains TCP connection state.\nnw_tcp_get_available_send_buffer\nAccesses the number of available bytes in the TCP send buffer.\nnw_tcp_get_available_receive_buffer\nAccesses the number of available bytes in the TCP receive buffer.\nSee Also\nNetwork Protocols\nTLS Options\nConfigure options for connections that use Transport Layer Security.\nQUIC Options\nConfigure options for connections that use the QUIC transport protocol.\nUDP Options\nConfigure options for connections that use the User Datagram Protocol.\nIP Options\nConfigure Internet Protocol options on connections.\nWebSocket Options\nConfigure options for connections that use WebSocket.\nFramer Protocol Options\nCreate custom protocols to frame applications messages over a connection."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.Defined",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/defined",
        "html": "Topics\nDefined Close Codes\ncase normalClosure\nA normal closure occurred with no errors.\ncase goingAway\nAn endpoint is no longer available, such as when a server is down.\ncase protocolError\nAn endpoint is terminating the connection due to a protocol error.\ncase unsupportedData\nAn endpoint is terminating the connection because it received a type of data it cannot accept.\ncase noStatusReceived\nThis value is reserved for local errors and indicates that no Close code was received.\ncase abnormalClosure\nThis value is reserved for local errors and indicates that no Close message was received.\ncase invalidFramePayloadData\nAn endpoint is terminating the connection because it received data within a message that was inconsistent with the message type.\ncase policyViolation\nAn endpoint is terminating the connection because it received a message that violates its policy.\ncase messageTooBig\nAn endpoint is terminating the connection because it received a message that is too big for it to process.\ncase mandatoryExtension\nThe WebSocket client expected the server to negotiate one or more extensions that were not negotiated.\ncase internalServerError\nThe server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\ncase tlsHandshake\nThis value is reserved for local errors and indicates that the TLS handshake failed.\nClose Codes Comparison Functions\nstatic func != (NWProtocolWebSocket.CloseCode.Defined, NWProtocolWebSocket.CloseCode.Defined) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int\nType Aliases\ntypealias NWProtocolWebSocket.CloseCode.Defined.RawValue\nInitializers\ninit?(rawValue: UInt16)\nInstance Properties\nvar rawValue: UInt16\nRelationships\nConforms To\nSendable\nSee Also\nClose Code Types\ninit(rawValue: UInt16)\nInitializes a close code with a raw value.\ncase protocolCode(NWProtocolWebSocket.CloseCode.Defined)\nA well-known close code reserved by the protocol (values 1000-2999).\ncase applicationCode(UInt16)\nA close code in the range reserved for applications and frameworks (3000-3999).\ncase privateCode(UInt16)\nA close code in the private-use range (4000-4999)."
    },
    {
        "title": "UDP Options",
        "url": "https://developer.apple.com/documentation/network/udp_options",
        "html": "Topics\nCreating UDP Connections\nnw_protocol_copy_udp_definition\nAccesses the system definition of the User Datagram Protocol.\nnw_udp_create_options\nInitializes a default set of UDP connection options.\nCustomizing UDP Connections\nnw_udp_options_set_prefer_no_checksum\nConfigures the connection to not send UDP checksums.\nSending UDP Messages\nnw_protocol_metadata_is_udp\nChecks whether a metadata object represents a UDP datagram.\nnw_udp_create_metadata\nInitializes a default UDP message.\nSee Also\nNetwork Protocols\nTCP Options\nConfigure options for connections that use the Transmission Control Protocol.\nTLS Options\nConfigure options for connections that use Transport Layer Security.\nQUIC Options\nConfigure options for connections that use the QUIC transport protocol.\nIP Options\nConfigure Internet Protocol options on connections.\nWebSocket Options\nConfigure options for connections that use WebSocket.\nFramer Protocol Options\nCreate custom protocols to frame applications messages over a connection."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.protocolCode(_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/protocolcode",
        "html": "See Also\nClose Code Types\ninit(rawValue: UInt16)\nInitializes a close code with a raw value.\nenum NWProtocolWebSocket.CloseCode.Defined\nWell-known close code values.\ncase applicationCode(UInt16)\nA close code in the range reserved for applications and frameworks (3000-3999).\ncase privateCode(UInt16)\nA close code in the private-use range (4000-4999)."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.applicationCode(_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/applicationcode",
        "html": "See Also\nClose Code Types\ninit(rawValue: UInt16)\nInitializes a close code with a raw value.\ncase protocolCode(NWProtocolWebSocket.CloseCode.Defined)\nA well-known close code reserved by the protocol (values 1000-2999).\nenum NWProtocolWebSocket.CloseCode.Defined\nWell-known close code values.\ncase privateCode(UInt16)\nA close code in the private-use range (4000-4999)."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode.privateCode(_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/privatecode",
        "html": "See Also\nClose Code Types\ninit(rawValue: UInt16)\nInitializes a close code with a raw value.\ncase protocolCode(NWProtocolWebSocket.CloseCode.Defined)\nA well-known close code reserved by the protocol (values 1000-2999).\nenum NWProtocolWebSocket.CloseCode.Defined\nWell-known close code values.\ncase applicationCode(UInt16)\nA close code in the range reserved for applications and frameworks (3000-3999)."
    },
    {
        "title": "init(status:subprotocol:additionalHeaders:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/3200562-init",
        "html": "See Also\nSending Handshake Responses\nenum NWProtocolWebSocket.Response.Status\nStatus values that are sent with a WebSocket server response.\nlet status: NWProtocolWebSocket.Response.Status\nThe status of a WebSocket server response.\nlet subprotocol: String?\nThe selected subprotocol in a WebSocket server response.\nlet additionalHeaders: [(name: String, value: String)]?\nAny additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/3200510",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/3236861-rawvalue",
        "html": "Relationships\nFrom Protocol\nRawRepresentable"
    },
    {
        "title": "init(code:reason:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/applicationerror/3802946-init",
        "html": "Parameters\ncode\n\nThe error code.\n\nreason\n\nA string that describes the error.\n\nSee Also\nConfiguring Application Errors\ninit(integerLiteral: UInt64)\nInitializes a QUIC application error with an integer literal error code."
    },
    {
        "title": "NWProtocolQUIC.ApplicationError.IntegerLiteralType",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/applicationerror/integerliteraltype",
        "html": "See Also\nInspecting Application Errors\nlet code: UInt64\nThe QUIC application error code.\nlet reason: String?\nThe QUIC application error reason."
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/3236814-rawvalue",
        "html": "Relationships\nFrom Protocol\nRawRepresentable"
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/3236813-init",
        "html": "Relationships\nFrom Protocol\nRawRepresentable"
    },
    {
        "title": "receivedIPPacketCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200409-receivedippacketcount",
        "html": "See Also\nInspecting Packet Metrics\nlet sentIPPacketCount: UInt64\nThe number of IP packets the connection sent."
    },
    {
        "title": "transportSmoothedRTT",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200419-transportsmoothedrtt",
        "html": "See Also\nInspecting Transport Metrics\nlet receivedTransportByteCount: UInt64\nThe number of bytes the transport protocol delivered.\nlet receivedTransportDuplicateByteCount: UInt64\nThe number of duplicated bytes the transport protocol detected.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet sentTransportByteCount: UInt64\nThe number of bytes sent into the transport protocol.\nlet retransmittedTransportByteCount: UInt64\nThe number of bytes the transport protocol retransmitted.\nlet transportMinimumRTT: TimeInterval\nThe minimum round-trip time the transport protocol measured.\nlet transportRTTVariance: TimeInterval\nThe variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/resolverconfiguration/3548843-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
    },
    {
        "title": "endpointCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/3200436-endpointcount",
        "html": "See Also\nExamining Resolved Endpoints\nlet successfulEndpoint: NWEndpoint\nThe resolved endpoint that led to the established connection.\nlet preferredEndpoint: NWEndpoint\nThe resolved endpoint that the connection used for its first connection attempt."
    },
    {
        "title": "NWParameters.PrivacyContext.ResolverConfiguration.tls(_:serverAddresses:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/resolverconfiguration/tls_serveraddresses",
        "html": "Discussion\n\nThe hostname of the provided endpoint will be used to validate the TLS certificate of the server. See RFC 7858 for more details. The associated server addresses you provide are hints for which well-known DNS server addresses to use.\n\nSee Also\nResolver Types\ncase https(URL, serverAddresses: [NWEndpoint])\nA DNS-over-HTTPS resolver configuration."
    },
    {
        "title": "receivedTransportDuplicateByteCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200411-receivedtransportduplicatebyteco",
        "html": "See Also\nInspecting Transport Metrics\nlet receivedTransportByteCount: UInt64\nThe number of bytes the transport protocol delivered.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet sentTransportByteCount: UInt64\nThe number of bytes sent into the transport protocol.\nlet retransmittedTransportByteCount: UInt64\nThe number of bytes the transport protocol retransmitted.\nlet transportSmoothedRTT: TimeInterval\nThe smoothed round-trip time the transport protocol measured.\nlet transportMinimumRTT: TimeInterval\nThe minimum round-trip time the transport protocol measured.\nlet transportRTTVariance: TimeInterval\nThe variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "receivedTransportByteCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200410-receivedtransportbytecount",
        "html": "See Also\nInspecting Transport Metrics\nlet receivedTransportDuplicateByteCount: UInt64\nThe number of duplicated bytes the transport protocol detected.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet sentTransportByteCount: UInt64\nThe number of bytes sent into the transport protocol.\nlet retransmittedTransportByteCount: UInt64\nThe number of bytes the transport protocol retransmitted.\nlet transportSmoothedRTT: TimeInterval\nThe smoothed round-trip time the transport protocol measured.\nlet transportMinimumRTT: TimeInterval\nThe minimum round-trip time the transport protocol measured.\nlet transportRTTVariance: TimeInterval\nThe variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "transportMinimumRTT",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200417-transportminimumrtt",
        "html": "See Also\nInspecting Transport Metrics\nlet receivedTransportByteCount: UInt64\nThe number of bytes the transport protocol delivered.\nlet receivedTransportDuplicateByteCount: UInt64\nThe number of duplicated bytes the transport protocol detected.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet sentTransportByteCount: UInt64\nThe number of bytes sent into the transport protocol.\nlet retransmittedTransportByteCount: UInt64\nThe number of bytes the transport protocol retransmitted.\nlet transportSmoothedRTT: TimeInterval\nThe smoothed round-trip time the transport protocol measured.\nlet transportRTTVariance: TimeInterval\nThe variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "retransmittedTransportByteCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200413-retransmittedtransportbytecount",
        "html": "See Also\nInspecting Transport Metrics\nlet receivedTransportByteCount: UInt64\nThe number of bytes the transport protocol delivered.\nlet receivedTransportDuplicateByteCount: UInt64\nThe number of duplicated bytes the transport protocol detected.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet sentTransportByteCount: UInt64\nThe number of bytes sent into the transport protocol.\nlet transportSmoothedRTT: TimeInterval\nThe smoothed round-trip time the transport protocol measured.\nlet transportMinimumRTT: TimeInterval\nThe minimum round-trip time the transport protocol measured.\nlet transportRTTVariance: TimeInterval\nThe variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "transportRTTVariance",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200418-transportrttvariance",
        "html": "See Also\nInspecting Transport Metrics\nlet receivedTransportByteCount: UInt64\nThe number of bytes the transport protocol delivered.\nlet receivedTransportDuplicateByteCount: UInt64\nThe number of duplicated bytes the transport protocol detected.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet sentTransportByteCount: UInt64\nThe number of bytes sent into the transport protocol.\nlet retransmittedTransportByteCount: UInt64\nThe number of bytes the transport protocol retransmitted.\nlet transportSmoothedRTT: TimeInterval\nThe smoothed round-trip time the transport protocol measured.\nlet transportMinimumRTT: TimeInterval\nThe minimum round-trip time the transport protocol measured."
    },
    {
        "title": "NWParameters.PrivacyContext.ResolverConfiguration.https(_:serverAddresses:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/resolverconfiguration/https_serveraddresses",
        "html": "Discussion\n\nThe URL describes the location of the DNS server, such as \u201chttps://dnsserver.example.net/dns-query\u201d. See RFC 8484 for more details. The associated server addresses you provide are hints for which well-known DNS server addresses to use.\n\nSee Also\nResolver Types\ncase tls(NWEndpoint, serverAddresses: [NWEndpoint])\nA DNS-over-TLS resolver configuration."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/3129508-hash",
        "html": "See Also\nComparison Functions\nstatic func != (IPv6Address.Scope, IPv6Address.Scope) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int"
    },
    {
        "title": "IPv6Address.Scope.global",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/global",
        "html": "See Also\nScope Values\ncase nodeLocal\nThe node-local multicast scope.\ncase linkLocal\nThe link-local multicast scope.\ncase siteLocal\nThe site-local multicast scope.\ncase organizationLocal\nThe organization-local multicast scope."
    },
    {
        "title": "additionalHeaders",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/3200561-additionalheaders",
        "html": "See Also\nSending Handshake Responses\ninit(status: NWProtocolWebSocket.Response.Status, subprotocol: String?, additionalHeaders: [(name: String, value: String)]?)\nInitializes a WebSocket server response with a status, selected subprotocol, and additional HTTP headers.\nenum NWProtocolWebSocket.Response.Status\nStatus values that are sent with a WebSocket server response.\nlet status: NWProtocolWebSocket.Response.Status\nThe status of a WebSocket server response.\nlet subprotocol: String?\nThe selected subprotocol in a WebSocket server response."
    },
    {
        "title": "indices",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200644-indices",
        "html": "Discussion\n\nA collection\u2019s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
    },
    {
        "title": "first",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200623-first",
        "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
    },
    {
        "title": "isEmpty",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord/3200647-isempty",
        "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don\u2019t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity: O(1)"
    },
    {
        "title": "NWConnection.EstablishmentReport.Resolution.DNSProtocol.tcp",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/tcp",
        "html": "See Also\nResolution Transports\ncase unknown\nThe DNS response protocol is unknown or not applicable.\ncase udp\nThe connection used cleartext UDP for DNS resolution.\ncase tls\nThe connection used TLS for DNS resolution.\ncase https\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/3548832",
        "html": "See Also\nComparing Transports\nstatic func != (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/3548834-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Transports\nstatic func != (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "NWConnection.EstablishmentReport.Resolution.DNSProtocol.https",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol/https",
        "html": "See Also\nResolution Transports\ncase unknown\nThe DNS response protocol is unknown or not applicable.\ncase udp\nThe connection used cleartext UDP for DNS resolution.\ncase tcp\nThe connection used cleartext TCP for DNS resolution.\ncase tls\nThe connection used TLS for DNS resolution."
    },
    {
        "title": "NWProtocolQUIC.Metadata.KeepAliveBehavior.on",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/keepalivebehavior/on",
        "html": "See Also\nKeepalive Behaviors\ncase off\nKeepalives are disabled.\ncase seconds(Int)\nKeepalives are enabled with a custom timeout, in seconds."
    },
    {
        "title": "nw_parameters_iterate_interfaces_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_iterate_interfaces_block_t",
        "html": "Return Value\n\nReturn true to continue iterating, or false to stop iterating.\n\nSee Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces."
    },
    {
        "title": "nw_parameters_require_interface(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976855-nw_parameters_require_interface",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "NWProtocolQUIC.Metadata.KeepAliveBehavior.off",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/keepalivebehavior/off",
        "html": "See Also\nKeepalive Behaviors\ncase on\nKeepalives are enabled with the default timeout.\ncase seconds(Int)\nKeepalives are enabled with a custom timeout, in seconds."
    },
    {
        "title": "NWProtocolQUIC.Metadata.KeepAliveBehavior.seconds(_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/keepalivebehavior/seconds",
        "html": "See Also\nKeepalive Behaviors\ncase on\nKeepalives are enabled with the default timeout.\ncase off\nKeepalives are disabled."
    },
    {
        "title": "nw_parameters_set_required_interface_type(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976862-nw_parameters_set_required_inter",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_copy_required_interface(_:)",
        "url": "https://developer.apple.com/documentation/network/2976837-nw_parameters_copy_required_inte",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/wifi/3851022-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/wifi/3851021-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode/3200528-init",
        "html": "See Also\nClose Code Types\ncase protocolCode(NWProtocolWebSocket.CloseCode.Defined)\nA well-known close code reserved by the protocol (values 1000-2999).\nenum NWProtocolWebSocket.CloseCode.Defined\nWell-known close code values.\ncase applicationCode(UInt16)\nA close code in the range reserved for applications and frameworks (3000-3999).\ncase privateCode(UInt16)\nA close code in the private-use range (4000-4999)."
    },
    {
        "title": "init(socksv5Proxy:)",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/4156653-init",
        "html": "Parameters\nsocksv5Proxy\n\nA host endpoint identifying the SOCKS proxy server.\n\nSee Also\nCreating Proxy Configurations\ninit(relayHops: [ProxyConfiguration.RelayHop])\nInitializes a proxy configuration with one or two relay hops.\nstruct ProxyConfiguration.RelayHop\nA single relay server you can chain together with other servers.\ninit(httpCONNECTProxy: NWEndpoint, tlsOptions: NWProtocolTLS.Options?)\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/3200543-hash",
        "html": "See Also\nType Comparison Functions\nvar hashValue: Int\nstatic func != (NWProtocolWebSocket.Opcode, NWProtocolWebSocket.Opcode) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/3200539",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nType Comparison Functions\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "NWProtocolWebSocket.Opcode.close",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/close",
        "html": "See Also\nControl Types\ncase ping\nA Ping message, which requests a Pong from the peer.\ncase pong\nA Pong message in response to a Ping from the peer."
    },
    {
        "title": "NWProtocolWebSocket.Opcode.pong",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/pong",
        "html": "See Also\nControl Types\ncase ping\nA Ping message, which requests a Pong from the peer.\ncase close\nA message indicating a close of the connection."
    },
    {
        "title": "NWProtocolWebSocket.Response.Status",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/status",
        "html": "Topics\nHandshake Status Values\ncase accept\nThe client request is being accepted.\ncase reject\nThe client request is being rejected.\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWProtocolWebSocket.Response.Status, NWProtocolWebSocket.Response.Status) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWProtocolWebSocket.Response.Status, NWProtocolWebSocket.Response.Status) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nSending Handshake Responses\ninit(status: NWProtocolWebSocket.Response.Status, subprotocol: String?, additionalHeaders: [(name: String, value: String)]?)\nInitializes a WebSocket server response with a status, selected subprotocol, and additional HTTP headers.\nlet status: NWProtocolWebSocket.Response.Status\nThe status of a WebSocket server response.\nlet subprotocol: String?\nThe selected subprotocol in a WebSocket server response.\nlet additionalHeaders: [(name: String, value: String)]?\nAny additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/3200544-hashvalue",
        "html": "See Also\nType Comparison Functions\nfunc hash(into: inout Hasher)\nstatic func != (NWProtocolWebSocket.Opcode, NWProtocolWebSocket.Opcode) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/3236860-init",
        "html": "Relationships\nFrom Protocol\nRawRepresentable"
    },
    {
        "title": "NWProtocolWebSocket.Opcode.ping",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode/ping",
        "html": "See Also\nControl Types\ncase pong\nA Pong message in response to a Ping from the peer.\ncase close\nA message indicating a close of the connection."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/version/3236866-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/wifi/3851014",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "applyCredential(username:password:)",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/4156649-applycredential",
        "html": "Parameters\nusername\n\nA proxy authentication username.\n\npassword\n\nA proxy authentication password.\n\nSee Also\nCustomizing Proxy Behavior\nvar allowFailover: Bool\nA Boolean that indicates whether or not a proxy configuration allows failover to non-proxied connections. Failover isn\u2019t allowed by default."
    },
    {
        "title": "allowFailover",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/4156648-allowfailover",
        "html": "See Also\nCustomizing Proxy Behavior\nfunc applyCredential(username: String, password: String)\nSets a username and password to use as authentication for a proxy configuration."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/4156650-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
    },
    {
        "title": "nw_privacy_context_t",
        "url": "https://developer.apple.com/documentation/network/nw_privacy_context_t",
        "html": "Discussion\n\nUse NW_DEFAULT_PRIVACY_CONTEXT to specify the default shared privacy context that applies to all connections that do not use a custom context.\n\nTopics\nConfiguring Custom Privacy Settings\nfunc nw_privacy_context_create(UnsafePointer<CChar>) -> nw_privacy_context_t\nInitializes a privacy context with a description string.\nfunc nw_privacy_context_disable_logging(nw_privacy_context_t)\nDisables system logging of connection activity.\nfunc nw_privacy_context_flush_cache(nw_privacy_context_t)\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context.\nRequiring Encrypted DNS\nfunc nw_privacy_context_require_encrypted_name_resolution(nw_privacy_context_t, Bool, nw_resolver_config_t?)\nRequires that any DNS name resolution for connections associated with this context use encrypted transports, such as TLS or HTTPS.\ntypealias nw_resolver_config_t\nA DNS server configuration that uses TLS or HTTPS.\nfunc nw_resolver_config_create_https(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-HTTPS resolver configuration.\nfunc nw_resolver_config_create_tls(nw_endpoint_t) -> nw_resolver_config_t\nInitializes a DNS-over-TLS resolver configuration.\nfunc nw_resolver_config_add_server_address(nw_resolver_config_t, nw_endpoint_t)\nProvides a well-known DNS server address to use instead of looking up the address dynamically.\nConfiguring Proxies\nfunc nw_privacy_context_add_proxy(nw_privacy_context_t, nw_proxy_config_t)\nApplies a proxy configuration to all connections associated with this context.\nfunc nw_privacy_context_clear_proxies(nw_privacy_context_t)\nClears out any proxies added using nw_privacy_context_add_proxy(_:_:)\ntypealias nw_proxy_config_t\nA proxy configuration for Relays, Oblivious HTTP, HTTP CONNECT, or SOCKSv5.\nSee Also\nConfiguring Privacy Settings\nfunc nw_parameters_set_privacy_context(nw_parameters_t, nw_privacy_context_t)\nAssociates a privacy context with any connections or listeners that use the parameters."
    },
    {
        "title": "nw_parameters_set_privacy_context(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3548034-nw_parameters_set_privacy_contex",
        "html": "See Also\nConfiguring Privacy Settings\ntypealias nw_privacy_context_t\nAn object that defines the privacy requirements for a set of connections."
    },
    {
        "title": "nw_parameters_get_reuse_local_address(_:)",
        "url": "https://developer.apple.com/documentation/network/2976847-nw_parameters_get_reuse_local_ad",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_set_local_only(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976858-nw_parameters_set_local_only",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_set_reuse_local_address(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976863-nw_parameters_set_reuse_local_ad",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_set_include_peer_to_peer(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3019340-nw_parameters_set_include_peer_t",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_get_include_peer_to_peer(_:)",
        "url": "https://developer.apple.com/documentation/network/3019339-nw_parameters_get_include_peer_t",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_get_local_only(_:)",
        "url": "https://developer.apple.com/documentation/network/2976842-nw_parameters_get_local_only",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link."
    },
    {
        "title": "nw_parameters_set_prefer_no_proxy(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976860-nw_parameters_set_prefer_no_prox",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_get_service_class(_:)",
        "url": "https://developer.apple.com/documentation/network/2976848-nw_parameters_get_service_class",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_get_prefer_no_proxy(_:)",
        "url": "https://developer.apple.com/documentation/network/2976844-nw_parameters_get_prefer_no_prox",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_get_expired_dns_behavior(_:)",
        "url": "https://developer.apple.com/documentation/network/2998460-nw_parameters_get_expired_dns_be",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_get_fast_open_enabled(_:)",
        "url": "https://developer.apple.com/documentation/network/2976841-nw_parameters_get_fast_open_enab",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_set_service_class(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976864-nw_parameters_set_service_class",
        "html": "Discussion\n\nService quality affects the on-device queuing priority of your traffic, and packet markings on supported networks. You should only modify this property for cases that have very specific scheduling needs, like interactive voice traffic. You should use the best effort service for most traffic in your app.\n\nSee Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_set_expired_dns_behavior(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2998461-nw_parameters_set_expired_dns_be",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_get_multipath_service(_:)",
        "url": "https://developer.apple.com/documentation/network/2976843-nw_parameters_get_multipath_serv",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_set_multipath_service(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976859-nw_parameters_set_multipath_serv",
        "html": "See Also\nCustomizing Connection Options\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_parameters_iterate_prohibited_interfaces(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976852-nw_parameters_iterate_prohibited",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_prohibit_interface(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976853-nw_parameters_prohibit_interface",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_clear_prohibited_interfaces(_:)",
        "url": "https://developer.apple.com/documentation/network/2976832-nw_parameters_clear_prohibited_i",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_iterate_prohibited_interface_types(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976851-nw_parameters_iterate_prohibited",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_clear_prohibited_interface_types(_:)",
        "url": "https://developer.apple.com/documentation/network/2976831-nw_parameters_clear_prohibited_i",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_prohibit_interface_type(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976854-nw_parameters_prohibit_interface",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_iterate_interface_types_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_iterate_interface_types_block_t",
        "html": "Return Value\n\nReturn true to continue iterating, or false to stop iterating.\n\nSee Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_get_prohibit_expensive(_:)",
        "url": "https://developer.apple.com/documentation/network/2976845-nw_parameters_get_prohibit_expen",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_set_local_endpoint(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976857-nw_parameters_set_local_endpoint",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_copy_local_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/2976836-nw_parameters_copy_local_endpoin",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_set_prohibit_expensive(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976861-nw_parameters_set_prohibit_expen",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_get_prohibit_constrained(_:)",
        "url": "https://developer.apple.com/documentation/network/3131047-nw_parameters_get_prohibit_const",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_parameters_copy_default_protocol_stack(_:)",
        "url": "https://developer.apple.com/documentation/network/2976835-nw_parameters_copy_default_proto",
        "html": "See Also\nModifying Protocol Stacks\ntypealias nw_protocol_stack_t\nAn ordered set of protocol options that define the protocols that connections and listeners use.\ntypealias nw_protocol_definition_t\nThe abstract superclass for identifying a network protocol.\ntypealias nw_protocol_options_t\nThe abstract superclass for configuring the options of a network protocol."
    },
    {
        "title": "IPv6Address.Scope.organizationLocal",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/organizationlocal",
        "html": "See Also\nScope Values\ncase nodeLocal\nThe node-local multicast scope.\ncase linkLocal\nThe link-local multicast scope.\ncase siteLocal\nThe site-local multicast scope.\ncase global\nThe global multicast scope."
    },
    {
        "title": "IPv6Address.Scope.siteLocal",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/sitelocal",
        "html": "See Also\nScope Values\ncase nodeLocal\nThe node-local multicast scope.\ncase linkLocal\nThe link-local multicast scope.\ncase organizationLocal\nThe organization-local multicast scope.\ncase global\nThe global multicast scope."
    },
    {
        "title": "IPv6Address.Scope.nodeLocal",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/nodelocal",
        "html": "See Also\nScope Values\ncase linkLocal\nThe link-local multicast scope.\ncase siteLocal\nThe site-local multicast scope.\ncase organizationLocal\nThe organization-local multicast scope.\ncase global\nThe global multicast scope."
    },
    {
        "title": "IPv6Address.Scope.linkLocal",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope/linklocal",
        "html": "See Also\nScope Values\ncase nodeLocal\nThe node-local multicast scope.\ncase siteLocal\nThe site-local multicast scope.\ncase organizationLocal\nThe organization-local multicast scope.\ncase global\nThe global multicast scope."
    },
    {
        "title": "nw_browse_result_change_interface_added",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_interface_added",
        "html": "See Also\nBrowse Result Change Flags\nvar nw_browse_result_change_invalid: Int\nThe comparison was invallid.\nvar nw_browse_result_change_identical: Int\nThe compared services are identical.\nvar nw_browse_result_change_result_added: Int\nA new service was discovered.\nvar nw_browse_result_change_result_removed: Int\nA previously discovered service was removed.\nvar nw_browse_result_change_txt_record_changed: Int\nThe service's associated TXT record changed.\nvar nw_browse_result_change_interface_removed: Int\nThe service was no longer discovered over a certain interface."
    },
    {
        "title": "NWInterface.RadioType.Cellular.NewRadio5GVariant",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/cellular/newradio5gvariant",
        "html": "Topics\nEnumeration Cases\ncase mmWave\ncase sub6GHz\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWInterface.RadioType.Cellular.NewRadio5GVariant, NWInterface.RadioType.Cellular.NewRadio5GVariant) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWInterface.RadioType.Cellular.NewRadio5GVariant, NWInterface.RadioType.Cellular.NewRadio5GVariant) -> Bool\nRelationships\nConforms To\nSendable"
    },
    {
        "title": "handshakeRTT",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/handshake/3200428-handshakertt",
        "html": "See Also\nMeasuring Performance\nlet handshakeDuration: TimeInterval\nThe duration of the protocol handshake."
    },
    {
        "title": "duration",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/3200435-duration",
        "html": "See Also\nMeasuring Performance\nlet source: NWConnection.EstablishmentReport.Resolution.Source\nThe source of the DNS response.\nenum NWConnection.EstablishmentReport.Resolution.Source\nSources that may provide DNS responses.\nvar dnsProtocol: NWConnection.EstablishmentReport.Resolution.DNSProtocol\nThe transport protocol your connection used for DNS resolution.\nenum NWConnection.EstablishmentReport.Resolution.DNSProtocol\nA set of transport protocols connections use for DNS resolution."
    },
    {
        "title": "source",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/3200438-source",
        "html": "See Also\nMeasuring Performance\nlet duration: TimeInterval\nThe duration of this resolution step, from when the query was issued to when the response was complete.\nenum NWConnection.EstablishmentReport.Resolution.Source\nSources that may provide DNS responses.\nvar dnsProtocol: NWConnection.EstablishmentReport.Resolution.DNSProtocol\nThe transport protocol your connection used for DNS resolution.\nenum NWConnection.EstablishmentReport.Resolution.DNSProtocol\nA set of transport protocols connections use for DNS resolution."
    },
    {
        "title": "handshakeDuration",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/handshake/3200427-handshakeduration",
        "html": "See Also\nMeasuring Performance\nlet handshakeRTT: TimeInterval\nThe round-trip time the protocol observed during its handshake."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/direction/3802970-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Directions\nstatic func == (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nstatic func != (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/direction/3802969-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Directions\nstatic func == (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nstatic func != (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int"
    },
    {
        "title": "dnsProtocol",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/3548840-dnsprotocol",
        "html": "See Also\nMeasuring Performance\nlet duration: TimeInterval\nThe duration of this resolution step, from when the query was issued to when the response was complete.\nlet source: NWConnection.EstablishmentReport.Resolution.Source\nThe source of the DNS response.\nenum NWConnection.EstablishmentReport.Resolution.Source\nSources that may provide DNS responses.\nenum NWConnection.EstablishmentReport.Resolution.DNSProtocol\nA set of transport protocols connections use for DNS resolution."
    },
    {
        "title": "init(httpCONNECTProxy:tlsOptions:)",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/4156651-init",
        "html": "Parameters\nhttpCONNECTProxy\n\nA host endpoint identifying the proxy server accessible using HTTP/1.1.\n\ntlsOptions\n\nOptional TLS options to use for a TLS handshake to the relay. If no TLS options are provided, the proxy will be accessed using cleartext HTTP.\n\nDiscussion\n\nThese HTTP CONNECT proxies only handle TCP connections. To support UDP proxying, use init(relayHops:).\n\nSee Also\nCreating Proxy Configurations\ninit(relayHops: [ProxyConfiguration.RelayHop])\nInitializes a proxy configuration with one or two relay hops.\nstruct ProxyConfiguration.RelayHop\nA single relay server you can chain together with other servers.\ninit(socksv5Proxy: NWEndpoint)\nInitializes a SOCKSv5 proxy configuration."
    },
    {
        "title": "status",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/3200563-status",
        "html": "See Also\nSending Handshake Responses\ninit(status: NWProtocolWebSocket.Response.Status, subprotocol: String?, additionalHeaders: [(name: String, value: String)]?)\nInitializes a WebSocket server response with a status, selected subprotocol, and additional HTTP headers.\nenum NWProtocolWebSocket.Response.Status\nStatus values that are sent with a WebSocket server response.\nlet subprotocol: String?\nThe selected subprotocol in a WebSocket server response.\nlet additionalHeaders: [(name: String, value: String)]?\nAny additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/version/3236867-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/version/3200566",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "subprotocol",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response/3200564-subprotocol",
        "html": "See Also\nSending Handshake Responses\ninit(status: NWProtocolWebSocket.Response.Status, subprotocol: String?, additionalHeaders: [(name: String, value: String)]?)\nInitializes a WebSocket server response with a status, selected subprotocol, and additional HTTP headers.\nenum NWProtocolWebSocket.Response.Status\nStatus values that are sent with a WebSocket server response.\nlet status: NWProtocolWebSocket.Response.Status\nThe status of a WebSocket server response.\nlet additionalHeaders: [(name: String, value: String)]?\nAny additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "init(relayHops:)",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration/4156652-init",
        "html": "Parameters\nrelayHops\n\nAn array of relay hops, which must contain either one or two hops.\n\nSee Also\nCreating Proxy Configurations\nstruct ProxyConfiguration.RelayHop\nA single relay server you can chain together with other servers.\ninit(httpCONNECTProxy: NWEndpoint, tlsOptions: NWProtocolTLS.Options?)\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1.\ninit(socksv5Proxy: NWEndpoint)\nInitializes a SOCKSv5 proxy configuration."
    },
    {
        "title": "nw_parameters_set_prohibit_constrained(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3131048-nw_parameters_set_prohibit_const",
        "html": "See Also\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces."
    },
    {
        "title": "nw_ethernet_channel_state_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_invalid",
        "html": "See Also\nStates\nvar nw_ethernet_channel_state_waiting: nw_ethernet_channel_state_t\nThe channel is waiting for its interface to become available.\nvar nw_ethernet_channel_state_preparing: nw_ethernet_channel_state_t\nThe channel is registering with the interface.\nvar nw_ethernet_channel_state_ready: nw_ethernet_channel_state_t\nThe channel is able to send and receive Ethernet frames.\nvar nw_ethernet_channel_state_failed: nw_ethernet_channel_state_t\nThe channel has encountered a fatal error.\nvar nw_ethernet_channel_state_cancelled: nw_ethernet_channel_state_t\nThe channel has been canceled."
    },
    {
        "title": "nw_ethernet_channel_state_waiting",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_waiting",
        "html": "See Also\nStates\nvar nw_ethernet_channel_state_invalid: nw_ethernet_channel_state_t\nThe channel is not valid.\nvar nw_ethernet_channel_state_preparing: nw_ethernet_channel_state_t\nThe channel is registering with the interface.\nvar nw_ethernet_channel_state_ready: nw_ethernet_channel_state_t\nThe channel is able to send and receive Ethernet frames.\nvar nw_ethernet_channel_state_failed: nw_ethernet_channel_state_t\nThe channel has encountered a fatal error.\nvar nw_ethernet_channel_state_cancelled: nw_ethernet_channel_state_t\nThe channel has been canceled."
    },
    {
        "title": "nw_endpoint_type_host",
        "url": "https://developer.apple.com/documentation/network/nw_endpoint_type_host",
        "html": "See Also\nEndpoint Types\nvar nw_endpoint_type_invalid: nw_endpoint_type_t\nAn undefined endpoint type.\nvar nw_endpoint_type_address: nw_endpoint_type_t\nAn endpoint represented as an IP address and port.\nvar nw_endpoint_type_bonjour_service: nw_endpoint_type_t\nAn endpoint represented as a Bonjour service.\nvar nw_endpoint_type_url: nw_endpoint_type_t\nAn endpoint represented as a URL, with host and port values inferred from the URL."
    },
    {
        "title": "nw_browse_result_change_txt_record_changed",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_txt_record_changed",
        "html": "See Also\nBrowse Result Change Flags\nvar nw_browse_result_change_invalid: Int\nThe comparison was invallid.\nvar nw_browse_result_change_identical: Int\nThe compared services are identical.\nvar nw_browse_result_change_result_added: Int\nA new service was discovered.\nvar nw_browse_result_change_result_removed: Int\nA previously discovered service was removed.\nvar nw_browse_result_change_interface_added: Int\nThe service was discovered over a new interface.\nvar nw_browse_result_change_interface_removed: Int\nThe service was no longer discovered over a certain interface."
    },
    {
        "title": "nw_browse_result_change_result_removed",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_result_removed",
        "html": "See Also\nBrowse Result Change Flags\nvar nw_browse_result_change_invalid: Int\nThe comparison was invallid.\nvar nw_browse_result_change_identical: Int\nThe compared services are identical.\nvar nw_browse_result_change_result_added: Int\nA new service was discovered.\nvar nw_browse_result_change_txt_record_changed: Int\nThe service's associated TXT record changed.\nvar nw_browse_result_change_interface_added: Int\nThe service was discovered over a new interface.\nvar nw_browse_result_change_interface_removed: Int\nThe service was no longer discovered over a certain interface."
    },
    {
        "title": "nw_browse_result_change_interface_removed",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_interface_removed",
        "html": "See Also\nBrowse Result Change Flags\nvar nw_browse_result_change_invalid: Int\nThe comparison was invallid.\nvar nw_browse_result_change_identical: Int\nThe compared services are identical.\nvar nw_browse_result_change_result_added: Int\nA new service was discovered.\nvar nw_browse_result_change_result_removed: Int\nA previously discovered service was removed.\nvar nw_browse_result_change_txt_record_changed: Int\nThe service's associated TXT record changed.\nvar nw_browse_result_change_interface_added: Int\nThe service was discovered over a new interface."
    },
    {
        "title": "NWBrowser.Result.Change",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/change",
        "html": "Topics\nInspecting Change Types\ncase identical\nNo change was detected for the result.\ncase added(NWBrowser.Result)\nA new result was discovered.\ncase removed(NWBrowser.Result)\nA previously discovered result was removed.\ncase changed(old: NWBrowser.Result, new: NWBrowser.Result, flags: NWBrowser.Result.Change.Flags)\nA result changed properties but was not removed.\nstruct NWBrowser.Result.Change.Flags\nFlags providing details about a change in a discovered service.\nCalculating Result Changes\ninit(between: NWBrowser.Result?, NWBrowser.Result?)\nInitializes a change between two results.\nfunc hash(into: inout Hasher)\nstatic func == (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool\nstatic func != (NWBrowser.Result.Change, NWBrowser.Result.Change) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nInstance Properties\nvar hashValue: Int\nRelationships\nConforms To\nHashable\nSendable\nSee Also\nComparing Results\nstatic func == (NWBrowser.Result, NWBrowser.Result) -> Bool\nstatic func != (NWBrowser.Result, NWBrowser.Result) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "nw_connection_state_preparing",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_preparing",
        "html": "See Also\nConnection States\nvar nw_connection_state_invalid: nw_connection_state_t\nThe connection is not valid.\nvar nw_connection_state_waiting: nw_connection_state_t\nThe connection is waiting for a network path change.\nvar nw_connection_state_ready: nw_connection_state_t\nThe connection is established, and ready to send and receive data.\nvar nw_connection_state_failed: nw_connection_state_t\nThe connection has disconnected or encountered an error.\nvar nw_connection_state_cancelled: nw_connection_state_t\nThe connection has been canceled."
    },
    {
        "title": "nw_parameters_configure_protocol_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_configure_protocol_block_t",
        "html": "Discussion\n\nPassing in a block allows you to customize how a protocol will behave in a connection.\n\nIf you want to use the default configuration for a protocol, pass NW_PARAMETERS_DEFAULT_CONFIGURATION.\n\nIf you want to disable a protocol (such as TLS), pass NW_PARAMETERS_DISABLE_PROTOCOL. Not all protocols can be disabled.\n\nSee Also\nCreating Parameters\nfunc nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for TLS or TCP connections and listeners.\nfunc nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for DTLS or UDP connections and listeners.\nfunc nw_parameters_create() -> nw_parameters_t\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\nfunc nw_parameters_create_custom_ip(UInt8, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc nw_parameters_copy(nw_parameters_t) -> nw_parameters_t\nPeforms a deep copy of a parameters object.\nRelated Documentation\nTCP Options\nConfigure options for connections that use the Transmission Control Protocol.\nTLS Options\nConfigure options for connections that use Transport Layer Security.\nUDP Options\nConfigure options for connections that use the User Datagram Protocol."
    },
    {
        "title": "nw_connection_state_ready",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_ready",
        "html": "See Also\nConnection States\nvar nw_connection_state_invalid: nw_connection_state_t\nThe connection is not valid.\nvar nw_connection_state_waiting: nw_connection_state_t\nThe connection is waiting for a network path change.\nvar nw_connection_state_preparing: nw_connection_state_t\nThe connection in the process of being established.\nvar nw_connection_state_failed: nw_connection_state_t\nThe connection has disconnected or encountered an error.\nvar nw_connection_state_cancelled: nw_connection_state_t\nThe connection has been canceled."
    },
    {
        "title": "nw_endpoint_type_url",
        "url": "https://developer.apple.com/documentation/network/nw_endpoint_type_url",
        "html": "See Also\nEndpoint Types\nvar nw_endpoint_type_invalid: nw_endpoint_type_t\nAn undefined endpoint type.\nvar nw_endpoint_type_address: nw_endpoint_type_t\nAn endpoint represented as an IP address and port.\nvar nw_endpoint_type_host: nw_endpoint_type_t\nAn endpoint represented as a hostname and port.\nvar nw_endpoint_type_bonjour_service: nw_endpoint_type_t\nAn endpoint represented as a Bonjour service."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwprotocoldefinition/2998742-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Protocol Definitions\nlet name: String\nThe name of the protocol."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocoldefinition/2998740",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Protocols\nstatic func == (NWProtocolDefinition, NWProtocolDefinition) -> Bool"
    },
    {
        "title": "nw_connection_state_waiting",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_waiting",
        "html": "See Also\nConnection States\nvar nw_connection_state_invalid: nw_connection_state_t\nThe connection is not valid.\nvar nw_connection_state_preparing: nw_connection_state_t\nThe connection in the process of being established.\nvar nw_connection_state_ready: nw_connection_state_t\nThe connection is established, and ready to send and receive data.\nvar nw_connection_state_failed: nw_connection_state_t\nThe connection has disconnected or encountered an error.\nvar nw_connection_state_cancelled: nw_connection_state_t\nThe connection has been canceled."
    },
    {
        "title": "NWTXTRecord",
        "url": "https://developer.apple.com/documentation/network/nwtxtrecord",
        "html": "Topics\nCreating TXT Records\ninit([String : String])\nInitializes a TXT record with a dictionary of strings.\nfunc removeEntry(key: String) -> Bool\nRemoves an entry from a TXT record dictionary.\nfunc setEntry(NWTXTRecord.Entry, for: String) -> Bool\nSets an entry in a TXT record dictionary.\nenum NWTXTRecord.Entry\nA type of entry in a TXT record dictionary.\nExamining TXT Records\nfunc getEntry(for: String) -> NWTXTRecord.Entry?\nAccesses an entry in a TXT record dictionary.\nsubscript(String) -> String?\nGet and set values in a TXT record dictionary, by keys.\nvar dictionary: [String : String]\nThe TXT record as a dictionary of strings.\nsubscript(NWTXTRecord.Index) -> NWTXTRecord.Element\nGet and set values in a TXT record dictionary, by index.\ntypealias NWTXTRecord.Element\nA container for a TXT record key and entry value.\nType Aliases\ntypealias NWTXTRecord.Indices\ntypealias NWTXTRecord.Iterator\ntypealias NWTXTRecord.SubSequence\nInitializers\ninit(Data)\nInstance Properties\nvar count: Int\nThe number of elements in the collection.\nvar data: Data\nvar debugDescription: String\nvar endIndex: NWTXTRecord.Index\nvar first: (key: String, value: Entry)?\nThe first element of the collection.\nvar indices: DefaultIndices<NWTXTRecord>\nThe indices that are valid for subscripting the collection, in ascending order.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar lazy: LazySequence<NWTXTRecord>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar publisher: Publishers.Sequence<NWTXTRecord, Never>\nvar startIndex: NWTXTRecord.Index\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection.\nInstance Methods\nfunc allSatisfy(((key: String, value: Entry)) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc compactMap<ElementOfResult>(((key: String, value: Entry)) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nfunc contains(where: ((key: String, value: Entry)) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc distance(from: Index, to: Index) -> Int\nReturns the distance between two indices.\nfunc drop(while: ((key: String, value: Entry)) -> Bool) -> Slice<NWTXTRecord>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<NWTXTRecord>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<NWTXTRecord>\nReturns a subsequence containing all but the specified number of final elements.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: ((key: String, value: Entry), OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc enumerated() -> EnumeratedSequence<NWTXTRecord>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc filter(((key: String, value: Entry)) -> Bool) -> [(key: String, value: Entry)]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<(key: String, value: Entry)>) -> [(key: String, value: Entry)]\nfunc first(where: ((key: String, value: Entry)) -> Bool) -> (key: String, value: Entry)?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(where: ((key: String, value: Entry)) -> Bool) -> Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc flatMap<SegmentOfResult>(((key: String, value: Entry)) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>(((key: String, value: Entry)) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated\nfunc forEach(((key: String, value: Entry)) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc formIndex(inout Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Index, offsetBy: Int, limitedBy: Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Index)\nReplaces the given index with its successor.\nfunc formatted<S>(S) -> S.FormatOutput\nfunc index(Index, offsetBy: Int) -> Index\nReturns an index that is the specified distance from the given index.\nfunc index(Index, offsetBy: Int, limitedBy: Index) -> Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc index(after: NWTXTRecord.Index) -> NWTXTRecord.Index\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: ((key: String, value: Entry), (key: String, value: Entry)) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nfunc makeIterator() -> IndexingIterator<NWTXTRecord>\nReturns an iterator over the elements of the collection.\nfunc map<T>(((key: String, value: Entry)) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence\u2019s elements.\nfunc max(by: ((key: String, value: Entry), (key: String, value: Entry)) -> Bool) -> (key: String, value: Entry)?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min(by: ((key: String, value: Entry), (key: String, value: Entry)) -> Bool) -> (key: String, value: Entry)?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> Slice<NWTXTRecord>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Index) -> Slice<NWTXTRecord>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Index) -> Slice<NWTXTRecord>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: ((key: String, value: Entry)) -> Bool) -> Slice<NWTXTRecord>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc randomElement() -> (key: String, value: Entry)?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> (key: String, value: Entry)?\nReturns a random element of the collection, using the given generator as a source for randomness.\nfunc reduce<Result>(Result, (Result, (key: String, value: Entry)) -> Result) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, (key: String, value: Entry)) -> ()) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reversed() -> [(key: String, value: Entry)]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled() -> [(key: String, value: Entry)]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [(key: String, value: Entry)]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nfunc sorted(by: ((key: String, value: Entry), (key: String, value: Entry)) -> Bool) -> [(key: String, value: Entry)]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [(key: String, value: Entry)]\nfunc sorted<S, Comparator>(using: S) -> [(key: String, value: Entry)]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: ((key: String, value: Entry)) -> Bool) -> [Slice<NWTXTRecord>]\nReturns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: ((key: String, value: Entry), PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc suffix(Int) -> Slice<NWTXTRecord>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Index) -> Slice<NWTXTRecord>\nReturns a subsequence from the specified position to the end of the collection.\nfunc trimmingPrefix(while: ((key: String, value: Entry)) -> Bool) -> Slice<NWTXTRecord>\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<(key: String, value: Entry)>) -> R) -> R?\nExecutes a closure on the sequence\u2019s contiguous storage.\nSubscripts\nsubscript<R>(R) -> Slice<NWTXTRecord>\nAccesses the contiguous subrange of the collection\u2019s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<NWTXTRecord>\nsubscript(Range<Index>) -> Slice<NWTXTRecord>\nAccesses a contiguous subrange of the collection\u2019s elements.\nOperator Functions\nstatic func != (NWTXTRecord, NWTXTRecord) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWTXTRecord, NWTXTRecord) -> Bool\nStructures\nstruct NWTXTRecord.Index\nRelationships\nConforms To\nCollection\nCustomDebugStringConvertible\nSendable\nSee Also\nEvaluating Browser Results\nlet endpoint: NWEndpoint\nThe discovered service endpoint.\nlet interfaces: [NWInterface]\nThe list of interfaces on which the service was discovered.\nlet metadata: NWBrowser.Result.Metadata\nThe metadata associated with the discovered service, such as the TXT record.\nenum NWBrowser.Result.Metadata\nValues associated with discovered services, such as TXT records."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/3236819-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/3200385-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Results\nenum NWBrowser.Result.Change\nWays in which discovered services can change between specific results.\nstatic func == (NWBrowser.Result, NWBrowser.Result) -> Bool\nstatic func != (NWBrowser.Result, NWBrowser.Result) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/3200320",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Results\nenum NWBrowser.Result.Change\nWays in which discovered services can change between specific results.\nstatic func == (NWBrowser.Result, NWBrowser.Result) -> Bool\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/3200321",
        "html": "See Also\nComparing Results\nenum NWBrowser.Result.Change\nWays in which discovered services can change between specific results.\nstatic func != (NWBrowser.Result, NWBrowser.Result) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "metadata",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/3200387-metadata",
        "html": "See Also\nEvaluating Browser Results\nlet endpoint: NWEndpoint\nThe discovered service endpoint.\nlet interfaces: [NWInterface]\nThe list of interfaces on which the service was discovered.\nenum NWBrowser.Result.Metadata\nValues associated with discovered services, such as TXT records.\nstruct NWTXTRecord\nA dictionary representing a TXT record in a DNS packet."
    },
    {
        "title": "NWBrowser.Descriptor.bonjour(type:domain:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/descriptor/bonjour_type_domain",
        "html": "See Also\nDescriptor Types\ncase bonjourWithTXTRecord(type: String, domain: String?)\nA service descriptor used to discover a Bonjour service with associated TXT records."
    },
    {
        "title": "NWProtocolTLS.Metadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltls/metadata",
        "html": "Topics\nInspecting TLS State\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the TLS handshake.\nRelationships\nInherits From\nNWProtocolMetadata"
    },
    {
        "title": "definition",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltls/2998796-definition",
        "html": "See Also\nCreating TLS Connections\nclass NWProtocolTLS.Options\nA container of options for configuring how TLS is used on a connection."
    },
    {
        "title": "securityProtocolOptions",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltls/options/2998795-securityprotocoloptions",
        "html": "See Also\nCustomizing TLS Connections\ninit()\nInitializes a default set of TLS connection options.\nRelated Documentation\nSecurity Options\nConfigure security options for TLS handshakes."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/direction/3802966",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Directions\nstatic func == (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "NWProtocolQUIC.Options.Direction.unidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/direction/unidirectional",
        "html": "See Also\nDirection Values\ncase bidirectional\nA bidirectional QUIC stream."
    },
    {
        "title": "NWProtocolQUIC.Options.Direction.bidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/direction/bidirectional",
        "html": "See Also\nDirection Values\ncase unidirectional\nA unidirectional QUIC stream."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/direction/3802967",
        "html": "See Also\nComparing Directions\nstatic func != (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "nw_parameters_copy(_:)",
        "url": "https://developer.apple.com/documentation/network/2976834-nw_parameters_copy",
        "html": "See Also\nCreating Parameters\nfunc nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for TLS or TCP connections and listeners.\nfunc nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for DTLS or UDP connections and listeners.\ntypealias nw_parameters_configure_protocol_block_t\nA block to configure protocol options during the creation of a parameters object.\nfunc nw_parameters_create() -> nw_parameters_t\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\nfunc nw_parameters_create_custom_ip(UInt8, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for connections and listeners using a custom IP protocol."
    },
    {
        "title": "nw_parameters_create_secure_udp(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976840-nw_parameters_create_secure_udp",
        "html": "Discussion\n\nThis function allows you to either use the default configurations for DTLS and UDP, or use customized protocol options. If you want to use the default configuration, pass NW_PARAMETERS_DEFAULT_CONFIGURATION. If you want to customize the options for a protocol, pass a block to modify the options.\n\nIf you need to disable DTLS, pass NW_PARAMETERS_DISABLE_PROTOCOL.\n\nSee Also\nCreating Parameters\nfunc nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for TLS or TCP connections and listeners.\ntypealias nw_parameters_configure_protocol_block_t\nA block to configure protocol options during the creation of a parameters object.\nfunc nw_parameters_create() -> nw_parameters_t\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\nfunc nw_parameters_create_custom_ip(UInt8, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc nw_parameters_copy(nw_parameters_t) -> nw_parameters_t\nPeforms a deep copy of a parameters object."
    },
    {
        "title": "nw_parameters_create_secure_tcp(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976839-nw_parameters_create_secure_tcp",
        "html": "Discussion\n\nThis function allows you to either use the default configurations for TLS and TCP, or use customized protocol options. If you want to use the default configuration, pass NW_PARAMETERS_DEFAULT_CONFIGURATION. If you want to customize the options for a protocol, pass a block to modify the options.\n\nIf you need to disable TLS, pass NW_PARAMETERS_DISABLE_PROTOCOL.\n\nSee Also\nCreating Parameters\nfunc nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for DTLS or UDP connections and listeners.\ntypealias nw_parameters_configure_protocol_block_t\nA block to configure protocol options during the creation of a parameters object.\nfunc nw_parameters_create() -> nw_parameters_t\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\nfunc nw_parameters_create_custom_ip(UInt8, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc nw_parameters_copy(nw_parameters_t) -> nw_parameters_t\nPeforms a deep copy of a parameters object."
    },
    {
        "title": "nw_parameters_create_custom_ip(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3141919-nw_parameters_create_custom_ip",
        "html": "Discussion\n\nCreating custom IP protocol connections requires the \"com.apple.developer.networking.custom-protocol\" entitlement.\n\nSee Also\nCreating Parameters\nfunc nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for TLS or TCP connections and listeners.\nfunc nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for DTLS or UDP connections and listeners.\ntypealias nw_parameters_configure_protocol_block_t\nA block to configure protocol options during the creation of a parameters object.\nfunc nw_parameters_create() -> nw_parameters_t\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\nfunc nw_parameters_copy(nw_parameters_t) -> nw_parameters_t\nPeforms a deep copy of a parameters object."
    },
    {
        "title": "nw_parameters_create()",
        "url": "https://developer.apple.com/documentation/network/2976838-nw_parameters_create",
        "html": "See Also\nCreating Parameters\nfunc nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for TLS or TCP connections and listeners.\nfunc nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for DTLS or UDP connections and listeners.\ntypealias nw_parameters_configure_protocol_block_t\nA block to configure protocol options during the creation of a parameters object.\nfunc nw_parameters_create_custom_ip(UInt8, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc nw_parameters_copy(nw_parameters_t) -> nw_parameters_t\nPeforms a deep copy of a parameters object."
    },
    {
        "title": "receivedApplicationByteCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200408-receivedapplicationbytecount",
        "html": "See Also\nInspecting Application Metrics\nlet sentApplicationByteCount: UInt64\nThe number of bytes sent on the connection."
    },
    {
        "title": "successfulEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/3200439-successfulendpoint",
        "html": "See Also\nExamining Resolved Endpoints\nlet preferredEndpoint: NWEndpoint\nThe resolved endpoint that the connection used for its first connection attempt.\nlet endpointCount: Int\nThe number of endpoints resolved in this step."
    },
    {
        "title": "NWConnection.EstablishmentReport.Resolution.DNSProtocol",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/dnsprotocol",
        "html": "Topics\nResolution Transports\ncase unknown\nThe DNS response protocol is unknown or not applicable.\ncase udp\nThe connection used cleartext UDP for DNS resolution.\ncase tcp\nThe connection used cleartext TCP for DNS resolution.\ncase tls\nThe connection used TLS for DNS resolution.\ncase https\nThe connection used HTTPS for DNS resolution.\nComparing Transports\nstatic func != (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWConnection.EstablishmentReport.Resolution.DNSProtocol, NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Bool\nvar hashValue: Int\nfunc hash(into: inout Hasher)\nRelationships\nConforms To\nSendable\nSee Also\nMeasuring Performance\nlet duration: TimeInterval\nThe duration of this resolution step, from when the query was issued to when the response was complete.\nlet source: NWConnection.EstablishmentReport.Resolution.Source\nThe source of the DNS response.\nenum NWConnection.EstablishmentReport.Resolution.Source\nSources that may provide DNS responses.\nvar dnsProtocol: NWConnection.EstablishmentReport.Resolution.DNSProtocol\nThe transport protocol your connection used for DNS resolution."
    },
    {
        "title": "preferredEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution/3200437-preferredendpoint",
        "html": "See Also\nExamining Resolved Endpoints\nlet successfulEndpoint: NWEndpoint\nThe resolved endpoint that led to the established connection.\nlet endpointCount: Int\nThe number of endpoints resolved in this step."
    },
    {
        "title": "sentApplicationByteCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200414-sentapplicationbytecount",
        "html": "See Also\nInspecting Application Metrics\nlet receivedApplicationByteCount: UInt64\nThe number of bytes the connection delivered."
    },
    {
        "title": "sentTransportByteCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200416-senttransportbytecount",
        "html": "See Also\nInspecting Transport Metrics\nlet receivedTransportByteCount: UInt64\nThe number of bytes the transport protocol delivered.\nlet receivedTransportDuplicateByteCount: UInt64\nThe number of duplicated bytes the transport protocol detected.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet retransmittedTransportByteCount: UInt64\nThe number of bytes the transport protocol retransmitted.\nlet transportSmoothedRTT: TimeInterval\nThe smoothed round-trip time the transport protocol measured.\nlet transportMinimumRTT: TimeInterval\nThe minimum round-trip time the transport protocol measured.\nlet transportRTTVariance: TimeInterval\nThe variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_ws_version_13",
        "url": "https://developer.apple.com/documentation/network/nw_ws_version_13",
        "html": "See Also\nVersions\nvar nw_ws_version_invalid: nw_ws_version_t\nAn invalid version."
    },
    {
        "title": "nw_browse_result_change_result_added",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_result_added",
        "html": "See Also\nBrowse Result Change Flags\nvar nw_browse_result_change_invalid: Int\nThe comparison was invallid.\nvar nw_browse_result_change_identical: Int\nThe compared services are identical.\nvar nw_browse_result_change_result_removed: Int\nA previously discovered service was removed.\nvar nw_browse_result_change_txt_record_changed: Int\nThe service's associated TXT record changed.\nvar nw_browse_result_change_interface_added: Int\nThe service was discovered over a new interface.\nvar nw_browse_result_change_interface_removed: Int\nThe service was no longer discovered over a certain interface."
    },
    {
        "title": "nw_browse_result_change_identical",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_identical",
        "html": "See Also\nBrowse Result Change Flags\nvar nw_browse_result_change_invalid: Int\nThe comparison was invallid.\nvar nw_browse_result_change_result_added: Int\nA new service was discovered.\nvar nw_browse_result_change_result_removed: Int\nA previously discovered service was removed.\nvar nw_browse_result_change_txt_record_changed: Int\nThe service's associated TXT record changed.\nvar nw_browse_result_change_interface_added: Int\nThe service was discovered over a new interface.\nvar nw_browse_result_change_interface_removed: Int\nThe service was no longer discovered over a certain interface."
    },
    {
        "title": "nw_browse_result_change_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_invalid",
        "html": "See Also\nBrowse Result Change Flags\nvar nw_browse_result_change_identical: Int\nThe compared services are identical.\nvar nw_browse_result_change_result_added: Int\nA new service was discovered.\nvar nw_browse_result_change_result_removed: Int\nA previously discovered service was removed.\nvar nw_browse_result_change_txt_record_changed: Int\nThe service's associated TXT record changed.\nvar nw_browse_result_change_interface_added: Int\nThe service was discovered over a new interface.\nvar nw_browse_result_change_interface_removed: Int\nThe service was no longer discovered over a certain interface."
    },
    {
        "title": "nw_endpoint_type_address",
        "url": "https://developer.apple.com/documentation/network/nw_endpoint_type_address",
        "html": "See Also\nEndpoint Types\nvar nw_endpoint_type_invalid: nw_endpoint_type_t\nAn undefined endpoint type.\nvar nw_endpoint_type_host: nw_endpoint_type_t\nAn endpoint represented as a hostname and port.\nvar nw_endpoint_type_bonjour_service: nw_endpoint_type_t\nAn endpoint represented as a Bonjour service.\nvar nw_endpoint_type_url: nw_endpoint_type_t\nAn endpoint represented as a URL, with host and port values inferred from the URL."
    },
    {
        "title": "Framer Protocol Options",
        "url": "https://developer.apple.com/documentation/network/framer_protocol_options",
        "html": "Topics\nAdding Framers to Connections\nnw_framer_create_definition\nInitializes a new protocol definition based on your protocol implementation.\nnw_framer_start_handler_t\nA handler that represents the entry point into your custom protocol.\nnw_framer_t\nAn object that represents a single instance of your custom protocol running in a connection.\nnw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nNW_FRAMER_CREATE_FLAGS_DEFAULT\nA constant flag value that indicates that the default framer protocol behavior should be used.\nnw_framer_create_options\nInitializes a set of protocol options with a custom framer definition.\nHandling Output Data\nnw_framer_set_output_handler\nSets a block to handle new outbound messages.\nnw_framer_output_handler_t\nA handler that notifies your protocol about a new outbound message.\nnw_framer_parse_output\nExamines the content of output data while inside your output handler.\nnw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nnw_framer_write_output\nSends arbitrary output data in a buffer from your protocol to the next protocol.\nnw_framer_write_output_data\nSends arbitrary output data from your protocol to the next protocol.\nnw_framer_write_output_no_copy\nSends a specific number of bytes from a message while inside your output handler.\nnw_framer_pass_through_output\nIndicates that your protocol no longer needs to handle output data.\nHandling Input Data\nnw_framer_set_input_handler\nSets a block to handle new inbound data.\nnw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\nnw_framer_parse_input\nExamines the content of input data while inside your input handler block.\nnw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nnw_framer_deliver_input\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nnw_framer_deliver_input_no_copy\nDelivers an inbound message containing a specific number of next received bytes.\nnw_framer_pass_through_input\nIndicates that your protocol no longer needs to handle input data.\nCustomizing Framer Messages\nnw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nnw_protocol_metadata_is_framer_message\nChecks if a metadata object represents a custom framer protocol message.\nnw_framer_protocol_create_message\nInitializes an empty message for a custom framer definition.\nnw_framer_message_create\nInitializes an empty message from within a framer implementation.\nnw_framer_message_set_value\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\nnw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nnw_framer_message_set_object_value\nSets an NSObject value to be stored in a framer message.\nnw_framer_message_access_value\nAccesses a custom value stored in a framer message.\nnw_framer_message_copy_object_value\nAccesses an NSObject value stored in a framer message.\nManaging Instance Lifetime\nnw_framer_mark_ready\nIndicates to a connection that your protocol's handshake is complete.\nnw_framer_mark_failed_with_error\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nnw_framer_prepend_application_protocol\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready.\nnw_framer_set_stop_handler\nSets a block to handle when the connection is being closed.\nnw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\nnw_framer_set_cleanup_handler\nSets a block to handle the final cleanup of allocations made by your protocol instance.\nnw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated.\nInspecting Instance Properties\nnw_framer_copy_remote_endpoint\nAccesses the remote endpoint of the connection in which your protocol is running.\nnw_framer_copy_local_endpoint\nAccesses the local endpoint of the connection in which your protocol is running.\nnw_framer_copy_parameters\nAccesses the parameters of the connection in which your protocol is running.\nHandling Asynchronous Events\nnw_framer_schedule_wakeup\nRequests that the nw_framer_wakeup_handler_t be called on your protocol at a specific time in the future.\nNW_FRAMER_WAKEUP_TIME_FOREVER\nA sentinel value that indicates that no wakeup should be delivered.\nnw_framer_set_wakeup_handler\nSets a handler to receive scheduled wakeup events.\nnw_framer_wakeup_handler_t\nA handler that delivers a scheduled wakeup event.\nnw_framer_async\nRequests that a block be executed on the connection's internal scheduling context.\nnw_framer_block_t\nA block to be invoked asynchronously on your framer protocol's scheduling context.\nSee Also\nNetwork Protocols\nTCP Options\nConfigure options for connections that use the Transmission Control Protocol.\nTLS Options\nConfigure options for connections that use Transport Layer Security.\nQUIC Options\nConfigure options for connections that use the QUIC transport protocol.\nUDP Options\nConfigure options for connections that use the User Datagram Protocol.\nIP Options\nConfigure Internet Protocol options on connections.\nWebSocket Options\nConfigure options for connections that use WebSocket."
    },
    {
        "title": "sentIPPacketCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport/3200415-sentippacketcount",
        "html": "See Also\nInspecting Packet Metrics\nlet receivedIPPacketCount: UInt64\nThe number of IP packets the connection received."
    },
    {
        "title": "nw_parameters_set_fast_open_enabled(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976856-nw_parameters_set_fast_open_enab",
        "html": "Discussion\n\nWhen fast open is enabled on a connection, the application is expected to send its early data to be included with the handshake as idempotent data. This data can be sent before or after calling start.\n\nSee Also\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link."
    },
    {
        "title": "nw_protocol_options_t",
        "url": "https://developer.apple.com/documentation/network/nw_protocol_options_t",
        "html": "Topics\nInspecting Protocols\nfunc nw_protocol_options_copy_definition(nw_protocol_options_t) -> nw_protocol_definition_t\nAccesses the protocol definition associated with the options object.\nSee Also\nModifying Protocol Stacks\nfunc nw_parameters_copy_default_protocol_stack(nw_parameters_t) -> nw_protocol_stack_t\nAccesses the protocol stack used by connections and listeners.\ntypealias nw_protocol_stack_t\nAn ordered set of protocol options that define the protocols that connections and listeners use.\ntypealias nw_protocol_definition_t\nThe abstract superclass for identifying a network protocol."
    },
    {
        "title": "nw_connection_state_failed",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_failed",
        "html": "See Also\nConnection States\nvar nw_connection_state_invalid: nw_connection_state_t\nThe connection is not valid.\nvar nw_connection_state_waiting: nw_connection_state_t\nThe connection is waiting for a network path change.\nvar nw_connection_state_preparing: nw_connection_state_t\nThe connection in the process of being established.\nvar nw_connection_state_ready: nw_connection_state_t\nThe connection is established, and ready to send and receive data.\nvar nw_connection_state_cancelled: nw_connection_state_t\nThe connection has been canceled."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocoldefinition/2998741",
        "html": "See Also\nComparing Protocols\nstatic func != (NWProtocolDefinition, NWProtocolDefinition) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "interfaces",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/3200386-interfaces",
        "html": "See Also\nEvaluating Browser Results\nlet endpoint: NWEndpoint\nThe discovered service endpoint.\nlet metadata: NWBrowser.Result.Metadata\nThe metadata associated with the discovered service, such as the TXT record.\nenum NWBrowser.Result.Metadata\nValues associated with discovered services, such as TXT records.\nstruct NWTXTRecord\nA dictionary representing a TXT record in a DNS packet."
    },
    {
        "title": "endpoint",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result/3200384-endpoint",
        "html": "See Also\nEvaluating Browser Results\nlet interfaces: [NWInterface]\nThe list of interfaces on which the service was discovered.\nlet metadata: NWBrowser.Result.Metadata\nThe metadata associated with the discovered service, such as the TXT record.\nenum NWBrowser.Result.Metadata\nValues associated with discovered services, such as TXT records.\nstruct NWTXTRecord\nA dictionary representing a TXT record in a DNS packet."
    },
    {
        "title": "NWBrowser.State.cancelled",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/state/cancelled",
        "html": "See Also\nStates\ncase setup\nThe browser has been initialized but not started.\ncase ready\nThe browser is registered for discovering services.\ncase failed(NWError)\nThe browser has encountered a fatal error."
    },
    {
        "title": "NWBrowser.State.failed(_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/state/failed",
        "html": "See Also\nStates\ncase setup\nThe browser has been initialized but not started.\ncase ready\nThe browser is registered for discovering services.\ncase cancelled\nThe browser has been canceled."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltls/options/2998794-init",
        "html": "See Also\nCustomizing TLS Connections\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options TLS uses."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/state/3200389",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "NWBrowser.State.ready",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/state/ready",
        "html": "See Also\nStates\ncase setup\nThe browser has been initialized but not started.\ncase failed(NWError)\nThe browser has encountered a fatal error.\ncase cancelled\nThe browser has been canceled."
    },
    {
        "title": "nw_connection_state_cancelled",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_cancelled",
        "html": "See Also\nConnection States\nvar nw_connection_state_invalid: nw_connection_state_t\nThe connection is not valid.\nvar nw_connection_state_waiting: nw_connection_state_t\nThe connection is waiting for a network path change.\nvar nw_connection_state_preparing: nw_connection_state_t\nThe connection in the process of being established.\nvar nw_connection_state_ready: nw_connection_state_t\nThe connection is established, and ready to send and receive data.\nvar nw_connection_state_failed: nw_connection_state_t\nThe connection has disconnected or encountered an error."
    },
    {
        "title": "nw_data_transfer_report_state_collected",
        "url": "https://developer.apple.com/documentation/network/nw_data_transfer_report_state_collected",
        "html": "See Also\nReport States\nvar nw_data_transfer_report_state_collecting: nw_data_transfer_report_state_t\nThe data transfer report has been started but is still collecting data."
    },
    {
        "title": "nw_error_domain_tls",
        "url": "https://developer.apple.com/documentation/network/nw_error_domain_tls",
        "html": "See Also\nError Domain Constants\nvar nw_error_domain_invalid: nw_error_domain_t\nThe error is invalid.\nvar nw_error_domain_posix: nw_error_domain_t\nA POSIX error, which is used for most network protocol and routing errors.\nvar nw_error_domain_dns: nw_error_domain_t\nA DNS error encountered in resolving, browsing, or advertising."
    },
    {
        "title": "kNWErrorDomainDNS",
        "url": "https://developer.apple.com/documentation/network/knwerrordomaindns",
        "html": "See Also\nCFError Domain Constants\nlet kNWErrorDomainPOSIX: CFString\nA POSIX error, which is used for most network protocol and routing errors.\nlet kNWErrorDomainTLS: CFString\nA TLS error reported by a TLS connection or listener."
    },
    {
        "title": "kNWErrorDomainPOSIX",
        "url": "https://developer.apple.com/documentation/network/knwerrordomainposix",
        "html": "See Also\nCFError Domain Constants\nlet kNWErrorDomainDNS: CFString\nA DNS error encountered in resolving, browsing, or advertising.\nlet kNWErrorDomainTLS: CFString\nA TLS error reported by a TLS connection or listener."
    },
    {
        "title": "nw_ip_ecn_flag_ect_1",
        "url": "https://developer.apple.com/documentation/network/nw_ip_ecn_flag_ect_1",
        "html": "See Also\nECN Flags\nvar nw_ip_ecn_flag_non_ect: nw_ip_ecn_flag_t\nNon-ECN Capable Transport.\nvar nw_ip_ecn_flag_ect_0: nw_ip_ecn_flag_t\nECN Capable Transport (flag 0).\nvar nw_ip_ecn_flag_ce: nw_ip_ecn_flag_t\nCongestion Experienced."
    },
    {
        "title": "nw_ethernet_channel_state_ready",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_ready",
        "html": "See Also\nStates\nvar nw_ethernet_channel_state_invalid: nw_ethernet_channel_state_t\nThe channel is not valid.\nvar nw_ethernet_channel_state_waiting: nw_ethernet_channel_state_t\nThe channel is waiting for its interface to become available.\nvar nw_ethernet_channel_state_preparing: nw_ethernet_channel_state_t\nThe channel is registering with the interface.\nvar nw_ethernet_channel_state_failed: nw_ethernet_channel_state_t\nThe channel has encountered a fatal error.\nvar nw_ethernet_channel_state_cancelled: nw_ethernet_channel_state_t\nThe channel has been canceled."
    },
    {
        "title": "nw_ethernet_channel_state_preparing",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_preparing",
        "html": "See Also\nStates\nvar nw_ethernet_channel_state_invalid: nw_ethernet_channel_state_t\nThe channel is not valid.\nvar nw_ethernet_channel_state_waiting: nw_ethernet_channel_state_t\nThe channel is waiting for its interface to become available.\nvar nw_ethernet_channel_state_ready: nw_ethernet_channel_state_t\nThe channel is able to send and receive Ethernet frames.\nvar nw_ethernet_channel_state_failed: nw_ethernet_channel_state_t\nThe channel has encountered a fatal error.\nvar nw_ethernet_channel_state_cancelled: nw_ethernet_channel_state_t\nThe channel has been canceled."
    },
    {
        "title": "nw_ethernet_channel_state_failed",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_failed",
        "html": "See Also\nStates\nvar nw_ethernet_channel_state_invalid: nw_ethernet_channel_state_t\nThe channel is not valid.\nvar nw_ethernet_channel_state_waiting: nw_ethernet_channel_state_t\nThe channel is waiting for its interface to become available.\nvar nw_ethernet_channel_state_preparing: nw_ethernet_channel_state_t\nThe channel is registering with the interface.\nvar nw_ethernet_channel_state_ready: nw_ethernet_channel_state_t\nThe channel is able to send and receive Ethernet frames.\nvar nw_ethernet_channel_state_cancelled: nw_ethernet_channel_state_t\nThe channel has been canceled."
    },
    {
        "title": "nw_ethernet_channel_state_cancelled",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_cancelled",
        "html": "See Also\nStates\nvar nw_ethernet_channel_state_invalid: nw_ethernet_channel_state_t\nThe channel is not valid.\nvar nw_ethernet_channel_state_waiting: nw_ethernet_channel_state_t\nThe channel is waiting for its interface to become available.\nvar nw_ethernet_channel_state_preparing: nw_ethernet_channel_state_t\nThe channel is registering with the interface.\nvar nw_ethernet_channel_state_ready: nw_ethernet_channel_state_t\nThe channel is able to send and receive Ethernet frames.\nvar nw_ethernet_channel_state_failed: nw_ethernet_channel_state_t\nThe channel has encountered a fatal error."
    },
    {
        "title": "NWBrowser.State.setup",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/state/setup",
        "html": "See Also\nStates\ncase ready\nThe browser is registered for discovering services.\ncase failed(NWError)\nThe browser has encountered a fatal error.\ncase cancelled\nThe browser has been canceled."
    },
    {
        "title": "nw_endpoint_type_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_endpoint_type_invalid",
        "html": "See Also\nEndpoint Types\nvar nw_endpoint_type_address: nw_endpoint_type_t\nAn endpoint represented as an IP address and port.\nvar nw_endpoint_type_host: nw_endpoint_type_t\nAn endpoint represented as a hostname and port.\nvar nw_endpoint_type_bonjour_service: nw_endpoint_type_t\nAn endpoint represented as a Bonjour service.\nvar nw_endpoint_type_url: nw_endpoint_type_t\nAn endpoint represented as a URL, with host and port values inferred from the URL."
    },
    {
        "title": "nw_endpoint_type_bonjour_service",
        "url": "https://developer.apple.com/documentation/network/nw_endpoint_type_bonjour_service",
        "html": "See Also\nEndpoint Types\nvar nw_endpoint_type_invalid: nw_endpoint_type_t\nAn undefined endpoint type.\nvar nw_endpoint_type_address: nw_endpoint_type_t\nAn endpoint represented as an IP address and port.\nvar nw_endpoint_type_host: nw_endpoint_type_t\nAn endpoint represented as a hostname and port.\nvar nw_endpoint_type_url: nw_endpoint_type_t\nAn endpoint represented as a URL, with host and port values inferred from the URL."
    },
    {
        "title": "nw_connection_state_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_invalid",
        "html": "See Also\nConnection States\nvar nw_connection_state_waiting: nw_connection_state_t\nThe connection is waiting for a network path change.\nvar nw_connection_state_preparing: nw_connection_state_t\nThe connection in the process of being established.\nvar nw_connection_state_ready: nw_connection_state_t\nThe connection is established, and ready to send and receive data.\nvar nw_connection_state_failed: nw_connection_state_t\nThe connection has disconnected or encountered an error.\nvar nw_connection_state_cancelled: nw_connection_state_t\nThe connection has been canceled."
    },
    {
        "title": "nw_protocol_definition_t",
        "url": "https://developer.apple.com/documentation/network/nw_protocol_definition_t",
        "html": "Topics\nComparing Protocols\nfunc nw_protocol_definition_is_equal(nw_protocol_definition_t, nw_protocol_definition_t) -> Bool\nCompares two protocol definitions, and returns true if they represent the same protocol implementation.\nSee Also\nModifying Protocol Stacks\nfunc nw_parameters_copy_default_protocol_stack(nw_parameters_t) -> nw_protocol_stack_t\nAccesses the protocol stack used by connections and listeners.\ntypealias nw_protocol_stack_t\nAn ordered set of protocol options that define the protocols that connections and listeners use.\ntypealias nw_protocol_options_t\nThe abstract superclass for configuring the options of a network protocol."
    },
    {
        "title": "nw_ws_opcode_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_ws_opcode_invalid",
        "html": "See Also\nControl Types\nvar nw_ws_opcode_ping: nw_ws_opcode_t\nA Ping message, which requests a Pong from the peer.\nvar nw_ws_opcode_pong: nw_ws_opcode_t\nA Pong message in response to a Ping from the peer.\nvar nw_ws_opcode_close: nw_ws_opcode_t\nA message indicating a close of the connection."
    },
    {
        "title": "nw_connection_group_state_cancelled",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_state_cancelled",
        "html": "See Also\nStates\nvar nw_connection_group_state_invalid: nw_connection_group_state_t\nThe connection group is not valid.\nvar nw_connection_group_state_waiting: nw_connection_group_state_t\nThe connection group is waiting for a network path change.\nvar nw_connection_group_state_ready: nw_connection_group_state_t\nThe connection group is joined, and ready to send and receive data.\nvar nw_connection_group_state_failed: nw_connection_group_state_t\nThe connection group encountered a fatal error."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_t/2977008-init",
        "html": "Parameters\nrawValue\n\nThe raw value of the service class.\n\nSee Also\nCreating a service class instance\ninit(rawValue: UInt32)\nCreates an instance of the service class structure."
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_t/2977009-init",
        "html": "Parameters\nrawValue\n\nThe raw value of the service class.\n\nSee Also\nCreating a service class instance\ninit(UInt32)\nCreates an instance of the service class structure."
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_t/2998805-init",
        "html": "Parameters\nrawValue\n\nThe raw value of the expired DNS behavior.\n\nSee Also\nCreating an expired DNS behavior instance\ninit(UInt32)\nCreates an instance of the expired DNS behavior structure."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_t/2998804-init",
        "html": "Parameters\nrawValue\n\nThe raw value of the expired DNS behavior.\n\nSee Also\nCreating an expired DNS behavior instance\ninit(rawValue: UInt32)\nCreates an instance of the expired DNS behavior structure."
    },
    {
        "title": "nw_service_class_background",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_background",
        "html": "See Also\nService classes\nvar nw_service_class_best_effort: nw_service_class_t\nDefault priority traffic.\nvar nw_service_class_interactive_video: nw_service_class_t\nInteractive video traffic.\nvar nw_service_class_interactive_voice: nw_service_class_t\nInteractive voice traffic.\nvar nw_service_class_responsive_data: nw_service_class_t\nResponsive user-data traffic.\nvar nw_service_class_signaling: nw_service_class_t\nSignaling control traffic."
    },
    {
        "title": "nw_framer_start_result_will_mark_ready",
        "url": "https://developer.apple.com/documentation/network/nw_framer_start_result_will_mark_ready",
        "html": "See Also\nStart Results\nvar nw_framer_start_result_ready: nw_framer_start_result_t\nThe protocol is immediately ready to send and receive data."
    },
    {
        "title": "nw_ws_version_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_ws_version_invalid",
        "html": "See Also\nVersions\nvar nw_ws_version_13: nw_ws_version_t\nVersion 13 of the WebSocket protocol."
    },
    {
        "title": "nw_ip_local_address_preference_default",
        "url": "https://developer.apple.com/documentation/network/nw_ip_local_address_preference_default",
        "html": "See Also\nAddress Preferences\nvar nw_ip_local_address_preference_temporary: nw_ip_local_address_preference_t\nPrefer using temporary local addresses.\nvar nw_ip_local_address_preference_stable: nw_ip_local_address_preference_t\nPrefer using stable local addresses."
    },
    {
        "title": "nw_ip_local_address_preference_temporary",
        "url": "https://developer.apple.com/documentation/network/nw_ip_local_address_preference_temporary",
        "html": "See Also\nAddress Preferences\nvar nw_ip_local_address_preference_default: nw_ip_local_address_preference_t\nAllow the system to decide which kind of local address to prefer for a connection or listener.\nvar nw_ip_local_address_preference_stable: nw_ip_local_address_preference_t\nPrefer using stable local addresses."
    },
    {
        "title": "nw_listener_state_cancelled",
        "url": "https://developer.apple.com/documentation/network/nw_listener_state_cancelled",
        "html": "See Also\nListener States\nvar nw_listener_state_invalid: nw_listener_state_t\nThe listener is not valid.\nvar nw_listener_state_waiting: nw_listener_state_t\nThe listener is waiting for a network to become available.\nvar nw_listener_state_ready: nw_listener_state_t\nThe listener is running and able to receive incoming connections.\nvar nw_listener_state_failed: nw_listener_state_t\nThe listener has encountered a fatal error."
    },
    {
        "title": "nw_multipath_service_interactive",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_service_interactive",
        "html": "See Also\nMultipath service types\nvar nw_multipath_service_disabled: nw_multipath_service_t\nDisable multipath.\nvar nw_multipath_service_handover: nw_multipath_service_t\nEnable multipath, but only use other interfaces when the primary interface is lost.\nvar nw_multipath_service_aggregate: nw_multipath_service_t\nEnable multipath to maximize bandwidth across multiple interfaces."
    },
    {
        "title": "nw_listener_state_waiting",
        "url": "https://developer.apple.com/documentation/network/nw_listener_state_waiting",
        "html": "See Also\nListener States\nvar nw_listener_state_invalid: nw_listener_state_t\nThe listener is not valid.\nvar nw_listener_state_ready: nw_listener_state_t\nThe listener is running and able to receive incoming connections.\nvar nw_listener_state_failed: nw_listener_state_t\nThe listener has encountered a fatal error.\nvar nw_listener_state_cancelled: nw_listener_state_t\nThe listener has been canceled."
    },
    {
        "title": "nw_listener_state_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_listener_state_invalid",
        "html": "See Also\nListener States\nvar nw_listener_state_waiting: nw_listener_state_t\nThe listener is waiting for a network to become available.\nvar nw_listener_state_ready: nw_listener_state_t\nThe listener is running and able to receive incoming connections.\nvar nw_listener_state_failed: nw_listener_state_t\nThe listener has encountered a fatal error.\nvar nw_listener_state_cancelled: nw_listener_state_t\nThe listener has been canceled."
    },
    {
        "title": "nw_listener_state_failed",
        "url": "https://developer.apple.com/documentation/network/nw_listener_state_failed",
        "html": "See Also\nListener States\nvar nw_listener_state_invalid: nw_listener_state_t\nThe listener is not valid.\nvar nw_listener_state_waiting: nw_listener_state_t\nThe listener is waiting for a network to become available.\nvar nw_listener_state_ready: nw_listener_state_t\nThe listener is running and able to receive incoming connections.\nvar nw_listener_state_cancelled: nw_listener_state_t\nThe listener has been canceled."
    },
    {
        "title": "nw_listener_state_ready",
        "url": "https://developer.apple.com/documentation/network/nw_listener_state_ready",
        "html": "See Also\nListener States\nvar nw_listener_state_invalid: nw_listener_state_t\nThe listener is not valid.\nvar nw_listener_state_waiting: nw_listener_state_t\nThe listener is waiting for a network to become available.\nvar nw_listener_state_failed: nw_listener_state_t\nThe listener has encountered a fatal error.\nvar nw_listener_state_cancelled: nw_listener_state_t\nThe listener has been canceled."
    },
    {
        "title": "nw_report_resolution_protocol_tls",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_protocol_tls",
        "html": "See Also\nResolution Transports\nvar nw_report_resolution_protocol_unknown: nw_report_resolution_protocol_t\nThe DNS response protocol is unknown or not applicable.\nvar nw_report_resolution_protocol_udp: nw_report_resolution_protocol_t\nThe connection used cleartext UDP for DNS resolution.\nvar nw_report_resolution_protocol_tcp: nw_report_resolution_protocol_t\nThe connection used cleartext TCP for DNS resolution.\nvar nw_report_resolution_protocol_https: nw_report_resolution_protocol_t\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "nw_data_transfer_report_state_collecting",
        "url": "https://developer.apple.com/documentation/network/nw_data_transfer_report_state_collecting",
        "html": "See Also\nReport States\nvar nw_data_transfer_report_state_collected: nw_data_transfer_report_state_t\nThe data transfer report has completed, and data can be examined."
    },
    {
        "title": "nw_error_domain_posix",
        "url": "https://developer.apple.com/documentation/network/nw_error_domain_posix",
        "html": "See Also\nError Domain Constants\nvar nw_error_domain_invalid: nw_error_domain_t\nThe error is invalid.\nvar nw_error_domain_dns: nw_error_domain_t\nA DNS error encountered in resolving, browsing, or advertising.\nvar nw_error_domain_tls: nw_error_domain_t\nA TLS error reported by a TLS connection or listener."
    },
    {
        "title": "nw_error_domain_dns",
        "url": "https://developer.apple.com/documentation/network/nw_error_domain_dns",
        "html": "See Also\nError Domain Constants\nvar nw_error_domain_invalid: nw_error_domain_t\nThe error is invalid.\nvar nw_error_domain_posix: nw_error_domain_t\nA POSIX error, which is used for most network protocol and routing errors.\nvar nw_error_domain_tls: nw_error_domain_t\nA TLS error reported by a TLS connection or listener."
    },
    {
        "title": "nw_error_domain_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_error_domain_invalid",
        "html": "See Also\nError Domain Constants\nvar nw_error_domain_posix: nw_error_domain_t\nA POSIX error, which is used for most network protocol and routing errors.\nvar nw_error_domain_dns: nw_error_domain_t\nA DNS error encountered in resolving, browsing, or advertising.\nvar nw_error_domain_tls: nw_error_domain_t\nA TLS error reported by a TLS connection or listener."
    },
    {
        "title": "kNWErrorDomainTLS",
        "url": "https://developer.apple.com/documentation/network/knwerrordomaintls",
        "html": "See Also\nCFError Domain Constants\nlet kNWErrorDomainPOSIX: CFString\nA POSIX error, which is used for most network protocol and routing errors.\nlet kNWErrorDomainDNS: CFString\nA DNS error encountered in resolving, browsing, or advertising."
    },
    {
        "title": "nw_report_resolution_source_query",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_source_query",
        "html": "See Also\nResolution Sources\nvar nw_report_resolution_source_cache: nw_report_resolution_source_t\nThe DNS response was retrieved from a local cache.\nvar nw_report_resolution_source_expired_cache: nw_report_resolution_source_t\nThe DNS response had expired and was retrieved from a local cache."
    },
    {
        "title": "nw_report_resolution_source_expired_cache",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_source_expired_cache",
        "html": "See Also\nResolution Sources\nvar nw_report_resolution_source_query: nw_report_resolution_source_t\nThe DNS response was received from the network.\nvar nw_report_resolution_source_cache: nw_report_resolution_source_t\nThe DNS response was retrieved from a local cache."
    },
    {
        "title": "nw_report_resolution_source_cache",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_source_cache",
        "html": "See Also\nResolution Sources\nvar nw_report_resolution_source_query: nw_report_resolution_source_t\nThe DNS response was received from the network.\nvar nw_report_resolution_source_expired_cache: nw_report_resolution_source_t\nThe DNS response had expired and was retrieved from a local cache."
    },
    {
        "title": "nw_connection_group_state_failed",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_state_failed",
        "html": "See Also\nStates\nvar nw_connection_group_state_invalid: nw_connection_group_state_t\nThe connection group is not valid.\nvar nw_connection_group_state_waiting: nw_connection_group_state_t\nThe connection group is waiting for a network path change.\nvar nw_connection_group_state_ready: nw_connection_group_state_t\nThe connection group is joined, and ready to send and receive data.\nvar nw_connection_group_state_cancelled: nw_connection_group_state_t\nThe connection group has been canceled."
    },
    {
        "title": "nw_browser_state_ready",
        "url": "https://developer.apple.com/documentation/network/nw_browser_state_ready",
        "html": "See Also\nStates\nvar nw_browser_state_invalid: nw_browser_state_t\nThe browser is not valid.\nvar nw_browser_state_failed: nw_browser_state_t\nThe browser has encountered a fatal error.\nvar nw_browser_state_cancelled: nw_browser_state_t\nThe browser has been canceled."
    },
    {
        "title": "nw_ws_opcode_close",
        "url": "https://developer.apple.com/documentation/network/nw_ws_opcode_close",
        "html": "See Also\nControl Types\nvar nw_ws_opcode_ping: nw_ws_opcode_t\nA Ping message, which requests a Pong from the peer.\nvar nw_ws_opcode_pong: nw_ws_opcode_t\nA Pong message in response to a Ping from the peer.\nvar nw_ws_opcode_invalid: nw_ws_opcode_t\nThe message is not valid."
    },
    {
        "title": "nw_connection_group_state_waiting",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_state_waiting",
        "html": "See Also\nStates\nvar nw_connection_group_state_invalid: nw_connection_group_state_t\nThe connection group is not valid.\nvar nw_connection_group_state_ready: nw_connection_group_state_t\nThe connection group is joined, and ready to send and receive data.\nvar nw_connection_group_state_failed: nw_connection_group_state_t\nThe connection group encountered a fatal error.\nvar nw_connection_group_state_cancelled: nw_connection_group_state_t\nThe connection group has been canceled."
    },
    {
        "title": "nw_connection_group_state_ready",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_state_ready",
        "html": "See Also\nStates\nvar nw_connection_group_state_invalid: nw_connection_group_state_t\nThe connection group is not valid.\nvar nw_connection_group_state_waiting: nw_connection_group_state_t\nThe connection group is waiting for a network path change.\nvar nw_connection_group_state_failed: nw_connection_group_state_t\nThe connection group encountered a fatal error.\nvar nw_connection_group_state_cancelled: nw_connection_group_state_t\nThe connection group has been canceled."
    },
    {
        "title": "nw_service_class_interactive_voice",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_interactive_voice",
        "html": "See Also\nService classes\nvar nw_service_class_best_effort: nw_service_class_t\nDefault priority traffic.\nvar nw_service_class_background: nw_service_class_t\nBulk traffic, or traffic that can be deprioritized behind foreground traffic.\nvar nw_service_class_interactive_video: nw_service_class_t\nInteractive video traffic.\nvar nw_service_class_responsive_data: nw_service_class_t\nResponsive user-data traffic.\nvar nw_service_class_signaling: nw_service_class_t\nSignaling control traffic."
    },
    {
        "title": "nw_service_class_signaling",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_signaling",
        "html": "See Also\nService classes\nvar nw_service_class_best_effort: nw_service_class_t\nDefault priority traffic.\nvar nw_service_class_background: nw_service_class_t\nBulk traffic, or traffic that can be deprioritized behind foreground traffic.\nvar nw_service_class_interactive_video: nw_service_class_t\nInteractive video traffic.\nvar nw_service_class_interactive_voice: nw_service_class_t\nInteractive voice traffic.\nvar nw_service_class_responsive_data: nw_service_class_t\nResponsive user-data traffic."
    },
    {
        "title": "nw_parameters_expired_dns_behavior_allow",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_allow",
        "html": "See Also\nExpired DNS behaviors\nvar nw_parameters_expired_dns_behavior_default: nw_parameters_expired_dns_behavior_t\nLet the system determine whether or not to allow expired DNS answers.\nvar nw_parameters_expired_dns_behavior_prohibit: nw_parameters_expired_dns_behavior_t\nExplicitly prohibit the use of expired DNS answers."
    },
    {
        "title": "nw_service_class_responsive_data",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_responsive_data",
        "html": "See Also\nService classes\nvar nw_service_class_best_effort: nw_service_class_t\nDefault priority traffic.\nvar nw_service_class_background: nw_service_class_t\nBulk traffic, or traffic that can be deprioritized behind foreground traffic.\nvar nw_service_class_interactive_video: nw_service_class_t\nInteractive video traffic.\nvar nw_service_class_interactive_voice: nw_service_class_t\nInteractive voice traffic.\nvar nw_service_class_signaling: nw_service_class_t\nSignaling control traffic."
    },
    {
        "title": "nw_parameters_expired_dns_behavior_default",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_default",
        "html": "See Also\nExpired DNS behaviors\nvar nw_parameters_expired_dns_behavior_allow: nw_parameters_expired_dns_behavior_t\nExplicitly allow the use of expired DNS answers.\nvar nw_parameters_expired_dns_behavior_prohibit: nw_parameters_expired_dns_behavior_t\nExplicitly prohibit the use of expired DNS answers."
    },
    {
        "title": "nw_parameters_expired_dns_behavior_prohibit",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_prohibit",
        "html": "See Also\nExpired DNS behaviors\nvar nw_parameters_expired_dns_behavior_default: nw_parameters_expired_dns_behavior_t\nLet the system determine whether or not to allow expired DNS answers.\nvar nw_parameters_expired_dns_behavior_allow: nw_parameters_expired_dns_behavior_t\nExplicitly allow the use of expired DNS answers."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_service_t/2977002-init",
        "html": "Parameters\nrawValue\n\nThe raw value of the multipath service type.\n\nSee Also\nCreating a multipath service type instance\ninit(rawValue: UInt32)\nCreates an instance of the multipath service type structure."
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_service_t/2977003-init",
        "html": "Parameters\nrawValue\n\nThe raw value of the multipath service type.\n\nSee Also\nCreating a multipath service type instance\ninit(UInt32)\nCreates an instance of the multipath service type structure."
    },
    {
        "title": "nw_multipath_service_handover",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_service_handover",
        "html": "See Also\nMultipath service types\nvar nw_multipath_service_disabled: nw_multipath_service_t\nDisable multipath.\nvar nw_multipath_service_interactive: nw_multipath_service_t\nEnable multipath to use other interfaces when the primary interface encounters loss or delay.\nvar nw_multipath_service_aggregate: nw_multipath_service_t\nEnable multipath to maximize bandwidth across multiple interfaces."
    },
    {
        "title": "nw_framer_start_result_ready",
        "url": "https://developer.apple.com/documentation/network/nw_framer_start_result_ready",
        "html": "See Also\nStart Results\nvar nw_framer_start_result_will_mark_ready: nw_framer_start_result_t\nThe protocol will perform a handshake, preventing the overall connection from becoming ready until nw_framer_mark_ready(_:) is called."
    },
    {
        "title": "nw_multipath_service_disabled",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_service_disabled",
        "html": "See Also\nMultipath service types\nvar nw_multipath_service_handover: nw_multipath_service_t\nEnable multipath, but only use other interfaces when the primary interface is lost.\nvar nw_multipath_service_interactive: nw_multipath_service_t\nEnable multipath to use other interfaces when the primary interface encounters loss or delay.\nvar nw_multipath_service_aggregate: nw_multipath_service_t\nEnable multipath to maximize bandwidth across multiple interfaces."
    },
    {
        "title": "nw_ip_local_address_preference_stable",
        "url": "https://developer.apple.com/documentation/network/nw_ip_local_address_preference_stable",
        "html": "See Also\nAddress Preferences\nvar nw_ip_local_address_preference_default: nw_ip_local_address_preference_t\nAllow the system to decide which kind of local address to prefer for a connection or listener.\nvar nw_ip_local_address_preference_temporary: nw_ip_local_address_preference_t\nPrefer using temporary local addresses."
    },
    {
        "title": "is6to4",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998523-is6to4",
        "html": "See Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "nw_report_resolution_protocol_unknown",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_protocol_unknown",
        "html": "See Also\nResolution Transports\nvar nw_report_resolution_protocol_udp: nw_report_resolution_protocol_t\nThe connection used cleartext UDP for DNS resolution.\nvar nw_report_resolution_protocol_tcp: nw_report_resolution_protocol_t\nThe connection used cleartext TCP for DNS resolution.\nvar nw_report_resolution_protocol_tls: nw_report_resolution_protocol_t\nThe connection used TLS for DNS resolution.\nvar nw_report_resolution_protocol_https: nw_report_resolution_protocol_t\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "nw_report_resolution_protocol_udp",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_protocol_udp",
        "html": "See Also\nResolution Transports\nvar nw_report_resolution_protocol_unknown: nw_report_resolution_protocol_t\nThe DNS response protocol is unknown or not applicable.\nvar nw_report_resolution_protocol_tcp: nw_report_resolution_protocol_t\nThe connection used cleartext TCP for DNS resolution.\nvar nw_report_resolution_protocol_tls: nw_report_resolution_protocol_t\nThe connection used TLS for DNS resolution.\nvar nw_report_resolution_protocol_https: nw_report_resolution_protocol_t\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "nw_report_resolution_protocol_tcp",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_protocol_tcp",
        "html": "See Also\nResolution Transports\nvar nw_report_resolution_protocol_unknown: nw_report_resolution_protocol_t\nThe DNS response protocol is unknown or not applicable.\nvar nw_report_resolution_protocol_udp: nw_report_resolution_protocol_t\nThe connection used cleartext UDP for DNS resolution.\nvar nw_report_resolution_protocol_tls: nw_report_resolution_protocol_t\nThe connection used TLS for DNS resolution.\nvar nw_report_resolution_protocol_https: nw_report_resolution_protocol_t\nThe connection used HTTPS for DNS resolution."
    },
    {
        "title": "nw_ip_version_6",
        "url": "https://developer.apple.com/documentation/network/nw_ip_version_6",
        "html": "See Also\nVersions\nvar nw_ip_version_any: nw_ip_version_t\nAllow any IP version.\nvar nw_ip_version_4: nw_ip_version_t\nRequire IP version 4."
    },
    {
        "title": "nw_report_resolution_protocol_https",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_protocol_https",
        "html": "See Also\nResolution Transports\nvar nw_report_resolution_protocol_unknown: nw_report_resolution_protocol_t\nThe DNS response protocol is unknown or not applicable.\nvar nw_report_resolution_protocol_udp: nw_report_resolution_protocol_t\nThe connection used cleartext UDP for DNS resolution.\nvar nw_report_resolution_protocol_tcp: nw_report_resolution_protocol_t\nThe connection used cleartext TCP for DNS resolution.\nvar nw_report_resolution_protocol_tls: nw_report_resolution_protocol_t\nThe connection used TLS for DNS resolution."
    },
    {
        "title": "nw_ip_ecn_flag_non_ect",
        "url": "https://developer.apple.com/documentation/network/nw_ip_ecn_flag_non_ect",
        "html": "See Also\nECN Flags\nvar nw_ip_ecn_flag_ect_0: nw_ip_ecn_flag_t\nECN Capable Transport (flag 0).\nvar nw_ip_ecn_flag_ect_1: nw_ip_ecn_flag_t\nECN Capable Transport (flag 1).\nvar nw_ip_ecn_flag_ce: nw_ip_ecn_flag_t\nCongestion Experienced."
    },
    {
        "title": "nw_ip_ecn_flag_ect_0",
        "url": "https://developer.apple.com/documentation/network/nw_ip_ecn_flag_ect_0",
        "html": "See Also\nECN Flags\nvar nw_ip_ecn_flag_non_ect: nw_ip_ecn_flag_t\nNon-ECN Capable Transport.\nvar nw_ip_ecn_flag_ect_1: nw_ip_ecn_flag_t\nECN Capable Transport (flag 1).\nvar nw_ip_ecn_flag_ce: nw_ip_ecn_flag_t\nCongestion Experienced."
    },
    {
        "title": "nw_ws_response_status_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_ws_response_status_invalid",
        "html": "See Also\nHandshake Status Values\nvar nw_ws_response_status_accept: nw_ws_response_status_t\nThe client request is being accepted.\nvar nw_ws_response_status_reject: nw_ws_response_status_t\nThe client request is being rejected."
    },
    {
        "title": "nw_ws_response_status_accept",
        "url": "https://developer.apple.com/documentation/network/nw_ws_response_status_accept",
        "html": "See Also\nHandshake Status Values\nvar nw_ws_response_status_invalid: nw_ws_response_status_t\nAn invalid response status.\nvar nw_ws_response_status_reject: nw_ws_response_status_t\nThe client request is being rejected."
    },
    {
        "title": "nw_ws_response_status_reject",
        "url": "https://developer.apple.com/documentation/network/nw_ws_response_status_reject",
        "html": "See Also\nHandshake Status Values\nvar nw_ws_response_status_invalid: nw_ws_response_status_t\nAn invalid response status.\nvar nw_ws_response_status_accept: nw_ws_response_status_t\nThe client request is being accepted."
    },
    {
        "title": "opcode",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/metadata/3200535-opcode",
        "html": "See Also\nReceiving Messages\nvar closeCode: NWProtocolWebSocket.CloseCode\nThe close code on a WebSocket message.\nenum NWProtocolWebSocket.CloseCode\nTypes of codes used upon closing a WebSocket connection."
    },
    {
        "title": "closeCode",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/metadata/3200533-closecode",
        "html": "See Also\nSending Messages\ninit(opcode: NWProtocolWebSocket.Opcode)\nInitializes a WebSocket message with a specific type code.\nenum NWProtocolWebSocket.Opcode\nTypes of messages that you send and receive on a WebSocket connection.\nfunc setPongHandler(DispatchQueue, handler: (NWError?) -> Void)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\nenum NWProtocolWebSocket.CloseCode\nTypes of codes used upon closing a WebSocket connection."
    },
    {
        "title": "nw_ws_opcode_cont",
        "url": "https://developer.apple.com/documentation/network/nw_ws_opcode_cont",
        "html": "Discussion\n\nContinuations are handled automatically, and should not be manually sent."
    },
    {
        "title": "nw_ws_opcode_ping",
        "url": "https://developer.apple.com/documentation/network/nw_ws_opcode_ping",
        "html": "See Also\nControl Types\nvar nw_ws_opcode_pong: nw_ws_opcode_t\nA Pong message in response to a Ping from the peer.\nvar nw_ws_opcode_close: nw_ws_opcode_t\nA message indicating a close of the connection.\nvar nw_ws_opcode_invalid: nw_ws_opcode_t\nThe message is not valid."
    },
    {
        "title": "next()",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/iterator/4166037-next",
        "html": "Relationships\nFrom Protocol\nAsyncIteratorProtocol"
    },
    {
        "title": "nw_browser_state_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_browser_state_invalid",
        "html": "See Also\nStates\nvar nw_browser_state_ready: nw_browser_state_t\nThe browser is registered for discovering services.\nvar nw_browser_state_failed: nw_browser_state_t\nThe browser has encountered a fatal error.\nvar nw_browser_state_cancelled: nw_browser_state_t\nThe browser has been canceled."
    },
    {
        "title": "nw_connection_group_state_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_state_invalid",
        "html": "See Also\nStates\nvar nw_connection_group_state_waiting: nw_connection_group_state_t\nThe connection group is waiting for a network path change.\nvar nw_connection_group_state_ready: nw_connection_group_state_t\nThe connection group is joined, and ready to send and receive data.\nvar nw_connection_group_state_failed: nw_connection_group_state_t\nThe connection group encountered a fatal error.\nvar nw_connection_group_state_cancelled: nw_connection_group_state_t\nThe connection group has been canceled."
    },
    {
        "title": "nw_browser_state_failed",
        "url": "https://developer.apple.com/documentation/network/nw_browser_state_failed",
        "html": "See Also\nStates\nvar nw_browser_state_invalid: nw_browser_state_t\nThe browser is not valid.\nvar nw_browser_state_ready: nw_browser_state_t\nThe browser is registered for discovering services.\nvar nw_browser_state_cancelled: nw_browser_state_t\nThe browser has been canceled."
    },
    {
        "title": "nw_browser_state_cancelled",
        "url": "https://developer.apple.com/documentation/network/nw_browser_state_cancelled",
        "html": "See Also\nStates\nvar nw_browser_state_invalid: nw_browser_state_t\nThe browser is not valid.\nvar nw_browser_state_ready: nw_browser_state_t\nThe browser is registered for discovering services.\nvar nw_browser_state_failed: nw_browser_state_t\nThe browser has encountered a fatal error."
    },
    {
        "title": "nw_service_class_best_effort",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_best_effort",
        "html": "See Also\nService classes\nvar nw_service_class_background: nw_service_class_t\nBulk traffic, or traffic that can be deprioritized behind foreground traffic.\nvar nw_service_class_interactive_video: nw_service_class_t\nInteractive video traffic.\nvar nw_service_class_interactive_voice: nw_service_class_t\nInteractive voice traffic.\nvar nw_service_class_responsive_data: nw_service_class_t\nResponsive user-data traffic.\nvar nw_service_class_signaling: nw_service_class_t\nSignaling control traffic."
    },
    {
        "title": "nw_service_class_interactive_video",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_interactive_video",
        "html": "See Also\nService classes\nvar nw_service_class_best_effort: nw_service_class_t\nDefault priority traffic.\nvar nw_service_class_background: nw_service_class_t\nBulk traffic, or traffic that can be deprioritized behind foreground traffic.\nvar nw_service_class_interactive_voice: nw_service_class_t\nInteractive voice traffic.\nvar nw_service_class_responsive_data: nw_service_class_t\nResponsive user-data traffic.\nvar nw_service_class_signaling: nw_service_class_t\nSignaling control traffic."
    },
    {
        "title": "transportProtocol",
        "url": "https://developer.apple.com/documentation/network/nwparameters/protocolstack/2998681-transportprotocol",
        "html": "See Also\nConfiguring Lower Protocols\nvar internetProtocol: NWProtocolOptions?\nThe Internet Protocol options used by connections and listeners."
    },
    {
        "title": "NWInterface.RadioType.WiFi",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/wifi",
        "html": "Topics\nEnumeration Cases\ncase a\ncase ac\ncase ax\ncase b\ncase g\ncase n\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWInterface.RadioType.WiFi, NWInterface.RadioType.WiFi) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWInterface.RadioType.WiFi, NWInterface.RadioType.WiFi) -> Bool\nRelationships\nConforms To\nSendable"
    },
    {
        "title": "NWInterface.InterfaceType.cellular",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/cellular",
        "html": "See Also\nInterface Types\ncase wifi\nThe network interface type used for communication over Wi-Fi networks.\ncase wiredEthernet\nThe network interface type used for communication over wired Ethernet networks.\ncase loopback\nThe network interface type used for communication over local loopback networks.\ncase other\nThe network interface type used for communication over virtual networks or networks of unknown types."
    },
    {
        "title": "NWInterface.InterfaceType.wifi",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/wifi",
        "html": "See Also\nInterface Types\ncase cellular\nThe network interface type used for communication over cellular networks.\ncase wiredEthernet\nThe network interface type used for communication over wired Ethernet networks.\ncase loopback\nThe network interface type used for communication over local loopback networks.\ncase other\nThe network interface type used for communication over virtual networks or networks of unknown types."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3204136-init",
        "html": "See Also\nCreating Addresses\ninit?(String)\nInitializes an Ethernet address with a string."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/state/2998654",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "nw_txt_record_find_key_no_value",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_find_key_no_value",
        "html": "See Also\nKey Value Status\nvar nw_txt_record_find_key_invalid: nw_txt_record_find_key_t\nThe key is not valid.\nvar nw_txt_record_find_key_not_present: nw_txt_record_find_key_t\nThe key is not present in the dictionary.\nvar nw_txt_record_find_key_empty_value: nw_txt_record_find_key_t\nThe key is present and has an empty associated value.\nvar nw_txt_record_find_key_non_empty_value: nw_txt_record_find_key_t\nThe key has an associated value."
    },
    {
        "title": "nw_txt_record_find_key_not_present",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_find_key_not_present",
        "html": "See Also\nKey Value Status\nvar nw_txt_record_find_key_invalid: nw_txt_record_find_key_t\nThe key is not valid.\nvar nw_txt_record_find_key_no_value: nw_txt_record_find_key_t\nThe key is present but has no associated value.\nvar nw_txt_record_find_key_empty_value: nw_txt_record_find_key_t\nThe key is present and has an empty associated value.\nvar nw_txt_record_find_key_non_empty_value: nw_txt_record_find_key_t\nThe key has an associated value."
    },
    {
        "title": "nw_txt_record_find_key_empty_value",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_find_key_empty_value",
        "html": "See Also\nKey Value Status\nvar nw_txt_record_find_key_invalid: nw_txt_record_find_key_t\nThe key is not valid.\nvar nw_txt_record_find_key_not_present: nw_txt_record_find_key_t\nThe key is not present in the dictionary.\nvar nw_txt_record_find_key_no_value: nw_txt_record_find_key_t\nThe key is present but has no associated value.\nvar nw_txt_record_find_key_non_empty_value: nw_txt_record_find_key_t\nThe key has an associated value."
    },
    {
        "title": "nw_txt_record_find_key_non_empty_value",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_find_key_non_empty_value",
        "html": "See Also\nKey Value Status\nvar nw_txt_record_find_key_invalid: nw_txt_record_find_key_t\nThe key is not valid.\nvar nw_txt_record_find_key_not_present: nw_txt_record_find_key_t\nThe key is not present in the dictionary.\nvar nw_txt_record_find_key_no_value: nw_txt_record_find_key_t\nThe key is present but has no associated value.\nvar nw_txt_record_find_key_empty_value: nw_txt_record_find_key_t\nThe key is present and has an empty associated value."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998519-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "NWListener.State.failed(_:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/state/failed",
        "html": "See Also\nStates\ncase setup\nThe listener has been initialized but not started.\ncase waiting(NWError)\nThe listener is waiting for a network to become available.\ncase ready\nThe listener is running and able to receive incoming connections.\ncase cancelled\nThe listener has been canceled."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/3003620-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Addresses\nstatic func == (IPv6Address, IPv6Address) -> Bool\nstatic func != (IPv6Address, IPv6Address) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "NWListener.State.cancelled",
        "url": "https://developer.apple.com/documentation/network/nwlistener/state/cancelled",
        "html": "See Also\nStates\ncase setup\nThe listener has been initialized but not started.\ncase waiting(NWError)\nThe listener is waiting for a network to become available.\ncase ready\nThe listener is running and able to receive incoming connections.\ncase failed(NWError)\nThe listener has encountered a fatal error."
    },
    {
        "title": "NWEthernetChannel.State.preparing",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state/preparing",
        "html": "See Also\nStates\ncase setup\nThe channel has been initialized but not started.\ncase waiting(NWError)\nThe channel is waiting for its interface to become available.\ncase ready\nThe channel is able to send and receive Ethernet frames.\ncase failed(NWError)\nThe channel has encountered a fatal error.\ncase cancelled\nThe channel has been canceled."
    },
    {
        "title": "nodeLocalNodes",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998534-nodelocalnodes",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv6Address\nThe unspecified address (::).\nstatic let broadcast: IPv6Address\nThe unspecified broadcast address (::).\nstatic let loopback: IPv6Address\nThe device's loopback address (::1).\nstatic let linkLocalNodes: IPv6Address\nThe multicast address for all link-local nodes (ff02::1).\nstatic let linkLocalRouters: IPv6Address\nThe multicast address for all link-local routers (ff02::2)."
    },
    {
        "title": "NWEthernetChannel.State.failed(_:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state/failed",
        "html": "See Also\nStates\ncase setup\nThe channel has been initialized but not started.\ncase waiting(NWError)\nThe channel is waiting for its interface to become available.\ncase preparing\nThe channel is registering with the interface.\ncase ready\nThe channel is able to send and receive Ethernet frames.\ncase cancelled\nThe channel has been canceled."
    },
    {
        "title": "loopback",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998532-loopback",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv6Address\nThe unspecified address (::).\nstatic let broadcast: IPv6Address\nThe unspecified broadcast address (::).\nstatic let nodeLocalNodes: IPv6Address\nThe multicast address for all local nodes (ff01::1).\nstatic let linkLocalNodes: IPv6Address\nThe multicast address for all link-local nodes (ff02::1).\nstatic let linkLocalRouters: IPv6Address\nThe multicast address for all link-local routers (ff02::2)."
    },
    {
        "title": "any",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998515-any",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let broadcast: IPv6Address\nThe unspecified broadcast address (::).\nstatic let loopback: IPv6Address\nThe device's loopback address (::1).\nstatic let nodeLocalNodes: IPv6Address\nThe multicast address for all local nodes (ff01::1).\nstatic let linkLocalNodes: IPv6Address\nThe multicast address for all link-local nodes (ff02::1).\nstatic let linkLocalRouters: IPv6Address\nThe multicast address for all link-local routers (ff02::2)."
    },
    {
        "title": "isMulticast",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998529-ismulticast",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "broadcast",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998517-broadcast",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv6Address\nThe unspecified address (::).\nstatic let loopback: IPv6Address\nThe device's loopback address (::1).\nstatic let nodeLocalNodes: IPv6Address\nThe multicast address for all local nodes (ff01::1).\nstatic let linkLocalNodes: IPv6Address\nThe multicast address for all link-local nodes (ff02::1).\nstatic let linkLocalRouters: IPv6Address\nThe multicast address for all link-local routers (ff02::2)."
    },
    {
        "title": "nw_multipath_service_aggregate",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_service_aggregate",
        "html": "See Also\nMultipath service types\nvar nw_multipath_service_disabled: nw_multipath_service_t\nDisable multipath.\nvar nw_multipath_service_handover: nw_multipath_service_t\nEnable multipath, but only use other interfaces when the primary interface is lost.\nvar nw_multipath_service_interactive: nw_multipath_service_t\nEnable multipath to use other interfaces when the primary interface encounters loss or delay."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwpath/unsatisfiedreason/3687003-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "internetProtocol",
        "url": "https://developer.apple.com/documentation/network/nwparameters/protocolstack/2998680-internetprotocol",
        "html": "See Also\nConfiguring Lower Protocols\nvar transportProtocol: NWProtocolOptions?\nThe transport protocol options used by connections and listeners."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwpath/unsatisfiedreason/3687000",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/2998643",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998535-rawvalue",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "interface",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998522-interface",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "init(applicationService:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/3952715-init",
        "html": "Parameters\napplicationService\n\nThe name of the application service. This must match the name passed to the network device picker.\n\nDiscussion\n\nUse this initializer to setup a listener for application services.\n\nApps that register as advertising an application service should always have a listener waiting for a local connection. The system launches your app when the user selects the current device in a DevicePicker or DDDevicePickerViewController. Create the listener as soon as your app launches, so that your app can connect with the requesting device."
    },
    {
        "title": "init(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998521-init",
        "html": "Discussion\n\nThe provided data is expected to be an IPv6 address of 16 bytes.\n\nRelationships\nFrom Protocol\nIPAddress\nSee Also\nCreating Addresses\ninit?(String)\nInitializes an IPv6 address with a string.\nvar asIPv4: IPv4Address?\nExtracts the IPv4 address contained within the IPv6 address, if the IPv6 address is an IPv4-mapped or IPv4-compatible address."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998520-init",
        "html": "Discussion\n\nThe provided string will be interpreted as an IPv6 address. If the string cannot be interpreted as an IPv6 address, the initialization will fail.\n\nRelationships\nFrom Protocol\nIPAddress\nSee Also\nCreating Addresses\ninit?(Data, NWInterface?)\nInitializes an IPv6 address with data.\nvar asIPv4: IPv4Address?\nExtracts the IPv4 address contained within the IPv6 address, if the IPv6 address is an IPv4-mapped or IPv4-compatible address."
    },
    {
        "title": "asIPv4",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998516-asipv4",
        "html": "See Also\nCreating Addresses\ninit?(String)\nInitializes an IPv6 address with a string.\ninit?(Data, NWInterface?)\nInitializes an IPv6 address with data."
    },
    {
        "title": "sourceFilter",
        "url": "https://developer.apple.com/documentation/network/nwmulticastgroup/3600711-sourcefilter",
        "html": "See Also\nInspecting Multicast Groups\nvar members: [NWEndpoint]\nThe set of IP multicast group addresses that the connection group joins.\nlet isUnicastDisabled: Bool\nA Boolean that specifies whether the connection group rejects unicast traffic."
    },
    {
        "title": "init(for:from:disableUnicast:)",
        "url": "https://developer.apple.com/documentation/network/nwmulticastgroup/3600708-init",
        "html": "Parameters\ngroupAddresses\n\nA set of multicast address endpoints you specify to define the IP multicast groups to join. The port indicates which local port the connection group will use to receive messages.\n\nfrom\n\nAn optional address endpoint used to filter received multicast packets.\n\ndisableUnicast\n\nA Boolean that specifies whether the connection group rejects unicast traffic."
    },
    {
        "title": "members",
        "url": "https://developer.apple.com/documentation/network/nwgroupdescriptor/3584971-members",
        "html": "Required"
    },
    {
        "title": "nw_path_status_unsatisfied",
        "url": "https://developer.apple.com/documentation/network/nw_path_status_unsatisfied",
        "html": "See Also\nStatus Values\nvar nw_path_status_invalid: nw_path_status_t\nThe path is not valid.\nvar nw_path_status_satisfied: nw_path_status_t\nThe path is available to establish connections and send data.\nvar nw_path_status_satisfiable: nw_path_status_t\nThe path is not currently available, but establishing a new connection may activate the path."
    },
    {
        "title": "nw_path_status_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_path_status_invalid",
        "html": "See Also\nStatus Values\nvar nw_path_status_unsatisfied: nw_path_status_t\nThe path is not available for use.\nvar nw_path_status_satisfied: nw_path_status_t\nThe path is available to establish connections and send data.\nvar nw_path_status_satisfiable: nw_path_status_t\nThe path is not currently available, but establishing a new connection may activate the path."
    },
    {
        "title": "nw_path_status_satisfied",
        "url": "https://developer.apple.com/documentation/network/nw_path_status_satisfied",
        "html": "See Also\nStatus Values\nvar nw_path_status_invalid: nw_path_status_t\nThe path is not valid.\nvar nw_path_status_unsatisfied: nw_path_status_t\nThe path is not available for use.\nvar nw_path_status_satisfiable: nw_path_status_t\nThe path is not currently available, but establishing a new connection may activate the path."
    },
    {
        "title": "nw_ip_version_any",
        "url": "https://developer.apple.com/documentation/network/nw_ip_version_any",
        "html": "See Also\nVersions\nvar nw_ip_version_4: nw_ip_version_t\nRequire IP version 4.\nvar nw_ip_version_6: nw_ip_version_t\nRequire IP version 6."
    },
    {
        "title": "nw_path_status_satisfiable",
        "url": "https://developer.apple.com/documentation/network/nw_path_status_satisfiable",
        "html": "See Also\nStatus Values\nvar nw_path_status_invalid: nw_path_status_t\nThe path is not valid.\nvar nw_path_status_unsatisfied: nw_path_status_t\nThe path is not available for use.\nvar nw_path_status_satisfied: nw_path_status_t\nThe path is available to establish connections and send data."
    },
    {
        "title": "nw_ip_version_4",
        "url": "https://developer.apple.com/documentation/network/nw_ip_version_4",
        "html": "See Also\nVersions\nvar nw_ip_version_any: nw_ip_version_t\nAllow any IP version.\nvar nw_ip_version_6: nw_ip_version_t\nRequire IP version 6."
    },
    {
        "title": "selectedSubprotocol",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/metadata/3200536-selectedsubprotocol",
        "html": "See Also\nInspecting Handshake Results\nvar additionalServerHeaders: [(String, String)]?\nAdditional HTTP headers sent by the server during the WebSocket handshake."
    },
    {
        "title": "setAdditionalHeaders(_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options/3200552-setadditionalheaders",
        "html": "See Also\nConfiguring Client Handshakes\nfunc setSubprotocols([String])\nAdds to the list of supported application protocols that will be presented to a WebSocket server during connection establishment.\nvar skipHandshake: Bool\nA Boolean indicating whether the WebSocket protocol skips its handshake and begins framing data once the underlying connection is established."
    },
    {
        "title": "maximumMessageSize",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options/3200551-maximummessagesize",
        "html": "See Also\nConfiguring WebSocket Options\ninit(NWProtocolWebSocket.Version)\nInitializes a default set of WebSocket connection options.\nenum NWProtocolWebSocket.Version\nSupported versions of the WebSocket protocol.\nvar autoReplyPing: Bool\nA Boolean indicating whether the connection automatically replies to Ping messages instead of delivering them to you."
    },
    {
        "title": "autoReplyPing",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options/3200549-autoreplyping",
        "html": "See Also\nConfiguring WebSocket Options\ninit(NWProtocolWebSocket.Version)\nInitializes a default set of WebSocket connection options.\nenum NWProtocolWebSocket.Version\nSupported versions of the WebSocket protocol.\nvar maximumMessageSize: Int\nThe maximum allowed message size, in bytes, to be received by the WebSocket connection."
    },
    {
        "title": "NWProtocolWebSocket.CloseCode",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/closecode",
        "html": "Topics\nClose Code Types\ninit(rawValue: UInt16)\nInitializes a close code with a raw value.\ncase protocolCode(NWProtocolWebSocket.CloseCode.Defined)\nA well-known close code reserved by the protocol (values 1000-2999).\nenum NWProtocolWebSocket.CloseCode.Defined\nWell-known close code values.\ncase applicationCode(UInt16)\nA close code in the range reserved for applications and frameworks (3000-3999).\ncase privateCode(UInt16)\nA close code in the private-use range (4000-4999).\nOperator Functions\nstatic func != (NWProtocolWebSocket.CloseCode, NWProtocolWebSocket.CloseCode) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWProtocolWebSocket.CloseCode, NWProtocolWebSocket.CloseCode) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nSending Messages\ninit(opcode: NWProtocolWebSocket.Opcode)\nInitializes a WebSocket message with a specific type code.\nenum NWProtocolWebSocket.Opcode\nTypes of messages that you send and receive on a WebSocket connection.\nfunc setPongHandler(DispatchQueue, handler: (NWError?) -> Void)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\nvar closeCode: NWProtocolWebSocket.CloseCode\nThe close code on a WebSocket message."
    },
    {
        "title": "NWProtocolWebSocket.Opcode",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/opcode",
        "html": "Topics\nData Types\ncase binary\nA binary data message.\ncase text\nA text data message.\ncase cont\nA continuation message.\nControl Types\ncase ping\nA Ping message, which requests a Pong from the peer.\ncase pong\nA Pong message in response to a Ping from the peer.\ncase close\nA message indicating a close of the connection.\nType Comparison Functions\nfunc hash(into: inout Hasher)\nvar hashValue: Int\nstatic func != (NWProtocolWebSocket.Opcode, NWProtocolWebSocket.Opcode) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nType Aliases\ntypealias NWProtocolWebSocket.Opcode.RawValue\nInitializers\ninit?(rawValue: UInt8)\nInstance Properties\nvar rawValue: UInt8\nRelationships\nConforms To\nSendable\nSee Also\nSending Messages\ninit(opcode: NWProtocolWebSocket.Opcode)\nInitializes a WebSocket message with a specific type code.\nfunc setPongHandler(DispatchQueue, handler: (NWError?) -> Void)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\nvar closeCode: NWProtocolWebSocket.CloseCode\nThe close code on a WebSocket message.\nenum NWProtocolWebSocket.CloseCode\nTypes of codes used upon closing a WebSocket connection."
    },
    {
        "title": "setPongHandler(_:handler:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/metadata/3200537-setponghandler",
        "html": "See Also\nSending Messages\ninit(opcode: NWProtocolWebSocket.Opcode)\nInitializes a WebSocket message with a specific type code.\nenum NWProtocolWebSocket.Opcode\nTypes of messages that you send and receive on a WebSocket connection.\nvar closeCode: NWProtocolWebSocket.CloseCode\nThe close code on a WebSocket message.\nenum NWProtocolWebSocket.CloseCode\nTypes of codes used upon closing a WebSocket connection."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options/3200550-init",
        "html": "See Also\nConfiguring WebSocket Options\nenum NWProtocolWebSocket.Version\nSupported versions of the WebSocket protocol.\nvar autoReplyPing: Bool\nA Boolean indicating whether the connection automatically replies to Ping messages instead of delivering them to you.\nvar maximumMessageSize: Int\nThe maximum allowed message size, in bytes, to be received by the WebSocket connection."
    },
    {
        "title": "keepAlive",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802955-keepalive",
        "html": "See Also\nConfiguring Keepalives\nenum NWProtocolQUIC.Metadata.KeepAliveBehavior\nA QUIC connection keepalive behavior."
    },
    {
        "title": "streamApplicationErrorCode",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802962-streamapplicationerrorcode",
        "html": "See Also\nHandling Errors\nvar applicationError: NWProtocolQUIC.ApplicationError\nThe QUIC application error code to send for the connection, or received from the peer.\nstruct NWProtocolQUIC.ApplicationError\nA QUIC application error code."
    },
    {
        "title": "NWProtocolQUIC.ApplicationError",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/applicationerror",
        "html": "Topics\nConfiguring Application Errors\ninit(code: UInt64, reason: String?)\nInitializes a QUIC application error with an error code and an optional reason.\ninit(integerLiteral: UInt64)\nInitializes a QUIC application error with an integer literal error code.\nInspecting Application Errors\nlet code: UInt64\nThe QUIC application error code.\nlet reason: String?\nThe QUIC application error reason.\ntypealias NWProtocolQUIC.ApplicationError.IntegerLiteralType\nThe QUIC application error code as an integer literal.\nRelationships\nConforms To\nExpressibleByIntegerLiteral\nSendable\nSee Also\nHandling Errors\nvar applicationError: NWProtocolQUIC.ApplicationError\nThe QUIC application error code to send for the connection, or received from the peer.\nvar streamApplicationErrorCode: UInt64\nThe QUIC application error code to send for the stream, or received from the peer."
    },
    {
        "title": "NWInterface.InterfaceType.loopback",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/loopback",
        "html": "See Also\nInterface Types\ncase wifi\nThe network interface type used for communication over Wi-Fi networks.\ncase cellular\nThe network interface type used for communication over cellular networks.\ncase wiredEthernet\nThe network interface type used for communication over wired Ethernet networks.\ncase other\nThe network interface type used for communication over virtual networks or networks of unknown types."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/3236832-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "NWInterface.InterfaceType.other",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/other",
        "html": "See Also\nInterface Types\ncase wifi\nThe network interface type used for communication over Wi-Fi networks.\ncase cellular\nThe network interface type used for communication over cellular networks.\ncase wiredEthernet\nThe network interface type used for communication over wired Ethernet networks.\ncase loopback\nThe network interface type used for communication over local loopback networks."
    },
    {
        "title": "idleTimeout",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802974-idletimeout",
        "html": "See Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "streamIdentifier",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802963-streamidentifier",
        "html": "See Also\nInspecting Stream State\nvar usableDatagramFrameSize: Int\nThe maximum usable size of a datagram frame on a QUIC datagram flow."
    },
    {
        "title": "applicationError",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802954-applicationerror",
        "html": "See Also\nHandling Errors\nstruct NWProtocolQUIC.ApplicationError\nA QUIC application error code.\nvar streamApplicationErrorCode: UInt64\nThe QUIC application error code to send for the stream, or received from the peer."
    },
    {
        "title": "NWInterface.InterfaceType.wiredEthernet",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/wiredethernet",
        "html": "See Also\nInterface Types\ncase wifi\nThe network interface type used for communication over Wi-Fi networks.\ncase cellular\nThe network interface type used for communication over cellular networks.\ncase loopback\nThe network interface type used for communication over local loopback networks.\ncase other\nThe network interface type used for communication over virtual networks or networks of unknown types."
    },
    {
        "title": "usableDatagramFrameSize",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3952718-usabledatagramframesize",
        "html": "See Also\nInspecting Stream State\nvar streamIdentifier: UInt64\nThe QUIC stream identifier."
    },
    {
        "title": "securityProtocolMetadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802961-securityprotocolmetadata",
        "html": "See Also\nInspecting Connection State\nvar negotiatedALPN: String?\nThe Application-Layer Protocol Negotiation value used when establishing the connection.\nvar localMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams that the peer can create on a QUIC connection.\nvar localMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteIdleTimeout: Int\nThe idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "localMaxStreamsUnidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802957-localmaxstreamsunidirectional",
        "html": "See Also\nInspecting Connection State\nvar negotiatedALPN: String?\nThe Application-Layer Protocol Negotiation value used when establishing the connection.\nvar localMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteIdleTimeout: Int\nThe idle timeout value from the peer\u2019s transport parameters, in milliseconds.\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the QUIC handshake."
    },
    {
        "title": "availableSendBuffer",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/metadata/2998771-availablesendbuffer",
        "html": "See Also\nInspecting TCP State\nvar availableReceiveBuffer: UInt32\nThe number of available bytes in the TCP receive buffer."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwpath/unsatisfiedreason/3687004-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3204137-init",
        "html": "See Also\nCreating Addresses\ninit?(Data)\nInitializes an Ethernet address with data."
    },
    {
        "title": "nw_txt_record_find_key_invalid",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_find_key_invalid",
        "html": "See Also\nKey Value Status\nvar nw_txt_record_find_key_not_present: nw_txt_record_find_key_t\nThe key is not present in the dictionary.\nvar nw_txt_record_find_key_no_value: nw_txt_record_find_key_t\nThe key is present but has no associated value.\nvar nw_txt_record_find_key_empty_value: nw_txt_record_find_key_t\nThe key is present and has an empty associated value.\nvar nw_txt_record_find_key_non_empty_value: nw_txt_record_find_key_t\nThe key has an associated value."
    },
    {
        "title": "NWEthernetChannel.State.ready",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state/ready",
        "html": "See Also\nStates\ncase setup\nThe channel has been initialized but not started.\ncase waiting(NWError)\nThe channel is waiting for its interface to become available.\ncase preparing\nThe channel is registering with the interface.\ncase failed(NWError)\nThe channel has encountered a fatal error.\ncase cancelled\nThe channel has been canceled."
    },
    {
        "title": "NWListener.State.setup",
        "url": "https://developer.apple.com/documentation/network/nwlistener/state/setup",
        "html": "See Also\nStates\ncase waiting(NWError)\nThe listener is waiting for a network to become available.\ncase ready\nThe listener is running and able to receive incoming connections.\ncase failed(NWError)\nThe listener has encountered a fatal error.\ncase cancelled\nThe listener has been canceled."
    },
    {
        "title": "NWEthernetChannel.State.cancelled",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state/cancelled",
        "html": "See Also\nStates\ncase setup\nThe channel has been initialized but not started.\ncase waiting(NWError)\nThe channel is waiting for its interface to become available.\ncase preparing\nThe channel is registering with the interface.\ncase ready\nThe channel is able to send and receive Ethernet frames.\ncase failed(NWError)\nThe channel has encountered a fatal error."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998506",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Addresses\nstatic func == (IPv6Address, IPv6Address) -> Bool\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "linkLocalRouters",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998531-linklocalrouters",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv6Address\nThe unspecified address (::).\nstatic let broadcast: IPv6Address\nThe unspecified broadcast address (::).\nstatic let loopback: IPv6Address\nThe device's loopback address (::1).\nstatic let nodeLocalNodes: IPv6Address\nThe multicast address for all local nodes (ff01::1).\nstatic let linkLocalNodes: IPv6Address\nThe multicast address for all link-local nodes (ff02::1)."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998507",
        "html": "See Also\nComparing Addresses\nstatic func != (IPv6Address, IPv6Address) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "linkLocalNodes",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998530-linklocalnodes",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv6Address\nThe unspecified address (::).\nstatic let broadcast: IPv6Address\nThe unspecified broadcast address (::).\nstatic let loopback: IPv6Address\nThe device's loopback address (::1).\nstatic let nodeLocalNodes: IPv6Address\nThe multicast address for all local nodes (ff01::1).\nstatic let linkLocalRouters: IPv6Address\nThe multicast address for all link-local routers (ff02::2)."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998518-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address."
    },
    {
        "title": "isLinkLocal",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998527-islinklocal",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "isLoopback",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998528-isloopback",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "IPv6Address.Scope",
        "url": "https://developer.apple.com/documentation/network/ipv6address/scope",
        "html": "Topics\nScope Values\ncase nodeLocal\nThe node-local multicast scope.\ncase linkLocal\nThe link-local multicast scope.\ncase siteLocal\nThe site-local multicast scope.\ncase organizationLocal\nThe organization-local multicast scope.\ncase global\nThe global multicast scope.\nComparison Functions\nstatic func != (IPv6Address.Scope, IPv6Address.Scope) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int\nType Aliases\ntypealias IPv6Address.Scope.RawValue\nInitializers\ninit?(rawValue: UInt8)\nInstance Properties\nvar rawValue: UInt8\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "isIPv4Mapped",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998526-isipv4mapped",
        "html": "See Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "isIPv4Compatabile",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998525-isipv4compatabile",
        "html": "See Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "multicastScope",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998533-multicastscope",
        "html": "See Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "isAny",
        "url": "https://developer.apple.com/documentation/network/ipv6address/2998524-isany",
        "html": "See Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "members",
        "url": "https://developer.apple.com/documentation/network/nwmulticastgroup/3600710-members",
        "html": "Relationships\nFrom Protocol\nNWGroupDescriptor\nSee Also\nInspecting Multicast Groups\nlet sourceFilter: NWEndpoint?\nAn optional address endpoint you provide to filter received multicast packets.\nlet isUnicastDisabled: Bool\nA Boolean that specifies whether the connection group rejects unicast traffic."
    },
    {
        "title": "isUnicastDisabled",
        "url": "https://developer.apple.com/documentation/network/nwmulticastgroup/3600709-isunicastdisabled",
        "html": "See Also\nInspecting Multicast Groups\nvar members: [NWEndpoint]\nThe set of IP multicast group addresses that the connection group joins.\nlet sourceFilter: NWEndpoint?\nAn optional address endpoint you provide to filter received multicast packets."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/2998644-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Services\nlet name: String?\nThe Bonjour name of the service.\nlet type: String\nThe Bonjour type of the service.\nlet domain: String?\nThe Bonjour domain of the service.\nvar txtRecordObject: NWTXTRecord?\nThe TXT record to advertise with the service.\nlet txtRecord: Data?\nThe TXT record as a raw buffer to advertise with the service."
    },
    {
        "title": "noAutoRename",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/3200458-noautorename",
        "html": "See Also\nDefining Services\ninit(name: String?, type: String, domain: String?, txtRecord: Data?)\nInitializes a Bonjour service to advertise.\ninit(name: String?, type: String, domain: String?, txtRecord: NWTXTRecord)\nInitializes a Bonjour service to advertise with a TXT record."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwpath/status/2998716",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwpath/status/3236844-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "maxUDPPayloadSize",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802983-maxudppayloadsize",
        "html": "See Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "NWInterface.RadioType.Cellular",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype/cellular",
        "html": "Topics\nEnumeration Cases\ncase cdma\ncase dualConnectivity5G(NWInterface.RadioType.Cellular.NewRadio5GVariant)\ncase evdo\ncase gsm\ncase lte\ncase standalone5G(NWInterface.RadioType.Cellular.NewRadio5GVariant)\ncase wcdma\nEnumerations\nenum NWInterface.RadioType.Cellular.NewRadio5GVariant\nRelationships\nConforms To\nSendable"
    },
    {
        "title": "maxDatagramFrameSize",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3952720-maxdatagramframesize",
        "html": "Discussion\n\nThis property determines the value of the max_datagram_frame_size transport parameter.\n\nSee Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "initialMaxStreamsBidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802981-initialmaxstreamsbidirectional",
        "html": "Discussion\n\nThis property determines the value of the initial_max_stream_bidi transport parameter.\n\nSee Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "initialMaxStreamsUnidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802982-initialmaxstreamsunidirectional",
        "html": "Discussion\n\nThis property determines the value of the initial_max_stream_uni transport parameter.\n\nSee Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "initialMaxStreamDataUnidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802980-initialmaxstreamdataunidirection",
        "html": "Discussion\n\nThis property determines the value of the initial_max_stream_data_uni transport parameter.\n\nSee Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "initialMaxStreamDataBidirectionalRemote",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802979-initialmaxstreamdatabidirectiona",
        "html": "Discussion\n\nThis property determines the value of the initial_max_stream_data_bidi_remote transport parameter.\n\nSee Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "initialMaxData",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802977-initialmaxdata",
        "html": "Discussion\n\nThis property determines the value of the initial_max_data transport parameter.\n\nSee Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "alpn",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802972-alpn",
        "html": "See Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "init(alpn:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802976-init",
        "html": "Parameters\nalpn\n\nA set of supported Application-Layer Protocol Negotiation values.\n\nSee Also\nCustomizing Connection Options\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "applicationProtocols",
        "url": "https://developer.apple.com/documentation/network/nwparameters/protocolstack/2998679-applicationprotocols",
        "html": "Discussion\n\nThe array of application protocols is ordered with the closest to the application first, and the closest to the transport protocol last. For example, if you want to run the WebSocket protocol over TLS, the WebSocket protocol should come first, and the TLS protocol should come second."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/3236831-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "NWProtocolQUIC.Metadata.KeepAliveBehavior",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/keepalivebehavior",
        "html": "Topics\nKeepalive Behaviors\ncase on\nKeepalives are enabled with the default timeout.\ncase off\nKeepalives are disabled.\ncase seconds(Int)\nKeepalives are enabled with a custom timeout, in seconds.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring Keepalives\nvar keepAlive: NWProtocolQUIC.Metadata.KeepAliveBehavior\nThe QUIC connection keepalive behavior."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype/2998630",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "remoteMaxStreamsUnidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802960-remotemaxstreamsunidirectional",
        "html": "See Also\nInspecting Connection State\nvar negotiatedALPN: String?\nThe Application-Layer Protocol Negotiation value used when establishing the connection.\nvar localMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams that the peer can create on a QUIC connection.\nvar localMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteIdleTimeout: Int\nThe idle timeout value from the peer\u2019s transport parameters, in milliseconds.\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the QUIC handshake."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3204134-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Addresses\nvar rawValue: Data\nThe raw data of the Ethernet address.\nstatic func == (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nstatic func != (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "NWParameters.PrivacyContext.ResolverConfiguration",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/resolverconfiguration",
        "html": "Topics\nResolver Types\ncase https(URL, serverAddresses: [NWEndpoint])\nA DNS-over-HTTPS resolver configuration.\ncase tls(NWEndpoint, serverAddresses: [NWEndpoint])\nA DNS-over-TLS resolver configuration.\nInspecting Resolvers\nvar debugDescription: String\nThe description of the resolver.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nRequiring Encrypted DNS\nfunc requireEncryptedNameResolution(Bool, fallbackResolver: NWParameters.PrivacyContext.ResolverConfiguration?)\nRequires that any DNS name resolution for connections associated with this context use encrypted transports, such as TLS or HTTPS."
    },
    {
        "title": "remoteIdleTimeout",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802958-remoteidletimeout",
        "html": "See Also\nInspecting Connection State\nvar negotiatedALPN: String?\nThe Application-Layer Protocol Negotiation value used when establishing the connection.\nvar localMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams that the peer can create on a QUIC connection.\nvar localMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the QUIC handshake."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3204135-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nInspecting Addresses\nvar rawValue: Data\nThe raw data of the Ethernet address.\nvar debugDescription: String\nThe description of the Ethernet address.\nstatic func == (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nstatic func != (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "remoteMaxStreamsBidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802959-remotemaxstreamsbidirectional",
        "html": "See Also\nInspecting Connection State\nvar negotiatedALPN: String?\nThe Application-Layer Protocol Negotiation value used when establishing the connection.\nvar localMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams that the peer can create on a QUIC connection.\nvar localMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteIdleTimeout: Int\nThe idle timeout value from the peer\u2019s transport parameters, in milliseconds.\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the QUIC handshake."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3204132",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nInspecting Addresses\nvar rawValue: Data\nThe raw data of the Ethernet address.\nvar debugDescription: String\nThe description of the Ethernet address.\nstatic func == (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "localMaxStreamsBidirectional",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3802956-localmaxstreamsbidirectional",
        "html": "See Also\nInspecting Connection State\nvar negotiatedALPN: String?\nThe Application-Layer Protocol Negotiation value used when establishing the connection.\nvar localMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteIdleTimeout: Int\nThe idle timeout value from the peer\u2019s transport parameters, in milliseconds.\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the QUIC handshake."
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3204138-rawvalue",
        "html": "See Also\nInspecting Addresses\nvar debugDescription: String\nThe description of the Ethernet address.\nstatic func == (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nstatic func != (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "availableReceiveBuffer",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/metadata/2998770-availablereceivebuffer",
        "html": "See Also\nInspecting TCP State\nvar availableSendBuffer: UInt32\nThe number of available bytes in the TCP send buffer."
    },
    {
        "title": "NWEthernetChannel.State.waiting(_:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state/waiting",
        "html": "See Also\nStates\ncase setup\nThe channel has been initialized but not started.\ncase preparing\nThe channel is registering with the interface.\ncase ready\nThe channel is able to send and receive Ethernet frames.\ncase failed(NWError)\nThe channel has encountered a fatal error.\ncase cancelled\nThe channel has been canceled."
    },
    {
        "title": "NWEthernetChannel.State.setup",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state/setup",
        "html": "See Also\nStates\ncase waiting(NWError)\nThe channel is waiting for its interface to become available.\ncase preparing\nThe channel is registering with the interface.\ncase ready\nThe channel is able to send and receive Ethernet frames.\ncase failed(NWError)\nThe channel has encountered a fatal error.\ncase cancelled\nThe channel has been canceled."
    },
    {
        "title": "txtRecord",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/2998648-txtrecord",
        "html": "See Also\nInspecting Services\nlet name: String?\nThe Bonjour name of the service.\nlet type: String\nThe Bonjour type of the service.\nlet domain: String?\nThe Bonjour domain of the service.\nvar txtRecordObject: NWTXTRecord?\nThe TXT record to advertise with the service.\nvar debugDescription: String\nThe description of the service."
    },
    {
        "title": "txtRecordObject",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/3200459-txtrecordobject",
        "html": "See Also\nInspecting Services\nlet name: String?\nThe Bonjour name of the service.\nlet type: String\nThe Bonjour type of the service.\nlet domain: String?\nThe Bonjour domain of the service.\nlet txtRecord: Data?\nThe TXT record as a raw buffer to advertise with the service.\nvar debugDescription: String\nThe description of the service."
    },
    {
        "title": "name",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/2998647-name",
        "html": "See Also\nInspecting Services\nlet type: String\nThe Bonjour type of the service.\nlet domain: String?\nThe Bonjour domain of the service.\nvar txtRecordObject: NWTXTRecord?\nThe TXT record to advertise with the service.\nlet txtRecord: Data?\nThe TXT record as a raw buffer to advertise with the service.\nvar debugDescription: String\nThe description of the service."
    },
    {
        "title": "type",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/2998649-type",
        "html": "See Also\nInspecting Services\nlet name: String?\nThe Bonjour name of the service.\nlet domain: String?\nThe Bonjour domain of the service.\nvar txtRecordObject: NWTXTRecord?\nThe TXT record to advertise with the service.\nlet txtRecord: Data?\nThe TXT record as a raw buffer to advertise with the service.\nvar debugDescription: String\nThe description of the service."
    },
    {
        "title": "init(name:type:domain:txtRecord:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/2998646-init",
        "html": "Discussion\n\nAdvertised services are primarily defined by their types. If you do not specify a service name, the device name will be chosen. You should not specify a Bonjour domain unless you know you need to advertise only on a particular domain.\n\nSee Also\nDefining Services\ninit(name: String?, type: String, domain: String?, txtRecord: NWTXTRecord)\nInitializes a Bonjour service to advertise with a TXT record.\nvar noAutoRename: Bool\nA Boolean that indicates whether the service prohibits automatic renaming in the event of a name conflict."
    },
    {
        "title": "nw_parameters_attribution_t.user",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_attribution_t/user",
        "html": "Discussion\n\nUse this value for the attribution parameter of a call to the nw_parameters_get_attribution(_:) method when constructing a network request that satisfies a user request to access an explicit, unmodified URL. In all other cases, use the nw_parameters_attribution_t.developer value instead.\n\nSee Also\nRequest Sources\ncase developer\nA developer-initiated network request."
    },
    {
        "title": "NWPath.Status.satisfied",
        "url": "https://developer.apple.com/documentation/network/nwpath/status/satisfied",
        "html": "See Also\nStatus Values\ncase unsatisfied\nThe path is not available for use.\ncase requiresConnection\nThe path is not currently available, but establishing a new connection may activate the path."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwpath/status/3236845-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "NWPath.Status.requiresConnection",
        "url": "https://developer.apple.com/documentation/network/nwpath/status/requiresconnection",
        "html": "See Also\nStatus Values\ncase unsatisfied\nThe path is not available for use.\ncase satisfied\nThe path is available to establish connections and send data."
    },
    {
        "title": "NWPath.Status.unsatisfied",
        "url": "https://developer.apple.com/documentation/network/nwpath/status/unsatisfied",
        "html": "See Also\nStatus Values\ncase satisfied\nThe path is available to establish connections and send data.\ncase requiresConnection\nThe path is not currently available, but establishing a new connection may activate the path."
    },
    {
        "title": "skipHandshake",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options/3200555-skiphandshake",
        "html": "Discussion\n\nThis option should not be set when communicating with a generic WebSocket server or client. This option allows a custom handshake (or no handshake) to be implemented below the WebSocket layer when both client and server are coordinated.\n\nSee Also\nConfiguring Client Handshakes\nfunc setAdditionalHeaders([(name: String, value: String)])\nSets additional HTTP header fields to be sent by the client during the WebSocket handshake.\nfunc setSubprotocols([String])\nAdds to the list of supported application protocols that will be presented to a WebSocket server during connection establishment."
    },
    {
        "title": "setClientRequestHandler(_:handler:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options/3200553-setclientrequesthandler",
        "html": "See Also\nHandling Server Handshakes\nstruct NWProtocolWebSocket.Response\nA WebSocket handshake reponse sent from a server to a client."
    },
    {
        "title": "additionalServerHeaders",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/metadata/3200532-additionalserverheaders",
        "html": "See Also\nInspecting Handshake Results\nvar selectedSubprotocol: String?\nThe subprotocol selected by the server during the WebSocket handshake."
    },
    {
        "title": "NWProtocolWebSocket.Response",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/response",
        "html": "Topics\nSending Handshake Responses\ninit(status: NWProtocolWebSocket.Response.Status, subprotocol: String?, additionalHeaders: [(name: String, value: String)]?)\nInitializes a WebSocket server response with a status, selected subprotocol, and additional HTTP headers.\nenum NWProtocolWebSocket.Response.Status\nStatus values that are sent with a WebSocket server response.\nlet status: NWProtocolWebSocket.Response.Status\nThe status of a WebSocket server response.\nlet subprotocol: String?\nThe selected subprotocol in a WebSocket server response.\nlet additionalHeaders: [(name: String, value: String)]?\nAny additional HTTP headers in a WebSocket server response.\nRelationships\nConforms To\nSendable\nSee Also\nHandling Server Handshakes\nfunc setClientRequestHandler(DispatchQueue, handler: ([String], [(name: String, value: String)]) -> NWProtocolWebSocket.Response)\nSets a handler to react to as a server to inbound WebSocket client handshakes."
    },
    {
        "title": "setSubprotocols(_:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options/3200554-setsubprotocols",
        "html": "See Also\nConfiguring Client Handshakes\nfunc setAdditionalHeaders([(name: String, value: String)])\nSets additional HTTP header fields to be sent by the client during the WebSocket handshake.\nvar skipHandshake: Bool\nA Boolean indicating whether the WebSocket protocol skips its handshake and begins framing data once the underlying connection is established."
    },
    {
        "title": "negotiatedALPN",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata/3822250-negotiatedalpn",
        "html": "See Also\nInspecting Connection State\nvar localMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams that the peer can create on a QUIC connection.\nvar localMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteIdleTimeout: Int\nThe idle timeout value from the peer\u2019s transport parameters, in milliseconds.\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the QUIC handshake."
    },
    {
        "title": "NWConnectionGroup.State.cancelled",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/state/cancelled",
        "html": "See Also\nStates\ncase setup\nYou have not yet started the connection group.\ncase waiting(NWError)\nThe connection group is waiting for a network path change.\ncase ready\nThe connection group is joined, and ready to send and receive data.\ncase failed(NWError)\nThe connection group encountered a fatal error."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3238020-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "init(identifier:expiration:priority:isFinal:antecedent:metadata:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message/3584946-init",
        "html": "See Also\nSending Messages\nstatic let `default`: NWConnectionGroup.Message\nA static object you use to send a message with default properties."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998488",
        "html": "See Also\nComparing Addresses\nstatic func != (IPv4Address, IPv4Address) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/ipv4address/3003619-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Addresses\nstatic func == (IPv4Address, IPv4Address) -> Bool\nstatic func != (IPv4Address, IPv4Address) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "NWProtocolWebSocket.Version",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/version",
        "html": "Topics\nVersions\ncase version13\nVersion 13 of the WebSocket protocol.\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWProtocolWebSocket.Version, NWProtocolWebSocket.Version) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWProtocolWebSocket.Version, NWProtocolWebSocket.Version) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring WebSocket Options\ninit(NWProtocolWebSocket.Version)\nInitializes a default set of WebSocket connection options.\nvar autoReplyPing: Bool\nA Boolean indicating whether the connection automatically replies to Ping messages instead of delivering them to you.\nvar maximumMessageSize: Int\nThe maximum allowed message size, in bytes, to be received by the WebSocket connection."
    },
    {
        "title": "persistTimeout",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998787-persisttimeout",
        "html": "See Also\nSetting Timeouts\nvar connectionTimeout: Int\nThe number of seconds that TCP waits before timing out its handshake.\nvar connectionDropTime: Int\nThe timeout, in seconds, for TCP retransmission attempts."
    },
    {
        "title": "mdnsGroup",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998503-mdnsgroup",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv4Address\nThe unspecified address (0.0.0.0).\nstatic let broadcast: IPv4Address\nThe local broadcast address (255.255.255.255).\nstatic let loopback: IPv4Address\nThe device's loopback address (127.0.0.1).\nstatic let allHostsGroup: IPv4Address\nThe multicast group for all hosts on the network segment (224.0.0.1).\nstatic let allRoutersGroup: IPv4Address\nThe multicast group for all routers on the network segment (224.0.0.2).\nstatic let allReportsGroup: IPv4Address\nThe multicast group for all IGMPv3 reports (224.0.0.22)."
    },
    {
        "title": "nw_parameters_attribution_t.developer",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_attribution_t/developer",
        "html": "Discussion\n\nUse this value for the attribution parameter of a call to the nw_parameters_get_attribution(_:) method when creating a network request for any purpose other than when the user explicitly accesses a link. This includes requests that your app makes to get user data. This is the default value.\n\nFor cases where the user enters a URL, like in the navigation bar of a web browser, or taps or clicks a URL to load the content it represents, use the nw_parameters_attribution_t.user value instead.\n\nSee Also\nRequest Sources\ncase user\nThe user explicitly directs the app to make a network request."
    },
    {
        "title": "init(opcode:)",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/metadata/3200534-init",
        "html": "See Also\nSending Messages\nenum NWProtocolWebSocket.Opcode\nTypes of messages that you send and receive on a WebSocket connection.\nfunc setPongHandler(DispatchQueue, handler: (NWError?) -> Void)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\nvar closeCode: NWProtocolWebSocket.CloseCode\nThe close code on a WebSocket message.\nenum NWProtocolWebSocket.CloseCode\nTypes of codes used upon closing a WebSocket connection."
    },
    {
        "title": "remoteEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message/3584949-remoteendpoint",
        "html": "See Also\nInspecting Received Messages\nvar localEndpoint: NWEndpoint?\nThe local address and port you use to receive the message.\nvar path: NWPath?\nThe network path on which you receive the message."
    },
    {
        "title": "preferNoChecksum",
        "url": "https://developer.apple.com/documentation/network/nwprotocoludp/options/2998802-prefernochecksum",
        "html": "Discussion\n\nUDP checksums are optional when the datagrams are sent over IPv4. This option configures UDP to not set checksums on these datagrams, but has no effect on IPv6.\n\nSee Also\nCustomizing UDP Connections\ninit()\nInitializes a default set of UDP connection options."
    },
    {
        "title": "flushCache()",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/3548849-flushcache",
        "html": "Discussion\n\nFlushing the cache may be asynchronous, which means that it will take effect shortly after you invoke the function.\n\nSee Also\nConfiguring Custom Privacy Settings\ninit(description: String)\nInitializes a privacy context with a description string.\nstatic let `default`: NWParameters.PrivacyContext\nThe privacy context that applies to all connections that do not use a custom context.\nfunc disableLogging()\nDisables system logging of connection activity.\nvar debugDescription: String\nThe description string you provide when creating the context."
    },
    {
        "title": "disableLogging()",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/3548848-disablelogging",
        "html": "See Also\nConfiguring Custom Privacy Settings\ninit(description: String)\nInitializes a privacy context with a description string.\nstatic let `default`: NWParameters.PrivacyContext\nThe privacy context that applies to all connections that do not use a custom context.\nfunc flushCache()\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context.\nvar debugDescription: String\nThe description string you provide when creating the context."
    },
    {
        "title": "default",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/3580282-default",
        "html": "Discussion\n\nYou cannot disable logging on the default privacy context.\n\nFlushing the cache on the default privacy context will not affect other privacy contexts.\n\nChanging name resolution settings will only affect privacy contexts that did not already explicitly configure resolution requirements.\n\nSee Also\nConfiguring Custom Privacy Settings\ninit(description: String)\nInitializes a privacy context with a description string.\nfunc disableLogging()\nDisables system logging of connection activity.\nfunc flushCache()\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context.\nvar debugDescription: String\nThe description string you provide when creating the context."
    },
    {
        "title": "requireEncryptedNameResolution(_:fallbackResolver:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/3548851-requireencryptednameresolution",
        "html": "Parameters\nrequireEncryption\n\nA Boolean that indicates whether your connections prohibits unencrypted name resolution.\n\nfallbackResolver\n\nAn encrypted DNS resolver configuration that your connections use if the system doesn\u2019t have a preferred encrypted resolver.\n\nDiscussion\n\nConnections that use iCloud Private Relay automatically use encrypted name resolution. When active, name resolution uses iCloud Private Relay instead of the fallbackResolver.\n\nSee Also\nRequiring Encrypted DNS\nenum NWParameters.PrivacyContext.ResolverConfiguration\nA DNS server configuration that uses TLS or HTTPS."
    },
    {
        "title": "ProxyConfiguration",
        "url": "https://developer.apple.com/documentation/network/proxyconfiguration",
        "html": "Topics\nCreating Proxy Configurations\ninit(relayHops: [ProxyConfiguration.RelayHop])\nInitializes a proxy configuration with one or two relay hops.\nstruct ProxyConfiguration.RelayHop\nA single relay server you can chain together with other servers.\ninit(httpCONNECTProxy: NWEndpoint, tlsOptions: NWProtocolTLS.Options?)\nInitializes a legacy HTTP CONNECT configuration for a proxy server accessible using HTTP/1.1.\ninit(socksv5Proxy: NWEndpoint)\nInitializes a SOCKSv5 proxy configuration.\nCustomizing Proxy Behavior\nvar allowFailover: Bool\nA Boolean that indicates whether or not a proxy configuration allows failover to non-proxied connections. Failover isn\u2019t allowed by default.\nfunc applyCredential(username: String, password: String)\nSets a username and password to use as authentication for a proxy configuration.\nInspecting Proxies\nvar debugDescription: String\nThe description of the proxy configuration.\nInitializers\ninit(obliviousHTTPRelay: ProxyConfiguration.RelayHop, relayResourcePath: String, gatewayKeyConfig: Data, matchDomains: [String])\nInstance Properties\nvar excludedDomains: [String]\nvar matchDomains: [String]\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nConfiguring Proxies\nvar proxyConfigurations: [ProxyConfiguration]\nApplies proxy configurations for all connections associated with this context."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/3548846-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nConfiguring Custom Privacy Settings\ninit(description: String)\nInitializes a privacy context with a description string.\nstatic let `default`: NWParameters.PrivacyContext\nThe privacy context that applies to all connections that do not use a custom context.\nfunc disableLogging()\nDisables system logging of connection activity.\nfunc flushCache()\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context."
    },
    {
        "title": "proxyConfigurations",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/4156642-proxyconfigurations",
        "html": "See Also\nConfiguring Proxies\nstruct ProxyConfiguration\nA proxy configuration for Relays, Oblivious HTTP, HTTP CONNECT, or SOCKSv5."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress/3204133",
        "html": "See Also\nInspecting Addresses\nvar rawValue: Data\nThe raw data of the Ethernet address.\nvar debugDescription: String\nThe description of the Ethernet address.\nstatic func != (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "init(description:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext/3548850-init",
        "html": "See Also\nConfiguring Custom Privacy Settings\nstatic let `default`: NWParameters.PrivacyContext\nThe privacy context that applies to all connections that do not use a custom context.\nfunc disableLogging()\nDisables system logging of connection activity.\nfunc flushCache()\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context.\nvar debugDescription: String\nThe description string you provide when creating the context."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state/3204140",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "NWListener.State.ready",
        "url": "https://developer.apple.com/documentation/network/nwlistener/state/ready",
        "html": "See Also\nStates\ncase setup\nThe listener has been initialized but not started.\ncase waiting(NWError)\nThe listener is waiting for a network to become available.\ncase failed(NWError)\nThe listener has encountered a fatal error.\ncase cancelled\nThe listener has been canceled."
    },
    {
        "title": "NWListener.State.waiting(_:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/state/waiting",
        "html": "See Also\nStates\ncase setup\nThe listener has been initialized but not started.\ncase ready\nThe listener is running and able to receive incoming connections.\ncase failed(NWError)\nThe listener has encountered a fatal error.\ncase cancelled\nThe listener has been canceled."
    },
    {
        "title": "domain",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/2998645-domain",
        "html": "See Also\nInspecting Services\nlet name: String?\nThe Bonjour name of the service.\nlet type: String\nThe Bonjour type of the service.\nvar txtRecordObject: NWTXTRecord?\nThe TXT record to advertise with the service.\nlet txtRecord: Data?\nThe TXT record as a raw buffer to advertise with the service.\nvar debugDescription: String\nThe description of the service."
    },
    {
        "title": "init(name:type:domain:txtRecord:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service/3200457-init",
        "html": "Discussion\n\nAdvertised services are primarily defined by their types. If you do not specify a service name, the device name will be chosen. You should not specify a Bonjour domain unless you know you need to advertise only on a particular domain.\n\nSee Also\nDefining Services\ninit(name: String?, type: String, domain: String?, txtRecord: Data?)\nInitializes a Bonjour service to advertise.\nvar noAutoRename: Bool\nA Boolean that indicates whether the service prohibits automatic renaming in the event of a name conflict."
    },
    {
        "title": "init(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipaddress/2998480-init",
        "html": "Required\n\nDiscussion\n\nThe provided data is expected to be either an IPv4 address of 4 bytes or an IPv6 address of 16 bytes.\n\nSee Also\nCreating Addresses\ninit?(String)\nInitializes an IP address with a string.\n\nRequired"
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/2998586-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/3129511-hashvalue",
        "html": "See Also\nComparing Ports\nvar rawValue: UInt16\nvar debugDescription: String\nstatic func != (NWEndpoint.Port, NWEndpoint.Port) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/attribution/3822245",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/attribution/3876115-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "any",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998492-any",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let broadcast: IPv4Address\nThe local broadcast address (255.255.255.255).\nstatic let loopback: IPv4Address\nThe device's loopback address (127.0.0.1).\nstatic let allHostsGroup: IPv4Address\nThe multicast group for all hosts on the network segment (224.0.0.1).\nstatic let allRoutersGroup: IPv4Address\nThe multicast group for all routers on the network segment (224.0.0.2).\nstatic let allReportsGroup: IPv4Address\nThe multicast group for all IGMPv3 reports (224.0.0.22).\nstatic let mdnsGroup: IPv4Address\nThe multicast group for multicast DNS (224.0.0.251)."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwparameters/attribution/3876116-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "connectionDropTime",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998773-connectiondroptime",
        "html": "See Also\nSetting Timeouts\nvar connectionTimeout: Int\nThe number of seconds that TCP waits before timing out its handshake.\nvar persistTimeout: Int\nThe TCP persist timeout, in seconds, as defined by RFC 6429."
    },
    {
        "title": "NWConnectionGroup.State.waiting(_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/state/waiting",
        "html": "See Also\nStates\ncase setup\nYou have not yet started the connection group.\ncase ready\nThe connection group is joined, and ready to send and receive data.\ncase failed(NWError)\nThe connection group encountered a fatal error.\ncase cancelled\nThe connection group has been canceled."
    },
    {
        "title": "NWConnectionGroup.State.failed(_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/state/failed",
        "html": "See Also\nStates\ncase setup\nYou have not yet started the connection group.\ncase waiting(NWError)\nThe connection group is waiting for a network path change.\ncase ready\nThe connection group is joined, and ready to send and receive data.\ncase cancelled\nThe connection group has been canceled."
    },
    {
        "title": "NWConnectionGroup.State.ready",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/state/ready",
        "html": "See Also\nStates\ncase setup\nYou have not yet started the connection group.\ncase waiting(NWError)\nThe connection group is waiting for a network path change.\ncase failed(NWError)\nThe connection group encountered a fatal error.\ncase cancelled\nThe connection group has been canceled."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/state/3584952",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "NWConnectionGroup.State.setup",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/state/setup",
        "html": "See Also\nStates\ncase waiting(NWError)\nThe connection group is waiting for a network path change.\ncase ready\nThe connection group is joined, and ready to send and receive data.\ncase failed(NWError)\nThe connection group encountered a fatal error.\ncase cancelled\nThe connection group has been canceled."
    },
    {
        "title": "default",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message/3600702-default",
        "html": "See Also\nSending Messages\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context you use to send data."
    },
    {
        "title": "extractConnection()",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message/3600703-extractconnection",
        "html": "See Also\nReplying to Received Messages\nfunc reply(content: Data?, message: NWConnectionGroup.Message)\nSends a reply to the specific endpoint that originates a group message you receive."
    },
    {
        "title": "reply(content:message:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message/3600704-reply",
        "html": "See Also\nReplying to Received Messages\nfunc extractConnection() -> NWConnection?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998779-init",
        "html": "See Also\nCustomizing TCP Options\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "NWListener.ServiceRegistrationChange.remove(_:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/serviceregistrationchange/remove",
        "html": "See Also\nChanges\ncase add(NWEndpoint)\nThe service is now advertising a new endpoint."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998495-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "localEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message/3584947-localendpoint",
        "html": "See Also\nInspecting Received Messages\nvar remoteEndpoint: NWEndpoint?\nThe endpoint that originates the message you receive.\nvar path: NWPath?\nThe network path on which you receive the message."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998487",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Addresses\nstatic func == (IPv4Address, IPv4Address) -> Bool\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "NWListener.ServiceRegistrationChange.add(_:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/serviceregistrationchange/add",
        "html": "See Also\nChanges\ncase remove(NWEndpoint)\nThe service is no longer advertising a specific endpoint."
    },
    {
        "title": "enableFastOpen",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998777-enablefastopen",
        "html": "Discussion\n\nIf TCP Fast Open is enabled and TLS is running on top of TCP, the TLS handshake will automatically be used as the TCP early data. If there is no protocol running on top of TCP, you should also enable fast open on the connection parameters and send idempotent data.\n\nSee Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings.\nRelated Documentation\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\ncase idempotent\nMark the sent data as idempotent\u2014data that can be sent multiple times."
    },
    {
        "title": "path",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message/3584948-path",
        "html": "See Also\nInspecting Received Messages\nvar remoteEndpoint: NWEndpoint?\nThe endpoint that originates the message you receive.\nvar localEndpoint: NWEndpoint?\nThe local address and port you use to receive the message."
    },
    {
        "title": "nw_parameters_t",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_t",
        "html": "Topics\nCreating Parameters\nfunc nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for TLS or TCP connections and listeners.\nfunc nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for DTLS or UDP connections and listeners.\ntypealias nw_parameters_configure_protocol_block_t\nA block to configure protocol options during the creation of a parameters object.\nfunc nw_parameters_create() -> nw_parameters_t\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\nfunc nw_parameters_create_custom_ip(UInt8, nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc nw_parameters_copy(nw_parameters_t) -> nw_parameters_t\nPeforms a deep copy of a parameters object.\nModifying Protocol Stacks\nfunc nw_parameters_copy_default_protocol_stack(nw_parameters_t) -> nw_protocol_stack_t\nAccesses the protocol stack used by connections and listeners.\ntypealias nw_protocol_stack_t\nAn ordered set of protocol options that define the protocols that connections and listeners use.\ntypealias nw_protocol_definition_t\nThe abstract superclass for identifying a network protocol.\ntypealias nw_protocol_options_t\nThe abstract superclass for configuring the options of a network protocol.\nSelecting Paths\nfunc nw_parameters_set_required_interface_type(nw_parameters_t, nw_interface_type_t)\nSets an interface type to require on connections and listeners.\nfunc nw_parameters_get_required_interface_type(nw_parameters_t) -> nw_interface_type_t\nAccesses the interface type required on connections and listeners.\nfunc nw_parameters_require_interface(nw_parameters_t, nw_interface_t?)\nSets a specific interface to require on connections, listeners, and browsers.\nfunc nw_parameters_copy_required_interface(nw_parameters_t) -> nw_interface_t?\nAccesses the interface required on connections, listeners, and browsers.\nfunc nw_parameters_set_local_endpoint(nw_parameters_t, nw_endpoint_t?)\nSets a specific local IP address and port to use for connections and listeners.\nfunc nw_parameters_copy_local_endpoint(nw_parameters_t) -> nw_endpoint_t?\nAccesses the local IP address and port used for connections and listeners.\nfunc nw_parameters_set_prohibit_constrained(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_get_prohibit_constrained(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as constrained by Low Data Mode.\nfunc nw_parameters_set_prohibit_expensive(nw_parameters_t, Bool)\nPrevents connections, listeners, and browsers from using network paths marked as expensive.\nfunc nw_parameters_get_prohibit_expensive(nw_parameters_t) -> Bool\nChecks if connections, listeners, and browsers are prevented from using network paths marked as expensive.\nfunc nw_parameters_prohibit_interface_type(nw_parameters_t, nw_interface_type_t)\nPrevents connections, listeners, and browsers from using a specific interface type.\nfunc nw_parameters_clear_prohibited_interface_types(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interface_types(nw_parameters_t, (nw_interface_type_t) -> Bool)\nExamines the list of prohibited interface types.\ntypealias nw_parameters_iterate_interface_types_block_t\nA block that allows inspection of a list of interface types.\nfunc nw_parameters_prohibit_interface(nw_parameters_t, nw_interface_t)\nPrevents connections and listeners from using a specific interface.\nfunc nw_parameters_clear_prohibited_interfaces(nw_parameters_t)\nRemoves all prohibited interface types.\nfunc nw_parameters_iterate_prohibited_interfaces(nw_parameters_t, (nw_interface_t) -> Bool)\nExamines the list of prohibited interfaces.\ntypealias nw_parameters_iterate_interfaces_block_t\nA block that allows inspection of a list of interfaces.\nCustomizing Connection Options\nfunc nw_parameters_set_multipath_service(nw_parameters_t, nw_multipath_service_t)\nEnables multipath protocols to allow connections to use multiple interfaces.\nfunc nw_parameters_get_multipath_service(nw_parameters_t) -> nw_multipath_service_t\nChecks if multipath is enabled on a connection.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nfunc nw_parameters_set_service_class(nw_parameters_t, nw_service_class_t)\nSets a level of service quality to use for connections.\nfunc nw_parameters_get_service_class(nw_parameters_t) -> nw_service_class_t\nChecks the level of service quality used for connections.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes.\nfunc nw_parameters_get_fast_open_enabled(nw_parameters_t) -> Bool\nChecks if sending application data with protocol handshakes is enabled.\nfunc nw_parameters_set_expired_dns_behavior(nw_parameters_t, nw_parameters_expired_dns_behavior_t)\nSets the behavior for how expired DNS answers should be used.\nfunc nw_parameters_get_expired_dns_behavior(nw_parameters_t) -> nw_parameters_expired_dns_behavior_t\nChecks the behavior for how expired DNS answers should be used.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nfunc nw_parameters_set_prefer_no_proxy(nw_parameters_t, Bool)\nSets a Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nfunc nw_parameters_get_prefer_no_proxy(nw_parameters_t) -> Bool\nChecks if proxies are ignored by default.\nfunc nw_parameters_set_include_peer_to_peer(nw_parameters_t, Bool)\nEnables peer-to-peer link technologies for connections and listeners.\nfunc nw_parameters_get_include_peer_to_peer(nw_parameters_t) -> Bool\nChecks whether a connection is allowed to use peer-to-peer link technologies.\nfunc nw_parameters_set_reuse_local_address(nw_parameters_t, Bool)\nAllows reusing local addresses and ports across connections.\nfunc nw_parameters_get_reuse_local_address(nw_parameters_t) -> Bool\nChecks whether a connection allows reusing local addresses and ports.\nfunc nw_parameters_set_local_only(nw_parameters_t, Bool)\nRestricts listeners to only accepting connections from the local link.\nfunc nw_parameters_get_local_only(nw_parameters_t) -> Bool\nChecks if a listener is restricted to accepting connections from the local link.\nConfiguring Privacy Settings\n\nfunc nw_parameters_set_privacy_context(nw_parameters_t, nw_privacy_context_t)\nAssociates a privacy context with any connections or listeners that use the parameters.\ntypealias nw_privacy_context_t\nAn object that defines the privacy requirements for a set of connections.\nSee Also\nAccessing flow information\nvar metaData: NEFlowMetaData\nA metadata object containing information about the source app of the flow.\nfunc setMetadata(nw_parameters_t)\nSets the flow\u2019s metadata for use by proxy providers.\nvar isBound: Bool\nA Boolean value that indicates whether the flow has a binding to a specific interface.\nvar networkInterface: nw_interface_t?\nThe network interface, if any, used by this flow.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nvar remoteHostname: String?\nThe remote host name for flows created from a hostname."
    },
    {
        "title": "securityProtocolOptions",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802984-securityprotocoloptions",
        "html": "See Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "NWProtocolQUIC.Options.Direction",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/direction",
        "html": "Topics\nDirection Values\ncase bidirectional\nA bidirectional QUIC stream.\ncase unidirectional\nA unidirectional QUIC stream.\nComparing Directions\nstatic func == (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nstatic func != (NWProtocolQUIC.Options.Direction, NWProtocolQUIC.Options.Direction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int\nRelationships\nConforms To\nSendable\nSee Also\nCustomizing Stream Options\nvar direction: NWProtocolQUIC.Options.Direction\nThe direction of the QUIC stream.\nvar isDatagram: Bool\nA Boolean that indicates that this is a QUIC datagram flow, not a stream of bytes."
    },
    {
        "title": "isDatagram",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3952719-isdatagram",
        "html": "See Also\nCustomizing Stream Options\nvar direction: NWProtocolQUIC.Options.Direction\nThe direction of the QUIC stream.\nenum NWProtocolQUIC.Options.Direction\nA directionality of a QUIC stream."
    },
    {
        "title": "direction",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802973-direction",
        "html": "See Also\nCustomizing Stream Options\nenum NWProtocolQUIC.Options.Direction\nA directionality of a QUIC stream.\nvar isDatagram: Bool\nA Boolean that indicates that this is a QUIC datagram flow, not a stream of bytes."
    },
    {
        "title": "usedProxy",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200448-usedproxy",
        "html": "See Also\nChecking for Proxies\nlet proxyConfigured: Bool\nA Boolean indicating whether a proxy was configured on the connection.\nlet proxyEndpoint: NWEndpoint?\nThe endpoint of the proxy the connection used."
    },
    {
        "title": "proxyConfigured",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200445-proxyconfigured",
        "html": "See Also\nChecking for Proxies\nlet usedProxy: Bool\nA Boolean indicating whether the connection used a proxy.\nlet proxyEndpoint: NWEndpoint?\nThe endpoint of the proxy the connection used."
    },
    {
        "title": "resolutions",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200447-resolutions",
        "html": "See Also\nInspecting Resolution\nstruct NWConnection.EstablishmentReport.Resolution\nA description of a single DNS resolution step."
    },
    {
        "title": "initialMaxStreamDataBidirectionalLocal",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802978-initialmaxstreamdatabidirectiona",
        "html": "Discussion\n\nThis property determines the value of the initial_max_stream_data_bidi_local transport parameter.\n\nSee Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "NWConnection.EstablishmentReport.Handshake",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/handshake",
        "html": "Topics\nMeasuring Performance\nlet handshakeDuration: TimeInterval\nThe duration of the protocol handshake.\nlet handshakeRTT: TimeInterval\nThe round-trip time the protocol observed during its handshake.\nIdentifying Protocols\nlet definition: NWProtocolDefinition\nThe protocol performing the handshake.\nRelationships\nConforms To\nSendable\nSee Also\nInspecting Protocol Handshakes\nlet handshakes: [NWConnection.EstablishmentReport.Handshake]\nThe array of protocol handshakes in order from first completed to last completed."
    },
    {
        "title": "proxyEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200446-proxyendpoint",
        "html": "See Also\nChecking for Proxies\nlet proxyConfigured: Bool\nA Boolean indicating whether a proxy was configured on the connection.\nlet usedProxy: Bool\nA Boolean indicating whether the connection used a proxy."
    },
    {
        "title": "duration",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200442-duration",
        "html": "See Also\nInspecting Connection Attempts\nlet previousAttemptCount: Int\nThe number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state.\nlet attemptStartedAfterInterval: TimeInterval\nThe time between the call to start and the beginning of the successful connection attempt.\nvar debugDescription: String\nThe description of the report."
    },
    {
        "title": "NWConnection.EstablishmentReport.Resolution",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/resolution",
        "html": "Topics\nMeasuring Performance\nlet duration: TimeInterval\nThe duration of this resolution step, from when the query was issued to when the response was complete.\nlet source: NWConnection.EstablishmentReport.Resolution.Source\nThe source of the DNS response.\nenum NWConnection.EstablishmentReport.Resolution.Source\nSources that may provide DNS responses.\nvar dnsProtocol: NWConnection.EstablishmentReport.Resolution.DNSProtocol\nThe transport protocol your connection used for DNS resolution.\nenum NWConnection.EstablishmentReport.Resolution.DNSProtocol\nA set of transport protocols connections use for DNS resolution.\nExamining Resolved Endpoints\nlet successfulEndpoint: NWEndpoint\nThe resolved endpoint that led to the established connection.\nlet preferredEndpoint: NWEndpoint\nThe resolved endpoint that the connection used for its first connection attempt.\nlet endpointCount: Int\nThe number of endpoints resolved in this step.\nRelationships\nConforms To\nSendable\nSee Also\nInspecting Resolution\nlet resolutions: [NWConnection.EstablishmentReport.Resolution]\nThe array of resolution steps performed during connection establishment, in order from first resolved to last resolved."
    },
    {
        "title": "handshakes",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200443-handshakes",
        "html": "See Also\nInspecting Protocol Handshakes\nstruct NWConnection.EstablishmentReport.Handshake\nA description of a single protocol handshake."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200441-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Connection Attempts\nlet duration: TimeInterval\nThe total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nlet previousAttemptCount: Int\nThe number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state.\nlet attemptStartedAfterInterval: TimeInterval\nThe time between the call to start and the beginning of the successful connection attempt."
    },
    {
        "title": "attemptStartedAfterInterval",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200440-attemptstartedafterinterval",
        "html": "See Also\nInspecting Connection Attempts\nlet duration: TimeInterval\nThe total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nlet previousAttemptCount: Int\nThe number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state.\nvar debugDescription: String\nThe description of the report."
    },
    {
        "title": "previousAttemptCount",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport/3200444-previousattemptcount",
        "html": "See Also\nInspecting Connection Attempts\nlet duration: TimeInterval\nThe total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nlet attemptStartedAfterInterval: TimeInterval\nThe time between the call to start and the beginning of the successful connection attempt.\nvar debugDescription: String\nThe description of the report."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options/3802975-init",
        "html": "See Also\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/network/nwprotocoludp/options/2998801-init",
        "html": "See Also\nCustomizing UDP Connections\nvar preferNoChecksum: Bool\nA Boolean that configures the connection to not send UDP checksums."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/3236841-hash",
        "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nAccessing the hash value\nvar hashValue: Int\nThe hash value."
    },
    {
        "title": "NWParameters.ServiceClass.signaling",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/signaling",
        "html": "Discussion\n\nUse this for establishing, maintaining, and tearing down a VoIP call.\n\nSee Also\nService Classes\ncase bestEffort\nA service type to enable Cellular Network Slicing when not setting the other service types.\ncase background\nA service type for high-delay tolerant, high-loss tolerant, elastic flow, and variable size connections.\ncase interactiveVideo\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase interactiveVoice\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase responsiveData\nA service type for medium-delay tolerant, elastic and inelastic flow, bursty, and long-lived connections."
    },
    {
        "title": "protocolMetadata(definition:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/2998544-protocolmetadata",
        "html": "See Also\nInspecting Receive Contexts\nlet isFinal: Bool\nA Boolean indicating whether this context represents the final message being sent or received."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/3200421-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nSummarizing Reports\nlet duration: TimeInterval\nThe duration of the data transfer report, from when it was started to when it was collected."
    },
    {
        "title": "antecedent",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/2998538-antecedent",
        "html": "See Also\nCreating Custom Send Contexts\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context.\nlet identifier: String\nThe identifier of the message, used for debugging.\nvar protocolMetadata: [NWProtocolMetadata]\nAn array of protocol metadata used to configure per-message or per-packet properties.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet expirationMilliseconds: UInt64\nA number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nlet relativePriority: Double\nA relative value of priority used to reorder contexts when sending."
    },
    {
        "title": "allReportsGroup",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998490-allreportsgroup",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv4Address\nThe unspecified address (0.0.0.0).\nstatic let broadcast: IPv4Address\nThe local broadcast address (255.255.255.255).\nstatic let loopback: IPv4Address\nThe device's loopback address (127.0.0.1).\nstatic let allHostsGroup: IPv4Address\nThe multicast group for all hosts on the network segment (224.0.0.1).\nstatic let allRoutersGroup: IPv4Address\nThe multicast group for all routers on the network segment (224.0.0.2).\nstatic let mdnsGroup: IPv4Address\nThe multicast group for multicast DNS (224.0.0.251)."
    },
    {
        "title": "allRoutersGroup",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998491-allroutersgroup",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv4Address\nThe unspecified address (0.0.0.0).\nstatic let broadcast: IPv4Address\nThe local broadcast address (255.255.255.255).\nstatic let loopback: IPv4Address\nThe device's loopback address (127.0.0.1).\nstatic let allHostsGroup: IPv4Address\nThe multicast group for all hosts on the network segment (224.0.0.1).\nstatic let allReportsGroup: IPv4Address\nThe multicast group for all IGMPv3 reports (224.0.0.22).\nstatic let mdnsGroup: IPv4Address\nThe multicast group for multicast DNS (224.0.0.251)."
    },
    {
        "title": "NWEndpoint.Host.ipv4(_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/ipv4",
        "html": "See Also\nAccessing Host Types\ncase name(String, NWInterface?)\nA host represented as a name.\ncase ipv6(IPv6Address)\nA host represented as an IPv6 address."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998600-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nComparing Ports\nvar rawValue: UInt16\nstatic func != (NWEndpoint.Port, NWEndpoint.Port) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998596",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Ports\nvar rawValue: UInt16\nvar debugDescription: String\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/3129510-hash",
        "html": "See Also\nComparing Ports\nvar rawValue: UInt16\nvar debugDescription: String\nstatic func != (NWEndpoint.Port, NWEndpoint.Port) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int"
    },
    {
        "title": "allHostsGroup",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998489-allhostsgroup",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv4Address\nThe unspecified address (0.0.0.0).\nstatic let broadcast: IPv4Address\nThe local broadcast address (255.255.255.255).\nstatic let loopback: IPv4Address\nThe device's loopback address (127.0.0.1).\nstatic let allRoutersGroup: IPv4Address\nThe multicast group for all routers on the network segment (224.0.0.2).\nstatic let allReportsGroup: IPv4Address\nThe multicast group for all IGMPv3 reports (224.0.0.22).\nstatic let mdnsGroup: IPv4Address\nThe multicast group for multicast DNS (224.0.0.251)."
    },
    {
        "title": "loopback",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998502-loopback",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv4Address\nThe unspecified address (0.0.0.0).\nstatic let broadcast: IPv4Address\nThe local broadcast address (255.255.255.255).\nstatic let allHostsGroup: IPv4Address\nThe multicast group for all hosts on the network segment (224.0.0.1).\nstatic let allRoutersGroup: IPv4Address\nThe multicast group for all routers on the network segment (224.0.0.2).\nstatic let allReportsGroup: IPv4Address\nThe multicast group for all IGMPv3 reports (224.0.0.22).\nstatic let mdnsGroup: IPv4Address\nThe multicast group for multicast DNS (224.0.0.251)."
    },
    {
        "title": "broadcast",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998493-broadcast",
        "html": "See Also\nSetting Well-Known Addresses\nstatic let any: IPv4Address\nThe unspecified address (0.0.0.0).\nstatic let loopback: IPv4Address\nThe device's loopback address (127.0.0.1).\nstatic let allHostsGroup: IPv4Address\nThe multicast group for all hosts on the network segment (224.0.0.1).\nstatic let allRoutersGroup: IPv4Address\nThe multicast group for all routers on the network segment (224.0.0.2).\nstatic let allReportsGroup: IPv4Address\nThe multicast group for all IGMPv3 reports (224.0.0.22).\nstatic let mdnsGroup: IPv4Address\nThe multicast group for multicast DNS (224.0.0.251)."
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998609-rawvalue",
        "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nComparing Ports\nvar debugDescription: String\nstatic func != (NWEndpoint.Port, NWEndpoint.Port) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998494-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv4 address.\nlet interface: NWInterface?\nThe interface associated with this address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address."
    },
    {
        "title": "isMulticast",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998501-ismulticast",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv4 address.\nlet interface: NWInterface?\nThe interface associated with this address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "socks",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998611-socks",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993)."
    },
    {
        "title": "interface",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998498-interface",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv4 address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "imap",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998603-imap",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998504-rawvalue",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nlet interface: NWInterface?\nThe interface associated with this address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "pop",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998608-pop",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "init(_:_:)",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998497-init",
        "html": "Discussion\n\nThe provided data is expected to be an IPv4 address of 4 bytes.\n\nRelationships\nFrom Protocol\nIPAddress\nSee Also\nCreating Addresses\ninit?(String)\nInitializes an IPv4 address with a string."
    },
    {
        "title": "http",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998601-http",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998496-init",
        "html": "Discussion\n\nThe provided string will be interpreted as an IPv4 address. If the string cannot be interpreted as an IPv4 address, the initialization will fail.\n\nRelationships\nFrom Protocol\nIPAddress\nSee Also\nCreating Addresses\ninit?(Data, NWInterface?)\nInitializes an IPv4 address with data."
    },
    {
        "title": "nw_data_transfer_report_t",
        "url": "https://developer.apple.com/documentation/network/nw_data_transfer_report_t",
        "html": "Topics\nCollecting Reports\nfunc nw_data_transfer_report_collect(nw_data_transfer_report_t, dispatch_queue_t, nw_data_transfer_report_collect_block_t)\nStops an outstanding data transfer report and calculates the results.\ntypealias nw_data_transfer_report_collect_block_t\nA block that is delivered when a data transfer report is fully collected.\nfunc nw_data_transfer_report_get_state(nw_data_transfer_report_t) -> nw_data_transfer_report_state_t\nChecks whether a data transfer report is collected.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nIdentifying Paths\nfunc nw_data_transfer_report_get_path_count(nw_data_transfer_report_t) -> UInt32\nChecks the number of valid paths in the report.\nfunc nw_data_transfer_report_get_duration_milliseconds(nw_data_transfer_report_t) -> UInt64\nChecks the duration of the data transfer report, from when it was started to when it was collected.\nfunc nw_data_transfer_report_copy_path_interface(nw_data_transfer_report_t, UInt32) -> nw_interface_t\nAccesses the network interface the path used.\nInspecting Application Metrics\nfunc nw_data_transfer_report_get_received_application_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the connection delivered.\nfunc nw_data_transfer_report_get_sent_application_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent on the connection.\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured.\nInspecting Packet Metrics\nfunc nw_data_transfer_report_get_received_ip_packet_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of IP packets the connection received.\nfunc nw_data_transfer_report_get_sent_ip_packet_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of IP packets the connection sent.\nSee Also\nCollecting Connection Metrics\ntypealias nw_establishment_report_t\nA report that provides metrics about how a connection was established.\nfunc nw_connection_access_establishment_report(nw_connection_t, dispatch_queue_t, nw_establishment_report_access_block_t)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\ntypealias nw_establishment_report_access_block_t\nA block that delivers a connection's establishment report when it's in the ready state.\nfunc nw_connection_create_new_data_transfer_report(nw_connection_t) -> nw_data_transfer_report_t\nBegins a new data transfer report, which can later be collected."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998605-init",
        "html": "Discussion\n\nPort strings are expected to be numeric values between 0 and 65535. Initializing with any other string will fail.\n\nSee Also\nCreating Ports\ninit?(rawValue: UInt16)\nInitializes a port with a raw UInt16 value.\ninit(integerLiteral: NWEndpoint.Port.IntegerLiteralType)\nInitializes a port with a literal type.\ntypealias NWEndpoint.Port.IntegerLiteralType\nA literal type defined for ports."
    },
    {
        "title": "isMulticast",
        "url": "https://developer.apple.com/documentation/network/ipaddress/2998484-ismulticast",
        "html": "Required\n\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IP address.\n\nRequired\n\nvar interface: NWInterface?\nThe interface associated with this address, such as the IPv6 scoped interface.\n\nRequired\n\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\n\nRequired\n\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\n\nRequired"
    },
    {
        "title": "isLoopback",
        "url": "https://developer.apple.com/documentation/network/ipaddress/2998483-isloopback",
        "html": "Required\n\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IP address.\n\nRequired\n\nvar interface: NWInterface?\nThe interface associated with this address, such as the IPv6 scoped interface.\n\nRequired\n\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\n\nRequired\n\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\n\nRequired"
    },
    {
        "title": "nw_error_t",
        "url": "https://developer.apple.com/documentation/network/nw_error_t",
        "html": "Topics\nInspecting Errors\nfunc nw_error_get_error_domain(nw_error_t) -> nw_error_domain_t\nAccesses the domain of the network error.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nfunc nw_error_get_error_code(nw_error_t) -> Int32\nAccesses the specific code of the network error.\nfunc nw_error_copy_cf_error(nw_error_t) -> Unmanaged<CFError>\nCopies out a CFError that represents a network error."
    },
    {
        "title": "nw_endpoint_t",
        "url": "https://developer.apple.com/documentation/network/nw_endpoint_t",
        "html": "Topics\nEndpoint Types\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nfunc nw_endpoint_get_type(nw_endpoint_t) -> nw_endpoint_type_t\nAccesses the type of a endpoint.\nHost Endpoints\nfunc nw_endpoint_create_host(UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a hostname and port, where the hostname may be interpreted as an IP address.\nfunc nw_endpoint_get_hostname(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the hostname stored in an endpoint.\nfunc nw_endpoint_get_port(nw_endpoint_t) -> UInt16\nAccesses the port stored in an endpoint, in host-byte order.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string.\nAddress Endpoints\nfunc nw_endpoint_create_address(UnsafePointer<sockaddr>) -> nw_endpoint_t\nCreates a network endpoint with an address structure.\nfunc nw_endpoint_get_address(nw_endpoint_t) -> UnsafePointer<sockaddr>\nAccesses the address structure stored in an address endpoint.\nfunc nw_endpoint_copy_address_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the address of an endpoint as a string.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string.\nBonjour Service Endpoints\nfunc nw_endpoint_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a Bonjour service name, type, and domain.\nfunc nw_endpoint_get_bonjour_service_name(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service name stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_type(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_domain(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service domain stored in an endpoint.\nURL Endpoints\nfunc nw_endpoint_create_url(UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a URL string.\nfunc nw_endpoint_get_url(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the URL string stored in an endpoint."
    },
    {
        "title": "nw_data_transfer_report_collect_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_data_transfer_report_collect_block_t",
        "html": "See Also\nCollecting Reports\nfunc nw_data_transfer_report_collect(nw_data_transfer_report_t, dispatch_queue_t, nw_data_transfer_report_collect_block_t)\nStops an outstanding data transfer report and calculates the results.\nfunc nw_data_transfer_report_get_state(nw_data_transfer_report_t) -> nw_data_transfer_report_state_t\nChecks whether a data transfer report is collected.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet."
    },
    {
        "title": "isLinkLocal",
        "url": "https://developer.apple.com/documentation/network/ipaddress/2998482-islinklocal",
        "html": "Required\n\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IP address.\n\nRequired\n\nvar interface: NWInterface?\nThe interface associated with this address, such as the IPv6 scoped interface.\n\nRequired\n\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\n\nRequired\n\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\n\nRequired"
    },
    {
        "title": "nw_ethernet_channel_send_completion_t",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_send_completion_t",
        "html": "See Also\nSending and Receiving Ethernet Frames\nfunc nw_ethernet_channel_send(nw_ethernet_channel_t, dispatch_data_t, UInt16, UnsafeMutablePointer<UInt8>, nw_ethernet_channel_send_completion_t)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\nfunc nw_ethernet_channel_set_receive_handler(nw_ethernet_channel_t, nw_ethernet_channel_receive_handler_t?)\nSets a handler to receive inbound Ethernet frames.\ntypealias nw_ethernet_channel_receive_handler_t\nA handler that delivers inbound Ethernet frames.\ntypealias nw_ethernet_address_t\nA 48-bit Ethernet address."
    },
    {
        "title": "interface",
        "url": "https://developer.apple.com/documentation/network/ipaddress/2998481-interface",
        "html": "Required\n\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IP address.\n\nRequired\n\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\n\nRequired\n\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\n\nRequired\n\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\n\nRequired"
    },
    {
        "title": "rawValue",
        "url": "https://developer.apple.com/documentation/network/ipaddress/2998485-rawvalue",
        "html": "Required\n\nSee Also\nInspecting Address Properties\nvar interface: NWInterface?\nThe interface associated with this address, such as the IPv6 scoped interface.\n\nRequired\n\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\n\nRequired\n\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\n\nRequired\n\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\n\nRequired"
    },
    {
        "title": "NWConnection.SendCompletion.contentProcessed(_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/sendcompletion/contentprocessed",
        "html": "See Also\nCompletions\ncase idempotent\nMark the sent data as idempotent\u2014data that can be sent multiple times."
    },
    {
        "title": "NWConnection.SendCompletion.idempotent",
        "url": "https://developer.apple.com/documentation/network/nwconnection/sendcompletion/idempotent",
        "html": "See Also\nCompletions\ncase contentProcessed((NWError?) -> Void)\nProvide a completion handler that's invoked when the sent data is processed by the stack."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state/2998550",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "disableAckStretching",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998775-disableackstretching",
        "html": "See Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "keepaliveInterval",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998782-keepaliveinterval",
        "html": "See Also\nConfiguring Keepalives\nvar enableKeepalive: Bool\nA Boolean that enables TCP keepalives.\nvar keepaliveIdle: Int\nThe number of seconds of idleness that TCP waits before sending keepalive probes.\nvar keepaliveCount: Int\nThe number of keepalive probes that TCP sends before terminating the connection."
    },
    {
        "title": "keepaliveCount",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998780-keepalivecount",
        "html": "See Also\nConfiguring Keepalives\nvar enableKeepalive: Bool\nA Boolean that enables TCP keepalives.\nvar keepaliveIdle: Int\nThe number of seconds of idleness that TCP waits before sending keepalive probes.\nvar keepaliveInterval: Int\nThe number of seconds that TCP waits between sending keepalive probes."
    },
    {
        "title": "connectionTimeout",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998774-connectiontimeout",
        "html": "See Also\nSetting Timeouts\nvar connectionDropTime: Int\nThe timeout, in seconds, for TCP retransmission attempts.\nvar persistTimeout: Int\nThe TCP persist timeout, in seconds, as defined by RFC 6429."
    },
    {
        "title": "NWProtocolOptions",
        "url": "https://developer.apple.com/documentation/network/nwprotocoloptions",
        "html": "Relationships\nConforms To\nSendable\nSee Also\nAdding Protocols to Connections\nclass NWProtocolDefinition\nThe abstract superclass for identifying a network protocol."
    },
    {
        "title": "keepaliveIdle",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998781-keepaliveidle",
        "html": "See Also\nConfiguring Keepalives\nvar enableKeepalive: Bool\nA Boolean that enables TCP keepalives.\nvar keepaliveCount: Int\nThe number of keepalive probes that TCP sends before terminating the connection.\nvar keepaliveInterval: Int\nThe number of seconds that TCP waits between sending keepalive probes."
    },
    {
        "title": "enableKeepalive",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998778-enablekeepalive",
        "html": "See Also\nConfiguring Keepalives\nvar keepaliveIdle: Int\nThe number of seconds of idleness that TCP waits before sending keepalive probes.\nvar keepaliveCount: Int\nThe number of keepalive probes that TCP sends before terminating the connection.\nvar keepaliveInterval: Int\nThe number of seconds that TCP waits between sending keepalive probes."
    },
    {
        "title": "disableECN",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998776-disableecn",
        "html": "See Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching."
    },
    {
        "title": "retransmitFinDrop",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998788-retransmitfindrop",
        "html": "See Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "noPush",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998786-nopush",
        "html": "See Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "noDelay",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998784-nodelay",
        "html": "See Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "noOptions",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998785-nooptions",
        "html": "See Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "maximumSegmentSize",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options/2998783-maximumsegmentsize",
        "html": "See Also\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "NWConnection.State.ready",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state/ready",
        "html": "See Also\nStates\ncase setup\nThe connection has been initialized but not started.\ncase waiting(NWError)\nThe connection is waiting for a network path change.\ncase preparing\nThe connection in the process of being established.\ncase failed(NWError)\nThe connection has disconnected or encountered an error.\ncase cancelled\nThe connection has been canceled."
    },
    {
        "title": "NWParameters.ServiceClass.background",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/background",
        "html": "Discussion\n\nAn example of this service type is prefetching content so that it\u2019s available when the user chooses to view it.\n\nSee Also\nService Classes\ncase bestEffort\nA service type to enable Cellular Network Slicing when not setting the other service types.\ncase interactiveVideo\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase interactiveVoice\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase responsiveData\nA service type for medium-delay tolerant, elastic and inelastic flow, bursty, and long-lived connections.\ncase signaling\nA service for low-loss tolerant, inelastic flow, jitter tolerant, bursty but short rate, and variable size connections."
    },
    {
        "title": "NWParameters.ServiceClass.interactiveVoice",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/interactivevoice",
        "html": "See Also\nService Classes\ncase bestEffort\nA service type to enable Cellular Network Slicing when not setting the other service types.\ncase background\nA service type for high-delay tolerant, high-loss tolerant, elastic flow, and variable size connections.\ncase interactiveVideo\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase responsiveData\nA service type for medium-delay tolerant, elastic and inelastic flow, bursty, and long-lived connections.\ncase signaling\nA service for low-loss tolerant, inelastic flow, jitter tolerant, bursty but short rate, and variable size connections."
    },
    {
        "title": "nw_ws_subprotocol_enumerator_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_subprotocol_enumerator_t",
        "html": "Return Value\n\nReturn true to continue enumerating, or false to stop enumerating.\n\nSee Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_txt_record_applier_t",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_applier_t",
        "html": "Return Value\n\nReturn true to continue iterating, or false to stop iterating.\n\nSee Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_resolution_report_t",
        "url": "https://developer.apple.com/documentation/network/nw_resolution_report_t",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_txt_record_access_bytes_t",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_access_bytes_t",
        "html": "Return Value\n\nThe return value is passed back to the caller of nw_txt_record_access_bytes(_:_:).\n\nSee Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record."
    },
    {
        "title": "expirationMilliseconds",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/2998539-expirationmilliseconds",
        "html": "See Also\nCreating Custom Send Contexts\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context.\nlet identifier: String\nThe identifier of the message, used for debugging.\nvar protocolMetadata: [NWProtocolMetadata]\nAn array of protocol metadata used to configure per-message or per-packet properties.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet antecedent: NWConnection.ContentContext?\nAn optional message context that must be sent before the context you are sending.\nlet relativePriority: Double\nA relative value of priority used to reorder contexts when sending."
    },
    {
        "title": "NWConnection.DataTransferReport.PathReport",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/pathreport",
        "html": "Topics\nIdentifying Paths\nlet interface: NWInterface\nThe network interface this path used.\nInspecting Application Metrics\nlet receivedApplicationByteCount: UInt64\nThe number of bytes the connection delivered.\nlet sentApplicationByteCount: UInt64\nThe number of bytes sent on the connection.\nInspecting Transport Metrics\nlet receivedTransportByteCount: UInt64\nThe number of bytes the transport protocol delivered.\nlet receivedTransportDuplicateByteCount: UInt64\nThe number of duplicated bytes the transport protocol detected.\nlet receivedTransportOutOfOrderByteCount: UInt64\nThe number of bytes the transport protocol received out of order.\nlet sentTransportByteCount: UInt64\nThe number of bytes sent into the transport protocol.\nlet retransmittedTransportByteCount: UInt64\nThe number of bytes the transport protocol retransmitted.\nlet transportSmoothedRTT: TimeInterval\nThe smoothed round-trip time the transport protocol measured.\nlet transportMinimumRTT: TimeInterval\nThe minimum round-trip time the transport protocol measured.\nlet transportRTTVariance: TimeInterval\nThe variance of the round-trip time the transport protocol measured.\nInspecting Packet Metrics\nlet receivedIPPacketCount: UInt64\nThe number of IP packets the connection received.\nlet sentIPPacketCount: UInt64\nThe number of IP packets the connection sent.\nInstance Properties\nvar radioType: NWInterface.RadioType?\nRelationships\nConforms To\nSendable\nSee Also\nExamining Data Transfer\nlet aggregatePathReport: NWConnection.DataTransferReport.PathReport\nA report that sums counts across all network paths.\nlet pathReports: [NWConnection.DataTransferReport.PathReport]\nAn array of reports for each network path the connection used."
    },
    {
        "title": "relativePriority",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/2998545-relativepriority",
        "html": "Discussion\n\nRelative priority of contexts only affects ordering when there is a queue of messages to be sent. The priority is a double ranging from 0.0 to 1.0, where default messages are set to 0.5.\n\nSee Also\nCreating Custom Send Contexts\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context.\nlet identifier: String\nThe identifier of the message, used for debugging.\nvar protocolMetadata: [NWProtocolMetadata]\nAn array of protocol metadata used to configure per-message or per-packet properties.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet antecedent: NWConnection.ContentContext?\nAn optional message context that must be sent before the context you are sending.\nlet expirationMilliseconds: UInt64\nA number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded."
    },
    {
        "title": "protocolMetadata",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/2998543-protocolmetadata",
        "html": "See Also\nCreating Custom Send Contexts\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context.\nlet identifier: String\nThe identifier of the message, used for debugging.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet antecedent: NWConnection.ContentContext?\nAn optional message context that must be sent before the context you are sending.\nlet expirationMilliseconds: UInt64\nA number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nlet relativePriority: Double\nA relative value of priority used to reorder contexts when sending."
    },
    {
        "title": "identifier",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/2998541-identifier",
        "html": "See Also\nCreating Custom Send Contexts\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context.\nvar protocolMetadata: [NWProtocolMetadata]\nAn array of protocol metadata used to configure per-message or per-packet properties.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet antecedent: NWConnection.ContentContext?\nAn optional message context that must be sent before the context you are sending.\nlet expirationMilliseconds: UInt64\nA number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nlet relativePriority: Double\nA relative value of priority used to reorder contexts when sending."
    },
    {
        "title": "init(identifier:expiration:priority:isFinal:antecedent:metadata:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/3003624-init",
        "html": "See Also\nCreating Custom Send Contexts\nlet identifier: String\nThe identifier of the message, used for debugging.\nvar protocolMetadata: [NWProtocolMetadata]\nAn array of protocol metadata used to configure per-message or per-packet properties.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet antecedent: NWConnection.ContentContext?\nAn optional message context that must be sent before the context you are sending.\nlet expirationMilliseconds: UInt64\nA number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nlet relativePriority: Double\nA relative value of priority used to reorder contexts when sending."
    },
    {
        "title": "NWEndpoint.Host.StringLiteralType",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/stringliteraltype",
        "html": "See Also\nComparing Hosts\ninit(unicodeScalarLiteral: StringLiteralType)\nCreates an instance initialized to the given value.\ninit(stringLiteral: NWEndpoint.Host.StringLiteralType)\ninit(extendedGraphemeClusterLiteral: String)\nCreates an instance initialized to the given value.\nvar debugDescription: String\nstatic func != (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "isFinal",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/3003625-isfinal",
        "html": "See Also\nInspecting Receive Contexts\nfunc protocolMetadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetreives the metadata associated with a specific protocol."
    },
    {
        "title": "init(unicodeScalarLiteral:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/2998590-init",
        "html": "Parameters\nvalue\n\nThe value of the new instance.\n\nDiscussion\n\nNote\n\nThis documentation comment was inherited from ExpressibleByUnicodeScalarLiteral.\n\nSee Also\nComparing Hosts\ninit(stringLiteral: NWEndpoint.Host.StringLiteralType)\ntypealias NWEndpoint.Host.StringLiteralType\ninit(extendedGraphemeClusterLiteral: String)\nCreates an instance initialized to the given value.\nvar debugDescription: String\nstatic func != (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "NWEndpoint.Host.ipv6(_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/ipv6",
        "html": "See Also\nAccessing Host Types\ncase name(String, NWInterface?)\nA host represented as a name.\ncase ipv4(IPv4Address)\nA host represented as an IPv4 address."
    },
    {
        "title": "defaultStream",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/3003622-defaultstream",
        "html": "Discussion\n\nOnce this context is used for sending, and the send is marked as complete, no more data can be sent on the connection.\n\nSee Also\nUsing Constant Send Contexts\nstatic let defaultMessage: NWConnection.ContentContext\nA static context representing a message with default properties.\nstatic let finalMessage: NWConnection.ContentContext\nA static context that's marked as the final message in a connection."
    },
    {
        "title": "NWProtocolDefinition",
        "url": "https://developer.apple.com/documentation/network/nwprotocoldefinition",
        "html": "Topics\nInspecting Protocol Definitions\nlet name: String\nThe name of the protocol.\nvar debugDescription: String\nThe description of the protocol definition.\nComparing Protocols\nstatic func == (NWProtocolDefinition, NWProtocolDefinition) -> Bool\nstatic func != (NWProtocolDefinition, NWProtocolDefinition) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nAdding Protocols to Connections\nclass NWProtocolOptions\nThe abstract superclass for configuring the options of a network protocol."
    },
    {
        "title": "NWEndpoint.Host.name(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/name",
        "html": "See Also\nAccessing Host Types\ncase ipv4(IPv4Address)\nA host represented as an IPv4 address.\ncase ipv6(IPv6Address)\nA host represented as an IPv6 address."
    },
    {
        "title": "isLoopback",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998500-isloopback",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv4 address.\nlet interface: NWInterface?\nThe interface associated with this address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "https",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998602-https",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "isLinkLocal",
        "url": "https://developer.apple.com/documentation/network/ipv4address/2998499-islinklocal",
        "html": "Relationships\nFrom Protocol\nIPAddress\nSee Also\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv4 address.\nlet interface: NWInterface?\nThe interface associated with this address.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address."
    },
    {
        "title": "imaps",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998604-imaps",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "nw_protocol_metadata_t",
        "url": "https://developer.apple.com/documentation/network/nw_protocol_metadata_t",
        "html": "Topics\nInspecting Metadata\nfunc nw_protocol_metadata_copy_definition(nw_protocol_metadata_t) -> nw_protocol_definition_t\nAccesses the protocol definition associated with the metadata object.\nSee Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "ssh",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998612-ssh",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "init(rawValue:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998607-init",
        "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating Ports\ninit?(String)\nInitializes a port with a string.\ninit(integerLiteral: NWEndpoint.Port.IntegerLiteralType)\nInitializes a port with a literal type.\ntypealias NWEndpoint.Port.IntegerLiteralType\nA literal type defined for ports."
    },
    {
        "title": "init(integerLiteral:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998606-init",
        "html": "Relationships\nFrom Protocol\nExpressibleByIntegerLiteral\nSee Also\nCreating Ports\ninit?(String)\nInitializes a port with a string.\ninit?(rawValue: UInt16)\nInitializes a port with a raw UInt16 value.\ntypealias NWEndpoint.Port.IntegerLiteralType\nA literal type defined for ports."
    },
    {
        "title": "nw_framer_start_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_start_handler_t",
        "html": "Return Value\n\nReturn a start result indicating if the connection should become ready immediately, or wait for you protocol to perform a handshake.\n\nDiscussion\n\nWithin your start handler, you should register all other callbacks for your custom protocol, particularly nw_framer_set_output_handler(_:_:) and nw_framer_set_input_handler(_:_:).\n\nAny state that you need to be associated with your protocol as customizable options can be captured within the start block.\n\nSee Also\nAdding Framers to Connections\nfunc nw_framer_create_definition(UnsafePointer<CChar>, UInt32, nw_framer_start_handler_t) -> nw_protocol_definition_t\nInitializes a new protocol definition based on your protocol implementation.\ntypealias nw_framer_t\nAn object that represents a single instance of your custom protocol running in a connection.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nvar NW_FRAMER_CREATE_FLAGS_DEFAULT: Int32\nA constant flag value that indicates that the default framer protocol behavior should be used.\nfunc nw_framer_create_options(nw_protocol_definition_t) -> nw_protocol_options_t\nInitializes a set of protocol options with a custom framer definition."
    },
    {
        "title": "any",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998599-any",
        "html": "See Also\nSetting Well-Known Ports\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "NWEndpoint.Port.IntegerLiteralType",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/integerliteraltype",
        "html": "See Also\nCreating Ports\ninit?(String)\nInitializes a port with a string.\ninit?(rawValue: UInt16)\nInitializes a port with a raw UInt16 value.\ninit(integerLiteral: NWEndpoint.Port.IntegerLiteralType)\nInitializes a port with a literal type."
    },
    {
        "title": "nw_path_monitor_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_monitor_t",
        "html": "Topics\nCreating Path Monitors\nfunc nw_path_monitor_create() -> nw_path_monitor_t\nInitializes a path monitor to observe all available interface types.\nfunc nw_path_monitor_create_with_type(nw_interface_type_t) -> nw_path_monitor_t\nInitializes a path monitor to observe a specific interface type.\nfunc nw_path_monitor_prohibit_interface_type(nw_path_monitor_t, nw_interface_type_t)\nProhibit a path monitor from using a specific interface type.\nfunc nw_path_monitor_set_queue(nw_path_monitor_t, dispatch_queue_t)\nSets a queue on which to deliver path events.\nfunc nw_path_monitor_start(nw_path_monitor_t)\nStarts monitoring path changes.\nHandling Path Updates\nfunc nw_path_monitor_set_update_handler(nw_path_monitor_t, nw_path_monitor_update_handler_t)\nSets a handler to receive network path updates.\ntypealias nw_path_monitor_update_handler_t\nA handler that delivers network path updates.\nCanceling Path Monitors\nfunc nw_path_monitor_cancel(nw_path_monitor_t)\nStops receiving network path updates.\nfunc nw_path_monitor_set_cancel_handler(nw_path_monitor_t, nw_path_monitor_cancel_handler_t)\nSets a handler to determine when a monitor is fully cancelled and will no longer deliver events.\ntypealias nw_path_monitor_cancel_handler_t\nA handler that indicates when a monitor has been cancelled."
    },
    {
        "title": "smtp",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port/2998610-smtp",
        "html": "See Also\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080)."
    },
    {
        "title": "nw_path_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_t",
        "html": "Topics\nChecking Path Availability\nfunc nw_path_get_status(nw_path_t) -> nw_path_status_t\nChecks whether a path can be used by connections.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nInspecting Interfaces\nfunc nw_path_uses_interface_type(nw_path_t, nw_interface_type_t) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nfunc nw_path_enumerate_interfaces(nw_path_t, (nw_interface_t) -> Bool)\nEnumerates the list of all interfaces available to the path, in order of preference.\ntypealias nw_path_enumerate_interfaces_block_t\nA block that enumerates the interfaces available to a path.\nfunc nw_path_enumerate_gateways(nw_path_t, (nw_endpoint_t) -> Bool)\nEnumerates the list of gateways configured on the interfaces available to a path.\ntypealias nw_path_enumerate_gateways_block_t\nA block that enumerates the gateways configured on the interfaces available to a path.\nChecking Path Capabilities\nfunc nw_path_has_ipv4(nw_path_t) -> Bool\nChecks whether the path can route IPv4 traffic.\nfunc nw_path_has_ipv6(nw_path_t) -> Bool\nChecks whether the path can route IPv6 traffic.\nfunc nw_path_has_dns(nw_path_t) -> Bool\nChecks whether the path has a DNS server configured.\nfunc nw_path_is_constrained(nw_path_t) -> Bool\nChecks whether the path uses an interface in Low Data Mode.\nfunc nw_path_is_expensive(nw_path_t) -> Bool\nChecks whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot.\nComparing Paths\nfunc nw_path_is_equal(nw_path_t, nw_path_t) -> Bool\nCompares if two paths are identical.\nInspecting Connected Paths\nfunc nw_path_copy_effective_local_endpoint(nw_path_t) -> nw_endpoint_t?\nAccesses the local endpoint in use by a connection's network path.\nfunc nw_path_copy_effective_remote_endpoint(nw_path_t) -> nw_endpoint_t?\nAccesses the remote endpoint in use by a connection's network path."
    },
    {
        "title": "nw_framer_output_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_output_handler_t",
        "html": "Parameters\nframer\n\nThe framer instance associated with the connection.\n\nmessage\n\nThe framer message passed by the application.\n\nmessage_length\n\nThe length of the message content being sent.\n\nis_complete\n\nA boolean indicating if this the last chunk of a message.\n\nDiscussion\n\nThe output handler is your opportunity to encapsulate or encode a signle application message. You should write any output using nw_framer_write_output(_:_:_:), nw_framer_write_output_data(_:_:), or nw_framer_write_output_no_copy(_:_:) before returning from the output handler. If you do not write a message, the application message will be discarded.\n\nSee Also\nHandling Output Data\nfunc nw_framer_set_output_handler(nw_framer_t, nw_framer_output_handler_t)\nSets a block to handle new outbound messages.\nfunc nw_framer_parse_output(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of output data while inside your output handler.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_write_output(nw_framer_t, UnsafePointer<UInt8>, Int)\nSends arbitrary output data in a buffer from your protocol to the next protocol.\nfunc nw_framer_write_output_data(nw_framer_t, dispatch_data_t)\nSends arbitrary output data from your protocol to the next protocol.\nfunc nw_framer_write_output_no_copy(nw_framer_t, Int) -> Bool\nSends a specific number of bytes from a message while inside your output handler.\nfunc nw_framer_pass_through_output(nw_framer_t)\nIndicates that your protocol no longer needs to handle output data."
    },
    {
        "title": "nw_establishment_report_t",
        "url": "https://developer.apple.com/documentation/network/nw_establishment_report_t",
        "html": "Topics\nInspecting Connection Attempts\nfunc nw_establishment_report_get_duration_milliseconds(nw_establishment_report_t) -> UInt64\nChecks the total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nfunc nw_establishment_report_get_previous_attempt_count(nw_establishment_report_t) -> UInt32\nChecks the number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state.\nfunc nw_establishment_report_get_attempt_started_after_milliseconds(nw_establishment_report_t) -> UInt64\nAccesses the time between the call to start and the beginning of the successful connection attempt, in milliseconds.\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment.\nInspecting Protocol Handshakes\nfunc nw_establishment_report_enumerate_protocols(nw_establishment_report_t, (nw_protocol_definition_t, UInt64, UInt64) -> Bool)\nIterates a list of protocol handshakes in order from first completed to last completed.\ntypealias nw_report_protocol_enumerator_t\nA block used to enumerate protocol handshakes performed during connection establishment.\nChecking for Proxies\nfunc nw_establishment_report_get_proxy_configured(nw_establishment_report_t) -> Bool\nChecks whether a proxy was configured on the connection.\nfunc nw_establishment_report_get_used_proxy(nw_establishment_report_t) -> Bool\nChecks whether the connection used a proxy.\nfunc nw_establishment_report_copy_proxy_endpoint(nw_establishment_report_t) -> nw_endpoint_t?\nAccesses the endpoint of the proxy the connection used.\nSee Also\nCollecting Connection Metrics\nfunc nw_connection_access_establishment_report(nw_connection_t, dispatch_queue_t, nw_establishment_report_access_block_t)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\ntypealias nw_establishment_report_access_block_t\nA block that delivers a connection's establishment report when it's in the ready state.\ntypealias nw_data_transfer_report_t\nA report that provides metrics about data being sent and received on a connection.\nfunc nw_connection_create_new_data_transfer_report(nw_connection_t) -> nw_data_transfer_report_t\nBegins a new data transfer report, which can later be collected."
    },
    {
        "title": "nw_framer_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_t",
        "html": "Discussion\n\nAll interaction between your protocol and the connection occurs through this object.\n\nSee Also\nAdding Framers to Connections\nfunc nw_framer_create_definition(UnsafePointer<CChar>, UInt32, nw_framer_start_handler_t) -> nw_protocol_definition_t\nInitializes a new protocol definition based on your protocol implementation.\ntypealias nw_framer_start_handler_t\nA handler that represents the entry point into your custom protocol.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nvar NW_FRAMER_CREATE_FLAGS_DEFAULT: Int32\nA constant flag value that indicates that the default framer protocol behavior should be used.\nfunc nw_framer_create_options(nw_protocol_definition_t) -> nw_protocol_options_t\nInitializes a set of protocol options with a custom framer definition."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/network/ipaddress/2998479-init",
        "html": "Required\n\nDiscussion\n\nThe provided string will be interpreted as an IPv4 or IPv6 address. If the string cannot be interpreted as an address, the initialization will fail.\n\nSee Also\nCreating Addresses\ninit?(Data, NWInterface?)\nInitializes an IP address with data.\n\nRequired"
    },
    {
        "title": "NWBrowser.Descriptor",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/descriptor",
        "html": "Topics\nDescriptor Types\ncase bonjour(type: String, domain: String?)\nA service descriptor used to discover a Bonjour service.\ncase bonjourWithTXTRecord(type: String, domain: String?)\nA service descriptor used to discover a Bonjour service with associated TXT records.\nEnumeration Cases\ncase applicationService(name: String)\nReturns a browser descriptor for application services.\nRelationships\nConforms To\nSendable\nSee Also\nBrowsing for Services\ninit(for: NWBrowser.Descriptor, using: NWParameters)\nInitializes a browser with a type of service to discover.\nfunc start(queue: DispatchQueue)\nStarts browsing for services, and sets the queue on which all browser events will be delivered.\nvar browseResultsChangedHandler: (Set<NWBrowser.Result>, Set<NWBrowser.Result.Change>) -> Void)?\nA handler that delivers updates about discovered services.\nstruct NWBrowser.Result\nA set of discovered services and changes from the last result.\nvar browseResults: Set<NWBrowser.Result>\nThe list of discovered services."
    },
    {
        "title": "finalMessage",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/3003623-finalmessage",
        "html": "Discussion\n\nOnce this context is used for sending, and the send is marked as complete, no more data can be sent on the connection.\n\nSee Also\nUsing Constant Send Contexts\nstatic let defaultMessage: NWConnection.ContentContext\nA static context representing a message with default properties.\nstatic let defaultStream: NWConnection.ContentContext\nA static context representing the total stream of bytes on a connection."
    },
    {
        "title": "NWConnection.State.failed(_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state/failed",
        "html": "See Also\nStates\ncase setup\nThe connection has been initialized but not started.\ncase waiting(NWError)\nThe connection is waiting for a network path change.\ncase preparing\nThe connection in the process of being established.\ncase ready\nThe connection is established, and ready to send and receive data.\ncase cancelled\nThe connection has been canceled."
    },
    {
        "title": "NWConnection.State.cancelled",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state/cancelled",
        "html": "See Also\nStates\ncase setup\nThe connection has been initialized but not started.\ncase waiting(NWError)\nThe connection is waiting for a network path change.\ncase preparing\nThe connection in the process of being established.\ncase ready\nThe connection is established, and ready to send and receive data.\ncase failed(NWError)\nThe connection has disconnected or encountered an error."
    },
    {
        "title": "NWParameters.ExpiredDNSBehavior.systemDefault",
        "url": "https://developer.apple.com/documentation/network/nwparameters/expireddnsbehavior/systemdefault",
        "html": "See Also\nBehaviors\ncase allow\nExplicitly allow the use of expired DNS answers.\ncase prohibit\nExplicitly prohibit the use of expired DNS answers."
    },
    {
        "title": "NWConnection.State.preparing",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state/preparing",
        "html": "See Also\nStates\ncase setup\nThe connection has been initialized but not started.\ncase waiting(NWError)\nThe connection is waiting for a network path change.\ncase ready\nThe connection is established, and ready to send and receive data.\ncase failed(NWError)\nThe connection has disconnected or encountered an error.\ncase cancelled\nThe connection has been canceled."
    },
    {
        "title": "NWConnection.State.waiting(_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state/waiting",
        "html": "Discussion\n\nConnections that are waiting will indicate the reason that the connection couldn't be established in the associated error. These errors are not fatal.\n\nSee Also\nStates\ncase setup\nThe connection has been initialized but not started.\ncase preparing\nThe connection in the process of being established.\ncase ready\nThe connection is established, and ready to send and receive data.\ncase failed(NWError)\nThe connection has disconnected or encountered an error.\ncase cancelled\nThe connection has been canceled."
    },
    {
        "title": "NWConnection.State.setup",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state/setup",
        "html": "See Also\nStates\ncase waiting(NWError)\nThe connection is waiting for a network path change.\ncase preparing\nThe connection in the process of being established.\ncase ready\nThe connection is established, and ready to send and receive data.\ncase failed(NWError)\nThe connection has disconnected or encountered an error.\ncase cancelled\nThe connection has been canceled."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwparameters/expireddnsbehavior/3236836-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "NWParameters.ServiceClass.responsiveData",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/responsivedata",
        "html": "See Also\nService Classes\ncase bestEffort\nA service type to enable Cellular Network Slicing when not setting the other service types.\ncase background\nA service type for high-delay tolerant, high-loss tolerant, elastic flow, and variable size connections.\ncase interactiveVideo\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase interactiveVoice\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase signaling\nA service for low-loss tolerant, inelastic flow, jitter tolerant, bursty but short rate, and variable size connections."
    },
    {
        "title": "NWParameters.ServiceClass.bestEffort",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/besteffort",
        "html": "See Also\nService Classes\ncase background\nA service type for high-delay tolerant, high-loss tolerant, elastic flow, and variable size connections.\ncase interactiveVideo\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase interactiveVoice\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase responsiveData\nA service type for medium-delay tolerant, elastic and inelastic flow, bursty, and long-lived connections.\ncase signaling\nA service for low-loss tolerant, inelastic flow, jitter tolerant, bursty but short rate, and variable size connections."
    },
    {
        "title": "NWParameters.ExpiredDNSBehavior.prohibit",
        "url": "https://developer.apple.com/documentation/network/nwparameters/expireddnsbehavior/prohibit",
        "html": "See Also\nBehaviors\ncase systemDefault\nLet the system determine whether or not to allow expired DNS answers.\ncase allow\nExplicitly allow the use of expired DNS answers."
    },
    {
        "title": "NWParameters.ExpiredDNSBehavior.allow",
        "url": "https://developer.apple.com/documentation/network/nwparameters/expireddnsbehavior/allow",
        "html": "See Also\nBehaviors\ncase systemDefault\nLet the system determine whether or not to allow expired DNS answers.\ncase prohibit\nExplicitly prohibit the use of expired DNS answers."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/2998683",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Service Classes\nstatic func == (NWParameters.ServiceClass, NWParameters.ServiceClass) -> Bool\nReturns a Boolean value indicating whether two values are equal."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/3236842-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nAccessing the hash value\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
    },
    {
        "title": "nw_ws_request_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_request_t",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_ws_additional_header_enumerator_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_additional_header_enumerator_t",
        "html": "Return Value\n\nReturn true to continue enumerating, or false to stop enumerating.\n\nSee Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype/3236838-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype/2998673",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "nw_txt_record_access_key_t",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_access_key_t",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype/3236839-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "nw_ws_metadata_get_opcode(_:)",
        "url": "https://developer.apple.com/documentation/network/3143621-nw_ws_metadata_get_opcode",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake."
    },
    {
        "title": "nw_ws_options_set_auto_reply_ping(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3143634-nw_ws_options_set_auto_reply_pin",
        "html": "See Also\nCreating WebSocket Connections\nfunc nw_protocol_copy_ws_definition() -> nw_protocol_definition_t\nAccesses the system definition of the WebSocket protocol.\nfunc nw_ws_create_options(nw_ws_version_t) -> nw_protocol_options_t\nInitializes a default set of WebSocket connection options.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol.\nfunc nw_ws_options_set_maximum_message_size(nw_protocol_options_t, Int)\nSets the maximum allowed message size, in bytes, to be received by the WebSocket connection."
    },
    {
        "title": "nw_ws_metadata_get_close_code(_:)",
        "url": "https://developer.apple.com/documentation/network/3143620-nw_ws_metadata_get_close_code",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake."
    },
    {
        "title": "nw_tls_copy_sec_protocol_options(_:)",
        "url": "https://developer.apple.com/documentation/network/2976942-nw_tls_copy_sec_protocol_options",
        "html": "See Also\nCreating TLS Connections\nfunc nw_protocol_copy_tls_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Transport Layer Security protocol.\nfunc nw_tls_create_options() -> nw_protocol_options_t\nInitializes a default set of TLS connection options."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/2998585-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nComparing Hosts\ninit(unicodeScalarLiteral: StringLiteralType)\nCreates an instance initialized to the given value.\ninit(stringLiteral: NWEndpoint.Host.StringLiteralType)\ntypealias NWEndpoint.Host.StringLiteralType\ninit(extendedGraphemeClusterLiteral: String)\nCreates an instance initialized to the given value.\nstatic func != (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/2998582",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Hosts\ninit(unicodeScalarLiteral: StringLiteralType)\nCreates an instance initialized to the given value.\ninit(stringLiteral: NWEndpoint.Host.StringLiteralType)\ntypealias NWEndpoint.Host.StringLiteralType\ninit(extendedGraphemeClusterLiteral: String)\nCreates an instance initialized to the given value.\nvar debugDescription: String\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/3003627-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Hosts\ninit(unicodeScalarLiteral: StringLiteralType)\nCreates an instance initialized to the given value.\ninit(stringLiteral: NWEndpoint.Host.StringLiteralType)\ntypealias NWEndpoint.Host.StringLiteralType\ninit(extendedGraphemeClusterLiteral: String)\nCreates an instance initialized to the given value.\nvar debugDescription: String\nstatic func != (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "init(stringLiteral:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/2998589-init",
        "html": "Relationships\nFrom Protocol\nExpressibleByStringLiteral\nSee Also\nComparing Hosts\ninit(unicodeScalarLiteral: StringLiteralType)\nCreates an instance initialized to the given value.\ntypealias NWEndpoint.Host.StringLiteralType\ninit(extendedGraphemeClusterLiteral: String)\nCreates an instance initialized to the given value.\nvar debugDescription: String\nstatic func != (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "init(extendedGraphemeClusterLiteral:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host/2998588-init",
        "html": "Parameters\nvalue\n\nThe value of the new instance.\n\nDiscussion\n\nNote\n\nThis documentation comment was inherited from ExpressibleByExtendedGraphemeClusterLiteral.\n\nSee Also\nComparing Hosts\ninit(unicodeScalarLiteral: StringLiteralType)\nCreates an instance initialized to the given value.\ninit(stringLiteral: NWEndpoint.Host.StringLiteralType)\ntypealias NWEndpoint.Host.StringLiteralType\nvar debugDescription: String\nstatic func != (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "aggregatePathReport",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/3200420-aggregatepathreport",
        "html": "See Also\nExamining Data Transfer\nlet pathReports: [NWConnection.DataTransferReport.PathReport]\nAn array of reports for each network path the connection used.\nstruct NWConnection.DataTransferReport.PathReport\nA report that contains details about data transfer over a single network path."
    },
    {
        "title": "pathReports",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/3200423-pathreports",
        "html": "See Also\nExamining Data Transfer\nlet aggregatePathReport: NWConnection.DataTransferReport.PathReport\nA report that sums counts across all network paths.\nstruct NWConnection.DataTransferReport.PathReport\nA report that contains details about data transfer over a single network path."
    },
    {
        "title": "duration",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport/3200422-duration",
        "html": "See Also\nSummarizing Reports\nvar debugDescription: String\nThe description of the report."
    },
    {
        "title": "nw_tls_copy_sec_protocol_metadata(_:)",
        "url": "https://developer.apple.com/documentation/network/2976941-nw_tls_copy_sec_protocol_metadat",
        "html": "See Also\nInspecting TLS State\nfunc nw_protocol_metadata_is_tls(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains TLS connection state."
    },
    {
        "title": "nw_connection_state_changed_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_changed_handler_t",
        "html": "See Also\nHandling State Updates\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nfunc nw_connection_set_state_changed_handler(nw_connection_t, nw_connection_state_changed_handler_t?)\nSets a handler to receive connection state updates."
    },
    {
        "title": "nw_group_descriptor_t",
        "url": "https://developer.apple.com/documentation/network/nw_group_descriptor_t",
        "html": "See Also\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages."
    },
    {
        "title": "nw_listener_new_connection_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_listener_new_connection_handler_t",
        "html": "See Also\nReceiving Connections\nfunc nw_listener_set_new_connection_handler(nw_listener_t, nw_listener_new_connection_handler_t?)\nSets a handler that receives inbound connections.\nfunc nw_listener_set_new_connection_limit(nw_listener_t, UInt32)\nResets the number of inbound connections to deliver before rejecting connections.\nfunc nw_listener_get_new_connection_limit(nw_listener_t) -> UInt32\nChecks the remaining number of inbound connections to deliver before rejecting connections.\nvar NW_LISTENER_INFINITE_CONNECTION_LIMIT: UInt32\nA static value that indicates that inbound connections should not be limited."
    },
    {
        "title": "nw_path_monitor_update_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_monitor_update_handler_t",
        "html": "See Also\nHandling Path Updates\nfunc nw_path_monitor_set_update_handler(nw_path_monitor_t, nw_path_monitor_update_handler_t)\nSets a handler to receive network path updates."
    },
    {
        "title": "nw_path_enumerate_interfaces_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_enumerate_interfaces_block_t",
        "html": "Return Value\n\nReturn true to continue enumerating, or false to stop enumerating.\n\nSee Also\nInspecting Interfaces\nfunc nw_path_uses_interface_type(nw_path_t, nw_interface_type_t) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nfunc nw_path_enumerate_interfaces(nw_path_t, (nw_interface_t) -> Bool)\nEnumerates the list of all interfaces available to the path, in order of preference.\nfunc nw_path_enumerate_gateways(nw_path_t, (nw_endpoint_t) -> Bool)\nEnumerates the list of gateways configured on the interfaces available to a path.\ntypealias nw_path_enumerate_gateways_block_t\nA block that enumerates the gateways configured on the interfaces available to a path."
    },
    {
        "title": "nw_interface_t",
        "url": "https://developer.apple.com/documentation/network/nw_interface_t",
        "html": "Topics\nNetwork Interface Types\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nInspecting Interfaces\nfunc nw_interface_get_type(nw_interface_t) -> nw_interface_type_t\nAccesses the type of the interface, such as Wi-Fi or Loopback.\nfunc nw_interface_get_name(nw_interface_t) -> UnsafePointer<CChar>\nAccesses the name of the interface.\nfunc nw_interface_get_index(nw_interface_t) -> UInt32\nAccesses the system interface index associated with the interface."
    },
    {
        "title": "nw_listener_advertised_endpoint_changed_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_listener_advertised_endpoint_changed_handler_t",
        "html": "See Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nfunc nw_listener_set_advertise_descriptor(nw_listener_t, nw_advertise_descriptor_t?)\nSets a Bonjour service that advertises the listener on the local network.\ntypealias nw_advertise_descriptor_t\nA description used to advertise the Bonjour service that a listener provides.\nfunc nw_listener_set_advertised_endpoint_changed_handler(nw_listener_t, nw_listener_advertised_endpoint_changed_handler_t?)\nSets a handler that receives updates for the service endpoint being advertised."
    },
    {
        "title": "nw_group_descriptor_enumerate_endpoints_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_group_descriptor_enumerate_endpoints_block_t",
        "html": "See Also\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages."
    },
    {
        "title": "nw_path_monitor_cancel_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_monitor_cancel_handler_t",
        "html": "See Also\nCanceling Path Monitors\nfunc nw_path_monitor_cancel(nw_path_monitor_t)\nStops receiving network path updates.\nfunc nw_path_monitor_set_cancel_handler(nw_path_monitor_t, nw_path_monitor_cancel_handler_t)\nSets a handler to determine when a monitor is fully cancelled and will no longer deliver events."
    },
    {
        "title": "NWBrowser.Result",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/result",
        "html": "Topics\nEvaluating Browser Results\nlet endpoint: NWEndpoint\nThe discovered service endpoint.\nlet interfaces: [NWInterface]\nThe list of interfaces on which the service was discovered.\nlet metadata: NWBrowser.Result.Metadata\nThe metadata associated with the discovered service, such as the TXT record.\nenum NWBrowser.Result.Metadata\nValues associated with discovered services, such as TXT records.\nstruct NWTXTRecord\nA dictionary representing a TXT record in a DNS packet.\nComparing Results\nenum NWBrowser.Result.Change\nWays in which discovered services can change between specific results.\nstatic func == (NWBrowser.Result, NWBrowser.Result) -> Bool\nstatic func != (NWBrowser.Result, NWBrowser.Result) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nInstance Properties\nvar hashValue: Int\nRelationships\nConforms To\nHashable\nSendable\nSee Also\nBrowsing for Services\ninit(for: NWBrowser.Descriptor, using: NWParameters)\nInitializes a browser with a type of service to discover.\nenum NWBrowser.Descriptor\nA service description used to discover Bonjour services.\nfunc start(queue: DispatchQueue)\nStarts browsing for services, and sets the queue on which all browser events will be delivered.\nvar browseResultsChangedHandler: (Set<NWBrowser.Result>, Set<NWBrowser.Result.Change>) -> Void)?\nA handler that delivers updates about discovered services.\nvar browseResults: Set<NWBrowser.Result>\nThe list of discovered services."
    },
    {
        "title": "stateUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200404-stateupdatehandler",
        "html": "See Also\nManaging Browsers\nenum NWBrowser.State\nStates indicating whether a browser is able to discover services.\nvar state: NWBrowser.State\nThe current state of the browser.\nfunc cancel()\nStops browsing for services."
    },
    {
        "title": "defaultMessage",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext/3003621-defaultmessage",
        "html": "Discussion\n\nYou should use this context for sending content unless there is a reason to override some values.\n\nSee Also\nUsing Constant Send Contexts\nstatic let finalMessage: NWConnection.ContentContext\nA static context that's marked as the final message in a connection.\nstatic let defaultStream: NWConnection.ContentContext\nA static context representing the total stream of bytes on a connection."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/expireddnsbehavior/3003631",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/expireddnsbehavior/3236835-hash",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "nw_ws_client_request_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_client_request_handler_t",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_ws_response_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_response_t",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_txt_record_t",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_t",
        "html": "Topics\nCreating TXT Records\nfunc nw_txt_record_create_dictionary() -> nw_txt_record_t\nInitializes a TXT record as a dictionary of strings.\nfunc nw_txt_record_create_with_bytes(UnsafePointer<UInt8>, Int) -> nw_txt_record_t\nInitializes a TXT record with raw bytes.\nfunc nw_txt_record_copy(nw_txt_record_t?) -> nw_txt_record_t?\nPerforms a deep copy of a TXT record.\nfunc nw_txt_record_set_key(nw_txt_record_t, UnsafePointer<CChar>, UnsafePointer<UInt8>?, Int) -> Bool\nSets a data value in a TXT record dictionary.\nfunc nw_txt_record_remove_key(nw_txt_record_t, UnsafePointer<CChar>) -> Bool\nRemoves a data value in a TXT record dictionary.\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record.\nSee Also\nHandling TXT Records\nfunc nw_browse_result_copy_txt_record_object(nw_browse_result_t) -> nw_txt_record_t?\nAccesses the TXT record associated with a discovered service."
    },
    {
        "title": "nw_ws_pong_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_pong_handler_t",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/3236840",
        "html": "Parameters\na\n\nA value to compare.\n\nb\n\nA value to compare.\n\nReturn Value\n\nReturns a Boolean value indicating whether two values are equal.\n\nSee Also\nComparing Service Classes\nstatic func != (NWParameters.ServiceClass, NWParameters.ServiceClass) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "NWParameters.ServiceClass.interactiveVideo",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass/interactivevideo",
        "html": "See Also\nService Classes\ncase bestEffort\nA service type to enable Cellular Network Slicing when not setting the other service types.\ncase background\nA service type for high-delay tolerant, high-loss tolerant, elastic flow, and variable size connections.\ncase interactiveVoice\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase responsiveData\nA service type for medium-delay tolerant, elastic and inelastic flow, bursty, and long-lived connections.\ncase signaling\nA service for low-loss tolerant, inelastic flow, jitter tolerant, bursty but short rate, and variable size connections."
    },
    {
        "title": "NWParameters.MultipathServiceType.disabled",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype/disabled",
        "html": "See Also\nMultipath Service Types\ncase handover\nEnable multipath, but only use other interfaces when the primary interface is lost.\ncase interactive\nEnable multipath to use other interfaces when the primary interface encounters loss or delay.\ncase aggregate\nEnable multipath to maximize bandwidth across multiple interfaces."
    },
    {
        "title": "NWParameters.MultipathServiceType.aggregate",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype/aggregate",
        "html": "See Also\nMultipath Service Types\ncase disabled\nDisable multipath.\ncase handover\nEnable multipath, but only use other interfaces when the primary interface is lost.\ncase interactive\nEnable multipath to use other interfaces when the primary interface encounters loss or delay."
    },
    {
        "title": "NWParameters.MultipathServiceType.interactive",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype/interactive",
        "html": "See Also\nMultipath Service Types\ncase disabled\nDisable multipath.\ncase handover\nEnable multipath, but only use other interfaces when the primary interface is lost.\ncase aggregate\nEnable multipath to maximize bandwidth across multiple interfaces."
    },
    {
        "title": "NWParameters.MultipathServiceType.handover",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype/handover",
        "html": "See Also\nMultipath Service Types\ncase disabled\nDisable multipath.\ncase interactive\nEnable multipath to use other interfaces when the primary interface encounters loss or delay.\ncase aggregate\nEnable multipath to maximize bandwidth across multiple interfaces."
    },
    {
        "title": "nw_quic_set_initial_max_data(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801762-nw_quic_set_initial_max_data",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\ninitial_max_data\n\nThe value of the initial_max_data transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_tcp_create_options()",
        "url": "https://developer.apple.com/documentation/network/2976921-nw_tcp_create_options",
        "html": "See Also\nCreating TCP Connections\nfunc nw_protocol_copy_tcp_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Transport Control Protocol."
    },
    {
        "title": "nw_content_context_t",
        "url": "https://developer.apple.com/documentation/network/nw_content_context_t",
        "html": "Discussion\n\nFor sending, you should use NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT unless there is a reason to override some values.\n\nYou can pass NW_CONNECTION_FINAL_MESSAGE_CONTEXT to mark the final message in a connection. Once this context is used for sending, and the send is marked as complete, no more data can be sent on the connection.\n\nIf you are using a protocol that expects message content, like WebSocket or a custom framer, create a custom context and set metadata using nw_content_context_set_metadata_for_protocol(_:_:).\n\nTopics\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context.\nInspecting Receive Contexts\nfunc nw_content_context_get_is_final(nw_content_context_t) -> Bool\nChecks whether this context represents the final message being received.\nfunc nw_content_context_copy_protocol_metadata(nw_content_context_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetreives the metadata associated with a specific protocol.\nfunc nw_content_context_foreach_protocol_metadata(nw_content_context_t, (nw_protocol_definition_t, nw_protocol_metadata_t) -> Void)\nIterates through all protocol metadata associated with the message context.\nSee Also\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "nw_quic_set_idle_timeout(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801761-nw_quic_set_idle_timeout",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nidle_timeout\n\nAn idle timeout value, in milliseconds.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_connection_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_t",
        "html": "Topics\nCreating Connections\nfunc nw_connection_create(nw_endpoint_t, nw_parameters_t) -> nw_connection_t\nInitializes a new connection to a remote endpoint.\nfunc nw_connection_set_queue(nw_connection_t, dispatch_queue_t)\nSets the queue on which all connection events are delivered.\nfunc nw_connection_start(nw_connection_t)\nStarts establishing a connection.\nfunc nw_connection_restart(nw_connection_t)\nRestarts a connection that is in the waiting state.\nHandling State Updates\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nfunc nw_connection_set_state_changed_handler(nw_connection_t, nw_connection_state_changed_handler_t?)\nSets a handler to receive connection state updates.\ntypealias nw_connection_state_changed_handler_t\nA handler that delivers connection state updates with associated errors.\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection.\nCanceling Connections\nfunc nw_connection_cancel(nw_connection_t)\nCancels the connection and gracefully disconnects any established network protocols.\nfunc nw_connection_force_cancel(nw_connection_t)\nCancels the connection and immediately disconnects any established network protocols.\nfunc nw_connection_cancel_current_endpoint(nw_connection_t)\nCauses the current endpoint to be rejected, allowing the connection to try another resolved address.\nHandling Path Updates\nfunc nw_connection_copy_current_path(nw_connection_t) -> nw_path_t?\nAccesses the network path the connection is using.\nfunc nw_connection_set_path_changed_handler(nw_connection_t, nw_connection_path_event_handler_t?)\nSets a handler that receives network path updates.\ntypealias nw_connection_path_event_handler_t\nA handler that delivers network path updates.\nfunc nw_connection_set_viability_changed_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when data can be sent and received.\nfunc nw_connection_set_better_path_available_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when an alternative network path is preferred over the current path.\ntypealias nw_connection_boolean_event_handler_t\nA handler that receives Boolean state updates from a connection, such as viability and better path state.\nCollecting Connection Metrics\ntypealias nw_establishment_report_t\nA report that provides metrics about how a connection was established.\nfunc nw_connection_access_establishment_report(nw_connection_t, dispatch_queue_t, nw_establishment_report_access_block_t)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\ntypealias nw_establishment_report_access_block_t\nA block that delivers a connection's establishment report when it's in the ready state.\ntypealias nw_data_transfer_report_t\nA report that provides metrics about data being sent and received on a connection.\nfunc nw_connection_create_new_data_transfer_report(nw_connection_t) -> nw_data_transfer_report_t\nBegins a new data transfer report, which can later be collected.\nCopying Connection State\nfunc nw_connection_copy_protocol_metadata(nw_connection_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetrieves the connection-wide metadata for a specific protocol.\nfunc nw_connection_copy_endpoint(nw_connection_t) -> nw_endpoint_t\nAccesses the endpoint with which the connection was created.\nfunc nw_connection_copy_parameters(nw_connection_t) -> nw_parameters_t\nAccesses the parameters with which the connection was created.\nfunc nw_connection_copy_description(nw_connection_t) -> UnsafeMutablePointer<CChar>\nCopies the description of the connection as a string."
    },
    {
        "title": "nw_tcp_options_set_no_push(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976935-nw_tcp_options_set_no_push",
        "html": "See Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "nw_connection_group_send_completion_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_send_completion_t",
        "html": "See Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group."
    },
    {
        "title": "nw_browse_result_enumerate_interface_t",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_enumerate_interface_t",
        "html": "Return Value\n\nReturn true to continue enumerating, or false to stop enumerating.\n\nSee Also\nEvaluating Browser Results\nfunc nw_browse_result_copy_endpoint(nw_browse_result_t) -> nw_endpoint_t\nThe discovered service endpoint.\nfunc nw_browse_result_enumerate_interfaces(nw_browse_result_t, (nw_interface_t) -> Bool)\nEnumerates the list of interfaces on which the service was discovered.\nfunc nw_browse_result_get_interfaces_count(nw_browse_result_t) -> Int\nAccesses the number of interfaces associated with a discovered service."
    },
    {
        "title": "parameters",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200400-parameters",
        "html": "See Also\nInspecting Browsers\nlet descriptor: NWBrowser.Descriptor\nThe service descriptor with which the browser was initialized.\nvar queue: DispatchQueue?\nThe queue on which browser events are delivered.\nvar debugDescription: String\nThe description of the browser."
    },
    {
        "title": "browseResults",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200394-browseresults",
        "html": "See Also\nBrowsing for Services\ninit(for: NWBrowser.Descriptor, using: NWParameters)\nInitializes a browser with a type of service to discover.\nenum NWBrowser.Descriptor\nA service description used to discover Bonjour services.\nfunc start(queue: DispatchQueue)\nStarts browsing for services, and sets the queue on which all browser events will be delivered.\nvar browseResultsChangedHandler: (Set<NWBrowser.Result>, Set<NWBrowser.Result.Change>) -> Void)?\nA handler that delivers updates about discovered services.\nstruct NWBrowser.Result\nA set of discovered services and changes from the last result."
    },
    {
        "title": "NWProtocolTLS.Options",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltls/options",
        "html": "Topics\nCustomizing TLS Connections\ninit()\nInitializes a default set of TLS connection options.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options TLS uses.\nRelationships\nInherits From\nNWProtocolOptions\nSee Also\nCreating TLS Connections\nstatic let definition: NWProtocolDefinition\nThe system definition of the Transport Layer Security protocol."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200397-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Browsers\nlet descriptor: NWBrowser.Descriptor\nThe service descriptor with which the browser was initialized.\nlet parameters: NWParameters\nThe parameters with which the browser was initialized.\nvar queue: DispatchQueue?\nThe queue on which browser events are delivered."
    },
    {
        "title": "queue",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200401-queue",
        "html": "See Also\nInspecting Browsers\nlet descriptor: NWBrowser.Descriptor\nThe service descriptor with which the browser was initialized.\nlet parameters: NWParameters\nThe parameters with which the browser was initialized.\nvar debugDescription: String\nThe description of the browser."
    },
    {
        "title": "descriptor",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200398-descriptor",
        "html": "See Also\nInspecting Browsers\nlet parameters: NWParameters\nThe parameters with which the browser was initialized.\nvar queue: DispatchQueue?\nThe queue on which browser events are delivered.\nvar debugDescription: String\nThe description of the browser."
    },
    {
        "title": "NWBrowser.State",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/state",
        "html": "Topics\nStates\ncase setup\nThe browser has been initialized but not started.\ncase ready\nThe browser is registered for discovering services.\ncase failed(NWError)\nThe browser has encountered a fatal error.\ncase cancelled\nThe browser has been canceled.\nEnumeration Cases\ncase waiting(NWError)\nOperator Functions\nstatic func != (NWBrowser.State, NWBrowser.State) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWBrowser.State, NWBrowser.State) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nManaging Browsers\nvar stateUpdateHandler: (NWBrowser.State) -> Void)?\nA handler that receives browser state updates.\nvar state: NWBrowser.State\nThe current state of the browser.\nfunc cancel()\nStops browsing for services."
    },
    {
        "title": "cancel()",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200396-cancel",
        "html": "See Also\nManaging Browsers\nvar stateUpdateHandler: (NWBrowser.State) -> Void)?\nA handler that receives browser state updates.\nenum NWBrowser.State\nStates indicating whether a browser is able to discover services.\nvar state: NWBrowser.State\nThe current state of the browser."
    },
    {
        "title": "nw_ws_response_get_selected_subprotocol(_:)",
        "url": "https://developer.apple.com/documentation/network/3180201-nw_ws_response_get_selected_subp",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "state",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200403-state",
        "html": "See Also\nManaging Browsers\nvar stateUpdateHandler: (NWBrowser.State) -> Void)?\nA handler that receives browser state updates.\nenum NWBrowser.State\nStates indicating whether a browser is able to discover services.\nfunc cancel()\nStops browsing for services."
    },
    {
        "title": "browseResultsChangedHandler",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200395-browseresultschangedhandler",
        "html": "See Also\nBrowsing for Services\ninit(for: NWBrowser.Descriptor, using: NWParameters)\nInitializes a browser with a type of service to discover.\nenum NWBrowser.Descriptor\nA service description used to discover Bonjour services.\nfunc start(queue: DispatchQueue)\nStarts browsing for services, and sets the queue on which all browser events will be delivered.\nstruct NWBrowser.Result\nA set of discovered services and changes from the last result.\nvar browseResults: Set<NWBrowser.Result>\nThe list of discovered services."
    },
    {
        "title": "start(queue:)",
        "url": "https://developer.apple.com/documentation/network/nwbrowser/3200402-start",
        "html": "See Also\nBrowsing for Services\ninit(for: NWBrowser.Descriptor, using: NWParameters)\nInitializes a browser with a type of service to discover.\nenum NWBrowser.Descriptor\nA service description used to discover Bonjour services.\nvar browseResultsChangedHandler: (Set<NWBrowser.Result>, Set<NWBrowser.Result.Change>) -> Void)?\nA handler that delivers updates about discovered services.\nstruct NWBrowser.Result\nA set of discovered services and changes from the last result.\nvar browseResults: Set<NWBrowser.Result>\nThe list of discovered services."
    },
    {
        "title": "nw_ws_response_get_status(_:)",
        "url": "https://developer.apple.com/documentation/network/3180202-nw_ws_response_get_status",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_quic_get_remote_max_streams_bidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801755-nw_quic_get_remote_max_streams_b",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\n\nSee Also\nInspecting Connection State\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "nw_ws_response_enumerate_additional_headers(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180200-nw_ws_response_enumerate_additio",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response."
    },
    {
        "title": "nw_ws_response_create(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180199-nw_ws_response_create",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_ws_options_set_maximum_message_size(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3143635-nw_ws_options_set_maximum_messag",
        "html": "See Also\nCreating WebSocket Connections\nfunc nw_protocol_copy_ws_definition() -> nw_protocol_definition_t\nAccesses the system definition of the WebSocket protocol.\nfunc nw_ws_create_options(nw_ws_version_t) -> nw_protocol_options_t\nInitializes a default set of WebSocket connection options.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol.\nfunc nw_ws_options_set_auto_reply_ping(nw_protocol_options_t, Bool)\nConfigures the connection to automatically reply to Ping messages instead of delivering them to you."
    },
    {
        "title": "nw_report_resolution_enumerator_t",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_enumerator_t",
        "html": "Return Value\n\nReturn true to continue enumerating, or false to stop enumerating.\n\nSee Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved."
    },
    {
        "title": "nw_ws_options_set_skip_handshake(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3172639-nw_ws_options_set_skip_handshake",
        "html": "Discussion\n\nThis option should not be set when communicating with a generic WebSocket server or client. This option allows a custom handshake (or no handshake) to be implemented below the WebSocket layer when both client and server are coordinated.\n\nSee Also\nConfiguring Client Handshakes\nfunc nw_ws_options_add_additional_header(nw_protocol_options_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds additional HTTP header fields to be sent by the client during the WebSocket handshake.\nfunc nw_ws_options_add_subprotocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds to the list of supported application protocols that will be presented to a WebSocket server during connection establishment."
    },
    {
        "title": "nw_ws_request_enumerate_additional_headers(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180195-nw_ws_request_enumerate_addition",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_report_resolution_report_enumerator_t",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_report_enumerator_t",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_report_protocol_enumerator_t",
        "url": "https://developer.apple.com/documentation/network/nw_report_protocol_enumerator_t",
        "html": "Return Value\n\nReturn true to continue enumerating, or false to stop enumerating.\n\nSee Also\nInspecting Protocol Handshakes\nfunc nw_establishment_report_enumerate_protocols(nw_establishment_report_t, (nw_protocol_definition_t, UInt64, UInt64) -> Bool)\nIterates a list of protocol handshakes in order from first completed to last completed."
    },
    {
        "title": "nw_ws_options_set_client_request_handler(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180194-nw_ws_options_set_client_request",
        "html": "See Also\nHandling Server Handshakes\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_listener_state_changed_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_listener_state_changed_handler_t",
        "html": "See Also\nHandling State Updates\nfunc nw_listener_set_state_changed_handler(nw_listener_t, nw_listener_state_changed_handler_t?)\nSets a handler to receive listener state updates.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections."
    },
    {
        "title": "nw_listener_t",
        "url": "https://developer.apple.com/documentation/network/nw_listener_t",
        "html": "Topics\nCreating Listeners\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections.\nReceiving Connections\nfunc nw_listener_set_new_connection_handler(nw_listener_t, nw_listener_new_connection_handler_t?)\nSets a handler that receives inbound connections.\ntypealias nw_listener_new_connection_handler_t\nA handler that delivers inbound connections.\nfunc nw_listener_set_new_connection_limit(nw_listener_t, UInt32)\nResets the number of inbound connections to deliver before rejecting connections.\nfunc nw_listener_get_new_connection_limit(nw_listener_t) -> UInt32\nChecks the remaining number of inbound connections to deliver before rejecting connections.\nvar NW_LISTENER_INFINITE_CONNECTION_LIMIT: UInt32\nA static value that indicates that inbound connections should not be limited.\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nfunc nw_listener_set_advertise_descriptor(nw_listener_t, nw_advertise_descriptor_t?)\nSets a Bonjour service that advertises the listener on the local network.\ntypealias nw_advertise_descriptor_t\nA description used to advertise the Bonjour service that a listener provides.\nfunc nw_listener_set_advertised_endpoint_changed_handler(nw_listener_t, nw_listener_advertised_endpoint_changed_handler_t?)\nSets a handler that receives updates for the service endpoint being advertised.\ntypealias nw_listener_advertised_endpoint_changed_handler_t\nA handler that indicates changes to the service endpoints being advertised as they are added and removed.\nHandling State Updates\nfunc nw_listener_set_state_changed_handler(nw_listener_t, nw_listener_state_changed_handler_t?)\nSets a handler to receive listener state updates.\ntypealias nw_listener_state_changed_handler_t\nA handler that delivers listener state updates with associated errors.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections."
    },
    {
        "title": "nw_path_enumerate_gateways_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_enumerate_gateways_block_t",
        "html": "Return Value\n\nReturn true to continue enumerating, or false to stop enumerating.\n\nSee Also\nInspecting Interfaces\nfunc nw_path_uses_interface_type(nw_path_t, nw_interface_type_t) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nfunc nw_path_enumerate_interfaces(nw_path_t, (nw_interface_t) -> Bool)\nEnumerates the list of all interfaces available to the path, in order of preference.\ntypealias nw_path_enumerate_interfaces_block_t\nA block that enumerates the interfaces available to a path.\nfunc nw_path_enumerate_gateways(nw_path_t, (nw_endpoint_t) -> Bool)\nEnumerates the list of gateways configured on the interfaces available to a path."
    },
    {
        "title": "nw_object_t",
        "url": "https://developer.apple.com/documentation/network/nw_object_t",
        "html": "Discussion\n\nNetwork.framework objects are reference-counted objects that can be used with Automatic Reference Counting (ARC) or directly retained and released.\n\nThe objects also conform to the description method of NSObject to be used for debugging."
    },
    {
        "title": "nw_framer_message_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_message_t",
        "html": "See Also\nCustomizing Framer Messages\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_ethernet_channel_t",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_t",
        "html": "Discussion\n\nUse Ethernet channels to send and receive custom Ethernet frame types over an interface.\n\nCreating Ethernet channels requires the com.apple.developer.networking.custom-protocol entitlement.\n\nTopics\nManaging Ethernet Channels\nfunc nw_ethernet_channel_create(UInt16, nw_interface_t) -> nw_ethernet_channel_t\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc nw_ethernet_channel_set_queue(nw_ethernet_channel_t, dispatch_queue_t)\nSets the queue on which all channel events are delivered.\nfunc nw_ethernet_channel_start(nw_ethernet_channel_t)\nStarts the process of registering the channel.\nfunc nw_ethernet_channel_cancel(nw_ethernet_channel_t)\nUnregisters the channel from the interface.\nHandling State Updates\nfunc nw_ethernet_channel_set_state_changed_handler(nw_ethernet_channel_t, nw_ethernet_channel_state_changed_handler_t?)\nSets a handler to receive channel state updates.\ntypealias nw_ethernet_channel_state_changed_handler_t\nA handler that delivers Ethernet channel state updates with associated errors.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nSending and Receiving Ethernet Frames\nfunc nw_ethernet_channel_send(nw_ethernet_channel_t, dispatch_data_t, UInt16, UnsafeMutablePointer<UInt8>, nw_ethernet_channel_send_completion_t)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\ntypealias nw_ethernet_channel_send_completion_t\nA handler that indicates when an Ethernet frame has been sent, or if an error was encountered.\nfunc nw_ethernet_channel_set_receive_handler(nw_ethernet_channel_t, nw_ethernet_channel_receive_handler_t?)\nSets a handler to receive inbound Ethernet frames.\ntypealias nw_ethernet_channel_receive_handler_t\nA handler that delivers inbound Ethernet frames.\ntypealias nw_ethernet_address_t\nA 48-bit Ethernet address."
    },
    {
        "title": "nw_ethernet_channel_state_changed_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_changed_handler_t",
        "html": "See Also\nHandling State Updates\nfunc nw_ethernet_channel_set_state_changed_handler(nw_ethernet_channel_t, nw_ethernet_channel_state_changed_handler_t?)\nSets a handler to receive channel state updates.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames."
    },
    {
        "title": "nw_framer_cleanup_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_cleanup_handler_t",
        "html": "See Also\nManaging Instance Lifetime\nfunc nw_framer_mark_ready(nw_framer_t)\nIndicates to a connection that your protocol's handshake is complete.\nfunc nw_framer_mark_failed_with_error(nw_framer_t, Int32)\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nfunc nw_framer_prepend_application_protocol(nw_framer_t, nw_protocol_options_t) -> Bool\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready(_:).\nfunc nw_framer_set_stop_handler(nw_framer_t, nw_framer_stop_handler_t)\nSets a block to handle when the connection is being closed.\ntypealias nw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\nfunc nw_framer_set_cleanup_handler(nw_framer_t, nw_framer_cleanup_handler_t)\nSets a block to handle the final cleanup of allocations made by your protocol instance."
    },
    {
        "title": "nw_framer_input_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_input_handler_t",
        "html": "See Also\nHandling Input Data\nfunc nw_framer_set_input_handler(nw_framer_t, nw_framer_input_handler_t)\nSets a block to handle new inbound data.\nfunc nw_framer_parse_input(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of input data while inside your input handler block.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_deliver_input(nw_framer_t, UnsafePointer<UInt8>, Int, nw_framer_message_t, Bool)\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nfunc nw_framer_deliver_input_no_copy(nw_framer_t, Int, nw_framer_message_t, Bool) -> Bool\nDelivers an inbound message containing a specific number of next received bytes.\nfunc nw_framer_pass_through_input(nw_framer_t)\nIndicates that your protocol no longer needs to handle input data."
    },
    {
        "title": "nw_framer_parse_completion_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_parse_completion_t",
        "html": "Parameters\nbuffer\n\nThe pointer to bytes to parse.\n\nbuffer_length\n\nThe length of the buffer.\n\nis_complete\n\nA boolean indicating if this span of bytes represents the end of a message.\n\nReturn Value\n\nReturn the number of bytes by which to increment the input or output cursor. Once the cursor is moved, previous bytes will no longer be delivered to nw_framer_parse_input(_:_:_:_:_:) and nw_framer_deliver_input_no_copy(_:_:_:_:) for input data, or nw_framer_parse_output(_:_:_:_:_:) and nw_framer_write_output_no_copy(_:_:) for output messages.\n\nSee Also\nHandling Input Data\nfunc nw_framer_set_input_handler(nw_framer_t, nw_framer_input_handler_t)\nSets a block to handle new inbound data.\ntypealias nw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\nfunc nw_framer_parse_input(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of input data while inside your input handler block.\nfunc nw_framer_deliver_input(nw_framer_t, UnsafePointer<UInt8>, Int, nw_framer_message_t, Bool)\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nfunc nw_framer_deliver_input_no_copy(nw_framer_t, Int, nw_framer_message_t, Bool) -> Bool\nDelivers an inbound message containing a specific number of next received bytes.\nfunc nw_framer_pass_through_input(nw_framer_t)\nIndicates that your protocol no longer needs to handle input data."
    },
    {
        "title": "nw_ethernet_channel_receive_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_receive_handler_t",
        "html": "See Also\nSending and Receiving Ethernet Frames\nfunc nw_ethernet_channel_send(nw_ethernet_channel_t, dispatch_data_t, UInt16, UnsafeMutablePointer<UInt8>, nw_ethernet_channel_send_completion_t)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\ntypealias nw_ethernet_channel_send_completion_t\nA handler that indicates when an Ethernet frame has been sent, or if an error was encountered.\nfunc nw_ethernet_channel_set_receive_handler(nw_ethernet_channel_t, nw_ethernet_channel_receive_handler_t?)\nSets a handler to receive inbound Ethernet frames.\ntypealias nw_ethernet_address_t\nA 48-bit Ethernet address."
    },
    {
        "title": "nw_framer_stop_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_stop_handler_t",
        "html": "See Also\nManaging Instance Lifetime\nfunc nw_framer_mark_ready(nw_framer_t)\nIndicates to a connection that your protocol's handshake is complete.\nfunc nw_framer_mark_failed_with_error(nw_framer_t, Int32)\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nfunc nw_framer_prepend_application_protocol(nw_framer_t, nw_protocol_options_t) -> Bool\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready(_:).\nfunc nw_framer_set_stop_handler(nw_framer_t, nw_framer_stop_handler_t)\nSets a block to handle when the connection is being closed.\nfunc nw_framer_set_cleanup_handler(nw_framer_t, nw_framer_cleanup_handler_t)\nSets a block to handle the final cleanup of allocations made by your protocol instance.\ntypealias nw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated."
    },
    {
        "title": "nw_ethernet_address_t",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_address_t",
        "html": "See Also\nSending and Receiving Ethernet Frames\nfunc nw_ethernet_channel_send(nw_ethernet_channel_t, dispatch_data_t, UInt16, UnsafeMutablePointer<UInt8>, nw_ethernet_channel_send_completion_t)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\ntypealias nw_ethernet_channel_send_completion_t\nA handler that indicates when an Ethernet frame has been sent, or if an error was encountered.\nfunc nw_ethernet_channel_set_receive_handler(nw_ethernet_channel_t, nw_ethernet_channel_receive_handler_t?)\nSets a handler to receive inbound Ethernet frames.\ntypealias nw_ethernet_channel_receive_handler_t\nA handler that delivers inbound Ethernet frames."
    },
    {
        "title": "nw_framer_message_dispose_value_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_message_dispose_value_t",
        "html": "See Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_framer_block_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_block_t",
        "html": "See Also\nHandling Asynchronous Events\nfunc nw_framer_schedule_wakeup(nw_framer_t, UInt64)\nRequests that the nw_framer_wakeup_handler_t be called on your protocol at a specific time in the future.\nvar NW_FRAMER_WAKEUP_TIME_FOREVER: UInt64\nA sentinel value that indicates that no wakeup should be delivered.\nfunc nw_framer_set_wakeup_handler(nw_framer_t, nw_framer_wakeup_handler_t)\nSets a handler to receive scheduled wakeup events.\ntypealias nw_framer_wakeup_handler_t\nA handler that delivers a scheduled wakeup event.\nfunc nw_framer_async(nw_framer_t, nw_framer_block_t)\nRequests that a block be executed on the connection's internal scheduling context."
    },
    {
        "title": "nw_quic_get_initial_max_data(_:)",
        "url": "https://developer.apple.com/documentation/network/3801744-nw_quic_get_initial_max_data",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe value of the initial_max_data transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_get_initial_max_stream_data_unidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801747-nw_quic_get_initial_max_stream_d",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe value of the initial_max_stream_data_uni transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_set_local_max_streams_unidirectional(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801770-nw_quic_set_local_max_streams_un",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nmax_streams_unidirectional\n\nThe maximum number of unidirectional streams that the peer can create.\n\nSee Also\nInspecting Connection State\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "nw_quic_get_initial_max_streams_bidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801748-nw_quic_get_initial_max_streams_",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe value of the initial_max_streams_bidi transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_protocol_options_is_quic(_:)",
        "url": "https://developer.apple.com/documentation/network/3801737-nw_protocol_options_is_quic",
        "html": "Parameters\noptions\n\nA network protocol options instance.\n\nReturn Value\n\nA Boolean value that indicates whether the options object uses the QUIC protocol."
    },
    {
        "title": "nw_quic_set_max_udp_payload_size(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801771-nw_quic_set_max_udp_payload_size",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nmax_udp_payload_size\n\nThe maximum length of a QUIC packet, in bytes.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_tcp_get_available_send_buffer(_:)",
        "url": "https://developer.apple.com/documentation/network/2976923-nw_tcp_get_available_send_buffer",
        "html": "See Also\nInspecting TCP State\nfunc nw_protocol_metadata_is_tcp(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains TCP connection state.\nfunc nw_tcp_get_available_receive_buffer(nw_protocol_metadata_t) -> UInt32\nAccesses the number of available bytes in the TCP receive buffer."
    },
    {
        "title": "nw_resolution_report_get_endpoint_count(_:)",
        "url": "https://developer.apple.com/documentation/network/3548028-nw_resolution_report_get_endpoin",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_tcp_options_set_connection_timeout(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976924-nw_tcp_options_set_connection_ti",
        "html": "See Also\nSetting Timeouts\nfunc nw_tcp_options_set_retransmit_connection_drop_time(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits between retransmission attempts.\nfunc nw_tcp_options_set_persist_timeout(nw_protocol_options_t, UInt32)\nSets the TCP persist timeout in seconds, as defined by RFC 6429."
    },
    {
        "title": "nw_quic_set_stream_is_datagram(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3951300-nw_quic_set_stream_is_datagram",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nis_datagram\n\nA Boolean value that indicates whether the QUIC stream is a datagram flow.\n\nSee Also\nCustomizing Stream Options\nfunc nw_quic_set_stream_is_unidirectional(nw_protocol_options_t, Bool)\nConfigures a QUIC stream as unidirectional, instead of bidirectional.\nfunc nw_quic_get_stream_is_unidirectional(nw_protocol_options_t) -> Bool\nChecks if a QUIC stream is unidirectional, instead of bidirectional."
    },
    {
        "title": "nw_quic_set_stream_is_unidirectional(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801773-nw_quic_set_stream_is_unidirecti",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nis_unidirectional\n\nA Boolean value that indicates whether the QUIC stream is unidirectional.\n\nSee Also\nCustomizing Stream Options\nfunc nw_quic_get_stream_is_unidirectional(nw_protocol_options_t) -> Bool\nChecks if a QUIC stream is unidirectional, instead of bidirectional.\nfunc nw_quic_set_stream_is_datagram(nw_protocol_options_t, Bool)\nConfigures a QUIC stream as a datagram flow, instead of a byte stream."
    },
    {
        "title": "nw_ws_metadata_copy_server_response(_:)",
        "url": "https://developer.apple.com/documentation/network/3180191-nw_ws_metadata_copy_server_respo",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered."
    },
    {
        "title": "nw_ws_create_options(_:)",
        "url": "https://developer.apple.com/documentation/network/3143619-nw_ws_create_options",
        "html": "See Also\nCreating WebSocket Connections\nfunc nw_protocol_copy_ws_definition() -> nw_protocol_definition_t\nAccesses the system definition of the WebSocket protocol.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol.\nfunc nw_ws_options_set_auto_reply_ping(nw_protocol_options_t, Bool)\nConfigures the connection to automatically reply to Ping messages instead of delivering them to you.\nfunc nw_ws_options_set_maximum_message_size(nw_protocol_options_t, Int)\nSets the maximum allowed message size, in bytes, to be received by the WebSocket connection."
    },
    {
        "title": "nw_txt_record_get_key_count(_:)",
        "url": "https://developer.apple.com/documentation/network/3114145-nw_txt_record_get_key_count",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_txt_record_set_key(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114149-nw_txt_record_set_key",
        "html": "See Also\nCreating TXT Records\nfunc nw_txt_record_create_dictionary() -> nw_txt_record_t\nInitializes a TXT record as a dictionary of strings.\nfunc nw_txt_record_create_with_bytes(UnsafePointer<UInt8>, Int) -> nw_txt_record_t\nInitializes a TXT record with raw bytes.\nfunc nw_txt_record_copy(nw_txt_record_t?) -> nw_txt_record_t?\nPerforms a deep copy of a TXT record.\nfunc nw_txt_record_remove_key(nw_txt_record_t, UnsafePointer<CChar>) -> Bool\nRemoves a data value in a TXT record dictionary."
    },
    {
        "title": "nw_txt_record_apply(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114134-nw_txt_record_apply",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_txt_record_access_key(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114131-nw_txt_record_access_key",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_txt_record_access_bytes(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114129-nw_txt_record_access_bytes",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_tls_create_options()",
        "url": "https://developer.apple.com/documentation/network/2976943-nw_tls_create_options",
        "html": "See Also\nCreating TLS Connections\nfunc nw_protocol_copy_tls_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Transport Layer Security protocol.\nfunc nw_tls_copy_sec_protocol_options(nw_protocol_options_t) -> sec_protocol_options_t\nAccesses the handshake security options TLS will use."
    },
    {
        "title": "nw_tcp_options_set_no_options(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976934-nw_tcp_options_set_no_options",
        "html": "See Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "nw_tcp_options_set_maximum_segment_size(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976932-nw_tcp_options_set_maximum_segme",
        "html": "See Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "nw_connection_send_completion_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_send_completion_t",
        "html": "See Also\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "nw_connection_boolean_event_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_boolean_event_handler_t",
        "html": "See Also\nHandling Path Updates\nfunc nw_connection_copy_current_path(nw_connection_t) -> nw_path_t?\nAccesses the network path the connection is using.\nfunc nw_connection_set_path_changed_handler(nw_connection_t, nw_connection_path_event_handler_t?)\nSets a handler that receives network path updates.\ntypealias nw_connection_path_event_handler_t\nA handler that delivers network path updates.\nfunc nw_connection_set_viability_changed_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when data can be sent and received.\nfunc nw_connection_set_better_path_available_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when an alternative network path is preferred over the current path."
    },
    {
        "title": "nw_connection_group_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_t",
        "html": "Topics\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages.\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent.\nManaging Groups\nfunc nw_connection_group_set_state_changed_handler(nw_connection_group_t, nw_connection_group_state_changed_handler_t?)\nSets a handler that receives connection group state updates.\ntypealias nw_connection_group_state_changed_handler_t\nA handler that receives connection group state updates.\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nfunc nw_connection_group_cancel(nw_connection_group_t)\nCancels the connection group object and leaves the network group.\nInspecting Groups\nfunc nw_connection_group_copy_descriptor(nw_connection_group_t) -> nw_group_descriptor_t\nAccesses the descriptor of the group you use to initialize the connection group.\nfunc nw_connection_group_copy_parameters(nw_connection_group_t) -> nw_parameters_t\nAccesses the parameters with which you initialize the connection group."
    },
    {
        "title": "nw_browse_result_change_t",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_change_t",
        "html": "Topics\nBrowse Result Change Flags\nvar nw_browse_result_change_invalid: Int\nThe comparison was invallid.\nvar nw_browse_result_change_identical: Int\nThe compared services are identical.\nvar nw_browse_result_change_result_added: Int\nA new service was discovered.\nvar nw_browse_result_change_result_removed: Int\nA previously discovered service was removed.\nvar nw_browse_result_change_txt_record_changed: Int\nThe service's associated TXT record changed.\nvar nw_browse_result_change_interface_added: Int\nThe service was discovered over a new interface.\nvar nw_browse_result_change_interface_removed: Int\nThe service was no longer discovered over a certain interface.\nSee Also\nTracking Result Changes\nfunc nw_browse_result_get_changes(nw_browse_result_t?, nw_browse_result_t?) -> nw_browse_result_change_t\nCompares two discovered services and calculates changes between them."
    },
    {
        "title": "nw_browser_t",
        "url": "https://developer.apple.com/documentation/network/nw_browser_t",
        "html": "Topics\nEssentials\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nBrowsing for Services\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service.\nManaging Browsers\nfunc nw_browser_set_state_changed_handler(nw_browser_t, nw_browser_state_changed_handler_t?)\nSets a handler to receive browser state updates.\ntypealias nw_browser_state_changed_handler_t\nA handler that delivers browser state updates with associated errors.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nfunc nw_browser_cancel(nw_browser_t)\nStops browsing for services.\nInspecting Browsers\nfunc nw_browser_copy_browse_descriptor(nw_browser_t) -> nw_browse_descriptor_t\nAccesses the service descriptor with which the browser was created.\nfunc nw_browser_copy_parameters(nw_browser_t) -> nw_parameters_t\nAccesses the parameters with which the browser was created."
    },
    {
        "title": "nw_connection_group_receive_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_receive_handler_t",
        "html": "See Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_connection_path_event_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_path_event_handler_t",
        "html": "See Also\nHandling Path Updates\nfunc nw_connection_copy_current_path(nw_connection_t) -> nw_path_t?\nAccesses the network path the connection is using.\nfunc nw_connection_set_path_changed_handler(nw_connection_t, nw_connection_path_event_handler_t?)\nSets a handler that receives network path updates.\nfunc nw_connection_set_viability_changed_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when data can be sent and received.\nfunc nw_connection_set_better_path_available_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when an alternative network path is preferred over the current path.\ntypealias nw_connection_boolean_event_handler_t\nA handler that receives Boolean state updates from a connection, such as viability and better path state."
    },
    {
        "title": "nw_connection_receive_completion_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_receive_completion_t",
        "html": "Parameters\ncontent\n\nThe received content, as constrained by the minimum and maximum length. This may be nil if the message or stream is complete (without any more data to deliver), or if an error was encountered.\n\ncontext\n\nContent context describing the received content. This includes protocol metadata that lets the caller introspect information about the received content (such as flags on a packet).\n\nis_complete\n\nAn indication that this context (a message or stream, for example) is now complete. For protocols such as TCP, this will be marked when the entire stream has be closed in the reading direction. For protocols such as UDP, this will be marked when the end of a datagram has been reached.\n\nerror\n\nAn error will be sent if the receive was terminated before completing. There may still be content delivered along with the error, but this content may be shorter than the requested ranges. An error will be sent for any outstanding receives when the connection is cancelled.\n\nSee Also\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "nw_browser_browse_results_changed_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_browser_browse_results_changed_handler_t",
        "html": "Discussion\n\nNew results will be delivered as changes from previous results in batches. Your application should process changes once a batch is complete, and be ready to handle multiple updates.\n\nSee Also\nBrowsing for Services\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service."
    },
    {
        "title": "nw_browse_descriptor_t",
        "url": "https://developer.apple.com/documentation/network/nw_browse_descriptor_t",
        "html": "Topics\nCreating Browse Descriptors\nfunc nw_browse_descriptor_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>?) -> nw_browse_descriptor_t\nInitializes a service descriptor used to discover a Bonjour service.\nfunc nw_browse_descriptor_set_include_txt_record(nw_browse_descriptor_t, Bool)\nRequires including associated TXT records with all results generated for this service descriptor.\nInspecting Browse Descriptors\nfunc nw_browse_descriptor_get_bonjour_service_type(nw_browse_descriptor_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type set on a browse descriptor.\nfunc nw_browse_descriptor_get_bonjour_service_domain(nw_browse_descriptor_t) -> UnsafePointer<CChar>?\nAccesses the Bonjour service domain set on a browse descriptor.\nfunc nw_browse_descriptor_get_include_txt_record(nw_browse_descriptor_t) -> Bool\nChecks if the browse descriptor requires including associated TXT records with all results.\nSee Also\nBrowsing for Services\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service."
    },
    {
        "title": "nw_browser_state_changed_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_browser_state_changed_handler_t",
        "html": "See Also\nManaging Browsers\nfunc nw_browser_set_state_changed_handler(nw_browser_t, nw_browser_state_changed_handler_t?)\nSets a handler to receive browser state updates.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nfunc nw_browser_cancel(nw_browser_t)\nStops browsing for services."
    },
    {
        "title": "nw_connection_group_state_changed_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_state_changed_handler_t",
        "html": "See Also\nManaging Groups\nfunc nw_connection_group_set_state_changed_handler(nw_connection_group_t, nw_connection_group_state_changed_handler_t?)\nSets a handler that receives connection group state updates.\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nfunc nw_connection_group_cancel(nw_connection_group_t)\nCancels the connection group object and leaves the network group."
    },
    {
        "title": "nw_advertise_descriptor_t",
        "url": "https://developer.apple.com/documentation/network/nw_advertise_descriptor_t",
        "html": "Topics\nAdvertising Bonjour Services\nfunc nw_advertise_descriptor_create_bonjour_service(UnsafePointer<CChar>?, UnsafePointer<CChar>, UnsafePointer<CChar>?) -> nw_advertise_descriptor_t?\nInitializes a Bonjour service to advertise.\nfunc nw_advertise_descriptor_set_no_auto_rename(nw_advertise_descriptor_t, Bool)\nSets a Boolean to indicate whether the service prohibits automatic renaming in the event of a name conflict.\nfunc nw_advertise_descriptor_get_no_auto_rename(nw_advertise_descriptor_t) -> Bool\nChecks whether the service prohibits automatic renaming in the event of a name conflict.\nConfiguring TXT Records\nfunc nw_advertise_descriptor_set_txt_record(nw_advertise_descriptor_t, UnsafeRawPointer?, Int)\nSets the TXT record as a raw buffer to advertise with the service.\nfunc nw_advertise_descriptor_set_txt_record_object(nw_advertise_descriptor_t, nw_txt_record_t?)\nSets the TXT record to advertise with the service.\nfunc nw_advertise_descriptor_copy_txt_record_object(nw_advertise_descriptor_t) -> nw_txt_record_t?\nAccesses the TXT record to advertise with the service.\nSee Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nfunc nw_listener_set_advertise_descriptor(nw_listener_t, nw_advertise_descriptor_t?)\nSets a Bonjour service that advertises the listener on the local network.\nfunc nw_listener_set_advertised_endpoint_changed_handler(nw_listener_t, nw_listener_advertised_endpoint_changed_handler_t?)\nSets a handler that receives updates for the service endpoint being advertised.\ntypealias nw_listener_advertised_endpoint_changed_handler_t\nA handler that indicates changes to the service endpoints being advertised as they are added and removed."
    },
    {
        "title": "nw_browse_result_t",
        "url": "https://developer.apple.com/documentation/network/nw_browse_result_t",
        "html": "Topics\nEvaluating Browser Results\nfunc nw_browse_result_copy_endpoint(nw_browse_result_t) -> nw_endpoint_t\nThe discovered service endpoint.\nfunc nw_browse_result_enumerate_interfaces(nw_browse_result_t, (nw_interface_t) -> Bool)\nEnumerates the list of interfaces on which the service was discovered.\ntypealias nw_browse_result_enumerate_interface_t\nA handler that enumerates the interfaces associated with a discovered service.\nfunc nw_browse_result_get_interfaces_count(nw_browse_result_t) -> Int\nAccesses the number of interfaces associated with a discovered service.\nHandling TXT Records\nfunc nw_browse_result_copy_txt_record_object(nw_browse_result_t) -> nw_txt_record_t?\nAccesses the TXT record associated with a discovered service.\ntypealias nw_txt_record_t\nA dictionary representing a TXT record in a DNS packet.\nTracking Result Changes\nfunc nw_browse_result_get_changes(nw_browse_result_t?, nw_browse_result_t?) -> nw_browse_result_change_t\nCompares two discovered services and calculates changes between them.\ntypealias nw_browse_result_change_t\nFlags describing ways in which discovered services can change between specific results.\nSee Also\nBrowsing for Services\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services."
    },
    {
        "title": "nw_ws_response_add_additional_header(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180198-nw_ws_response_add_additional_he",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_ws_request_enumerate_subprotocols(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180196-nw_ws_request_enumerate_subproto",
        "html": "See Also\nHandling Server Handshakes\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response."
    },
    {
        "title": "nw_path_enumerate_gateways(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3175017-nw_path_enumerate_gateways",
        "html": "See Also\nInspecting Interfaces\nfunc nw_path_uses_interface_type(nw_path_t, nw_interface_type_t) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nfunc nw_path_enumerate_interfaces(nw_path_t, (nw_interface_t) -> Bool)\nEnumerates the list of all interfaces available to the path, in order of preference.\ntypealias nw_path_enumerate_interfaces_block_t\nA block that enumerates the interfaces available to a path.\ntypealias nw_path_enumerate_gateways_block_t\nA block that enumerates the gateways configured on the interfaces available to a path."
    },
    {
        "title": "nw_path_copy_effective_local_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/2976882-nw_path_copy_effective_local_end",
        "html": "See Also\nInspecting Connected Paths\nfunc nw_path_copy_effective_remote_endpoint(nw_path_t) -> nw_endpoint_t?\nAccesses the remote endpoint in use by a connection's network path."
    },
    {
        "title": "nw_quic_set_application_error(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801760-nw_quic_set_application_error",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\napplication_error\n\nA QUIC application error code.\n\nreason\n\nAn error reason string.\n\nSee Also\nHandling Errors\nfunc nw_quic_get_application_error(nw_protocol_metadata_t) -> UInt64\nAccesses the QUIC application error code received from the peer.\nfunc nw_quic_get_application_error_reason(nw_protocol_metadata_t) -> UnsafePointer<CChar>?\nAccesses the QUIC application error reason received from the peer.\nfunc nw_quic_set_stream_application_error(nw_protocol_metadata_t, UInt64)\nSets the QUIC application error code to send for the stream."
    },
    {
        "title": "nw_quic_get_max_datagram_frame_size(_:)",
        "url": "https://developer.apple.com/documentation/network/3951295-nw_quic_get_max_datagram_frame_s",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe value of the max_datagram_frame_size transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_get_stream_usable_datagram_frame_size(_:)",
        "url": "https://developer.apple.com/documentation/network/3951298-nw_quic_get_stream_usable_datagr",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe maximum usable size of a datagram frame, in bytes."
    },
    {
        "title": "nw_quic_get_initial_max_streams_unidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801749-nw_quic_get_initial_max_streams_",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe value of the initial_max_streams_uni transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_get_stream_application_error(_:)",
        "url": "https://developer.apple.com/documentation/network/3801757-nw_quic_get_stream_application_e",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nA QUIC application error code."
    },
    {
        "title": "nw_quic_get_local_max_streams_bidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801751-nw_quic_get_local_max_streams_bi",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe maximum number of bidirectional streams that the peer can create.\n\nSee Also\nInspecting Connection State\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "nw_quic_get_stream_type(_:)",
        "url": "https://developer.apple.com/documentation/network/3951297-nw_quic_get_stream_type",
        "html": "Parameters\nstream_metadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nA QUIC stream type.\n\nSee Also\nInspecting Stream State\nfunc nw_quic_get_stream_id(nw_protocol_metadata_t) -> UInt64\nAccesses the QUIC stream identifier."
    },
    {
        "title": "nw_quic_get_remote_max_streams_unidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801756-nw_quic_get_remote_max_streams_u",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\n\nSee Also\nInspecting Connection State\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "nw_quic_get_stream_id(_:)",
        "url": "https://developer.apple.com/documentation/network/3801758-nw_quic_get_stream_id",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe QUIC stream identifier.\n\nSee Also\nInspecting Stream State\nfunc nw_quic_get_stream_type(nw_protocol_metadata_t) -> UInt8\nAccesses the stream type of the QUIC stream."
    },
    {
        "title": "nw_quic_get_keepalive_interval(_:)",
        "url": "https://developer.apple.com/documentation/network/3801750-nw_quic_get_keepalive_interval",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nA keepalive interval, in seconds."
    },
    {
        "title": "nw_resolution_report_get_milliseconds(_:)",
        "url": "https://developer.apple.com/documentation/network/3548029-nw_resolution_report_get_millise",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_tcp_options_set_disable_ecn(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976926-nw_tcp_options_set_disable_ecn",
        "html": "See Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching."
    },
    {
        "title": "nw_resolution_report_get_protocol(_:)",
        "url": "https://developer.apple.com/documentation/network/3548030-nw_resolution_report_get_protoco",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_resolution_report_get_source(_:)",
        "url": "https://developer.apple.com/documentation/network/3548031-nw_resolution_report_get_source",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_quic_set_keepalive_interval(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801768-nw_quic_set_keepalive_interval",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nkeepalive_interval\n\nA keepalive interval, in seconds."
    },
    {
        "title": "nw_quic_set_initial_max_streams_unidirectional(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801767-nw_quic_set_initial_max_streams_",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\ninitial_max_streams_unidirectional\n\nThe value of the initial_max_streams_uni transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_resolution_report_copy_successful_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/3548027-nw_resolution_report_copy_succes",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_resolution_report_copy_preferred_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/3548026-nw_resolution_report_copy_prefer",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_quic_set_initial_max_streams_bidirectional(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801766-nw_quic_set_initial_max_streams_",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\ninitial_max_streams_bidirectional\n\nThe value of the initial_max_streams_bidi transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_set_max_datagram_frame_size(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3951299-nw_quic_set_max_datagram_frame_s",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nmax_datagram_frame_size\n\nThe value of the max_datagram_frame_size transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_set_local_max_streams_bidirectional(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801769-nw_quic_set_local_max_streams_bi",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nmax_streams_bidirectional\n\nThe maximum number of bidirectional streams that the peer can create.\n\nSee Also\nInspecting Connection State\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "nw_ws_metadata_set_pong_handler(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3143623-nw_ws_metadata_set_pong_handler",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake."
    },
    {
        "title": "nw_ws_metadata_set_close_code(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3143622-nw_ws_metadata_set_close_code",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake."
    },
    {
        "title": "nw_ws_options_add_subprotocol(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180193-nw_ws_options_add_subprotocol",
        "html": "See Also\nConfiguring Client Handshakes\nfunc nw_ws_options_add_additional_header(nw_protocol_options_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds additional HTTP header fields to be sent by the client during the WebSocket handshake.\nfunc nw_ws_options_set_skip_handshake(nw_protocol_options_t, Bool)\nSpecifies whether the WebSocket protocol skips its handshake and begins framing data once the underlying connection is established."
    },
    {
        "title": "nw_ws_options_add_additional_header(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3180192-nw_ws_options_add_additional_hea",
        "html": "See Also\nConfiguring Client Handshakes\nfunc nw_ws_options_add_subprotocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds to the list of supported application protocols that will be presented to a WebSocket server during connection establishment.\nfunc nw_ws_options_set_skip_handshake(nw_protocol_options_t, Bool)\nSpecifies whether the WebSocket protocol skips its handshake and begins framing data once the underlying connection is established."
    },
    {
        "title": "nw_txt_record_copy(_:)",
        "url": "https://developer.apple.com/documentation/network/3114135-nw_txt_record_copy",
        "html": "See Also\nCreating TXT Records\nfunc nw_txt_record_create_dictionary() -> nw_txt_record_t\nInitializes a TXT record as a dictionary of strings.\nfunc nw_txt_record_create_with_bytes(UnsafePointer<UInt8>, Int) -> nw_txt_record_t\nInitializes a TXT record with raw bytes.\nfunc nw_txt_record_set_key(nw_txt_record_t, UnsafePointer<CChar>, UnsafePointer<UInt8>?, Int) -> Bool\nSets a data value in a TXT record dictionary.\nfunc nw_txt_record_remove_key(nw_txt_record_t, UnsafePointer<CChar>) -> Bool\nRemoves a data value in a TXT record dictionary."
    },
    {
        "title": "nw_txt_record_find_key(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114138-nw_txt_record_find_key",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_txt_record_create_with_bytes(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114137-nw_txt_record_create_with_bytes",
        "html": "See Also\nCreating TXT Records\nfunc nw_txt_record_create_dictionary() -> nw_txt_record_t\nInitializes a TXT record as a dictionary of strings.\nfunc nw_txt_record_copy(nw_txt_record_t?) -> nw_txt_record_t?\nPerforms a deep copy of a TXT record.\nfunc nw_txt_record_set_key(nw_txt_record_t, UnsafePointer<CChar>, UnsafePointer<UInt8>?, Int) -> Bool\nSets a data value in a TXT record dictionary.\nfunc nw_txt_record_remove_key(nw_txt_record_t, UnsafePointer<CChar>) -> Bool\nRemoves a data value in a TXT record dictionary."
    },
    {
        "title": "nw_txt_record_is_equal(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114147-nw_txt_record_is_equal",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_txt_record_remove_key(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114148-nw_txt_record_remove_key",
        "html": "See Also\nCreating TXT Records\nfunc nw_txt_record_create_dictionary() -> nw_txt_record_t\nInitializes a TXT record as a dictionary of strings.\nfunc nw_txt_record_create_with_bytes(UnsafePointer<UInt8>, Int) -> nw_txt_record_t\nInitializes a TXT record with raw bytes.\nfunc nw_txt_record_copy(nw_txt_record_t?) -> nw_txt_record_t?\nPerforms a deep copy of a TXT record.\nfunc nw_txt_record_set_key(nw_txt_record_t, UnsafePointer<CChar>, UnsafePointer<UInt8>?, Int) -> Bool\nSets a data value in a TXT record dictionary."
    },
    {
        "title": "nw_ws_create_metadata(_:)",
        "url": "https://developer.apple.com/documentation/network/3143618-nw_ws_create_metadata",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake."
    },
    {
        "title": "nw_txt_record_create_dictionary()",
        "url": "https://developer.apple.com/documentation/network/3114136-nw_txt_record_create_dictionary",
        "html": "See Also\nCreating TXT Records\nfunc nw_txt_record_create_with_bytes(UnsafePointer<UInt8>, Int) -> nw_txt_record_t\nInitializes a TXT record with raw bytes.\nfunc nw_txt_record_copy(nw_txt_record_t?) -> nw_txt_record_t?\nPerforms a deep copy of a TXT record.\nfunc nw_txt_record_set_key(nw_txt_record_t, UnsafePointer<CChar>, UnsafePointer<UInt8>?, Int) -> Bool\nSets a data value in a TXT record dictionary.\nfunc nw_txt_record_remove_key(nw_txt_record_t, UnsafePointer<CChar>) -> Bool\nRemoves a data value in a TXT record dictionary."
    },
    {
        "title": "nw_txt_record_is_dictionary(_:)",
        "url": "https://developer.apple.com/documentation/network/3114146-nw_txt_record_is_dictionary",
        "html": "See Also\nExamining TXT Records\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record."
    },
    {
        "title": "nw_udp_create_metadata()",
        "url": "https://developer.apple.com/documentation/network/2976946-nw_udp_create_metadata",
        "html": "See Also\nSending UDP Messages\nfunc nw_protocol_metadata_is_udp(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a UDP datagram."
    },
    {
        "title": "nw_udp_options_set_prefer_no_checksum(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976948-nw_udp_options_set_prefer_no_che",
        "html": "Discussion\n\nUDP checksums are optional when the datagrams are sent over IPv4. This option configures UDP to not set checksums on these datagrams, but has no effect on IPv6."
    },
    {
        "title": "nw_udp_create_options()",
        "url": "https://developer.apple.com/documentation/network/2976947-nw_udp_create_options",
        "html": "See Also\nCreating UDP Connections\nfunc nw_protocol_copy_udp_definition() -> nw_protocol_definition_t\nAccesses the system definition of the User Datagram Protocol."
    },
    {
        "title": "nw_tcp_options_set_retransmit_fin_drop(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976938-nw_tcp_options_set_retransmit_fi",
        "html": "See Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "nw_tcp_options_set_retransmit_connection_drop_time(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976937-nw_tcp_options_set_retransmit_co",
        "html": "See Also\nSetting Timeouts\nfunc nw_tcp_options_set_connection_timeout(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits before timing out its handshake.\nfunc nw_tcp_options_set_persist_timeout(nw_protocol_options_t, UInt32)\nSets the TCP persist timeout in seconds, as defined by RFC 6429."
    },
    {
        "title": "nw_tcp_options_set_persist_timeout(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976936-nw_tcp_options_set_persist_timeo",
        "html": "See Also\nSetting Timeouts\nfunc nw_tcp_options_set_connection_timeout(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits before timing out its handshake.\nfunc nw_tcp_options_set_retransmit_connection_drop_time(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits between retransmission attempts."
    },
    {
        "title": "nw_framer_parse_input(_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114497-nw_framer_parse_input",
        "html": "Parameters\nminimum_incomplete_length\n\nThe minimum number of bytes that should be delivered to the parse completion.\n\nmaximum_length\n\nThe maximum number of bytes that should be delivered to the parse completion.\n\ntemp_buffer\n\nAn optional buffer into which the parser will copy bytes. Use this if you need to make guarantees about byte alignment.\n\nparse\n\nA completion handler that will be called inline to examine a region of bytes.\n\nReturn Value\n\nReturns true if the requested length was available to parse, or false if the conditions could not be met.\n\nSee Also\nHandling Input Data\nfunc nw_framer_set_input_handler(nw_framer_t, nw_framer_input_handler_t)\nSets a block to handle new inbound data.\ntypealias nw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_deliver_input(nw_framer_t, UnsafePointer<UInt8>, Int, nw_framer_message_t, Bool)\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nfunc nw_framer_deliver_input_no_copy(nw_framer_t, Int, nw_framer_message_t, Bool) -> Bool\nDelivers an inbound message containing a specific number of next received bytes.\nfunc nw_framer_pass_through_input(nw_framer_t)\nIndicates that your protocol no longer needs to handle input data."
    },
    {
        "title": "nw_tcp_options_set_enable_fast_open(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976927-nw_tcp_options_set_enable_fast_o",
        "html": "Discussion\n\nIf TCP Fast Open is enabled and TLS is running on top of TCP, the TLS handshake will automatically be used as the TCP early data. If there is no protocol running on top of TCP, you should also enable fast open on the connection parameters and send idempotent data.\n\nSee Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings.\nRelated Documentation\nfunc nw_parameters_set_fast_open_enabled(nw_parameters_t, Bool)\nEnables sending application data with protocol handshakes."
    },
    {
        "title": "nw_tcp_options_set_no_delay(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976933-nw_tcp_options_set_no_delay",
        "html": "See Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "nw_tcp_options_set_keepalive_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976929-nw_tcp_options_set_keepalive_cou",
        "html": "See Also\nConfiguring Keepalives\nfunc nw_tcp_options_set_enable_keepalive(nw_protocol_options_t, Bool)\nEnables TCP keepalives.\nfunc nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t, UInt32)\nSets the number of seconds of idleness that TCP waits before sending keepalive probes.\nfunc nw_tcp_options_set_keepalive_interval(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits between sending keepalive probes."
    },
    {
        "title": "nw_tcp_options_set_keepalive_interval(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976931-nw_tcp_options_set_keepalive_int",
        "html": "See Also\nConfiguring Keepalives\nfunc nw_tcp_options_set_enable_keepalive(nw_protocol_options_t, Bool)\nEnables TCP keepalives.\nfunc nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t, UInt32)\nSets the number of seconds of idleness that TCP waits before sending keepalive probes.\nfunc nw_tcp_options_set_keepalive_count(nw_protocol_options_t, UInt32)\nSets the number of keepalive probes that TCP sends before terminating the connection."
    },
    {
        "title": "nw_tcp_options_set_keepalive_idle_time(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976930-nw_tcp_options_set_keepalive_idl",
        "html": "See Also\nConfiguring Keepalives\nfunc nw_tcp_options_set_enable_keepalive(nw_protocol_options_t, Bool)\nEnables TCP keepalives.\nfunc nw_tcp_options_set_keepalive_count(nw_protocol_options_t, UInt32)\nSets the number of keepalive probes that TCP sends before terminating the connection.\nfunc nw_tcp_options_set_keepalive_interval(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits between sending keepalive probes."
    },
    {
        "title": "nw_tcp_options_set_enable_keepalive(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976928-nw_tcp_options_set_enable_keepal",
        "html": "See Also\nConfiguring Keepalives\nfunc nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t, UInt32)\nSets the number of seconds of idleness that TCP waits before sending keepalive probes.\nfunc nw_tcp_options_set_keepalive_count(nw_protocol_options_t, UInt32)\nSets the number of keepalive probes that TCP sends before terminating the connection.\nfunc nw_tcp_options_set_keepalive_interval(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits between sending keepalive probes."
    },
    {
        "title": "nw_listener_set_new_connection_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976788-nw_listener_set_new_connection_h",
        "html": "Discussion\n\nUpon receiving a new connection, you should set update handlers on the connection and start it in order to accept it. If you want to reject the connection, cancel the connection.\n\nSee Also\nReceiving Connections\ntypealias nw_listener_new_connection_handler_t\nA handler that delivers inbound connections.\nfunc nw_listener_set_new_connection_limit(nw_listener_t, UInt32)\nResets the number of inbound connections to deliver before rejecting connections.\nfunc nw_listener_get_new_connection_limit(nw_listener_t) -> UInt32\nChecks the remaining number of inbound connections to deliver before rejecting connections.\nvar NW_LISTENER_INFINITE_CONNECTION_LIMIT: UInt32\nA static value that indicates that inbound connections should not be limited."
    },
    {
        "title": "nw_path_copy_effective_remote_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/2976883-nw_path_copy_effective_remote_en",
        "html": "See Also\nInspecting Connected Paths\nfunc nw_path_copy_effective_local_endpoint(nw_path_t) -> nw_endpoint_t?\nAccesses the local endpoint in use by a connection's network path."
    },
    {
        "title": "nw_quic_get_initial_max_stream_data_bidirectional_local(_:)",
        "url": "https://developer.apple.com/documentation/network/3801745-nw_quic_get_initial_max_stream_d",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe value of the initial_max_stream_data_bidi_local transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_protocol_copy_quic_definition()",
        "url": "https://developer.apple.com/documentation/network/3801735-nw_protocol_copy_quic_definition",
        "html": "Return Value\n\nThe system definition of the QUIC transport protocol.\n\nSee Also\nCreating QUIC Connections\nfunc nw_quic_create_options() -> nw_protocol_options_t\nInitializes a default set of QUIC connection options."
    },
    {
        "title": "nw_protocol_copy_udp_definition()",
        "url": "https://developer.apple.com/documentation/network/2976944-nw_protocol_copy_udp_definition",
        "html": "See Also\nCreating UDP Connections\nfunc nw_udp_create_options() -> nw_protocol_options_t\nInitializes a default set of UDP connection options."
    },
    {
        "title": "nw_protocol_metadata_is_tcp(_:)",
        "url": "https://developer.apple.com/documentation/network/2976920-nw_protocol_metadata_is_tcp",
        "html": "See Also\nInspecting TCP State\nfunc nw_tcp_get_available_send_buffer(nw_protocol_metadata_t) -> UInt32\nAccesses the number of available bytes in the TCP send buffer.\nfunc nw_tcp_get_available_receive_buffer(nw_protocol_metadata_t) -> UInt32\nAccesses the number of available bytes in the TCP receive buffer."
    },
    {
        "title": "nw_protocol_copy_tls_definition()",
        "url": "https://developer.apple.com/documentation/network/2976939-nw_protocol_copy_tls_definition",
        "html": "See Also\nCreating TLS Connections\nfunc nw_tls_create_options() -> nw_protocol_options_t\nInitializes a default set of TLS connection options.\nfunc nw_tls_copy_sec_protocol_options(nw_protocol_options_t) -> sec_protocol_options_t\nAccesses the handshake security options TLS will use."
    },
    {
        "title": "nw_protocol_metadata_is_quic(_:)",
        "url": "https://developer.apple.com/documentation/network/3801736-nw_protocol_metadata_is_quic",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nA Boolean value that indicates whether the metadata object contains QUIC connection state.\n\nSee Also\nInspecting Connection State\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "nw_protocol_metadata_is_framer_message(_:)",
        "url": "https://developer.apple.com/documentation/network/3114518-nw_protocol_metadata_is_framer_m",
        "html": "See Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_path_monitor_start(_:)",
        "url": "https://developer.apple.com/documentation/network/2976907-nw_path_monitor_start",
        "html": "See Also\nCreating Path Monitors\nfunc nw_path_monitor_create() -> nw_path_monitor_t\nInitializes a path monitor to observe all available interface types.\nfunc nw_path_monitor_create_with_type(nw_interface_type_t) -> nw_path_monitor_t\nInitializes a path monitor to observe a specific interface type.\nfunc nw_path_monitor_prohibit_interface_type(nw_path_monitor_t, nw_interface_type_t)\nProhibit a path monitor from using a specific interface type.\nfunc nw_path_monitor_set_queue(nw_path_monitor_t, dispatch_queue_t)\nSets a queue on which to deliver path events."
    },
    {
        "title": "nw_protocol_copy_tcp_definition()",
        "url": "https://developer.apple.com/documentation/network/2976919-nw_protocol_copy_tcp_definition",
        "html": "See Also\nCreating TCP Connections\nfunc nw_tcp_create_options() -> nw_protocol_options_t\nInitializes a default set of TCP connection options."
    },
    {
        "title": "nw_protocol_metadata_is_udp(_:)",
        "url": "https://developer.apple.com/documentation/network/2976945-nw_protocol_metadata_is_udp",
        "html": "See Also\nSending UDP Messages\nfunc nw_udp_create_metadata() -> nw_protocol_metadata_t\nInitializes a default UDP message."
    },
    {
        "title": "nw_protocol_metadata_is_tls(_:)",
        "url": "https://developer.apple.com/documentation/network/2976940-nw_protocol_metadata_is_tls",
        "html": "See Also\nInspecting TLS State\nfunc nw_tls_copy_sec_protocol_metadata(nw_protocol_metadata_t) -> sec_protocol_metadata_t\nAccesses the result of the TLS handshake."
    },
    {
        "title": "nw_protocol_copy_ip_definition()",
        "url": "https://developer.apple.com/documentation/network/2976776-nw_protocol_copy_ip_definition",
        "html": "See Also\nConfiguring IP Connections\nfunc nw_ip_options_set_version(nw_protocol_options_t, nw_ip_version_t)\nSets a required IP version to disable all other versions for a connection.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets.\nfunc nw_ip_options_set_hop_limit(nw_protocol_options_t, UInt8)\nConfigures the default hop limit for packets generated by a connection.\nfunc nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t, Bool)\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nfunc nw_ip_options_set_disable_fragmentation(nw_protocol_options_t, Bool)\nConfigures a connection to disable fragmentation on outbound packets.\nfunc nw_ip_options_set_local_address_preference(nw_protocol_options_t, nw_ip_local_address_preference_t)\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable."
    },
    {
        "title": "nw_path_uses_interface_type(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976898-nw_path_uses_interface_type",
        "html": "Discussion\n\nPaths can use interface types by directly routing over an interface, routing through a tunnel that goes over a physical interface, or being eligble to use multiple interfaces directly.\n\nSee Also\nInspecting Interfaces\nfunc nw_path_enumerate_interfaces(nw_path_t, (nw_interface_t) -> Bool)\nEnumerates the list of all interfaces available to the path, in order of preference.\ntypealias nw_path_enumerate_interfaces_block_t\nA block that enumerates the interfaces available to a path.\nfunc nw_path_enumerate_gateways(nw_path_t, (nw_endpoint_t) -> Bool)\nEnumerates the list of gateways configured on the interfaces available to a path.\ntypealias nw_path_enumerate_gateways_block_t\nA block that enumerates the gateways configured on the interfaces available to a path."
    },
    {
        "title": "nw_protocol_metadata_is_ws(_:)",
        "url": "https://developer.apple.com/documentation/network/3143603-nw_protocol_metadata_is_ws",
        "html": "See Also\nHandling WebSocket Messages\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake."
    },
    {
        "title": "nw_protocol_copy_ws_definition()",
        "url": "https://developer.apple.com/documentation/network/3143602-nw_protocol_copy_ws_definition",
        "html": "See Also\nCreating WebSocket Connections\nfunc nw_ws_create_options(nw_ws_version_t) -> nw_protocol_options_t\nInitializes a default set of WebSocket connection options.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol.\nfunc nw_ws_options_set_auto_reply_ping(nw_protocol_options_t, Bool)\nConfigures the connection to automatically reply to Ping messages instead of delivering them to you.\nfunc nw_ws_options_set_maximum_message_size(nw_protocol_options_t, Int)\nSets the maximum allowed message size, in bytes, to be received by the WebSocket connection."
    },
    {
        "title": "nw_tcp_options_set_disable_ack_stretching(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976925-nw_tcp_options_set_disable_ack_s",
        "html": "See Also\nCustomizing TCP Options\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings."
    },
    {
        "title": "nw_tcp_get_available_receive_buffer(_:)",
        "url": "https://developer.apple.com/documentation/network/2976922-nw_tcp_get_available_receive_buf",
        "html": "See Also\nInspecting TCP State\nfunc nw_protocol_metadata_is_tcp(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains TCP connection state.\nfunc nw_tcp_get_available_send_buffer(nw_protocol_metadata_t) -> UInt32\nAccesses the number of available bytes in the TCP send buffer."
    },
    {
        "title": "nw_quic_set_stream_application_error(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801772-nw_quic_set_stream_application_e",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\napplication_error\n\nA QUIC application error code.\n\nSee Also\nHandling Errors\nfunc nw_quic_set_application_error(nw_protocol_metadata_t, UInt64, UnsafePointer<CChar>?)\nSets the QUIC application error code to send for the connection.\nfunc nw_quic_get_application_error(nw_protocol_metadata_t) -> UInt64\nAccesses the QUIC application error code received from the peer.\nfunc nw_quic_get_application_error_reason(nw_protocol_metadata_t) -> UnsafePointer<CChar>?\nAccesses the QUIC application error reason received from the peer."
    },
    {
        "title": "nw_quic_set_initial_max_stream_data_bidirectional_remote(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801764-nw_quic_set_initial_max_stream_d",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\ninitial_max_stream_data_bidirectional_remote\n\nThe value of the initial_max_stream_data_bidi_remote transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_set_initial_max_stream_data_bidirectional_local(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801763-nw_quic_set_initial_max_stream_d",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\ninitial_max_stream_data_bidirectional_local\n\nThe value of the initial_max_stream_data_bidi_local transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_ip_options_set_use_minimum_mtu(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976770-nw_ip_options_set_use_minimum_mt",
        "html": "See Also\nConfiguring IP Connections\nfunc nw_protocol_copy_ip_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Internet Protocol.\nfunc nw_ip_options_set_version(nw_protocol_options_t, nw_ip_version_t)\nSets a required IP version to disable all other versions for a connection.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets.\nfunc nw_ip_options_set_hop_limit(nw_protocol_options_t, UInt8)\nConfigures the default hop limit for packets generated by a connection.\nfunc nw_ip_options_set_disable_fragmentation(nw_protocol_options_t, Bool)\nConfigures a connection to disable fragmentation on outbound packets.\nfunc nw_ip_options_set_local_address_preference(nw_protocol_options_t, nw_ip_local_address_preference_t)\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable."
    },
    {
        "title": "nw_ip_options_set_version(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976771-nw_ip_options_set_version",
        "html": "See Also\nConfiguring IP Connections\nfunc nw_protocol_copy_ip_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Internet Protocol.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets.\nfunc nw_ip_options_set_hop_limit(nw_protocol_options_t, UInt8)\nConfigures the default hop limit for packets generated by a connection.\nfunc nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t, Bool)\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nfunc nw_ip_options_set_disable_fragmentation(nw_protocol_options_t, Bool)\nConfigures a connection to disable fragmentation on outbound packets.\nfunc nw_ip_options_set_local_address_preference(nw_protocol_options_t, nw_ip_local_address_preference_t)\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable."
    },
    {
        "title": "nw_ip_options_set_hop_limit(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976769-nw_ip_options_set_hop_limit",
        "html": "See Also\nConfiguring IP Connections\nfunc nw_protocol_copy_ip_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Internet Protocol.\nfunc nw_ip_options_set_version(nw_protocol_options_t, nw_ip_version_t)\nSets a required IP version to disable all other versions for a connection.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets.\nfunc nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t, Bool)\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nfunc nw_ip_options_set_disable_fragmentation(nw_protocol_options_t, Bool)\nConfigures a connection to disable fragmentation on outbound packets.\nfunc nw_ip_options_set_local_address_preference(nw_protocol_options_t, nw_ip_local_address_preference_t)\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable."
    },
    {
        "title": "nw_ip_options_set_local_address_preference(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3194212-nw_ip_options_set_local_address_",
        "html": "See Also\nConfiguring IP Connections\nfunc nw_protocol_copy_ip_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Internet Protocol.\nfunc nw_ip_options_set_version(nw_protocol_options_t, nw_ip_version_t)\nSets a required IP version to disable all other versions for a connection.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets.\nfunc nw_ip_options_set_hop_limit(nw_protocol_options_t, UInt8)\nConfigures the default hop limit for packets generated by a connection.\nfunc nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t, Bool)\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nfunc nw_ip_options_set_disable_fragmentation(nw_protocol_options_t, Bool)\nConfigures a connection to disable fragmentation on outbound packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable."
    },
    {
        "title": "nw_listener_create_with_port(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976783-nw_listener_create_with_port",
        "html": "See Also\nCreating Listeners\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections."
    },
    {
        "title": "nw_listener_set_advertised_endpoint_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976787-nw_listener_set_advertised_endpo",
        "html": "See Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nfunc nw_listener_set_advertise_descriptor(nw_listener_t, nw_advertise_descriptor_t?)\nSets a Bonjour service that advertises the listener on the local network.\ntypealias nw_advertise_descriptor_t\nA description used to advertise the Bonjour service that a listener provides.\ntypealias nw_listener_advertised_endpoint_changed_handler_t\nA handler that indicates changes to the service endpoints being advertised as they are added and removed."
    },
    {
        "title": "nw_listener_set_state_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976790-nw_listener_set_state_changed_ha",
        "html": "See Also\nHandling State Updates\ntypealias nw_listener_state_changed_handler_t\nA handler that delivers listener state updates with associated errors.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections."
    },
    {
        "title": "nw_endpoint_get_port(_:)",
        "url": "https://developer.apple.com/documentation/network/2976726-nw_endpoint_get_port",
        "html": "See Also\nHost Endpoints\nfunc nw_endpoint_create_host(UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a hostname and port, where the hostname may be interpreted as an IP address.\nfunc nw_endpoint_get_hostname(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the hostname stored in an endpoint.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string."
    },
    {
        "title": "nw_listener_start(_:)",
        "url": "https://developer.apple.com/documentation/network/2976791-nw_listener_start",
        "html": "See Also\nCreating Listeners\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections."
    },
    {
        "title": "nw_framer_protocol_create_message(_:)",
        "url": "https://developer.apple.com/documentation/network/3114501-nw_framer_protocol_create_messag",
        "html": "See Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_framer_set_input_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114504-nw_framer_set_input_handler",
        "html": "See Also\nHandling Input Data\ntypealias nw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\nfunc nw_framer_parse_input(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of input data while inside your input handler block.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_deliver_input(nw_framer_t, UnsafePointer<UInt8>, Int, nw_framer_message_t, Bool)\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nfunc nw_framer_deliver_input_no_copy(nw_framer_t, Int, nw_framer_message_t, Bool) -> Bool\nDelivers an inbound message containing a specific number of next received bytes.\nfunc nw_framer_pass_through_input(nw_framer_t)\nIndicates that your protocol no longer needs to handle input data."
    },
    {
        "title": "nw_framer_prepend_application_protocol(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3141918-nw_framer_prepend_application_pr",
        "html": "See Also\nManaging Instance Lifetime\nfunc nw_framer_mark_ready(nw_framer_t)\nIndicates to a connection that your protocol's handshake is complete.\nfunc nw_framer_mark_failed_with_error(nw_framer_t, Int32)\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nfunc nw_framer_set_stop_handler(nw_framer_t, nw_framer_stop_handler_t)\nSets a block to handle when the connection is being closed.\ntypealias nw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\nfunc nw_framer_set_cleanup_handler(nw_framer_t, nw_framer_cleanup_handler_t)\nSets a block to handle the final cleanup of allocations made by your protocol instance.\ntypealias nw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated."
    },
    {
        "title": "nw_framer_wakeup_handler_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_wakeup_handler_t",
        "html": "See Also\nHandling Asynchronous Events\nfunc nw_framer_schedule_wakeup(nw_framer_t, UInt64)\nRequests that the nw_framer_wakeup_handler_t be called on your protocol at a specific time in the future.\nvar NW_FRAMER_WAKEUP_TIME_FOREVER: UInt64\nA sentinel value that indicates that no wakeup should be delivered.\nfunc nw_framer_set_wakeup_handler(nw_framer_t, nw_framer_wakeup_handler_t)\nSets a handler to receive scheduled wakeup events.\nfunc nw_framer_async(nw_framer_t, nw_framer_block_t)\nRequests that a block be executed on the connection's internal scheduling context.\ntypealias nw_framer_block_t\nA block to be invoked asynchronously on your framer protocol's scheduling context."
    },
    {
        "title": "nw_framer_pass_through_input(_:)",
        "url": "https://developer.apple.com/documentation/network/3114499-nw_framer_pass_through_input",
        "html": "See Also\nHandling Input Data\nfunc nw_framer_set_input_handler(nw_framer_t, nw_framer_input_handler_t)\nSets a block to handle new inbound data.\ntypealias nw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\nfunc nw_framer_parse_input(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of input data while inside your input handler block.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_deliver_input(nw_framer_t, UnsafePointer<UInt8>, Int, nw_framer_message_t, Bool)\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nfunc nw_framer_deliver_input_no_copy(nw_framer_t, Int, nw_framer_message_t, Bool) -> Bool\nDelivers an inbound message containing a specific number of next received bytes."
    },
    {
        "title": "nw_framer_message_set_object_value(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114492-nw_framer_message_set_object_val",
        "html": "See Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_framer_deliver_input(_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114481-nw_framer_deliver_input",
        "html": "See Also\nHandling Input Data\nfunc nw_framer_set_input_handler(nw_framer_t, nw_framer_input_handler_t)\nSets a block to handle new inbound data.\ntypealias nw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\nfunc nw_framer_parse_input(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of input data while inside your input handler block.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_deliver_input_no_copy(nw_framer_t, Int, nw_framer_message_t, Bool) -> Bool\nDelivers an inbound message containing a specific number of next received bytes.\nfunc nw_framer_pass_through_input(nw_framer_t)\nIndicates that your protocol no longer needs to handle input data."
    },
    {
        "title": "nw_framer_deliver_input_no_copy(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114482-nw_framer_deliver_input_no_copy",
        "html": "See Also\nHandling Input Data\nfunc nw_framer_set_input_handler(nw_framer_t, nw_framer_input_handler_t)\nSets a block to handle new inbound data.\ntypealias nw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\nfunc nw_framer_parse_input(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of input data while inside your input handler block.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_deliver_input(nw_framer_t, UnsafePointer<UInt8>, Int, nw_framer_message_t, Bool)\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nfunc nw_framer_pass_through_input(nw_framer_t)\nIndicates that your protocol no longer needs to handle input data."
    },
    {
        "title": "nw_path_monitor_prohibit_interface_type(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3548035-nw_path_monitor_prohibit_interfa",
        "html": "See Also\nCreating Path Monitors\nfunc nw_path_monitor_create() -> nw_path_monitor_t\nInitializes a path monitor to observe all available interface types.\nfunc nw_path_monitor_create_with_type(nw_interface_type_t) -> nw_path_monitor_t\nInitializes a path monitor to observe a specific interface type.\nfunc nw_path_monitor_set_queue(nw_path_monitor_t, dispatch_queue_t)\nSets a queue on which to deliver path events.\nfunc nw_path_monitor_start(nw_path_monitor_t)\nStarts monitoring path changes."
    },
    {
        "title": "nw_framer_mark_failed_with_error(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114484-nw_framer_mark_failed_with_error",
        "html": "See Also\nManaging Instance Lifetime\nfunc nw_framer_mark_ready(nw_framer_t)\nIndicates to a connection that your protocol's handshake is complete.\nfunc nw_framer_prepend_application_protocol(nw_framer_t, nw_protocol_options_t) -> Bool\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready(_:).\nfunc nw_framer_set_stop_handler(nw_framer_t, nw_framer_stop_handler_t)\nSets a block to handle when the connection is being closed.\ntypealias nw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\nfunc nw_framer_set_cleanup_handler(nw_framer_t, nw_framer_cleanup_handler_t)\nSets a block to handle the final cleanup of allocations made by your protocol instance.\ntypealias nw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated."
    },
    {
        "title": "nw_path_monitor_set_queue(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976905-nw_path_monitor_set_queue",
        "html": "See Also\nCreating Path Monitors\nfunc nw_path_monitor_create() -> nw_path_monitor_t\nInitializes a path monitor to observe all available interface types.\nfunc nw_path_monitor_create_with_type(nw_interface_type_t) -> nw_path_monitor_t\nInitializes a path monitor to observe a specific interface type.\nfunc nw_path_monitor_prohibit_interface_type(nw_path_monitor_t, nw_interface_type_t)\nProhibit a path monitor from using a specific interface type.\nfunc nw_path_monitor_start(nw_path_monitor_t)\nStarts monitoring path changes."
    },
    {
        "title": "nw_path_monitor_create_with_type(_:)",
        "url": "https://developer.apple.com/documentation/network/2976903-nw_path_monitor_create_with_type",
        "html": "See Also\nCreating Path Monitors\nfunc nw_path_monitor_create() -> nw_path_monitor_t\nInitializes a path monitor to observe all available interface types.\nfunc nw_path_monitor_prohibit_interface_type(nw_path_monitor_t, nw_interface_type_t)\nProhibit a path monitor from using a specific interface type.\nfunc nw_path_monitor_set_queue(nw_path_monitor_t, dispatch_queue_t)\nSets a queue on which to deliver path events.\nfunc nw_path_monitor_start(nw_path_monitor_t)\nStarts monitoring path changes."
    },
    {
        "title": "nw_path_monitor_set_cancel_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976904-nw_path_monitor_set_cancel_handl",
        "html": "See Also\nCanceling Path Monitors\nfunc nw_path_monitor_cancel(nw_path_monitor_t)\nStops receiving network path updates.\ntypealias nw_path_monitor_cancel_handler_t\nA handler that indicates when a monitor has been cancelled."
    },
    {
        "title": "nw_framer_message_create(_:)",
        "url": "https://developer.apple.com/documentation/network/3114489-nw_framer_message_create",
        "html": "See Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_path_monitor_create()",
        "url": "https://developer.apple.com/documentation/network/2976902-nw_path_monitor_create",
        "html": "See Also\nCreating Path Monitors\nfunc nw_path_monitor_create_with_type(nw_interface_type_t) -> nw_path_monitor_t\nInitializes a path monitor to observe a specific interface type.\nfunc nw_path_monitor_prohibit_interface_type(nw_path_monitor_t, nw_interface_type_t)\nProhibit a path monitor from using a specific interface type.\nfunc nw_path_monitor_set_queue(nw_path_monitor_t, dispatch_queue_t)\nSets a queue on which to deliver path events.\nfunc nw_path_monitor_start(nw_path_monitor_t)\nStarts monitoring path changes."
    },
    {
        "title": "nw_framer_mark_ready(_:)",
        "url": "https://developer.apple.com/documentation/network/3114485-nw_framer_mark_ready",
        "html": "See Also\nManaging Instance Lifetime\nfunc nw_framer_mark_failed_with_error(nw_framer_t, Int32)\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nfunc nw_framer_prepend_application_protocol(nw_framer_t, nw_protocol_options_t) -> Bool\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready(_:).\nfunc nw_framer_set_stop_handler(nw_framer_t, nw_framer_stop_handler_t)\nSets a block to handle when the connection is being closed.\ntypealias nw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\nfunc nw_framer_set_cleanup_handler(nw_framer_t, nw_framer_cleanup_handler_t)\nSets a block to handle the final cleanup of allocations made by your protocol instance.\ntypealias nw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated.\nRelated Documentation\nvar nw_framer_start_result_will_mark_ready: nw_framer_start_result_t\nThe protocol will perform a handshake, preventing the overall connection from becoming ready until is called."
    },
    {
        "title": "nw_path_get_status(_:)",
        "url": "https://developer.apple.com/documentation/network/2976886-nw_path_get_status",
        "html": "See Also\nChecking Path Availability\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections."
    },
    {
        "title": "nw_quic_get_stream_is_unidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801759-nw_quic_get_stream_is_unidirecti",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nA Boolean value that indicates whether the QUIC stream is unidirectional.\n\nSee Also\nCustomizing Stream Options\nfunc nw_quic_set_stream_is_unidirectional(nw_protocol_options_t, Bool)\nConfigures a QUIC stream as unidirectional, instead of bidirectional.\nfunc nw_quic_set_stream_is_datagram(nw_protocol_options_t, Bool)\nConfigures a QUIC stream as a datagram flow, instead of a byte stream."
    },
    {
        "title": "nw_quic_get_stream_is_datagram(_:)",
        "url": "https://developer.apple.com/documentation/network/3951296-nw_quic_get_stream_is_datagram",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nA Boolean value that indicates whether the QUIC stream is a datagram flow."
    },
    {
        "title": "nw_quic_get_max_udp_payload_size(_:)",
        "url": "https://developer.apple.com/documentation/network/3801753-nw_quic_get_max_udp_payload_size",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe maximum length of a QUIC packet, in bytes.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_get_remote_idle_timeout(_:)",
        "url": "https://developer.apple.com/documentation/network/3801754-nw_quic_get_remote_idle_timeout",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe idle_timeout value from the peer\u2019s transport parameters, in milliseconds.\n\nSee Also\nInspecting Connection State\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create."
    },
    {
        "title": "nw_quic_get_local_max_streams_unidirectional(_:)",
        "url": "https://developer.apple.com/documentation/network/3801752-nw_quic_get_local_max_streams_un",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe maximum number of unidirectional streams that the peer can create.\n\nSee Also\nInspecting Connection State\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds."
    },
    {
        "title": "nw_quic_get_initial_max_stream_data_bidirectional_remote(_:)",
        "url": "https://developer.apple.com/documentation/network/3801746-nw_quic_get_initial_max_stream_d",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe value of the initial_max_stream_data_bidi_remote transport parameter.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_get_idle_timeout(_:)",
        "url": "https://developer.apple.com/documentation/network/3801743-nw_quic_get_idle_timeout",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nAn idle timeout value, in milliseconds.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_add_tls_application_protocol(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3801738-nw_quic_add_tls_application_prot",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\napplication_protocol\n\nA supported Application-Layer Protocol Negotiation value.\n\nSee Also\nCustomizing Connection Options\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes."
    },
    {
        "title": "nw_quic_get_application_error(_:)",
        "url": "https://developer.apple.com/documentation/network/3801742-nw_quic_get_application_error",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nA QUIC application error code.\n\nSee Also\nHandling Errors\nfunc nw_quic_set_application_error(nw_protocol_metadata_t, UInt64, UnsafePointer<CChar>?)\nSets the QUIC application error code to send for the connection.\nfunc nw_quic_get_application_error_reason(nw_protocol_metadata_t) -> UnsafePointer<CChar>?\nAccesses the QUIC application error reason received from the peer.\nfunc nw_quic_set_stream_application_error(nw_protocol_metadata_t, UInt64)\nSets the QUIC application error code to send for the stream."
    },
    {
        "title": "nw_quic_get_application_error_reason(_:)",
        "url": "https://developer.apple.com/documentation/network/3816771-nw_quic_get_application_error_re",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nAn error reason string.\n\nSee Also\nHandling Errors\nfunc nw_quic_set_application_error(nw_protocol_metadata_t, UInt64, UnsafePointer<CChar>?)\nSets the QUIC application error code to send for the connection.\nfunc nw_quic_get_application_error(nw_protocol_metadata_t) -> UInt64\nAccesses the QUIC application error code received from the peer.\nfunc nw_quic_set_stream_application_error(nw_protocol_metadata_t, UInt64)\nSets the QUIC application error code to send for the stream."
    },
    {
        "title": "nw_quic_create_options()",
        "url": "https://developer.apple.com/documentation/network/3801741-nw_quic_create_options",
        "html": "Return Value\n\nA default set of QUIC connection options.\n\nSee Also\nCreating QUIC Connections\nfunc nw_protocol_copy_quic_definition() -> nw_protocol_definition_t\nAccesses the system definition of the QUIC transport protocol."
    },
    {
        "title": "nw_quic_copy_sec_protocol_metadata(_:)",
        "url": "https://developer.apple.com/documentation/network/3801739-nw_quic_copy_sec_protocol_metada",
        "html": "Parameters\nmetadata\n\nA QUIC protocol metadata instance.\n\nReturn Value\n\nThe security metadata for the QUIC connection."
    },
    {
        "title": "nw_quic_copy_sec_protocol_options(_:)",
        "url": "https://developer.apple.com/documentation/network/3801740-nw_quic_copy_sec_protocol_option",
        "html": "Parameters\noptions\n\nA QUIC protocol options instance.\n\nReturn Value\n\nThe security options for the QUIC connection."
    },
    {
        "title": "nw_protocol_metadata_is_ip(_:)",
        "url": "https://developer.apple.com/documentation/network/2976777-nw_protocol_metadata_is_ip",
        "html": "See Also\nHandling IP Packets\nfunc nw_ip_create_metadata() -> nw_protocol_metadata_t\nInitializes an IP packet configuration with default settings.\nfunc nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t, nw_ip_ecn_flag_t)\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nfunc nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t) -> nw_ip_ecn_flag_t\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nfunc nw_ip_metadata_set_service_class(nw_protocol_metadata_t, nw_service_class_t)\nSets a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_service_class(nw_protocol_metadata_t) -> nw_service_class_t\nAccesses a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW."
    },
    {
        "title": "nw_parameters_requires_dnssec_validation(_:)",
        "url": "https://developer.apple.com/documentation/network/3951293-nw_parameters_requires_dnssec_va",
        "html": "Parameters\nparameters\n\nAn object that stores the protocols to use for connections, options for sending data, and network path constraints.\n\nReturn Value\n\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints."
    },
    {
        "title": "nw_endpoint_create_bonjour_service(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976719-nw_endpoint_create_bonjour_servi",
        "html": "See Also\nBonjour Service Endpoints\nfunc nw_endpoint_get_bonjour_service_name(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service name stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_type(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_domain(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service domain stored in an endpoint."
    },
    {
        "title": "nw_framer_async(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114473-nw_framer_async",
        "html": "Discussion\n\nYou should call this if you need to call any framer functions but are in another scheduling context.\n\nSee Also\nHandling Asynchronous Events\nfunc nw_framer_schedule_wakeup(nw_framer_t, UInt64)\nRequests that the nw_framer_wakeup_handler_t be called on your protocol at a specific time in the future.\nvar NW_FRAMER_WAKEUP_TIME_FOREVER: UInt64\nA sentinel value that indicates that no wakeup should be delivered.\nfunc nw_framer_set_wakeup_handler(nw_framer_t, nw_framer_wakeup_handler_t)\nSets a handler to receive scheduled wakeup events.\ntypealias nw_framer_wakeup_handler_t\nA handler that delivers a scheduled wakeup event.\ntypealias nw_framer_block_t\nA block to be invoked asynchronously on your framer protocol's scheduling context."
    },
    {
        "title": "nw_parameters_create_quic(_:)",
        "url": "https://developer.apple.com/documentation/network/3801734-nw_parameters_create_quic",
        "html": "Parameters\nconfigure_quic\n\nA closure that receives an nw_protocol_options_t instance. Provide a custom block and call the various nw_quic_set\u2026 functions on this instance to customize connection and listener parameters. If you want to use default parameters, pass NW_PARAMETERS_DEFAULT_CONFIGURATION for this value. This method doesn\u2019t support passing NW_PARAMETERS_DISABLE_PROTOCOL to disable the protocol."
    },
    {
        "title": "nw_parameters_set_requires_dnssec_validation(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3951294-nw_parameters_set_requires_dnsse",
        "html": "Parameters\nparameters\n\nAn object that stores the protocols to use for connections, options for sending data, and network path constraints.\n\nrequires_dnssec_validation\n\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints."
    },
    {
        "title": "nw_multicast_group_descriptor_set_specific_source(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584817-nw_multicast_group_descriptor_se",
        "html": "See Also\nCustomizing Multicast Behavior\nfunc nw_multicast_group_descriptor_set_disable_unicast_traffic(nw_group_descriptor_t, Bool)\nSets a Boolean that indicates whether a connection group should reject unicast traffic.\nfunc nw_multicast_group_descriptor_get_disable_unicast_traffic(nw_group_descriptor_t) -> Bool\nChecks a Boolean that indicates whether a connection group should reject unicast traffic."
    },
    {
        "title": "nw_multicast_group_descriptor_set_disable_unicast_traffic(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584816-nw_multicast_group_descriptor_se",
        "html": "See Also\nCustomizing Multicast Behavior\nfunc nw_multicast_group_descriptor_get_disable_unicast_traffic(nw_group_descriptor_t) -> Bool\nChecks a Boolean that indicates whether a connection group should reject unicast traffic.\nfunc nw_multicast_group_descriptor_set_specific_source(nw_group_descriptor_t, nw_endpoint_t)\nSets an optional address endpoint used to filter received multicast packets."
    },
    {
        "title": "nw_data_transfer_report_get_received_transport_out_of_order_byte_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114440-nw_data_transfer_report_get_rece",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_interface_get_name(_:)",
        "url": "https://developer.apple.com/documentation/network/2976749-nw_interface_get_name",
        "html": "See Also\nInspecting Interfaces\nfunc nw_interface_get_type(nw_interface_t) -> nw_interface_type_t\nAccesses the type of the interface, such as Wi-Fi or Loopback.\nfunc nw_interface_get_index(nw_interface_t) -> UInt32\nAccesses the system interface index associated with the interface."
    },
    {
        "title": "nw_group_descriptor_enumerate_endpoints(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584812-nw_group_descriptor_enumerate_en",
        "html": "See Also\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages."
    },
    {
        "title": "nw_framer_set_cleanup_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114503-nw_framer_set_cleanup_handler",
        "html": "See Also\nManaging Instance Lifetime\nfunc nw_framer_mark_ready(nw_framer_t)\nIndicates to a connection that your protocol's handshake is complete.\nfunc nw_framer_mark_failed_with_error(nw_framer_t, Int32)\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nfunc nw_framer_prepend_application_protocol(nw_framer_t, nw_protocol_options_t) -> Bool\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready(_:).\nfunc nw_framer_set_stop_handler(nw_framer_t, nw_framer_stop_handler_t)\nSets a block to handle when the connection is being closed.\ntypealias nw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\ntypealias nw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated."
    },
    {
        "title": "nw_ip_options_set_disable_fragmentation(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976768-nw_ip_options_set_disable_fragme",
        "html": "See Also\nConfiguring IP Connections\nfunc nw_protocol_copy_ip_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Internet Protocol.\nfunc nw_ip_options_set_version(nw_protocol_options_t, nw_ip_version_t)\nSets a required IP version to disable all other versions for a connection.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets.\nfunc nw_ip_options_set_hop_limit(nw_protocol_options_t, UInt8)\nConfigures the default hop limit for packets generated by a connection.\nfunc nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t, Bool)\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nfunc nw_ip_options_set_local_address_preference(nw_protocol_options_t, nw_ip_local_address_preference_t)\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable."
    },
    {
        "title": "nw_ip_metadata_get_service_class(_:)",
        "url": "https://developer.apple.com/documentation/network/2976765-nw_ip_metadata_get_service_class",
        "html": "See Also\nHandling IP Packets\nfunc nw_ip_create_metadata() -> nw_protocol_metadata_t\nInitializes an IP packet configuration with default settings.\nfunc nw_protocol_metadata_is_ip(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents an IP packet.\nfunc nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t, nw_ip_ecn_flag_t)\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nfunc nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t) -> nw_ip_ecn_flag_t\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nfunc nw_ip_metadata_set_service_class(nw_protocol_metadata_t, nw_service_class_t)\nSets a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW."
    },
    {
        "title": "nw_framer_parse_output(_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114498-nw_framer_parse_output",
        "html": "Parameters\nminimum_incomplete_length\n\nThe minimum number of bytes that should be delivered to the parse completion.\n\nmaximum_length\n\nThe maximum number of bytes that should be delivered to the parse completion.\n\ntemp_buffer\n\nAn optional buffer into which the parser will copy bytes. Use this if you need to make guarantees about byte alignment.\n\nparse\n\nA completion handler that will be called inline to examine a region of bytes.\n\nReturn Value\n\nReturns true if the requested length was available to parse, or false if the conditions could not be met.\n\nSee Also\nHandling Output Data\nfunc nw_framer_set_output_handler(nw_framer_t, nw_framer_output_handler_t)\nSets a block to handle new outbound messages.\ntypealias nw_framer_output_handler_t\nA handler that notifies your protocol about a new outbound message.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_write_output(nw_framer_t, UnsafePointer<UInt8>, Int)\nSends arbitrary output data in a buffer from your protocol to the next protocol.\nfunc nw_framer_write_output_data(nw_framer_t, dispatch_data_t)\nSends arbitrary output data from your protocol to the next protocol.\nfunc nw_framer_write_output_no_copy(nw_framer_t, Int) -> Bool\nSends a specific number of bytes from a message while inside your output handler.\nfunc nw_framer_pass_through_output(nw_framer_t)\nIndicates that your protocol no longer needs to handle output data."
    },
    {
        "title": "nw_framer_write_output_no_copy(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114517-nw_framer_write_output_no_copy",
        "html": "See Also\nHandling Output Data\nfunc nw_framer_set_output_handler(nw_framer_t, nw_framer_output_handler_t)\nSets a block to handle new outbound messages.\ntypealias nw_framer_output_handler_t\nA handler that notifies your protocol about a new outbound message.\nfunc nw_framer_parse_output(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of output data while inside your output handler.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_write_output(nw_framer_t, UnsafePointer<UInt8>, Int)\nSends arbitrary output data in a buffer from your protocol to the next protocol.\nfunc nw_framer_write_output_data(nw_framer_t, dispatch_data_t)\nSends arbitrary output data from your protocol to the next protocol.\nfunc nw_framer_pass_through_output(nw_framer_t)\nIndicates that your protocol no longer needs to handle output data."
    },
    {
        "title": "nw_framer_write_output_data(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114516-nw_framer_write_output_data",
        "html": "See Also\nHandling Output Data\nfunc nw_framer_set_output_handler(nw_framer_t, nw_framer_output_handler_t)\nSets a block to handle new outbound messages.\ntypealias nw_framer_output_handler_t\nA handler that notifies your protocol about a new outbound message.\nfunc nw_framer_parse_output(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of output data while inside your output handler.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_write_output(nw_framer_t, UnsafePointer<UInt8>, Int)\nSends arbitrary output data in a buffer from your protocol to the next protocol.\nfunc nw_framer_write_output_no_copy(nw_framer_t, Int) -> Bool\nSends a specific number of bytes from a message while inside your output handler.\nfunc nw_framer_pass_through_output(nw_framer_t)\nIndicates that your protocol no longer needs to handle output data."
    },
    {
        "title": "nw_framer_write_output(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114515-nw_framer_write_output",
        "html": "See Also\nHandling Output Data\nfunc nw_framer_set_output_handler(nw_framer_t, nw_framer_output_handler_t)\nSets a block to handle new outbound messages.\ntypealias nw_framer_output_handler_t\nA handler that notifies your protocol about a new outbound message.\nfunc nw_framer_parse_output(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of output data while inside your output handler.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_write_output_data(nw_framer_t, dispatch_data_t)\nSends arbitrary output data from your protocol to the next protocol.\nfunc nw_framer_write_output_no_copy(nw_framer_t, Int) -> Bool\nSends a specific number of bytes from a message while inside your output handler.\nfunc nw_framer_pass_through_output(nw_framer_t)\nIndicates that your protocol no longer needs to handle output data."
    },
    {
        "title": "nw_framer_schedule_wakeup(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114502-nw_framer_schedule_wakeup",
        "html": "See Also\nHandling Asynchronous Events\nvar NW_FRAMER_WAKEUP_TIME_FOREVER: UInt64\nA sentinel value that indicates that no wakeup should be delivered.\nfunc nw_framer_set_wakeup_handler(nw_framer_t, nw_framer_wakeup_handler_t)\nSets a handler to receive scheduled wakeup events.\ntypealias nw_framer_wakeup_handler_t\nA handler that delivers a scheduled wakeup event.\nfunc nw_framer_async(nw_framer_t, nw_framer_block_t)\nRequests that a block be executed on the connection's internal scheduling context.\ntypealias nw_framer_block_t\nA block to be invoked asynchronously on your framer protocol's scheduling context."
    },
    {
        "title": "nw_group_descriptor_add_endpoint(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584810-nw_group_descriptor_add_endpoint",
        "html": "See Also\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages."
    },
    {
        "title": "nw_framer_set_wakeup_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114507-nw_framer_set_wakeup_handler",
        "html": "See Also\nHandling Asynchronous Events\nfunc nw_framer_schedule_wakeup(nw_framer_t, UInt64)\nRequests that the nw_framer_wakeup_handler_t be called on your protocol at a specific time in the future.\nvar NW_FRAMER_WAKEUP_TIME_FOREVER: UInt64\nA sentinel value that indicates that no wakeup should be delivered.\ntypealias nw_framer_wakeup_handler_t\nA handler that delivers a scheduled wakeup event.\nfunc nw_framer_async(nw_framer_t, nw_framer_block_t)\nRequests that a block be executed on the connection's internal scheduling context.\ntypealias nw_framer_block_t\nA block to be invoked asynchronously on your framer protocol's scheduling context."
    },
    {
        "title": "nw_framer_pass_through_output(_:)",
        "url": "https://developer.apple.com/documentation/network/3114500-nw_framer_pass_through_output",
        "html": "See Also\nHandling Output Data\nfunc nw_framer_set_output_handler(nw_framer_t, nw_framer_output_handler_t)\nSets a block to handle new outbound messages.\ntypealias nw_framer_output_handler_t\nA handler that notifies your protocol about a new outbound message.\nfunc nw_framer_parse_output(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of output data while inside your output handler.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\nfunc nw_framer_write_output(nw_framer_t, UnsafePointer<UInt8>, Int)\nSends arbitrary output data in a buffer from your protocol to the next protocol.\nfunc nw_framer_write_output_data(nw_framer_t, dispatch_data_t)\nSends arbitrary output data from your protocol to the next protocol.\nfunc nw_framer_write_output_no_copy(nw_framer_t, Int) -> Bool\nSends a specific number of bytes from a message while inside your output handler."
    },
    {
        "title": "nw_framer_set_stop_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114506-nw_framer_set_stop_handler",
        "html": "See Also\nManaging Instance Lifetime\nfunc nw_framer_mark_ready(nw_framer_t)\nIndicates to a connection that your protocol's handshake is complete.\nfunc nw_framer_mark_failed_with_error(nw_framer_t, Int32)\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nfunc nw_framer_prepend_application_protocol(nw_framer_t, nw_protocol_options_t) -> Bool\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready(_:).\ntypealias nw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\nfunc nw_framer_set_cleanup_handler(nw_framer_t, nw_framer_cleanup_handler_t)\nSets a block to handle the final cleanup of allocations made by your protocol instance.\ntypealias nw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated."
    },
    {
        "title": "nw_framer_create_definition(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114479-nw_framer_create_definition",
        "html": "Discussion\n\nEach time you initialize a protocol definition with your custom start handler, a new definition is created that will not be considered equal to other definitions. If you need to associate messages with a protocol you have added to a connection's protocol stack, make sure to use the same definition.\n\nSee Also\nAdding Framers to Connections\ntypealias nw_framer_start_handler_t\nA handler that represents the entry point into your custom protocol.\ntypealias nw_framer_t\nAn object that represents a single instance of your custom protocol running in a connection.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nvar NW_FRAMER_CREATE_FLAGS_DEFAULT: Int32\nA constant flag value that indicates that the default framer protocol behavior should be used.\nfunc nw_framer_create_options(nw_protocol_definition_t) -> nw_protocol_options_t\nInitializes a set of protocol options with a custom framer definition."
    },
    {
        "title": "nw_path_monitor_set_update_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976906-nw_path_monitor_set_update_handl",
        "html": "See Also\nHandling Path Updates\ntypealias nw_path_monitor_update_handler_t\nA handler that delivers network path updates."
    },
    {
        "title": "nw_framer_message_set_value(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114493-nw_framer_message_set_value",
        "html": "See Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_framer_copy_remote_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/3114478-nw_framer_copy_remote_endpoint",
        "html": "See Also\nInspecting Instance Properties\nfunc nw_framer_copy_local_endpoint(nw_framer_t) -> nw_endpoint_t\nAccesses the local endpoint of the connection in which your protocol is running.\nfunc nw_framer_copy_parameters(nw_framer_t) -> nw_parameters_t\nAccesses the parameters of the connection in which your protocol is running."
    },
    {
        "title": "nw_framer_message_copy_object_value(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114487-nw_framer_message_copy_object_va",
        "html": "See Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message."
    },
    {
        "title": "nw_framer_message_access_value(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114486-nw_framer_message_access_value",
        "html": "Parameters\nmessage\n\nThe message to inspect.\n\nkey\n\nThe custom key used to store the value.\n\naccess_value\n\nA block that will deliver the pointer value stored for the key. The block will be called inline. Returns a value to return to the outer function.\n\nReturn Value\n\nReturns false if the key was not present, or else the boolean returned by the access block.\n\nSee Also\nCustomizing Framer Messages\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message."
    },
    {
        "title": "nw_path_is_constrained(_:)",
        "url": "https://developer.apple.com/documentation/network/3131049-nw_path_is_constrained",
        "html": "See Also\nChecking Path Capabilities\nfunc nw_path_has_ipv4(nw_path_t) -> Bool\nChecks whether the path can route IPv4 traffic.\nfunc nw_path_has_ipv6(nw_path_t) -> Bool\nChecks whether the path can route IPv6 traffic.\nfunc nw_path_has_dns(nw_path_t) -> Bool\nChecks whether the path has a DNS server configured.\nfunc nw_path_is_expensive(nw_path_t) -> Bool\nChecks whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot."
    },
    {
        "title": "nw_path_enumerate_interfaces(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976884-nw_path_enumerate_interfaces",
        "html": "See Also\nInspecting Interfaces\nfunc nw_path_uses_interface_type(nw_path_t, nw_interface_type_t) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\ntypealias nw_path_enumerate_interfaces_block_t\nA block that enumerates the interfaces available to a path.\nfunc nw_path_enumerate_gateways(nw_path_t, (nw_endpoint_t) -> Bool)\nEnumerates the list of gateways configured on the interfaces available to a path.\ntypealias nw_path_enumerate_gateways_block_t\nA block that enumerates the gateways configured on the interfaces available to a path."
    },
    {
        "title": "nw_path_has_ipv6(_:)",
        "url": "https://developer.apple.com/documentation/network/2976889-nw_path_has_ipv6",
        "html": "See Also\nChecking Path Capabilities\nfunc nw_path_has_ipv4(nw_path_t) -> Bool\nChecks whether the path can route IPv4 traffic.\nfunc nw_path_has_dns(nw_path_t) -> Bool\nChecks whether the path has a DNS server configured.\nfunc nw_path_is_constrained(nw_path_t) -> Bool\nChecks whether the path uses an interface in Low Data Mode.\nfunc nw_path_is_expensive(nw_path_t) -> Bool\nChecks whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot."
    },
    {
        "title": "nw_path_has_dns(_:)",
        "url": "https://developer.apple.com/documentation/network/2976887-nw_path_has_dns",
        "html": "See Also\nChecking Path Capabilities\nfunc nw_path_has_ipv4(nw_path_t) -> Bool\nChecks whether the path can route IPv4 traffic.\nfunc nw_path_has_ipv6(nw_path_t) -> Bool\nChecks whether the path can route IPv6 traffic.\nfunc nw_path_is_constrained(nw_path_t) -> Bool\nChecks whether the path uses an interface in Low Data Mode.\nfunc nw_path_is_expensive(nw_path_t) -> Bool\nChecks whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot."
    },
    {
        "title": "nw_path_is_expensive(_:)",
        "url": "https://developer.apple.com/documentation/network/2976891-nw_path_is_expensive",
        "html": "See Also\nChecking Path Capabilities\nfunc nw_path_has_ipv4(nw_path_t) -> Bool\nChecks whether the path can route IPv4 traffic.\nfunc nw_path_has_ipv6(nw_path_t) -> Bool\nChecks whether the path can route IPv6 traffic.\nfunc nw_path_has_dns(nw_path_t) -> Bool\nChecks whether the path has a DNS server configured.\nfunc nw_path_is_constrained(nw_path_t) -> Bool\nChecks whether the path uses an interface in Low Data Mode."
    },
    {
        "title": "nw_path_has_ipv4(_:)",
        "url": "https://developer.apple.com/documentation/network/2976888-nw_path_has_ipv4",
        "html": "See Also\nChecking Path Capabilities\nfunc nw_path_has_ipv6(nw_path_t) -> Bool\nChecks whether the path can route IPv6 traffic.\nfunc nw_path_has_dns(nw_path_t) -> Bool\nChecks whether the path has a DNS server configured.\nfunc nw_path_is_constrained(nw_path_t) -> Bool\nChecks whether the path uses an interface in Low Data Mode.\nfunc nw_path_is_expensive(nw_path_t) -> Bool\nChecks whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot."
    },
    {
        "title": "nw_path_monitor_cancel(_:)",
        "url": "https://developer.apple.com/documentation/network/2976900-nw_path_monitor_cancel",
        "html": "See Also\nCanceling Path Monitors\nfunc nw_path_monitor_set_cancel_handler(nw_path_monitor_t, nw_path_monitor_cancel_handler_t)\nSets a handler to determine when a monitor is fully cancelled and will no longer deliver events.\ntypealias nw_path_monitor_cancel_handler_t\nA handler that indicates when a monitor has been cancelled."
    },
    {
        "title": "nw_connection_receive_message(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976683-nw_connection_receive_message",
        "html": "Parameters\ncompletion\n\nA receive completion is invoked exactly once for a call to receive. The completion indicates that the requested content has been received (in which case the content is delivered), or else an error has occurred.\n\nThe completion delivers the received content, which may be nil if the message is complete or an error occurred, the message context, a flag indicating if the message is complete, and any associated error.\n\nDiscussion\n\nReceiving messages allows you to deal with complete datagrams or application-layer messages without needing to reconstruct a stream.\n\nIf you are using UDP, receiving a message will deliver a single datagram.\n\nIf you request to receive a message on a protocol that is otherwise an unbounded bytestream, like TCP or TLS, note that this will not deliver any data until the stream is closed by the peer.\n\nIn order to use messages on top of a bytestream protocol, add WebSocket Options or custom Framer Protocol Options to your protocol stack.\n\nSee Also\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "nw_data_transfer_report_get_received_application_byte_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114436-nw_data_transfer_report_get_rece",
        "html": "See Also\nInspecting Application Metrics\nfunc nw_data_transfer_report_get_sent_application_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent on the connection."
    },
    {
        "title": "nw_data_transfer_report_get_duration_milliseconds(_:)",
        "url": "https://developer.apple.com/documentation/network/3114434-nw_data_transfer_report_get_dura",
        "html": "See Also\nIdentifying Paths\nfunc nw_data_transfer_report_get_path_count(nw_data_transfer_report_t) -> UInt32\nChecks the number of valid paths in the report.\nfunc nw_data_transfer_report_copy_path_interface(nw_data_transfer_report_t, UInt32) -> nw_interface_t\nAccesses the network interface the path used."
    },
    {
        "title": "nw_ethernet_channel_cancel(_:)",
        "url": "https://developer.apple.com/documentation/network/3181990-nw_ethernet_channel_cancel",
        "html": "See Also\nManaging Ethernet Channels\nfunc nw_ethernet_channel_create(UInt16, nw_interface_t) -> nw_ethernet_channel_t\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc nw_ethernet_channel_set_queue(nw_ethernet_channel_t, dispatch_queue_t)\nSets the queue on which all channel events are delivered.\nfunc nw_ethernet_channel_start(nw_ethernet_channel_t)\nStarts the process of registering the channel."
    },
    {
        "title": "nw_framer_copy_local_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/3114476-nw_framer_copy_local_endpoint",
        "html": "See Also\nInspecting Instance Properties\nfunc nw_framer_copy_remote_endpoint(nw_framer_t) -> nw_endpoint_t\nAccesses the remote endpoint of the connection in which your protocol is running.\nfunc nw_framer_copy_parameters(nw_framer_t) -> nw_parameters_t\nAccesses the parameters of the connection in which your protocol is running."
    },
    {
        "title": "nw_endpoint_create_host(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976720-nw_endpoint_create_host",
        "html": "See Also\nHost Endpoints\nfunc nw_endpoint_get_hostname(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the hostname stored in an endpoint.\nfunc nw_endpoint_get_port(nw_endpoint_t) -> UInt16\nAccesses the port stored in an endpoint, in host-byte order.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string."
    },
    {
        "title": "nw_framer_copy_parameters(_:)",
        "url": "https://developer.apple.com/documentation/network/3114477-nw_framer_copy_parameters",
        "html": "See Also\nInspecting Instance Properties\nfunc nw_framer_copy_remote_endpoint(nw_framer_t) -> nw_endpoint_t\nAccesses the remote endpoint of the connection in which your protocol is running.\nfunc nw_framer_copy_local_endpoint(nw_framer_t) -> nw_endpoint_t\nAccesses the local endpoint of the connection in which your protocol is running."
    },
    {
        "title": "nw_ethernet_channel_start(_:)",
        "url": "https://developer.apple.com/documentation/network/3181997-nw_ethernet_channel_start",
        "html": "See Also\nManaging Ethernet Channels\nfunc nw_ethernet_channel_create(UInt16, nw_interface_t) -> nw_ethernet_channel_t\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc nw_ethernet_channel_set_queue(nw_ethernet_channel_t, dispatch_queue_t)\nSets the queue on which all channel events are delivered.\nfunc nw_ethernet_channel_cancel(nw_ethernet_channel_t)\nUnregisters the channel from the interface."
    },
    {
        "title": "nw_ethernet_channel_create(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3181991-nw_ethernet_channel_create",
        "html": "Parameters\nether_type\n\nThe custom Ethernet frame type to register for this channel, in host-byte order.\n\ninterface\n\nThe interface on which to send and receive Ethernet frames.\n\nSee Also\nManaging Ethernet Channels\nfunc nw_ethernet_channel_set_queue(nw_ethernet_channel_t, dispatch_queue_t)\nSets the queue on which all channel events are delivered.\nfunc nw_ethernet_channel_start(nw_ethernet_channel_t)\nStarts the process of registering the channel.\nfunc nw_ethernet_channel_cancel(nw_ethernet_channel_t)\nUnregisters the channel from the interface."
    },
    {
        "title": "nw_endpoint_get_hostname(_:)",
        "url": "https://developer.apple.com/documentation/network/2976725-nw_endpoint_get_hostname",
        "html": "See Also\nHost Endpoints\nfunc nw_endpoint_create_host(UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a hostname and port, where the hostname may be interpreted as an IP address.\nfunc nw_endpoint_get_port(nw_endpoint_t) -> UInt16\nAccesses the port stored in an endpoint, in host-byte order.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string."
    },
    {
        "title": "nw_establishment_report_get_used_proxy(_:)",
        "url": "https://developer.apple.com/documentation/network/3114461-nw_establishment_report_get_used",
        "html": "See Also\nChecking for Proxies\nfunc nw_establishment_report_get_proxy_configured(nw_establishment_report_t) -> Bool\nChecks whether a proxy was configured on the connection.\nfunc nw_establishment_report_copy_proxy_endpoint(nw_establishment_report_t) -> nw_endpoint_t?\nAccesses the endpoint of the proxy the connection used."
    },
    {
        "title": "nw_endpoint_copy_address_string(_:)",
        "url": "https://developer.apple.com/documentation/network/2976716-nw_endpoint_copy_address_string",
        "html": "Discussion\n\nThis function allocates a new string. You should free the returned buffer when done using the string.\n\nSee Also\nAddress Endpoints\nfunc nw_endpoint_create_address(UnsafePointer<sockaddr>) -> nw_endpoint_t\nCreates a network endpoint with an address structure.\nfunc nw_endpoint_get_address(nw_endpoint_t) -> UnsafePointer<sockaddr>\nAccesses the address structure stored in an address endpoint.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string."
    },
    {
        "title": "nw_endpoint_create_address(_:)",
        "url": "https://developer.apple.com/documentation/network/2976718-nw_endpoint_create_address",
        "html": "See Also\nAddress Endpoints\nfunc nw_endpoint_get_address(nw_endpoint_t) -> UnsafePointer<sockaddr>\nAccesses the address structure stored in an address endpoint.\nfunc nw_endpoint_copy_address_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the address of an endpoint as a string.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string."
    },
    {
        "title": "nw_listener_set_queue(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976789-nw_listener_set_queue",
        "html": "See Also\nCreating Listeners\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections."
    },
    {
        "title": "nw_listener_set_new_connection_limit(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3152230-nw_listener_set_new_connection_l",
        "html": "Discussion\n\nWhen the new connection limit is set to a non-infinite value, it will decrement for every received connection. Once the value hits zero, new connections will be queued and eventually blocked, until you raise the limit. This allows you to limit the rate of inbound connections you handle.\n\nBy default, the limit is NW_LISTENER_INFINITE_CONNECTION_LIMIT. When the limit is infinite, it does not decrement but allows all inbound connections.\n\nSee Also\nReceiving Connections\nfunc nw_listener_set_new_connection_handler(nw_listener_t, nw_listener_new_connection_handler_t?)\nSets a handler that receives inbound connections.\ntypealias nw_listener_new_connection_handler_t\nA handler that delivers inbound connections.\nfunc nw_listener_get_new_connection_limit(nw_listener_t) -> UInt32\nChecks the remaining number of inbound connections to deliver before rejecting connections.\nvar NW_LISTENER_INFINITE_CONNECTION_LIMIT: UInt32\nA static value that indicates that inbound connections should not be limited."
    },
    {
        "title": "nw_listener_get_new_connection_limit(_:)",
        "url": "https://developer.apple.com/documentation/network/3152229-nw_listener_get_new_connection_l",
        "html": "See Also\nReceiving Connections\nfunc nw_listener_set_new_connection_handler(nw_listener_t, nw_listener_new_connection_handler_t?)\nSets a handler that receives inbound connections.\ntypealias nw_listener_new_connection_handler_t\nA handler that delivers inbound connections.\nfunc nw_listener_set_new_connection_limit(nw_listener_t, UInt32)\nResets the number of inbound connections to deliver before rejecting connections.\nvar NW_LISTENER_INFINITE_CONNECTION_LIMIT: UInt32\nA static value that indicates that inbound connections should not be limited."
    },
    {
        "title": "nw_listener_get_port(_:)",
        "url": "https://developer.apple.com/documentation/network/2976784-nw_listener_get_port",
        "html": "Discussion\n\nThe listener's port is available once the listener is in the ready state.\n\nSee Also\nCreating Listeners\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections."
    },
    {
        "title": "nw_listener_set_advertise_descriptor(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976786-nw_listener_set_advertise_descri",
        "html": "See Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\ntypealias nw_advertise_descriptor_t\nA description used to advertise the Bonjour service that a listener provides.\nfunc nw_listener_set_advertised_endpoint_changed_handler(nw_listener_t, nw_listener_advertised_endpoint_changed_handler_t?)\nSets a handler that receives updates for the service endpoint being advertised.\ntypealias nw_listener_advertised_endpoint_changed_handler_t\nA handler that indicates changes to the service endpoints being advertised as they are added and removed."
    },
    {
        "title": "nw_listener_cancel(_:)",
        "url": "https://developer.apple.com/documentation/network/2976780-nw_listener_cancel",
        "html": "See Also\nCreating Listeners\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections."
    },
    {
        "title": "nw_listener_create(_:)",
        "url": "https://developer.apple.com/documentation/network/2976781-nw_listener_create",
        "html": "See Also\nCreating Listeners\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections."
    },
    {
        "title": "nw_listener_create_with_connection(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976782-nw_listener_create_with_connecti",
        "html": "See Also\nCreating Listeners\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections."
    },
    {
        "title": "nw_ip_metadata_get_ecn_flag(_:)",
        "url": "https://developer.apple.com/documentation/network/2976764-nw_ip_metadata_get_ecn_flag",
        "html": "See Also\nHandling IP Packets\nfunc nw_ip_create_metadata() -> nw_protocol_metadata_t\nInitializes an IP packet configuration with default settings.\nfunc nw_protocol_metadata_is_ip(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents an IP packet.\nfunc nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t, nw_ip_ecn_flag_t)\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nfunc nw_ip_metadata_set_service_class(nw_protocol_metadata_t, nw_service_class_t)\nSets a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_service_class(nw_protocol_metadata_t) -> nw_service_class_t\nAccesses a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW."
    },
    {
        "title": "nw_ip_metadata_set_ecn_flag(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976766-nw_ip_metadata_set_ecn_flag",
        "html": "See Also\nHandling IP Packets\nfunc nw_ip_create_metadata() -> nw_protocol_metadata_t\nInitializes an IP packet configuration with default settings.\nfunc nw_protocol_metadata_is_ip(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents an IP packet.\nfunc nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t) -> nw_ip_ecn_flag_t\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nfunc nw_ip_metadata_set_service_class(nw_protocol_metadata_t, nw_service_class_t)\nSets a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_service_class(nw_protocol_metadata_t) -> nw_service_class_t\nAccesses a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW."
    },
    {
        "title": "nw_ip_options_set_calculate_receive_time(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3019338-nw_ip_options_set_calculate_rece",
        "html": "See Also\nConfiguring IP Connections\nfunc nw_protocol_copy_ip_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Internet Protocol.\nfunc nw_ip_options_set_version(nw_protocol_options_t, nw_ip_version_t)\nSets a required IP version to disable all other versions for a connection.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nfunc nw_ip_options_set_hop_limit(nw_protocol_options_t, UInt8)\nConfigures the default hop limit for packets generated by a connection.\nfunc nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t, Bool)\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nfunc nw_ip_options_set_disable_fragmentation(nw_protocol_options_t, Bool)\nConfigures a connection to disable fragmentation on outbound packets.\nfunc nw_ip_options_set_local_address_preference(nw_protocol_options_t, nw_ip_local_address_preference_t)\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nRelated Documentation\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on ."
    },
    {
        "title": "nw_interface_get_type(_:)",
        "url": "https://developer.apple.com/documentation/network/2976750-nw_interface_get_type",
        "html": "See Also\nInspecting Interfaces\nfunc nw_interface_get_name(nw_interface_t) -> UnsafePointer<CChar>\nAccesses the name of the interface.\nfunc nw_interface_get_index(nw_interface_t) -> UInt32\nAccesses the system interface index associated with the interface."
    },
    {
        "title": "nw_ip_metadata_get_receive_time(_:)",
        "url": "https://developer.apple.com/documentation/network/3019337-nw_ip_metadata_get_receive_time",
        "html": "See Also\nHandling IP Packets\nfunc nw_ip_create_metadata() -> nw_protocol_metadata_t\nInitializes an IP packet configuration with default settings.\nfunc nw_protocol_metadata_is_ip(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents an IP packet.\nfunc nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t, nw_ip_ecn_flag_t)\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nfunc nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t) -> nw_ip_ecn_flag_t\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nfunc nw_ip_metadata_set_service_class(nw_protocol_metadata_t, nw_service_class_t)\nSets a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_service_class(nw_protocol_metadata_t) -> nw_service_class_t\nAccesses a specific service class to mark on an IP packet.\nRelated Documentation\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets."
    },
    {
        "title": "nw_ip_metadata_set_service_class(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976767-nw_ip_metadata_set_service_class",
        "html": "See Also\nHandling IP Packets\nfunc nw_ip_create_metadata() -> nw_protocol_metadata_t\nInitializes an IP packet configuration with default settings.\nfunc nw_protocol_metadata_is_ip(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents an IP packet.\nfunc nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t, nw_ip_ecn_flag_t)\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nfunc nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t) -> nw_ip_ecn_flag_t\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nfunc nw_ip_metadata_get_service_class(nw_protocol_metadata_t) -> nw_service_class_t\nAccesses a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW."
    },
    {
        "title": "nw_ip_create_metadata()",
        "url": "https://developer.apple.com/documentation/network/2976758-nw_ip_create_metadata",
        "html": "See Also\nHandling IP Packets\nfunc nw_protocol_metadata_is_ip(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents an IP packet.\nfunc nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t, nw_ip_ecn_flag_t)\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nfunc nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t) -> nw_ip_ecn_flag_t\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nfunc nw_ip_metadata_set_service_class(nw_protocol_metadata_t, nw_service_class_t)\nSets a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_service_class(nw_protocol_metadata_t) -> nw_service_class_t\nAccesses a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW."
    },
    {
        "title": "nw_interface_get_index(_:)",
        "url": "https://developer.apple.com/documentation/network/2976748-nw_interface_get_index",
        "html": "See Also\nInspecting Interfaces\nfunc nw_interface_get_type(nw_interface_t) -> nw_interface_type_t\nAccesses the type of the interface, such as Wi-Fi or Loopback.\nfunc nw_interface_get_name(nw_interface_t) -> UnsafePointer<CChar>\nAccesses the name of the interface."
    },
    {
        "title": "nw_group_descriptor_create_multicast(_:)",
        "url": "https://developer.apple.com/documentation/network/3584811-nw_group_descriptor_create_multi",
        "html": "Discussion\n\nImportant\n\nIn order to use multicast on iOS, your app will need to have the com.apple.developer.networking.multicast entitlement.\n\nTopics\nCustomizing Multicast Behavior\nfunc nw_multicast_group_descriptor_set_disable_unicast_traffic(nw_group_descriptor_t, Bool)\nSets a Boolean that indicates whether a connection group should reject unicast traffic.\nfunc nw_multicast_group_descriptor_get_disable_unicast_traffic(nw_group_descriptor_t) -> Bool\nChecks a Boolean that indicates whether a connection group should reject unicast traffic.\nfunc nw_multicast_group_descriptor_set_specific_source(nw_group_descriptor_t, nw_endpoint_t)\nSets an optional address endpoint used to filter received multicast packets.\nSee Also\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages."
    },
    {
        "title": "nw_framer_create_options(_:)",
        "url": "https://developer.apple.com/documentation/network/3114480-nw_framer_create_options",
        "html": "See Also\nAdding Framers to Connections\nfunc nw_framer_create_definition(UnsafePointer<CChar>, UInt32, nw_framer_start_handler_t) -> nw_protocol_definition_t\nInitializes a new protocol definition based on your protocol implementation.\ntypealias nw_framer_start_handler_t\nA handler that represents the entry point into your custom protocol.\ntypealias nw_framer_t\nAn object that represents a single instance of your custom protocol running in a connection.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nvar NW_FRAMER_CREATE_FLAGS_DEFAULT: Int32\nA constant flag value that indicates that the default framer protocol behavior should be used."
    },
    {
        "title": "nw_content_context_create(_:)",
        "url": "https://developer.apple.com/documentation/network/2976705-nw_content_context_create",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_connection_set_viability_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976691-nw_connection_set_viability_chan",
        "html": "See Also\nHandling Path Updates\nfunc nw_connection_copy_current_path(nw_connection_t) -> nw_path_t?\nAccesses the network path the connection is using.\nfunc nw_connection_set_path_changed_handler(nw_connection_t, nw_connection_path_event_handler_t?)\nSets a handler that receives network path updates.\ntypealias nw_connection_path_event_handler_t\nA handler that delivers network path updates.\nfunc nw_connection_set_better_path_available_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when an alternative network path is preferred over the current path.\ntypealias nw_connection_boolean_event_handler_t\nA handler that receives Boolean state updates from a connection, such as viability and better path state."
    },
    {
        "title": "nw_connection_set_better_path_available_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976687-nw_connection_set_better_path_av",
        "html": "See Also\nHandling Path Updates\nfunc nw_connection_copy_current_path(nw_connection_t) -> nw_path_t?\nAccesses the network path the connection is using.\nfunc nw_connection_set_path_changed_handler(nw_connection_t, nw_connection_path_event_handler_t?)\nSets a handler that receives network path updates.\ntypealias nw_connection_path_event_handler_t\nA handler that delivers network path updates.\nfunc nw_connection_set_viability_changed_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when data can be sent and received.\ntypealias nw_connection_boolean_event_handler_t\nA handler that receives Boolean state updates from a connection, such as viability and better path state."
    },
    {
        "title": "nw_connection_restart(_:)",
        "url": "https://developer.apple.com/documentation/network/2976684-nw_connection_restart",
        "html": "Discussion\n\nRestart a connection when it is in the waiting state and you have reason to believe the connection may succeed if it tries again. Connections that are waiting will automatically restart on network path changes.\n\nSee Also\nCreating Connections\nfunc nw_connection_create(nw_endpoint_t, nw_parameters_t) -> nw_connection_t\nInitializes a new connection to a remote endpoint.\nfunc nw_connection_set_queue(nw_connection_t, dispatch_queue_t)\nSets the queue on which all connection events are delivered.\nfunc nw_connection_start(nw_connection_t)\nStarts establishing a connection."
    },
    {
        "title": "nw_connection_group_reply(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584793-nw_connection_group_reply",
        "html": "See Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_connection_receive(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976681-nw_connection_receive",
        "html": "Parameters\nminimum_incomplete_length\n\nThe minimum length to receive from the connection, until the content is complete.\n\nmaximum_length\n\nThe maximum length to receive from the connection in a single completion.\n\ncompletion\n\nA receive completion is invoked exactly once for a call to receive. The completion indicates that the requested content has been received (in which case the content is delivered), or else an error has occurred.\n\nThe completion delivers the received content, which may be nil if the message is complete or an error occurred, the message context, a flag indicating if the message is complete, and any associated error.\n\nSee Also\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "nw_connection_send(_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976685-nw_connection_send",
        "html": "Parameters\ncontent\n\nThe data to send on the connection. May be nil if this send marks its context as complete, such as by sending NW_CONNECTION_FINAL_MESSAGE_CONTEXT as the context and marking the send complete to send a write-close.\n\ncontext\n\nThe context associated with the content, which represents a logical message to be sent on the connection. All content sent within a single context will be sent as an in-order unit, up until the point that the context is marked complete. Once a context is marked complete, it may be re-used as a new logical message. Protocols like TCP that cannot send multiple independent messages at once (serial bytestreams) will only start processing a new context once the prior context has been marked complete. Defaults to NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT.\n\nis_complete\n\nA flag indicating if the caller's sending context (logical message) is now complete. Until a context is marked complete, content sent for other contexts may not be sent immediately (if the protocol requires sending bytes serially, like TCP). For datagram protocols, like UDP, this flag indicates that the content represents a complete datagram.\n\nWhen sending using streaming protocols like TCP, this flag can be used to mark the end of a single message on the stream, of which there may be many. However, it can also indicate that the connection should send a \"write close\" (a TCP FIN) if the sending context is the final context on the connection. Specifically, to send a \"write close\", pass NW_CONNECTION_FINAL_MESSAGE_CONTEXT or NW_CONNECTION_DEFAULT_STREAM_CONTEXT for the context (or create a custom context and call nw_content_context_set_is_final(_:_:)), and mark the send as complete.\n\ncompletion\n\nA completion handler to notify the caller when content has been processed by the connection, or a marker that this data is idempotent (NW_CONNECTION_SEND_IDEMPOTENT_CONTENT) and may be sent multiple times as fast open data if nw_parameters_set_fast_open_enabled(_:_:) was called.\n\nSee Also\nSending and Receiving Data\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "nw_connection_group_send_message(_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584795-nw_connection_group_send_message",
        "html": "Parameters\ngroup\n\nThe connection group you use to send.\n\ncontent\n\nThe data to send.\n\nendpoint\n\nAn optional endpoint that specifies a member of the group that receives the data. If the endpoint is nil, the data will be sent to the entire group.\n\ncontext\n\nThe metadata that defines how the message is sent.\n\ncompletion\n\nA completion that notifies you when the connection group has processed and sent the data.\n\nSee Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_connection_copy_current_path(_:)",
        "url": "https://developer.apple.com/documentation/network/2976672-nw_connection_copy_current_path",
        "html": "See Also\nHandling Path Updates\nfunc nw_connection_set_path_changed_handler(nw_connection_t, nw_connection_path_event_handler_t?)\nSets a handler that receives network path updates.\ntypealias nw_connection_path_event_handler_t\nA handler that delivers network path updates.\nfunc nw_connection_set_viability_changed_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when data can be sent and received.\nfunc nw_connection_set_better_path_available_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when an alternative network path is preferred over the current path.\ntypealias nw_connection_boolean_event_handler_t\nA handler that receives Boolean state updates from a connection, such as viability and better path state."
    },
    {
        "title": "nw_data_transfer_report_get_received_ip_packet_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114437-nw_data_transfer_report_get_rece",
        "html": "See Also\nInspecting Packet Metrics\nfunc nw_data_transfer_report_get_sent_ip_packet_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of IP packets the connection sent."
    },
    {
        "title": "nw_advertise_descriptor_set_no_auto_rename(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976660-nw_advertise_descriptor_set_no_a",
        "html": "See Also\nAdvertising Bonjour Services\nfunc nw_advertise_descriptor_create_bonjour_service(UnsafePointer<CChar>?, UnsafePointer<CChar>, UnsafePointer<CChar>?) -> nw_advertise_descriptor_t?\nInitializes a Bonjour service to advertise.\nfunc nw_advertise_descriptor_get_no_auto_rename(nw_advertise_descriptor_t) -> Bool\nChecks whether the service prohibits automatic renaming in the event of a name conflict."
    },
    {
        "title": "nw_advertise_descriptor_set_txt_record(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976661-nw_advertise_descriptor_set_txt_",
        "html": "See Also\nConfiguring TXT Records\nfunc nw_advertise_descriptor_set_txt_record_object(nw_advertise_descriptor_t, nw_txt_record_t?)\nSets the TXT record to advertise with the service.\nfunc nw_advertise_descriptor_copy_txt_record_object(nw_advertise_descriptor_t) -> nw_txt_record_t?\nAccesses the TXT record to advertise with the service."
    },
    {
        "title": "nw_browser_set_queue(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3043506-nw_browser_set_queue",
        "html": "See Also\nBrowsing for Services\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service."
    },
    {
        "title": "nw_browser_set_state_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3043507-nw_browser_set_state_changed_han",
        "html": "See Also\nManaging Browsers\ntypealias nw_browser_state_changed_handler_t\nA handler that delivers browser state updates with associated errors.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nfunc nw_browser_cancel(nw_browser_t)\nStops browsing for services."
    },
    {
        "title": "nw_establishment_report_get_duration_milliseconds(_:)",
        "url": "https://developer.apple.com/documentation/network/3114458-nw_establishment_report_get_dura",
        "html": "See Also\nInspecting Connection Attempts\nfunc nw_establishment_report_get_previous_attempt_count(nw_establishment_report_t) -> UInt32\nChecks the number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state.\nfunc nw_establishment_report_get_attempt_started_after_milliseconds(nw_establishment_report_t) -> UInt64\nAccesses the time between the call to start and the beginning of the successful connection attempt, in milliseconds."
    },
    {
        "title": "nw_establishment_report_get_previous_attempt_count(_:)",
        "url": "https://developer.apple.com/documentation/network/3114459-nw_establishment_report_get_prev",
        "html": "See Also\nInspecting Connection Attempts\nfunc nw_establishment_report_get_duration_milliseconds(nw_establishment_report_t) -> UInt64\nChecks the total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nfunc nw_establishment_report_get_attempt_started_after_milliseconds(nw_establishment_report_t) -> UInt64\nAccesses the time between the call to start and the beginning of the successful connection attempt, in milliseconds."
    },
    {
        "title": "nw_ethernet_channel_set_receive_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3181995-nw_ethernet_channel_set_receive_",
        "html": "Discussion\n\nThe receive handler only needs to be set once, and will be invoked for each received Ethernet frame.\n\nSee Also\nSending and Receiving Ethernet Frames\nfunc nw_ethernet_channel_send(nw_ethernet_channel_t, dispatch_data_t, UInt16, UnsafeMutablePointer<UInt8>, nw_ethernet_channel_send_completion_t)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\ntypealias nw_ethernet_channel_send_completion_t\nA handler that indicates when an Ethernet frame has been sent, or if an error was encountered.\ntypealias nw_ethernet_channel_receive_handler_t\nA handler that delivers inbound Ethernet frames.\ntypealias nw_ethernet_address_t\nA 48-bit Ethernet address."
    },
    {
        "title": "nw_establishment_report_enumerate_resolutions(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114456-nw_establishment_report_enumerat",
        "html": "See Also\nInspecting Resolution\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_establishment_report_enumerate_resolution_reports(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3548018-nw_establishment_report_enumerat",
        "html": "See Also\nInspecting Resolution\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment."
    },
    {
        "title": "nw_establishment_report_get_attempt_started_after_milliseconds(_:)",
        "url": "https://developer.apple.com/documentation/network/3114457-nw_establishment_report_get_atte",
        "html": "See Also\nInspecting Connection Attempts\nfunc nw_establishment_report_get_duration_milliseconds(nw_establishment_report_t) -> UInt64\nChecks the total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nfunc nw_establishment_report_get_previous_attempt_count(nw_establishment_report_t) -> UInt32\nChecks the number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state."
    },
    {
        "title": "nw_ethernet_channel_send(_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3181993-nw_ethernet_channel_send",
        "html": "See Also\nSending and Receiving Ethernet Frames\ntypealias nw_ethernet_channel_send_completion_t\nA handler that indicates when an Ethernet frame has been sent, or if an error was encountered.\nfunc nw_ethernet_channel_set_receive_handler(nw_ethernet_channel_t, nw_ethernet_channel_receive_handler_t?)\nSets a handler to receive inbound Ethernet frames.\ntypealias nw_ethernet_channel_receive_handler_t\nA handler that delivers inbound Ethernet frames.\ntypealias nw_ethernet_address_t\nA 48-bit Ethernet address."
    },
    {
        "title": "nw_ethernet_channel_set_state_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3181996-nw_ethernet_channel_set_state_ch",
        "html": "See Also\nHandling State Updates\ntypealias nw_ethernet_channel_state_changed_handler_t\nA handler that delivers Ethernet channel state updates with associated errors.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames."
    },
    {
        "title": "nw_ethernet_channel_set_queue(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3181994-nw_ethernet_channel_set_queue",
        "html": "See Also\nManaging Ethernet Channels\nfunc nw_ethernet_channel_create(UInt16, nw_interface_t) -> nw_ethernet_channel_t\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc nw_ethernet_channel_start(nw_ethernet_channel_t)\nStarts the process of registering the channel.\nfunc nw_ethernet_channel_cancel(nw_ethernet_channel_t)\nUnregisters the channel from the interface."
    },
    {
        "title": "nw_endpoint_get_url(_:)",
        "url": "https://developer.apple.com/documentation/network/3141916-nw_endpoint_get_url",
        "html": "See Also\nURL Endpoints\nfunc nw_endpoint_create_url(UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a URL string."
    },
    {
        "title": "nw_error_copy_cf_error(_:)",
        "url": "https://developer.apple.com/documentation/network/2976738-nw_error_copy_cf_error",
        "html": "See Also\nInspecting Errors\nfunc nw_error_get_error_domain(nw_error_t) -> nw_error_domain_t\nAccesses the domain of the network error.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nfunc nw_error_get_error_code(nw_error_t) -> Int32\nAccesses the specific code of the network error."
    },
    {
        "title": "nw_error_get_error_code(_:)",
        "url": "https://developer.apple.com/documentation/network/2976744-nw_error_get_error_code",
        "html": "See Also\nInspecting Errors\nfunc nw_error_get_error_domain(nw_error_t) -> nw_error_domain_t\nAccesses the domain of the network error.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nfunc nw_error_copy_cf_error(nw_error_t) -> Unmanaged<CFError>\nCopies out a CFError that represents a network error."
    },
    {
        "title": "nw_establishment_report_copy_proxy_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/3114454-nw_establishment_report_copy_pro",
        "html": "See Also\nChecking for Proxies\nfunc nw_establishment_report_get_proxy_configured(nw_establishment_report_t) -> Bool\nChecks whether a proxy was configured on the connection.\nfunc nw_establishment_report_get_used_proxy(nw_establishment_report_t) -> Bool\nChecks whether the connection used a proxy."
    },
    {
        "title": "nw_establishment_report_get_proxy_configured(_:)",
        "url": "https://developer.apple.com/documentation/network/3114460-nw_establishment_report_get_prox",
        "html": "See Also\nChecking for Proxies\nfunc nw_establishment_report_get_used_proxy(nw_establishment_report_t) -> Bool\nChecks whether the connection used a proxy.\nfunc nw_establishment_report_copy_proxy_endpoint(nw_establishment_report_t) -> nw_endpoint_t?\nAccesses the endpoint of the proxy the connection used."
    },
    {
        "title": "nw_error_get_error_domain(_:)",
        "url": "https://developer.apple.com/documentation/network/2976745-nw_error_get_error_domain",
        "html": "See Also\nInspecting Errors\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nfunc nw_error_get_error_code(nw_error_t) -> Int32\nAccesses the specific code of the network error.\nfunc nw_error_copy_cf_error(nw_error_t) -> Unmanaged<CFError>\nCopies out a CFError that represents a network error."
    },
    {
        "title": "nw_endpoint_get_type(_:)",
        "url": "https://developer.apple.com/documentation/network/2976727-nw_endpoint_get_type",
        "html": "See Also\nEndpoint Types\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service."
    },
    {
        "title": "nw_endpoint_create_url(_:)",
        "url": "https://developer.apple.com/documentation/network/3141915-nw_endpoint_create_url",
        "html": "See Also\nURL Endpoints\nfunc nw_endpoint_get_url(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the URL string stored in an endpoint."
    },
    {
        "title": "nw_endpoint_get_bonjour_service_type(_:)",
        "url": "https://developer.apple.com/documentation/network/2976724-nw_endpoint_get_bonjour_service_",
        "html": "See Also\nBonjour Service Endpoints\nfunc nw_endpoint_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a Bonjour service name, type, and domain.\nfunc nw_endpoint_get_bonjour_service_name(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service name stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_domain(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service domain stored in an endpoint."
    },
    {
        "title": "nw_endpoint_get_bonjour_service_name(_:)",
        "url": "https://developer.apple.com/documentation/network/2976723-nw_endpoint_get_bonjour_service_",
        "html": "See Also\nBonjour Service Endpoints\nfunc nw_endpoint_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a Bonjour service name, type, and domain.\nfunc nw_endpoint_get_bonjour_service_type(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_domain(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service domain stored in an endpoint."
    },
    {
        "title": "nw_endpoint_get_address(_:)",
        "url": "https://developer.apple.com/documentation/network/2976721-nw_endpoint_get_address",
        "html": "See Also\nAddress Endpoints\nfunc nw_endpoint_create_address(UnsafePointer<sockaddr>) -> nw_endpoint_t\nCreates a network endpoint with an address structure.\nfunc nw_endpoint_copy_address_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the address of an endpoint as a string.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string."
    },
    {
        "title": "nw_endpoint_get_bonjour_service_domain(_:)",
        "url": "https://developer.apple.com/documentation/network/2976722-nw_endpoint_get_bonjour_service_",
        "html": "See Also\nBonjour Service Endpoints\nfunc nw_endpoint_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a Bonjour service name, type, and domain.\nfunc nw_endpoint_get_bonjour_service_name(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service name stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_type(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type stored in an endpoint."
    },
    {
        "title": "nw_data_transfer_report_get_sent_transport_byte_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114443-nw_data_transfer_report_get_sent",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_data_transfer_report_get_received_transport_byte_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114438-nw_data_transfer_report_get_rece",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_endpoint_copy_port_string(_:)",
        "url": "https://developer.apple.com/documentation/network/2976717-nw_endpoint_copy_port_string",
        "html": "Discussion\n\nThis function allocates a new string. You should free the returned buffer when done using the string.\n\nSee Also\nAddress Endpoints\nfunc nw_endpoint_create_address(UnsafePointer<sockaddr>) -> nw_endpoint_t\nCreates a network endpoint with an address structure.\nfunc nw_endpoint_get_address(nw_endpoint_t) -> UnsafePointer<sockaddr>\nAccesses the address structure stored in an address endpoint.\nfunc nw_endpoint_copy_address_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the address of an endpoint as a string."
    },
    {
        "title": "nw_data_transfer_report_get_state(_:)",
        "url": "https://developer.apple.com/documentation/network/3114445-nw_data_transfer_report_get_stat",
        "html": "See Also\nCollecting Reports\nfunc nw_data_transfer_report_collect(nw_data_transfer_report_t, dispatch_queue_t, nw_data_transfer_report_collect_block_t)\nStops an outstanding data transfer report and calculates the results.\ntypealias nw_data_transfer_report_collect_block_t\nA block that is delivered when a data transfer report is fully collected.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet."
    },
    {
        "title": "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114448-nw_data_transfer_report_get_tran",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_data_transfer_report_get_received_transport_duplicate_byte_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114439-nw_data_transfer_report_get_rece",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114446-nw_data_transfer_report_get_tran",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114444-nw_data_transfer_report_get_sent",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured."
    },
    {
        "title": "nw_data_transfer_report_get_sent_application_byte_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114441-nw_data_transfer_report_get_sent",
        "html": "See Also\nInspecting Application Metrics\nfunc nw_data_transfer_report_get_received_application_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the connection delivered."
    },
    {
        "title": "nw_data_transfer_report_get_sent_ip_packet_count(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114442-nw_data_transfer_report_get_sent",
        "html": "See Also\nInspecting Packet Metrics\nfunc nw_data_transfer_report_get_received_ip_packet_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of IP packets the connection received."
    },
    {
        "title": "nw_connection_group_create(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584790-nw_connection_group_create",
        "html": "See Also\nEstablishing Group Connectivity\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages."
    },
    {
        "title": "nw_data_transfer_report_get_transport_rtt_variance(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114447-nw_data_transfer_report_get_tran",
        "html": "See Also\nInspecting Transport Metrics\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds."
    },
    {
        "title": "nw_connection_group_copy_remote_endpoint_for_message(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584789-nw_connection_group_copy_remote_",
        "html": "See Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_connection_copy_protocol_metadata(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976676-nw_connection_copy_protocol_meta",
        "html": "See Also\nCopying Connection State\nfunc nw_connection_copy_endpoint(nw_connection_t) -> nw_endpoint_t\nAccesses the endpoint with which the connection was created.\nfunc nw_connection_copy_parameters(nw_connection_t) -> nw_parameters_t\nAccesses the parameters with which the connection was created.\nfunc nw_connection_copy_description(nw_connection_t) -> UnsafeMutablePointer<CChar>\nCopies the description of the connection as a string."
    },
    {
        "title": "nw_connection_group_copy_descriptor(_:)",
        "url": "https://developer.apple.com/documentation/network/3584785-nw_connection_group_copy_descrip",
        "html": "See Also\nInspecting Groups\nfunc nw_connection_group_copy_parameters(nw_connection_group_t) -> nw_parameters_t\nAccesses the parameters with which you initialize the connection group."
    },
    {
        "title": "nw_connection_force_cancel(_:)",
        "url": "https://developer.apple.com/documentation/network/2976678-nw_connection_force_cancel",
        "html": "See Also\nCanceling Connections\nfunc nw_connection_cancel(nw_connection_t)\nCancels the connection and gracefully disconnects any established network protocols.\nfunc nw_connection_cancel_current_endpoint(nw_connection_t)\nCauses the current endpoint to be rejected, allowing the connection to try another resolved address."
    },
    {
        "title": "nw_content_context_copy_protocol_metadata(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976704-nw_content_context_copy_protocol",
        "html": "See Also\nInspecting Receive Contexts\nfunc nw_content_context_get_is_final(nw_content_context_t) -> Bool\nChecks whether this context represents the final message being received.\nfunc nw_content_context_foreach_protocol_metadata(nw_content_context_t, (nw_protocol_definition_t, nw_protocol_metadata_t) -> Void)\nIterates through all protocol metadata associated with the message context."
    },
    {
        "title": "nw_content_context_set_is_final(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2998455-nw_content_context_set_is_final",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_content_context_set_metadata_for_protocol(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976712-nw_content_context_set_metadata_",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_content_context_set_antecedent(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976710-nw_content_context_set_anteceden",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_content_context_get_expiration_milliseconds(_:)",
        "url": "https://developer.apple.com/documentation/network/2976707-nw_content_context_get_expiratio",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_content_context_get_is_final(_:)",
        "url": "https://developer.apple.com/documentation/network/2998454-nw_content_context_get_is_final",
        "html": "See Also\nInspecting Receive Contexts\nfunc nw_content_context_copy_protocol_metadata(nw_content_context_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetreives the metadata associated with a specific protocol.\nfunc nw_content_context_foreach_protocol_metadata(nw_content_context_t, (nw_protocol_definition_t, nw_protocol_metadata_t) -> Void)\nIterates through all protocol metadata associated with the message context."
    },
    {
        "title": "nw_content_context_foreach_protocol_metadata(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976706-nw_content_context_foreach_proto",
        "html": "See Also\nInspecting Receive Contexts\nfunc nw_content_context_get_is_final(nw_content_context_t) -> Bool\nChecks whether this context represents the final message being received.\nfunc nw_content_context_copy_protocol_metadata(nw_content_context_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetreives the metadata associated with a specific protocol."
    },
    {
        "title": "nw_connection_start(_:)",
        "url": "https://developer.apple.com/documentation/network/2976692-nw_connection_start",
        "html": "See Also\nCreating Connections\nfunc nw_connection_create(nw_endpoint_t, nw_parameters_t) -> nw_connection_t\nInitializes a new connection to a remote endpoint.\nfunc nw_connection_set_queue(nw_connection_t, dispatch_queue_t)\nSets the queue on which all connection events are delivered.\nfunc nw_connection_restart(nw_connection_t)\nRestarts a connection that is in the waiting state."
    },
    {
        "title": "nw_content_context_copy_antecedent(_:)",
        "url": "https://developer.apple.com/documentation/network/2976703-nw_content_context_copy_antecede",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_content_context_get_relative_priority(_:)",
        "url": "https://developer.apple.com/documentation/network/2976709-nw_content_context_get_relative_",
        "html": "Discussion\n\nRelative priority of contexts only affects ordering when there is a queue of messages to be sent. The priority is a double ranging from 0.0 to 1.0, where default messages are set to 0.5.\n\nSee Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_connection_batch(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976668-nw_connection_batch",
        "html": "See Also\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "nw_advertise_descriptor_get_no_auto_rename(_:)",
        "url": "https://developer.apple.com/documentation/network/2976659-nw_advertise_descriptor_get_no_a",
        "html": "See Also\nAdvertising Bonjour Services\nfunc nw_advertise_descriptor_create_bonjour_service(UnsafePointer<CChar>?, UnsafePointer<CChar>, UnsafePointer<CChar>?) -> nw_advertise_descriptor_t?\nInitializes a Bonjour service to advertise.\nfunc nw_advertise_descriptor_set_no_auto_rename(nw_advertise_descriptor_t, Bool)\nSets a Boolean to indicate whether the service prohibits automatic renaming in the event of a name conflict."
    },
    {
        "title": "nw_data_transfer_report_get_path_count(_:)",
        "url": "https://developer.apple.com/documentation/network/3114435-nw_data_transfer_report_get_path",
        "html": "Discussion\n\nUse the path index to look up individual values, or pass NW_ALL_PATHS to get an aggregate view.\n\nSee Also\nIdentifying Paths\nfunc nw_data_transfer_report_get_duration_milliseconds(nw_data_transfer_report_t) -> UInt64\nChecks the duration of the data transfer report, from when it was started to when it was collected.\nfunc nw_data_transfer_report_copy_path_interface(nw_data_transfer_report_t, UInt32) -> nw_interface_t\nAccesses the network interface the path used."
    },
    {
        "title": "nw_browse_descriptor_set_include_txt_record(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114405-nw_browse_descriptor_set_include",
        "html": "See Also\nCreating Browse Descriptors\nfunc nw_browse_descriptor_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>?) -> nw_browse_descriptor_t\nInitializes a service descriptor used to discover a Bonjour service."
    },
    {
        "title": "nw_connection_cancel(_:)",
        "url": "https://developer.apple.com/documentation/network/2976670-nw_connection_cancel",
        "html": "See Also\nCanceling Connections\nfunc nw_connection_force_cancel(nw_connection_t)\nCancels the connection and immediately disconnects any established network protocols.\nfunc nw_connection_cancel_current_endpoint(nw_connection_t)\nCauses the current endpoint to be rejected, allowing the connection to try another resolved address."
    },
    {
        "title": "nw_browse_descriptor_get_bonjour_service_domain(_:)",
        "url": "https://developer.apple.com/documentation/network/3043493-nw_browse_descriptor_get_bonjour",
        "html": "See Also\nInspecting Browse Descriptors\nfunc nw_browse_descriptor_get_bonjour_service_type(nw_browse_descriptor_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type set on a browse descriptor.\nfunc nw_browse_descriptor_get_include_txt_record(nw_browse_descriptor_t) -> Bool\nChecks if the browse descriptor requires including associated TXT records with all results."
    },
    {
        "title": "nw_advertise_descriptor_set_txt_record_object(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114403-nw_advertise_descriptor_set_txt_",
        "html": "See Also\nConfiguring TXT Records\nfunc nw_advertise_descriptor_set_txt_record(nw_advertise_descriptor_t, UnsafeRawPointer?, Int)\nSets the TXT record as a raw buffer to advertise with the service.\nfunc nw_advertise_descriptor_copy_txt_record_object(nw_advertise_descriptor_t) -> nw_txt_record_t?\nAccesses the TXT record to advertise with the service."
    },
    {
        "title": "nw_browse_result_copy_txt_record_object(_:)",
        "url": "https://developer.apple.com/documentation/network/3114417-nw_browse_result_copy_txt_record",
        "html": "See Also\nHandling TXT Records\ntypealias nw_txt_record_t\nA dictionary representing a TXT record in a DNS packet."
    },
    {
        "title": "nw_connection_group_extract_connection_for_message(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3600283-nw_connection_group_extract_conn",
        "html": "See Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_browse_descriptor_create_bonjour_service(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3043492-nw_browse_descriptor_create_bonj",
        "html": "See Also\nCreating Browse Descriptors\nfunc nw_browse_descriptor_set_include_txt_record(nw_browse_descriptor_t, Bool)\nRequires including associated TXT records with all results generated for this service descriptor."
    },
    {
        "title": "nw_browser_create(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3043500-nw_browser_create",
        "html": "See Also\nBrowsing for Services\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service."
    },
    {
        "title": "nw_browse_result_enumerate_interfaces(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114419-nw_browse_result_enumerate_inter",
        "html": "See Also\nEvaluating Browser Results\nfunc nw_browse_result_copy_endpoint(nw_browse_result_t) -> nw_endpoint_t\nThe discovered service endpoint.\ntypealias nw_browse_result_enumerate_interface_t\nA handler that enumerates the interfaces associated with a discovered service.\nfunc nw_browse_result_get_interfaces_count(nw_browse_result_t) -> Int\nAccesses the number of interfaces associated with a discovered service."
    },
    {
        "title": "nw_browser_start(_:)",
        "url": "https://developer.apple.com/documentation/network/3043508-nw_browser_start",
        "html": "See Also\nBrowsing for Services\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service."
    },
    {
        "title": "NW_FRAMER_WAKEUP_TIME_FOREVER",
        "url": "https://developer.apple.com/documentation/network/nw_framer_wakeup_time_forever",
        "html": "See Also\nHandling Asynchronous Events\nfunc nw_framer_schedule_wakeup(nw_framer_t, UInt64)\nRequests that the nw_framer_wakeup_handler_t be called on your protocol at a specific time in the future.\nfunc nw_framer_set_wakeup_handler(nw_framer_t, nw_framer_wakeup_handler_t)\nSets a handler to receive scheduled wakeup events.\ntypealias nw_framer_wakeup_handler_t\nA handler that delivers a scheduled wakeup event.\nfunc nw_framer_async(nw_framer_t, nw_framer_block_t)\nRequests that a block be executed on the connection's internal scheduling context.\ntypealias nw_framer_block_t\nA block to be invoked asynchronously on your framer protocol's scheduling context."
    },
    {
        "title": "nw_content_context_set_relative_priority(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976713-nw_content_context_set_relative_",
        "html": "Discussion\n\nRelative priority of contexts only affects ordering when there is a queue of messages to be sent. The priority is a double ranging from 0.0 to 1.0, where default messages are set to 0.5.\n\nSee Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_browser_set_browse_results_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114425-nw_browser_set_browse_results_ch",
        "html": "See Also\nBrowsing for Services\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service."
    },
    {
        "title": "NW_FRAMER_CREATE_FLAGS_DEFAULT",
        "url": "https://developer.apple.com/documentation/network/nw_framer_create_flags_default",
        "html": "See Also\nAdding Framers to Connections\nfunc nw_framer_create_definition(UnsafePointer<CChar>, UInt32, nw_framer_start_handler_t) -> nw_protocol_definition_t\nInitializes a new protocol definition based on your protocol implementation.\ntypealias nw_framer_start_handler_t\nA handler that represents the entry point into your custom protocol.\ntypealias nw_framer_t\nAn object that represents a single instance of your custom protocol running in a connection.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nfunc nw_framer_create_options(nw_protocol_definition_t) -> nw_protocol_options_t\nInitializes a set of protocol options with a custom framer definition."
    },
    {
        "title": "nw_data_transfer_report_collect(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114431-nw_data_transfer_report_collect",
        "html": "See Also\nCollecting Reports\ntypealias nw_data_transfer_report_collect_block_t\nA block that is delivered when a data transfer report is fully collected.\nfunc nw_data_transfer_report_get_state(nw_data_transfer_report_t) -> nw_data_transfer_report_state_t\nChecks whether a data transfer report is collected.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet."
    },
    {
        "title": "nw_data_transfer_report_copy_path_interface(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114433-nw_data_transfer_report_copy_pat",
        "html": "See Also\nIdentifying Paths\nfunc nw_data_transfer_report_get_path_count(nw_data_transfer_report_t) -> UInt32\nChecks the number of valid paths in the report.\nfunc nw_data_transfer_report_get_duration_milliseconds(nw_data_transfer_report_t) -> UInt64\nChecks the duration of the data transfer report, from when it was started to when it was collected."
    },
    {
        "title": "nw_connection_access_establishment_report(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114429-nw_connection_access_establishme",
        "html": "See Also\nCollecting Connection Metrics\ntypealias nw_establishment_report_t\nA report that provides metrics about how a connection was established.\ntypealias nw_establishment_report_access_block_t\nA block that delivers a connection's establishment report when it's in the ready state.\ntypealias nw_data_transfer_report_t\nA report that provides metrics about data being sent and received on a connection.\nfunc nw_connection_create_new_data_transfer_report(nw_connection_t) -> nw_data_transfer_report_t\nBegins a new data transfer report, which can later be collected."
    },
    {
        "title": "nw_browser_copy_browse_descriptor(_:)",
        "url": "https://developer.apple.com/documentation/network/3114424-nw_browser_copy_browse_descripto",
        "html": "See Also\nInspecting Browsers\nfunc nw_browser_copy_parameters(nw_browser_t) -> nw_parameters_t\nAccesses the parameters with which the browser was created."
    },
    {
        "title": "nw_content_context_set_expiration_milliseconds(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976711-nw_content_context_set_expiratio",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context."
    },
    {
        "title": "nw_content_context_get_identifier(_:)",
        "url": "https://developer.apple.com/documentation/network/2976708-nw_content_context_get_identifie",
        "html": "See Also\nCreating Custom Send Contexts\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent."
    },
    {
        "title": "nw_connection_set_queue(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976689-nw_connection_set_queue",
        "html": "See Also\nCreating Connections\nfunc nw_connection_create(nw_endpoint_t, nw_parameters_t) -> nw_connection_t\nInitializes a new connection to a remote endpoint.\nfunc nw_connection_start(nw_connection_t)\nStarts establishing a connection.\nfunc nw_connection_restart(nw_connection_t)\nRestarts a connection that is in the waiting state."
    },
    {
        "title": "nw_connection_set_path_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976688-nw_connection_set_path_changed_h",
        "html": "See Also\nHandling Path Updates\nfunc nw_connection_copy_current_path(nw_connection_t) -> nw_path_t?\nAccesses the network path the connection is using.\ntypealias nw_connection_path_event_handler_t\nA handler that delivers network path updates.\nfunc nw_connection_set_viability_changed_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when data can be sent and received.\nfunc nw_connection_set_better_path_available_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when an alternative network path is preferred over the current path.\ntypealias nw_connection_boolean_event_handler_t\nA handler that receives Boolean state updates from a connection, such as viability and better path state."
    },
    {
        "title": "nw_connection_set_state_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976690-nw_connection_set_state_changed_",
        "html": "See Also\nHandling State Updates\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\ntypealias nw_connection_state_changed_handler_t\nA handler that delivers connection state updates with associated errors."
    },
    {
        "title": "nw_connection_group_start(_:)",
        "url": "https://developer.apple.com/documentation/network/3584800-nw_connection_group_start",
        "html": "See Also\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events."
    },
    {
        "title": "nw_connection_group_set_state_changed_handler(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584799-nw_connection_group_set_state_ch",
        "html": "See Also\nManaging Groups\ntypealias nw_connection_group_state_changed_handler_t\nA handler that receives connection group state updates.\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nfunc nw_connection_group_cancel(nw_connection_group_t)\nCancels the connection group object and leaves the network group."
    },
    {
        "title": "nw_connection_group_set_receive_handler(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/3600285-nw_connection_group_set_receive_",
        "html": "See Also\nSending and Receiving Group Messages\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_connection_group_set_queue(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584798-nw_connection_group_set_queue",
        "html": "See Also\nEstablishing Group Connectivity\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages."
    },
    {
        "title": "NW_LISTENER_INFINITE_CONNECTION_LIMIT",
        "url": "https://developer.apple.com/documentation/network/nw_listener_infinite_connection_limit",
        "html": "See Also\nReceiving Connections\nfunc nw_listener_set_new_connection_handler(nw_listener_t, nw_listener_new_connection_handler_t?)\nSets a handler that receives inbound connections.\ntypealias nw_listener_new_connection_handler_t\nA handler that delivers inbound connections.\nfunc nw_listener_set_new_connection_limit(nw_listener_t, UInt32)\nResets the number of inbound connections to deliver before rejecting connections.\nfunc nw_listener_get_new_connection_limit(nw_listener_t) -> UInt32\nChecks the remaining number of inbound connections to deliver before rejecting connections."
    },
    {
        "title": "nw_connection_copy_description(_:)",
        "url": "https://developer.apple.com/documentation/network/2976673-nw_connection_copy_description",
        "html": "Discussion\n\nThis function allocates a new string. You should free the returned buffer when done using the string.\n\nSee Also\nCopying Connection State\nfunc nw_connection_copy_protocol_metadata(nw_connection_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetrieves the connection-wide metadata for a specific protocol.\nfunc nw_connection_copy_endpoint(nw_connection_t) -> nw_endpoint_t\nAccesses the endpoint with which the connection was created.\nfunc nw_connection_copy_parameters(nw_connection_t) -> nw_parameters_t\nAccesses the parameters with which the connection was created."
    },
    {
        "title": "nw_browse_descriptor_get_bonjour_service_type(_:)",
        "url": "https://developer.apple.com/documentation/network/3043494-nw_browse_descriptor_get_bonjour",
        "html": "See Also\nInspecting Browse Descriptors\nfunc nw_browse_descriptor_get_bonjour_service_domain(nw_browse_descriptor_t) -> UnsafePointer<CChar>?\nAccesses the Bonjour service domain set on a browse descriptor.\nfunc nw_browse_descriptor_get_include_txt_record(nw_browse_descriptor_t) -> Bool\nChecks if the browse descriptor requires including associated TXT records with all results."
    },
    {
        "title": "nw_browse_result_copy_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/3114416-nw_browse_result_copy_endpoint",
        "html": "See Also\nEvaluating Browser Results\nfunc nw_browse_result_enumerate_interfaces(nw_browse_result_t, (nw_interface_t) -> Bool)\nEnumerates the list of interfaces on which the service was discovered.\ntypealias nw_browse_result_enumerate_interface_t\nA handler that enumerates the interfaces associated with a discovered service.\nfunc nw_browse_result_get_interfaces_count(nw_browse_result_t) -> Int\nAccesses the number of interfaces associated with a discovered service."
    },
    {
        "title": "nw_connection_create_new_data_transfer_report(_:)",
        "url": "https://developer.apple.com/documentation/network/3114430-nw_connection_create_new_data_tr",
        "html": "See Also\nCollecting Connection Metrics\ntypealias nw_establishment_report_t\nA report that provides metrics about how a connection was established.\nfunc nw_connection_access_establishment_report(nw_connection_t, dispatch_queue_t, nw_establishment_report_access_block_t)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\ntypealias nw_establishment_report_access_block_t\nA block that delivers a connection's establishment report when it's in the ready state.\ntypealias nw_data_transfer_report_t\nA report that provides metrics about data being sent and received on a connection."
    },
    {
        "title": "nw_connection_group_copy_path_for_message(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584788-nw_connection_group_copy_path_fo",
        "html": "See Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_connection_get_maximum_datagram_size(_:)",
        "url": "https://developer.apple.com/documentation/network/2976679-nw_connection_get_maximum_datagr",
        "html": "See Also\nSending and Receiving Data\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance."
    },
    {
        "title": "nw_connection_group_copy_local_endpoint_for_message(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3584786-nw_connection_group_copy_local_e",
        "html": "See Also\nSending and Receiving Group Messages\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent."
    },
    {
        "title": "nw_connection_create(_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976677-nw_connection_create",
        "html": "See Also\nCreating Connections\nfunc nw_connection_set_queue(nw_connection_t, dispatch_queue_t)\nSets the queue on which all connection events are delivered.\nfunc nw_connection_start(nw_connection_t)\nStarts establishing a connection.\nfunc nw_connection_restart(nw_connection_t)\nRestarts a connection that is in the waiting state."
    },
    {
        "title": "nw_connection_group_cancel(_:)",
        "url": "https://developer.apple.com/documentation/network/3584782-nw_connection_group_cancel",
        "html": "See Also\nManaging Groups\nfunc nw_connection_group_set_state_changed_handler(nw_connection_group_t, nw_connection_group_state_changed_handler_t?)\nSets a handler that receives connection group state updates.\ntypealias nw_connection_group_state_changed_handler_t\nA handler that receives connection group state updates.\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages."
    },
    {
        "title": "nw_connection_group_copy_parameters(_:)",
        "url": "https://developer.apple.com/documentation/network/3584787-nw_connection_group_copy_paramet",
        "html": "See Also\nInspecting Groups\nfunc nw_connection_group_copy_descriptor(nw_connection_group_t) -> nw_group_descriptor_t\nAccesses the descriptor of the group you use to initialize the connection group."
    },
    {
        "title": "nw_connection_copy_parameters(_:)",
        "url": "https://developer.apple.com/documentation/network/2976675-nw_connection_copy_parameters",
        "html": "See Also\nCopying Connection State\nfunc nw_connection_copy_protocol_metadata(nw_connection_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetrieves the connection-wide metadata for a specific protocol.\nfunc nw_connection_copy_endpoint(nw_connection_t) -> nw_endpoint_t\nAccesses the endpoint with which the connection was created.\nfunc nw_connection_copy_description(nw_connection_t) -> UnsafeMutablePointer<CChar>\nCopies the description of the connection as a string."
    },
    {
        "title": "nw_connection_copy_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/2976674-nw_connection_copy_endpoint",
        "html": "See Also\nCopying Connection State\nfunc nw_connection_copy_protocol_metadata(nw_connection_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetrieves the connection-wide metadata for a specific protocol.\nfunc nw_connection_copy_parameters(nw_connection_t) -> nw_parameters_t\nAccesses the parameters with which the connection was created.\nfunc nw_connection_copy_description(nw_connection_t) -> UnsafeMutablePointer<CChar>\nCopies the description of the connection as a string."
    },
    {
        "title": "OS_nw_resolution_report",
        "url": "https://developer.apple.com/documentation/network/os_nw_resolution_report",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "nw_browse_descriptor_get_include_txt_record(_:)",
        "url": "https://developer.apple.com/documentation/network/3114404-nw_browse_descriptor_get_include",
        "html": "See Also\nInspecting Browse Descriptors\nfunc nw_browse_descriptor_get_bonjour_service_type(nw_browse_descriptor_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type set on a browse descriptor.\nfunc nw_browse_descriptor_get_bonjour_service_domain(nw_browse_descriptor_t) -> UnsafePointer<CChar>?\nAccesses the Bonjour service domain set on a browse descriptor."
    },
    {
        "title": "OS_nw_connection_group",
        "url": "https://developer.apple.com/documentation/network/os_nw_connection_group",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "nw_advertise_descriptor_create_bonjour_service(_:_:_:)",
        "url": "https://developer.apple.com/documentation/network/2976658-nw_advertise_descriptor_create_b",
        "html": "Discussion\n\nAdvertised services are primarily defined by their types. If you do not specify a service name, the device name will be chosen. You should not specify a Bonjour domain unless you know you need to advertise only on a particular domain.\n\nSee Also\nAdvertising Bonjour Services\nfunc nw_advertise_descriptor_set_no_auto_rename(nw_advertise_descriptor_t, Bool)\nSets a Boolean to indicate whether the service prohibits automatic renaming in the event of a name conflict.\nfunc nw_advertise_descriptor_get_no_auto_rename(nw_advertise_descriptor_t) -> Bool\nChecks whether the service prohibits automatic renaming in the event of a name conflict."
    },
    {
        "title": "nw_connection_cancel_current_endpoint(_:)",
        "url": "https://developer.apple.com/documentation/network/2976671-nw_connection_cancel_current_end",
        "html": "Discussion\n\nProtocols that do not have handshakes, such as UDP, do not allow connections to validate connectivity on their own. Cancelling an endpoint allows you to indicate that a certain endpoint should be rejected due to a lack of valid response. If other addresses were resolved for the remote endpoint, those will be attempted next.\n\nSee Also\nCanceling Connections\nfunc nw_connection_cancel(nw_connection_t)\nCancels the connection and gracefully disconnects any established network protocols.\nfunc nw_connection_force_cancel(nw_connection_t)\nCancels the connection and immediately disconnects any established network protocols."
    },
    {
        "title": "nw_advertise_descriptor_copy_txt_record_object(_:)",
        "url": "https://developer.apple.com/documentation/network/3114402-nw_advertise_descriptor_copy_txt",
        "html": "See Also\nConfiguring TXT Records\nfunc nw_advertise_descriptor_set_txt_record(nw_advertise_descriptor_t, UnsafeRawPointer?, Int)\nSets the TXT record as a raw buffer to advertise with the service.\nfunc nw_advertise_descriptor_set_txt_record_object(nw_advertise_descriptor_t, nw_txt_record_t?)\nSets the TXT record to advertise with the service."
    },
    {
        "title": "OS_nw_data_transfer_report",
        "url": "https://developer.apple.com/documentation/network/os_nw_data_transfer_report",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "members",
        "url": "https://developer.apple.com/documentation/network/nwmultiplexgroup/3749203-members",
        "html": "Relationships\nFrom Protocol\nNWGroupDescriptor"
    },
    {
        "title": "OS_nw_resolver_config",
        "url": "https://developer.apple.com/documentation/network/os_nw_resolver_config",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_relay_hop",
        "url": "https://developer.apple.com/documentation/network/os_nw_relay_hop",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "Recording a Wi-Fi Packet Trace",
        "url": "https://developer.apple.com/documentation/network/recording_a_packet_trace/recording_a_wi-fi_packet_trace",
        "html": "Overview\n\nWhen working with Wi-Fi, your best option for recording a packet trace depends on whether you\u2019re interested in the network traffic itself, or in the details of how the Wi-Fi network manages traffic.\n\nRecord a High-Level Packet Trace of Wi-Fi Traffic\n\nIf you\u2019re primarily interested in the traffic going over the Wi-Fi \u2014 that is, you would like to ignore all the low-level details of Wi-Fi and treat the Wi-Fi network like an Ethernet network without all those pesky wires \u2014 use one of the following high-level approaches:\n\nIf possible, run the packet trace on one of the machines involved in the communication \u2014 including using RVI to record an iOS packet trace. That\u2019s the easiest solution. See Recording a Packet Trace for instructions.\n\nIf your Wi-Fi access point supports bridge mode (notably, all Apple base stations do), you can bridge the Wi-Fi network on to an Ethernet network and then use standard Ethernet techniques to capture a packet trace. You won\u2019t be able to see Wi-Fi to Wi-Fi traffic, but in many situations that\u2019s not a problem.\n\nIf you enable Internet Sharing on your Mac, and have your Wi-Fi clients join the shared network, you can run your packet trace program on the Mac and see all the Wi-Fi traffic. If you target the Mac\u2019s Wi-Fi interface, you will see all traffic, including Wi-Fi to Wi-Fi traffic. If you target the Mac\u2019s Ethernet interface, you will only see traffic entering or leaving the Wi-Fi network.\n\nRecord Low-Level Details of Wi-Fi Traffic Management\n\nIf you are interested in the low-level details of how the Wi-Fi network manages traffic, record a low-level Wi-Fi packet trace. To do this:\n\nChoose a Mac on which to record your trace. That Mac cannot use the Wi-Fi interface for normal network traffic while recording the trace.\n\nConfigure your access point to use a fixed channel. When recording a packet trace, you must specify the channel to record, and having the access point choose its channel automatically makes that harder.\n\nEither temporarily turn off the Wi-Fi password on your network or use a separate test network that has no password. If the Wi-Fi network has a password, Wi-Fi encryption makes it harder to examine the trace.\n\nOpen the Wireless Diagnostics app (you can find this in /System/Library/CoreServices/Applications/).\n\nChoose Window > Sniffer.\n\nIn the Sniffer window, select the channel number and width you want to record and click Start.\n\nClick Stop when you\u2019re done.\n\nIn the Finder, navigate to /var/tmp/ and look for the resulting .pcap file.\n\nSee Also\nWorking with Packet Traces\nTroubleshooting Packet Traces\nTake action to address packet tracing problems.\nSubmitting a Packet Trace to Apple\nLearn the best way to record a packet trace when communicating with Apple."
    },
    {
        "title": "OS_nw_protocol_options",
        "url": "https://developer.apple.com/documentation/network/os_nw_protocol_options",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "nw_browse_result_get_changes(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3114420-nw_browse_result_get_changes",
        "html": "See Also\nTracking Result Changes\ntypealias nw_browse_result_change_t\nFlags describing ways in which discovered services can change between specific results."
    },
    {
        "title": "nw_browse_result_get_interfaces_count(_:)",
        "url": "https://developer.apple.com/documentation/network/3114421-nw_browse_result_get_interfaces_",
        "html": "See Also\nEvaluating Browser Results\nfunc nw_browse_result_copy_endpoint(nw_browse_result_t) -> nw_endpoint_t\nThe discovered service endpoint.\nfunc nw_browse_result_enumerate_interfaces(nw_browse_result_t, (nw_interface_t) -> Bool)\nEnumerates the list of interfaces on which the service was discovered.\ntypealias nw_browse_result_enumerate_interface_t\nA handler that enumerates the interfaces associated with a discovered service."
    },
    {
        "title": "nw_browser_cancel(_:)",
        "url": "https://developer.apple.com/documentation/network/3043497-nw_browser_cancel",
        "html": "See Also\nManaging Browsers\nfunc nw_browser_set_state_changed_handler(nw_browser_t, nw_browser_state_changed_handler_t?)\nSets a handler to receive browser state updates.\ntypealias nw_browser_state_changed_handler_t\nA handler that delivers browser state updates with associated errors.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services."
    },
    {
        "title": "nw_browser_copy_parameters(_:)",
        "url": "https://developer.apple.com/documentation/network/3043499-nw_browser_copy_parameters",
        "html": "See Also\nInspecting Browsers\nfunc nw_browser_copy_browse_descriptor(nw_browser_t) -> nw_browse_descriptor_t\nAccesses the service descriptor with which the browser was created."
    },
    {
        "title": "nw_endpoint_type_t",
        "url": "https://developer.apple.com/documentation/network/nw_endpoint_type_t",
        "html": "Topics\nEndpoint Types\nvar nw_endpoint_type_invalid: nw_endpoint_type_t\nAn undefined endpoint type.\nvar nw_endpoint_type_address: nw_endpoint_type_t\nAn endpoint represented as an IP address and port.\nvar nw_endpoint_type_host: nw_endpoint_type_t\nAn endpoint represented as a hostname and port.\nvar nw_endpoint_type_bonjour_service: nw_endpoint_type_t\nAn endpoint represented as a Bonjour service.\nvar nw_endpoint_type_url: nw_endpoint_type_t\nAn endpoint represented as a URL, with host and port values inferred from the URL.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_connection_state_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_state_t",
        "html": "Topics\nConnection States\nvar nw_connection_state_invalid: nw_connection_state_t\nThe connection is not valid.\nvar nw_connection_state_waiting: nw_connection_state_t\nThe connection is waiting for a network path change.\nvar nw_connection_state_preparing: nw_connection_state_t\nThe connection in the process of being established.\nvar nw_connection_state_ready: nw_connection_state_t\nThe connection is established, and ready to send and receive data.\nvar nw_connection_state_failed: nw_connection_state_t\nThe connection has disconnected or encountered an error.\nvar nw_connection_state_cancelled: nw_connection_state_t\nThe connection has been canceled.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_data_transfer_report_state_t",
        "url": "https://developer.apple.com/documentation/network/nw_data_transfer_report_state_t",
        "html": "Topics\nReport States\nvar nw_data_transfer_report_state_collecting: nw_data_transfer_report_state_t\nThe data transfer report has been started but is still collecting data.\nvar nw_data_transfer_report_state_collected: nw_data_transfer_report_state_t\nThe data transfer report has completed, and data can be examined.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_error_domain_t",
        "url": "https://developer.apple.com/documentation/network/nw_error_domain_t",
        "html": "Topics\nError Domain Constants\nvar nw_error_domain_invalid: nw_error_domain_t\nThe error is invalid.\nvar nw_error_domain_posix: nw_error_domain_t\nA POSIX error, which is used for most network protocol and routing errors.\nvar nw_error_domain_dns: nw_error_domain_t\nA DNS error encountered in resolving, browsing, or advertising.\nvar nw_error_domain_tls: nw_error_domain_t\nA TLS error reported by a TLS connection or listener.\nCFError Domain Constants\nlet kNWErrorDomainPOSIX: CFString\nA POSIX error, which is used for most network protocol and routing errors.\nlet kNWErrorDomainDNS: CFString\nA DNS error encountered in resolving, browsing, or advertising.\nlet kNWErrorDomainTLS: CFString\nA TLS error reported by a TLS connection or listener.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_ethernet_channel_state_t",
        "url": "https://developer.apple.com/documentation/network/nw_ethernet_channel_state_t",
        "html": "Topics\nStates\nvar nw_ethernet_channel_state_invalid: nw_ethernet_channel_state_t\nThe channel is not valid.\nvar nw_ethernet_channel_state_waiting: nw_ethernet_channel_state_t\nThe channel is waiting for its interface to become available.\nvar nw_ethernet_channel_state_preparing: nw_ethernet_channel_state_t\nThe channel is registering with the interface.\nvar nw_ethernet_channel_state_ready: nw_ethernet_channel_state_t\nThe channel is able to send and receive Ethernet frames.\nvar nw_ethernet_channel_state_failed: nw_ethernet_channel_state_t\nThe channel has encountered a fatal error.\nvar nw_ethernet_channel_state_cancelled: nw_ethernet_channel_state_t\nThe channel has been canceled.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_framer_start_result_t",
        "url": "https://developer.apple.com/documentation/network/nw_framer_start_result_t",
        "html": "Topics\nStart Results\nvar nw_framer_start_result_ready: nw_framer_start_result_t\nThe protocol is immediately ready to send and receive data.\nvar nw_framer_start_result_will_mark_ready: nw_framer_start_result_t\nThe protocol will perform a handshake, preventing the overall connection from becoming ready until nw_framer_mark_ready(_:) is called.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_ws_version_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_version_t",
        "html": "Topics\nVersions\nvar nw_ws_version_invalid: nw_ws_version_t\nAn invalid version.\nvar nw_ws_version_13: nw_ws_version_t\nVersion 13 of the WebSocket protocol.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response."
    },
    {
        "title": "OS_nw_browser",
        "url": "https://developer.apple.com/documentation/network/os_nw_browser",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "nw_ip_local_address_preference_t",
        "url": "https://developer.apple.com/documentation/network/nw_ip_local_address_preference_t",
        "html": "Topics\nAddress Preferences\nvar nw_ip_local_address_preference_default: nw_ip_local_address_preference_t\nAllow the system to decide which kind of local address to prefer for a connection or listener.\nvar nw_ip_local_address_preference_temporary: nw_ip_local_address_preference_t\nPrefer using temporary local addresses.\nvar nw_ip_local_address_preference_stable: nw_ip_local_address_preference_t\nPrefer using stable local addresses.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_ip_ecn_flag_t",
        "url": "https://developer.apple.com/documentation/network/nw_ip_ecn_flag_t",
        "html": "Topics\nECN Flags\nvar nw_ip_ecn_flag_non_ect: nw_ip_ecn_flag_t\nNon-ECN Capable Transport.\nvar nw_ip_ecn_flag_ect_0: nw_ip_ecn_flag_t\nECN Capable Transport (flag 0).\nvar nw_ip_ecn_flag_ect_1: nw_ip_ecn_flag_t\nECN Capable Transport (flag 1).\nvar nw_ip_ecn_flag_ce: nw_ip_ecn_flag_t\nCongestion Experienced.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_ws_response_status_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_response_status_t",
        "html": "Topics\nHandshake Status Values\nvar nw_ws_response_status_invalid: nw_ws_response_status_t\nAn invalid response status.\nvar nw_ws_response_status_accept: nw_ws_response_status_t\nThe client request is being accepted.\nvar nw_ws_response_status_reject: nw_ws_response_status_t\nThe client request is being rejected.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_report_resolution_source_t",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_source_t",
        "html": "Topics\nResolution Sources\nvar nw_report_resolution_source_query: nw_report_resolution_source_t\nThe DNS response was received from the network.\nvar nw_report_resolution_source_cache: nw_report_resolution_source_t\nThe DNS response was retrieved from a local cache.\nvar nw_report_resolution_source_expired_cache: nw_report_resolution_source_t\nThe DNS response had expired and was retrieved from a local cache.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "OS_nw_advertise_descriptor",
        "url": "https://developer.apple.com/documentation/network/os_nw_advertise_descriptor",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "nw_ws_opcode_t",
        "url": "https://developer.apple.com/documentation/network/nw_ws_opcode_t",
        "html": "Topics\nData Types\nvar nw_ws_opcode_binary: nw_ws_opcode_t\nA binary data message.\nvar nw_ws_opcode_text: nw_ws_opcode_t\nA text data message.\nvar nw_ws_opcode_cont: nw_ws_opcode_t\nA continuation message.\nControl Types\nvar nw_ws_opcode_ping: nw_ws_opcode_t\nA Ping message, which requests a Pong from the peer.\nvar nw_ws_opcode_pong: nw_ws_opcode_t\nA Pong message in response to a Ping from the peer.\nvar nw_ws_opcode_close: nw_ws_opcode_t\nA message indicating a close of the connection.\nvar nw_ws_opcode_invalid: nw_ws_opcode_t\nThe message is not valid.\nInitializers\ninit(Int32)\ninit(rawValue: Int32)\nInstance Properties\nvar rawValue: Int32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "OS_nw_browse_descriptor",
        "url": "https://developer.apple.com/documentation/network/os_nw_browse_descriptor",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_browse_result",
        "url": "https://developer.apple.com/documentation/network/os_nw_browse_result",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_connection",
        "url": "https://developer.apple.com/documentation/network/os_nw_connection",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "errorCode",
        "url": "https://developer.apple.com/documentation/network/nwerror/4104762-errorcode",
        "html": "Relationships\nFrom Protocol\nCustomNSError"
    },
    {
        "title": "OS_nw_content_context",
        "url": "https://developer.apple.com/documentation/network/os_nw_content_context",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "Troubleshooting Packet Traces",
        "url": "https://developer.apple.com/documentation/network/recording_a_packet_trace/troubleshooting_packet_traces",
        "html": "Overview\n\nIf you\u2019re having problems recording a packet trace, read this document for some troubleshooting tips.\n\nTroubleshoot the Remote Virtual Interface (RVI)\n\nWhen you first launch Xcode, it installs the rvictl tool. If Terminal is unable to find the tool:\n\nMake sure you have the latest version of Xcode installed.\n\nMake sure /usr/bin/ is in your shell search path.\n\nIf rvictl fails with the message bootstrap_look_up(): 1102, make sure that the com.apple.rpmuxd daemon is installed and loaded. The following command should print information about the daemon:\n\nsudo launchctl list com.apple.rpmuxd\n\n\nIf the daemon is installed correctly, you should see output like this:\n\n$ sudo launchctl list com.apple.rpmuxd\n{\n    \"Label\" = \"com.apple.rpmuxd\";\n    \u2026\n};\n\n\nIf the daemon isn\u2019t installed correctly you\u2019ll see this:\n\n$ sudo launchctl list com.apple.rpmuxd\nCould not find service \"com.apple.rpmuxd\" in domain for system\n\n\nThis message can indicate that the daemon is unloaded. You can force it to load as follows:\n\nsudo launchctl load -w /System/Library/LaunchDaemons/com.apple.rpmuxd.plist\n\n\nUnderstand How Your Network Debugging Tool Deals with Local Traffic\n\nSome network debugging tools have problems dealing with traffic to or from the local machine, and some work best with that arrangement. Consult the documentation that comes with your tool for up-to-date information about its limitations.\n\nFor example, the tcpdump tool may flag the TCP checksum of packets sent by the local machine as bad. This is because of TCP checksum offloading. It\u2019s not a fatal problem, but if the bad checksums bother you, turn off this check by passing the -K option to tcpdump.\n\nAvoid Dropped Packets by Increasing the Recording Buffer Size\n\nIf you record all the bytes of each packet, it\u2019s possible to overrun the kernel\u2019s packet recording buffer. In this case, your packet trace tool should report a problem. For example, the tcpdump tool prints a summary of how many packets were recorded, filtered, and dropped when you stop the recording.\n\n$ sudo tcpdump -i en0 -w trace.pcap\ntcpdump: listening on en0, link-type EN10MB (Ethernet), capture size 65535 bytes\n^C\n94 packets captured\n177 packets received by filter\n0 packets dropped by kernel\n\n\nIf the dropped count is non-zero, increase the packet recording buffer size by passing the -B option to tcpdump.\n\nNote\n\nFor more information about this and other tcpdump options, see Reading UNIX Manual Pages.\n\nUse Promiscuous Mode Effectively\n\nOn modern systems it\u2019s generally best to run your packet trace tool on one of the machines involved in the communication you\u2019re investigating. However, in some cases that\u2019s not practical, so you have to run your tool on a different machine entirely. When doing so, be aware of these challenges:\n\nThe target interface must support promiscuous mode, that is, the ability to record packets that aren\u2019t destined for that interface. Most Ethernet interfaces support promiscuous mode. Most Wi-Fi interfaces also support promiscuous mode, but that\u2019s not useful because of network topology restrictions. Other interface types typically don\u2019t support promiscuous mode.\n\nThe network topology must allow the interface to see the packets. Historically, you could ensure this by connecting your machines using a hub. However, hubs are almost unheard of these days: Your DSL gateway might claim to have \u201can embedded four-port hub\u201d, but actually that\u2019s a switch.\n\nBy default, switches don\u2019t forward all traffic to all ports. If you have a simple switch, there\u2019s no way to override this default. For promiscuous mode to be useful, you\u2019ll need an advanced switch that supports port mirroring, that is, the ability to forward all traffic to a specific port.\n\nIf you\u2019re trying to use promiscuous mode on Wi-Fi, be aware that Wi-Fi access points act like switches, with standard traffic being seen only by the stations involved and the access point. Only a low-level Wi-Fi packet trace can take advantage of Wi-Fi promiscuous mode; see Record Low-Level Details of Wi-Fi Traffic Management.\n\nGet More Hints from the Wireshark Wiki\n\nThe Wireshark wiki has some useful information about how to set up your packet tracing environment:\n\nThe Ethernet Capture Setup page contains background information on how to set up your network for monitoring.\n\nThe Hub Reference page contains information on various types of hubs.\n\nThe Switch Reference page contains information on analysis features, such as port mirroring, found on various models of switches, including links to online documentation for those switches.\n\nSee Also\nWorking with Packet Traces\nRecording a Wi-Fi Packet Trace\nRecord traces of Wi-Fi traffic and traffic management.\nSubmitting a Packet Trace to Apple\nLearn the best way to record a packet trace when communicating with Apple.\nRelated Documentation\nReading UNIX Manual Pages\nUse the Terminal app to read the documentation for low-level UNIX tools and APIs."
    },
    {
        "title": "errorUserInfo",
        "url": "https://developer.apple.com/documentation/network/nwerror/4104764-erroruserinfo",
        "html": "Relationships\nFrom Protocol\nCustomNSError"
    },
    {
        "title": "localizedDescription",
        "url": "https://developer.apple.com/documentation/network/nwerror/2998623-localizeddescription",
        "html": "See Also\nInspecting Errors\nvar debugDescription: String\nThe description of the error.\nstatic func != (NWError, NWError) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwerror/2998620",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nInspecting Errors\nvar debugDescription: String\nThe description of the error.\nvar localizedDescription: String\nThe localized description of the error."
    },
    {
        "title": "type",
        "url": "https://developer.apple.com/documentation/network/nwinterface/2998640-type",
        "html": "See Also\nInspecting Interfaces\nenum NWInterface.InterfaceType\nTypes of network interfaces, based on their link layer media types.\nvar name: String\nThe name of the interface.\nvar index: Int\nThe system interface index associated with the interface.\nvar debugDescription: String\nThe description of the network interface."
    },
    {
        "title": "prefix(while:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166072-prefix",
        "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren\u2019t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
    },
    {
        "title": "NWError.tls(_:)",
        "url": "https://developer.apple.com/documentation/network/nwerror/tls",
        "html": "See Also\nChecking Error Types\ncase posix(POSIXErrorCode)\nA POSIX error, which is used for most network protocol and routing errors.\ncase dns(DNSServiceErrorType)\nA DNS error encountered in resolving, browsing, or advertising."
    },
    {
        "title": "reduce(into:_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166076-reduce",
        "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
    },
    {
        "title": "reduce(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166074-reduce",
        "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwerror/2998621-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Errors\nvar localizedDescription: String\nThe localized description of the error.\nstatic func != (NWError, NWError) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "NWPathMonitor.Iterator",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/iterator",
        "html": "Topics\nType Aliases\ntypealias NWPathMonitor.Iterator.Element\nInstance Methods\nfunc next() -> NWPathMonitor.Element?\nRelationships\nConforms To\nAsyncIteratorProtocol"
    },
    {
        "title": "NWError.dns(_:)",
        "url": "https://developer.apple.com/documentation/network/nwerror/dns",
        "html": "See Also\nChecking Error Types\ncase posix(POSIXErrorCode)\nA POSIX error, which is used for most network protocol and routing errors.\ncase tls(OSStatus)\nA TLS error reported by a TLS connection or listener."
    },
    {
        "title": "NWError.posix(_:)",
        "url": "https://developer.apple.com/documentation/network/nwerror/posix",
        "html": "See Also\nChecking Error Types\ncase dns(DNSServiceErrorType)\nA DNS error encountered in resolving, browsing, or advertising.\ncase tls(OSStatus)\nA TLS error reported by a TLS connection or listener."
    },
    {
        "title": "OS_nw_ws_response",
        "url": "https://developer.apple.com/documentation/network/os_nw_ws_response",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request"
    },
    {
        "title": "OS_nw_txt_record",
        "url": "https://developer.apple.com/documentation/network/os_nw_txt_record",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_ws_request",
        "url": "https://developer.apple.com/documentation/network/os_nw_ws_request",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_listener",
        "url": "https://developer.apple.com/documentation/network/os_nw_listener",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_ethernet_channel",
        "url": "https://developer.apple.com/documentation/network/os_nw_ethernet_channel",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_protocol_definition",
        "url": "https://developer.apple.com/documentation/network/os_nw_protocol_definition",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_path",
        "url": "https://developer.apple.com/documentation/network/os_nw_path",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_protocol_stack",
        "url": "https://developer.apple.com/documentation/network/os_nw_protocol_stack",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_protocol_metadata",
        "url": "https://developer.apple.com/documentation/network/os_nw_protocol_metadata",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_group_descriptor",
        "url": "https://developer.apple.com/documentation/network/os_nw_group_descriptor",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_establishment_report",
        "url": "https://developer.apple.com/documentation/network/os_nw_establishment_report",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_interface",
        "url": "https://developer.apple.com/documentation/network/os_nw_interface",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_path_monitor",
        "url": "https://developer.apple.com/documentation/network/os_nw_path_monitor",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_object",
        "url": "https://developer.apple.com/documentation/network/os_nw_object",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_privacy_context",
        "url": "https://developer.apple.com/documentation/network/os_nw_privacy_context",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_framer",
        "url": "https://developer.apple.com/documentation/network/os_nw_framer",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_parameters",
        "url": "https://developer.apple.com/documentation/network/os_nw_parameters",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "nw_browser_state_t",
        "url": "https://developer.apple.com/documentation/network/nw_browser_state_t",
        "html": "Topics\nStates\nvar nw_browser_state_invalid: nw_browser_state_t\nThe browser is not valid.\nvar nw_browser_state_ready: nw_browser_state_t\nThe browser is registered for discovering services.\nvar nw_browser_state_failed: nw_browser_state_t\nThe browser has encountered a fatal error.\nvar nw_browser_state_cancelled: nw_browser_state_t\nThe browser has been canceled.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_connection_group_state_t",
        "url": "https://developer.apple.com/documentation/network/nw_connection_group_state_t",
        "html": "Topics\nStates\nvar nw_connection_group_state_invalid: nw_connection_group_state_t\nThe connection group is not valid.\nvar nw_connection_group_state_waiting: nw_connection_group_state_t\nThe connection group is waiting for a network path change.\nvar nw_connection_group_state_ready: nw_connection_group_state_t\nThe connection group is joined, and ready to send and receive data.\nvar nw_connection_group_state_failed: nw_connection_group_state_t\nThe connection group encountered a fatal error.\nvar nw_connection_group_state_cancelled: nw_connection_group_state_t\nThe connection group has been canceled.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "map(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166064-map",
        "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn\u2019t provide a key for 4, and the closure throws an error for any key it can\u2019t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998721-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nChecking Path Capabilities\nlet supportsIPv4: Bool\nA Boolean indicating whether the path can route IPv4 traffic.\nlet supportsIPv6: Bool\nA Boolean indicating whether the path can route IPv6 traffic.\nlet supportsDNS: Bool\nA Boolean indicating whether the path has a DNS server configured.\nvar isConstrained: Bool\nA Boolean indicating whether the path uses an interface in Low Data Mode.\nlet isExpensive: Bool\nA Boolean indicating whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot."
    },
    {
        "title": "max(by:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166066-max",
        "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence\u2019s values don\u2019t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
    },
    {
        "title": "map(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166062-map",
        "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
    },
    {
        "title": "makeAsyncIterator()",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166061-makeasynciterator",
        "html": "Relationships\nFrom Protocol\nAsyncSequence"
    },
    {
        "title": "flatMap(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166059-flatmap",
        "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method \u201cflattens\u201d the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
    },
    {
        "title": "flatMap(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166057-flatmap",
        "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method \u201cflattens\u201d the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
    },
    {
        "title": "first(where:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166055-first",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that\u2019s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
    },
    {
        "title": "filter(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166053-filter",
        "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
    },
    {
        "title": "allSatisfy(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166038-allsatisfy",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
    },
    {
        "title": "start(queue:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/2998737-start",
        "html": "See Also\nCreating Path Monitors\ninit()\nInitializes a path monitor to observe all available interface types.\ninit(requiredInterfaceType: NWInterface.InterfaceType)\nInitializes a path monitor to observe a specific interface type.\ninit(prohibitedInterfaceTypes: [NWInterface.InterfaceType])\nInitializes a path monitor to observe interface types that are not explicitly prohibited.\nvar queue: DispatchQueue?\nThe queue on which path events are delivered."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166048-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998713",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Paths\nstatic func == (NWPath, NWPath) -> Bool"
    },
    {
        "title": "remoteEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998724-remoteendpoint",
        "html": "See Also\nInspecting Connected Paths\nlet localEndpoint: NWEndpoint?\nThe local endpoint in use by a connection's network path."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998714",
        "html": "See Also\nComparing Paths\nstatic func != (NWPath, NWPath) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "queue",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/2998736-queue",
        "html": "See Also\nCreating Path Monitors\ninit()\nInitializes a path monitor to observe all available interface types.\ninit(requiredInterfaceType: NWInterface.InterfaceType)\nInitializes a path monitor to observe a specific interface type.\ninit(prohibitedInterfaceTypes: [NWInterface.InterfaceType])\nInitializes a path monitor to observe interface types that are not explicitly prohibited.\nfunc start(queue: DispatchQueue)\nStarts monitoring path changes, and sets a queue on which to deliver path events."
    },
    {
        "title": "setPrivacyContext(_:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3580283-setprivacycontext",
        "html": "Discussion\n\nThe privacy context allows using separate caches for different sets of connections, as well as restricting how connection-specific information is logged and shared on the network.\n\nSee Also\nConfiguring Privacy Settings\nclass NWParameters.PrivacyContext\nAn object that defines the privacy requirements for a set of connections."
    },
    {
        "title": "localEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998723-localendpoint",
        "html": "See Also\nInspecting Connected Paths\nlet remoteEndpoint: NWEndpoint?\nThe remote endpoint in use by a connection's network path."
    },
    {
        "title": "prohibitExpensivePaths",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998702-prohibitexpensivepaths",
        "html": "Discussion\n\nTo test the behavior of this property, you can override the device\u2019s current values for cellular and Wi-Fi cost in Settings > Developer > Network Override.\n\nTip\n\nPrefer basing your app\u2019s policy logic around the prohibitConstrainedPaths property rather than this one. People using your app can use the \u201cLow Data Mode\u201d setting to set the constrained status, and thereby choose to use a potentially expensive network.\n\nSee Also\nSelecting Paths\nvar requiredInterfaceType: NWInterface.InterfaceType\nAn interface type to require on connections and listeners.\nvar requiredInterface: NWInterface?\nA specific interface to require on connections, listeners, and browsers.\nvar requiredLocalEndpoint: NWEndpoint?\nA specific local IP address and port to use for connections and listeners.\nvar prohibitConstrainedPaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nvar prohibitedInterfaceTypes: [NWInterface.InterfaceType]?\nA list of interface types that connections, listeners, and browsers will not use.\nvar prohibitedInterfaces: [NWInterface]?\nA list of specific interfaces that connections and listeners will not use."
    },
    {
        "title": "serviceClass",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998708-serviceclass",
        "html": "Discussion\n\nThere are two steps to enable Cellular Network Slicing:\n\nSet the entitlements in your property list for 5G Network Slicing App Category and 5G Network Slicing Traffic Category. If you don\u2019t entitle your app by specifying both these entitlements, your apps network connections won\u2019t be using Cellular Network Slicing, even if supported by the carrier.\n\nSet this to the appropriate NWParameters.ServiceClass.\n\n.\n\nSee Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "nw_service_class_t",
        "url": "https://developer.apple.com/documentation/network/nw_service_class_t",
        "html": "Topics\nCreating a service class instance\ninit(UInt32)\nCreates an instance of the service class structure.\ninit(rawValue: UInt32)\nCreates an instance of the service class structure.\nService classes\nvar nw_service_class_best_effort: nw_service_class_t\nDefault priority traffic.\nvar nw_service_class_background: nw_service_class_t\nBulk traffic, or traffic that can be deprioritized behind foreground traffic.\nvar nw_service_class_interactive_video: nw_service_class_t\nInteractive video traffic.\nvar nw_service_class_interactive_voice: nw_service_class_t\nInteractive voice traffic.\nvar nw_service_class_responsive_data: nw_service_class_t\nResponsive user-data traffic.\nvar nw_service_class_signaling: nw_service_class_t\nSignaling control traffic.\nAccessing the raw value\nvar rawValue: UInt32\nThe raw value of this instance.\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_parameters_expired_dns_behavior_t",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_t",
        "html": "Topics\nCreating an expired DNS behavior instance\ninit(UInt32)\nCreates an instance of the expired DNS behavior structure.\ninit(rawValue: UInt32)\nCreates an instance of the expired DNS behavior structure.\nExpired DNS behaviors\nvar nw_parameters_expired_dns_behavior_default: nw_parameters_expired_dns_behavior_t\nLet the system determine whether or not to allow expired DNS answers.\nvar nw_parameters_expired_dns_behavior_allow: nw_parameters_expired_dns_behavior_t\nExplicitly allow the use of expired DNS answers.\nvar nw_parameters_expired_dns_behavior_prohibit: nw_parameters_expired_dns_behavior_t\nExplicitly prohibit the use of expired DNS answers.\nAccessing the raw value\nvar rawValue: UInt32\nThe raw value of this instance.\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_multipath_service_t",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_service_t",
        "html": "Topics\nCreating a multipath service type instance\ninit(UInt32)\nCreates an instance of the multipath service type structure.\ninit(rawValue: UInt32)\nCreates an instance of the multipath service type structure.\nMultipath service types\nvar nw_multipath_service_disabled: nw_multipath_service_t\nDisable multipath.\nvar nw_multipath_service_handover: nw_multipath_service_t\nEnable multipath, but only use other interfaces when the primary interface is lost.\nvar nw_multipath_service_interactive: nw_multipath_service_t\nEnable multipath to use other interfaces when the primary interface encounters loss or delay.\nvar nw_multipath_service_aggregate: nw_multipath_service_t\nEnable multipath to maximize bandwidth across multiple interfaces.\nAccessing the raw value\nvar rawValue: UInt32\nThe raw value of this instance.\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_listener_state_t",
        "url": "https://developer.apple.com/documentation/network/nw_listener_state_t",
        "html": "Topics\nListener States\nvar nw_listener_state_invalid: nw_listener_state_t\nThe listener is not valid.\nvar nw_listener_state_waiting: nw_listener_state_t\nThe listener is waiting for a network to become available.\nvar nw_listener_state_ready: nw_listener_state_t\nThe listener is running and able to receive incoming connections.\nvar nw_listener_state_failed: nw_listener_state_t\nThe listener has encountered a fatal error.\nvar nw_listener_state_cancelled: nw_listener_state_t\nThe listener has been canceled.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_report_resolution_protocol_t",
        "url": "https://developer.apple.com/documentation/network/nw_report_resolution_protocol_t",
        "html": "Topics\nResolution Transports\nvar nw_report_resolution_protocol_unknown: nw_report_resolution_protocol_t\nThe DNS response protocol is unknown or not applicable.\nvar nw_report_resolution_protocol_udp: nw_report_resolution_protocol_t\nThe connection used cleartext UDP for DNS resolution.\nvar nw_report_resolution_protocol_tcp: nw_report_resolution_protocol_t\nThe connection used cleartext TCP for DNS resolution.\nvar nw_report_resolution_protocol_tls: nw_report_resolution_protocol_t\nThe connection used TLS for DNS resolution.\nvar nw_report_resolution_protocol_https: nw_report_resolution_protocol_t\nThe connection used HTTPS for DNS resolution.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_path_status_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_status_t",
        "html": "Topics\nStatus Values\nvar nw_path_status_invalid: nw_path_status_t\nThe path is not valid.\nvar nw_path_status_unsatisfied: nw_path_status_t\nThe path is not available for use.\nvar nw_path_status_satisfied: nw_path_status_t\nThe path is available to establish connections and send data.\nvar nw_path_status_satisfiable: nw_path_status_t\nThe path is not currently available, but establishing a new connection may activate the path.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_ip_version_t",
        "url": "https://developer.apple.com/documentation/network/nw_ip_version_t",
        "html": "Topics\nVersions\nvar nw_ip_version_any: nw_ip_version_t\nAllow any IP version.\nvar nw_ip_version_4: nw_ip_version_t\nRequire IP version 4.\nvar nw_ip_version_6: nw_ip_version_t\nRequire IP version 6.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "nw_txt_record_find_key_t",
        "url": "https://developer.apple.com/documentation/network/nw_txt_record_find_key_t",
        "html": "Topics\nKey Value Status\nvar nw_txt_record_find_key_invalid: nw_txt_record_find_key_t\nThe key is not valid.\nvar nw_txt_record_find_key_not_present: nw_txt_record_find_key_t\nThe key is not present in the dictionary.\nvar nw_txt_record_find_key_no_value: nw_txt_record_find_key_t\nThe key is present but has no associated value.\nvar nw_txt_record_find_key_empty_value: nw_txt_record_find_key_t\nThe key is present and has an empty associated value.\nvar nw_txt_record_find_key_non_empty_value: nw_txt_record_find_key_t\nThe key has an associated value.\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable\nSee Also\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol."
    },
    {
        "title": "init(dtls:udp:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998698-init",
        "html": "See Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "IPv6Address",
        "url": "https://developer.apple.com/documentation/network/ipv6address",
        "html": "Topics\nCreating Addresses\ninit?(String)\nInitializes an IPv6 address with a string.\ninit?(Data, NWInterface?)\nInitializes an IPv6 address with data.\nvar asIPv4: IPv4Address?\nExtracts the IPv4 address contained within the IPv6 address, if the IPv6 address is an IPv4-mapped or IPv4-compatible address.\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv6 address.\nlet interface: NWInterface?\nThe IPv6 scoped interface associated with this address.\nvar multicastScope: IPv6Address.Scope?\nThe IPv6 multicast scope of the address.\nenum IPv6Address.Scope\nAn IPv6 multicast scope.\nvar isAny: Bool\nA Boolean indicating whether the address is the unspecified address (::).\nvar is6to4: Bool\nA Boolean indicating whether the address is a 6to4 address.\nvar isIPv4Compatabile: Bool\nA Boolean indicating whether the address is IPv4-compatible.\nvar isIPv4Mapped: Bool\nA Boolean indicating whether the address is an IPv4-mapped address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address.\nSetting Well-Known Addresses\nstatic let any: IPv6Address\nThe unspecified address (::).\nstatic let broadcast: IPv6Address\nThe unspecified broadcast address (::).\nstatic let loopback: IPv6Address\nThe device's loopback address (::1).\nstatic let nodeLocalNodes: IPv6Address\nThe multicast address for all local nodes (ff01::1).\nstatic let linkLocalNodes: IPv6Address\nThe multicast address for all link-local nodes (ff02::1).\nstatic let linkLocalRouters: IPv6Address\nThe multicast address for all link-local routers (ff02::2).\nComparing Addresses\nstatic func == (IPv6Address, IPv6Address) -> Bool\nstatic func != (IPv6Address, IPv6Address) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nInstance Properties\nvar hashValue: Int\n@backDeployed(before: macOS 14, iOS 17, watchOS 10, tvOS 17) var isUniqueLocal: Bool\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nIPAddress\nSee Also\nInternet Addresses\nprotocol IPAddress\nAn abstract protocol you use to interact with IP addresses.\nstruct IPv4Address\nA structure containing an IPv4 address."
    },
    {
        "title": "NWParameters.ProtocolStack",
        "url": "https://developer.apple.com/documentation/network/nwparameters/protocolstack",
        "html": "Topics\nAdding Application Protocols\nvar applicationProtocols: [NWProtocolOptions]\nThe array of application protocol options used by connections and listeners.\nConfiguring Lower Protocols\nvar transportProtocol: NWProtocolOptions?\nThe transport protocol options used by connections and listeners.\nvar internetProtocol: NWProtocolOptions?\nThe Internet Protocol options used by connections and listeners.\nSee Also\nModifying Protocol Stacks\nvar defaultProtocolStack: NWParameters.ProtocolStack\nThe protocol stack used by connections and listeners.\nclass NWProtocol\nThe abstract superclass used by Network framework protocols and by custom network protocols that you define."
    },
    {
        "title": "OS_nw_endpoint",
        "url": "https://developer.apple.com/documentation/network/os_nw_endpoint",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSendable\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "OS_nw_error",
        "url": "https://developer.apple.com/documentation/network/os_nw_error",
        "html": "Relationships\nInherits From\nNSObjectProtocol\nSee Also\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "NWInterface.RadioType",
        "url": "https://developer.apple.com/documentation/network/nwinterface/radiotype",
        "html": "Topics\nEnumeration Cases\ncase cell(NWInterface.RadioType.Cellular)\ncase wifi(NWInterface.RadioType.WiFi)\nEnumerations\nenum NWInterface.RadioType.Cellular\nenum NWInterface.RadioType.WiFi\nRelationships\nConforms To\nSendable"
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwinterface/2998637-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "Submitting a Packet Trace to Apple",
        "url": "https://developer.apple.com/documentation/network/recording_a_packet_trace/submitting_a_packet_trace_to_apple",
        "html": "Overview\n\nAt times you may need to record a packet trace and then share it with Apple for further analysis. For example:\n\nYou might be reporting a bug where a packet trace is needed by the Apple engineers to understand, and hence fix, the bug.\n\nYou might be working with Developer Technical Support (DTS) to investigate a problem that can only be reproduced on your network.\n\nWhen you submit a packet trace in such situations, follow the instructions below to ensure that you\u2019ve included all the relevant information.\n\nNote\n\nThese instructions are also useful if you\u2019re investigating a problem reported by an advanced user and need them to send you a packet trace to further that investigation.\n\nRecord the Trace\n\nFollow these steps to record a packet trace to submit to Apple.\n\nNote\n\nThese steps assume you\u2019re recording the trace using the facilities built in to macOS. If necessary you can use a third-party tool, and even a tool on another platform, to record your trace, but make sure to read the information on packet trace formats in Work Through the Submission Checklist.\n\nIf you\u2019re developing for the Mac, determine the correct interface as described in Choose the Correct Interface. If you\u2019re developing for iOS, set up a remote virtual interface (RVI) per the instructions in Set Up iOS Packet Tracing.\n\nOpen a Terminal window and run the command sudo tcpdump -i en0 -w trace.pcap, replacing en0 with the name of the network interface from step 1.\n\nReproduce the problem.\n\nWhen you\u2019re done, press Control-C in Terminal to stop the packet trace.\n\nLocate the resulting trace.pcap file.\n\nFollow the instructions in Work Through the Submission Checklist to ensure that you\u2019ve included all the necessary information.\n\nSubmit the file to Apple as described in Submit the Packet Trace to Apple .\n\nWork Through the Submission Checklist\n\nWhen you submit a packet trace to Apple, make sure you provide:\n\nThe system type and OS version of the computer that recorded the packet trace. In the case of an RVI trace, include this information for both the Mac and the iOS device.\n\nIf you\u2019re using a packet trace tool that\u2019s not built in to macOS, include the name and version of the tool you used to record the packet trace.\n\nFor each relevant machine shown in the packet trace, describe the following:\n\nThe machine\u2019s role in the network conversation\n\nThe system type and OS version\n\nThe machine\u2019s IP address\n\nThe machine's hardware address (also known as the Ethernet address, Wi-Fi address, or MAC address)\n\nSubmit the Packet Trace to Apple\n\nBefore you submit your trace to Apple, make sure you\u2019ve included all of the information described in Work Through the Submission Checklist. You can put this information in a separate text file if you want, but it\u2019s OK to just include it as text in your bug report, DTS support request, and so on.\n\nIf you\u2019re using a packet trace tool whose native file format is PCAP or PcapNg (including tcpdump, Wireshark, and various others), you can include your packet trace file as is. Otherwise, include the original packet trace file and, if the file isn\u2019t already text, export the trace as text and include that text file as well. That way Apple is guaranteed to be able to read your packet trace.\n\nSee Also\nWorking with Packet Traces\nTroubleshooting Packet Traces\nTake action to address packet tracing problems.\nRecording a Wi-Fi Packet Trace\nRecord traces of Wi-Fi traffic and traffic management."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/3003629-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Interfaces\nstatic func == (NWInterface, NWInterface) -> Bool\nstatic func != (NWInterface, NWInterface) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/2998627",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Interfaces\nstatic func == (NWInterface, NWInterface) -> Bool\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwinterface/2998636-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Interfaces\nvar type: NWInterface.InterfaceType\nThe type of the interface, such as Wi-Fi or loopback.\nenum NWInterface.InterfaceType\nTypes of network interfaces, based on their link layer media types.\nvar name: String\nThe name of the interface.\nvar index: Int\nThe system interface index associated with the interface."
    },
    {
        "title": "==(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwinterface/2998628",
        "html": "See Also\nComparing Interfaces\nstatic func != (NWInterface, NWInterface) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "index",
        "url": "https://developer.apple.com/documentation/network/nwinterface/2998638-index",
        "html": "See Also\nInspecting Interfaces\nvar type: NWInterface.InterfaceType\nThe type of the interface, such as Wi-Fi or loopback.\nenum NWInterface.InterfaceType\nTypes of network interfaces, based on their link layer media types.\nvar name: String\nThe name of the interface.\nvar debugDescription: String\nThe description of the network interface."
    },
    {
        "title": "name",
        "url": "https://developer.apple.com/documentation/network/nwinterface/2998639-name",
        "html": "See Also\nInspecting Interfaces\nvar type: NWInterface.InterfaceType\nThe type of the interface, such as Wi-Fi or loopback.\nenum NWInterface.InterfaceType\nTypes of network interfaces, based on their link layer media types.\nvar index: Int\nThe system interface index associated with the interface.\nvar debugDescription: String\nThe description of the network interface."
    },
    {
        "title": "NWInterface.InterfaceType",
        "url": "https://developer.apple.com/documentation/network/nwinterface/interfacetype",
        "html": "Topics\nInterface Types\ncase wifi\nThe network interface type used for communication over Wi-Fi networks.\ncase cellular\nThe network interface type used for communication over cellular networks.\ncase wiredEthernet\nThe network interface type used for communication over wired Ethernet networks.\ncase loopback\nThe network interface type used for communication over local loopback networks.\ncase other\nThe network interface type used for communication over virtual networks or networks of unknown types.\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWInterface.InterfaceType, NWInterface.InterfaceType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWInterface.InterfaceType, NWInterface.InterfaceType) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nInspecting Interfaces\nvar type: NWInterface.InterfaceType\nThe type of the interface, such as Wi-Fi or loopback.\nvar name: String\nThe name of the interface.\nvar index: Int\nThe system interface index associated with the interface.\nvar debugDescription: String\nThe description of the network interface."
    },
    {
        "title": "prefix(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166070-prefix",
        "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
    },
    {
        "title": "isExpensive",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998722-isexpensive",
        "html": "See Also\nChecking Path Capabilities\nlet supportsIPv4: Bool\nA Boolean indicating whether the path can route IPv4 traffic.\nlet supportsIPv6: Bool\nA Boolean indicating whether the path can route IPv6 traffic.\nlet supportsDNS: Bool\nA Boolean indicating whether the path has a DNS server configured.\nvar isConstrained: Bool\nA Boolean indicating whether the path uses an interface in Low Data Mode.\nvar debugDescription: String\nThe description of the network path."
    },
    {
        "title": "supportsDNS",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998726-supportsdns",
        "html": "See Also\nChecking Path Capabilities\nlet supportsIPv4: Bool\nA Boolean indicating whether the path can route IPv4 traffic.\nlet supportsIPv6: Bool\nA Boolean indicating whether the path can route IPv6 traffic.\nvar isConstrained: Bool\nA Boolean indicating whether the path uses an interface in Low Data Mode.\nlet isExpensive: Bool\nA Boolean indicating whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot.\nvar debugDescription: String\nThe description of the network path."
    },
    {
        "title": "isConstrained",
        "url": "https://developer.apple.com/documentation/network/nwpath/3200463-isconstrained",
        "html": "See Also\nChecking Path Capabilities\nlet supportsIPv4: Bool\nA Boolean indicating whether the path can route IPv4 traffic.\nlet supportsIPv6: Bool\nA Boolean indicating whether the path can route IPv6 traffic.\nlet supportsDNS: Bool\nA Boolean indicating whether the path has a DNS server configured.\nlet isExpensive: Bool\nA Boolean indicating whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot.\nvar debugDescription: String\nThe description of the network path."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584960-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Groups\nlet descriptor: any NWGroupDescriptor\nThe descriptor of the group you use to initialize the connection group.\nlet parameters: NWParameters\nThe parameters with which you initialize the connection group.\nvar queue: DispatchQueue?\nThe queue on which you handle group events."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998661-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Listeners\nlet parameters: NWParameters\nThe parameters used to initialize the listener.\nvar queue: DispatchQueue?\nThe queue on which listener events are delivered."
    },
    {
        "title": "service",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998667-service",
        "html": "See Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nstruct NWListener.Service\nA description used to advertise the Bonjour service that a listener provides.\nvar serviceRegistrationUpdateHandler: (NWListener.ServiceRegistrationChange) -> Void)?\nA handler that receives updates for the service endpoint being advertised.\nenum NWListener.ServiceRegistrationChange\nChanges to how a network listener's service is advertised."
    },
    {
        "title": "newConnectionLimit",
        "url": "https://developer.apple.com/documentation/network/nwlistener/3200460-newconnectionlimit",
        "html": "Discussion\n\nWhen the new connection limit is set to a non-infinite value, it will decrement for every received connection. Once the value hits zero, new connections will be queued and eventually blocked, until you raise the limit. This allows you to limit the rate of inbound connections you handle.\n\nBy default, the limit is InfiniteConnectionLimit. When the limit is infinite, it does not decrement but allows all inbound connections.\n\nSee Also\nReceiving Connections\nvar newConnectionHandler: (NWConnection) -> Void)?\nA handler that receives inbound connections.\nstatic let InfiniteConnectionLimit: Int\nA static value to indicate that inbound connections should not be limited."
    },
    {
        "title": "InfiniteConnectionLimit",
        "url": "https://developer.apple.com/documentation/network/nwlistener/3200455-infiniteconnectionlimit",
        "html": "See Also\nReceiving Connections\nvar newConnectionHandler: (NWConnection) -> Void)?\nA handler that receives inbound connections.\nvar newConnectionLimit: Int\nThe remaining number of inbound connections to deliver before rejecting connections."
    },
    {
        "title": "gateways",
        "url": "https://developer.apple.com/documentation/network/nwpath/3200462-gateways",
        "html": "See Also\nInspecting Interfaces\nfunc usesInterfaceType(NWInterface.InterfaceType) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nlet availableInterfaces: [NWInterface]\nA list of all interfaces available to the path, in order of preference."
    },
    {
        "title": "supportsIPv4",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998727-supportsipv4",
        "html": "See Also\nChecking Path Capabilities\nlet supportsIPv6: Bool\nA Boolean indicating whether the path can route IPv6 traffic.\nlet supportsDNS: Bool\nA Boolean indicating whether the path has a DNS server configured.\nvar isConstrained: Bool\nA Boolean indicating whether the path uses an interface in Low Data Mode.\nlet isExpensive: Bool\nA Boolean indicating whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot.\nvar debugDescription: String\nThe description of the network path."
    },
    {
        "title": "supportsIPv6",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998728-supportsipv6",
        "html": "See Also\nChecking Path Capabilities\nlet supportsIPv4: Bool\nA Boolean indicating whether the path can route IPv4 traffic.\nlet supportsDNS: Bool\nA Boolean indicating whether the path has a DNS server configured.\nvar isConstrained: Bool\nA Boolean indicating whether the path uses an interface in Low Data Mode.\nlet isExpensive: Bool\nA Boolean indicating whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot.\nvar debugDescription: String\nThe description of the network path."
    },
    {
        "title": "availableInterfaces",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998720-availableinterfaces",
        "html": "See Also\nInspecting Interfaces\nfunc usesInterfaceType(NWInterface.InterfaceType) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nvar gateways: [NWEndpoint]\nA list of gateways configured on the interfaces available to a path."
    },
    {
        "title": "usesInterfaceType(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998729-usesinterfacetype",
        "html": "Discussion\n\nPaths can use interface types by directly routing over an interface, routing through a tunnel that goes over a physical interface, or being eligble to use multiple interfaces directly.\n\nSee Also\nInspecting Interfaces\nlet availableInterfaces: [NWInterface]\nA list of all interfaces available to the path, in order of preference.\nvar gateways: [NWEndpoint]\nA list of gateways configured on the interfaces available to a path."
    },
    {
        "title": "Inspecting app activity data",
        "url": "https://developer.apple.com/documentation/network/privacy_management/inspecting_app_activity_data",
        "html": "Overview\n\nIn iOS 15.2, iPadOS 15.2, and watchOS 8.3 or later, users can view a privacy report of when your app:\n\nAccesses certain kinds of user data, like photos and contacts.\n\nAccesses sensitive device resources, like the camera and microphone.\n\nContacts network domains, including websites that a user visits from within your app (iOS- and iPadOS-only).\n\nExamine the data that your app contributes to this summary to find out what the report shows users, and to make sure that your app behaves as you expect.\n\nStart recording app activity\n\nUsers can enable app activity recording on their device from the Settings app by choosing Privacy > App Privacy Report, and then tapping Turn On App Privacy Report.\n\nThe system keeps a record \u2014 stored only on the user\u2019s device \u2014 of the last seven days of app activity. After turning on this feature on your own device, use your app to fully test its data, resource, and network accesses. Be sure to use the app for long enough to allow for any delayed accesses. How long depends on the behavior of your app. For example, if an analytics framework in your app caches data to avoid frequent server accesses, be sure to run your app until it experiences an analytics server access.\n\nGet the app activity data\n\nAfter running your app for a while, you can get a report on your app\u2019s activity by tapping the Share button on the App Privacy Report screen:\n\nSave the report to a location where you can examine it. For example, you can use AirDrop to send it to a nearby Mac.\n\nThe report uses a newline-delimited JSON format (NDJSON), which you can open with any text editor, and contains a collection of JSON dictionaries separated by newlines. Dictionaries that have the type key with a value set to access provide information about resource accesses, while those that have the type key with a value set to networkActivity provide information about network activity:\n\n{..., \"type\":\"access\", ...}\n{..., \"type\":\"access\", ...}\n...\n{..., \"type\":\"networkActivity\", ...}\n{..., \"type\":\"networkActivity\", ...}\n...\n\n\nExamine resource access data\n\nEach access dictionary in the file represents the start or end of an access made by a particular app. The following shows an example of this dictionary with whitespace, newlines, and comments added for readability:\n\n{\n  \"accessor\" : { \n    \"identifier\" : \"com.example.calendar\", // The app accessing the resource.\n    \"identifierType\" : \"bundleID\"\n  },\n  \"broadcaster\": { // Only present for screen recording.\n    \"identifier\" : \"com.apple.springboard\", // The app broadcasting the screen.\n    \"identifierType\" : \"bundleID\"\n  },\n  \"category\" : \"screenRecording\", // The accessed resource.\n  \"identifier\" : \"8A4054BB-1810-4F8B-8163-483409E2D35C\", // A unique identifier.\n  \"kind\" : \"intervalBegin\", // Whether this the beginning or end of an interval.\n  \"timeStamp\" : \"2021-08-06T15:46:13.532-07:00\", // The time of the access.\n  \"type\" : \"access\" // This is resource access data.\n}\n\n\nTo find accesses made by your app, look for all of the access dictionaries that have an accessor key with a dictionary value that contains the bundle identifier of your app. Use the category field to determine which resource your app accessed, and the timeStamp field to associate the access with the activity that generated the access. You might encounter any of the following category values:\n\nCategory\n\n\t\n\nResource\n\n\n\n\ncamera\n\n\t\n\nThe device\u2019s camera\n\n\n\n\ncontacts\n\n\t\n\nThe user\u2019s contacts\n\n\n\n\nlocation\n\n\t\n\nLocation data\n\n\n\n\nmediaLibrary\n\n\t\n\nThe user\u2019s media library\n\n\n\n\nmicrophone\n\n\t\n\nThe device\u2019s microphone\n\n\n\n\nphotos\n\n\t\n\nThe user\u2019s photo library\n\n\n\n\nscreenRecording\n\n\t\n\nScreen sharing\n\nEvery resource access occurs over a time interval and generates a pair of access dictionaries to indicate:\n\nThe start of the interval with the kind field set to intervalBegin, as shown in the example above.\n\nThe end of the interval with the kind field set to intervalEnd.\n\nThe two dictionaries that bound an access interval have the same value for the identifier key.\n\nFor the screenRecording category, the dictionary also includes a broadcaster key with a value that indicates the app broadcasting the screen to the accessor, which is typically Springboard.\n\nExamine network activity\n\nA file exported from iOS or iPadOS contains another set of dictionaries that have the type key with a value set to networkActivity to report network accesses. Each dictionary describes a connection made by a specified app to a particular domain. The following shows an example of this dictionary, again with whitespace and newlines added for clarity:\n\n{\n  \"domain\" : \"api.example.com\",\n  \"firstTimeStamp\" : \"2021-06-06T16:15:48Z\",\n  \"context\" : \"\",\n  \"timeStamp\" : \"2021-06-06T16:15:59Z\",\n  \"domainType\" : 2,\n  \"initiatedType\" : \"AppInitiated\",\n  \"hits\" : 10,\n  \"type\" : \"networkActivity\",\n  \"domainOwner\" : \"\",\n  \"bundleID\" : \"com.example.App1\"\n}\n\n\nThe dictionary includes the following keys to describe the network activity:\n\ndomain\n\nThe domain of the network connection.\n\nfirstTimeStamp\n\nThe time of the first connection to this domain.\n\ncontext\n\nThe website that made the connection, if applicable.\n\ntimeStamp\n\nThe time of the most recent connection.\n\ndomainType\n\nWhen the associated value is 1, the domain has been identified as potentially collecting information across apps and sites, and potentially profiling users. A value of 2 means that the domain hasn\u2019t been identified as such.\n\ninitiatedType\n\nWhether the app (AppInitiated) or the user (NonAppInitiated) initiated the connection.\n\nhits\n\nThe number of times the app contacted the domain in the last seven days.\n\ntype\n\nAn associated value of networkActivity means that this dictionary describes network activity data.\n\ndomainOwner\n\nThe owner of the domain, if applicable.\n\nbundleID\n\nThe bundle identifier of the initiating app.\n\nWhen deciding how to set the value for the initiatedType key, the system attributes connections made from a web browser in your app, like when you instantiate an SFSafariViewController, to the user. Otherwise, the system considers any connection that your app makes with the URL Loading System, or lower-level interfaces like the Network framework, as app-initiated. This includes user data that you load from a server in direct response to a user action.\n\nYou can change the associated value of this key when you make a general network request by setting a property. For example, when creating a URLRequest, set the attribution property; when using an NWConnection instance, call the nw_parameters_set_attribution(_:_:) function. However, only change the attribution for connections that the user directly and completely controls, such as when the user enters a URL or taps or clicks a URL that they can read. For more information about network attribution, see Indicating the source of network activity.\n\nConsider whether your app needs changes\n\nIf you see that your app makes network connections that you don\u2019t recognize, or accesses resources that it shouldn\u2019t, review your app. Closely examine any third-party frameworks or modules that you\u2019ve integrated because they might make unexpected connections.\n\nSee Also\nEssentials\nRequesting access to protected resources\nProvide a purpose string that explains to a person why you need access to protected resources on their device."
    },
    {
        "title": "NWProtocolQUIC.Metadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/metadata",
        "html": "Topics\nInspecting Connection State\nvar negotiatedALPN: String?\nThe Application-Layer Protocol Negotiation value used when establishing the connection.\nvar localMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams that the peer can create on a QUIC connection.\nvar localMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams that the peer can create on a QUIC connection.\nvar remoteMaxStreamsBidirectional: Int\nThe maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteMaxStreamsUnidirectional: Int\nThe maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nvar remoteIdleTimeout: Int\nThe idle timeout value from the peer\u2019s transport parameters, in milliseconds.\nvar securityProtocolMetadata: sec_protocol_metadata_t\nThe result of the QUIC handshake.\nInspecting Stream State\nvar streamIdentifier: UInt64\nThe QUIC stream identifier.\nvar usableDatagramFrameSize: Int\nThe maximum usable size of a datagram frame on a QUIC datagram flow.\nHandling Errors\nvar applicationError: NWProtocolQUIC.ApplicationError\nThe QUIC application error code to send for the connection, or received from the peer.\nstruct NWProtocolQUIC.ApplicationError\nA QUIC application error code.\nvar streamApplicationErrorCode: UInt64\nThe QUIC application error code to send for the stream, or received from the peer.\nConfiguring Keepalives\nvar keepAlive: NWProtocolQUIC.Metadata.KeepAliveBehavior\nThe QUIC connection keepalive behavior.\nenum NWProtocolQUIC.Metadata.KeepAliveBehavior\nA QUIC connection keepalive behavior.\nRelationships\nInherits From\nNWProtocolMetadata"
    },
    {
        "title": "Indicating the source of network activity",
        "url": "https://developer.apple.com/documentation/network/privacy_management/indicating_the_source_of_network_activity",
        "html": "Overview\n\nIn iOS and iPadOS 15 or later, users can view an App Privacy Report that includes the network domains that apps on the device have recently accessed. The report differentiates between network connections that the user initiates and those that the app initiates.\n\nBy default, the system attributes all connections \u2014 except those that your app makes using SFSafariViewController or ASWebAuthenticationSession \u2014 to the app. However, for network connections that meet certain criteria, you can tell the system to attribute the connection to the user. The API you use to control attribution depends on how you make the network connection.\n\nTo learn how to examine all the data your app contributes to the privacy report, see Inspecting app activity data.\n\nDetermine the appropriate attribution\n\nAll connections, other than those that use SFSafariViewController or ASWebAuthenticationSession, are classified by default as app-initiated. User-initiated network connections are the exception. Network connections to third-party domains can only be classified as user-initiated if they meet all of the following criteria:\n\nUser-directed \u2014 Network connections to domains that occur only when a user affirmatively chooses to engage with content in your app. For a connection to qualify as user-directed, the user must be provided with a meaningful choice of whether to interact with the content.\n\nNon-primary functionality \u2014\u00a0The app\u2019s features must be functional without this particular network connection.\n\nIf you don\u2019t categorize your app\u2019s traffic using the APIs, all network connections are classified as app-initiated.\n\nFor example, the following connections should retain the app-initiated attribution:\n\nA podcast app that automatically chooses and downloads podcasts based on the user\u2019s interests. While the loaded content isn\u2019t core to the app, the user has no control over it.\n\nAn app that transmits analytics and other user data for use in improving the app. The access is core to the app\u2019s functionality, and the user has no control over it.\n\nA maps app that loads and presents content from a review service \u2014 for example, for hotels or restaurants \u2014 when the user taps on a location pin. The action is core to the app\u2019s functionality, and the user didn\u2019t explicitly request the information.\n\nIn contrast, you can attribute these connections to the user:\n\nLinks to user-generated content in a social media app, like when a user clicks or taps a news feed link. The user chooses the link, and the particular link isn\u2019t part of the app\u2019s primary functionality.\n\nMessages in an email app. The user creates and configures the email account, and no particular email or email account is central to the app\u2019s functionality.\n\nPages loaded by a web browser. The user chooses the web sites to visit, and no particular web site is specific to the app\u2019s functionality. Note that connections made by the browser that the user doesn\u2019t choose, like sending analytics data or retrieving user configuration information, should retain app attribution.\n\nTo reclassify an access as user-initiated, use API at the same layer of the protocol stack that you use to make the connection.\n\nAttribute URL Loading System connections\n\nTo mark a connection as user-initiated when using the URL Loading System, create an explicit URLRequest and set its attribution property to NSURLRequest.Attribution.user before calling one of the URLSession methods that takes a request, like data(for:delegate:):\n\nimport Foundation\n\n\nlet url = URL(string: \"https://example.com\")!\nvar request = URLRequest(url: url)\nrequest.attribution = .user\n\n\nlet (data, response) = try await URLSession.shared.data(for: request)\n\n\nThe NSURLRequest and NSMutableURLRequest classes also have a comparable property. Use this kind of parameterized request for other high level link types as well, as the next few sections describe.\n\nAttribute WebKit loads\n\nA WebKit network access that you initiate with a URL request using the load(_:) method honors the attribution parameter that you set on the URLRequest instance, just like the previous section describes for a URLSession access. If you want to set an attribution when you use WebKit to load an HTML string, data, or a file URL, use one of the corresponding load methods that takes a request. For example, you can load an HTML string with attribution using the loadSimulatedRequest(_:responseHTML:) method, relying on the request defined in the previous section:\n\nimport WebKit\n\n\nlet webView = WKWebView()\nlet html = \"<html><body><h1>Hello, world!</h1></body></html>\"\n\n\nwebView.loadSimulatedRequest(request, responseHTML: html)\n\n\nAlternatively, you can load a data version of the same content using the loadSimulatedRequest(_:response:responseData:) method:\n\nlet data = Data(html.utf8)\nlet response = URLResponse(\n    url: url,\n    mimeType: \"text/HTML\",\n    expectedContentLength: data.count,\n    textEncodingName: \"UTF-8\")\n\n\nwebView.loadSimulatedRequest(request, response: response, responseData: data)\n\n\nTo load a file called index.html from your main bundle\u2019s resources directory with user attribution, use the loadFileRequest(_:allowingReadAccessTo:) method:\n\nlet fileURL = Bundle.main.url(\n    forResource: \"index\",\n    withExtension: \"html\",\n    subdirectory: \"resources\")!\n\n\nvar fileRequest = URLRequest(url: fileURL)\nfileRequest.attribution = .user\n\n\nwebView.loadFileRequest(\n    fileRequest,\n    allowingReadAccessTo: fileURL.deletingLastPathComponent())\n\n\nThese load methods \u2014 as opposed to their non-request counterparts like loadHTMLString(_:baseURL:) and loadFileRequest(_:allowingReadAccessTo:) \u2014 also enable the user to browse backward and forward among the corresponding pages.\n\nAttribute LinkPresentation metadata fetches\n\nTo load link presentation metadata with attribution, use the LPMetadataProvider fetch method that takes a request. Specifically, use the startFetchingMetadata(for:completionHandler:) method \u2014 again, relying on the user-attributed request value that you defined earlier:\n\nimport LinkPresentation\n\n\nlet metadataProvider = LPMetadataProvider()\nlet metadata = try await metadataProvider.startFetchingMetadata(for: request)\n\nAttribute Network framework connections\n\nTo control attribution when using the Network framework, set the attribution property of an NWParameters instance to NWParameters.Attribution.user, and use that to create a connection:\n\nimport Network\n\n\nlet parameters = NWParameters()\nparameters.attribution = .user\nlet endpoint = NWEndpoint.url(url)\nlet connection = NWConnection(to: endpoint, using: parameters)\n\n\nAlternatively, you can work with an nw_parameters_t instance, and set the attribution to nw_parameters_attribution_t.user with a call to the nw_parameters_set_attribution(_:_:) function:\n\nlet parameters = nw_parameters_create()\nnw_parameters_set_attribution(parameters, .user)\nlet endpoint = nw_endpoint_create_url(\"https://example.com\")\nlet connection = nw_connection_create(endpoint, parameters)\n\nAttribute connections made with sockets\n\nTo control attribution when working with sockets, import the ne_socket.h header file, and use the ne_socket_set_attribution function to set the value NE_SOCKET_ATTRIBUTION_USER on a socket:\n\n#include <sys/socket.h>\n#include <networkext/ne_socket.h>\n\n\nint tcpSocket = socket(PF_INET, SOCK_STREAM, 0);\nif (ne_socket_set_attribution(tcpSocket, NE_SOCKET_ATTRIBUTION_USER) != 0) {\n    // Handle error.\n}\n\n\nIf you use custom DNS resolution, also call ne_socket_set_domains() function to associate the resolved domain name (as well as any resolved CNAME) with the socket:\n\nconst char *domains[] = { \"resolved.example.com\" };\nif (ne_socket_set_domains(tcpSocket, domains, 1) != 0) {\n    // Handle error.\n}\n\n\nThis gives the system an opportunity to evaluate whether the resolved domain has been identified as potentially collecting information across apps and sites. After performing any additional configuration, use the socket to create a connection:\n\nconst struct sockaddr *address = <#Some address#>;\nint connectResult = connect(tcpSocket, address, address->sa_len);\n\nSee Also\nNetwork activity attribution\nInspecting app activity data\nVerify that your app accesses only the user data and network resources that you expect it to access."
    },
    {
        "title": "NWProtocolWebSocket.Metadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/metadata",
        "html": "Topics\nSending Messages\ninit(opcode: NWProtocolWebSocket.Opcode)\nInitializes a WebSocket message with a specific type code.\nenum NWProtocolWebSocket.Opcode\nTypes of messages that you send and receive on a WebSocket connection.\nfunc setPongHandler(DispatchQueue, handler: (NWError?) -> Void)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\nvar closeCode: NWProtocolWebSocket.CloseCode\nThe close code on a WebSocket message.\nenum NWProtocolWebSocket.CloseCode\nTypes of codes used upon closing a WebSocket connection.\nReceiving Messages\nlet opcode: NWProtocolWebSocket.Opcode\nThe type code of a WebSocket message.\nvar closeCode: NWProtocolWebSocket.CloseCode\nThe close code on a WebSocket message.\nenum NWProtocolWebSocket.CloseCode\nTypes of codes used upon closing a WebSocket connection.\nInspecting Handshake Results\nvar selectedSubprotocol: String?\nThe subprotocol selected by the server during the WebSocket handshake.\nvar additionalServerHeaders: [(String, String)]?\nAdditional HTTP headers sent by the server during the WebSocket handshake.\nRelationships\nInherits From\nNWProtocolMetadata"
    },
    {
        "title": "NWProtocolWebSocket.Options",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/options",
        "html": "Topics\nConfiguring WebSocket Options\ninit(NWProtocolWebSocket.Version)\nInitializes a default set of WebSocket connection options.\nenum NWProtocolWebSocket.Version\nSupported versions of the WebSocket protocol.\nvar autoReplyPing: Bool\nA Boolean indicating whether the connection automatically replies to Ping messages instead of delivering them to you.\nvar maximumMessageSize: Int\nThe maximum allowed message size, in bytes, to be received by the WebSocket connection.\nConfiguring Client Handshakes\nfunc setAdditionalHeaders([(name: String, value: String)])\nSets additional HTTP header fields to be sent by the client during the WebSocket handshake.\nfunc setSubprotocols([String])\nAdds to the list of supported application protocols that will be presented to a WebSocket server during connection establishment.\nvar skipHandshake: Bool\nA Boolean indicating whether the WebSocket protocol skips its handshake and begins framing data once the underlying connection is established.\nHandling Server Handshakes\nfunc setClientRequestHandler(DispatchQueue, handler: ([String], [(name: String, value: String)]) -> NWProtocolWebSocket.Response)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\nstruct NWProtocolWebSocket.Response\nA WebSocket handshake reponse sent from a server to a client.\nRelationships\nInherits From\nNWProtocolOptions\nSee Also\nCreating WebSocket Connections\nstatic let definition: NWProtocolDefinition\nThe system definition of the WebSocket protocol."
    },
    {
        "title": "definition",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket/3200568-definition",
        "html": "See Also\nCreating WebSocket Connections\nclass NWProtocolWebSocket.Options\nA container of options for configuring how WebSocket is used on a connection."
    },
    {
        "title": "min(by:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166068-min",
        "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence\u2019s values don\u2019t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
    },
    {
        "title": "receiveHandler",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204153-receivehandler",
        "html": "Discussion\n\nThe receive handler only needs to be set once, and will be invoked for each received Ethernet frame.\n\nSee Also\nSending and Receiving Ethernet Frames\nfunc send(content: Data, to: NWEthernetChannel.EthernetAddress, vlanTag: UInt16, completion: (NWError?) -> Void)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\nstruct NWEthernetChannel.EthernetAddress\nA 48-bit Ethernet address."
    },
    {
        "title": "send(content:to:vlanTag:completion:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204154-send",
        "html": "See Also\nSending and Receiving Ethernet Frames\nvar receiveHandler: (Data, UInt16, NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Void)?\nA handler that delivers inbound Ethernet frames.\nstruct NWEthernetChannel.EthernetAddress\nA 48-bit Ethernet address."
    },
    {
        "title": "NWEthernetChannel.EthernetAddress",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/ethernetaddress",
        "html": "Topics\nCreating Addresses\ninit?(Data)\nInitializes an Ethernet address with data.\ninit?(String)\nInitializes an Ethernet address with a string.\nInspecting Addresses\nvar rawValue: Data\nThe raw data of the Ethernet address.\nvar debugDescription: String\nThe description of the Ethernet address.\nstatic func == (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nstatic func != (NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nInstance Properties\nvar hashValue: Int\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSendable\nSee Also\nSending and Receiving Ethernet Frames\nfunc send(content: Data, to: NWEthernetChannel.EthernetAddress, vlanTag: UInt16, completion: (NWError?) -> Void)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\nvar receiveHandler: (Data, UInt16, NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Void)?\nA handler that delivers inbound Ethernet frames."
    },
    {
        "title": "etherType",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204149-ethertype",
        "html": "See Also\nInspecting Ethernet Channels\nlet interface: NWInterface\nThe interface with which the channel was initialized.\nvar queue: DispatchQueue?\nThe queue on which channel events will be delivered.\nvar debugDescription: String\nThe description of the Ethernet channel."
    },
    {
        "title": "interface",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204151-interface",
        "html": "See Also\nInspecting Ethernet Channels\nlet etherType: UInt16\nThe custom Ethernet type with which the channel was initialized.\nvar queue: DispatchQueue?\nThe queue on which channel events will be delivered.\nvar debugDescription: String\nThe description of the Ethernet channel."
    },
    {
        "title": "stateUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204157-stateupdatehandler",
        "html": "See Also\nHandling State Updates\nvar state: NWEthernetChannel.State\nThe current state of the channel.\nenum NWEthernetChannel.State\nStates indicating whether an Ethernet channel is able to send and receive frames."
    },
    {
        "title": "state",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204156-state",
        "html": "See Also\nHandling State Updates\nenum NWEthernetChannel.State\nStates indicating whether an Ethernet channel is able to send and receive frames.\nvar stateUpdateHandler: (NWEthernetChannel.State) -> Void)?\nA handler that delivers channel state updates."
    },
    {
        "title": "NWListener.State",
        "url": "https://developer.apple.com/documentation/network/nwlistener/state",
        "html": "Topics\nStates\ncase setup\nThe listener has been initialized but not started.\ncase waiting(NWError)\nThe listener is waiting for a network to become available.\ncase ready\nThe listener is running and able to receive incoming connections.\ncase failed(NWError)\nThe listener has encountered a fatal error.\ncase cancelled\nThe listener has been canceled.\nOperator Functions\nstatic func != (NWListener.State, NWListener.State) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWListener.State, NWListener.State) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nCreating Listeners\ninit(using: NWParameters, on: NWEndpoint.Port)\nInitializes a network listener, with an optional local port.\nfunc start(queue: DispatchQueue)\nRegisters for listening, and sets the queue on which all listener events are delivered.\nvar stateUpdateHandler: (NWListener.State) -> Void)?\nA handler that receives listener state updates.\nvar port: NWEndpoint.Port?\nThe port on which the listener can accept connections.\nfunc cancel()\nStops listening for inbound connections."
    },
    {
        "title": "state",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998576-state",
        "html": "See Also\nHandling State Updates\nenum NWConnection.State\nStates indicating whether a connection can be used to send and receive data.\nvar stateUpdateHandler: (NWConnection.State) -> Void)?\nA handler that receives connection state updates."
    },
    {
        "title": "stateUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998670-stateupdatehandler",
        "html": "See Also\nCreating Listeners\ninit(using: NWParameters, on: NWEndpoint.Port)\nInitializes a network listener, with an optional local port.\nfunc start(queue: DispatchQueue)\nRegisters for listening, and sets the queue on which all listener events are delivered.\nenum NWListener.State\nStates indicating whether a listener is able to accept incoming connections.\nvar port: NWEndpoint.Port?\nThe port on which the listener can accept connections.\nfunc cancel()\nStops listening for inbound connections."
    },
    {
        "title": "NWEthernetChannel.State",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/state",
        "html": "Topics\nStates\ncase setup\nThe channel has been initialized but not started.\ncase waiting(NWError)\nThe channel is waiting for its interface to become available.\ncase preparing\nThe channel is registering with the interface.\ncase ready\nThe channel is able to send and receive Ethernet frames.\ncase failed(NWError)\nThe channel has encountered a fatal error.\ncase cancelled\nThe channel has been canceled.\nOperator Functions\nstatic func != (NWEthernetChannel.State, NWEthernetChannel.State) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWEthernetChannel.State, NWEthernetChannel.State) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nHandling State Updates\nvar state: NWEthernetChannel.State\nThe current state of the channel.\nvar stateUpdateHandler: (NWEthernetChannel.State) -> Void)?\nA handler that delivers channel state updates."
    },
    {
        "title": "start(queue:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204155-start",
        "html": "See Also\nManaging Ethernet Channels\ninit(on: NWInterface, etherType: UInt16)\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc cancel()\nUnregisters the channel from the interface."
    },
    {
        "title": "init(host:port:using:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998565-init",
        "html": "See Also\nCreating Connections\ninit(to: NWEndpoint, using: NWParameters)\nInitializes a new connection to a remote endpoint.\nfunc start(queue: DispatchQueue)\nStarts establishing a connection, and sets the queue on which to deliver all connection events.\nfunc restart()\nRestarts a connection that is in the waiting state."
    },
    {
        "title": "newConnectionHandler",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998663-newconnectionhandler",
        "html": "Discussion\n\nUpon receiving a new connection, you should set update handlers on the connection and start it in order to accept it. If you want to reject the connection, cancel the connection.\n\nSee Also\nReceiving Connections\nvar newConnectionLimit: Int\nThe remaining number of inbound connections to deliver before rejecting connections.\nstatic let InfiniteConnectionLimit: Int\nA static value to indicate that inbound connections should not be limited."
    },
    {
        "title": "init(using:on:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/3019348-init",
        "html": "See Also\nCreating Listeners\nfunc start(queue: DispatchQueue)\nRegisters for listening, and sets the queue on which all listener events are delivered.\nvar stateUpdateHandler: (NWListener.State) -> Void)?\nA handler that receives listener state updates.\nenum NWListener.State\nStates indicating whether a listener is able to accept incoming connections.\nvar port: NWEndpoint.Port?\nThe port on which the listener can accept connections.\nfunc cancel()\nStops listening for inbound connections."
    },
    {
        "title": "cancel()",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998660-cancel",
        "html": "See Also\nCreating Listeners\ninit(using: NWParameters, on: NWEndpoint.Port)\nInitializes a network listener, with an optional local port.\nfunc start(queue: DispatchQueue)\nRegisters for listening, and sets the queue on which all listener events are delivered.\nvar stateUpdateHandler: (NWListener.State) -> Void)?\nA handler that receives listener state updates.\nenum NWListener.State\nStates indicating whether a listener is able to accept incoming connections.\nvar port: NWEndpoint.Port?\nThe port on which the listener can accept connections."
    },
    {
        "title": "compactMap(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166042-compactmap",
        "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
    },
    {
        "title": "contains(where:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166046-contains",
        "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn\u2019t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
    },
    {
        "title": "drop(while:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166049-drop",
        "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
    },
    {
        "title": "contains(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166044-contains",
        "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
    },
    {
        "title": "dropFirst(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166051-dropfirst",
        "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
    },
    {
        "title": "compactMap(_:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/4166040-compactmap",
        "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
    },
    {
        "title": "NWPath.UnsatisfiedReason",
        "url": "https://developer.apple.com/documentation/network/nwpath/unsatisfiedreason",
        "html": "Topics\nEnumeration Cases\ncase cellularDenied\ncase localNetworkDenied\ncase notAvailable\ncase vpnInactive\ncase wifiDenied\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWPath.UnsatisfiedReason, NWPath.UnsatisfiedReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWPath.UnsatisfiedReason, NWPath.UnsatisfiedReason) -> Bool\nRelationships\nConforms To\nSendable"
    },
    {
        "title": "pathUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/2998735-pathupdatehandler",
        "html": "See Also\nHandling Path Updates\nvar currentPath: NWPath\nThe currently available network path observed by the path monitor."
    },
    {
        "title": "currentPath",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/2998732-currentpath",
        "html": "See Also\nHandling Path Updates\nvar pathUpdateHandler: (NWPath) -> Void)?\nA handler that receives network path updates."
    },
    {
        "title": "init(requiredInterfaceType:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/2998734-init",
        "html": "See Also\nCreating Path Monitors\ninit()\nInitializes a path monitor to observe all available interface types.\ninit(prohibitedInterfaceTypes: [NWInterface.InterfaceType])\nInitializes a path monitor to observe interface types that are not explicitly prohibited.\nfunc start(queue: DispatchQueue)\nStarts monitoring path changes, and sets a queue on which to deliver path events.\nvar queue: DispatchQueue?\nThe queue on which path events are delivered."
    },
    {
        "title": "init(prohibitedInterfaceTypes:)",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/3548854-init",
        "html": "See Also\nCreating Path Monitors\ninit()\nInitializes a path monitor to observe all available interface types.\ninit(requiredInterfaceType: NWInterface.InterfaceType)\nInitializes a path monitor to observe a specific interface type.\nfunc start(queue: DispatchQueue)\nStarts monitoring path changes, and sets a queue on which to deliver path events.\nvar queue: DispatchQueue?\nThe queue on which path events are delivered."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor/2998733-init",
        "html": "See Also\nCreating Path Monitors\ninit(requiredInterfaceType: NWInterface.InterfaceType)\nInitializes a path monitor to observe a specific interface type.\ninit(prohibitedInterfaceTypes: [NWInterface.InterfaceType])\nInitializes a path monitor to observe interface types that are not explicitly prohibited.\nfunc start(queue: DispatchQueue)\nStarts monitoring path changes, and sets a queue on which to deliver path events.\nvar queue: DispatchQueue?\nThe queue on which path events are delivered."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998694-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object."
    },
    {
        "title": "descriptor",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584961-descriptor",
        "html": "See Also\nInspecting Groups\nlet parameters: NWParameters\nThe parameters with which you initialize the connection group.\nvar queue: DispatchQueue?\nThe queue on which you handle group events.\nvar debugDescription: String\nThe description of the connection group."
    },
    {
        "title": "parameters",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584964-parameters",
        "html": "See Also\nInspecting Groups\nlet descriptor: any NWGroupDescriptor\nThe descriptor of the group you use to initialize the connection group.\nvar queue: DispatchQueue?\nThe queue on which you handle group events.\nvar debugDescription: String\nThe description of the connection group."
    },
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/3003628-hash",
        "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nEndpoint Properties\nvar interface: NWInterface?\nThe optional interface associated with this endpoint, such as the interface on which it was discovered.\nvar debugDescription: String\nThe description of this endpoint.\nstatic func != (NWEndpoint, NWEndpoint) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "queue",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584965-queue",
        "html": "See Also\nInspecting Groups\nlet descriptor: any NWGroupDescriptor\nThe descriptor of the group you use to initialize the connection group.\nlet parameters: NWParameters\nThe parameters with which you initialize the connection group.\nvar debugDescription: String\nThe description of the connection group."
    },
    {
        "title": "NWMulticastGroup",
        "url": "https://developer.apple.com/documentation/network/nwmulticastgroup",
        "html": "Overview\n\nImportant\n\nIn order to use multicast on iOS, your app will need to have the com.apple.developer.networking.multicast entitlement.\n\nTopics\nEssentials\ncom.apple.developer.networking.multicast\nA Boolean value that indicates whether an app can send or receive IP multicast traffic.\nDefining Multicast Groups\ninit(for: [NWEndpoint], from: NWEndpoint?, disableUnicast: Bool)\nInitializes a multicast group with a set of multicast addresses.\nInspecting Multicast Groups\nvar members: [NWEndpoint]\nThe set of IP multicast group addresses that the connection group joins.\nlet sourceFilter: NWEndpoint?\nAn optional address endpoint you provide to filter received multicast packets.\nlet isUnicastDisabled: Bool\nA Boolean that specifies whether the connection group rejects unicast traffic.\nRelationships\nConforms To\nNWGroupDescriptor\nSendable\nSee Also\nEstablishing Group Connectivity\ninit(with: any NWGroupDescriptor, using: NWParameters)\nInitializes a new connection group with a group identifier.\nprotocol NWGroupDescriptor\nA protocol that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc start(queue: DispatchQueue)\nJoins the group, registers to receive messages, and sets the queue on you handle group events."
    },
    {
        "title": "start(queue:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584967-start",
        "html": "See Also\nEstablishing Group Connectivity\ninit(with: any NWGroupDescriptor, using: NWParameters)\nInitializes a new connection group with a group identifier.\nclass NWMulticastGroup\nA descriptor for a group you use to join an IP multicast group on a local network.\nprotocol NWGroupDescriptor\nA protocol that defines a group of endpoints with which you can communicate, such as a multicast group."
    },
    {
        "title": "NWGroupDescriptor",
        "url": "https://developer.apple.com/documentation/network/nwgroupdescriptor",
        "html": "Topics\nInspecting Groups\nvar members: [NWEndpoint]\nThe set of endpoints that define the connection group.\n\nRequired\n\nRelationships\nInherits From\nSendable\nConforming Types\nNWMulticastGroup\nNWMultiplexGroup\nSee Also\nEstablishing Group Connectivity\ninit(with: any NWGroupDescriptor, using: NWParameters)\nInitializes a new connection group with a group identifier.\nclass NWMulticastGroup\nA descriptor for a group you use to join an IP multicast group on a local network.\nfunc start(queue: DispatchQueue)\nJoins the group, registers to receive messages, and sets the queue on you handle group events."
    },
    {
        "title": "state",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584968-state",
        "html": "See Also\nManaging Groups\nvar stateUpdateHandler: (NWConnectionGroup.State) -> Void)?\nA handler that receives connection group state updates.\nenum NWConnectionGroup.State\nStates that indicate whether you can use a connection group to send and receive messages.\nfunc cancel()\nCancels the connection group object and leaves the network group."
    },
    {
        "title": "init(with:using:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584962-init",
        "html": "See Also\nEstablishing Group Connectivity\nclass NWMulticastGroup\nA descriptor for a group you use to join an IP multicast group on a local network.\nprotocol NWGroupDescriptor\nA protocol that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc start(queue: DispatchQueue)\nJoins the group, registers to receive messages, and sets the queue on you handle group events."
    },
    {
        "title": "NWListener.Service",
        "url": "https://developer.apple.com/documentation/network/nwlistener/service",
        "html": "Topics\nDefining Services\ninit(name: String?, type: String, domain: String?, txtRecord: Data?)\nInitializes a Bonjour service to advertise.\ninit(name: String?, type: String, domain: String?, txtRecord: NWTXTRecord)\nInitializes a Bonjour service to advertise with a TXT record.\nvar noAutoRename: Bool\nA Boolean that indicates whether the service prohibits automatic renaming in the event of a name conflict.\nInspecting Services\nlet name: String?\nThe Bonjour name of the service.\nlet type: String\nThe Bonjour type of the service.\nlet domain: String?\nThe Bonjour domain of the service.\nvar txtRecordObject: NWTXTRecord?\nThe TXT record to advertise with the service.\nlet txtRecord: Data?\nThe TXT record as a raw buffer to advertise with the service.\nvar debugDescription: String\nThe description of the service.\nInitializers\ninit(applicationService: String)\nCreates a listener for apps that listen for connections from a network device picker.\nOperator Functions\nstatic func != (NWListener.Service, NWListener.Service) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWListener.Service, NWListener.Service) -> Bool\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nvar service: NWListener.Service?\nA Bonjour service that advertises the listener on the local network.\nvar serviceRegistrationUpdateHandler: (NWListener.ServiceRegistrationChange) -> Void)?\nA handler that receives updates for the service endpoint being advertised.\nenum NWListener.ServiceRegistrationChange\nChanges to how a network listener's service is advertised."
    },
    {
        "title": "queue",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998666-queue",
        "html": "See Also\nInspecting Listeners\nlet parameters: NWParameters\nThe parameters used to initialize the listener.\nvar debugDescription: String\nThe description of the listener."
    },
    {
        "title": "parameters",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998664-parameters",
        "html": "See Also\nInspecting Listeners\nvar queue: DispatchQueue?\nThe queue on which listener events are delivered.\nvar debugDescription: String\nThe description of the listener."
    },
    {
        "title": "NWPath.Status",
        "url": "https://developer.apple.com/documentation/network/nwpath/status",
        "html": "Topics\nStatus Values\ncase unsatisfied\nThe path is not available for use.\ncase satisfied\nThe path is available to establish connections and send data.\ncase requiresConnection\nThe path is not currently available, but establishing a new connection may activate the path.\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWPath.Status, NWPath.Status) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWPath.Status, NWPath.Status) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nChecking Path Availability\nlet status: NWPath.Status\nA status indicating whether a path can be used by connections."
    },
    {
        "title": "nw_parameters_get_attribution(_:)",
        "url": "https://developer.apple.com/documentation/network/3747053-nw_parameters_get_attribution",
        "html": "Parameters\nparameters\n\nThe network parameters to read from.\n\nReturn Value\n\nAn indication of whether the network request comes from the developer or from the user.\n\nSee Also\nTraffic Attribution\nInspecting app activity data\nVerify that your app accesses only the user data and network resources that you expect it to access.\nIndicating the source of network activity\nControl whether the App Privacy Report attributes network traffic to the app or to the user.\nfunc nw_parameters_set_attribution(nw_parameters_t, nw_parameters_attribution_t)\nSets a flag that indicates whether the network request originates from the developer or the user.\nenum nw_parameters_attribution_t\nThe entities that can make a network request."
    },
    {
        "title": "nw_parameters_attribution_t",
        "url": "https://developer.apple.com/documentation/network/nw_parameters_attribution_t",
        "html": "Overview\n\nUse one of these values when setting the attribution parameter of a network request with the nw_parameters_get_attribution(_:) method. If you don\u2019t set a value, the system assumes nw_parameters_attribution_t.developer.\n\nTopics\nRequest Sources\ncase developer\nA developer-initiated network request.\ncase user\nThe user explicitly directs the app to make a network request.\nRelationships\nConforms To\nSendable\nSee Also\nTraffic Attribution\nInspecting app activity data\nVerify that your app accesses only the user data and network resources that you expect it to access.\nIndicating the source of network activity\nControl whether the App Privacy Report attributes network traffic to the app or to the user.\nfunc nw_parameters_set_attribution(nw_parameters_t, nw_parameters_attribution_t)\nSets a flag that indicates whether the network request originates from the developer or the user.\nfunc nw_parameters_get_attribution(nw_parameters_t) -> nw_parameters_attribution_t\nGets a flag that indicates whether the network request originates from the developer or the user."
    },
    {
        "title": "nw_parameters_set_attribution(_:_:)",
        "url": "https://developer.apple.com/documentation/network/3747054-nw_parameters_set_attribution",
        "html": "Parameters\nparameters\n\nThe network parameters to update.\n\nattribution\n\nAn indication of whether the network request comes from the developer or from the user.\n\nDiscussion\n\nIf you don\u2019t set this flag, the system assumes a value of nw_parameters_attribution_t.developer. Use this default value for any network request that your app makes that isn\u2019t explicitly from the user. This includes requests that you make to your own server, even when you load user data. It also includes links that the user selects, but that you modify in any way \u2014 including by adding HTTP headers \u2014 before loading the content.\n\nSet this value to nw_parameters_attribution_t.user only for requests that the user explicitly makes, like when the user enters a URL or taps or clicks a URL that they can read, and only if your app loads and displays the data without altering the request.\n\nSee Also\nTraffic Attribution\nInspecting app activity data\nVerify that your app accesses only the user data and network resources that you expect it to access.\nIndicating the source of network activity\nControl whether the App Privacy Report attributes network traffic to the app or to the user.\nfunc nw_parameters_get_attribution(nw_parameters_t) -> nw_parameters_attribution_t\nGets a flag that indicates whether the network request originates from the developer or the user.\nenum nw_parameters_attribution_t\nThe entities that can make a network request."
    },
    {
        "title": "status",
        "url": "https://developer.apple.com/documentation/network/nwpath/2998725-status",
        "html": "See Also\nChecking Path Availability\nenum NWPath.Status\nStatus values indicating whether a path can be used by connections."
    },
    {
        "title": "NWProtocolQUIC.Options",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/options",
        "html": "Topics\nCustomizing Connection Options\ninit(alpn: [String])\nInitializes a default set of QUIC options along with a set of supported Application-Layer Protocol Negotiation values.\ninit()\nInitializes a default set of QUIC options, without specifying a set of supported Application-Layer Protocol Negotiation values.\nvar alpn: [String]\nA set of supported Application-Layer Protocol Negotiation values.\nvar idleTimeout: Int\nThe idle timeout for the QUIC connection, in milliseconds.\nvar initialMaxData: Int\nA QUIC connection\u2019s initial maximum data transport parameter.\nvar initialMaxStreamDataBidirectionalLocal: Int\nA QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nvar initialMaxStreamDataBidirectionalRemote: Int\nA QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nvar initialMaxStreamDataUnidirectional: Int\nA QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nvar initialMaxStreamsBidirectional: Int\nA QUIC connection\u2019s initial maximum number of bidirectional streams.\nvar initialMaxStreamsUnidirectional: Int\nA QUIC connection\u2019s initial maximum number of unidirectional streams.\nvar maxDatagramFrameSize: Int\nA QUIC connection\u2019s maximum DATAGRAM frame size.\nvar maxUDPPayloadSize: Int\nThe maximum length of a QUIC packet that can be received on a connection, in bytes.\nvar securityProtocolOptions: sec_protocol_options_t\nThe handshake security options QUIC uses.\nCustomizing Stream Options\nvar direction: NWProtocolQUIC.Options.Direction\nThe direction of the QUIC stream.\nenum NWProtocolQUIC.Options.Direction\nA directionality of a QUIC stream.\nvar isDatagram: Bool\nA Boolean that indicates that this is a QUIC datagram flow, not a stream of bytes.\nRelationships\nInherits From\nNWProtocolOptions\nSee Also\nCreating QUIC Connections\nstatic let definition: NWProtocolDefinition\nThe system definition of the QUIC transport protocol."
    },
    {
        "title": "definition",
        "url": "https://developer.apple.com/documentation/network/nwprotocoludp/2998803-definition",
        "html": "See Also\nCreating UDP Connections\nclass NWProtocolUDP.Options\nA container of options for configuring how UDP is used on a connection."
    },
    {
        "title": "NWProtocolUDP.Metadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocoludp/metadata",
        "html": "Topics\nCreating UDP Messages\ninit()\nInitializes a default UDP message.\nRelationships\nInherits From\nNWProtocolMetadata"
    },
    {
        "title": "definition",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic/3802985-definition",
        "html": "See Also\nCreating QUIC Connections\nclass NWProtocolQUIC.Options\nA container of options that configure the use of QUIC on a connection."
    },
    {
        "title": "queue",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204152-queue",
        "html": "See Also\nInspecting Ethernet Channels\nlet etherType: UInt16\nThe custom Ethernet type with which the channel was initialized.\nlet interface: NWInterface\nThe interface with which the channel was initialized.\nvar debugDescription: String\nThe description of the Ethernet channel."
    },
    {
        "title": "NWProtocolUDP.Options",
        "url": "https://developer.apple.com/documentation/network/nwprotocoludp/options",
        "html": "Topics\nCustomizing UDP Connections\ninit()\nInitializes a default set of UDP connection options.\nvar preferNoChecksum: Bool\nA Boolean that configures the connection to not send UDP checksums.\nRelationships\nInherits From\nNWProtocolOptions\nSee Also\nCreating UDP Connections\nstatic let definition: NWProtocolDefinition\nThe system definition of the User Datagram Protocol."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204148-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Ethernet Channels\nlet etherType: UInt16\nThe custom Ethernet type with which the channel was initialized.\nlet interface: NWInterface\nThe interface with which the channel was initialized.\nvar queue: DispatchQueue?\nThe queue on which channel events will be delivered."
    },
    {
        "title": "NWConnection.EstablishmentReport",
        "url": "https://developer.apple.com/documentation/network/nwconnection/establishmentreport",
        "html": "Overview\n\nUse this report to inspect connection establishment details, such as its resolution steps, use of proxies, and duration.\n\nThis report shows different data when iCloud Private Relay makes the connection. iCloud Private Relay can change the timing and sequence of events for your connections by using a set of privacy proxies.\n\nWhen iCloud Private Relay is in use, any proxied connections have the usedProxy property set. The handshakes property contains information about the stages of proxy connections used, and the timings to establish the end-to-end connection.\n\nConnections that aren\u2019t proxied might still use iCloud Private Relay for name resolution. In this case, the resolutions property includes information about resolutions that use the https DNS protocol.\n\nTopics\nInspecting Connection Attempts\nlet duration: TimeInterval\nThe total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nlet previousAttemptCount: Int\nThe number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state.\nlet attemptStartedAfterInterval: TimeInterval\nThe time between the call to start and the beginning of the successful connection attempt.\nvar debugDescription: String\nThe description of the report.\nInspecting Resolution\nlet resolutions: [NWConnection.EstablishmentReport.Resolution]\nThe array of resolution steps performed during connection establishment, in order from first resolved to last resolved.\nstruct NWConnection.EstablishmentReport.Resolution\nA description of a single DNS resolution step.\nInspecting Protocol Handshakes\nlet handshakes: [NWConnection.EstablishmentReport.Handshake]\nThe array of protocol handshakes in order from first completed to last completed.\nstruct NWConnection.EstablishmentReport.Handshake\nA description of a single protocol handshake.\nChecking for Proxies\nlet proxyConfigured: Bool\nA Boolean indicating whether a proxy was configured on the connection.\nlet usedProxy: Bool\nA Boolean indicating whether the connection used a proxy.\nlet proxyEndpoint: NWEndpoint?\nThe endpoint of the proxy the connection used.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nCollecting Connection Metrics\nCollecting Network Connection Metrics\nUse reports to understand how DNS and protocol handshakes impact connection establishment.\nfunc requestEstablishmentReport(queue: DispatchQueue, completion: (NWConnection.EstablishmentReport?) -> Void)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\nfunc startDataTransferReport() -> NWConnection.PendingDataTransferReport\nBegins a new data transfer report, which can later be collected.\nclass NWConnection.PendingDataTransferReport\nAn outstanding data transfer report that has yet to be collected.\nstruct NWConnection.DataTransferReport\nA report that provides metrics about data being sent and received on a connection."
    },
    {
        "title": "viabilityUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998578-viabilityupdatehandler",
        "html": "See Also\nHandling Path Updates\nvar currentPath: NWPath?\nThe network path the connection is using.\nvar pathUpdateHandler: (NWPath) -> Void)?\nA handler that receives network path updates.\nvar betterPathUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when an alternative network path is preferred over the current path."
    },
    {
        "title": "init(on:etherType:)",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204150-init",
        "html": "Parameters\ninterface\n\nThe interface on which to send and receive Ethernet frames.\n\netherType\n\nThe custom Ethernet frame type to register for this channel, in host-byte order.\n\nSee Also\nManaging Ethernet Channels\nfunc start(queue: DispatchQueue)\nStarts the process of registering the channel, and sets the queue on which all channel events are delivered.\nfunc cancel()\nUnregisters the channel from the interface."
    },
    {
        "title": "definition",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/2998789-definition",
        "html": "See Also\nCreating TCP Connections\nclass NWProtocolTCP.Options\nA container of options for configuring how TCP is used on a connection."
    },
    {
        "title": "cancel()",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel/3204147-cancel",
        "html": "See Also\nManaging Ethernet Channels\ninit(on: NWInterface, etherType: UInt16)\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc start(queue: DispatchQueue)\nStarts the process of registering the channel, and sets the queue on which all channel events are delivered."
    },
    {
        "title": "NWProtocolTCP.Metadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/metadata",
        "html": "Topics\nInspecting TCP State\nvar availableSendBuffer: UInt32\nThe number of available bytes in the TCP send buffer.\nvar availableReceiveBuffer: UInt32\nThe number of available bytes in the TCP receive buffer.\nRelationships\nInherits From\nNWProtocolMetadata"
    },
    {
        "title": "port",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998665-port",
        "html": "Discussion\n\nThe listener's port is available once the listener is in the ready state.\n\nSee Also\nCreating Listeners\ninit(using: NWParameters, on: NWEndpoint.Port)\nInitializes a network listener, with an optional local port.\nfunc start(queue: DispatchQueue)\nRegisters for listening, and sets the queue on which all listener events are delivered.\nvar stateUpdateHandler: (NWListener.State) -> Void)?\nA handler that receives listener state updates.\nenum NWListener.State\nStates indicating whether a listener is able to accept incoming connections.\nfunc cancel()\nStops listening for inbound connections."
    },
    {
        "title": "NWParameters.PrivacyContext",
        "url": "https://developer.apple.com/documentation/network/nwparameters/privacycontext",
        "html": "Topics\nConfiguring Custom Privacy Settings\ninit(description: String)\nInitializes a privacy context with a description string.\nstatic let `default`: NWParameters.PrivacyContext\nThe privacy context that applies to all connections that do not use a custom context.\nfunc disableLogging()\nDisables system logging of connection activity.\nfunc flushCache()\nFlushes all cached data, such as TLS session state, created by connections associated with the privacy context.\nvar debugDescription: String\nThe description string you provide when creating the context.\nRequiring Encrypted DNS\nfunc requireEncryptedNameResolution(Bool, fallbackResolver: NWParameters.PrivacyContext.ResolverConfiguration?)\nRequires that any DNS name resolution for connections associated with this context use encrypted transports, such as TLS or HTTPS.\nenum NWParameters.PrivacyContext.ResolverConfiguration\nA DNS server configuration that uses TLS or HTTPS.\nConfiguring Proxies\nvar proxyConfigurations: [ProxyConfiguration]\nApplies proxy configurations for all connections associated with this context.\nstruct ProxyConfiguration\nA proxy configuration for Relays, Oblivious HTTP, HTTP CONNECT, or SOCKSv5.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nConfiguring Privacy Settings\nfunc setPrivacyContext(NWParameters.PrivacyContext)\nAssociates a privacy context with any connections or listeners that use the parameters."
    },
    {
        "title": "NWParameters.Attribution",
        "url": "https://developer.apple.com/documentation/network/nwparameters/attribution",
        "html": "Topics\nEnumeration Cases\ncase developer\ncase user\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWParameters.Attribution, NWParameters.Attribution) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWParameters.Attribution, NWParameters.Attribution) -> Bool\nRelationships\nConforms To\nSendable"
    },
    {
        "title": "applicationService",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3952716-applicationservice",
        "html": "Discussion\n\nThe default parameters set up an encrypted connection with another device on the local network. You can use these parameters as-is, or you can add a NWProtocolFramer to provide application-level messaging support."
    },
    {
        "title": "acceptLocalOnly",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998690-acceptlocalonly",
        "html": "See Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections."
    },
    {
        "title": "allowLocalEndpointReuse",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998692-allowlocalendpointreuse",
        "html": "See Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "allowFastOpen",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998691-allowfastopen",
        "html": "Discussion\n\nWhen fast open is enabled on a connection, the application is expected to send its early data to be included with the handshake as idempotent data. This data can be sent before or after calling start.\n\nSee Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link.\nRelated Documentation\ncase idempotent\nMark the sent data as idempotent\u2014data that can be sent multiple times."
    },
    {
        "title": "start(queue:)",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998669-start",
        "html": "See Also\nCreating Listeners\ninit(using: NWParameters, on: NWEndpoint.Port)\nInitializes a network listener, with an optional local port.\nvar stateUpdateHandler: (NWListener.State) -> Void)?\nA handler that receives listener state updates.\nenum NWListener.State\nStates indicating whether a listener is able to accept incoming connections.\nvar port: NWEndpoint.Port?\nThe port on which the listener can accept connections.\nfunc cancel()\nStops listening for inbound connections."
    },
    {
        "title": "preferNoProxies",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998701-prefernoproxies",
        "html": "See Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "expiredDNSBehavior",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3003635-expireddnsbehavior",
        "html": "See Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "includePeerToPeer",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3020639-includepeertopeer",
        "html": "See Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "requiresDNSSECValidation",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3952717-requiresdnssecvalidation",
        "html": "See Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "multipathServiceType",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998700-multipathservicetype",
        "html": "See Also\nCustomizing Connection Options\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "prohibitedInterfaces",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998704-prohibitedinterfaces",
        "html": "See Also\nSelecting Paths\nvar requiredInterfaceType: NWInterface.InterfaceType\nAn interface type to require on connections and listeners.\nvar requiredInterface: NWInterface?\nA specific interface to require on connections, listeners, and browsers.\nvar requiredLocalEndpoint: NWEndpoint?\nA specific local IP address and port to use for connections and listeners.\nvar prohibitConstrainedPaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nvar prohibitExpensivePaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as expensive.\nvar prohibitedInterfaceTypes: [NWInterface.InterfaceType]?\nA list of interface types that connections, listeners, and browsers will not use."
    },
    {
        "title": "prohibitConstrainedPaths",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3200461-prohibitconstrainedpaths",
        "html": "See Also\nSelecting Paths\nvar requiredInterfaceType: NWInterface.InterfaceType\nAn interface type to require on connections and listeners.\nvar requiredInterface: NWInterface?\nA specific interface to require on connections, listeners, and browsers.\nvar requiredLocalEndpoint: NWEndpoint?\nA specific local IP address and port to use for connections and listeners.\nvar prohibitExpensivePaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as expensive.\nvar prohibitedInterfaceTypes: [NWInterface.InterfaceType]?\nA list of interface types that connections, listeners, and browsers will not use.\nvar prohibitedInterfaces: [NWInterface]?\nA list of specific interfaces that connections and listeners will not use."
    },
    {
        "title": "requiredInterface",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998705-requiredinterface",
        "html": "See Also\nSelecting Paths\nvar requiredInterfaceType: NWInterface.InterfaceType\nAn interface type to require on connections and listeners.\nvar requiredLocalEndpoint: NWEndpoint?\nA specific local IP address and port to use for connections and listeners.\nvar prohibitConstrainedPaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nvar prohibitExpensivePaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as expensive.\nvar prohibitedInterfaceTypes: [NWInterface.InterfaceType]?\nA list of interface types that connections, listeners, and browsers will not use.\nvar prohibitedInterfaces: [NWInterface]?\nA list of specific interfaces that connections and listeners will not use."
    },
    {
        "title": "requiredLocalEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998707-requiredlocalendpoint",
        "html": "See Also\nSelecting Paths\nvar requiredInterfaceType: NWInterface.InterfaceType\nAn interface type to require on connections and listeners.\nvar requiredInterface: NWInterface?\nA specific interface to require on connections, listeners, and browsers.\nvar prohibitConstrainedPaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nvar prohibitExpensivePaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as expensive.\nvar prohibitedInterfaceTypes: [NWInterface.InterfaceType]?\nA list of interface types that connections, listeners, and browsers will not use.\nvar prohibitedInterfaces: [NWInterface]?\nA list of specific interfaces that connections and listeners will not use."
    },
    {
        "title": "prohibitedInterfaceTypes",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998703-prohibitedinterfacetypes",
        "html": "See Also\nSelecting Paths\nvar requiredInterfaceType: NWInterface.InterfaceType\nAn interface type to require on connections and listeners.\nvar requiredInterface: NWInterface?\nA specific interface to require on connections, listeners, and browsers.\nvar requiredLocalEndpoint: NWEndpoint?\nA specific local IP address and port to use for connections and listeners.\nvar prohibitConstrainedPaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nvar prohibitExpensivePaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as expensive.\nvar prohibitedInterfaces: [NWInterface]?\nA list of specific interfaces that connections and listeners will not use."
    },
    {
        "title": "requiredInterfaceType",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998706-requiredinterfacetype",
        "html": "See Also\nSelecting Paths\nvar requiredInterface: NWInterface?\nA specific interface to require on connections, listeners, and browsers.\nvar requiredLocalEndpoint: NWEndpoint?\nA specific local IP address and port to use for connections and listeners.\nvar prohibitConstrainedPaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nvar prohibitExpensivePaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as expensive.\nvar prohibitedInterfaceTypes: [NWInterface.InterfaceType]?\nA list of interface types that connections, listeners, and browsers will not use.\nvar prohibitedInterfaces: [NWInterface]?\nA list of specific interfaces that connections and listeners will not use."
    },
    {
        "title": "NWProtocol",
        "url": "https://developer.apple.com/documentation/network/nwprotocol",
        "html": "Topics\nAdding Protocols to Connections\nclass NWProtocolOptions\nThe abstract superclass for configuring the options of a network protocol.\nclass NWProtocolDefinition\nThe abstract superclass for identifying a network protocol.\nInteracting with Protocols\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nRelationships\nConforms To\nSendable\nSee Also\nModifying Protocol Stacks\nvar defaultProtocolStack: NWParameters.ProtocolStack\nThe protocol stack used by connections and listeners.\nclass NWParameters.ProtocolStack\nAn ordered set of protocol options that define the protocols that connections and listeners use."
    },
    {
        "title": "defaultProtocolStack",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998695-defaultprotocolstack",
        "html": "See Also\nModifying Protocol Stacks\nclass NWParameters.ProtocolStack\nAn ordered set of protocol options that define the protocols that connections and listeners use.\nclass NWProtocol\nThe abstract superclass used by Network framework protocols and by custom network protocols that you define."
    },
    {
        "title": "quicDatagram(alpn:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3962525-quicdatagram",
        "html": "Parameters\nalpn\n\nA set of supported Application-Layer Protocol Negotiation values.\n\nSee Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "quic(alpn:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3851026-quic",
        "html": "Parameters\nalpn\n\nA set of supported Application-Layer Protocol Negotiation values.\n\nSee Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "udp",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998711-udp",
        "html": "See Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "hashValue",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/2998614-hashvalue",
        "html": "Relationships\nFrom Protocol\nHashable"
    },
    {
        "title": "tcp",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998709-tcp",
        "html": "See Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "tls",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998710-tls",
        "html": "See Also\nCreating Parameters\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "dtls",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998696-dtls",
        "html": "See Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/2998580",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nEndpoint Properties\nvar interface: NWInterface?\nThe optional interface associated with this endpoint, such as the interface on which it was discovered.\nvar debugDescription: String\nThe description of this endpoint.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/2998613-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nEndpoint Properties\nvar interface: NWInterface?\nThe optional interface associated with this endpoint, such as the interface on which it was discovered.\nstatic func != (NWEndpoint, NWEndpoint) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)"
    },
    {
        "title": "NWProtocolTCP.Options",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp/options",
        "html": "Topics\nCustomizing TCP Options\ninit()\nInitializes a default set of TCP connection options.\nvar enableFastOpen: Bool\nA Boolean that enables TCP Fast Open on a connection.\nvar maximumSegmentSize: Int\nTCP's maximum segment size in bytes.\nvar noDelay: Bool\nA Boolean that disables Nagle's algorithm for TCP.\nvar noOptions: Bool\nA Boolean that sets TCP into no-options mode.\nvar noPush: Bool\nA Boolean that sets TCP into no-push mode.\nvar retransmitFinDrop: Bool\nA Boolean that causes TCP to drop its connection after not receiving an ACK packet after a FIN packet.\nvar disableAckStretching: Bool\nA Boolean that disables TCP acknowledgment stretching.\nvar disableECN: Bool\nA Boolean that disables negotiation of Explicit Congestion Notification markings.\nConfiguring Keepalives\nvar enableKeepalive: Bool\nA Boolean that enables TCP keepalives.\nvar keepaliveIdle: Int\nThe number of seconds of idleness that TCP waits before sending keepalive probes.\nvar keepaliveCount: Int\nThe number of keepalive probes that TCP sends before terminating the connection.\nvar keepaliveInterval: Int\nThe number of seconds that TCP waits between sending keepalive probes.\nSetting Timeouts\nvar connectionTimeout: Int\nThe number of seconds that TCP waits before timing out its handshake.\nvar connectionDropTime: Int\nThe timeout, in seconds, for TCP retransmission attempts.\nvar persistTimeout: Int\nThe TCP persist timeout, in seconds, as defined by RFC 6429.\nRelationships\nInherits From\nNWProtocolOptions\nSee Also\nCreating TCP Connections\nstatic let definition: NWProtocolDefinition\nThe system definition of the Transport Control Protocol."
    },
    {
        "title": "send(content:to:message:completion:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3600705-send",
        "html": "Parameters\ncontent\n\nThe data to send.\n\nto\n\nAn optional endpoint that specifies a member of the group that receives the data. If the endpoint is nil, the data will be sent to the entire group.\n\nmessage\n\nThe metadata that defines how the message is sent.\n\ncompletion\n\nA completion that notifies you when the connection group has processed and sent the data.\n\nSee Also\nSending and Receiving Group Messages\nfunc setReceiveHandler(maximumMessageSize: Int, rejectOversizedMessages: Bool, handler: (NWConnectionGroup.Message, Data?, Bool) -> Void)?)\nSets a handler that receives inbound messages from members of the group.\nclass NWConnectionGroup.Message\nAn object that represents a message that you send or receive within a group, and that contains protocol metadata and send properties."
    },
    {
        "title": "setReceiveHandler(maximumMessageSize:rejectOversizedMessages:handler:)",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3600706-setreceivehandler",
        "html": "See Also\nSending and Receiving Group Messages\nfunc send(content: Data?, to: NWEndpoint?, message: NWConnectionGroup.Message, completion: (NWError?) -> Void)\nSends data to the entire group, or to a specific member of the group.\nclass NWConnectionGroup.Message\nAn object that represents a message that you send or receive within a group, and that contains protocol metadata and send properties."
    },
    {
        "title": "NWConnectionGroup.Message",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/message",
        "html": "Topics\nInspecting Received Messages\nvar remoteEndpoint: NWEndpoint?\nThe endpoint that originates the message you receive.\nvar localEndpoint: NWEndpoint?\nThe local address and port you use to receive the message.\nvar path: NWPath?\nThe network path on which you receive the message.\nReplying to Received Messages\nfunc reply(content: Data?, message: NWConnectionGroup.Message)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc extractConnection() -> NWConnection?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nSending Messages\nstatic let `default`: NWConnectionGroup.Message\nA static object you use to send a message with default properties.\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context you use to send data.\nInitializers\ninit(nw: nw_content_context_t)\nInstance Methods\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRelationships\nInherits From\nNWConnection.ContentContext\nSee Also\nSending and Receiving Group Messages\nfunc setReceiveHandler(maximumMessageSize: Int, rejectOversizedMessages: Bool, handler: (NWConnectionGroup.Message, Data?, Bool) -> Void)?)\nSets a handler that receives inbound messages from members of the group.\nfunc send(content: Data?, to: NWEndpoint?, message: NWConnectionGroup.Message, completion: (NWError?) -> Void)\nSends data to the entire group, or to a specific member of the group."
    },
    {
        "title": "cancel()",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584959-cancel",
        "html": "See Also\nManaging Groups\nvar stateUpdateHandler: (NWConnectionGroup.State) -> Void)?\nA handler that receives connection group state updates.\nenum NWConnectionGroup.State\nStates that indicate whether you can use a connection group to send and receive messages.\nvar state: NWConnectionGroup.State\nThe current state of the connection group."
    },
    {
        "title": "NWConnectionGroup.State",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/state",
        "html": "Topics\nStates\ncase setup\nYou have not yet started the connection group.\ncase waiting(NWError)\nThe connection group is waiting for a network path change.\ncase ready\nThe connection group is joined, and ready to send and receive data.\ncase failed(NWError)\nThe connection group encountered a fatal error.\ncase cancelled\nThe connection group has been canceled.\nOperator Functions\nstatic func != (NWConnectionGroup.State, NWConnectionGroup.State) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWConnectionGroup.State, NWConnectionGroup.State) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nManaging Groups\nvar stateUpdateHandler: (NWConnectionGroup.State) -> Void)?\nA handler that receives connection group state updates.\nvar state: NWConnectionGroup.State\nThe current state of the connection group.\nfunc cancel()\nCancels the connection group object and leaves the network group."
    },
    {
        "title": "stateUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup/3584969-stateupdatehandler",
        "html": "See Also\nManaging Groups\nenum NWConnectionGroup.State\nStates that indicate whether you can use a connection group to send and receive messages.\nvar state: NWConnectionGroup.State\nThe current state of the connection group.\nfunc cancel()\nCancels the connection group object and leaves the network group."
    },
    {
        "title": "serviceRegistrationUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwlistener/2998668-serviceregistrationupdatehandler",
        "html": "See Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nvar service: NWListener.Service?\nA Bonjour service that advertises the listener on the local network.\nstruct NWListener.Service\nA description used to advertise the Bonjour service that a listener provides.\nenum NWListener.ServiceRegistrationChange\nChanges to how a network listener's service is advertised."
    },
    {
        "title": "NWListener.ServiceRegistrationChange",
        "url": "https://developer.apple.com/documentation/network/nwlistener/serviceregistrationchange",
        "html": "Topics\nChanges\ncase add(NWEndpoint)\nThe service is now advertising a new endpoint.\ncase remove(NWEndpoint)\nThe service is no longer advertising a specific endpoint.\nSee Also\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nvar service: NWListener.Service?\nA Bonjour service that advertises the listener on the local network.\nstruct NWListener.Service\nA description used to advertise the Bonjour service that a listener provides.\nvar serviceRegistrationUpdateHandler: (NWListener.ServiceRegistrationChange) -> Void)?\nA handler that receives updates for the service endpoint being advertised."
    },
    {
        "title": "IPv4Address",
        "url": "https://developer.apple.com/documentation/network/ipv4address",
        "html": "Topics\nCreating Addresses\ninit?(String)\nInitializes an IPv4 address with a string.\ninit?(Data, NWInterface?)\nInitializes an IPv4 address with data.\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IPv4 address.\nlet interface: NWInterface?\nThe interface associated with this address.\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\nvar debugDescription: String\nThe description of the IP address.\nSetting Well-Known Addresses\nstatic let any: IPv4Address\nThe unspecified address (0.0.0.0).\nstatic let broadcast: IPv4Address\nThe local broadcast address (255.255.255.255).\nstatic let loopback: IPv4Address\nThe device's loopback address (127.0.0.1).\nstatic let allHostsGroup: IPv4Address\nThe multicast group for all hosts on the network segment (224.0.0.1).\nstatic let allRoutersGroup: IPv4Address\nThe multicast group for all routers on the network segment (224.0.0.2).\nstatic let allReportsGroup: IPv4Address\nThe multicast group for all IGMPv3 reports (224.0.0.22).\nstatic let mdnsGroup: IPv4Address\nThe multicast group for multicast DNS (224.0.0.251).\nComparing Addresses\nstatic func == (IPv4Address, IPv4Address) -> Bool\nstatic func != (IPv4Address, IPv4Address) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nInstance Properties\nvar hashValue: Int\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nIPAddress\nSee Also\nInternet Addresses\nprotocol IPAddress\nAn abstract protocol you use to interact with IP addresses.\nstruct IPv6Address\nA structure containing an IPv6 address."
    },
    {
        "title": "NWEndpoint.Port",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/port",
        "html": "Topics\nCreating Ports\ninit?(String)\nInitializes a port with a string.\ninit?(rawValue: UInt16)\nInitializes a port with a raw UInt16 value.\ninit(integerLiteral: NWEndpoint.Port.IntegerLiteralType)\nInitializes a port with a literal type.\ntypealias NWEndpoint.Port.IntegerLiteralType\nA literal type defined for ports.\nSetting Well-Known Ports\nstatic let any: NWEndpoint.Port\nThe unspecified port (port 0).\nstatic let ssh: NWEndpoint.Port\nThe Secure Shell port (port 22).\nstatic let smtp: NWEndpoint.Port\nThe Simple Mail Transfer Protocol port (port 25).\nstatic let http: NWEndpoint.Port\nThe Hypertext Transfer Protocol port (port 80).\nstatic let pop: NWEndpoint.Port\nThe Post Office Protocol port (port 110).\nstatic let imap: NWEndpoint.Port\nThe Internet Message Access Protocol port (port 143).\nstatic let https: NWEndpoint.Port\nThe Secure Hypertext Transfer Protocol port (port 443).\nstatic let imaps: NWEndpoint.Port\nThe Secure Internet Message Access Protocol port (port 993).\nstatic let socks: NWEndpoint.Port\nThe SOCKS proxy protocol port (port 1080).\nComparing Ports\nvar rawValue: UInt16\nvar debugDescription: String\nstatic func != (NWEndpoint.Port, NWEndpoint.Port) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int\nType Aliases\ntypealias NWEndpoint.Port.RawValue\nRelationships\nConforms To\nCustomDebugStringConvertible\nExpressibleByIntegerLiteral\nHashable\nRawRepresentable\nSendable\nSee Also\nHost and Ports\nenum NWEndpoint.Host\nA name or address that identifies a network endpoint."
    },
    {
        "title": "NWEndpoint.url(_:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/url",
        "html": "See Also\nEndpoint Types\ncase hostPort(host: NWEndpoint.Host, port: NWEndpoint.Port)\nAn endpoint represented as a host and port, with the host including both names and addresses.\ncase service(name: String, type: String, domain: String, interface: NWInterface?)\nAn endpoint represented as a Bonjour service.\ncase unix(path: String)\nAn endpoint represented as a UNIX domain path."
    },
    {
        "title": "IPAddress",
        "url": "https://developer.apple.com/documentation/network/ipaddress",
        "html": "Topics\nCreating Addresses\ninit?(String)\nInitializes an IP address with a string.\n\nRequired\n\ninit?(Data, NWInterface?)\nInitializes an IP address with data.\n\nRequired\n\nInspecting Address Properties\nvar rawValue: Data\nThe raw data of an IP address.\n\nRequired\n\nvar interface: NWInterface?\nThe interface associated with this address, such as the IPv6 scoped interface.\n\nRequired\n\nvar isLinkLocal: Bool\nA Boolean indicating whether this address is in a link-local range.\n\nRequired\n\nvar isLoopback: Bool\nA Boolean indicating whether this address is a loopback address for the local device.\n\nRequired\n\nvar isMulticast: Bool\nA Boolean indicating whether this address is a multicast address.\n\nRequired\n\nRelationships\nInherits From\nSendable\nConforming Types\nIPv4Address\nIPv6Address\nSee Also\nInternet Addresses\nstruct IPv4Address\nA structure containing an IPv4 address.\nstruct IPv6Address\nA structure containing an IPv6 address."
    },
    {
        "title": "NWEndpoint.Host",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/host",
        "html": "Topics\nCreating Hosts\ninit(String)\nInitializes a host with a string.\nAccessing Host Types\ncase name(String, NWInterface?)\nA host represented as a name.\ncase ipv4(IPv4Address)\nA host represented as an IPv4 address.\ncase ipv6(IPv6Address)\nA host represented as an IPv6 address.\nRequiring Interfaces\nvar interface: NWInterface?\nThe interface associated with this host, such as the interface scope stored in an IPv6 address.\nComparing Hosts\ninit(unicodeScalarLiteral: StringLiteralType)\nCreates an instance initialized to the given value.\ninit(stringLiteral: NWEndpoint.Host.StringLiteralType)\ntypealias NWEndpoint.Host.StringLiteralType\ninit(extendedGraphemeClusterLiteral: String)\nCreates an instance initialized to the given value.\nvar debugDescription: String\nstatic func != (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nType Aliases\ntypealias NWEndpoint.Host.ExtendedGraphemeClusterLiteralType\ntypealias NWEndpoint.Host.UnicodeScalarLiteralType\nInstance Properties\nvar hashValue: Int\nOperator Functions\nstatic func == (NWEndpoint.Host, NWEndpoint.Host) -> Bool\nRelationships\nConforms To\nCustomDebugStringConvertible\nExpressibleByStringLiteral\nHashable\nSendable\nSee Also\nHost and Ports\nstruct NWEndpoint.Port\nA port number you use along with a host to identify a network endpoint."
    },
    {
        "title": "NWEndpoint.service(name:type:domain:interface:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/service_name_type_domain_interface",
        "html": "See Also\nEndpoint Types\ncase hostPort(host: NWEndpoint.Host, port: NWEndpoint.Port)\nAn endpoint represented as a host and port, with the host including both names and addresses.\ncase url(URL)\nAn endpoint represented as a URL, with host and port values inferred from the URL.\ncase unix(path: String)\nAn endpoint represented as a UNIX domain path."
    },
    {
        "title": "debugDescription",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998562-debugdescription",
        "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nInspecting Connections\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetrieves the connection-wide metadata for a specific protocol.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet endpoint: NWEndpoint\nThe remote endpoint with which the connection was initialized.\nlet parameters: NWParameters\nThe parameters with which the connection was initialized.\nvar queue: DispatchQueue?\nThe queue on which connection events are delivered."
    },
    {
        "title": "endpoint",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998563-endpoint",
        "html": "See Also\nInspecting Connections\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetrieves the connection-wide metadata for a specific protocol.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet parameters: NWParameters\nThe parameters with which the connection was initialized.\nvar queue: DispatchQueue?\nThe queue on which connection events are delivered.\nvar debugDescription: String\nThe description of the connection."
    },
    {
        "title": "queue",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998570-queue",
        "html": "See Also\nInspecting Connections\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetrieves the connection-wide metadata for a specific protocol.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet endpoint: NWEndpoint\nThe remote endpoint with which the connection was initialized.\nlet parameters: NWParameters\nThe parameters with which the connection was initialized.\nvar debugDescription: String\nThe description of the connection."
    },
    {
        "title": "parameters",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998568-parameters",
        "html": "See Also\nInspecting Connections\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetrieves the connection-wide metadata for a specific protocol.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet endpoint: NWEndpoint\nThe remote endpoint with which the connection was initialized.\nvar queue: DispatchQueue?\nThe queue on which connection events are delivered.\nvar debugDescription: String\nThe description of the connection."
    },
    {
        "title": "NWProtocolMetadata",
        "url": "https://developer.apple.com/documentation/network/nwprotocolmetadata",
        "html": "Overview\n\nYou can use metadata when sending and receiving messages, as well as when inspecting connection properties.\n\nRelationships\nConforms To\nSendable\nSee Also\nInspecting Connections\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetrieves the connection-wide metadata for a specific protocol.\nlet endpoint: NWEndpoint\nThe remote endpoint with which the connection was initialized.\nlet parameters: NWParameters\nThe parameters with which the connection was initialized.\nvar queue: DispatchQueue?\nThe queue on which connection events are delivered.\nvar debugDescription: String\nThe description of the connection."
    },
    {
        "title": "metadata(definition:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998567-metadata",
        "html": "See Also\nInspecting Connections\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet endpoint: NWEndpoint\nThe remote endpoint with which the connection was initialized.\nlet parameters: NWParameters\nThe parameters with which the connection was initialized.\nvar queue: DispatchQueue?\nThe queue on which connection events are delivered.\nvar debugDescription: String\nThe description of the connection."
    },
    {
        "title": "NWConnection.PendingDataTransferReport",
        "url": "https://developer.apple.com/documentation/network/nwconnection/pendingdatatransferreport",
        "html": "Topics\nCollecting Reports\nfunc collect(queue: DispatchQueue, completion: (NWConnection.DataTransferReport) -> Void)\nStops an outstanding data transfer report and delivers the result.\nRelationships\nConforms To\nSendable\nSee Also\nCollecting Connection Metrics\nCollecting Network Connection Metrics\nUse reports to understand how DNS and protocol handshakes impact connection establishment.\nfunc requestEstablishmentReport(queue: DispatchQueue, completion: (NWConnection.EstablishmentReport?) -> Void)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\nstruct NWConnection.EstablishmentReport\nA report that provides metrics about the establishment of a connection.\nfunc startDataTransferReport() -> NWConnection.PendingDataTransferReport\nBegins a new data transfer report, which can later be collected.\nstruct NWConnection.DataTransferReport\nA report that provides metrics about data being sent and received on a connection."
    },
    {
        "title": "requestEstablishmentReport(queue:completion:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/3200452-requestestablishmentreport",
        "html": "See Also\nCollecting Connection Metrics\nCollecting Network Connection Metrics\nUse reports to understand how DNS and protocol handshakes impact connection establishment.\nstruct NWConnection.EstablishmentReport\nA report that provides metrics about the establishment of a connection.\nfunc startDataTransferReport() -> NWConnection.PendingDataTransferReport\nBegins a new data transfer report, which can later be collected.\nclass NWConnection.PendingDataTransferReport\nAn outstanding data transfer report that has yet to be collected.\nstruct NWConnection.DataTransferReport\nA report that provides metrics about data being sent and received on a connection."
    },
    {
        "title": "startDataTransferReport()",
        "url": "https://developer.apple.com/documentation/network/nwconnection/3200453-startdatatransferreport",
        "html": "See Also\nCollecting Connection Metrics\nCollecting Network Connection Metrics\nUse reports to understand how DNS and protocol handshakes impact connection establishment.\nfunc requestEstablishmentReport(queue: DispatchQueue, completion: (NWConnection.EstablishmentReport?) -> Void)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\nstruct NWConnection.EstablishmentReport\nA report that provides metrics about the establishment of a connection.\nclass NWConnection.PendingDataTransferReport\nAn outstanding data transfer report that has yet to be collected.\nstruct NWConnection.DataTransferReport\nA report that provides metrics about data being sent and received on a connection."
    },
    {
        "title": "NWConnection.DataTransferReport",
        "url": "https://developer.apple.com/documentation/network/nwconnection/datatransferreport",
        "html": "Topics\nExamining Data Transfer\nlet aggregatePathReport: NWConnection.DataTransferReport.PathReport\nA report that sums counts across all network paths.\nlet pathReports: [NWConnection.DataTransferReport.PathReport]\nAn array of reports for each network path the connection used.\nstruct NWConnection.DataTransferReport.PathReport\nA report that contains details about data transfer over a single network path.\nSummarizing Reports\nlet duration: TimeInterval\nThe duration of the data transfer report, from when it was started to when it was collected.\nvar debugDescription: String\nThe description of the report.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nCollecting Connection Metrics\nCollecting Network Connection Metrics\nUse reports to understand how DNS and protocol handshakes impact connection establishment.\nfunc requestEstablishmentReport(queue: DispatchQueue, completion: (NWConnection.EstablishmentReport?) -> Void)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\nstruct NWConnection.EstablishmentReport\nA report that provides metrics about the establishment of a connection.\nfunc startDataTransferReport() -> NWConnection.PendingDataTransferReport\nBegins a new data transfer report, which can later be collected.\nclass NWConnection.PendingDataTransferReport\nAn outstanding data transfer report that has yet to be collected."
    },
    {
        "title": "Collecting Network Connection Metrics",
        "url": "https://developer.apple.com/documentation/network/nwconnection/collecting_network_connection_metrics",
        "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC 2019 session 713: Advances in Networking, Part 2.\n\nSee Also\nCollecting Connection Metrics\nfunc requestEstablishmentReport(queue: DispatchQueue, completion: (NWConnection.EstablishmentReport?) -> Void)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\nstruct NWConnection.EstablishmentReport\nA report that provides metrics about the establishment of a connection.\nfunc startDataTransferReport() -> NWConnection.PendingDataTransferReport\nBegins a new data transfer report, which can later be collected.\nclass NWConnection.PendingDataTransferReport\nAn outstanding data transfer report that has yet to be collected.\nstruct NWConnection.DataTransferReport\nA report that provides metrics about data being sent and received on a connection."
    },
    {
        "title": "cancel()",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998559-cancel",
        "html": "See Also\nCanceling Connections\nfunc forceCancel()\nCancels the connection and immediately disconnects any established network protocols.\nfunc cancelCurrentEndpoint()\nCauses the current endpoint to be rejected, allowing the connection to try another resolved address."
    },
    {
        "title": "NWConnection.ContentContext",
        "url": "https://developer.apple.com/documentation/network/nwconnection/contentcontext",
        "html": "Overview\n\nFor sending, you should use defaultMessage unless there is a reason to override some values.\n\nYou can pass finalMessage to mark the final message in a connection. Once this context is used for sending, and the send is marked as complete, no more data can be sent on the connection.\n\nIf you are using a protocol that expects message content, like WebSocket or a custom framer, create a custom context and set metadata using protocolMetadata.\n\nTopics\nUsing Constant Send Contexts\nstatic let defaultMessage: NWConnection.ContentContext\nA static context representing a message with default properties.\nstatic let finalMessage: NWConnection.ContentContext\nA static context that's marked as the final message in a connection.\nstatic let defaultStream: NWConnection.ContentContext\nA static context representing the total stream of bytes on a connection.\nCreating Custom Send Contexts\ninit(identifier: String, expiration: UInt64, priority: Double, isFinal: Bool, antecedent: NWConnection.ContentContext?, metadata: [NWProtocolMetadata]?)\nInitializes a custom message context.\nlet identifier: String\nThe identifier of the message, used for debugging.\nvar protocolMetadata: [NWProtocolMetadata]\nAn array of protocol metadata used to configure per-message or per-packet properties.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet antecedent: NWConnection.ContentContext?\nAn optional message context that must be sent before the context you are sending.\nlet expirationMilliseconds: UInt64\nA number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nlet relativePriority: Double\nA relative value of priority used to reorder contexts when sending.\nInspecting Receive Contexts\nlet isFinal: Bool\nA Boolean indicating whether this context represents the final message being sent or received.\nfunc protocolMetadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetreives the metadata associated with a specific protocol.\nRelationships\nConforms To\nSendable\nSee Also\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "maximumDatagramSize",
        "url": "https://developer.apple.com/documentation/network/nwconnection/3200451-maximumdatagramsize",
        "html": "See Also\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties."
    },
    {
        "title": "receiveMessage(completion:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/3020638-receivemessage",
        "html": "Parameters\ncompletion\n\nA receive completion is invoked exactly once for a call to receive. The completion indicates that the requested content has been received (in which case the content is delivered), or that an error has occurred.\n\nThe completion delivers the received content, which may be nil if the message is complete or an error occurred, the message context, a flag indicating if the message is complete, and any associated error.\n\nDiscussion\n\nReceiving messages allows you to deal with complete datagrams or application-layer messages without needing to reconstruct a stream.\n\nIf you are using UDP, receiving a message will deliver a single datagram.\n\nIf you request to receive a message on a protocol that is otherwise an unbounded bytestream, like TCP or TLS, note that this will not deliver any data until the stream is closed by the peer.\n\nIn order to use messages on top of a bytestream protocol, add a protocol such as NWProtocolWebSocket or a custom NWProtocolFramer to your protocol stack.\n\nSee Also\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "send(content:contentContext:isComplete:completion:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/3358306-send",
        "html": "Parameters\ncontent\n\nThe data to send on the connection. May be nil if this send marks its context as complete, such as by sending finalMessage as the context and marking the send complete to send a write-close.\n\ncontentContext\n\nThe context associated with the content, which represents a logical message to be sent on the connection. All content sent within a single context will be sent as an in-order unit, up until the point that the context is marked complete. Once a context is marked complete, it may be re-used as a new logical message. Protocols like TCP that cannot send multiple independent messages at once (serial bytestreams) will only start processing a new context once the prior context has been marked complete. Defaults to defaultMessage.\n\nisComplete\n\nA flag indicating if the caller\u2019s sending context (logical message) is now complete. Until a context is marked complete, content sent for other contexts may not be sent immediately (if the protocol requires sending bytes serially, like TCP). For datagram protocols, like UDP, this flag indicates that the content represents a complete datagram.\n\nWhen sending using streaming protocols like TCP, this flag can be used to mark the end of a single message on the stream, of which there may be many. However, it can also indicate that the connection should send a \u201cwrite close\u201d (a TCP FIN) if the sending context is the final context on the connection. Specifically, to send a \u201cwrite close\u201d, pass finalMessage or defaultStream for the context (or create a custom context and set isFinal), and mark the send as complete.\n\ncompletion\n\nA completion handler (NWConnection.SendCompletion.contentProcessed(_:)) to notify the caller when content has been processed by the connection, or a marker that this data is idempotent (NWConnection.SendCompletion.idempotent) and may be sent multiple times as fast open data if allowFastOpen is set.\n\nSee Also\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "send(content:contentContext:isComplete:completion:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/3003626-send",
        "html": "Parameters\ncontent\n\nThe data to send on the connection. May be nil if this send marks its context as complete, such as by sending finalMessage as the context and marking the send complete to send a write-close.\n\ncontentContext\n\nThe context associated with the content, which represents a logical message to be sent on the connection. All content sent within a single context will be sent as an in-order unit, up until the point that the context is marked complete. Once a context is marked complete, it may be re-used as a new logical message. Protocols like TCP that cannot send multiple independent messages at once (serial bytestreams) will only start processing a new context once the prior context has been marked complete. Defaults to defaultMessage.\n\nisComplete\n\nA flag indicating if the caller's sending context (logical message) is now complete. Until a context is marked complete, content sent for other contexts may not be sent immediately (if the protocol requires sending bytes serially, like TCP). For datagram protocols, like UDP, this flag indicates that the content represents a complete datagram.\n\nWhen sending using streaming protocols like TCP, this flag can be used to mark the end of a single message on the stream, of which there may be many. However, it can also indicate that the connection should send a \"write close\" (a TCP FIN) if the sending context is the final context on the connection. Specifically, to send a \"write close\", pass finalMessage or defaultStream for the context (or create a custom context and set isFinal), and mark the send as complete.\n\ncompletion\n\nA completion handler (NWConnection.SendCompletion.contentProcessed(_:)) to notify the caller when content has been processed by the connection, or a marker that this data is idempotent (NWConnection.SendCompletion.idempotent) and may be sent multiple times as fast open data if allowFastOpen is set.\n\nSee Also\nSending and Receiving Data\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "batch(_:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998557-batch",
        "html": "See Also\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "NWConnection.SendCompletion",
        "url": "https://developer.apple.com/documentation/network/nwconnection/sendcompletion",
        "html": "Topics\nCompletions\ncase contentProcessed((NWError?) -> Void)\nProvide a completion handler that's invoked when the sent data is processed by the stack.\ncase idempotent\nMark the sent data as idempotent\u2014data that can be sent multiple times.\nSee Also\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "start(queue:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998575-start",
        "html": "See Also\nCreating Connections\ninit(host: NWEndpoint.Host, port: NWEndpoint.Port, using: NWParameters)\nInitializes a new connection to a host and port.\ninit(to: NWEndpoint, using: NWParameters)\nInitializes a new connection to a remote endpoint.\nfunc restart()\nRestarts a connection that is in the waiting state."
    },
    {
        "title": "NWConnection.State",
        "url": "https://developer.apple.com/documentation/network/nwconnection/state",
        "html": "Topics\nStates\ncase setup\nThe connection has been initialized but not started.\ncase waiting(NWError)\nThe connection is waiting for a network path change.\ncase preparing\nThe connection in the process of being established.\ncase ready\nThe connection is established, and ready to send and receive data.\ncase failed(NWError)\nThe connection has disconnected or encountered an error.\ncase cancelled\nThe connection has been canceled.\nOperator Functions\nstatic func != (NWConnection.State, NWConnection.State) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWConnection.State, NWConnection.State) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nHandling State Updates\nvar state: NWConnection.State\nThe current state of the connection.\nvar stateUpdateHandler: (NWConnection.State) -> Void)?\nA handler that receives connection state updates."
    },
    {
        "title": "stateUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998577-stateupdatehandler",
        "html": "See Also\nHandling State Updates\nvar state: NWConnection.State\nThe current state of the connection.\nenum NWConnection.State\nStates indicating whether a connection can be used to send and receive data."
    },
    {
        "title": "restart()",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998573-restart",
        "html": "Discussion\n\nRestart a connection when it is in the waiting state and you have reason to believe the connection may succeed if it tries again. Connections that are waiting will automatically restart on network path changes.\n\nSee Also\nCreating Connections\ninit(host: NWEndpoint.Host, port: NWEndpoint.Port, using: NWParameters)\nInitializes a new connection to a host and port.\ninit(to: NWEndpoint, using: NWParameters)\nInitializes a new connection to a remote endpoint.\nfunc start(queue: DispatchQueue)\nStarts establishing a connection, and sets the queue on which to deliver all connection events."
    },
    {
        "title": "NWParameters.ExpiredDNSBehavior",
        "url": "https://developer.apple.com/documentation/network/nwparameters/expireddnsbehavior",
        "html": "Topics\nBehaviors\ncase systemDefault\nLet the system determine whether or not to allow expired DNS answers.\ncase allow\nExplicitly allow the use of expired DNS answers.\ncase prohibit\nExplicitly prohibit the use of expired DNS answers.\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWParameters.ExpiredDNSBehavior, NWParameters.ExpiredDNSBehavior) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWParameters.ExpiredDNSBehavior, NWParameters.ExpiredDNSBehavior) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "NWParameters.ServiceClass",
        "url": "https://developer.apple.com/documentation/network/nwparameters/serviceclass",
        "html": "Topics\nService Classes\ncase bestEffort\nA service type to enable Cellular Network Slicing when not setting the other service types.\ncase background\nA service type for high-delay tolerant, high-loss tolerant, elastic flow, and variable size connections.\ncase interactiveVideo\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase interactiveVoice\nA service type for low-delay tolerant, very low-loss tolerant, inelastic flow, and constant packet rate connections.\ncase responsiveData\nA service type for medium-delay tolerant, elastic and inelastic flow, bursty, and long-lived connections.\ncase signaling\nA service for low-loss tolerant, inelastic flow, jitter tolerant, bursty but short rate, and variable size connections.\nAccessing the hash value\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nComparing Service Classes\nstatic func != (NWParameters.ServiceClass, NWParameters.ServiceClass) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWParameters.ServiceClass, NWParameters.ServiceClass) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nRelationships\nConforms To\nSendable\nSee Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "NWParameters.MultipathServiceType",
        "url": "https://developer.apple.com/documentation/network/nwparameters/multipathservicetype",
        "html": "Topics\nMultipath Service Types\ncase disabled\nDisable multipath.\ncase handover\nEnable multipath, but only use other interfaces when the primary interface is lost.\ncase interactive\nEnable multipath to use other interfaces when the primary interface encounters loss or delay.\ncase aggregate\nEnable multipath to maximize bandwidth across multiple interfaces.\nInstance Properties\nvar hashValue: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (NWParameters.MultipathServiceType, NWParameters.MultipathServiceType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (NWParameters.MultipathServiceType, NWParameters.MultipathServiceType) -> Bool\nRelationships\nConforms To\nSendable\nSee Also\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link."
    },
    {
        "title": "Network Data Types",
        "url": "https://developer.apple.com/documentation/network/network_data_types",
        "html": "Topics\nData Types\ntypealias nw_advertise_descriptor_t\nA description used to advertise the Bonjour service that a listener provides.\ntypealias nw_browse_descriptor_t\nA service description used to discover Bonjour services.\ntypealias nw_browse_result_change_t\nFlags describing ways in which discovered services can change between specific results.\ntypealias nw_browse_result_enumerate_interface_t\nA handler that enumerates the interfaces associated with a discovered service.\ntypealias nw_browse_result_t\nA discovered service and metadata about the service.\ntypealias nw_browser_browse_results_changed_handler_t\nA handler that delivers updates about discovered services.\ntypealias nw_browser_state_changed_handler_t\nA handler that delivers browser state updates with associated errors.\ntypealias nw_browser_t\nAn object you use to browse for available network services.\ntypealias nw_connection_boolean_event_handler_t\nA handler that receives Boolean state updates from a connection, such as viability and better path state.\ntypealias nw_connection_group_new_connection_handler_t\ntypealias nw_connection_group_receive_handler_t\nA handler that receives inbound messages from members of the group.\ntypealias nw_connection_group_send_completion_t\nA completion to notify you when data has been processed and sent.\ntypealias nw_connection_group_state_changed_handler_t\nA handler that receives connection group state updates.\ntypealias nw_connection_group_t\nAn object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.\ntypealias nw_connection_path_event_handler_t\nA handler that delivers network path updates.\ntypealias nw_connection_receive_completion_t\nA completion handler that indicates when content has been received by the connection, or that an error was encountered.\ntypealias nw_connection_send_completion_t\nA completion handler that indicates when the connection has finished processing sent content.\ntypealias nw_connection_state_changed_handler_t\nA handler that delivers connection state updates with associated errors.\ntypealias nw_connection_t\nA bidirectional data connection between a local endpoint and a remote endpoint.\ntypealias nw_content_context_t\nA representation of a message to send or receive, containing protocol metadata and send properties.\ntypealias nw_data_transfer_report_collect_block_t\nA block that is delivered when a data transfer report is fully collected.\ntypealias nw_data_transfer_report_t\nA report that provides metrics about data being sent and received on a connection.\ntypealias nw_endpoint_t\nA local or remote endpoint in a network connection.\ntypealias nw_error_t\nThe errors returned by the Network framework.\ntypealias nw_establishment_report_access_block_t\nA block that delivers a connection's establishment report when it's in the ready state.\ntypealias nw_establishment_report_t\nA report that provides metrics about how a connection was established.\ntypealias nw_ethernet_address_t\nA 48-bit Ethernet address.\ntypealias nw_ethernet_channel_receive_handler_t\nA handler that delivers inbound Ethernet frames.\ntypealias nw_ethernet_channel_send_completion_t\nA handler that indicates when an Ethernet frame has been sent, or if an error was encountered.\ntypealias nw_ethernet_channel_state_changed_handler_t\nA handler that delivers Ethernet channel state updates with associated errors.\ntypealias nw_ethernet_channel_t\nAn object you use to send and receive custom Ethernet frames.\ntypealias nw_framer_block_t\nA block to be invoked asynchronously on your framer protocol's scheduling context.\ntypealias nw_framer_cleanup_handler_t\nA handler that tells your protocol to clean up all allocations before being deallocated.\ntypealias nw_framer_input_handler_t\nA handler that notifies your protocol that new inbound data is available to parse.\ntypealias nw_framer_message_dispose_value_t\nA handler that's invoked when your custom value needs to be released due to a message being released or the value being replaced.\ntypealias nw_framer_message_t\nA message for a custom protocol, in which you can store arbitrary key-value pairs.\ntypealias nw_framer_output_handler_t\nA handler that notifies your protocol about a new outbound message.\ntypealias nw_framer_parse_completion_t\nA handler that examines a range of data being sent or received.\ntypealias nw_framer_start_handler_t\nA handler that represents the entry point into your custom protocol.\ntypealias nw_framer_stop_handler_t\nA handler that requests that your protocol send any final messages to close the connection.\ntypealias nw_framer_t\nAn object that represents a single instance of your custom protocol running in a connection.\ntypealias nw_framer_wakeup_handler_t\nA handler that delivers a scheduled wakeup event.\ntypealias nw_group_descriptor_enumerate_endpoints_block_t\nA handler that lists all endpoints added to the group descriptor.\ntypealias nw_group_descriptor_t\nA type that defines a group of endpoints with which you can communicate, such as a multicast group.\ntypealias nw_interface_t\nAn interface that a network connection uses to send and receive data.\ntypealias nw_listener_advertised_endpoint_changed_handler_t\nA handler that indicates changes to the service endpoints being advertised as they are added and removed.\ntypealias nw_listener_new_connection_group_handler_t\ntypealias nw_listener_new_connection_handler_t\nA handler that delivers inbound connections.\ntypealias nw_listener_state_changed_handler_t\nA handler that delivers listener state updates with associated errors.\ntypealias nw_listener_t\nAn object you use to listen for incoming network connections.\ntypealias nw_object_t\nThe generic type for objects in the Network framework.\ntypealias nw_path_enumerate_gateways_block_t\nA block that enumerates the gateways configured on the interfaces available to a path.\ntypealias nw_path_enumerate_interfaces_block_t\nA block that enumerates the interfaces available to a path.\ntypealias nw_path_monitor_cancel_handler_t\nA handler that indicates when a monitor has been cancelled.\ntypealias nw_path_monitor_t\nAn observer that you use to monitor and react to network changes.\ntypealias nw_path_monitor_update_handler_t\nA handler that delivers network path updates.\ntypealias nw_path_t\nAn object that contains information about the properties of the network that a connection uses, or that are available to your app.\ntypealias nw_protocol_metadata_t\nThe abstract superclass for specifying metadata about a network protocol.\ntypealias nw_proxy_domain_enumerator_t\ntypealias nw_report_protocol_enumerator_t\nA block used to enumerate protocol handshakes performed during connection establishment.\ntypealias nw_report_resolution_enumerator_t\nA block used to enumerate resolution steps performed during connection establishment.\ntypealias nw_report_resolution_report_enumerator_t\nIterates a list of resolution steps, as nw_resolution_report_t objects, performed during connection establishment, in order from first resolved to last resolved.\ntypealias nw_resolution_report_t\nA description of a single DNS resolution step.\ntypealias nw_txt_record_access_bytes_t\nA block that provides access to the raw bytes of a TXT record.\ntypealias nw_txt_record_access_key_t\nA block that returns a value in a TXT record dictionary.\ntypealias nw_txt_record_applier_t\nA block that iterates over values and keys in a TXT record dictionary.\ntypealias nw_txt_record_t\nA dictionary representing a TXT record in a DNS packet.\ntypealias nw_ws_additional_header_enumerator_t\nA block that enumerates additional HTTP headers in a WebSocket client request.\ntypealias nw_ws_client_request_handler_t\nA handler that delivers inbound client handshake requests.\ntypealias nw_ws_pong_handler_t\nA handler that indicates that a Pong message has been received for a previously sent Ping message, or that an error was encountered.\ntypealias nw_ws_request_t\nA WebSocket handshake request sent from a client to a server.\ntypealias nw_ws_response_t\nA WebSocket handshake reponse sent from a server to a client.\ntypealias nw_ws_subprotocol_enumerator_t\nA block that enumerates the supported subprotocols in a WebSocket client request."
    },
    {
        "title": "init(tls:tcp:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998699-init",
        "html": "See Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "init(quic:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3802941-init",
        "html": "Parameters\nquic\n\nA QUIC options instance.\n\nSee Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "copy()",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998693-copy",
        "html": "See Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "init(customIPProtocolNumber:)",
        "url": "https://developer.apple.com/documentation/network/nwparameters/3204158-init",
        "html": "Discussion\n\nCreating custom IP protocol connections requires the \"com.apple.developer.networking.custom-protocol\" entitlement.\n\nSee Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/network/nwparameters/2998697-init",
        "html": "See Also\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters."
    },
    {
        "title": "NWBrowser",
        "url": "https://developer.apple.com/documentation/network/nwbrowser",
        "html": "Topics\nEssentials\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nBrowsing for Services\ninit(for: NWBrowser.Descriptor, using: NWParameters)\nInitializes a browser with a type of service to discover.\nenum NWBrowser.Descriptor\nA service description used to discover Bonjour services.\nfunc start(queue: DispatchQueue)\nStarts browsing for services, and sets the queue on which all browser events will be delivered.\nvar browseResultsChangedHandler: (Set<NWBrowser.Result>, Set<NWBrowser.Result.Change>) -> Void)?\nA handler that delivers updates about discovered services.\nstruct NWBrowser.Result\nA set of discovered services and changes from the last result.\nvar browseResults: Set<NWBrowser.Result>\nThe list of discovered services.\nManaging Browsers\nvar stateUpdateHandler: (NWBrowser.State) -> Void)?\nA handler that receives browser state updates.\nenum NWBrowser.State\nStates indicating whether a browser is able to discover services.\nvar state: NWBrowser.State\nThe current state of the browser.\nfunc cancel()\nStops browsing for services.\nInspecting Browsers\nlet descriptor: NWBrowser.Descriptor\nThe service descriptor with which the browser was initialized.\nlet parameters: NWParameters\nThe parameters with which the browser was initialized.\nvar queue: DispatchQueue?\nThe queue on which browser events are delivered.\nvar debugDescription: String\nThe description of the browser.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSee Also\nConnections and Listeners\nclass NWConnection\nA bidirectional data connection between a local endpoint and a remote endpoint.\nclass NWListener\nAn object you use to listen for incoming network connections.\nclass NWConnectionGroup\nAn object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.\nclass NWEthernetChannel\nAn object you use to send and receive custom Ethernet frames."
    },
    {
        "title": "Network Functions",
        "url": "https://developer.apple.com/documentation/network/network_functions",
        "html": "Topics\nFunctions\nfunc nw_advertise_descriptor_copy_txt_record_object(nw_advertise_descriptor_t) -> nw_txt_record_t?\nAccesses the TXT record to advertise with the service.\nfunc nw_advertise_descriptor_create_application_service(UnsafePointer<CChar>) -> nw_advertise_descriptor_t\nfunc nw_advertise_descriptor_create_bonjour_service(UnsafePointer<CChar>?, UnsafePointer<CChar>, UnsafePointer<CChar>?) -> nw_advertise_descriptor_t?\nInitializes a Bonjour service to advertise.\nfunc nw_advertise_descriptor_get_application_service_name(nw_advertise_descriptor_t) -> UnsafePointer<CChar>?\nfunc nw_advertise_descriptor_get_no_auto_rename(nw_advertise_descriptor_t) -> Bool\nChecks whether the service prohibits automatic renaming in the event of a name conflict.\nfunc nw_advertise_descriptor_set_no_auto_rename(nw_advertise_descriptor_t, Bool)\nSets a Boolean to indicate whether the service prohibits automatic renaming in the event of a name conflict.\nfunc nw_advertise_descriptor_set_txt_record(nw_advertise_descriptor_t, UnsafeRawPointer?, Int)\nSets the TXT record as a raw buffer to advertise with the service.\nfunc nw_advertise_descriptor_set_txt_record_object(nw_advertise_descriptor_t, nw_txt_record_t?)\nSets the TXT record to advertise with the service.\nfunc nw_browse_descriptor_create_application_service(UnsafePointer<CChar>) -> nw_browse_descriptor_t\nfunc nw_browse_descriptor_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>?) -> nw_browse_descriptor_t\nInitializes a service descriptor used to discover a Bonjour service.\nfunc nw_browse_descriptor_get_application_service_name(nw_browse_descriptor_t) -> UnsafePointer<CChar>?\nfunc nw_browse_descriptor_get_bonjour_service_domain(nw_browse_descriptor_t) -> UnsafePointer<CChar>?\nAccesses the Bonjour service domain set on a browse descriptor.\nfunc nw_browse_descriptor_get_bonjour_service_type(nw_browse_descriptor_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type set on a browse descriptor.\nfunc nw_browse_descriptor_get_include_txt_record(nw_browse_descriptor_t) -> Bool\nChecks if the browse descriptor requires including associated TXT records with all results.\nfunc nw_browse_descriptor_set_include_txt_record(nw_browse_descriptor_t, Bool)\nRequires including associated TXT records with all results generated for this service descriptor.\nfunc nw_browse_result_copy_endpoint(nw_browse_result_t) -> nw_endpoint_t\nThe discovered service endpoint.\nfunc nw_browse_result_copy_txt_record_object(nw_browse_result_t) -> nw_txt_record_t?\nAccesses the TXT record associated with a discovered service.\nfunc nw_browse_result_enumerate_interfaces(nw_browse_result_t, (nw_interface_t) -> Bool)\nEnumerates the list of interfaces on which the service was discovered.\nfunc nw_browse_result_get_changes(nw_browse_result_t?, nw_browse_result_t?) -> nw_browse_result_change_t\nCompares two discovered services and calculates changes between them.\nfunc nw_browse_result_get_interfaces_count(nw_browse_result_t) -> Int\nAccesses the number of interfaces associated with a discovered service.\nfunc nw_browser_cancel(nw_browser_t)\nStops browsing for services.\nfunc nw_browser_copy_browse_descriptor(nw_browser_t) -> nw_browse_descriptor_t\nAccesses the service descriptor with which the browser was created.\nfunc nw_browser_copy_parameters(nw_browser_t) -> nw_parameters_t\nAccesses the parameters with which the browser was created.\nfunc nw_browser_create(nw_browse_descriptor_t, nw_parameters_t?) -> nw_browser_t\nInitializes a browser with a type of service to discover.\nfunc nw_browser_set_browse_results_changed_handler(nw_browser_t, nw_browser_browse_results_changed_handler_t?)\nSets the handler to receive updates about discovered services.\nfunc nw_browser_set_queue(nw_browser_t, dispatch_queue_t)\nSets the queue on which all browser events will be delivered.\nfunc nw_browser_set_state_changed_handler(nw_browser_t, nw_browser_state_changed_handler_t?)\nSets a handler to receive browser state updates.\nfunc nw_browser_start(nw_browser_t)\nStarts browsing for services.\nfunc nw_connection_access_establishment_report(nw_connection_t, dispatch_queue_t, nw_establishment_report_access_block_t)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\nfunc nw_connection_batch(nw_connection_t, () -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nfunc nw_connection_cancel(nw_connection_t)\nCancels the connection and gracefully disconnects any established network protocols.\nfunc nw_connection_cancel_current_endpoint(nw_connection_t)\nCauses the current endpoint to be rejected, allowing the connection to try another resolved address.\nfunc nw_connection_copy_current_path(nw_connection_t) -> nw_path_t?\nAccesses the network path the connection is using.\nfunc nw_connection_copy_description(nw_connection_t) -> UnsafeMutablePointer<CChar>\nCopies the description of the connection as a string.\nfunc nw_connection_copy_endpoint(nw_connection_t) -> nw_endpoint_t\nAccesses the endpoint with which the connection was created.\nfunc nw_connection_copy_parameters(nw_connection_t) -> nw_parameters_t\nAccesses the parameters with which the connection was created.\nfunc nw_connection_copy_protocol_metadata(nw_connection_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetrieves the connection-wide metadata for a specific protocol.\nfunc nw_connection_create(nw_endpoint_t, nw_parameters_t) -> nw_connection_t\nInitializes a new connection to a remote endpoint.\nfunc nw_connection_create_new_data_transfer_report(nw_connection_t) -> nw_data_transfer_report_t\nBegins a new data transfer report, which can later be collected.\nfunc nw_connection_force_cancel(nw_connection_t)\nCancels the connection and immediately disconnects any established network protocols.\nfunc nw_connection_get_maximum_datagram_size(nw_connection_t) -> UInt32\nAccesses the maximum size of a datagram message that can be sent on a connection.\nfunc nw_connection_group_cancel(nw_connection_group_t)\nCancels the connection group object and leaves the network group.\nfunc nw_connection_group_copy_descriptor(nw_connection_group_t) -> nw_group_descriptor_t\nAccesses the descriptor of the group you use to initialize the connection group.\nfunc nw_connection_group_copy_local_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the local address and port you use to receive the message.\nfunc nw_connection_group_copy_parameters(nw_connection_group_t) -> nw_parameters_t\nAccesses the parameters with which you initialize the connection group.\nfunc nw_connection_group_copy_path_for_message(nw_connection_group_t, nw_content_context_t) -> nw_path_t?\nAccesses the network path on which you receive the message.\nfunc nw_connection_group_copy_protocol_metadata(nw_connection_group_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nfunc nw_connection_group_copy_protocol_metadata_for_message(nw_connection_group_t, nw_content_context_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nfunc nw_connection_group_copy_remote_endpoint_for_message(nw_connection_group_t, nw_content_context_t) -> nw_endpoint_t?\nAccesses the endpoint that originates the message you receive.\nfunc nw_connection_group_create(nw_group_descriptor_t, nw_parameters_t) -> nw_connection_group_t\nInitializes a new connection group with a group identifier.\nfunc nw_connection_group_extract_connection(nw_connection_group_t, nw_endpoint_t?, nw_protocol_options_t?) -> nw_connection_t?\nfunc nw_connection_group_extract_connection_for_message(nw_connection_group_t, nw_content_context_t) -> nw_connection_t?\nConverts a message you receive from an endpoint into a connection object that you use for long-term communication with that endpoint.\nfunc nw_connection_group_reinsert_extracted_connection(nw_connection_group_t, nw_connection_t) -> Bool\nfunc nw_connection_group_reply(nw_connection_group_t, nw_content_context_t, nw_content_context_t, dispatch_data_t?)\nSends a reply to the specific endpoint that originates a group message you receive.\nfunc nw_connection_group_send_message(nw_connection_group_t, dispatch_data_t?, nw_endpoint_t?, nw_content_context_t, nw_connection_group_send_completion_t)\nSends data to the entire group, or to a specific member of the group.\nfunc nw_connection_group_set_new_connection_handler(nw_connection_group_t, nw_connection_group_new_connection_handler_t?)\nfunc nw_connection_group_set_queue(nw_connection_group_t, dispatch_queue_t)\nSets the queue on which you handle connection group events.\nfunc nw_connection_group_set_receive_handler(nw_connection_group_t, UInt32, Bool, nw_connection_group_receive_handler_t?)\nSets a handler that receives inbound messages from members of the group.\nfunc nw_connection_group_set_state_changed_handler(nw_connection_group_t, nw_connection_group_state_changed_handler_t?)\nSets a handler that receives connection group state updates.\nfunc nw_connection_group_start(nw_connection_group_t)\nJoins the group and registers to receive messages.\nfunc nw_connection_receive(nw_connection_t, UInt32, UInt32, nw_connection_receive_completion_t)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc nw_connection_receive_message(nw_connection_t, nw_connection_receive_completion_t)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc nw_connection_restart(nw_connection_t)\nRestarts a connection that is in the waiting state.\nfunc nw_connection_send(nw_connection_t, dispatch_data_t?, nw_content_context_t, Bool, nw_connection_send_completion_t)\nSends data on a connection.\nfunc nw_connection_set_better_path_available_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when an alternative network path is preferred over the current path.\nfunc nw_connection_set_path_changed_handler(nw_connection_t, nw_connection_path_event_handler_t?)\nSets a handler that receives network path updates.\nfunc nw_connection_set_queue(nw_connection_t, dispatch_queue_t)\nSets the queue on which all connection events are delivered.\nfunc nw_connection_set_state_changed_handler(nw_connection_t, nw_connection_state_changed_handler_t?)\nSets a handler to receive connection state updates.\nfunc nw_connection_set_viability_changed_handler(nw_connection_t, nw_connection_boolean_event_handler_t?)\nSets a handler that receives updates when data can be sent and received.\nfunc nw_connection_start(nw_connection_t)\nStarts establishing a connection.\nfunc nw_content_context_copy_antecedent(nw_content_context_t) -> nw_content_context_t?\nAccesses the optional message context that must be sent before the context you are sending.\nfunc nw_content_context_copy_protocol_metadata(nw_content_context_t, nw_protocol_definition_t) -> nw_protocol_metadata_t?\nRetreives the metadata associated with a specific protocol.\nfunc nw_content_context_create(UnsafePointer<CChar>) -> nw_content_context_t\nInitializes a custom message context.\nfunc nw_content_context_foreach_protocol_metadata(nw_content_context_t, (nw_protocol_definition_t, nw_protocol_metadata_t) -> Void)\nIterates through all protocol metadata associated with the message context.\nfunc nw_content_context_get_expiration_milliseconds(nw_content_context_t) -> UInt64\nAccesses the expiration set for this message context.\nfunc nw_content_context_get_identifier(nw_content_context_t) -> UnsafePointer<CChar>\nAccesses the identifier used to create this message context.\nfunc nw_content_context_get_is_final(nw_content_context_t) -> Bool\nChecks whether this context represents the final message being received.\nfunc nw_content_context_get_relative_priority(nw_content_context_t) -> Double\nAccesses the relative value of priority used to reorder contexts when sending.\nfunc nw_content_context_set_antecedent(nw_content_context_t, nw_content_context_t?)\nSet an optional message context that must be sent before the context you are sending.\nfunc nw_content_context_set_expiration_milliseconds(nw_content_context_t, UInt64)\nSets the number of milliseconds after which sending the data associated with this context must begin, otherwise the data is discarded.\nfunc nw_content_context_set_is_final(nw_content_context_t, Bool)\nSets a Boolean indicating if this context represents the final message being sent.\nfunc nw_content_context_set_metadata_for_protocol(nw_content_context_t, nw_protocol_metadata_t)\nSets protocol metadata to configure per-message or per-packet properties.\nfunc nw_content_context_set_relative_priority(nw_content_context_t, Double)\nSets the relative value of priority used to reorder contexts when sending.\nfunc nw_data_transfer_report_collect(nw_data_transfer_report_t, dispatch_queue_t, nw_data_transfer_report_collect_block_t)\nStops an outstanding data transfer report and calculates the results.\nfunc nw_data_transfer_report_copy_path_interface(nw_data_transfer_report_t, UInt32) -> nw_interface_t\nAccesses the network interface the path used.\nfunc nw_data_transfer_report_get_duration_milliseconds(nw_data_transfer_report_t) -> UInt64\nChecks the duration of the data transfer report, from when it was started to when it was collected.\nfunc nw_data_transfer_report_get_path_count(nw_data_transfer_report_t) -> UInt32\nChecks the number of valid paths in the report.\nfunc nw_data_transfer_report_get_path_radio_type(nw_data_transfer_report_t, UInt32) -> nw_interface_radio_type_t\nfunc nw_data_transfer_report_get_received_application_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the connection delivered.\nfunc nw_data_transfer_report_get_received_ip_packet_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of IP packets the connection received.\nfunc nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol delivered.\nfunc nw_data_transfer_report_get_received_transport_duplicate_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of duplicated bytes the transport protocol detected.\nfunc nw_data_transfer_report_get_received_transport_out_of_order_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol received out of order.\nfunc nw_data_transfer_report_get_sent_application_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent on the connection.\nfunc nw_data_transfer_report_get_sent_ip_packet_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of IP packets the connection sent.\nfunc nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes sent into the transport protocol.\nfunc nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the number of bytes the transport protocol retransmitted.\nfunc nw_data_transfer_report_get_state(nw_data_transfer_report_t) -> nw_data_transfer_report_state_t\nChecks whether a data transfer report is collected.\nfunc nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the minimum round-trip time the transport protocol measured, in milliseconds.\nfunc nw_data_transfer_report_get_transport_rtt_variance(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the variance of the round-trip time the transport protocol measured.\nfunc nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(nw_data_transfer_report_t, UInt32) -> UInt64\nAccesses the smoothed round-trip time the transport protocol measured, in milliseconds.\nfunc nw_endpoint_copy_address_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the address of an endpoint as a string.\nfunc nw_endpoint_copy_port_string(nw_endpoint_t) -> UnsafeMutablePointer<CChar>\nCopies the port of an endpoint as a string.\nfunc nw_endpoint_copy_txt_record(nw_endpoint_t) -> nw_txt_record_t?\nfunc nw_endpoint_create_address(UnsafePointer<sockaddr>) -> nw_endpoint_t\nCreates a network endpoint with an address structure.\nfunc nw_endpoint_create_bonjour_service(UnsafePointer<CChar>, UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a Bonjour service name, type, and domain.\nfunc nw_endpoint_create_host(UnsafePointer<CChar>, UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a hostname and port, where the hostname may be interpreted as an IP address.\nfunc nw_endpoint_create_url(UnsafePointer<CChar>) -> nw_endpoint_t\nCreates a network endpoint with a URL string.\nfunc nw_endpoint_get_address(nw_endpoint_t) -> UnsafePointer<sockaddr>\nAccesses the address structure stored in an address endpoint.\nfunc nw_endpoint_get_bonjour_service_domain(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service domain stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_name(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service name stored in an endpoint.\nfunc nw_endpoint_get_bonjour_service_type(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the Bonjour service type stored in an endpoint.\nfunc nw_endpoint_get_hostname(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the hostname stored in an endpoint.\nfunc nw_endpoint_get_port(nw_endpoint_t) -> UInt16\nAccesses the port stored in an endpoint, in host-byte order.\nfunc nw_endpoint_get_signature(nw_endpoint_t, UnsafeMutablePointer<Int>) -> UnsafePointer<UInt8>?\nfunc nw_endpoint_get_type(nw_endpoint_t) -> nw_endpoint_type_t\nAccesses the type of a endpoint.\nfunc nw_endpoint_get_url(nw_endpoint_t) -> UnsafePointer<CChar>\nAccesses the URL string stored in an endpoint.\nfunc nw_error_copy_cf_error(nw_error_t) -> Unmanaged<CFError>\nCopies out a CFError that represents a network error.\nfunc nw_error_get_error_code(nw_error_t) -> Int32\nAccesses the specific code of the network error.\nfunc nw_error_get_error_domain(nw_error_t) -> nw_error_domain_t\nAccesses the domain of the network error.\nfunc nw_establishment_report_copy_proxy_endpoint(nw_establishment_report_t) -> nw_endpoint_t?\nAccesses the endpoint of the proxy the connection used.\nfunc nw_establishment_report_enumerate_protocols(nw_establishment_report_t, (nw_protocol_definition_t, UInt64, UInt64) -> Bool)\nIterates a list of protocol handshakes in order from first completed to last completed.\nfunc nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t, (nw_resolution_report_t) -> Bool)\nfunc nw_establishment_report_enumerate_resolutions(nw_establishment_report_t, (nw_report_resolution_source_t, UInt64, UInt32, nw_endpoint_t, nw_endpoint_t) -> Bool)\nIterates a list of resolution steps performed during connection establishment, in order from first resolved to last resolved.\nfunc nw_establishment_report_get_attempt_started_after_milliseconds(nw_establishment_report_t) -> UInt64\nAccesses the time between the call to start and the beginning of the successful connection attempt, in milliseconds.\nfunc nw_establishment_report_get_duration_milliseconds(nw_establishment_report_t) -> UInt64\nChecks the total duration of the successful connection establishment attempt, from the preparing state to the ready state.\nfunc nw_establishment_report_get_previous_attempt_count(nw_establishment_report_t) -> UInt32\nChecks the number of attempts made before the successful attempt, when the connection moved from the preparing state back to the waiting state.\nfunc nw_establishment_report_get_proxy_configured(nw_establishment_report_t) -> Bool\nChecks whether a proxy was configured on the connection.\nfunc nw_establishment_report_get_used_proxy(nw_establishment_report_t) -> Bool\nChecks whether the connection used a proxy.\nfunc nw_ethernet_channel_cancel(nw_ethernet_channel_t)\nUnregisters the channel from the interface.\nfunc nw_ethernet_channel_create(UInt16, nw_interface_t) -> nw_ethernet_channel_t\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc nw_ethernet_channel_create_with_parameters(UInt16, nw_interface_t, nw_parameters_t) -> nw_ethernet_channel_t\nfunc nw_ethernet_channel_get_maximum_payload_size(nw_ethernet_channel_t) -> UInt32\nfunc nw_ethernet_channel_send(nw_ethernet_channel_t, dispatch_data_t, UInt16, UnsafeMutablePointer<UInt8>, nw_ethernet_channel_send_completion_t)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\nfunc nw_ethernet_channel_set_queue(nw_ethernet_channel_t, dispatch_queue_t)\nSets the queue on which all channel events are delivered.\nfunc nw_ethernet_channel_set_receive_handler(nw_ethernet_channel_t, nw_ethernet_channel_receive_handler_t?)\nSets a handler to receive inbound Ethernet frames.\nfunc nw_ethernet_channel_set_state_changed_handler(nw_ethernet_channel_t, nw_ethernet_channel_state_changed_handler_t?)\nSets a handler to receive channel state updates.\nfunc nw_ethernet_channel_start(nw_ethernet_channel_t)\nStarts the process of registering the channel.\nfunc nw_framer_async(nw_framer_t, nw_framer_block_t)\nRequests that a block be executed on the connection's internal scheduling context.\nfunc nw_framer_copy_local_endpoint(nw_framer_t) -> nw_endpoint_t\nAccesses the local endpoint of the connection in which your protocol is running.\nfunc nw_framer_copy_options(nw_framer_t) -> nw_protocol_options_t\nfunc nw_framer_copy_parameters(nw_framer_t) -> nw_parameters_t\nAccesses the parameters of the connection in which your protocol is running.\nfunc nw_framer_copy_remote_endpoint(nw_framer_t) -> nw_endpoint_t\nAccesses the remote endpoint of the connection in which your protocol is running.\nfunc nw_framer_create_definition(UnsafePointer<CChar>, UInt32, nw_framer_start_handler_t) -> nw_protocol_definition_t\nInitializes a new protocol definition based on your protocol implementation.\nfunc nw_framer_create_options(nw_protocol_definition_t) -> nw_protocol_options_t\nInitializes a set of protocol options with a custom framer definition.\nfunc nw_framer_deliver_input(nw_framer_t, UnsafePointer<UInt8>, Int, nw_framer_message_t, Bool)\nDelivers an inbound message containing arbitrary data from your protocol to the application.\nfunc nw_framer_deliver_input_no_copy(nw_framer_t, Int, nw_framer_message_t, Bool) -> Bool\nDelivers an inbound message containing a specific number of next received bytes.\nfunc nw_framer_mark_failed_with_error(nw_framer_t, Int32)\nIndicates to a connection that your protocol has encountered an error, or has gracefully closed.\nfunc nw_framer_mark_ready(nw_framer_t)\nIndicates to a connection that your protocol's handshake is complete.\nfunc nw_framer_message_access_value(nw_framer_message_t, UnsafePointer<CChar>, (UnsafeRawPointer?) -> Bool) -> Bool\nAccesses a custom value stored in a framer message.\nfunc nw_framer_message_copy_object_value(nw_framer_message_t, UnsafePointer<CChar>) -> Any?\nAccesses an NSObject value stored in a framer message.\nfunc nw_framer_message_create(nw_framer_t) -> nw_framer_message_t\nInitializes an empty message from within a framer implementation.\nfunc nw_framer_message_set_object_value(nw_framer_message_t, UnsafePointer<CChar>, Any?)\nSets an NSObject value to be stored in a framer message.\nfunc nw_framer_message_set_value(nw_framer_message_t, UnsafePointer<CChar>, UnsafeMutableRawPointer?, nw_framer_message_dispose_value_t?)\nSets a value to be stored in a framer message, with a completion to call to disposed the stored value when the message is released.\nfunc nw_framer_options_copy_object_value(nw_protocol_options_t, UnsafePointer<CChar>) -> Any?\nfunc nw_framer_options_set_object_value(nw_protocol_options_t, UnsafePointer<CChar>, Any?)\nfunc nw_framer_parse_input(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of input data while inside your input handler block.\nfunc nw_framer_parse_output(nw_framer_t, Int, Int, UnsafeMutablePointer<UInt8>?, (UnsafeMutablePointer<UInt8>?, Int, Bool) -> Int) -> Bool\nExamines the content of output data while inside your output handler.\nfunc nw_framer_pass_through_input(nw_framer_t)\nIndicates that your protocol no longer needs to handle input data.\nfunc nw_framer_pass_through_output(nw_framer_t)\nIndicates that your protocol no longer needs to handle output data.\nfunc nw_framer_prepend_application_protocol(nw_framer_t, nw_protocol_options_t) -> Bool\nDynamically adds another protocol that will run above your protocol after your protocol calls nw_framer_mark_ready(_:).\nfunc nw_framer_protocol_create_message(nw_protocol_definition_t) -> nw_framer_message_t\nInitializes an empty message for a custom framer definition.\nfunc nw_framer_schedule_wakeup(nw_framer_t, UInt64)\nRequests that the nw_framer_wakeup_handler_t be called on your protocol at a specific time in the future.\nfunc nw_framer_set_cleanup_handler(nw_framer_t, nw_framer_cleanup_handler_t)\nSets a block to handle the final cleanup of allocations made by your protocol instance.\nfunc nw_framer_set_input_handler(nw_framer_t, nw_framer_input_handler_t)\nSets a block to handle new inbound data.\nfunc nw_framer_set_output_handler(nw_framer_t, nw_framer_output_handler_t)\nSets a block to handle new outbound messages.\nfunc nw_framer_set_stop_handler(nw_framer_t, nw_framer_stop_handler_t)\nSets a block to handle when the connection is being closed.\nfunc nw_framer_set_wakeup_handler(nw_framer_t, nw_framer_wakeup_handler_t)\nSets a handler to receive scheduled wakeup events.\nfunc nw_framer_write_output(nw_framer_t, UnsafePointer<UInt8>, Int)\nSends arbitrary output data in a buffer from your protocol to the next protocol.\nfunc nw_framer_write_output_data(nw_framer_t, dispatch_data_t)\nSends arbitrary output data from your protocol to the next protocol.\nfunc nw_framer_write_output_no_copy(nw_framer_t, Int) -> Bool\nSends a specific number of bytes from a message while inside your output handler.\nfunc nw_group_descriptor_add_endpoint(nw_group_descriptor_t, nw_endpoint_t) -> Bool\nAdds a multicast address endpoint you specify to define an extra IP multicast group to join.\nfunc nw_group_descriptor_create_multicast(nw_endpoint_t) -> nw_group_descriptor_t\nCreates group descriptor you use to join an IP multicast group on a local network.\nfunc nw_group_descriptor_create_multiplex(nw_endpoint_t) -> nw_group_descriptor_t\nfunc nw_group_descriptor_enumerate_endpoints(nw_group_descriptor_t, (nw_endpoint_t) -> Bool)\nSets a handler to list all endpoints added to the group descriptor.\nfunc nw_interface_get_index(nw_interface_t) -> UInt32\nAccesses the system interface index associated with the interface.\nfunc nw_interface_get_name(nw_interface_t) -> UnsafePointer<CChar>\nAccesses the name of the interface.\nfunc nw_interface_get_type(nw_interface_t) -> nw_interface_type_t\nAccesses the type of the interface, such as Wi-Fi or Loopback.\nfunc nw_ip_create_metadata() -> nw_protocol_metadata_t\nInitializes an IP packet configuration with default settings.\nfunc nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t) -> nw_ip_ecn_flag_t\nChecks the Explicit Congestion Notification flag value received on an IP packet.\nfunc nw_ip_metadata_get_receive_time(nw_protocol_metadata_t) -> UInt64\nAccess the time at which a packet was received, in nanoseconds, based on CLOCK_MONOTONIC_RAW.\nfunc nw_ip_metadata_get_service_class(nw_protocol_metadata_t) -> nw_service_class_t\nAccesses a specific service class to mark on an IP packet.\nfunc nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t, nw_ip_ecn_flag_t)\nSets a specific Explicit Congestion Notification flag value to set on an IP packet.\nfunc nw_ip_metadata_set_service_class(nw_protocol_metadata_t, nw_service_class_t)\nSets a specific service class to mark on an IP packet.\nfunc nw_ip_options_set_calculate_receive_time(nw_protocol_options_t, Bool)\nConfigures a connection to deliver receive timestamps for IP packets.\nfunc nw_ip_options_set_disable_fragmentation(nw_protocol_options_t, Bool)\nConfigures a connection to disable fragmentation on outbound packets.\nfunc nw_ip_options_set_disable_multicast_loopback(nw_protocol_options_t, Bool)\nfunc nw_ip_options_set_hop_limit(nw_protocol_options_t, UInt8)\nConfigures the default hop limit for packets generated by a connection.\nfunc nw_ip_options_set_local_address_preference(nw_protocol_options_t, nw_ip_local_address_preference_t)\nConfigures a connection to prefer certain types of local addresses, such as temporary or stable.\nfunc nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t, Bool)\nConfigures a connection to use the minimum MTU value, which is 1280 bytes for IPv6.\nfunc nw_ip_options_set_version(nw_protocol_options_t, nw_ip_version_t)\nSets a required IP version to disable all other versions for a connection.\nfunc nw_listener_cancel(nw_listener_t)\nStops listening for inbound connections.\nfunc nw_listener_create(nw_parameters_t) -> nw_listener_t?\nInitializes a network listener, which will select a random port.\nfunc nw_listener_create_with_connection(nw_connection_t, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener to receive new streams on a multiplexed connection.\nfunc nw_listener_create_with_port(UnsafePointer<CChar>, nw_parameters_t) -> nw_listener_t?\nInitializes a network listener with a specified local port.\nfunc nw_listener_get_new_connection_limit(nw_listener_t) -> UInt32\nChecks the remaining number of inbound connections to deliver before rejecting connections.\nfunc nw_listener_get_port(nw_listener_t) -> UInt16\nThe port on which the listener can accept connections.\nfunc nw_listener_set_advertise_descriptor(nw_listener_t, nw_advertise_descriptor_t?)\nSets a Bonjour service that advertises the listener on the local network.\nfunc nw_listener_set_advertised_endpoint_changed_handler(nw_listener_t, nw_listener_advertised_endpoint_changed_handler_t?)\nSets a handler that receives updates for the service endpoint being advertised.\nfunc nw_listener_set_new_connection_group_handler(nw_listener_t, nw_listener_new_connection_group_handler_t?)\nfunc nw_listener_set_new_connection_handler(nw_listener_t, nw_listener_new_connection_handler_t?)\nSets a handler that receives inbound connections.\nfunc nw_listener_set_new_connection_limit(nw_listener_t, UInt32)\nResets the number of inbound connections to deliver before rejecting connections.\nfunc nw_listener_set_queue(nw_listener_t, dispatch_queue_t)\nSets the queue on which all listener events are delivered.\nfunc nw_listener_set_state_changed_handler(nw_listener_t, nw_listener_state_changed_handler_t?)\nSets a handler to receive listener state updates.\nfunc nw_listener_start(nw_listener_t)\nRegisters for listening for inbound connections.\nfunc nw_multicast_group_descriptor_get_disable_unicast_traffic(nw_group_descriptor_t) -> Bool\nChecks a Boolean that indicates whether a connection group should reject unicast traffic.\nfunc nw_multicast_group_descriptor_set_disable_unicast_traffic(nw_group_descriptor_t, Bool)\nSets a Boolean that indicates whether a connection group should reject unicast traffic.\nfunc nw_multicast_group_descriptor_set_specific_source(nw_group_descriptor_t, nw_endpoint_t)\nSets an optional address endpoint used to filter received multicast packets.\nfunc nw_parameters_create_application_service() -> nw_parameters_t\nfunc nw_parameters_create_quic(nw_parameters_configure_protocol_block_t) -> nw_parameters_t\nInitializes parameters for QUIC connections and listeners.\nfunc nw_parameters_requires_dnssec_validation(nw_parameters_t) -> Bool\nChecks whether a connection requires DNSSEC validation when resolving endpoints.\nfunc nw_parameters_set_requires_dnssec_validation(nw_parameters_t, Bool)\nDetermines whether a connection requires DNSSEC validation when resolving endpoints.\nfunc nw_path_copy_effective_local_endpoint(nw_path_t) -> nw_endpoint_t?\nAccesses the local endpoint in use by a connection's network path.\nfunc nw_path_copy_effective_remote_endpoint(nw_path_t) -> nw_endpoint_t?\nAccesses the remote endpoint in use by a connection's network path.\nfunc nw_path_enumerate_gateways(nw_path_t, (nw_endpoint_t) -> Bool)\nEnumerates the list of gateways configured on the interfaces available to a path.\nfunc nw_path_enumerate_interfaces(nw_path_t, (nw_interface_t) -> Bool)\nEnumerates the list of all interfaces available to the path, in order of preference.\nfunc nw_path_get_status(nw_path_t) -> nw_path_status_t\nChecks whether a path can be used by connections.\nfunc nw_path_get_unsatisfied_reason(nw_path_t) -> nw_path_unsatisfied_reason_t\nfunc nw_path_has_dns(nw_path_t) -> Bool\nChecks whether the path has a DNS server configured.\nfunc nw_path_has_ipv4(nw_path_t) -> Bool\nChecks whether the path can route IPv4 traffic.\nfunc nw_path_has_ipv6(nw_path_t) -> Bool\nChecks whether the path can route IPv6 traffic.\nfunc nw_path_is_constrained(nw_path_t) -> Bool\nChecks whether the path uses an interface in Low Data Mode.\nfunc nw_path_is_equal(nw_path_t, nw_path_t) -> Bool\nCompares if two paths are identical.\nfunc nw_path_is_expensive(nw_path_t) -> Bool\nChecks whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot.\nfunc nw_path_monitor_cancel(nw_path_monitor_t)\nStops receiving network path updates.\nfunc nw_path_monitor_create() -> nw_path_monitor_t\nInitializes a path monitor to observe all available interface types.\nfunc nw_path_monitor_create_for_ethernet_channel() -> nw_path_monitor_t\nfunc nw_path_monitor_create_with_type(nw_interface_type_t) -> nw_path_monitor_t\nInitializes a path monitor to observe a specific interface type.\nfunc nw_path_monitor_prohibit_interface_type(nw_path_monitor_t, nw_interface_type_t)\nProhibit a path monitor from using a specific interface type.\nfunc nw_path_monitor_set_cancel_handler(nw_path_monitor_t, nw_path_monitor_cancel_handler_t)\nSets a handler to determine when a monitor is fully cancelled and will no longer deliver events.\nfunc nw_path_monitor_set_queue(nw_path_monitor_t, dispatch_queue_t)\nSets a queue on which to deliver path events.\nfunc nw_path_monitor_set_update_handler(nw_path_monitor_t, nw_path_monitor_update_handler_t)\nSets a handler to receive network path updates.\nfunc nw_path_monitor_start(nw_path_monitor_t)\nStarts monitoring path changes.\nfunc nw_path_uses_interface_type(nw_path_t, nw_interface_type_t) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nfunc nw_protocol_copy_ip_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Internet Protocol.\nfunc nw_protocol_copy_quic_definition() -> nw_protocol_definition_t\nAccesses the system definition of the QUIC transport protocol.\nfunc nw_protocol_copy_tcp_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Transport Control Protocol.\nfunc nw_protocol_copy_tls_definition() -> nw_protocol_definition_t\nAccesses the system definition of the Transport Layer Security protocol.\nfunc nw_protocol_copy_udp_definition() -> nw_protocol_definition_t\nAccesses the system definition of the User Datagram Protocol.\nfunc nw_protocol_copy_ws_definition() -> nw_protocol_definition_t\nAccesses the system definition of the WebSocket protocol.\nfunc nw_protocol_metadata_copy_definition(nw_protocol_metadata_t) -> nw_protocol_definition_t\nAccesses the protocol definition associated with the metadata object.\nfunc nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t) -> Bool\nChecks if a metadata object represents a custom framer protocol message.\nfunc nw_protocol_metadata_is_ip(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents an IP packet.\nfunc nw_protocol_metadata_is_quic(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains QUIC connection state.\nfunc nw_protocol_metadata_is_tcp(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains TCP connection state.\nfunc nw_protocol_metadata_is_tls(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object contains TLS connection state.\nfunc nw_protocol_metadata_is_udp(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a UDP datagram.\nfunc nw_protocol_metadata_is_ws(nw_protocol_metadata_t) -> Bool\nChecks whether a metadata object represents a WebSocket message.\nfunc nw_protocol_options_is_quic(nw_protocol_options_t) -> Bool\nChecks whether an options object uses the QUIC protocol.\nfunc nw_proxy_config_add_excluded_domain(nw_proxy_config_t, UnsafePointer<CChar>)\nfunc nw_proxy_config_add_match_domain(nw_proxy_config_t, UnsafePointer<CChar>)\nfunc nw_proxy_config_clear_excluded_domains(nw_proxy_config_t)\nfunc nw_proxy_config_clear_match_domains(nw_proxy_config_t)\nfunc nw_proxy_config_enumerate_excluded_domains(nw_proxy_config_t, (UnsafePointer<CChar>) -> Void)\nfunc nw_proxy_config_enumerate_match_domains(nw_proxy_config_t, (UnsafePointer<CChar>) -> Void)\nfunc nw_quic_add_tls_application_protocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds a supported Application-Layer Protocol Negotiation value.\nfunc nw_quic_copy_sec_protocol_metadata(nw_protocol_metadata_t) -> sec_protocol_metadata_t\nAccesses the result of the QUIC handshake.\nfunc nw_quic_copy_sec_protocol_options(nw_protocol_options_t) -> sec_protocol_options_t\nAccesses the handshake security options QUIC will use.\nfunc nw_quic_create_options() -> nw_protocol_options_t\nInitializes a default set of QUIC connection options.\nfunc nw_quic_get_application_error(nw_protocol_metadata_t) -> UInt64\nAccesses the QUIC application error code received from the peer.\nfunc nw_quic_get_application_error_reason(nw_protocol_metadata_t) -> UnsafePointer<CChar>?\nAccesses the QUIC application error reason received from the peer.\nfunc nw_quic_get_idle_timeout(nw_protocol_options_t) -> UInt32\nAccesses the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_get_initial_max_data(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t) -> UInt64\nAccesses a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_get_keepalive_interval(nw_protocol_metadata_t) -> UInt16\nAccesses the keepalive interval for the QUIC connection, in seconds.\nfunc nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_get_max_datagram_frame_size(nw_protocol_options_t) -> UInt16\nAccesses a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_get_max_udp_payload_size(nw_protocol_options_t) -> UInt16\nAccesses the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t) -> UInt64\nAccesses the idle timeout value from the peer\u2019s transport parameters, in milliseconds.\nfunc nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of bidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t) -> UInt64\nAccesses the maximum number of unidirectional streams advertised by peer that the connection is allowed to create.\nfunc nw_quic_get_stream_application_error(nw_protocol_metadata_t) -> UInt64\nAccesses the QUIC application error code received from the peer for the stream.\nfunc nw_quic_get_stream_id(nw_protocol_metadata_t) -> UInt64\nAccesses the QUIC stream identifier.\nfunc nw_quic_get_stream_is_datagram(nw_protocol_options_t) -> Bool\nChecks if a QUIC stream is a datagram flow, instead of a byte stream.\nfunc nw_quic_get_stream_is_unidirectional(nw_protocol_options_t) -> Bool\nChecks if a QUIC stream is unidirectional, instead of bidirectional.\nfunc nw_quic_get_stream_type(nw_protocol_metadata_t) -> UInt8\nAccesses the stream type of the QUIC stream.\nfunc nw_quic_get_stream_usable_datagram_frame_size(nw_protocol_metadata_t) -> UInt16\nAccesses the maximum usable size of a datagram frame on a QUIC datagram flow.\nfunc nw_quic_set_application_error(nw_protocol_metadata_t, UInt64, UnsafePointer<CChar>?)\nSets the QUIC application error code to send for the connection.\nfunc nw_quic_set_idle_timeout(nw_protocol_options_t, UInt32)\nSets the idle timeout for the QUIC connection, in milliseconds.\nfunc nw_quic_set_initial_max_data(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum data transport parameter.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for locally-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for remote-initiated bidirectional streams.\nfunc nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum stream data limit for unidirectional streams.\nfunc nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of bidirectional streams.\nfunc nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t, UInt64)\nSets a QUIC connection\u2019s initial maximum number of unidirectional streams.\nfunc nw_quic_set_keepalive_interval(nw_protocol_metadata_t, UInt16)\nSets the keepalive interval for the QUIC connection, in seconds.\nfunc nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of bidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t, UInt64)\nSets the maximum number of unidirectional streams that the peer can create on a QUIC connection.\nfunc nw_quic_set_max_datagram_frame_size(nw_protocol_options_t, UInt16)\nSets a QUIC connection\u2019s maximum DATAGRAM frame size.\nfunc nw_quic_set_max_udp_payload_size(nw_protocol_options_t, UInt16)\nSets the maximum length of a QUIC packet that can be received on a connection, in bytes.\nfunc nw_quic_set_stream_application_error(nw_protocol_metadata_t, UInt64)\nSets the QUIC application error code to send for the stream.\nfunc nw_quic_set_stream_is_datagram(nw_protocol_options_t, Bool)\nConfigures a QUIC stream as a datagram flow, instead of a byte stream.\nfunc nw_quic_set_stream_is_unidirectional(nw_protocol_options_t, Bool)\nConfigures a QUIC stream as unidirectional, instead of bidirectional.\nfunc nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that the connection used for its first connection attempt.\nfunc nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t) -> nw_endpoint_t\nAccesses the resolved endpoint that led to the established connection.\nfunc nw_resolution_report_get_endpoint_count(nw_resolution_report_t) -> UInt32\nAccesses the number of endpoints resolved in this step.\nfunc nw_resolution_report_get_milliseconds(nw_resolution_report_t) -> UInt64\nAccesses the duration of this resolution step, from when the query was issued to when the response was complete.\nfunc nw_resolution_report_get_protocol(nw_resolution_report_t) -> nw_report_resolution_protocol_t\nAccesses the transport protocol your connection used for DNS resolution.\nfunc nw_resolution_report_get_source(nw_resolution_report_t) -> nw_report_resolution_source_t\nAccesses the source of the DNS response.\nfunc nw_tcp_create_options() -> nw_protocol_options_t\nInitializes a default set of TCP connection options.\nfunc nw_tcp_get_available_receive_buffer(nw_protocol_metadata_t) -> UInt32\nAccesses the number of available bytes in the TCP receive buffer.\nfunc nw_tcp_get_available_send_buffer(nw_protocol_metadata_t) -> UInt32\nAccesses the number of available bytes in the TCP send buffer.\nfunc nw_tcp_options_set_connection_timeout(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits before timing out its handshake.\nfunc nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t, Bool)\nDisables TCP acknowledgment stretching.\nfunc nw_tcp_options_set_disable_ecn(nw_protocol_options_t, Bool)\nDisables negotiation of Explicit Congestion Notification markings.\nfunc nw_tcp_options_set_enable_fast_open(nw_protocol_options_t, Bool)\nEnables TCP Fast Open on a connection.\nfunc nw_tcp_options_set_enable_keepalive(nw_protocol_options_t, Bool)\nEnables TCP keepalives.\nfunc nw_tcp_options_set_keepalive_count(nw_protocol_options_t, UInt32)\nSets the number of keepalive probes that TCP sends before terminating the connection.\nfunc nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t, UInt32)\nSets the number of seconds of idleness that TCP waits before sending keepalive probes.\nfunc nw_tcp_options_set_keepalive_interval(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits between sending keepalive probes.\nfunc nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t, UInt32)\nSets TCP's maximum segment size in bytes.\nfunc nw_tcp_options_set_multipath_force_version(nw_protocol_options_t, nw_multipath_version_t)\nfunc nw_tcp_options_set_no_delay(nw_protocol_options_t, Bool)\nDisables Nagle's algorithm for TCP.\nfunc nw_tcp_options_set_no_options(nw_protocol_options_t, Bool)\nSets TCP into no-options mode.\nfunc nw_tcp_options_set_no_push(nw_protocol_options_t, Bool)\nSets TCP into no-push mode.\nfunc nw_tcp_options_set_persist_timeout(nw_protocol_options_t, UInt32)\nSets the TCP persist timeout in seconds, as defined by RFC 6429.\nfunc nw_tcp_options_set_retransmit_connection_drop_time(nw_protocol_options_t, UInt32)\nSets the number of seconds that TCP waits between retransmission attempts.\nfunc nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t, Bool)\nCauses TCP to drop its connection after not receiving an ACK after a FIN.\nfunc nw_tls_copy_sec_protocol_metadata(nw_protocol_metadata_t) -> sec_protocol_metadata_t\nAccesses the result of the TLS handshake.\nfunc nw_tls_copy_sec_protocol_options(nw_protocol_options_t) -> sec_protocol_options_t\nAccesses the handshake security options TLS will use.\nfunc nw_tls_create_options() -> nw_protocol_options_t\nInitializes a default set of TLS connection options.\nfunc nw_txt_record_access_bytes(nw_txt_record_t, nw_txt_record_access_bytes_t) -> Bool\nAccesses the raw bytes contained within a TXT record.\nfunc nw_txt_record_access_key(nw_txt_record_t, UnsafePointer<CChar>, nw_txt_record_access_key_t) -> Bool\nAccesses the value for a specific key in a TXT record dictionary.\nfunc nw_txt_record_apply(nw_txt_record_t, nw_txt_record_applier_t) -> Bool\nIterates through all keys in a TXT record dictionary.\nfunc nw_txt_record_copy(nw_txt_record_t?) -> nw_txt_record_t?\nPerforms a deep copy of a TXT record.\nfunc nw_txt_record_create_dictionary() -> nw_txt_record_t\nInitializes a TXT record as a dictionary of strings.\nfunc nw_txt_record_create_with_bytes(UnsafePointer<UInt8>, Int) -> nw_txt_record_t\nInitializes a TXT record with raw bytes.\nfunc nw_txt_record_find_key(nw_txt_record_t, UnsafePointer<CChar>) -> nw_txt_record_find_key_t\nChecks the status of value associated with a key in a TXT record dictionary.\nfunc nw_txt_record_get_key_count(nw_txt_record_t?) -> Int\nAccesses the number of keys stored in the TXT record dictionary.\nfunc nw_txt_record_is_dictionary(nw_txt_record_t) -> Bool\nChecks whether a TXT record conforms to a dictionary format.\nfunc nw_txt_record_is_equal(nw_txt_record_t?, nw_txt_record_t?) -> Bool\nChecks whether two TXT records are equivalent.\nfunc nw_txt_record_remove_key(nw_txt_record_t, UnsafePointer<CChar>) -> Bool\nRemoves a data value in a TXT record dictionary.\nfunc nw_txt_record_set_key(nw_txt_record_t, UnsafePointer<CChar>, UnsafePointer<UInt8>?, Int) -> Bool\nSets a data value in a TXT record dictionary.\nfunc nw_udp_create_metadata() -> nw_protocol_metadata_t\nInitializes a default UDP message.\nfunc nw_udp_create_options() -> nw_protocol_options_t\nInitializes a default set of UDP connection options.\nfunc nw_udp_options_set_prefer_no_checksum(nw_protocol_options_t, Bool)\nConfigures the connection to not send UDP checksums.\nfunc nw_ws_create_metadata(nw_ws_opcode_t) -> nw_protocol_metadata_t\nInitializes a WebSocket message with a specific type code.\nfunc nw_ws_create_options(nw_ws_version_t) -> nw_protocol_options_t\nInitializes a default set of WebSocket connection options.\nfunc nw_ws_metadata_copy_server_response(nw_protocol_metadata_t) -> nw_ws_response_t\nAccesses the WebSocket server's response sent during the handshake.\nfunc nw_ws_metadata_get_close_code(nw_protocol_metadata_t) -> nw_ws_close_code_t\nAccesses the close code on a WebSocket message.\nfunc nw_ws_metadata_get_opcode(nw_protocol_metadata_t) -> nw_ws_opcode_t\nChecks the type code on a WebSocket message.\nfunc nw_ws_metadata_set_close_code(nw_protocol_metadata_t, nw_ws_close_code_t)\nSets a close code on a WebSocket message.\nfunc nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t, dispatch_queue_t, nw_ws_pong_handler_t)\nSets a handler on a Ping message to be invoked when the corresponding Pong message is received.\nfunc nw_ws_options_add_additional_header(nw_protocol_options_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds additional HTTP header fields to be sent by the client during the WebSocket handshake.\nfunc nw_ws_options_add_subprotocol(nw_protocol_options_t, UnsafePointer<CChar>)\nAdds to the list of supported application protocols that will be presented to a WebSocket server during connection establishment.\nfunc nw_ws_options_set_auto_reply_ping(nw_protocol_options_t, Bool)\nConfigures the connection to automatically reply to Ping messages instead of delivering them to you.\nfunc nw_ws_options_set_client_request_handler(nw_protocol_options_t, dispatch_queue_t, nw_ws_client_request_handler_t)\nSets a handler to react to as a server to inbound WebSocket client handshakes.\nfunc nw_ws_options_set_maximum_message_size(nw_protocol_options_t, Int)\nSets the maximum allowed message size, in bytes, to be received by the WebSocket connection.\nfunc nw_ws_options_set_skip_handshake(nw_protocol_options_t, Bool)\nSpecifies whether the WebSocket protocol skips its handshake and begins framing data once the underlying connection is established.\nfunc nw_ws_request_enumerate_additional_headers(nw_ws_request_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates additional HTTP headers in a WebSocket message.\nfunc nw_ws_request_enumerate_subprotocols(nw_ws_request_t, (UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the supported subprotocols in a WebSocket message.\nfunc nw_ws_response_add_additional_header(nw_ws_response_t, UnsafePointer<CChar>, UnsafePointer<CChar>)\nAdds an additional HTTP header to a WebSocket server response.\nfunc nw_ws_response_create(nw_ws_response_status_t, UnsafePointer<CChar>?) -> nw_ws_response_t\nInitializes a WebSocket server response with a status and selected subprotocol.\nfunc nw_ws_response_enumerate_additional_headers(nw_ws_response_t, (UnsafePointer<CChar>, UnsafePointer<CChar>) -> Bool) -> Bool\nEnumerates the additional HTTP headers in a WebSocket server response.\nfunc nw_ws_response_get_selected_subprotocol(nw_ws_response_t) -> UnsafePointer<CChar>?\nAccesses the selected subprotocol in a WebSocket server response.\nfunc nw_ws_response_get_status(nw_ws_response_t?) -> nw_ws_response_status_t\nAccesses the status of a WebSocket server response."
    },
    {
        "title": "NWEndpoint.unix(path:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/unix_path",
        "html": "See Also\nEndpoint Types\ncase hostPort(host: NWEndpoint.Host, port: NWEndpoint.Port)\nAn endpoint represented as a host and port, with the host including both names and addresses.\ncase service(name: String, type: String, domain: String, interface: NWInterface?)\nAn endpoint represented as a Bonjour service.\ncase url(URL)\nAn endpoint represented as a URL, with host and port values inferred from the URL."
    },
    {
        "title": "Network Constants",
        "url": "https://developer.apple.com/documentation/network/network_constants",
        "html": "Topics\nConstants\nvar NW_FRAMER_CREATE_FLAGS_DEFAULT: Int32\nA constant flag value that indicates that the default framer protocol behavior should be used.\nvar NW_FRAMER_WAKEUP_TIME_FOREVER: UInt64\nA sentinel value that indicates that no wakeup should be delivered.\nvar NW_LISTENER_INFINITE_CONNECTION_LIMIT: UInt32\nA static value that indicates that inbound connections should not be limited.\nvar NW_NOT_i386_MAC: Int32\nvar nw_browser_state_waiting: nw_browser_state_t\nvar nw_interface_radio_type_cell_cdma: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_endc_mmw: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_endc_sub6: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_evdo: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_gsm: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_lte: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_nr_sa_mmw: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_nr_sa_sub6: nw_interface_radio_type_t\nvar nw_interface_radio_type_cell_wcdma: nw_interface_radio_type_t\nvar nw_interface_radio_type_unknown: nw_interface_radio_type_t\nvar nw_interface_radio_type_wifi_a: nw_interface_radio_type_t\nvar nw_interface_radio_type_wifi_ac: nw_interface_radio_type_t\nvar nw_interface_radio_type_wifi_ax: nw_interface_radio_type_t\nvar nw_interface_radio_type_wifi_b: nw_interface_radio_type_t\nvar nw_interface_radio_type_wifi_g: nw_interface_radio_type_t\nvar nw_interface_radio_type_wifi_n: nw_interface_radio_type_t\nvar nw_multipath_version_0: nw_multipath_version_t\nvar nw_multipath_version_1: nw_multipath_version_t\nvar nw_multipath_version_unspecified: nw_multipath_version_t\nvar nw_path_unsatisfied_reason_cellular_denied: nw_path_unsatisfied_reason_t\nvar nw_path_unsatisfied_reason_local_network_denied: nw_path_unsatisfied_reason_t\nvar nw_path_unsatisfied_reason_not_available: nw_path_unsatisfied_reason_t\nvar nw_path_unsatisfied_reason_vpn_inactive: nw_path_unsatisfied_reason_t\nvar nw_path_unsatisfied_reason_wifi_denied: nw_path_unsatisfied_reason_t\nvar nw_quic_stream_type_bidirectional: nw_quic_stream_type_t\nvar nw_quic_stream_type_datagram: nw_quic_stream_type_t\nvar nw_quic_stream_type_unidirectional: nw_quic_stream_type_t\nvar nw_quic_stream_type_unknown: nw_quic_stream_type_t"
    },
    {
        "title": "NWEndpoint.hostPort(host:port:)",
        "url": "https://developer.apple.com/documentation/network/nwendpoint/hostport_host_port",
        "html": "See Also\nEndpoint Types\ncase service(name: String, type: String, domain: String, interface: NWInterface?)\nAn endpoint represented as a Bonjour service.\ncase url(URL)\nAn endpoint represented as a URL, with host and port values inferred from the URL.\ncase unix(path: String)\nAn endpoint represented as a UNIX domain path."
    },
    {
        "title": "pathUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998569-pathupdatehandler",
        "html": "See Also\nHandling Path Updates\nvar currentPath: NWPath?\nThe network path the connection is using.\nvar viabilityUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when data can be sent and received.\nvar betterPathUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when an alternative network path is preferred over the current path."
    },
    {
        "title": "betterPathUpdateHandler",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998558-betterpathupdatehandler",
        "html": "Discussion\n\nBetter path events are an indication that a more preferable network path is available. If you can migrate your work to a new connection, try establishing a new connection. Once that new connection is ready, cancel the original connection.\n\nSee Also\nHandling Path Updates\nvar currentPath: NWPath?\nThe network path the connection is using.\nvar pathUpdateHandler: (NWPath) -> Void)?\nA handler that receives network path updates.\nvar viabilityUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when data can be sent and received."
    },
    {
        "title": "forceCancel()",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998564-forcecancel",
        "html": "See Also\nCanceling Connections\nfunc cancel()\nCancels the connection and gracefully disconnects any established network protocols.\nfunc cancelCurrentEndpoint()\nCauses the current endpoint to be rejected, allowing the connection to try another resolved address."
    },
    {
        "title": "cancelCurrentEndpoint()",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998560-cancelcurrentendpoint",
        "html": "Discussion\n\nProtocols that do not have handshakes, such as UDP, do not allow connections to validate connectivity on their own. Cancelling an endpoint allows you to indicate that a certain endpoint should be rejected due to a lack of valid response. If other addresses were resolved for the remote endpoint, those will be attempted next.\n\nSee Also\nCanceling Connections\nfunc cancel()\nCancels the connection and gracefully disconnects any established network protocols.\nfunc forceCancel()\nCancels the connection and immediately disconnects any established network protocols."
    },
    {
        "title": "currentPath",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998561-currentpath",
        "html": "See Also\nHandling Path Updates\nvar pathUpdateHandler: (NWPath) -> Void)?\nA handler that receives network path updates.\nvar viabilityUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when data can be sent and received.\nvar betterPathUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when an alternative network path is preferred over the current path."
    },
    {
        "title": "receive(minimumIncompleteLength:maximumLength:completion:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998572-receive",
        "html": "Parameters\nminimumIncompleteLength\n\nThe minimum length to receive from the connection, until the content is complete.\n\nmaximumLength\n\nThe maximum length to receive from the connection in a single completion.\n\ncompletion\n\nA receive completion is invoked exactly once for a call to receive. The completion indicates that the requested content has been received (in which case the content is delivered), or that an error has occurred.\n\nThe completion delivers the received content, which may be nil if the message is complete or an error occurred, the message context, a flag indicating if the message is complete, and any associated error.\n\nSee Also\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection."
    },
    {
        "title": "init(to:using:)",
        "url": "https://developer.apple.com/documentation/network/nwconnection/2998566-init",
        "html": "See Also\nCreating Connections\ninit(host: NWEndpoint.Host, port: NWEndpoint.Port, using: NWParameters)\nInitializes a new connection to a host and port.\nfunc start(queue: DispatchQueue)\nStarts establishing a connection, and sets the queue on which to deliver all connection events.\nfunc restart()\nRestarts a connection that is in the waiting state."
    },
    {
        "title": "nw_quic_stream_type_t",
        "url": "https://developer.apple.com/documentation/network/nw_quic_stream_type_t",
        "html": "Topics\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable"
    },
    {
        "title": "nw_multipath_version_t",
        "url": "https://developer.apple.com/documentation/network/nw_multipath_version_t",
        "html": "Topics\nInitializers\ninit(Int32)\ninit(rawValue: Int32)\nInstance Properties\nvar rawValue: Int32\nRelationships\nConforms To\nRawRepresentable"
    },
    {
        "title": "nw_path_unsatisfied_reason_t",
        "url": "https://developer.apple.com/documentation/network/nw_path_unsatisfied_reason_t",
        "html": "Topics\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable"
    },
    {
        "title": "NWMultiplexGroup",
        "url": "https://developer.apple.com/documentation/network/nwmultiplexgroup",
        "html": "Topics\nInitializers\ninit(to: NWEndpoint)\nInstance Properties\nvar members: [NWEndpoint]\nRelationships\nConforms To\nNWGroupDescriptor\nSendable"
    },
    {
        "title": "nw_interface_radio_type_t",
        "url": "https://developer.apple.com/documentation/network/nw_interface_radio_type_t",
        "html": "Topics\nInitializers\ninit(UInt32)\ninit(rawValue: UInt32)\nInstance Properties\nvar rawValue: UInt32\nRelationships\nConforms To\nRawRepresentable"
    },
    {
        "title": "C-Language Symbols",
        "url": "https://developer.apple.com/documentation/network/c-language_symbols",
        "html": "Topics\nC Network Structures\nstruct nw_connection_group_state_t\nStates that indicate whether you can use a connection group to send and receive messages.\nstruct nw_browser_state_t\nStates indicating whether a browser is able to discover services.\nstruct nw_connection_state_t\nStates indicating whether a connection can be used to send and receive data.\nstruct nw_data_transfer_report_state_t\nStates indicating whether a data transfer report is collected yet.\nstruct nw_endpoint_type_t\nThe type of a network endpoint, such as a host or a service.\nstruct nw_error_domain_t\nThe error domain for errors used by the Network framework.\nstruct nw_ethernet_channel_state_t\nStates indicating whether an Ethernet channel is able to send and receive frames.\nstruct nw_framer_start_result_t\nResults that you send to indicate the disposition of your protocol after the start handler is invoked.\nstruct nw_interface_type_t\nTypes of network interfaces, based on their link layer media types.\nstruct nw_ip_ecn_flag_t\nFlag values for Explicit Congestion Notifications in IP packets.\nstruct nw_ip_local_address_preference_t\nTypes of local addresses that can be selected, such as temporary or stable.\nstruct nw_ip_version_t\nIP versions to require on connections and listeners.\nstruct nw_listener_state_t\nStates indicating whether a listener is able to accept incoming connections.\nstruct nw_multipath_service_t\nModes in which a connection can support multipath protocols.\nstruct nw_parameters_expired_dns_behavior_t\nOptions for configuring how expired DNS answers should be used.\nstruct nw_path_status_t\nStatus values indicating whether a path can be used by connections.\nstruct nw_report_resolution_protocol_t\nA set of transport protocols connections use for DNS resolution.\nstruct nw_report_resolution_source_t\nSources that may provide DNS responses.\nstruct nw_service_class_t\nLevels of service quality that can be used with a connection.\nstruct nw_txt_record_find_key_t\nStatus values describing what kind of value is stored in a TXT record dictionary.\nstruct nw_ws_close_code_t\nTypes of codes used upon closing a WebSocket connection.\nstruct nw_ws_opcode_t\nTypes of messages that you send and receive on a WebSocket connection.\nstruct nw_ws_response_status_t\nStatus values that are sent with a WebSocket server response.\nstruct nw_ws_version_t\nSupported versions of the WebSocket protocol.\nC Network Protocols\nprotocol OS_nw_advertise_descriptor\nprotocol OS_nw_browse_descriptor\nprotocol OS_nw_browse_result\nprotocol OS_nw_browser\nprotocol OS_nw_connection\nprotocol OS_nw_connection_group\nprotocol OS_nw_content_context\nprotocol OS_nw_data_transfer_report\nprotocol OS_nw_endpoint\nprotocol OS_nw_error\nprotocol OS_nw_establishment_report\nprotocol OS_nw_ethernet_channel\nprotocol OS_nw_framer\nprotocol OS_nw_group_descriptor\nprotocol OS_nw_interface\nprotocol OS_nw_listener\nprotocol OS_nw_object\nprotocol OS_nw_parameters\nprotocol OS_nw_path\nprotocol OS_nw_path_monitor\nprotocol OS_nw_privacy_context\nprotocol OS_nw_protocol_definition\nprotocol OS_nw_protocol_metadata\nprotocol OS_nw_protocol_options\nprotocol OS_nw_protocol_stack\nprotocol OS_nw_proxy_config\nprotocol OS_nw_relay_hop\nprotocol OS_nw_resolution_report\nprotocol OS_nw_resolver_config\nprotocol OS_nw_txt_record\nprotocol OS_nw_ws_request\nprotocol OS_nw_ws_response"
    },
    {
        "title": "Taking Advantage of Third-Party Network Debugging Tools",
        "url": "https://developer.apple.com/documentation/network/taking_advantage_of_third-party_network_debugging_tools",
        "html": "Overview\n\niOS and macOS have built-in network debugging tools (see Analyzing HTTP traffic with Instruments and Choosing a Network Debugging Tool), but you may also want to take advantage of the third-party tools discussed here.\n\nImportant\n\nInformation about products not manufactured by Apple is provided without recommendation or endorsement. Apple assumes no responsibility with regard to the selection, performance, or use of third-party products. Contact the vendor for additional information. Other company and product names may be trademarks of their respective owners.\n\nDebugging HTTP Proxies\nCharles HTTP Proxy\n\nA debugging HTTP proxy that enables a developer to view all of the HTTP and HTTPS traffic between their machine and the internet.\n\nmitmproxy\n\nA free and open source interactive debugging HTTP proxy. The name stands for machine-in-the-middle proxy.\n\nmacOS Apps\nDebookee\n\nA simple and powerful network traffic analyzer for macOS.\n\nIPNetMonitorX\n\nA network troubleshooting toolkit for debugging internet service problems and optimizing performance.\n\nWireshark\n\nA free and open source packet analyzer that supports macOS.\n\nCommand-Line Tools\ntcpflow\n\nA program that records data transmitted as part of TCP connections (flows), and stores the data in a way that\u2019s convenient for protocol analysis or debugging.\n\ntcptrace\n\nAn open source tool for analyzing the TCP connections in a packet trace.\n\nSee Also\nNetwork Debugging\nChoosing a Network Debugging Tool\nDecide which tool works best for your network debugging problem.\nDebugging HTTP Server-Side Errors\nUnderstand HTTP server-side errors and how to debug them.\nDebugging HTTPS Problems with CFNetwork Diagnostic Logging\nUse CFNetwork diagnostic logging to investigate HTTP and HTTPS problems.\nRecording a Packet Trace\nLearn how to record a low-level trace of network traffic.\nTesting and Debugging L4S in Your App\nLearn how to verify your app on an L4S-capable host and network to improve your app\u2019s responsiveness."
    },
    {
        "title": "Testing and Debugging L4S in Your App",
        "url": "https://developer.apple.com/documentation/network/testing_and_debugging_l4s_in_your_app",
        "html": "Overview\n\nWith Low Latency, Low Loss, and Scalable Throughput (L4S) applications can have both low network delays and high throughput. L4S benefits most applications, such as conversational audio/video apps, interactive apps with dynamic content, interactive video, live streaming, cloud or online gaming, and virtual or augmented reality. In any end-to-end path from client to server (or server to client), there\u2019s one slowest link at any moment of time, called the bottleneck. When the sender\u2019s rate is higher than the bottleneck link rate, a queue builds up at the bottleneck, leading to increased delays and eventual loss, which tells the sender it needs to slow down.\n\nL4S uses an Explicit Congestion Notification (ECN) mechanism to give early warning of congestion at the bottleneck link by marking a Congestion Experienced (CE) codepoint in the IP header of packets. After receiving the packets, the receiver echoes this congestion information to the sender in the acknowledgement (ACK) packets of the transport protocol. The sender uses this congestion feedback to reduce its sending rate to avoid delay at the bottleneck. L4S requires implementation updates at end devices as well as on the network bottleneck. Beginning with iOS 17 and iPadOS 17, Apple supports L4S on its platforms for some users, for the QUIC and TCP networking stacks.\n\nTurn on L4S on Apple Devices\n\nApple\u2019s QUIC implementation fully supports L4S, whereas Apple\u2019s TCP implementation supports only the receiver-side L4S. Apple\u2019s FaceTime application also supports L4S. As L4S may not be enabled for all users, turn on L4S support for QUIC, TCP, and FaceTime on iOS and iPadOS devices by turning on L4S in Developer settings.\n\nOn macOS, enable L4S by using the following command in Terminal:\n\ndefaults write -g network_enable_l4s -bool true\n\n\nConfirm an Apple Device Sends ECT(1) for QUIC\n\nThe sending device indicates that it\u2019s L4S capable by setting the ECN-Capable Transport (ECT) codepoint to 01, known as ECT(1).\n\nTo confirm that your Apple device is L4S capable, take a packet capture using Wireshark, and look for ECT(1) in the IP header of transmitted packets as shown below. Some networks bleach (zero) the ECN field. Apple\u2019s stack performs validation in the beginning of the connection to test for bleaching. If bleaching is detected, Apple\u2019s stack doesn\u2019t use ECN and, therefore, L4S for such connections. Look for ECT(1) in at least 10\u201320 sent packets.\n\nBecause Apple\u2019s QUIC stack always provides ECN feedback when the device acts as a receiver, you don\u2019t need to confirm ECT(1) on Apple devices.\n\nConfirm an Apple Device Negotiated Accurate ECN for TCP\n\nWhen L4S is enabled for the TCP receiver side, an Apple device negotiates Accurate ECN during the three-way handshake with the server, which is essential to provide the detailed congestion feedback an L4S sender needs. The Accurate ECN protocol uses two ways to provide feedback:\n\nTCP header flags that indicate the number of packets arriving with a CE codepoint in their IP-ECN field. AE, CWR, and ECE (ACE) are the three flags that convey Accurate ECN information.\n\nAccurate ECN TCP options that provide feedback about the number of bytes arriving with one of the three ECN code points: ECT(1), ECT(0), and CE.\n\nApple\u2019s TCP implementation provides both types of feedback. To confirm that Apple\u2019s implementation negotiated Accurate ECN in the three-way handshake, take a packet capture on the device, and look in the synchronize (SYN) packet for the flags set as shown in the figure below. You need the latest version of Wireshark to parse the new Accurate ECN feedback in TCP.\n\nThen, to check how the server responded to this request, check if TCP flags are set on the synchronize-acknowledge (SYN-ACK) packet as below.\n\nIn the last ACK packet of the three-way handshake, Apple\u2019s implementation adds the Accurate ECN TCP option in addition to setting the ACE header flags.\n\nAfter the negotiation is complete, the server may send data packets. If it supports L4S sender-side behavior, the server indicates that it\u2019s L4S capable by setting the ECT codepoint to 01. You can check for ECT(1) in the client-side packet capture by looking at packets from the server to the client. As some networks may inconsistently affect the ECN field, check at least 10\u201320 packets.\n\nTo verify that your Apple device echoes Accurate ECN feedback, look at the ACE flags and Accurate ECN options because some of these fields change as more packets arrive. Note that the ACE flags use only 3 bits to count the number of CE packets, so they reset to 0 each time 8 CE packets arrive.\n\nTest Your App Against Third-Party QUIC Server Implementations\n\nIf your app uses QUIC and your Content Delivery Network (CDN) provider (for example, Amazon CloudFront or Cloudflare quiche) or some other third-party library provides your server-side implementation, work with that provider. The server implementation needs to support L4S for both its sending and receiving sides, similar to the client. But if your server supports only ECN (it can receive L4S traffic), you can test uploading use cases from Apple devices to your server.\n\nTo test for sending-side support, follow the steps described above for Apple devices. To test for receiver-side support, take a packet capture on your server. Because QUIC is an encrypted protocol, you need Transport Layer Security (TLS) keys to decrypt and view the QUIC header. The steps to decrypt QUIC packets for Cloudflare\u2019s quiche stack are described below. Contact your server provider for other stacks.\n\nBelow are the instructions to decrypt QUIC for quiche.\n\nAdd the following lines to your server application:\n\nif let Some(keylog_path) = std::env::var_os(\"SSLKEYLOGFILE\") {\n    let file = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(keylog_path)\n        .unwrap();\n\n\n    keylog = Some(file);\n\n\n    config.log_keys();\n}\n\n\nConfigure the SSLKEYLOGFILE environment variable.\n\nexport SSLKEYLOGFILE=/tmp/keys.log\n\n\nRestart your server application. Each new session key is logged in the file created in step 2.\n\nPerform a Wireshark capture. Using a filter for User Datagram Protocol (UDP) packets is optional.\n\nIn Wireshark Preferences > Protocols > TLS, select the SSLKEYLOGFILE as the TLS secret log file in the (Pre)-Master-Secret log filename field.\n\nIn Wireshark, select any packet with an ACK_ECN frame. Then, in the packet details view below under QUIC, look at the ECT counts. If the ECT counts are nonzero, then your server supports ECN and is capable of being an L4S server.\n\nTest L4S on a Linux TCP Implementation\n\nCurrently, a publicly available implementation for Linux TCP supports L4S. This Linux repository describes the various patches that were developed for L4S and instructions to install such a kernel.\n\nCheck both the client-side and server-side packet captures because faulty networks may bleach (zero) the IP-ECN field or remove certain TCP headers. Similar to on the client side, take a packet capture on the server side. Look at the IP-ECN field in the direction from the server to the client, the TCP Accurate ECN flags, and the AccECN TCP option fields.\n\nTest If Your Network Supports ECN and L4S\n\nThere are two aspects to verifying that if your network supports L4S.\n\nFirst, check that your network doesn\u2019t change the ECN field or drop packets that have ECN bits set. Compare packet captures at the client and the server, and check if packets the client sends with ECN marking in the IP header are received at the server with ECN marking. Any of the following ECN field transitions are valid, where the left side is the sender and the right side is the receiver:\n\nNot-ECT \u2192 Not-ECT\n\nECT1 \u2192 ECT1\n\nECT0 \u2192 ECT0\n\nECT1 \u2192 CE\n\nECT0 \u2192 CE\n\nCE \u2192 CE\n\nIf you see any other transition, it means that network doesn\u2019t support ECN correctly. To check which hop of your network doesn\u2019t support ECN correctly, you can use Tracebox. Here is an example usage:\n\nsudo tracebox -v -p \"ip{ecn=1}/udp{dst=33451}\" apple.com\n\n\nEvery line in the Tracebox output shows a hop and packet headers that were modified before they reached that hop. This helps you identify the hop that modified ECN bits on the packet. For example, in the output below, IP::ExpCongestionNot (1 \u2192 0) on the third line means that hop 2 bleached the ECN bit (from 1\u21920) because hop 3 received a packet with modified ECN bits.\n\n1: a.b.c.d 0ms IP::CheckSum (0x45bf \u2192 0x6d97)\n2: e.f.h.g 1ms IP::TTL (2 \u2192 1) IP::CheckSum (0x44bf \u2192 0x6d97)\n3: h.i.j.k 3ms IP::ExpCongestionNot (1 \u2192 0) IP::TTL (3 \u2192 1) IP::CheckSum (0x6ec0 \u2192 0x9879)\n\n\nThe second aspect is to check if your network bottleneck supports L4S queue management. Most bottleneck links use a traditional tail-drop queue, which keeps buffering packets until the queue is full and then drops packets at the tail end of the queue.\n\nActive Queue Management (AQM) has been deployed at some bottlenecks. It drops selected packets earlier in the buffer, which keeps the queue shorter and leaves the rest of the buffer empty for bursts. After ECN was standardized, some networks implemented what is now known as Classic ECN AQM. Classic ECN AQM is an advance over a tail-drop queue, but it reduces network delays to a limited extent. With L4S, the sender and the network can use L4S ECN to reduce queuing delays even further. In most cases, a network bottleneck that supports L4S AQM can reduce the worst 1 percent of queuing delays by about 10 times compared to Classic ECN AQM.\n\nTo verify that your network bottleneck supports L4S, run the following test:\n\nStart an L4S flow and a non-L4S flow together in the direction (upload or download) you want to test, running them long enough to be sure to saturate the bottleneck. Consider using two devices, one with L4S turned on and the other with L4S turned off.\n\nTake a packet capture at the receiver, and check if there are non-zero CE counts in the IP header of received packets as shown below.\n\nIf you can\u2019t take a packet capture at the receiver, you can verify the CE counts in the ACK header at the sender. The figure below shows how QUIC formats the ACK header.\n\nThe screenshot below for TCP shows both CE counts in ACE flags and byte counts for ECT(1), CE, and ECT(0) in Accurate ECN options.\n\nIf there are no CE marks for either flow, your network bottleneck doesn\u2019t support either Classic ECN AQM or L4S AQM.\n\nIf either flow has CE marks, measure the round-trip time (or alternatively, the one way delay) of each flow. If both L4S and non-L4S flow have the same round-trip time, your network bottleneck likely supports classic ECN AQM. If the L4S flow has a lower round-trip time than the non-L4S flow, your network bottleneck likely supports L4S AQM.\n\nEnsure Low Latency and Low Loss on Your Network\n\nIf you\u2019re a network operator, you can take a couple of actions to provide low latency and low loss to your users.\n\nCheck that your network configuration doesn\u2019t bleach, alter, or block ECN traffic because doing any of these actions may harm the traffic. However, your network might be accidentally doing it while it\u2019s trying to zero the Differentiated Services Codepoint (DSCP) because both the Diffserv and ECN fields are in the same IP header byte. You can fix this in your code or ask your equipment provider to provide a bug fix that zeros only the DSCP portion (bytes 8-13).\n\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |   DSCP    |ECN|         Total Length          |\n\n\nTo allow your users to get even lower latency, consider deploying L4S-capable queue management. An example of an L4S AQM is IETF-standardized Dual-Queue Coupled AQM. Another alternative is Per-Flow Queue L4S AQM.\n\nSee Also\nNetwork Debugging\nChoosing a Network Debugging Tool\nDecide which tool works best for your network debugging problem.\nDebugging HTTP Server-Side Errors\nUnderstand HTTP server-side errors and how to debug them.\nDebugging HTTPS Problems with CFNetwork Diagnostic Logging\nUse CFNetwork diagnostic logging to investigate HTTP and HTTPS problems.\nRecording a Packet Trace\nLearn how to record a low-level trace of network traffic.\nTaking Advantage of Third-Party Network Debugging Tools\nLearn about the available third-party network debugging tools."
    },
    {
        "title": "Recording a Packet Trace",
        "url": "https://developer.apple.com/documentation/network/recording_a_packet_trace",
        "html": "Overview\n\nA packet trace is a record of traffic traveling across the network. It\u2019s useful for investigating complex network problems related to both correctness and performance.\n\nOnce you start a packet trace on a network interface, it records all traffic passing through that interface until you stop the trace. Packet traces are usually quite short \u2014 perhaps recording the traffic associated with one specific connection \u2014 but there are situations where you might want to run the trace for hours or even days.\n\nBoth macOS and iOS have built-in support for packet traces. This article explains how to record a packet trace on both platforms. Even if your primary focus is iOS, you should start by running some tests on macOS to familiarize yourself with the tools before you attempt to debug your actual problem.\n\nNote\n\nPacket traces are a low-level feature and, if you\u2019re just getting started, you may be better off using one of the higher-level tools referenced in Choosing a Network Debugging Tool. Additionally, while the focus of this article is the built-in packet trace tools, there are a variety of third-party packet trace tools that you might want to investigate; see Taking Advantage of Third-Party Network Debugging Tools for details.\n\nChoose the Correct Interface\n\nThe first step in recording a packet trace on the Mac is to choose the correct interface. If you choose the wrong interface, you may end up recording an empty packet trace. For example, if you use the en0 interface on a Mac that has built-in Ethernet but is connected to the Internet over Wi-Fi, your packet trace will include all the traffic over the built-in Ethernet, that is, nothing.\n\nDetermine the correct interface name by running the networksetup command-line tool with the -listallhardwareports argument. This prints a list of network interfaces, including both the user-visible name and the short interface name needed by packet trace tools. For example:\n\n$ networksetup -listallhardwareports\n\n\nHardware Port: Ethernet\nDevice: en0\nEthernet Address: 54:45:5b:01:ca:89\n\n\nHardware Port: Wi-Fi\nDevice: en1\nEthernet Address: 78:a1:3c:02:2b:da\n\n\n\u2026 and so on \u2026\n\n\nIn this example, the built-in Ethernet is en0 and the built-in Wi-Fi is en1, but this will change from machine to machine. Look through this list for the user-visible name of the interface you want to trace (these match the names shown in Network preferences), then use the associated short interface name.\n\nRecord and Analyze a Packet Trace on a Mac\n\nWorking with packet traces usually involves recording a packet trace to a file and analyzing that file. It\u2019s possible to do both steps at once, and it\u2019s a good idea to do that when you\u2019re just getting started. The following Terminal command starts a packet trace and prints information about each packet as it\u2019s transferred.\n\nsudo tcpdump -i en0 -n\n\n\nIn this example:\n\ntcpdump is the name of macOS\u2019s built-in packet trace tool.\n\nThe sudo command causes tcpdump to run with privileges, which is necessary in order to record packets.\n\nThe -i en0 option tells tcpdump to record packets on the default Ethernet-like interface. Replace en0 with the short interface name you determined in Choose the Correct Interface.\n\nThe -n option tells tcpdump not to attempt to use reverse DNS to map IP addresses to names; such mapping is rarely useful on the modern Internet and it radically slows things down.\n\nWhen you run tcpdump in this way, you see something like this:\n\n17:49:26.500970 IP 192.168.1.187.64917 > 192.168.1.39.22: Flags [S], seq 3769365868, win 65535, options [mss 1460,nop,wscale 5,nop,nop,TS val 1478872373 ecr 0,sackOK,eol], length 0\n17:49:26.503325 IP 192.168.1.39.22 > 192.168.1.187.64917: Flags [S.], seq 405178393, ack 3769365869, win 65535, options [mss 1460,nop,wscale 5,nop,nop,TS val 72353448 ecr 1478872373,sackOK,eol], length 0\n17:49:26.503413 IP 192.168.1.187.64917 > 192.168.1.39.22: Flags [.], ack 1, win 4117, options [nop,nop,TS val 1478872375 ecr 72353448], length 0\n17:49:26.504887 IP 192.168.1.39.22 > 192.168.1.187.64917: Flags [.], ack 1, win 4117, options [nop,nop,TS val 72353449 ecr 1478872375], length 0\n17:49:26.526134 IP 192.168.1.39.22 > 192.168.1.187.64917: Flags [P.], seq 1:22, ack 1, win 4117, options [nop,nop,TS val 72353470 ecr 1478872375], length 21\n17:49:26.526228 IP 192.168.1.187.64917 > 192.168.1.39.22: Flags [.], ack 22, win 4117, options [nop,nop,TS val 1478872396 ecr 72353470], length 0\n\n\nThere\u2019s a line of output for each packet seen on the network. On each line there\u2019s a timestamp and a lot of information about that packet. This specific example shows the start of a connection from an SSH client at 192.168.1.187 to an SSH server listening on port 22 of 192.168.1.39.\n\nPacket traces can be quite overwhelming. Rather than trying to interpret the packet trace in real time, use the -w option to write the trace to a file and then do your analysis later on.\n\nsudo tcpdump -i en0 -w trace.pcap\n\n\nThis example records a packet trace and writes the results to a file call trace.pcap. You can save that file to analyze later on using tcpdump itself, or one of the tools listed in Taking Advantage of Third-Party Network Debugging Tools. You can also submit it to Apple for analysis (see Submitting a Packet Trace to Apple).\n\nImportant\n\nEven if your ultimate goal is to save a packet trace file, it\u2019s often a good idea to start out by looking at real-time results from tcpdump, just to make sure that you\u2019re capturing the right thing.\n\nIf you\u2019re having problems recording a packet trace, see Troubleshooting Packet Traces.\n\nSet Up iOS Packet Tracing\n\niOS doesn\u2019t let you record a packet trace directly. However, you can use your Mac to record a packet trace on an attached iOS device using the Remote Virtual Interface (RVI) mechanism. To get started, first connect your iOS device to your Mac via USB. Next run the rvictl command in Terminal.\n\nrvictl -s b0e8fe73db17d4993bd549418bfbdba70a4af2b1\n\n\nIn this example:\n\nrvictl is the name of the command that manipulates RVIs.\n\n-s tells rvictl to set up a new RVI.\n\nb0e8fe73db17d4993bd549418bfbdba70a4af2b1 is the UDID of the iOS device to target. This UDID is just an example; you can find your device\u2019s UDID in the Devices and Simulators window in Xcode.\n\nThis command prints the following output.\n\n$ rvictl -s b0e8fe73db17d4993bd549418bfbdba70a4af2b1\n\n\nStarting device b0e8fe73db17d4993bd549418bfbdba70a4af2b1 [SUCCEEDED] with interface rvi0\n\n\nThis output includes the interface name of the newly-created RVI, rvi0 in this example. Supply this interface name to your favorite packet trace tool to record a trace of the traffic on your iOS device. For example, use the following command to record a packet trace on rvi0 and write it to trace.pcap.\n\nsudo tcpdump -i rvi0 -w trace.pcap\n\n\nIf you\u2019re having problems working with RVIs, see Troubleshooting Packet Traces for some troubleshooting tips.\n\nDisplay and Filter iOS Interface Information\n\nAn RVI represents the entire networking stack of the iOS device; you cannot target a specific interface on the device as you would on the Mac. However, information about the interface is recorded in the packet metadata. You can use your packet trace tool to display the interface for each packet and filter the trace based on that interface. For the tcpdump tool, use the -k option to display packet metadata and tcpdump -Q to filter on it. The tcpdump man page has the details; see Reading UNIX Manual Pages.\n\nTopics\nWorking with Packet Traces\nTroubleshooting Packet Traces\nTake action to address packet tracing problems.\nRecording a Wi-Fi Packet Trace\nRecord traces of Wi-Fi traffic and traffic management.\nSubmitting a Packet Trace to Apple\nLearn the best way to record a packet trace when communicating with Apple.\nSee Also\nNetwork Debugging\nChoosing a Network Debugging Tool\nDecide which tool works best for your network debugging problem.\nDebugging HTTP Server-Side Errors\nUnderstand HTTP server-side errors and how to debug them.\nDebugging HTTPS Problems with CFNetwork Diagnostic Logging\nUse CFNetwork diagnostic logging to investigate HTTP and HTTPS problems.\nTaking Advantage of Third-Party Network Debugging Tools\nLearn about the available third-party network debugging tools.\nTesting and Debugging L4S in Your App\nLearn how to verify your app on an L4S-capable host and network to improve your app\u2019s responsiveness.\nRelated Documentation\nReading UNIX Manual Pages\nUse the Terminal app to read the documentation for low-level UNIX tools and APIs."
    },
    {
        "title": "Debugging HTTPS Problems with CFNetwork Diagnostic Logging",
        "url": "https://developer.apple.com/documentation/network/debugging_https_problems_with_cfnetwork_diagnostic_logging",
        "html": "Overview\n\nIf you\u2019re using URLSession and need to debug a complex networking issue, you can enable CFNetwork diagnostic logging to get detailed information about the progress of your network requests. CFNetwork diagnostic logging has unique advantages relative to other network debugging tools, including:\n\nMinimal setup\n\nThe ability to look at network traffic that\u2019s protected by Transport Layer Security (TLS)\n\nInformation about CFNetwork\u2019s internal state, like which cookies get saved and applied\n\nFor information about other network debugging tools, see Choosing a Network Debugging Tool.\n\nNote\n\nXcode 13 includes the HTTP Tracing instrument to aid in debugging HTTP issues. See Analyzing HTTP traffic with Instruments.\n\nUnderstand the Security Implications\n\nCFNetwork diagnostic logs may contain decrypted TLS data and other security-sensitive information. Take these precautions:\n\nRestrict access to any logs you capture.\n\nIf you build an app that enables this logging programmatically, make sure that anyone who receives that app understands the security implications of using it.\n\nIf you send a log to Apple, redact any security-sensitive information.\n\nImportant\n\nCFNetwork diagnostic logs may contain information that\u2019s extremely security-sensitive. Protect these logs accordingly.\n\nEnable Logging In Xcode\n\nTo enable CFNetwork diagnostic logging, edit the current scheme (choose Product > Scheme > Edit Scheme), navigate to the Arguments tab, and add a CFNETWORK_DIAGNOSTICS item to the Environment Variables list. The value of this item can range from 0 to 3, where 0 turns logging off, and higher numbers give you progressively more logging. When you next run your app and use URLSession, CFNetwork diagnostic log entries appear in Xcode\u2019s debug console area. If the console area isn\u2019t visible, choose View > Debug Area > Show Debug Area to show it.\n\nEnable Logging Programmatically to See Problems Outside of Xcode\n\nTo investigate problems outside of Xcode, programmatically enable CFNetwork diagnostic logging by setting the environment variable directly.\n\nsetenv(\"CFNETWORK_DIAGNOSTICS\", \"3\", 1)\n\n\nDo this right at the beginning of the app\u2019s launch sequence:\n\nIf you\u2019re programming in Objective-C, put the code at the start of your main function.\n\nIf your program has a C++ component, make sure this code runs before any C++ static initializers that use CFNetwork or any APIs, like URLSession, that use CFNetwork.\n\nIf you\u2019re programming in Swift, put this code in main.swift.\n\nNote\n\nBy default, Swift apps don\u2019t have a main.swift; The Swift Programming Language explains how to add one.\n\nView Log Entries\n\nHow you view the resulting log entries depends on your specific situation:\n\nIn macOS, if you can reproduce the problem locally, run the Console utility on your Mac and view log entries there.\n\nIn iOS, if you can reproduce the problem locally, and you\u2019re able to connect the device to your Mac through USB, run the Console utility on your Mac and view log entries there. Make sure you select your iOS device from the source list on the left of the main Console window (choose View > Show Sources if the source list isn\u2019t visible).\n\nIf neither of the above work for you \u2014 for example, if you\u2019re trying to debug a problem that can only be reproduced by one of your users in the field \u2014 get a sysdiagnose log from the machine exhibiting the problem and then extract the log entries from that. See the Bug Reporting > Profiles and Logs page on the developer website for details on how to get a sysdiagnose log.\n\nSee Also\nNetwork Debugging\nChoosing a Network Debugging Tool\nDecide which tool works best for your network debugging problem.\nDebugging HTTP Server-Side Errors\nUnderstand HTTP server-side errors and how to debug them.\nRecording a Packet Trace\nLearn how to record a low-level trace of network traffic.\nTaking Advantage of Third-Party Network Debugging Tools\nLearn about the available third-party network debugging tools.\nTesting and Debugging L4S in Your App\nLearn how to verify your app on an L4S-capable host and network to improve your app\u2019s responsiveness."
    },
    {
        "title": "Debugging HTTP Server-Side Errors",
        "url": "https://developer.apple.com/documentation/network/debugging_http_server-side_errors",
        "html": "Overview\n\nApple\u2019s HTTP APIs report transport errors and server-side errors:\n\nA transport error occurs due to a problem getting your request to, or getting the response from, the server. This NSError value is typically passed to your completion handler block or to a delegate method like urlSession(_:task:didCompleteWithError:). If you get a transport error, investigate what is happening with your network traffic. To get started, read Choosing a Network Debugging Tool.\n\nA server-side error occurs due to problems detected by the server. The statusCode property of the HTTPURLResponse contains the error.\n\nThe status codes returned by the server aren\u2019t always easy to interpret (see Section 6, Response Status Codes, of RFC 7231) . Many HTTP server-side errors don\u2019t give you a way to determine, from the client side, what went wrong. These include the 5xx errors (like 500 Internal Server Error) and many 4xx errors (for example, with 400 Bad Request, it\u2019s hard to know exactly why the server considers the request bad).\n\nNote\n\nXcode 13 includes the HTTP Tracing instrument to aid in debugging HTTP issues. See Analyzing HTTP traffic with Instruments.\n\nThe following sections explain how to debug these server-side problems.\n\nPrint the HTTP Response Body\n\nIn some cases, the error response from the server includes an HTTP response body that explains what the problem is. Look at the HTTP response body to see whether such an explanation is present. If it is, that\u2019s the easiest way to figure out what went wrong. For example, consider this standard URLSession request code.\n\nURLSession.shared.dataTask(with: url) { (responseBody, response, error) in\n    if let error = error {\n        // Handle transport error.\n    }\n    let response = response as! HTTPURLResponse\n    let responseBody = responseBody!\n    if !(200...299).contains(response.statusCode) {\n        // Handle HTTP server-side error.\n    }\n    // Handle success.\n    print(\"success\")\n}.resume()\n\n\nA server-side error runs the line labeled \u201cHandle HTTP server-side error.\u201d To see if the server\u2019s response contains any helpful hints as to what went wrong, add some code that prints the HTTP response body.\n\n        // Handle HTTP server-side error.\n        if let responseString = String(bytes: responseBody, encoding: .utf8) {\n            // The response body seems to be a valid UTF-8 string, so print that.\n            print(responseString)\n        } else {\n            // Otherwise print a hex dump of the body.\n            print(responseBody as NSData)\n        }\n\nCompare Against a Working Client\n\nIf the HTTP response body doesn\u2019t help, compare your request to a request issued by a working client. For example, the server might not fail if you send it the same request from:\n\nA web browser, like Safari\n\nA command-line tool, like curl\n\nAn app running on a different platform\n\nIf you have a working client, it\u2019s relatively straightforward to debug your problem:\n\nUse the same network debugging tool to record the requests made by your client and the working client. If you\u2019re using HTTP (not HTTPS), use a low-level packet trace tool to record these requests (see Recording a Packet Trace). If you\u2019re using HTTPS, with Transport Layer Security (TLS), you can\u2019t see the HTTP request. In that case, if your server has a debugging mode that lets you see the plaintext request, look there. If not, a debugging HTTP proxy may let you see the request; see Debugging HTTP Proxies for more information.\n\nCompare the two requests. Focus on the most significant values first. Do the URL paths match? Do the HTTP methods match? Do the Content-Type headers match? What about the remaining headers? Do the request bodies match? If these all match and things still don\u2019t work, you may need to look at more obscure values, like the HTTP transfer encoding and, if you\u2019re using HTTPS, various TLS parameters.\n\nAddress any discrepancies.\n\nRetry with your updated client.\n\nIf things still fail, go back to step 1.\n\nDebug on the Server\n\nIf you don\u2019t have access to a working client, or you can\u2019t get things to work using the steps described in the previous section, your only remaining option is to debug the problem on the server. Ideally, the server has documented debugging options that offer more insight into the failure. If not, escalate the problem through the support channel associated with your server software.\n\nSee Also\nNetwork Debugging\nChoosing a Network Debugging Tool\nDecide which tool works best for your network debugging problem.\nDebugging HTTPS Problems with CFNetwork Diagnostic Logging\nUse CFNetwork diagnostic logging to investigate HTTP and HTTPS problems.\nRecording a Packet Trace\nLearn how to record a low-level trace of network traffic.\nTaking Advantage of Third-Party Network Debugging Tools\nLearn about the available third-party network debugging tools.\nTesting and Debugging L4S in Your App\nLearn how to verify your app on an L4S-capable host and network to improve your app\u2019s responsiveness."
    },
    {
        "title": "NWInterface",
        "url": "https://developer.apple.com/documentation/network/nwinterface",
        "html": "Topics\nInspecting Interfaces\nvar type: NWInterface.InterfaceType\nThe type of the interface, such as Wi-Fi or loopback.\nenum NWInterface.InterfaceType\nTypes of network interfaces, based on their link layer media types.\nvar name: String\nThe name of the interface.\nvar index: Int\nThe system interface index associated with the interface.\nvar debugDescription: String\nThe description of the network interface.\nComparing Interfaces\nstatic func == (NWInterface, NWInterface) -> Bool\nstatic func != (NWInterface, NWInterface) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nInstance Properties\nvar hashValue: Int\nEnumerations\nenum NWInterface.RadioType\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSendable\nSee Also\nPaths and Interfaces\nstruct NWPath\nAn object that contains information about the properties of the network that a connection uses, or that are available to your app.\nclass NWPathMonitor\nAn observer that you use to monitor and react to network changes."
    },
    {
        "title": "NWError",
        "url": "https://developer.apple.com/documentation/network/nwerror",
        "html": "Topics\nChecking Error Types\ncase posix(POSIXErrorCode)\nA POSIX error, which is used for most network protocol and routing errors.\ncase dns(DNSServiceErrorType)\nA DNS error encountered in resolving, browsing, or advertising.\ncase tls(OSStatus)\nA TLS error reported by a TLS connection or listener.\nInspecting Errors\nvar debugDescription: String\nThe description of the error.\nvar localizedDescription: String\nThe localized description of the error.\nstatic func != (NWError, NWError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nInstance Properties\nvar errorCode: Int\nvar errorUserInfo: [String : Any]\nType Properties\nstatic var errorDomain: String\nOperator Functions\nstatic func == (NWError, NWError) -> Bool\nRelationships\nConforms To\nCustomDebugStringConvertible\nCustomNSError\nError"
    },
    {
        "title": "NWPathMonitor",
        "url": "https://developer.apple.com/documentation/network/nwpathmonitor",
        "html": "Topics\nCreating Path Monitors\ninit()\nInitializes a path monitor to observe all available interface types.\ninit(requiredInterfaceType: NWInterface.InterfaceType)\nInitializes a path monitor to observe a specific interface type.\ninit(prohibitedInterfaceTypes: [NWInterface.InterfaceType])\nInitializes a path monitor to observe interface types that are not explicitly prohibited.\nfunc start(queue: DispatchQueue)\nStarts monitoring path changes, and sets a queue on which to deliver path events.\nvar queue: DispatchQueue?\nThe queue on which path events are delivered.\nHandling Path Updates\nvar currentPath: NWPath\nThe currently available network path observed by the path monitor.\nvar pathUpdateHandler: (NWPath) -> Void)?\nA handler that receives network path updates.\nCanceling Path Monitors\nfunc cancel()\nStops receiving network path updates.\nType Aliases\ntypealias NWPathMonitor.AsyncIterator\ntypealias NWPathMonitor.Element\nInstance Properties\nvar debugDescription: String\nType Properties\nstatic var ethernetChannel: NWPathMonitor\nInstance Methods\nfunc allSatisfy((NWPath) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((NWPath) -> ElementOfResult?) -> AsyncCompactMapSequence<NWPathMonitor, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence\u2019s elements, omitting results that don\u2019t return a value.\nfunc compactMap<ElementOfResult>((NWPath) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<NWPathMonitor, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence\u2019s elements, omitting results that don\u2019t return a value.\nfunc contains(NWPath) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (NWPath) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (NWPath) -> Bool) -> AsyncDropWhileSequence<NWPathMonitor>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<NWPathMonitor>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((NWPath) -> Bool) -> AsyncFilterSequence<NWPathMonitor>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (NWPath) -> Bool) -> NWPath?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((NWPath) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<NWPathMonitor, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((NWPath) -> SegmentOfResult) -> AsyncFlatMapSequence<NWPathMonitor, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> NWPathMonitor.Iterator\nfunc map<Transformed>((NWPath) -> Transformed) -> AsyncMapSequence<NWPathMonitor, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence\u2019s elements.\nfunc map<Transformed>((NWPath) -> Transformed) -> AsyncThrowingMapSequence<NWPathMonitor, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence\u2019s elements.\nfunc max(by: (NWPath, NWPath) -> Bool) -> NWPath?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (NWPath, NWPath) -> Bool) -> NWPath?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<NWPathMonitor>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (NWPath) -> Bool) -> AsyncPrefixWhileSequence<NWPathMonitor>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, NWPath) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, NWPath) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nStructures\nstruct NWPathMonitor.Iterator\nRelationships\nConforms To\nAsyncSequence\nCustomDebugStringConvertible\nSendable\nSee Also\nPaths and Interfaces\nstruct NWPath\nAn object that contains information about the properties of the network that a connection uses, or that are available to your app.\nstruct NWInterface\nAn interface that a network connection uses to send and receive data."
    },
    {
        "title": "Security Options",
        "url": "https://developer.apple.com/documentation/network/security_options",
        "html": "Topics\nConfiguring TLS Handshake Options\ntypealias sec_protocol_options_t\nAn object that contains security options to use for TLS handshakes.\nprotocol OS_sec_protocol_options\nAn interface that supports the object containing security options to use for TLS handshakes.\nfunc sec_protocol_options_set_tls_server_name(sec_protocol_options_t, UnsafePointer<CChar>)\nSets the server name to request in the TLS handshake.\nfunc sec_protocol_options_add_pre_shared_key(sec_protocol_options_t, dispatch_data_t, dispatch_data_t)\nAdds a preshared key to use for authentication.\nfunc sec_protocol_options_add_tls_application_protocol(sec_protocol_options_t, UnsafePointer<CChar>)\nAdds an Application-Layer Protocol Negotiation (ALPN) value to present in the TLS handshake.\nfunc sec_protocol_options_append_tls_ciphersuite(sec_protocol_options_t, tls_ciphersuite_t)\nAdds a supported TLS ciphersuite to the configuration.\nfunc sec_protocol_options_append_tls_ciphersuite_group(sec_protocol_options_t, tls_ciphersuite_group_t)\nAdds a supported TLS ciphersuite group to the configuration.\nfunc sec_protocol_options_add_tls_ciphersuite(sec_protocol_options_t, SSLCipherSuite)\nAdds a supported TLS ciphersuite to the configuration.\nDeprecated\nfunc sec_protocol_options_add_tls_ciphersuite_group(sec_protocol_options_t, SSLCiphersuiteGroup)\nAdds a supported TLS ciphersuite group to the configuration.\nDeprecated\nfunc sec_protocol_options_set_tls_diffie_hellman_parameters(sec_protocol_options_t, dispatch_data_t)\nConfigures legacy Diffie-Hellman parameters.\nDeprecated\nfunc sec_protocol_options_are_equal(sec_protocol_options_t, sec_protocol_options_t) -> Bool\nChecks if two security options objects are equivalent.\nConfiguring TLS Versions\nfunc sec_protocol_options_set_min_tls_protocol_version(sec_protocol_options_t, tls_protocol_version_t)\nSets the oldest TLS version to negotiate.\nfunc sec_protocol_options_set_max_tls_protocol_version(sec_protocol_options_t, tls_protocol_version_t)\nSets the newest TLS version to negotiate.\nfunc sec_protocol_options_get_default_min_tls_protocol_version() -> tls_protocol_version_t\nAccesses the system's default oldest TLS version.\nfunc sec_protocol_options_get_default_max_tls_protocol_version() -> tls_protocol_version_t\nAccesses the system's default newest TLS version.\nfunc sec_protocol_options_get_default_min_dtls_protocol_version() -> tls_protocol_version_t\nAccesses the system's default oldest DTLS version.\nfunc sec_protocol_options_get_default_max_dtls_protocol_version() -> tls_protocol_version_t\nAccesses the system's default newest DTLS version.\nfunc sec_protocol_options_set_tls_min_version(sec_protocol_options_t, SSLProtocol)\nSets the oldest TLS version to negotiate.\nDeprecated\nfunc sec_protocol_options_set_tls_max_version(sec_protocol_options_t, SSLProtocol)\nSets the newest TLS version to negotiate.\nDeprecated\nConfiguring TLS Behavior\nfunc sec_protocol_options_set_tls_resumption_enabled(sec_protocol_options_t, Bool)\nEnables TLS session resumption.\nfunc sec_protocol_options_set_tls_tickets_enabled(sec_protocol_options_t, Bool)\nEnables the use of TLS session tickets.\nfunc sec_protocol_options_set_tls_false_start_enabled(sec_protocol_options_t, Bool)\nEnables TLS false start, as defined in RFC 7918.\nfunc sec_protocol_options_set_tls_sct_enabled(sec_protocol_options_t, Bool)\nEnables Signed Certificate Timestamp support.\nfunc sec_protocol_options_set_tls_ocsp_enabled(sec_protocol_options_t, Bool)\nEnables OCSP support.\nfunc sec_protocol_options_set_tls_renegotiation_enabled(sec_protocol_options_t, Bool)\nEnables TLS session renegotiation for versions 1.2 and earlier.\nfunc sec_protocol_options_set_peer_authentication_required(sec_protocol_options_t, Bool)\nConfigures TLS to require peer authentication.\nfunc sec_protocol_options_set_tls_is_fallback_attempt(sec_protocol_options_t, Bool)\nIndicates that this TLS handshake is a fallback attempt with more relaxed requirements than a previous attempt.\nfunc sec_protocol_options_set_tls_pre_shared_key_identity_hint(sec_protocol_options_t, dispatch_data_t)\nSets the PSK identity hint to use by servers when negotiating a PSK ciphersuite.\nHandling TLS Events\nfunc sec_protocol_options_set_verify_block(sec_protocol_options_t, sec_protocol_verify_t, dispatch_queue_t)\nSets a handler to override trust verification for TLS handshakes.\ntypealias sec_protocol_verify_t\nA block that delivers a trust object for verification during a TLS handshake.\ntypealias sec_protocol_verify_complete_t\nA block you return to indicate the result of a trust verification, where true indicates verification success.\nfunc sec_protocol_options_set_challenge_block(sec_protocol_options_t, sec_protocol_challenge_t, dispatch_queue_t)\nSets a handler to receive identity challenges.\ntypealias sec_protocol_challenge_t\nA block that delivers the current TLS state for a handshake upon an identity challenge.\ntypealias sec_protocol_challenge_complete_t\nA block you return to indicate the identity with which to reply to a challenge.\nfunc sec_protocol_options_set_key_update_block(sec_protocol_options_t, sec_protocol_key_update_t, dispatch_queue_t)\nSets a handler to receive notifications of TLS key updates.\ntypealias sec_protocol_key_update_t\nA block that delivers the current TLS state upon a key update.\ntypealias sec_protocol_key_update_complete_t\nA block you return to indicate that you have finished responding to a key update.\nfunc sec_protocol_options_set_pre_shared_key_selection_block(sec_protocol_options_t, sec_protocol_pre_shared_key_selection_t, dispatch_queue_t)\nSets a handler to receive notifications about PSK selection.\ntypealias sec_protocol_pre_shared_key_selection_t\nA block that delivers a PSK identity given a hint from its peers.\ntypealias sec_protocol_pre_shared_key_selection_complete_t\nA block you return to indicate that you have chosen a PSK identity.\nInspecting TLS State\ntypealias sec_protocol_metadata_t\nAn object that represents the TLS state associated with a connection.\nprotocol OS_sec_protocol_metadata\nAn interface used to define the object that represents the TLS state associated with a connection.\nfunc sec_protocol_metadata_get_negotiated_protocol(sec_protocol_metadata_t) -> UnsafePointer<CChar>?\nAccesses the application protocol (ALPN) negotiated by TLS.\nfunc sec_protocol_metadata_get_server_name(sec_protocol_metadata_t) -> UnsafePointer<CChar>?\nAccesses the server name presented in the TLS handshake.\nfunc sec_protocol_metadata_get_negotiated_tls_protocol_version(sec_protocol_metadata_t) -> tls_protocol_version_t\nAccesses the negotiated TLS version.\nfunc sec_protocol_metadata_get_negotiated_tls_ciphersuite(sec_protocol_metadata_t) -> tls_ciphersuite_t\nAccesses the negotiated TLS ciphersuite.\nfunc sec_protocol_metadata_get_negotiated_protocol_version(sec_protocol_metadata_t) -> SSLProtocol\nAccesses the negotiated TLS version.\nDeprecated\nfunc sec_protocol_metadata_get_negotiated_ciphersuite(sec_protocol_metadata_t) -> SSLCipherSuite\nAccesses the negotiated TLS ciphersuite.\nDeprecated\nfunc sec_protocol_metadata_get_early_data_accepted(sec_protocol_metadata_t) -> Bool\nChecks if TLS early data was successfully accepted.\nfunc sec_protocol_metadata_copy_peer_public_key(sec_protocol_metadata_t) -> dispatch_data_t?\nAccesses the public key presented by the peer in the TLS handshake.\nHandling TLS Challenges\nfunc sec_protocol_metadata_access_distinguished_names(sec_protocol_metadata_t, (dispatch_data_t) -> Void) -> Bool\nAccesses the X.509 Distinguished Names presented by the peer.\nfunc sec_protocol_metadata_access_ocsp_response(sec_protocol_metadata_t, (dispatch_data_t) -> Void) -> Bool\nAccesses the contents of the OCSP response.\nfunc sec_protocol_metadata_access_peer_certificate_chain(sec_protocol_metadata_t, (sec_certificate_t) -> Void) -> Bool\nAccesses the certificate chain presented by the peer.\nfunc sec_protocol_metadata_access_supported_signature_algorithms(sec_protocol_metadata_t, (UInt16) -> Void) -> Bool\nAccesses the list of signature algorithms supported by the peer.\nfunc sec_protocol_metadata_access_pre_shared_keys(sec_protocol_metadata_t, (dispatch_data_t, dispatch_data_t) -> Void) -> Bool\nAccesses the PSKs supported by the local instance.\nfunc sec_protocol_metadata_create_secret(sec_protocol_metadata_t, Int, UnsafePointer<CChar>, Int) -> dispatch_data_t?\nExports a cryptographic key derived from the protocol metadata using a label string.\nfunc sec_protocol_metadata_create_secret_with_context(sec_protocol_metadata_t, Int, UnsafePointer<CChar>, Int, UnsafePointer<UInt8>, Int) -> dispatch_data_t?\nExports a cryptographic key derived from the protocol metadata using a label and context string.\nfunc sec_protocol_metadata_peers_are_equal(sec_protocol_metadata_t, sec_protocol_metadata_t) -> Bool\nCompares peer information for two security metadata instances.\nfunc sec_protocol_metadata_challenge_parameters_are_equal(sec_protocol_metadata_t, sec_protocol_metadata_t) -> Bool\nCompares challenge-relevant information for two security metadata instances.\nHandling Certificates\ntypealias sec_certificate_t\nA wrapper around SecCertificate.\nprotocol OS_sec_certificate\nAn interface for supporting the certificate wrapper type.\nfunc sec_certificate_create(SecCertificate) -> sec_certificate_t?\nCreates a sec_certificate_t from a SecCertificate.\nfunc sec_certificate_copy_ref(sec_certificate_t) -> Unmanaged<SecCertificate>\nExtracts a SecCertificate from a sec_certificate_t.\nHandling Identities\nfunc sec_protocol_options_set_local_identity(sec_protocol_options_t, sec_identity_t)\nConfigures a specific local identity to present in the TLS handshake.\ntypealias sec_identity_t\nA wrapper around SecIdentity.\nprotocol OS_sec_identity\nAn interface for supporting the identity wrapper type.\nfunc sec_identity_create(SecIdentity) -> sec_identity_t?\nCreates a sec_identity_t from a SecIdentity.\nfunc sec_identity_create_with_certificates(SecIdentity, CFArray) -> sec_identity_t?\nCreates a sec_identity_t from an array of SecCertificate objects.\nfunc sec_identity_copy_ref(sec_identity_t) -> Unmanaged<SecIdentity>?\nExtracts a SecIdentity from a sec_identity_t.\nfunc sec_identity_access_certificates(sec_identity_t, (sec_certificate_t) -> Void) -> Bool\nAccesses the list of certificates associated with an identity.\nfunc sec_identity_copy_certificates_ref(sec_identity_t) -> Unmanaged<CFArray>?\nCopies the array of certificates associated with an identity.\nHandling Trust\ntypealias sec_trust_t\nA wrapper around SecTrust.\nprotocol OS_sec_trust\nAn interface for supporting the trust wrapper type.\nfunc sec_trust_create(SecTrust) -> sec_trust_t?\nCreates a sec_trust_t from a SecTrust.\nfunc sec_trust_copy_ref(sec_trust_t) -> Unmanaged<SecTrust>\nExtracts a SecTrust from a sec_trust_t.\nManaging Security Objects\nfunc sec_release(UnsafeMutableRawPointer!)\nReleases a reference count on a security object.\nfunc sec_retain(UnsafeMutableRawPointer!) -> UnsafeMutableRawPointer!\nAdds a reference count to a security object.\ntypealias sec_object_t\nThe generic type for security objects used with the Network framework.\nprotocol OS_sec_object\nAn interface that supports the generic type for security objects used with the Network framework.\nSee Also\nNetwork Security and Privacy\nPrivacy Management\nConfigure parameters related to user privacy.\nCreating an Identity for Local Network TLS\nLearn how to create and use a digital identity in your application for local network TLS."
    },
    {
        "title": "NWPath",
        "url": "https://developer.apple.com/documentation/network/nwpath",
        "html": "Topics\nChecking Path Availability\nlet status: NWPath.Status\nA status indicating whether a path can be used by connections.\nenum NWPath.Status\nStatus values indicating whether a path can be used by connections.\nInspecting Interfaces\nfunc usesInterfaceType(NWInterface.InterfaceType) -> Bool\nChecks if connections using the path may send traffic over a specific interface type.\nlet availableInterfaces: [NWInterface]\nA list of all interfaces available to the path, in order of preference.\nvar gateways: [NWEndpoint]\nA list of gateways configured on the interfaces available to a path.\nChecking Path Capabilities\nlet supportsIPv4: Bool\nA Boolean indicating whether the path can route IPv4 traffic.\nlet supportsIPv6: Bool\nA Boolean indicating whether the path can route IPv6 traffic.\nlet supportsDNS: Bool\nA Boolean indicating whether the path has a DNS server configured.\nvar isConstrained: Bool\nA Boolean indicating whether the path uses an interface in Low Data Mode.\nlet isExpensive: Bool\nA Boolean indicating whether the path uses an interface that is considered expensive, such as Cellular or a Personal Hotspot.\nvar debugDescription: String\nThe description of the network path.\nInspecting Connected Paths\nlet localEndpoint: NWEndpoint?\nThe local endpoint in use by a connection's network path.\nlet remoteEndpoint: NWEndpoint?\nThe remote endpoint in use by a connection's network path.\nComparing Paths\nstatic func == (NWPath, NWPath) -> Bool\nstatic func != (NWPath, NWPath) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nInstance Properties\nvar unsatisfiedReason: NWPath.UnsatisfiedReason\nEnumerations\nenum NWPath.UnsatisfiedReason\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nPaths and Interfaces\nclass NWPathMonitor\nAn observer that you use to monitor and react to network changes.\nstruct NWInterface\nAn interface that a network connection uses to send and receive data."
    },
    {
        "title": "Creating an Identity for Local Network TLS",
        "url": "https://developer.apple.com/documentation/network/creating_an_identity_for_local_network_tls",
        "html": "Overview\n\nIn the context of Transport Layer Security (TLS), a digital identity is a cryptographic asset that contains a certificate and an associated private key for encrypting network traffic sent between a client and a server. Creating a digital identity for iOS or macOS is done so clients can communicate using TLS over the internet or a local network.\n\nIn this scenario, a server accepts client connections on a local network. While this article focuses on local network TLS, you can apply many of the concepts for other use cases. For example, setting up TLS with a certificate obtained from third-party Certificate Authority or configuring any system that needs to establish chain of trust to a root certificate.\n\nPrepare the Environment\n\nImagine you\u2019re building an app to handle orders in a restaurant. This app runs on a server device \u2014 like an iPad or Mac \u2014 located at the front desk. Out in the restaurant, customers create and send orders to the server to be processed by the server using iOS client devices. In this situation, the server uses a digital identity from a local certificate authority to provide TLS to the clients. The following article explains how to setup both the server and client devices for local network TLS.\n\nTo create an identity for local network TLS the first thing you need to do is create and manage a local Certificate Authority (CA). A CA is a trusted entity that issues certificates for use in cryptographic operations. In this case, the CA serves as the trusted source of truth to issue a certificate that is used in a digital identity for TLS. Without this trusted authority, clients won\u2019t be able to verify the issuer of the certificate they are using.\n\nAfter creating the CA, you need to issue a leaf certificate for the digital identity that is installed on the server. Next, you need to distribute the identity to the server. In the restaurant example, this is either the macOS or iOS device acting as the server. Lastly, you also need to distribute the root certificate to all of the iOS client devices in the restaurant network so that they can establish the chain of trust during the handshake process, and trust evaluation doesn\u2019t need to be overridden.\n\nAn overview of how this would work can be described as follows:\n\nCreate and manage your own certificate authority using the Keychain app on macOS.\n\nDistribute the identity to the server. On macOS, either create and use an identity on the same machine the server is running on, or securely distribute the PKCS#12 file to the device Keychain. On iOS, import the PKCS#12 file onto the server device. For example, you could load the PKCS#12 file onto a thumb drive and import it to the iOS server app and save it in the Keychain.\n\nOn iOS client devices, install the root certificate onto the iOS device to form the chain of trust.\n\nDistribute the Identity to the Server\n\nOn iOS, the certificate authority owner is faced with the challenge of distributing the identity to the server. After transferring the identity on the server \u2014 either through thumb drive or through secure network transfer \u2014 save it to the Keychain. To save the identity in the iOS Keychain, use the following:\n\nlet password = <# A password from the Keychain #>\nlet options = [kSecImportExportPassphrase: password ] as NSDictionary\nvar rawItems: CFArray?\nlet status = SecPKCS12Import(data as CFData, // Data from imported Identity.\n                             options as CFDictionary,\n                             &rawItems)\n\n\nguard status == errSecSuccess,\n      let items = rawItems,\n      let dictionaryItems = items as? Array<Dictionary<String, Any>> else {\n    // handle error \u2026\n}\n\n\nlet secIdentity: SecIdentity = dictionaryItems[0][kSecImportItemIdentity as String] as! SecIdentity\n\n\n// Notice that kSecClass as String: kSecClassIdentity isn't used here as this is inferred from kSecValueRef.\nlet identityAddition = [\n    kSecValueRef: secIdentity,\n    kSecAttrLabel: \"ListenerIdentityLabel\"\n] as NSDictionary\n\n\nlet identityStatus = SecItemAdd(identityAddition as CFDictionary, nil)\n\n\nguard identityStatus == errSecSuccess else {\n    // handle error \u2026\n}\n// Added identity successfully.\n\n\nTo retrieve the identity from the iOS Keychain, use the following:\n\nfunc getSecIdentity() -> SecIdentity? {\n\n\n    // On the query, use kSecClassIdentity to make sure a SecIdentity is extracted.\n    let identityQuery = [\n        kSecClass: kSecClassIdentity,\n        kSecReturnRef: true,\n        kSecAttrLabel: \"ListenerIdentityLabel\"\n    ] as NSDictionary\n    var identityItem: CFTypeRef?\n    let getIdentityStatus = SecItemCopyMatching(identityQuery as CFDictionary, &identityItem)\n\n\n    guard getIdentityStatus == errSecSuccess else {\n        // handle error \u2026\n    }\n    let secIdentity = identityItem as! SecIdentity\n    return secIdentity\n}\n\n\nWith the local identity accessible from the Keychain, set it to NWListener to serve connections using TLS 1.2+ with the following:\n\nlet tlsOptions = NWProtocolTLS.Options()\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\n\nif let secIdentity = getSecIdentity(),\n   let identity = sec_identity_create(secIdentity) {\n    sec_protocol_options_set_min_tls_protocol_version(\n        tlsOptions.securityProtocolOptions, .TLSv12)\n    sec_protocol_options_set_local_identity(\n        tlsOptions.securityProtocolOptions, identity)\n} \nlet listener = try NWListener(using: tlsParams, on: 4433)\n\n\nOn macOS, the code is largely the same except if the NWListener is running on the same machine that set up the local certificate authority then the app\u2019s code can reference the identity by loading a reference from the SecCertificate in the Keychain. To retrieve the identity from the Keychain on macOS, use the following:\n\nfunc getSecIdentity() -> SecIdentity? {\n\n\n    var identity: SecIdentity?\n    let getquery = [kSecClass: kSecClassCertificate,\n        kSecAttrLabel: \"certificate_name_in_keychain\",\n        kSecReturnRef: true] as NSDictionary\n\n\n    var item: CFTypeRef?\n    let status = SecItemCopyMatching(getquery as CFDictionary, &item)\n    guard status == errSecSuccess else {\n        // handle error \u2026\n    }\n    let certificate = item as! SecCertificate\n\n\n    let identityStatus = SecIdentityCreateWithCertificate(nil, certificate, &identity)\n    guard identityStatus == errSecSuccess else {\n        // handle error \u2026\n    }\n    return identity\n}\n\n\nAfter loading the identity on macOS, you can use the exact same NWListener code on iOS.\n\nConfigure the Client Devices\n\nFor clients that connect to the server, install the root certificate on the client device to avoid overriding trust evaluation. After installing the root certificate on the client device, the client connects to the server using a local network name. When connecting from the client side of the connection, use the following:\n\nlet tlsOptions = NWProtocolTLS.Options()\nsec_protocol_options_set_min_tls_protocol_version(\n    tlsOptions.securityProtocolOptions, \n    .TLSv12)\n\n\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\n\nlet endpoint = NWEndpoint.hostPort(host: \"listener-name.local\", port: 4433)\nlet connection = NWConnection(to: endpoint, using: tlsParams)\n\n\nNote\n\nIf the root certificate from the CA is installed on the device, you can use the code above without implementing sec_protocol_options_set_verify_block(_:_:_:) to override trust evaluation.\n\nIf your client needs to connect over IP, instead of using a local network name, the server needs to use a leaf certificate that lists the IP in the \u201cIP Address\u201d field of the Subject Alternative Name. This also avoids having to override trust evaluation on the client and allows client connections to use the following:\n\nlet tlsOptions = NWProtocolTLS.Options()\nsec_protocol_options_set_min_tls_protocol_version(\n    tlsOptions.securityProtocolOptions, \n    .TLSv12)\n\n\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\n\nlet endpoint = NWEndpoint.hostPort(host: \"x.x.x.x\", port: 4433)\nlet connection = NWConnection(to: endpoint, using: tlsParams)\n\n\nAttempting to connect from a client to a server without the root certificate installed on the client iOS device results in application errors similar to the following:\n\n// [BoringSSL] boringssl_context_error_print(1863) boringssl ctx 0x2813acbe0: 4348594328:error:1000007d:SSL routines:OPENSSL_internal:CERTIFICATE_VERIFY_FAILED\n// [BoringSSL] boringssl_session_handshake_incomplete(164) [C1:1][0x1032186d0] SSL library error\n\n\nNote\n\nThe same is true if either the IP Address or DNS Name in the Subject Alternative Name fields are missing in the leaf certificate.\n\nTo work around this on the client, use sec_protocol_options_set_verify_block to perform your own verification checks on the peer\u2019s leaf certificate. This isn\u2019t the recommended path, but could be done in extreme cases. In the following example, SecPolicyCreateBasicX509() checks against the certificate\u2019s basic x509 policy:\n\nsec_protocol_options_set_verify_block(tlsOptions.securityProtocolOptions, { (_, trust, completionHandler) in\n    let secTrustRef = sec_trust_copy_ref(trust).takeRetainedValue() as SecTrust\n\n\n    // Cannot do hostname here because of IP.\n    let x509Policy = SecPolicyCreateBasicX509()\n    SecTrustSetPolicies(secTrustRef, x509Policy)\n\n\n    var error: CFError?\n    if !SecTrustEvaluateWithError(secTrustRef, &error) {\n        completionHandler(false)\n    }\n    // Perfom other certificate-based checks.  \n\n\n    completionHandler(true)\n}, .main)\n\n\nFrom there the client can set up a handshake using TLS on a local network.\n\nSee Also\nNetwork Security and Privacy\nSecurity Options\nConfigure security options for TLS handshakes.\nPrivacy Management\nConfigure parameters related to user privacy."
    },
    {
        "title": "Privacy Management",
        "url": "https://developer.apple.com/documentation/network/privacy_management",
        "html": "Topics\nTraffic Attribution\nInspecting app activity data\nVerify that your app accesses only the user data and network resources that you expect it to access.\nIndicating the source of network activity\nControl whether the App Privacy Report attributes network traffic to the app or to the user.\nfunc nw_parameters_set_attribution(nw_parameters_t, nw_parameters_attribution_t)\nSets a flag that indicates whether the network request originates from the developer or the user.\nfunc nw_parameters_get_attribution(nw_parameters_t) -> nw_parameters_attribution_t\nGets a flag that indicates whether the network request originates from the developer or the user.\nenum nw_parameters_attribution_t\nThe entities that can make a network request.\nSee Also\nNetwork Security and Privacy\nSecurity Options\nConfigure security options for TLS handshakes.\nCreating an Identity for Local Network TLS\nLearn how to create and use a digital identity in your application for local network TLS."
    },
    {
        "title": "NWProtocolWebSocket",
        "url": "https://developer.apple.com/documentation/network/nwprotocolwebsocket",
        "html": "Topics\nCreating WebSocket Connections\nclass NWProtocolWebSocket.Options\nA container of options for configuring how WebSocket is used on a connection.\nstatic let definition: NWProtocolDefinition\nThe system definition of the WebSocket protocol.\nHandling WebSocket Messages\nclass NWProtocolWebSocket.Metadata\nA WebSocket message you configure when sending and receiving packets.\nRelationships\nInherits From\nNWProtocol\nSee Also\nNetwork Protocols\nBuilding a custom peer-to-peer protocol\nUse networking frameworks to create a custom protocol for playing a game across iOS, iPadOS, watchOS, and tvOS devices.\nclass NWProtocolTCP\nA network protocol for connections that use the Transmission Control Protocol.\nclass NWProtocolTLS\nA network protocol for connections that use Transport Layer Security.\nclass NWProtocolQUIC\nA network protocol for connections that use the QUIC transport protocol.\nclass NWProtocolUDP\nA network protocol for connections that use the User Datagram Protocol.\nclass NWProtocolIP\nA network protocol for configuring the Internet Protocol on connections.\nclass NWProtocolFramer\nA customizable network protocol for defining application message parsers."
    },
    {
        "title": "NWProtocolUDP",
        "url": "https://developer.apple.com/documentation/network/nwprotocoludp",
        "html": "Topics\nCreating UDP Connections\nclass NWProtocolUDP.Options\nA container of options for configuring how UDP is used on a connection.\nstatic let definition: NWProtocolDefinition\nThe system definition of the User Datagram Protocol.\nSending UDP Messages\nclass NWProtocolUDP.Metadata\nA container representing UDP when sending and receiving packets.\nRelationships\nInherits From\nNWProtocol\nSee Also\nNetwork Protocols\nBuilding a custom peer-to-peer protocol\nUse networking frameworks to create a custom protocol for playing a game across iOS, iPadOS, watchOS, and tvOS devices.\nclass NWProtocolTCP\nA network protocol for connections that use the Transmission Control Protocol.\nclass NWProtocolTLS\nA network protocol for connections that use Transport Layer Security.\nclass NWProtocolQUIC\nA network protocol for connections that use the QUIC transport protocol.\nclass NWProtocolIP\nA network protocol for configuring the Internet Protocol on connections.\nclass NWProtocolWebSocket\nA network protocol for connections that use WebSocket.\nclass NWProtocolFramer\nA customizable network protocol for defining application message parsers."
    },
    {
        "title": "NWProtocolQUIC",
        "url": "https://developer.apple.com/documentation/network/nwprotocolquic",
        "html": "Topics\nCreating QUIC Connections\nclass NWProtocolQUIC.Options\nA container of options that configure the use of QUIC on a connection.\nstatic let definition: NWProtocolDefinition\nThe system definition of the QUIC transport protocol.\nInspecting QUIC State\nclass NWProtocolQUIC.Metadata\nA handle you can use to inspect a connection\u2019s QUIC state.\nRelationships\nInherits From\nNWProtocol\nSee Also\nNetwork Protocols\nBuilding a custom peer-to-peer protocol\nUse networking frameworks to create a custom protocol for playing a game across iOS, iPadOS, watchOS, and tvOS devices.\nclass NWProtocolTCP\nA network protocol for connections that use the Transmission Control Protocol.\nclass NWProtocolTLS\nA network protocol for connections that use Transport Layer Security.\nclass NWProtocolUDP\nA network protocol for connections that use the User Datagram Protocol.\nclass NWProtocolIP\nA network protocol for configuring the Internet Protocol on connections.\nclass NWProtocolWebSocket\nA network protocol for connections that use WebSocket.\nclass NWProtocolFramer\nA customizable network protocol for defining application message parsers."
    },
    {
        "title": "NWEthernetChannel",
        "url": "https://developer.apple.com/documentation/network/nwethernetchannel",
        "html": "Overview\n\nUse Ethernet channels to send and receive custom Ethernet frame types over an interface.\n\nCreating Ethernet channels requires the com.apple.developer.networking.custom-protocol entitlement.\n\nTopics\nManaging Ethernet Channels\ninit(on: NWInterface, etherType: UInt16)\nInitializes an Ethernet channel on a specific interface with a custom Ethernet type.\nfunc start(queue: DispatchQueue)\nStarts the process of registering the channel, and sets the queue on which all channel events are delivered.\nfunc cancel()\nUnregisters the channel from the interface.\nHandling State Updates\nvar state: NWEthernetChannel.State\nThe current state of the channel.\nenum NWEthernetChannel.State\nStates indicating whether an Ethernet channel is able to send and receive frames.\nvar stateUpdateHandler: (NWEthernetChannel.State) -> Void)?\nA handler that delivers channel state updates.\nSending and Receiving Ethernet Frames\nfunc send(content: Data, to: NWEthernetChannel.EthernetAddress, vlanTag: UInt16, completion: (NWError?) -> Void)\nSends a single Ethernet frame over a channel to a specific Ethernet address.\nvar receiveHandler: (Data, UInt16, NWEthernetChannel.EthernetAddress, NWEthernetChannel.EthernetAddress) -> Void)?\nA handler that delivers inbound Ethernet frames.\nstruct NWEthernetChannel.EthernetAddress\nA 48-bit Ethernet address.\nInspecting Ethernet Channels\nlet etherType: UInt16\nThe custom Ethernet type with which the channel was initialized.\nlet interface: NWInterface\nThe interface with which the channel was initialized.\nvar queue: DispatchQueue?\nThe queue on which channel events will be delivered.\nvar debugDescription: String\nThe description of the Ethernet channel.\nInitializers\ninit(on: NWInterface, etherType: UInt16, parameters: NWParameters)\nInstance Properties\nvar maximumPayloadSize: Int\nRelationships\nConforms To\nCustomDebugStringConvertible\nSee Also\nConnections and Listeners\nclass NWConnection\nA bidirectional data connection between a local endpoint and a remote endpoint.\nclass NWListener\nAn object you use to listen for incoming network connections.\nclass NWBrowser\nAn object you use to browse for available network services.\nclass NWConnectionGroup\nAn object you use to communicate with a group of endpoints, such as an IP multicast group on a local network."
    },
    {
        "title": "NWProtocolTCP",
        "url": "https://developer.apple.com/documentation/network/nwprotocoltcp",
        "html": "Topics\nCreating TCP Connections\nclass NWProtocolTCP.Options\nA container of options for configuring how TCP is used on a connection.\nstatic let definition: NWProtocolDefinition\nThe system definition of the Transport Control Protocol.\nInspecting TCP State\nclass NWProtocolTCP.Metadata\nA handle you can use to inspect a connection's TCP state.\nRelationships\nInherits From\nNWProtocol\nSee Also\nNetwork Protocols\nBuilding a custom peer-to-peer protocol\nUse networking frameworks to create a custom protocol for playing a game across iOS, iPadOS, watchOS, and tvOS devices.\nclass NWProtocolTLS\nA network protocol for connections that use Transport Layer Security.\nclass NWProtocolQUIC\nA network protocol for connections that use the QUIC transport protocol.\nclass NWProtocolUDP\nA network protocol for connections that use the User Datagram Protocol.\nclass NWProtocolIP\nA network protocol for configuring the Internet Protocol on connections.\nclass NWProtocolWebSocket\nA network protocol for connections that use WebSocket.\nclass NWProtocolFramer\nA customizable network protocol for defining application message parsers."
    },
    {
        "title": "Building a custom peer-to-peer protocol",
        "url": "https://developer.apple.com/documentation/network/building_a_custom_peer-to-peer_protocol",
        "html": "Overview\n\nThis TicTacToe sample code project creates a networked game that you can play between different devices, communicating with a custom protocol. The game offers two ways to play:\n\nOn Apple TV, the game uses DeviceDiscoveryUI to discover nearby iOS, iPadOS, and watchOS devices. After connecting, you can use your device to play against an AI opponent on Apple TV.\n\nOn iOS and iPadOS devices, the game uses Bonjour and TLS to establish secure connections between nearby devices. You can use this mode to play a peer-to-peer two-player game.\n\nNote\n\nThis sample code project is associated with WWDC22 session 110339: Build device-to-device interactions with the Network framework. It\u2019s also associated with WWDC 2020 session 10110: Support local network privacy in your app and with WWDC 2019 session 713: Advances in Networking, Part 2.\n\nSee Also\nNetwork Protocols\nclass NWProtocolTCP\nA network protocol for connections that use the Transmission Control Protocol.\nclass NWProtocolTLS\nA network protocol for connections that use Transport Layer Security.\nclass NWProtocolQUIC\nA network protocol for connections that use the QUIC transport protocol.\nclass NWProtocolUDP\nA network protocol for connections that use the User Datagram Protocol.\nclass NWProtocolIP\nA network protocol for configuring the Internet Protocol on connections.\nclass NWProtocolWebSocket\nA network protocol for connections that use WebSocket.\nclass NWProtocolFramer\nA customizable network protocol for defining application message parsers."
    },
    {
        "title": "NWConnectionGroup",
        "url": "https://developer.apple.com/documentation/network/nwconnectiongroup",
        "html": "Topics\nEstablishing Group Connectivity\ninit(with: any NWGroupDescriptor, using: NWParameters)\nInitializes a new connection group with a group identifier.\nclass NWMulticastGroup\nA descriptor for a group you use to join an IP multicast group on a local network.\nprotocol NWGroupDescriptor\nA protocol that defines a group of endpoints with which you can communicate, such as a multicast group.\nfunc start(queue: DispatchQueue)\nJoins the group, registers to receive messages, and sets the queue on you handle group events.\nSending and Receiving Group Messages\nfunc setReceiveHandler(maximumMessageSize: Int, rejectOversizedMessages: Bool, handler: (NWConnectionGroup.Message, Data?, Bool) -> Void)?)\nSets a handler that receives inbound messages from members of the group.\nfunc send(content: Data?, to: NWEndpoint?, message: NWConnectionGroup.Message, completion: (NWError?) -> Void)\nSends data to the entire group, or to a specific member of the group.\nclass NWConnectionGroup.Message\nAn object that represents a message that you send or receive within a group, and that contains protocol metadata and send properties.\nManaging Groups\nvar stateUpdateHandler: (NWConnectionGroup.State) -> Void)?\nA handler that receives connection group state updates.\nenum NWConnectionGroup.State\nStates that indicate whether you can use a connection group to send and receive messages.\nvar state: NWConnectionGroup.State\nThe current state of the connection group.\nfunc cancel()\nCancels the connection group object and leaves the network group.\nInspecting Groups\nlet descriptor: any NWGroupDescriptor\nThe descriptor of the group you use to initialize the connection group.\nlet parameters: NWParameters\nThe parameters with which you initialize the connection group.\nvar queue: DispatchQueue?\nThe queue on which you handle group events.\nvar debugDescription: String\nThe description of the connection group.\nInstance Properties\nvar newConnectionHandler: (NWConnection) -> Void)?\nInstance Methods\nfunc extract(connectionTo: NWEndpoint?, using: NWProtocolOptions?) -> NWConnection?\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nfunc reinsert(connection: NWConnection) -> Bool\nRelationships\nConforms To\nCustomDebugStringConvertible\nSee Also\nConnections and Listeners\nclass NWConnection\nA bidirectional data connection between a local endpoint and a remote endpoint.\nclass NWListener\nAn object you use to listen for incoming network connections.\nclass NWBrowser\nAn object you use to browse for available network services.\nclass NWEthernetChannel\nAn object you use to send and receive custom Ethernet frames."
    },
    {
        "title": "NWListener",
        "url": "https://developer.apple.com/documentation/network/nwlistener",
        "html": "Topics\nCreating Listeners\ninit(using: NWParameters, on: NWEndpoint.Port)\nInitializes a network listener, with an optional local port.\nfunc start(queue: DispatchQueue)\nRegisters for listening, and sets the queue on which all listener events are delivered.\nvar stateUpdateHandler: (NWListener.State) -> Void)?\nA handler that receives listener state updates.\nenum NWListener.State\nStates indicating whether a listener is able to accept incoming connections.\nvar port: NWEndpoint.Port?\nThe port on which the listener can accept connections.\nfunc cancel()\nStops listening for inbound connections.\nReceiving Connections\nvar newConnectionHandler: (NWConnection) -> Void)?\nA handler that receives inbound connections.\nvar newConnectionLimit: Int\nThe remaining number of inbound connections to deliver before rejecting connections.\nstatic let InfiniteConnectionLimit: Int\nA static value to indicate that inbound connections should not be limited.\nAdvertising Bonjour Services\nproperty list key NSBonjourServices\nBonjour service types browsed by the app.\nName: Bonjour services\nproperty list key NSLocalNetworkUsageDescription\nA message that tells the user why the app is requesting access to the local network.\nName: Privacy - Local Network Usage Description\nvar service: NWListener.Service?\nA Bonjour service that advertises the listener on the local network.\nstruct NWListener.Service\nA description used to advertise the Bonjour service that a listener provides.\nvar serviceRegistrationUpdateHandler: (NWListener.ServiceRegistrationChange) -> Void)?\nA handler that receives updates for the service endpoint being advertised.\nenum NWListener.ServiceRegistrationChange\nChanges to how a network listener's service is advertised.\nInspecting Listeners\nlet parameters: NWParameters\nThe parameters used to initialize the listener.\nvar queue: DispatchQueue?\nThe queue on which listener events are delivered.\nvar debugDescription: String\nThe description of the listener.\nInitializers\ninit(applicationService: String, using: NWParameters)\ninit(service: NWListener.Service, using: NWParameters)\nInstance Properties\nvar newConnectionGroupHandler: (NWConnectionGroup) -> Void)?\nvar state: NWListener.State\nRelationships\nConforms To\nCustomDebugStringConvertible\nSee Also\nConnections and Listeners\nclass NWConnection\nA bidirectional data connection between a local endpoint and a remote endpoint.\nclass NWBrowser\nAn object you use to browse for available network services.\nclass NWConnectionGroup\nAn object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.\nclass NWEthernetChannel\nAn object you use to send and receive custom Ethernet frames."
    },
    {
        "title": "NWParameters",
        "url": "https://developer.apple.com/documentation/network/nwparameters",
        "html": "Topics\nCreating Parameters\nclass var tls: NWParameters\nA set of default parameters for connections and listeners that use TLS and TCP.\nclass var tcp: NWParameters\nA set of default parameters for connections and listeners that use TCP.\nclass var dtls: NWParameters\nA set of default parameters for connections and listeners that use DTLS and UDP.\nclass var udp: NWParameters\nA set of default parameters for connections and listeners that use UDP.\nclass func quic(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC, with a set of supported Application-Layer Protocol Negotiation values.\nclass func quicDatagram(alpn: [String]) -> NWParameters\nReturns a set of default parameters for connections and listeners that use QUIC datagrams, with a set of supported Application-Layer Protocol Negotiation values.\ninit(tls: NWProtocolTLS.Options?, tcp: NWProtocolTCP.Options)\nInitializes parameters for TLS connections and listeners with custom TLS and TCP options.\ninit(dtls: NWProtocolTLS.Options?, udp: NWProtocolUDP.Options)\nInitializes parameters for DTLS connections and listeners with custom DTLS and UDP options.\ninit(quic: NWProtocolQUIC.Options)\nInitializes parameters for QUIC connections and listeners with custom QUIC options.\ninit()\nInitializes parameters for connections, listeners, and browsers with no protocols specified.\ninit(customIPProtocolNumber: UInt8)\nInitializes parameters for connections and listeners using a custom IP protocol.\nfunc copy() -> NWParameters\nPerforms a deep copy of a parameters object.\nvar debugDescription: String\nA summarized description of the parameters.\nModifying Protocol Stacks\nvar defaultProtocolStack: NWParameters.ProtocolStack\nThe protocol stack used by connections and listeners.\nclass NWParameters.ProtocolStack\nAn ordered set of protocol options that define the protocols that connections and listeners use.\nclass NWProtocol\nThe abstract superclass used by Network framework protocols and by custom network protocols that you define.\nSelecting Paths\nvar requiredInterfaceType: NWInterface.InterfaceType\nAn interface type to require on connections and listeners.\nvar requiredInterface: NWInterface?\nA specific interface to require on connections, listeners, and browsers.\nvar requiredLocalEndpoint: NWEndpoint?\nA specific local IP address and port to use for connections and listeners.\nvar prohibitConstrainedPaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as constrained by Low Data Mode.\nvar prohibitExpensivePaths: Bool\nA Boolean that prevents connections, listeners, and browsers from using network paths marked as expensive.\nvar prohibitedInterfaceTypes: [NWInterface.InterfaceType]?\nA list of interface types that connections, listeners, and browsers will not use.\nvar prohibitedInterfaces: [NWInterface]?\nA list of specific interfaces that connections and listeners will not use.\nCustomizing Connection Options\nvar multipathServiceType: NWParameters.MultipathServiceType\nAn option to allow connections to use multipath protocols.\nenum NWParameters.MultipathServiceType\nModes in which a connection can support multipath protocols.\nvar serviceClass: NWParameters.ServiceClass\nA level of service quality for connections to use for Cellular Network Slicing.\nenum NWParameters.ServiceClass\nIndicates the traffic characteristics of the network connections used by Cellular Network Slicing.\nvar allowFastOpen: Bool\nA Boolean that enables sending application data with protocol handshakes.\nvar expiredDNSBehavior: NWParameters.ExpiredDNSBehavior\nA behavior that defines how expired DNS answers will be used.\nenum NWParameters.ExpiredDNSBehavior\nOptions for configuring how expired DNS answers should be used.\nvar requiresDNSSECValidation: Bool\nA Boolean value that determines whether a connection requires DNSSEC validation when resolving endpoints.\nvar preferNoProxies: Bool\nA Boolean that indicates that connections should ignore proxies when they are enabled on the system.\nvar includePeerToPeer: Bool\nA Boolean that enables peer-to-peer link technologies for connections and listeners.\nvar allowLocalEndpointReuse: Bool\nA Boolean that allows reusing local addresses and ports across connections.\nvar acceptLocalOnly: Bool\nA Boolean that restricts listeners to only accepting connections from the local link.\nConfiguring Privacy Settings\nfunc setPrivacyContext(NWParameters.PrivacyContext)\nAssociates a privacy context with any connections or listeners that use the parameters.\nclass NWParameters.PrivacyContext\nAn object that defines the privacy requirements for a set of connections.\nInstance Properties\nvar attribution: NWParameters.Attribution\nType Properties\nclass var applicationService: NWParameters\nThe default parameters for connecting with other, local devices that are running your app.\nEnumerations\nenum NWParameters.Attribution\nRelationships\nConforms To\nCustomDebugStringConvertible\nSee Also\nEssentials\nenum NWEndpoint\nA local or remote endpoint in a network connection."
    },
    {
        "title": "NWEndpoint",
        "url": "https://developer.apple.com/documentation/network/nwendpoint",
        "html": "Topics\nEndpoint Types\ncase hostPort(host: NWEndpoint.Host, port: NWEndpoint.Port)\nAn endpoint represented as a host and port, with the host including both names and addresses.\ncase service(name: String, type: String, domain: String, interface: NWInterface?)\nAn endpoint represented as a Bonjour service.\ncase url(URL)\nAn endpoint represented as a URL, with host and port values inferred from the URL.\ncase unix(path: String)\nAn endpoint represented as a UNIX domain path.\nHost and Ports\nenum NWEndpoint.Host\nA name or address that identifies a network endpoint.\nstruct NWEndpoint.Port\nA port number you use along with a host to identify a network endpoint.\nInternet Addresses\nprotocol IPAddress\nAn abstract protocol you use to interact with IP addresses.\nstruct IPv4Address\nA structure containing an IPv4 address.\nstruct IPv6Address\nA structure containing an IPv6 address.\nEndpoint Properties\nvar interface: NWInterface?\nThe optional interface associated with this endpoint, such as the interface on which it was discovered.\nvar debugDescription: String\nThe description of this endpoint.\nstatic func != (NWEndpoint, NWEndpoint) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nEnumeration Cases\ncase opaque(nw_endpoint_t)\nInstance Properties\nvar hashValue: Int\nvar txtRecord: NWTXTRecord?\nOperator Functions\nstatic func == (NWEndpoint, NWEndpoint) -> Bool\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSendable\nSee Also\nEssentials\nclass NWParameters\nAn object that stores the protocols to use for connections, options for sending data, and network path constraints."
    },
    {
        "title": "NWConnection",
        "url": "https://developer.apple.com/documentation/network/nwconnection",
        "html": "Topics\nCreating Connections\ninit(host: NWEndpoint.Host, port: NWEndpoint.Port, using: NWParameters)\nInitializes a new connection to a host and port.\ninit(to: NWEndpoint, using: NWParameters)\nInitializes a new connection to a remote endpoint.\nfunc start(queue: DispatchQueue)\nStarts establishing a connection, and sets the queue on which to deliver all connection events.\nfunc restart()\nRestarts a connection that is in the waiting state.\nHandling State Updates\nvar state: NWConnection.State\nThe current state of the connection.\nenum NWConnection.State\nStates indicating whether a connection can be used to send and receive data.\nvar stateUpdateHandler: (NWConnection.State) -> Void)?\nA handler that receives connection state updates.\nSending and Receiving Data\nfunc send(content: Data?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection.\nfunc send<Content>(content: Content?, contentContext: NWConnection.ContentContext, isComplete: Bool, completion: NWConnection.SendCompletion)\nSends data on a connection using a custom Data type.\nenum NWConnection.SendCompletion\nA completion handler that indicates when the connection has finished processing sent content.\nfunc receive(minimumIncompleteLength: Int, maximumLength: Int, completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler, with a range indicating how many bytes the handler can receive at one time.\nfunc receiveMessage(completion: (Data?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nSchedules a single receive completion handler for a complete message, as opposed to a range of bytes.\nfunc batch(() -> Void)\nDefines a block in which calls to send and receive are processed as a batch to improve performance.\nclass NWConnection.ContentContext\nAn object that represents a message to send or receive, containing protocol metadata and send properties.\nvar maximumDatagramSize: Int\nThe maximum size of a datagram message that can be sent on a connection.\nCanceling Connections\nfunc cancel()\nCancels the connection and gracefully disconnects any established network protocols.\nfunc forceCancel()\nCancels the connection and immediately disconnects any established network protocols.\nfunc cancelCurrentEndpoint()\nCauses the current endpoint to be rejected, allowing the connection to try another resolved address.\nHandling Path Updates\nvar currentPath: NWPath?\nThe network path the connection is using.\nvar pathUpdateHandler: (NWPath) -> Void)?\nA handler that receives network path updates.\nvar viabilityUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when data can be sent and received.\nvar betterPathUpdateHandler: (Bool) -> Void)?\nA handler that receives updates when an alternative network path is preferred over the current path.\nCollecting Connection Metrics\nCollecting Network Connection Metrics\nUse reports to understand how DNS and protocol handshakes impact connection establishment.\nfunc requestEstablishmentReport(queue: DispatchQueue, completion: (NWConnection.EstablishmentReport?) -> Void)\nRequests a copy of the connection's establishment report once the connection is in the ready state.\nstruct NWConnection.EstablishmentReport\nA report that provides metrics about the establishment of a connection.\nfunc startDataTransferReport() -> NWConnection.PendingDataTransferReport\nBegins a new data transfer report, which can later be collected.\nclass NWConnection.PendingDataTransferReport\nAn outstanding data transfer report that has yet to be collected.\nstruct NWConnection.DataTransferReport\nA report that provides metrics about data being sent and received on a connection.\nInspecting Connections\nfunc metadata(definition: NWProtocolDefinition) -> NWProtocolMetadata?\nRetrieves the connection-wide metadata for a specific protocol.\nclass NWProtocolMetadata\nThe abstract superclass for specifying metadata about a network protocol.\nlet endpoint: NWEndpoint\nThe remote endpoint with which the connection was initialized.\nlet parameters: NWParameters\nThe parameters with which the connection was initialized.\nvar queue: DispatchQueue?\nThe queue on which connection events are delivered.\nvar debugDescription: String\nThe description of the connection.\nInitializers\ninit?(from: NWConnectionGroup, to: NWEndpoint?, using: NWProtocolOptions?)\ninit?(message: NWConnectionGroup.Message)\nInstance Methods\nfunc receiveDiscontiguous(minimumIncompleteLength: Int, maximumLength: Int, completion: (DispatchData?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nfunc receiveMessageDiscontiguous(completion: (DispatchData?, NWConnection.ContentContext?, Bool, NWError?) -> Void)\nRelationships\nConforms To\nCustomDebugStringConvertible\nSee Also\nConnections and Listeners\nclass NWListener\nAn object you use to listen for incoming network connections.\nclass NWBrowser\nAn object you use to browse for available network services.\nclass NWConnectionGroup\nAn object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.\nclass NWEthernetChannel\nAn object you use to send and receive custom Ethernet frames."
    },
    {
        "title": "Network",
        "url": "https://developer.apple.com/documentation/network",
        "html": "Overview\n\nUse this framework when you need direct access to protocols like TLS, TCP, and UDP for your custom application protocols. Continue to use URLSession, which is built upon this framework, for loading HTTP- and URL-based resources.\n\nNote\n\nwatchOS supports Network framework for specific use cases. For more details, see TN3135: Low-level networking on watchOS.\n\nTopics\nEssentials\nenum NWEndpoint\nA local or remote endpoint in a network connection.\nclass NWParameters\nAn object that stores the protocols to use for connections, options for sending data, and network path constraints.\nConnections and Listeners\nclass NWConnection\nA bidirectional data connection between a local endpoint and a remote endpoint.\nclass NWListener\nAn object you use to listen for incoming network connections.\nclass NWBrowser\nAn object you use to browse for available network services.\nclass NWConnectionGroup\nAn object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.\nclass NWEthernetChannel\nAn object you use to send and receive custom Ethernet frames.\nNetwork Protocols\nConfigure protocol options to use with connections and listeners, and inspect the results of protocol handshakes.\nBuilding a custom peer-to-peer protocol\nUse networking frameworks to create a custom protocol for playing a game across iOS, iPadOS, watchOS, and tvOS devices.\nclass NWProtocolTCP\nA network protocol for connections that use the Transmission Control Protocol.\nclass NWProtocolTLS\nA network protocol for connections that use Transport Layer Security.\nclass NWProtocolQUIC\nA network protocol for connections that use the QUIC transport protocol.\nclass NWProtocolUDP\nA network protocol for connections that use the User Datagram Protocol.\nclass NWProtocolIP\nA network protocol for configuring the Internet Protocol on connections.\nclass NWProtocolWebSocket\nA network protocol for connections that use WebSocket.\nclass NWProtocolFramer\nA customizable network protocol for defining application message parsers.\nNetwork Security and Privacy\nSecurity Options\nConfigure security options for TLS handshakes.\nPrivacy Management\nConfigure parameters related to user privacy.\nCreating an Identity for Local Network TLS\nLearn how to create and use a digital identity in your application for local network TLS.\nPaths and Interfaces\nstruct NWPath\nAn object that contains information about the properties of the network that a connection uses, or that are available to your app.\nclass NWPathMonitor\nAn observer that you use to monitor and react to network changes.\nstruct NWInterface\nAn interface that a network connection uses to send and receive data.\nErrors\nenum NWError\nThe errors returned by objects in the Network framework.\nNetwork Debugging\nChoosing a Network Debugging Tool\nDecide which tool works best for your network debugging problem.\nDebugging HTTP Server-Side Errors\nUnderstand HTTP server-side errors and how to debug them.\nDebugging HTTPS Problems with CFNetwork Diagnostic Logging\nUse CFNetwork diagnostic logging to investigate HTTP and HTTPS problems.\nRecording a Packet Trace\nLearn how to record a low-level trace of network traffic.\nTaking Advantage of Third-Party Network Debugging Tools\nLearn about the available third-party network debugging tools.\nTesting and Debugging L4S in Your App\nLearn how to verify your app on an L4S-capable host and network to improve your app\u2019s responsiveness.\nC-Language Symbols\nAccess Network framework symbols used in C.\nC-Language Symbols\nStructures\nstruct nw_interface_radio_type_t\nstruct nw_multipath_version_t\nstruct nw_path_unsatisfied_reason_t\nstruct nw_quic_stream_type_t\nClasses\nclass NWMultiplexGroup\nReference\nNetwork Constants\nAccess Network framework constants used in C.\nNetwork Functions\nAccess Network framework functions used in C.\nNetwork Data Types"
    }
]