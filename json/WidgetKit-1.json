[
  {
    "title": "buildArray(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewactivitybuilder/buildarray(_:)",
    "html": "See Also\nPreviewing Live Activities\nstatic func buildExpression(A.ContentState) -> [A.ContentState]\nstatic func buildPartialBlock(accumulated: [A.ContentState], next: [A.ContentState]) -> [A.ContentState]\nstatic func buildPartialBlock(first: [A.ContentState]) -> [A.ContentState]"
  },
  {
    "title": "belowIfTooWide | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionverticalplacement/belowiftoowide",
    "html": "See Also\nConfiguring vertical content placement\nstatic let `default`: DynamicIslandExpandedRegionVerticalPlacement\nThe system’s default vertical placement."
  },
  {
    "title": "default | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionverticalplacement/default",
    "html": "See Also\nConfiguring vertical content placement\nstatic let belowIfTooWide: DynamicIslandExpandedRegionVerticalPlacement\nVertical placement below the default vertical position for content that’s too wide to fit next to the TrueDepth camera."
  },
  {
    "title": "buildExpression(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewactivitybuilder/buildexpression(_:)",
    "html": "See Also\nPreviewing Live Activities\nstatic func buildArray([[A.ContentState]]) -> [A.ContentState]\nstatic func buildPartialBlock(accumulated: [A.ContentState], next: [A.ContentState]) -> [A.ContentState]\nstatic func buildPartialBlock(first: [A.ContentState]) -> [A.ContentState]"
  },
  {
    "title": "buildPartialBlock(first:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewactivitybuilder/buildpartialblock(first:)",
    "html": "See Also\nPreviewing Live Activities\nstatic func buildArray([[A.ContentState]]) -> [A.ContentState]\nstatic func buildExpression(A.ContentState) -> [A.ContentState]\nstatic func buildPartialBlock(accumulated: [A.ContentState], next: [A.ContentState]) -> [A.ContentState]"
  },
  {
    "title": "buildPartialBlock(accumulated:next:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewactivitybuilder/buildpartialblock(accumulated:next:)",
    "html": "See Also\nPreviewing Live Activities\nstatic func buildArray([[A.ContentState]]) -> [A.ContentState]\nstatic func buildExpression(A.ContentState) -> [A.ContentState]\nstatic func buildPartialBlock(first: [A.ContentState]) -> [A.ContentState]"
  },
  {
    "title": "minimal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandmode/minimal",
    "html": "See Also\nDynamic Island presentations\nstatic let compactLeading: DynamicIslandMode\nThe compact leading presentation of a Live Activity in the Dynamic Island.\nstatic let compactTrailing: DynamicIslandMode\nThe compact trailing presentation of a Live Activity in the Dynamic Island.\nstatic let expanded: DynamicIslandMode\nThe expanded presentation of a Live Activity in the Dynamic Island."
  },
  {
    "title": "ActivityPreviewViewKind.DynamicIslandPreviewViewState.compact | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activitypreviewviewkind/dynamicislandpreviewviewstate/compact",
    "html": "See Also\nDynamic Island presentations\ncase minimal\nThe minimal presentation of a Live Activity in the Dynamic Island.\ncase expanded\nThe expanded presentation of a Live Activity in the Dynamic Island."
  },
  {
    "title": "family | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/userinfokey/family",
    "html": "See Also\nDescribing a widget\nstatic let kind: String\nA key you use to access the widget’s kind. The value matches the kind property specified in the widget’s configuration."
  },
  {
    "title": "kind | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/userinfokey/kind",
    "html": "See Also\nDescribing a widget\nstatic let family: String\nA key you use to access the widget’s family."
  },
  {
    "title": "ActivityPreviewViewKind.DynamicIslandPreviewViewState.expanded | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activitypreviewviewkind/dynamicislandpreviewviewstate/expanded",
    "html": "See Also\nDynamic Island presentations\ncase compact\nThe presentation of a Live Activity in the Dynamic Island that shows both the compactLeading and compactTrailing views combined.\ncase minimal\nThe minimal presentation of a Live Activity in the Dynamic Island."
  },
  {
    "title": "ActivityPreviewViewKind.DynamicIslandPreviewViewState.minimal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activitypreviewviewkind/dynamicislandpreviewviewstate/minimal",
    "html": "See Also\nDynamic Island presentations\ncase compact\nThe presentation of a Live Activity in the Dynamic Island that shows both the compactLeading and compactTrailing views combined.\ncase expanded\nThe expanded presentation of a Live Activity in the Dynamic Island."
  },
  {
    "title": "bottom | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionposition/bottom",
    "html": "See Also\nView positions\nstatic let center: DynamicIslandExpandedRegionPosition\nThe center position in the Dynamic Island for views of an expanded Live Activity.\nstatic let leading: DynamicIslandExpandedRegionPosition\nThe leading position in the Dynamic Island for views of an expanded Live Activity.\nstatic let trailing: DynamicIslandExpandedRegionPosition\nThe trailing position in the Dynamic Island for views of an expanded Live Activity."
  },
  {
    "title": "trailing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionposition/trailing",
    "html": "See Also\nView positions\nstatic let bottom: DynamicIslandExpandedRegionPosition\nThe bottom position in the Dynamic Island for views of an expanded Live Activity.\nstatic let center: DynamicIslandExpandedRegionPosition\nThe center position in the Dynamic Island for views of an expanded Live Activity.\nstatic let leading: DynamicIslandExpandedRegionPosition\nThe leading position in the Dynamic Island for views of an expanded Live Activity."
  },
  {
    "title": "leading | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionposition/leading",
    "html": "See Also\nView positions\nstatic let bottom: DynamicIslandExpandedRegionPosition\nThe bottom position in the Dynamic Island for views of an expanded Live Activity.\nstatic let center: DynamicIslandExpandedRegionPosition\nThe center position in the Dynamic Island for views of an expanded Live Activity.\nstatic let trailing: DynamicIslandExpandedRegionPosition\nThe trailing position in the Dynamic Island for views of an expanded Live Activity."
  },
  {
    "title": "center | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionposition/center",
    "html": "See Also\nView positions\nstatic let bottom: DynamicIslandExpandedRegionPosition\nThe bottom position in the Dynamic Island for views of an expanded Live Activity.\nstatic let leading: DynamicIslandExpandedRegionPosition\nThe leading position in the Dynamic Island for views of an expanded Live Activity.\nstatic let trailing: DynamicIslandExpandedRegionPosition\nThe trailing position in the Dynamic Island for views of an expanded Live Activity."
  },
  {
    "title": "buildExpression(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewtimelinebuilder/buildexpression(_:)",
    "html": "See Also\nPreviewing timelines\nstatic func buildArray([[TimelineEntry]]) -> [TimelineEntry]\nstatic func buildPartialBlock(accumulated: [TimelineEntry], next: [TimelineEntry]) -> [TimelineEntry]\nstatic func buildPartialBlock(first: [TimelineEntry]) -> [TimelineEntry]"
  },
  {
    "title": "compactLeading | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandmode/compactleading",
    "html": "See Also\nDynamic Island presentations\nstatic let compactTrailing: DynamicIslandMode\nThe compact trailing presentation of a Live Activity in the Dynamic Island.\nstatic let expanded: DynamicIslandMode\nThe expanded presentation of a Live Activity in the Dynamic Island.\nstatic let minimal: DynamicIslandMode\nThe minimal presentation of a Live Activity in the Dynamic Island."
  },
  {
    "title": "expanded | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandmode/expanded",
    "html": "See Also\nDynamic Island presentations\nstatic let compactLeading: DynamicIslandMode\nThe compact leading presentation of a Live Activity in the Dynamic Island.\nstatic let compactTrailing: DynamicIslandMode\nThe compact trailing presentation of a Live Activity in the Dynamic Island.\nstatic let minimal: DynamicIslandMode\nThe minimal presentation of a Live Activity in the Dynamic Island."
  },
  {
    "title": "compactTrailing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandmode/compacttrailing",
    "html": "See Also\nDynamic Island presentations\nstatic let compactLeading: DynamicIslandMode\nThe compact leading presentation of a Live Activity in the Dynamic Island.\nstatic let expanded: DynamicIslandMode\nThe expanded presentation of a Live Activity in the Dynamic Island.\nstatic let minimal: DynamicIslandMode\nThe minimal presentation of a Live Activity in the Dynamic Island."
  },
  {
    "title": "attributes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activityviewcontext/attributes",
    "html": "See Also\nDescribing a Live Activity\nlet state: Attributes.ContentState\nThe dynamic content of a Live Activity at the time of its creation.\nlet isStale: Bool\nA Boolean value that describes whether the Live Activity is out of date.\nlet activityID: String\nA unique identifier for the Live Activity."
  },
  {
    "title": "isStale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activityviewcontext/isstale",
    "html": "See Also\nDescribing a Live Activity\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content at the time of its creation.\nlet state: Attributes.ContentState\nThe dynamic content of a Live Activity at the time of its creation.\nlet activityID: String\nA unique identifier for the Live Activity."
  },
  {
    "title": "activityID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activityviewcontext/activityid",
    "html": "See Also\nDescribing a Live Activity\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content at the time of its creation.\nlet state: Attributes.ContentState\nThe dynamic content of a Live Activity at the time of its creation.\nlet isStale: Bool\nA Boolean value that describes whether the Live Activity is out of date."
  },
  {
    "title": "state | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activityviewcontext/state",
    "html": "See Also\nDescribing a Live Activity\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content at the time of its creation.\nlet isStale: Bool\nA Boolean value that describes whether the Live Activity is out of date.\nlet activityID: String\nA unique identifier for the Live Activity."
  },
  {
    "title": "buildArray(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewtimelinebuilder/buildarray(_:)",
    "html": "See Also\nPreviewing timelines\nstatic func buildExpression(some TimelineEntry) -> [TimelineEntry]\nstatic func buildPartialBlock(accumulated: [TimelineEntry], next: [TimelineEntry]) -> [TimelineEntry]\nstatic func buildPartialBlock(first: [TimelineEntry]) -> [TimelineEntry]"
  },
  {
    "title": "buildPartialBlock(accumulated:next:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewtimelinebuilder/buildpartialblock(accumulated:next:)",
    "html": "See Also\nPreviewing timelines\nstatic func buildArray([[TimelineEntry]]) -> [TimelineEntry]\nstatic func buildExpression(some TimelineEntry) -> [TimelineEntry]\nstatic func buildPartialBlock(first: [TimelineEntry]) -> [TimelineEntry]"
  },
  {
    "title": "buildPartialBlock(first:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewtimelinebuilder/buildpartialblock(first:)",
    "html": "See Also\nPreviewing timelines\nstatic func buildArray([[TimelineEntry]]) -> [TimelineEntry]\nstatic func buildExpression(some TimelineEntry) -> [TimelineEntry]\nstatic func buildPartialBlock(accumulated: [TimelineEntry], next: [TimelineEntry]) -> [TimelineEntry]"
  },
  {
    "title": "date | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineentry/date",
    "html": "Required\n\nSee Also\nConfiguring Timeline Entry Properties\nvar relevance: TimelineEntryRelevance?\nThe relevance of a widget’s content to the user.\n\nRequired Default implementation provided."
  },
  {
    "title": "DynamicIslandExpandedContentBuilder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedcontentbuilder",
    "html": "Topics\nType Methods\nstatic func buildPartialBlock<C0, C1>(accumulated: DynamicIslandExpandedContent<C0>, next: DynamicIslandExpandedContent<C1>) -> DynamicIslandExpandedContent<some View>\nstatic func buildPartialBlock<C0, C1>(accumulated: DynamicIslandExpandedContent<C0>, next: DynamicIslandExpandedRegion<C1>) -> DynamicIslandExpandedContent<some View>\nstatic func buildPartialBlock<C>(first: DynamicIslandExpandedRegion<C>) -> DynamicIslandExpandedContent<some View>\nstatic func buildPartialBlock<C>(first: DynamicIslandExpandedContent<C>) -> DynamicIslandExpandedContent<some View>\nSee Also\nCreating the expanded presentation\ninit(DynamicIslandExpandedRegionPosition, priority: Double, content: () -> Content)\nCreates the object that defines and positions the content of an expanded Live Activity in the Dynamic Island.\nstruct DynamicIslandExpandedRegionPosition\nView positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedRegionVerticalPlacement\nVertical view positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContent\nA view that describes the expanded presentation of a Live Activity that appears in the Dynamic Island."
  },
  {
    "title": "DynamicIslandExpandedRegionPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionposition",
    "html": "Topics\nView positions\nstatic let bottom: DynamicIslandExpandedRegionPosition\nThe bottom position in the Dynamic Island for views of an expanded Live Activity.\nstatic let center: DynamicIslandExpandedRegionPosition\nThe center position in the Dynamic Island for views of an expanded Live Activity.\nstatic let leading: DynamicIslandExpandedRegionPosition\nThe leading position in the Dynamic Island for views of an expanded Live Activity.\nstatic let trailing: DynamicIslandExpandedRegionPosition\nThe trailing position in the Dynamic Island for views of an expanded Live Activity.\nSee Also\nCreating the expanded presentation\ninit(DynamicIslandExpandedRegionPosition, priority: Double, content: () -> Content)\nCreates the object that defines and positions the content of an expanded Live Activity in the Dynamic Island.\nstruct DynamicIslandExpandedRegionVerticalPlacement\nVertical view positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContent\nA view that describes the expanded presentation of a Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContentBuilder\nA result builder that constructs the content of an expanded Live Activity in the Dynamic Island."
  },
  {
    "title": "contentMargins(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregion/contentmargins(_:_:)",
    "html": "Parameters\nedges\n\nThe edges that use the custom content margins.\n\nlength\n\nThe length of the custom margin for the given edges.\n\nReturn Value\n\nThe view for the Dynamic Island expanded region with the updated content margins.\n\nDiscussion\n\nIf you repeatedly use the contentMargins(_:_:) modifier, the system uses the innermost specified values. The following example results in a margin of 8 points for the trailing, top, and bottom edges, and uses the default margin for the leading edge:\n\nDynamicIslandContentRegion(.trailing) {\n    ContainerRelativeShape()\n    .aspectRatio(1, contentMode:.fit)\n}.contentMargins([.trailing, .top, .bottom], 8)\n\n\nNote that the system applies the provided custom content margins to content that’s adjacent to the modified content margin edges."
  },
  {
    "title": "DynamicIslandExpandedRegionVerticalPlacement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregionverticalplacement",
    "html": "Topics\nConfiguring vertical content placement\nstatic let `default`: DynamicIslandExpandedRegionVerticalPlacement\nThe system’s default vertical placement.\nstatic let belowIfTooWide: DynamicIslandExpandedRegionVerticalPlacement\nVertical placement below the default vertical position for content that’s too wide to fit next to the TrueDepth camera.\nRelationships\nConforms To\nEquatable\nSee Also\nCreating the expanded presentation\ninit(DynamicIslandExpandedRegionPosition, priority: Double, content: () -> Content)\nCreates the object that defines and positions the content of an expanded Live Activity in the Dynamic Island.\nstruct DynamicIslandExpandedRegionPosition\nView positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContent\nA view that describes the expanded presentation of a Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContentBuilder\nA result builder that constructs the content of an expanded Live Activity in the Dynamic Island."
  },
  {
    "title": "init(_:priority:content:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregion/init(_:priority:content:)",
    "html": "Parameters\nposition\n\nThe position for Live Activity content.\n\npriority\n\nThe priority that tells the system which content to prioritize when it sizes the content of an expanded Live Activity in the Dynamic Island.\n\ncontent\n\nThe content of an expanded Live Activity.\n\nSee Also\nCreating the expanded presentation\nstruct DynamicIslandExpandedRegionPosition\nView positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedRegionVerticalPlacement\nVertical view positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContent\nA view that describes the expanded presentation of a Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContentBuilder\nA result builder that constructs the content of an expanded Live Activity in the Dynamic Island."
  },
  {
    "title": "DynamicIslandExpandedContent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedcontent",
    "html": "Overview\n\nThis view holds the intermediate content for the DynamicIslandExpandedContentBuilder.\n\nSee Also\nCreating the expanded presentation\ninit(DynamicIslandExpandedRegionPosition, priority: Double, content: () -> Content)\nCreates the object that defines and positions the content of an expanded Live Activity in the Dynamic Island.\nstruct DynamicIslandExpandedRegionPosition\nView positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedRegionVerticalPlacement\nVertical view positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContentBuilder\nA result builder that constructs the content of an expanded Live Activity in the Dynamic Island."
  },
  {
    "title": "init(expanded:compactLeading:compactTrailing:minimal:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicisland/init(expanded:compactleading:compacttrailing:minimal:)",
    "html": "Parameters\nexpanded\n\nA closure that builds the view for the expanded presentation of the Live Activity.\n\ncompactLeading\n\nA closure that builds the view for the compact leading presentation of the Live Activity.\n\ncompactTrailing\n\nA closure that builds the view for the compact trailing presentation of the Live Activity.\n\nminimal\n\nA closure that builds the view for the minimal presentation of the Live Activity.\n\nSee Also\nCreating the view for the Dynamic Island\nstruct DynamicIslandExpandedRegion\nA structure that defines and positions the content of an expanded Live Activity in the Dynamic Island."
  },
  {
    "title": "PreviewActivityBuilder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewactivitybuilder",
    "html": "Topics\nPreviewing Live Activities\nstatic func buildArray([[A.ContentState]]) -> [A.ContentState]\nstatic func buildExpression(A.ContentState) -> [A.ContentState]\nstatic func buildPartialBlock(accumulated: [A.ContentState], next: [A.ContentState]) -> [A.ContentState]\nstatic func buildPartialBlock(first: [A.ContentState]) -> [A.ContentState]\nSee Also\nGenerated structures\nstruct PreviewTimelineBuilder"
  },
  {
    "title": "keylineTint(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicisland/keylinetint(_:)",
    "html": "Parameters\ncolor\n\nThe tint color to use.\n\nReturn Value\n\nThe configuration object for the Dynamic Island with the specified keyline tint color."
  },
  {
    "title": "TimelineProviderContext.EnvironmentVariants | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovidercontext/environmentvariants-swift.struct",
    "html": "Overview\n\nWhen changes occur in environment values that affect display, like colorScheme, WidgetKit renders your widget’s views. If your widget uses assets that take time to generate or depend on the specific environment they’re rendered in, you can generate those assets in advance based on the new environment values.\n\nFor example, in macOS, if the user has a mixture of @1x and @2x displays, the value for displayScale includes both scales. With these values, you can prepare your content in advance, if needed, to handle either type of display.\n\nTopics\nSubscripts\nsubscript<T>(WritableKeyPath<EnvironmentValues, T>) -> [T]?\nReturns the widget environment variants for a key path to an environment values instance.\nsubscript<T>(dynamicMember _: WritableKeyPath<EnvironmentValues, T>) -> [T]?\nReturns the widget environment variants for a key path to an environment values instance.\nSee Also\nAccessing Environment Variations\nlet environmentVariants: TimelineProviderContext.EnvironmentVariants\nAll environment values that might be set when a widget appears."
  },
  {
    "title": "environmentVariants | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovidercontext/environmentvariants-swift.property",
    "html": "See Also\nAccessing Environment Variations\nstruct EnvironmentVariants\nA structure containing all varieties of environments where a widget could appear."
  },
  {
    "title": "displaySize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovidercontext/displaysize",
    "html": "See Also\nAccessing Size Attributes\nlet family: WidgetFamily\nThe user-configured family of the widget: small, medium, or large."
  },
  {
    "title": "shared | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/shared",
    "html": "See Also\nGetting Widget Information\nfunc getCurrentConfigurations((Result<[WidgetInfo], Error>) -> Void)\nRetrieves information about user-configured widgets.\nstruct UserInfoKey\nAn object that defines keys for accessing information in a user info dictionary."
  },
  {
    "title": "getSnapshot(for:in:completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider/getsnapshot(for:in:completion:)",
    "html": "Required\n\nParameters\nconfiguration\n\nThe intent containing user-customized values.\n\ncontext\n\nAn object describing the context to show the widget in.\n\ncompletion\n\nThe completion handler to call after you create the snapshot entry.\n\nDiscussion\n\nWidgetKit calls getSnapshot(for:in:completion:) when the widget appears in transient situations. If context.isPreview is true, the widget appears in the widget gallery. In that case, call the completion handler as quickly as possible, perhaps supplying sample data if it could take more than a few seconds to fetch or calculate the widget’s current state.\n\nThe configuration parameter provides user-customized values, as defined in your custom intent definition.\n\nSee Also\nGenerating Timelines\nfunc getTimeline(for: Self.Intent, in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : INIntent\nThe intent that contains user-customized values.\n\nRequired\n\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\n\nRequired Default implementation provided.\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "init(intent:description:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintentrecommendation/init(intent:description:)-2p4dh",
    "html": "Parameters\nintent\n\nThe intent that represents the recommended configuration.\n\ndescription\n\nA key for a localized string in your bundle that helps the user understand the value of the preconfigured configuration option. For example, if the configuration represents a location in a weather app, the description may be the name of one of the user’s favorite cities, such as Cupertino.\n\nDiscussion\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — AppIntentRecommendation is inactive.\n\nSee Also\nCreating a recommended widget configuration\ninit(intent: Intent, description: Text)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets.\ninit(intent: Intent, description: some StringProtocol)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets."
  },
  {
    "title": "reloadAllTimelines() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/reloadalltimelines()",
    "html": "See Also\nReloading Widget Timelines\nfunc reloadTimelines(ofKind: String)\nReloads the timelines for all widgets of a particular kind."
  },
  {
    "title": "WidgetCenter.UserInfoKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/userinfokey",
    "html": "Overview\n\nNote\n\nIn Objective-C, use WGWidgetUserInfoKeyFamily and WGWidgetUserInfoKeyKind instead.\n\nTopics\nDescribing a widget\nstatic let family: String\nA key you use to access the widget’s family.\nstatic let kind: String\nA key you use to access the widget’s kind. The value matches the kind property specified in the widget’s configuration.\nDescribing a Live Activity\nstatic let activityID: String\nA key you use to access the activity ID if the widget represents a Live Activity.\nSee Also\nGetting Widget Information\nstatic let shared: WidgetCenter\nThe shared widget center.\nfunc getCurrentConfigurations((Result<[WidgetInfo], Error>) -> Void)\nRetrieves information about user-configured widgets."
  },
  {
    "title": "Entry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovider/entry",
    "html": "Required\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry that represents the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "ActivityPreviewViewKind.DynamicIslandPreviewViewState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activitypreviewviewkind/dynamicislandpreviewviewstate",
    "html": "Topics\nDynamic Island presentations\ncase compact\nThe presentation of a Live Activity in the Dynamic Island that shows both the compactLeading and compactTrailing views combined.\ncase minimal\nThe minimal presentation of a Live Activity in the Dynamic Island.\ncase expanded\nThe expanded presentation of a Live Activity in the Dynamic Island.\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nLive Activity preview types\ncase content\nThe Live Activity presentation that appears on the Lock Screen and as a banner on devices that don’t support the Dynamic Island.\ncase dynamicIsland(ActivityPreviewViewKind.DynamicIslandPreviewViewState)\nThe Live Activity presentation that appears in the Dynamic Island."
  },
  {
    "title": "ActivityPreviewViewKind.content | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activitypreviewviewkind/content",
    "html": "See Also\nLive Activity preview types\ncase dynamicIsland(ActivityPreviewViewKind.DynamicIslandPreviewViewState)\nThe Live Activity presentation that appears in the Dynamic Island.\nenum DynamicIslandPreviewViewState\nValues that represent the different presentations of a Live Activity in the Dynamic Island for use in Xcode previews."
  },
  {
    "title": "ActivityPreviewViewKind.dynamicIsland(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activitypreviewviewkind/dynamicisland(_:)",
    "html": "See Also\nLive Activity preview types\ncase content\nThe Live Activity presentation that appears on the Lock Screen and as a banner on devices that don’t support the Dynamic Island.\nenum DynamicIslandPreviewViewState\nValues that represent the different presentations of a Live Activity in the Dynamic Island for use in Xcode previews."
  },
  {
    "title": "WidgetFamily.accessoryCircular | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/accessorycircular",
    "html": "Discussion\n\nThe accessory circular widget can appear as a complication in watchOS, or on the Lock Screen in iOS and iPadOS.\n\nNote\n\nWidgets on the iPad Lock Screen require iPadOS 17 or later.\n\nSee Also\nAccessing accessory families\ncase accessoryCorner\nA widget-based complication in the corner of a watch face in watchOS.\ncase accessoryRectangular\nA rectangular widget.\ncase accessoryInline\nA flat widget that contains a single row of text and an optional image."
  },
  {
    "title": "widgetURL(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicisland/widgeturl(_:)",
    "html": "Parameters\nurl\n\nThe URL that opens the app.\n\nReturn Value\n\nThe configuration object for the Dynamic Island with the specified URL.\n\nDiscussion\n\nBy setting the URL with this function, it becomes the default URL for deep linking into the app for each view of the Live Activity. However, if you include a Link in the Live Activity, the link takes priority over the default URL. When a person taps on the Link, it takes them to the place in the app that corresponds to the URL of the Link."
  },
  {
    "title": "DynamicIslandExpandedRegion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandexpandedregion",
    "html": "Overview\n\nThe expanded presentation of a Live Activity in the Dynamic Island consists of four regions:\n\ncenter places content right below the TrueDepth camera.\n\nleading places content along the leading edge of the expanded Live Activity next to the TrueDepth camera and wraps additional content below it.\n\ntrailing places content along the trailing edge of the expanded Live Activity next to the TrueDepth camera and wraps additional content below it.\n\nbottom places content below leading, trailing, and center content.\n\nTopics\nCreating the expanded presentation\ninit(DynamicIslandExpandedRegionPosition, priority: Double, content: () -> Content)\nCreates the object that defines and positions the content of an expanded Live Activity in the Dynamic Island.\nstruct DynamicIslandExpandedRegionPosition\nView positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedRegionVerticalPlacement\nVertical view positions of an expanded Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContent\nA view that describes the expanded presentation of a Live Activity that appears in the Dynamic Island.\nstruct DynamicIslandExpandedContentBuilder\nA result builder that constructs the content of an expanded Live Activity in the Dynamic Island.\nSpecifying custom content margins\nfunc contentMargins(Edge.Set, Double) -> DynamicIslandExpandedRegion<Content>\nOverrides default content margins for the provided edges in the Dynamic Island.\nAvailable when Content conforms to View.\nSee Also\nCreating the view for the Dynamic Island\ninit<Expanded, CompactLeading, CompactTrailing, Minimal>(expanded: () -> DynamicIslandExpandedContent<Expanded>, compactLeading: () -> CompactLeading, compactTrailing: () -> CompactTrailing, minimal: () -> Minimal)\nCreates a configuration object with views that appear in the Dynamic Island."
  },
  {
    "title": "contentMargins(_:_:for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicisland/contentmargins(_:_:for:)",
    "html": "Parameters\nedges\n\nThe edges that should use custom content margins.\n\nlength\n\nThe value for the custom content margin for the specified edges.\n\nfor\n\nThe presentation of the Dynamic Island that the custom content margins apply to.\n\nReturn Value\n\nThe Dynamic Island view with updated content margins.\n\nDiscussion\n\nUse this modifier to customize the content margins for a content mode in the Dynamic Island. The following example uses the default margin for the leading edge and sets a custom margin of 8 points for the top, bottom, and trailing edges of a Live Activity in the expanded presentation.\n\ndynamicIsland\n    .contentMargin([.top, .bottom, .trailing], 8, for:.expanded)\n\n\nWhen you override default content margins, avoid placing content too close to the edges of the Dynamic Island.\n\nWhen applying multiple contentMargins(_:_:for:) modifiers, modifiers with the same placement override modifiers higher up in the view hierarchy. The following example results in a margin of 8 points for the trailing edge and 20 points for all other edges when the Live Activity appears in the expanded presentation:\n\ndynamicIsland\n    .contentMargins(.trailing, 8, for:.expanded)\n    .contentMargins(20, for:.expanded)\n\nSee Also\nSpecifying content margins\nstruct DynamicIslandMode\nA structure that offers values that describe the content mode for a Live Activity."
  },
  {
    "title": "DynamicIslandMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicislandmode",
    "html": "Topics\nDynamic Island presentations\nstatic let compactLeading: DynamicIslandMode\nThe compact leading presentation of a Live Activity in the Dynamic Island.\nstatic let compactTrailing: DynamicIslandMode\nThe compact trailing presentation of a Live Activity in the Dynamic Island.\nstatic let expanded: DynamicIslandMode\nThe expanded presentation of a Live Activity in the Dynamic Island.\nstatic let minimal: DynamicIslandMode\nThe minimal presentation of a Live Activity in the Dynamic Island.\nRelationships\nConforms To\nEquatable\nSee Also\nSpecifying content margins\nfunc contentMargins(Edge.Set, Double, for: DynamicIslandMode) -> DynamicIsland\nOverrides default content margins for the provided content modes in the Dynamic Island."
  },
  {
    "title": "ActivityViewContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activityviewcontext",
    "html": "Topics\nDescribing a Live Activity\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content at the time of its creation.\nlet state: Attributes.ContentState\nThe dynamic content of a Live Activity at the time of its creation.\nlet isStale: Bool\nA Boolean value that describes whether the Live Activity is out of date.\nlet activityID: String\nA unique identifier for the Live Activity.\nSee Also\nCreating a Live Activity configuration\ninit<Content>(for: Attributes.Type, content: (ActivityViewContext<Attributes>) -> Content, dynamicIsland: (ActivityViewContext<Attributes>) -> DynamicIsland)\nCreates a configuration object for a Live Activity."
  },
  {
    "title": "Preview(_:as:widget:timelineProvider:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/preview(_:as:widget:timelineprovider:)",
    "html": "Parameters\nname\n\nAn optional display name for the preview, which will appear in the canvas.\n\nfamily\n\nThe widget family to display.\n\nwidget\n\nA closure producing the widget to be previewed.\n\ntimelineProvider\n\nA closure producing the timeline provider that will generate the preview’s timeline.\n\nOverview\n\nThe preview will allow you to step through the timeline generated by the provider. It might be helpful to instantiate your timeline provider with sample data.\n\nNote\n\nThe timeline provider must be of the type expected by the widget. (This will be enforced at run-time.)\n\nSee Also\nProviding a widget preview\nmacro Preview<Widget>(String?, as: WidgetFamily, widget: () -> Widget, timeline: () async -> [TimelineEntry])\nPreview a timeline-style widget."
  },
  {
    "title": "init(for:content:dynamicIsland:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activityconfiguration/init(for:content:dynamicisland:)",
    "html": "Parameters\nattributesType\n\nThe type that describes the content of the Live Activity.\n\ncontent\n\nA closure that creates the view for the Live Activity that appears on the Lock Screen. This view also appears as a banner on the Home Screen of devices that don’t support the Dynamic Island when you alert a person about updated Live Activity content.\n\ndynamicIsland\n\nA closure that builds the Live Activity that appears in the Dynamic Island.\n\nSee Also\nCreating a Live Activity configuration\nstruct ActivityViewContext\nA structure that describes the view context for creating the views of a Live Activity."
  },
  {
    "title": "WidgetFamily.accessoryRectangular | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/accessoryrectangular",
    "html": "Discussion\n\nIn watchOS, the accessory rectangular widget can appear as a widget in the Smart Stack or as a complication on a watch face. In iOS and iPadOS, it can appear on the Lock Screen.\n\nNote\n\nWidgets on the iPad Lock Screen require iPadOS 17 or later.\n\nSee Also\nAccessing accessory families\ncase accessoryCircular\nA circular widget.\ncase accessoryCorner\nA widget-based complication in the corner of a watch face in watchOS.\ncase accessoryInline\nA flat widget that contains a single row of text and an optional image."
  },
  {
    "title": "Preview(_:as:widget:timeline:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/preview(_:as:widget:timeline:)",
    "html": "Parameters\nname\n\nAn optional display name for the preview, which will appear in the canvas.\n\nfamily\n\nThe widget family to display.\n\nwidget\n\nA closure producing the widget to be previewed.\n\ntimeline\n\nA closure building the timeline of entries to be previewed.\n\nOverview\n\nThe preview will allow you to step through your timeline and test out the transitions between entries. (The dates of the entries will be ignored.)\n\nNote\n\nThe timeline entries must be of the type expected by the widget. (This will be enforced at run-time.)\n\nSee Also\nProviding a widget preview\nmacro Preview<Widget, Provider>(String?, as: WidgetFamily, widget: () -> Widget, timelineProvider: () -> Provider)\nPreview a widget with a static configuration, using the specified timeline provider."
  },
  {
    "title": "Preview(_:as:using:widget:contentStates:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/preview(_:as:using:widget:contentstates:)",
    "html": "Parameters\nname\n\nAn optional display name for the preview, which will appear in the canvas.\n\nviewKind\n\nThe kind of widget view to display.\n\nattributes\n\nThe attributes with which to configure the widget.\n\nwidget\n\nA closure producing the widget to be previewed.\n\ncontentStates\n\nA closure building the content states to be previewed.\n\nOverview\n\nThe preview will allow you to step through the specified content states and test out the transitions between states.\n\nNote\n\nThe attributes must be of the type expected by the widget. (This will be enforced at run-time.)"
  },
  {
    "title": "WidgetFamily.systemMedium | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/systemmedium",
    "html": "Discussion\n\nThe medium system widget can appear on the Home Screen or in the Today View in iOS and iPadOS. In macOS, the medium system widget can appear on the desktop or in Notification Center.\n\nSee Also\nAccessing system families\ncase systemSmall\nA small widget.\ncase systemLarge\nA large widget.\ncase systemExtraLarge\nAn extra-large widget."
  },
  {
    "title": "init(family:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetpreviewcontext/init(family:)",
    "html": "Parameters\nfamily\n\nThe template the widget preview uses: small, medium, or large."
  },
  {
    "title": "PreviewTimelineBuilder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/previewtimelinebuilder",
    "html": "Topics\nPreviewing timelines\nstatic func buildArray([[TimelineEntry]]) -> [TimelineEntry]\nstatic func buildExpression(some TimelineEntry) -> [TimelineEntry]\nstatic func buildPartialBlock(accumulated: [TimelineEntry], next: [TimelineEntry]) -> [TimelineEntry]\nstatic func buildPartialBlock(first: [TimelineEntry]) -> [TimelineEntry]\nSee Also\nGenerated structures\nstruct PreviewActivityBuilder"
  },
  {
    "title": "placeholder(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider/placeholder(in:)",
    "html": "Required\n\nParameters\ncontext\n\nAn object that describes the context in which to show the widget.\n\nReturn Value\n\nA timeline entry that represents a placeholder version of the widget.\n\nDiscussion\n\nWhen WidgetKit displays your widget for the first time, it renders the widget’s view as a placeholder. A placeholder view displays a generic representation of your widget, giving the user a general idea of what the widget shows. WidgetKit calls placeholder(in:) to request an entry representing the widget’s placeholder configuration. For example, the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project implements this method for its leaderboard widget as follows:\n\nstruct LeaderboardProvider: TimelineProvider {\n\n\n    public typealias Entry = LeaderboardEntry\n\n\n    func placeholder(in context: Context) -> LeaderboardEntry {\n        return LeaderboardEntry(date: Date(), heros: EmojiRanger.availableHeros)\n    }\n}\n\n\nIn addition, WidgetKit may render your widget as a placeholder if user’s choose to hide sensitive information on Apple Watch or the iPhone Lock Screen. To learn more about redacting sensitive data, see Creating a widget extension.\n\nImportant\n\nplaceholder(in:) is synchronous and returns a TimelineEntry immediately. Return from placeholder(in:) as quickly as possible.\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(for: Self.Intent, in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(for: Self.Intent, in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : INIntent\nThe intent that contains user-customized values.\n\nRequired\n\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\n\nRequired Default implementation provided.\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "init(score:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineentryrelevance/init(score:duration:)",
    "html": "Parameters\nscore\n\nA value on a scale of your choosing, indicating the importance of an entry compared to other entries in the same timeline.\n\nduration\n\nThe number of seconds following an entry’s date that WidgetKit may rotate the widget to the top of the stack."
  },
  {
    "title": "duration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineentryrelevance/duration",
    "html": "See Also\nConfiguring Relevance Properties\nvar score: Float\nA value that indicates the relevance of an entry compared to other entries in the current and past timelines."
  },
  {
    "title": "Entry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider/entry",
    "html": "Required\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(for: Self.Intent, in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(for: Self.Intent, in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Intent : INIntent\nThe intent that contains user-customized values.\n\nRequired\n\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\n\nRequired Default implementation provided.\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "Intent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider/intent",
    "html": "Required\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(for: Self.Intent, in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(for: Self.Intent, in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\n\nRequired Default implementation provided.\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "recommendations() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider/recommendations()-5ltr5",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nIntentTimelineProvider Implementations\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\nSee Also\nGenerating Timelines\nfunc getSnapshot(for: Self.Intent, in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(for: Self.Intent, in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : INIntent\nThe intent that contains user-customized values.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "score | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineentryrelevance/score",
    "html": "See Also\nConfiguring Relevance Properties\nvar duration: TimeInterval\nThe number of seconds, following an entry’s date, that WidgetKit considers the widget for rotation to the top of the stack."
  },
  {
    "title": "relevance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineentry/relevance-2oovl",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nTimelineEntry Implementations\nvar relevance: TimelineEntryRelevance?\nThe relevance of a widget’s content to the user.\nSee Also\nConfiguring Timeline Entry Properties\nvar date: Date\nThe date for WidgetKit to render a widget.\n\nRequired"
  },
  {
    "title": "IntentTimelineProvider.Context | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider/context",
    "html": "Discussion\n\nFor more information, see TimelineProviderContext.\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(for: Self.Intent, in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(for: Self.Intent, in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : INIntent\nThe intent that contains user-customized values.\n\nRequired\n\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\n\nRequired Default implementation provided."
  },
  {
    "title": "reloadTimelines(ofKind:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/reloadtimelines(ofkind:)",
    "html": "Parameters\nkind\n\nA string that identifies the widget and matches the value you used when you created the widget’s configuration.\n\nSee Also\nReloading Widget Timelines\nfunc reloadAllTimelines()\nReloads the timelines for all configured widgets belonging to the containing app."
  },
  {
    "title": "init(entries:policy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timeline/init(entries:policy:)",
    "html": "Parameters\nentries\n\nAn array of timeline entries.\n\npolicy\n\nThe policy that determines the earliest date and time WidgetKit requests a new timeline from a timeline provider.\n\nDiscussion\n\nSet the date and time of the first entry in a timeline to the current date and time. Add entries for future dates and times when you want WidgetKit to update the widget’s view. Note that the widget’s view might not be updated precisely at a timeline entry’s date and time; the update might occur later."
  },
  {
    "title": "TimelineProvider.Context | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovider/context",
    "html": "Discussion\n\nFor more information, see TimelineProviderContext.\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry that represents the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired"
  },
  {
    "title": "Keeping a widget up to date | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/keeping-a-widget-up-to-date",
    "html": "Overview\n\nWidgets use SwiftUI views to display their content. WidgetKit renders the views on your behalf in a separate process. As a result, your widget extension is not continually active, even if the widget is onscreen. Despite your widget not always being active, there are several ways you can keep its content up to date.\n\nPlan reloads within a budget\n\nReloading widgets consumes system resources and causes battery drain due to additional networking and processing. To reduce this performance impact and maintain all-day battery life, limit the frequency and number of updates you request to what’s necessary.\n\nTo manage system load, WidgetKit uses a budget to distribute widget reloads over the course of the day. The budget allocation is dynamic and takes many factors into account, including:\n\nThe frequency and times the widget is visible to the user.\n\nThe widget’s last reload time.\n\nWhether the widget’s containing app is active.\n\nWidgetKit maintains different budgets for each active widget the user adds to their device. For example, if the user adds two instances of a configurable sports widget, showing information for two different teams, each widget has its own budget.\n\nA widget’s budget applies to a 24-hour period. WidgetKit tunes the 24-hour window to the user’s daily usage pattern, which means the daily budget doesn’t necessarily reset at exactly midnight. For a widget the user frequently views, a daily budget typically includes from 40 to 70 refreshes. This rate roughly translates to widget reloads every 15 to 60 minutes, but it’s common for these intervals to vary due to the many factors involved.\n\nNote\n\nThe system takes a few days to learn the user’s behavior. During this learning period, your widget may receive more reloads than normal.\n\nCases in which WidgetKit doesn’t count reloads against your widget’s budget include when:\n\nThe widget’s containing app is in the foreground.\n\nThe widget’s containing app has an active audio or navigation session.\n\nThe widget performs an app intent, such as when the user taps a button or toggles a switch.\n\nThe widget performs an animation.\n\nThe system locale changes.\n\nDynamic Type or Accessibility settings change.\n\nFor cases such as system appearance changes or system locale changes, don’t request a timeline reload from your app. The system updates your widgets automatically. In StandBy, the system refreshes your widget’s display at a system-defined rate that doesn’t count against the its budget.\n\nAlthough your widget timeline provider drives your reload schedule, WidgetKit sometimes reloads your widget to help keep its content fresh. Some common scenarios include:\n\nIf a widget is on a Home Screen page that the user rarely visits, WidgetKit may reduce the frequency of reloads for that widget. Later, when the user views the page, WidgetKit may reload the widget when it becomes visible.\n\nFor widgets that use Location Services, WidgetKit reloads them after a significant location change happens. For more information related to reloads for widgets that use Location Services, see Accessing location information in widgets.\n\nIf your widget can predict points in time that it should reload, the best approach is to generate a timeline for as many future dates as possible. Keep the interval of entries in the timeline as large as possible for the content you display. WidgetKit imposes a minimum amount of time before it reloads a widget. Your timeline provider should create timeline entries that are at least about 5 minutes apart. WidgetKit may coalesce reloads across multiple widgets, affecting the exact time a widget is reloaded.\n\nGenerate a timeline for predictable events\n\nMany widgets have predictable points in time where it makes sense to update their content. For example, a widget that displays weather information might update the temperature hourly throughout the day. A stock market widget could update its content frequently during open market hours, but not at all over the weekend. By planning these times in advance, WidgetKit automatically refreshes your widget when the appropriate time arrives.\n\nWhen you define your widget, you implement a custom TimelineProvider. WidgetKit gets a timeline from your provider, and uses it to track when to update your widget. A timeline is an array of TimelineEntry objects. Each entry in the timeline has a date and time, and additional information the widget needs to display its view. In addition to the timeline entries, the timeline specifies a refresh policy that tells WidgetKit when to request a new timeline.\n\nThe following is an example of a game widget that displays a character’s health level. When the health level is less then 100 percent, the character recovers at a rate of 25 percent per hour. For example, when the character’s health level is 25 percent, it takes 3 hours to fully recover to 100 percent. The following diagram shows how WidgetKit requests the timeline from the provider, rendering the widget at each time specified in the timeline entries.\n\nWhen WidgetKit initially requests the timeline, the provider creates one with four entries. The first entry represents the current time, followed by three entries at hourly intervals. With the refresh policy set to the default atEnd, WidgetKit requests a new timeline after the last date in the timeline’s entries. When each date in the timeline arrives, WidgetKit invokes the widget’s content closure and displays the result. After the last timeline entry passes, WidgetKit repeats the process by asking the provider for a new timeline. Because the character’s health has reached 100 percent, the provider responds with a single entry for the current time and a refresh policy set to never. With this setting, WidgetKit doesn’t ask for another timeline until the app uses WidgetCenter to tell WidgetKit to request a new timeline.\n\nIn addition to the atEnd and never refresh policies, a provider can specify a different date altogether if the timeline might change before or after reaching the end of the entries. For example, if a dragon will appear in 2 hours to challenge the character to a battle, the provider sets the reload policy to after(_:), passing a date 2 hours in the future. The following diagram shows how WidgetKit, after rendering the widget at the 2-hour mark, requests a new one.\n\nDue to the battle with the dragon, the character’s healing will take 2 additional hours to reach 100 percent. The new timeline consists of two entries, one for the current time, and a second entry 2 hours in the future. The timeline specifies atEnd for the refresh policy, indicating there are no more known events that might alter the timeline.\n\nWhen the 2 hours have passed, and the character’s health is at 100 percent, WidgetKit asks the provider for a new timeline. Because the character’s health has recovered, the provider generates the same final timeline as the first diagram above. When the user plays the game and the character’s health level changes, the app uses WidgetCenter to have WidgetKit refresh the timeline and update the widget.\n\nIn addition to specifying a date before the end of the timeline, the provider can specify a date after the end of the timeline. This is useful when you know that the widget’s state will not change until a later time. For example, a stock market widget could create a timeline at the close of the market on Friday with an after(_:) refresh policy specifying the time the market opens on Monday. Because the stock market is closed over the weekend, there is no need to update the widget until the market opens.\n\nImportant\n\nPlan ahead if your widget makes requests to a server when it reloads and uses after(_:) with a specific date in timeline entries. WidgetKit tries to respect the date you specify, which may cause a significant increase in server load when multiple devices reload your widget at around the same time.\n\nInform WidgetKit when a timeline changes\n\nYour app can tell WidgetKit to request a new timeline when something affects a widget’s current timeline. In the game widget example above, if the app receives a push notification indicating a teammate has given the character a healing potion, the app can tell WidgetKit to reload the timeline and update the widget’s content. To reload a specific type of widget, your app uses WidgetCenter, as shown here:\n\nWidgetCenter.shared.reloadTimelines(ofKind: \"com.mygame.character-detail\")\n\n\nThe kind parameter contains the same string as the value used to create the widget’s WidgetConfiguration.\n\nIf your widgets have user-configurable properties, avoid unnecessary reloads by using WidgetCenter to verify that a widget with the appropriate settings exists. For example, when the game receives a push notification about a character receiving a healing potion, it verifies that a widget is showing that character before reloading the timeline.\n\nIn the following code, the app calls getCurrentConfigurations(_:) to retrieve the list of user-configured widgets. It then iterates through the resulting WidgetInfo objects to find one with an intent configured with the character that received the healing potion. If it finds one, the app calls reloadTimelines(ofKind:) for that widget’s kind.\n\nWidgetCenter.shared.getCurrentConfigurations { result in\n    guard case .success(let widgets) = result else { return }\n\n\n    // Iterate over the WidgetInfo elements to find one that matches\n    // the character from the push notification.\n    if let widget = widgets.first(\n        where: { widget in\n            let intent = widget.configuration as? SelectCharacterIntent\n            return intent?.character == characterThatReceivedHealingPotion\n        }\n    ) {\n        WidgetCenter.shared.reloadTimelines(ofKind: widget.kind)\n    }\n}\n\n\nIf your app uses WidgetBundle to support multiple widgets, you can use WidgetCenter to reload the timelines for all your widgets. For example, if your widgets require the user to sign in to an account but they have signed out, you can reload all the widgets by calling:\n\nWidgetCenter.shared.reloadAllTimelines()\n\nDisplay dynamic dates\n\nEven though your widget doesn’t run continually, it can display time-based information that WidgetKit updates live. For example, it might display a countdown timer that continues to count down even if your widget extension isn’t running. For more information, see Displaying dynamic dates in widgets.\n\nLoad data from your server before updating the timeline\n\nYou may need to load new data from your server before reloading a timeline. To do this, use the system’s URL loading system and a URLSession. To learn more, see Making network requests in a widget extension.\n\nSee Also\nTimeline management\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display."
  },
  {
    "title": "getTimeline(for:in:completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider/gettimeline(for:in:completion:)",
    "html": "Required\n\nParameters\nconfiguration\n\nThe intent containing user-customized values.\n\ncontext\n\nAn object describing the context to show the widget in.\n\ncompletion\n\nThe completion handler to call after you create the timeline.\n\nDiscussion\n\nThe configuration parameter provides user-customized values, as defined in your custom intent definition.\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(for: Self.Intent, in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : INIntent\nThe intent that contains user-customized values.\n\nRequired\n\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\n\nRequired Default implementation provided.\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "init(kind:intent:provider:content:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intentconfiguration/init(kind:intent:provider:content:)",
    "html": "Parameters\nkind\n\nA unique string that you choose.\n\nintent\n\nA custom intent definition containing user-editable parameters.\n\nprovider\n\nAn object that determines the timing of updates to the widget’s views.\n\ncontent\n\nA view that renders the widget."
  },
  {
    "title": "init(intent:description:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintentrecommendation/init(intent:description:)-65igj",
    "html": "Parameters\nintent\n\nThe intent that represents the recommended configuration.\n\ndescription\n\nA description that helps the user understand the value of the preconfigured configuration option. For example, if the configuration represents a location in a weather app, the description may be the name of one of the user’s favorite cities, such as Cupertino.\n\nDiscussion\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — AppIntentRecommendation is inactive.\n\nSee Also\nCreating a recommended widget configuration\ninit(intent: Intent, description: LocalizedStringKey)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets with a localized description.\ninit(intent: Intent, description: some StringProtocol)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets."
  },
  {
    "title": "getCurrentConfigurations(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/getcurrentconfigurations(_:)",
    "html": "Parameters\ncompletion\n\nA completion handler called when the widget information is available.\n\nSee Also\nGetting Widget Information\nstatic let shared: WidgetCenter\nThe shared widget center.\nstruct UserInfoKey\nAn object that defines keys for accessing information in a user info dictionary."
  },
  {
    "title": "init(intent:description:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intentrecommendation/init(intent:description:)-1zh33",
    "html": "Parameters\nintent\n\nThe intent that represents the recommended configuration.\n\ndescription\n\nA key for a localized string in your bundle that helps the user understand the value of the preconfigured configuration option. For example, if the configuration represents a location in a weather app, the description may be the name of one of the user’s favorite cities, such as Cupertino.\n\nDiscussion\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — IntentRecommendation is inactive.\n\nSee Also\nCreating a Recommended Widget Configuration\ninit(intent: T, description: Text)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets.\ninit<S>(intent: T, description: S)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets."
  },
  {
    "title": "init(intent:description:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intentrecommendation/init(intent:description:)-4epo2",
    "html": "Parameters\nintent\n\nThe intent that represents the recommended configuration.\n\ndescription\n\nA description that helps the user understand the value of the preconfigured configuration option. For example, if the configuration represents a location in a weather app, the description may be the name of one of the user’s favorite cities, such as Cupertino.\n\nDiscussion\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — IntentRecommendation is inactive.\n\nSee Also\nCreating a Recommended Widget Configuration\ninit(intent: T, description: LocalizedStringKey)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets with a localized description.\ninit<S>(intent: T, description: S)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets."
  },
  {
    "title": "init(intent:description:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intentrecommendation/init(intent:description:)-6v7dj",
    "html": "Parameters\nintent\n\nThe intent that represents the recommended configuration.\n\ndescription\n\nA description that helps the user understand the value of the preconfigured configuration option. For example, if the configuration represents a location in a weather app, the description may be the name of one of the user’s favorite cities, such as Cupertino.\n\nDiscussion\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — IntentRecommendation is inactive.\n\nSee Also\nCreating a Recommended Widget Configuration\ninit(intent: T, description: LocalizedStringKey)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets with a localized description.\ninit(intent: T, description: Text)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets."
  },
  {
    "title": "widgetConfigurationIntent(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetinfo/widgetconfigurationintent(of:)",
    "html": "Parameters\nintentType\n\nThe expected type for the App Intent.\n\nReturn Value\n\nAn App Intent that contains the user-edited values or nil if there is no associated App Intent or the type does not match intentType."
  },
  {
    "title": "lockScreen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetlocation/lockscreen",
    "html": "See Also\nSpecifying a location style\nstatic let homeScreen: WidgetLocation\nThe Home Screen, Today View, Mac desktop, or similar location."
  },
  {
    "title": "homeScreen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetlocation/homescreen",
    "html": "See Also\nSpecifying a location style\nstatic let lockScreen: WidgetLocation\nThe Lock Screen location."
  },
  {
    "title": "getTimeline(in:completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovider/gettimeline(in:completion:)",
    "html": "Required\n\nParameters\ncontext\n\nAn object describing the context to show the widget in.\n\ncompletion\n\nThe completion handler to call after you create the timeline.\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry that represents the current time and state of a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "placeholder(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovider/placeholder(in:)",
    "html": "Required\n\nParameters\ncontext\n\nAn object that describes the context in which to show the widget.\n\nReturn Value\n\nA timeline entry that represents a placeholder version of the widget.\n\nDiscussion\n\nWhen WidgetKit displays your widget for the first time, it renders the widget’s view as a placeholder. A placeholder view displays a generic representation of your widget, giving the user a general idea of what the widget shows. WidgetKit calls placeholder(in:) to request an entry representing the widget’s placeholder configuration. For example, the game status widget would implement this method as follows:\n\n```swift\nstruct GameStatusProvider: TimelineProvider {\n    func placeholder(in context: Context) -> SimpleEntry {\n       GameStatusEntry(date: Date(), gameStatus: \"—\")\n    }\n}\n\n\nIn addition, WidgetKit may render your widget as a placeholder if users choose to hide sensitive information on Apple Watch or the iPhone Lock Screen. To learn more about redacting sensitive data, see Creating a widget extension.\n\nImportant\n\nplaceholder(in:) is synchronous and returns a TimelineEntry immediately. Return from placeholder(in:) as quickly as possible.\n\nSee Also\nGenerating Timelines\nfunc getSnapshot(in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry that represents the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "Displaying dynamic dates in widgets | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/displaying-dynamic-dates",
    "html": "Overview\n\nBecause your widget extension isn’t always running, you can’t directly update your widget’s content. Instead, WidgetKit renders your widget’s view on your behalf and displays the result. However, some SwiftUI views let you display content that continues updating while your widget is visible.\n\nUsing a Text view in your widget, you can display dates and times that stay up to date onscreen. The following examples show the combinations available.\n\nTo display a relative time that updates automatically:\n\nlet components = DateComponents(minute: 11, second: 14)\nlet futureDate = Calendar.current.date(byAdding: components, to: Date())!\n\n\nText(futureDate, style: .relative)\n// Displays:\n// 11 min, 14 sec\n\n\nText(futureDate, style: .offset)\n// Displays:\n// -11 minutes\n\n\nUsing the relative style shows the absolute difference between the current date and time and the date specified, regardless of whether the date is in the future or the past. The offset style shows the difference between the current date and time and the date specified, indicating dates in the future with a minus sign (-) prefix and dates in the past with a plus sign (+) prefix.\n\nTo display a timer that continues updating automatically:\n\nlet components = DateComponents(minute: 15)\nlet futureDate = Calendar.current.date(byAdding: components, to: Date())!\n\n\nText(futureDate, style: .timer)\n// Displays:\n// 15:00\n\n\nFor dates in the future, the timer style counts down until the current time reaches the specified date and time, and counts up when the date passes.\n\nTo display an absolute date or time:\n\n// Absolute Date or Time\nlet components = DateComponents(year: 2020, month: 4, day: 1, hour: 9, minute: 41)\nlet aprilFirstDate = Calendar.current(components)!\n\n\nText(aprilFirstDate, style: .date)\nText(\"Date: \\(aprilFirstDate, style: .date)\")\nText(\"Time: \\(aprilFirstDate, style: .time)\")\n\n\n// Displays:\n// April 1, 2020\n// Date: April 1, 2020\n// Time: 9:41AM\n\n\nAnd finally, to display a time interval between two dates:\n\nlet startComponents = DateComponents(hour: 9, minute: 30)\nlet startDate = Calendar.current.date(from: startComponents)!\n\n\nlet endComponents = DateComponents(hour: 14, minute: 45)\nlet endDate = Calendar.current.date(from: endComponents)!\n\n\nText(startDate ... endDate)\nText(\"The meeting will take place: \\(startDate ... endDate)\")\n\n\n// Displays:\n// 9:30AM-2:45PM\n// The meeting will take place: 9:30AM-2:45PM\n"
  },
  {
    "title": "getSnapshot(in:completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovider/getsnapshot(in:completion:)",
    "html": "Required\n\nParameters\ncontext\n\nAn object describing the context to show the widget in.\n\ncompletion\n\nThe completion handler to call after you create the snapshot entry.\n\nDiscussion\n\nWidgetKit calls getSnapshot(in:completion:) when the widget appears in transient situations. If context.isPreview is true, the widget appears in the widget gallery. In that case, call the completion handler as quickly as possible, perhaps supplying sample data if it could take more than a few seconds to fetch or calculate the widget’s current state.\n\nSee Also\nGenerating Timelines\nfunc getTimeline(in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
  },
  {
    "title": "family | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovidercontext/family",
    "html": "See Also\nAccessing Size Attributes\nlet displaySize: CGSize\nThe size, in points, of the widget."
  },
  {
    "title": "init(kind:provider:content:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/staticconfiguration/init(kind:provider:content:)",
    "html": "Parameters\nkind\n\nA unique string that you choose.\n\nprovider\n\nAn object that determines the timing of updates to the widget’s views.\n\ncontent\n\nA view that renders the widget."
  },
  {
    "title": "accented | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetrenderingmode/accented",
    "html": "Discussion\n\nIn watchOS, the system displays accented widget-based complications on many watch faces. For example, when the user selects a color, the Infograph watch face uses white for the default group, and the user-selected color for the accent. However, these colors can change from face to face. In the X-Large watch face, the system applies the selected color to the default group, and colors the accent group white. Other faces use system-defined colors for both groups; for example, the Solar Dial face defines both an accent and a default color, and changes these colors based on the time of day.\n\nWhen applying the colors, the system treats the widget’s views as if they were template images. It replaces the view’s color — rendering the new colors while preserving the view’s alpha channel.\n\nTo control your view’s appearance, add the widgetAccentable(_:) modifier to part of your view’s hierarchy. The system adds that view and all of its subviews to the accent group. It puts all other views in the default group.\n\nvar body: some View {\n    VStack {\n        Text(\"MON\")\n            .font(.caption)\n            .widgetAccentable()\n        Text(\"6\")\n            .font(.title)\n        }\n    }\n}\n\nSee Also\nRendering modes\nstatic let fullColor: WidgetRenderingMode\nThe system renders the widget in full color.\nstatic let vibrant: WidgetRenderingMode\nThe system desaturates the widget, making a monochrome version that it uses to create an adaptive, vibrant effect."
  },
  {
    "title": "WidgetFamily.accessoryCorner | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/accessorycorner",
    "html": "See Also\nAccessing accessory families\ncase accessoryCircular\nA circular widget.\ncase accessoryRectangular\nA rectangular widget.\ncase accessoryInline\nA flat widget that contains a single row of text and an optional image."
  },
  {
    "title": "WidgetFamily.systemExtraLarge | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/systemextralarge",
    "html": "Discussion\n\nThe extra-large system widget can appear on the Home Screen or in the Today View in iPadOS. In macOS, the extra-large system widget can appear on the desktop or in Notification Center.\n\nNote\n\nThis value is only available in iPadOS and macOS.\n\nSee Also\nAccessing system families\ncase systemSmall\nA small widget.\ncase systemMedium\nA medium-sized widget.\ncase systemLarge\nA large widget."
  },
  {
    "title": "vibrant | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetrenderingmode/vibrant",
    "html": "Discussion\n\nThe system displays vibrant widgets on the Lock Screen on iPhone.\n\nSee Also\nRendering modes\nstatic let fullColor: WidgetRenderingMode\nThe system renders the widget in full color.\nstatic let accented: WidgetRenderingMode\nThe system divides the widget’s view hierarchy into an accent group and a default group, applying a different color to each group."
  },
  {
    "title": "fullColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetrenderingmode/fullcolor",
    "html": "Discussion\n\nIn this mode, the system doesn’t alter or filter the widget’s colors.\n\nThe system displays full-color widget-based complications on some watch faces, such as the Infograph face, on the Home Screen or Today View in iOS or iPadOS, and in Notification Center on macOS.\n\nNote\n\nThe Infograph face only uses full-color rendering when the user sets the face to multicolor. If the user selects an accent color, the system uses accented instead.\n\nSee Also\nRendering modes\nstatic let accented: WidgetRenderingMode\nThe system divides the widget’s view hierarchy into an accent group and a default group, applying a different color to each group.\nstatic let vibrant: WidgetRenderingMode\nThe system desaturates the widget, making a monochrome version that it uses to create an adaptive, vibrant effect."
  },
  {
    "title": "WidgetFamily.systemSmall | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/systemsmall",
    "html": "Discussion\n\nThe small system widget can appear on the Home Screen or in the Today View in iOS and iPadOS. Starting with iPadOS 17, it also appears on the iPad Lock Screen. In macOS, the small system widget can appear on the desktop or in Notification Center.\n\nSee Also\nAccessing system families\ncase systemMedium\nA medium-sized widget.\ncase systemLarge\nA large widget.\ncase systemExtraLarge\nAn extra-large widget."
  },
  {
    "title": "recommendations() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider/recommendations()-766em",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nAppIntentTimelineProvider Implementations\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\nSee Also\nGenerating timelines\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nfunc snapshot(for: Self.Intent, in: Self.Context) async -> Self.Entry\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc timeline(for: Self.Intent, in: Self.Context) async -> Timeline<Self.Entry>\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : WidgetConfigurationIntent\nThe intent that contains user-customized values.\n\nRequired"
  },
  {
    "title": "placeholder(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider/placeholder(in:)",
    "html": "Required\n\nParameters\ncontext\n\nAn object that describes the context in which to show the widget.\n\nReturn Value\n\nA timeline entry that represents a placeholder version of the widget.\n\nDiscussion\n\nWhen WidgetKit displays your widget for the first time, it renders the widget’s view as a placeholder. A placeholder view displays a generic representation of your widget, giving the user a general idea of what the widget shows. WidgetKit calls placeholder(in:) to request an entry representing the widget’s placeholder configuration. For example, the game status widget would implement this method as follows:\n\n```swift\nstruct GameStatusProvider: TimelineProvider {\n    func placeholder(in context: Context) -> SimpleEntry {\n       GameStatusEntry(date: Date(), gameStatus: \"—\")\n    }\n}\n\n\nIn addition, WidgetKit may render your widget as a placeholder if user’s choose to hide sensitive information on Apple Watch or the iPhone Lock Screen. To learn more about redacting sensitive data, see Creating a widget extension.\n\nImportant\n\nplaceholder(in:) is synchronous and returns a TimelineEntry immediately. Return from placeholder(in:) as quickly as possible.\n\nSee Also\nGenerating timelines\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\n\nRequired Default implementation provided.\n\nfunc snapshot(for: Self.Intent, in: Self.Context) async -> Self.Entry\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc timeline(for: Self.Intent, in: Self.Context) async -> Timeline<Self.Entry>\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : WidgetConfigurationIntent\nThe intent that contains user-customized values.\n\nRequired"
  },
  {
    "title": "timeline(for:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider/timeline(for:in:)",
    "html": "Required\n\nParameters\nconfiguration\n\nThe intent containing user-customized values.\n\ncontext\n\nAn object describing the context to show the widget in.\n\nReturn Value\n\nAn array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nDiscussion\n\nThe configuration parameter provides user-customized values, as defined in your custom intent.\n\nSee Also\nGenerating timelines\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\n\nRequired Default implementation provided.\n\nfunc snapshot(for: Self.Intent, in: Self.Context) async -> Self.Entry\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : WidgetConfigurationIntent\nThe intent that contains user-customized values.\n\nRequired"
  },
  {
    "title": "snapshot(for:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider/snapshot(for:in:)",
    "html": "Required\n\nParameters\nconfiguration\n\nThe intent containing user-customized values.\n\ncontext\n\nAn object describing the context to show the widget in.\n\nReturn Value\n\nA timeline entry representing the current time and state of a widget\n\nDiscussion\n\nWidgetKit calls snapshot(for:in:) when the widget appears in transient situations. If context.isPreview is true, the widget appears in the widget gallery. In that case, return the Entry as quickly as possible, perhaps supplying sample data if it could take more than a few seconds to fetch or calculate the widget’s current state.\n\nThe configuration parameter provides user-customized values, as defined in your custom intent.\n\nSee Also\nGenerating timelines\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\n\nRequired Default implementation provided.\n\nfunc timeline(for: Self.Intent, in: Self.Context) async -> Timeline<Self.Entry>\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : WidgetConfigurationIntent\nThe intent that contains user-customized values.\n\nRequired"
  },
  {
    "title": "Entry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider/entry",
    "html": "Required\n\nSee Also\nGenerating timelines\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\n\nRequired Default implementation provided.\n\nfunc snapshot(for: Self.Intent, in: Self.Context) async -> Self.Entry\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc timeline(for: Self.Intent, in: Self.Context) async -> Timeline<Self.Entry>\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nassociatedtype Intent : WidgetConfigurationIntent\nThe intent that contains user-customized values.\n\nRequired"
  },
  {
    "title": "Intent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider/intent",
    "html": "Required\n\nSee Also\nGenerating timelines\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\n\nRequired Default implementation provided.\n\nfunc snapshot(for: Self.Intent, in: Self.Context) async -> Self.Entry\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc timeline(for: Self.Intent, in: Self.Context) async -> Timeline<Self.Entry>\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired"
  },
  {
    "title": "AppIntentTimelineProvider.Context | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider/context",
    "html": "Discussion\n\nFor more information, see TimelineProviderContext.\n\nSee Also\nGenerating timelines\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\n\nRequired Default implementation provided.\n\nfunc snapshot(for: Self.Intent, in: Self.Context) async -> Self.Entry\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc timeline(for: Self.Intent, in: Self.Context) async -> Timeline<Self.Entry>\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : WidgetConfigurationIntent\nThe intent that contains user-customized values.\n\nRequired"
  },
  {
    "title": "never | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelinereloadpolicy/never",
    "html": "See Also\nReload Policies\nstatic let atEnd: TimelineReloadPolicy\nA policy that specifies that WidgetKit requests a new timeline after the last date in a timeline passes.\nstatic func after(Date) -> TimelineReloadPolicy\nA policy that specifies a future date for WidgetKit to request a new timeline."
  },
  {
    "title": "after(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelinereloadpolicy/after(_:)",
    "html": "See Also\nReload Policies\nstatic let atEnd: TimelineReloadPolicy\nA policy that specifies that WidgetKit requests a new timeline after the last date in a timeline passes.\nstatic let never: TimelineReloadPolicy\nA policy that specifies that the app prompts WidgetKit when a new timeline is available."
  },
  {
    "title": "atEnd | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelinereloadpolicy/atend",
    "html": "See Also\nReload Policies\nstatic func after(Date) -> TimelineReloadPolicy\nA policy that specifies a future date for WidgetKit to request a new timeline.\nstatic let never: TimelineReloadPolicy\nA policy that specifies that the app prompts WidgetKit when a new timeline is available."
  },
  {
    "title": "entries | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timeline/entries",
    "html": "See Also\nGetting Timeline Properties\nlet policy: TimelineReloadPolicy\nThe policy that determines the earliest date and time WidgetKit requests a new timeline from a timeline provider.\nstruct TimelineReloadPolicy\nA type that indicates the earliest date WidgetKit requests a new timeline from the widget’s provider."
  },
  {
    "title": "TimelineReloadPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelinereloadpolicy",
    "html": "Topics\nReload Policies\nstatic let atEnd: TimelineReloadPolicy\nA policy that specifies that WidgetKit requests a new timeline after the last date in a timeline passes.\nstatic func after(Date) -> TimelineReloadPolicy\nA policy that specifies a future date for WidgetKit to request a new timeline.\nstatic let never: TimelineReloadPolicy\nA policy that specifies that the app prompts WidgetKit when a new timeline is available.\nRelationships\nConforms To\nEquatable\nSee Also\nGetting Timeline Properties\nlet entries: [EntryType]\nAn array of timeline entries.\nlet policy: TimelineReloadPolicy\nThe policy that determines the earliest date and time WidgetKit requests a new timeline from a timeline provider."
  },
  {
    "title": "policy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timeline/policy",
    "html": "See Also\nGetting Timeline Properties\nlet entries: [EntryType]\nAn array of timeline entries.\nstruct TimelineReloadPolicy\nA type that indicates the earliest date WidgetKit requests a new timeline from the widget’s provider."
  },
  {
    "title": "WidgetCenter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter",
    "html": "Overview\n\nWidgetCenter provides information about user-configured widgets, such as their family. For widgets that use IntentConfiguration, you can retrieve the user-edited values.\n\nGetting Configured Widget Information\n\nTo get a list of user-configured widgets, use getCurrentConfigurations(_:). This property provides an array of WidgetInfo objects containing the following information:\n\nstruct WidgetInfo {\n    public let configuration: INIntent?\n    public let family: WidgetFamily\n    public let kind: String\n}\n\n\nThe kind string matches the parameter you use when creating the widget’s StaticConfiguration or IntentConfiguration. The family property matches one of the options specified in the supportedFamilies(_:) property of the widget’s configuration. If your widget is based on IntentConfiguration, the configuration property provides the custom intent containing the user-customized values for each individual widget.\n\nRequesting a Reload of Your Widget’s Timeline\n\nChanges in your app’s state may affect a widget’s timeline. When this happens, you can tell WidgetKit to reload the timeline for either a specific kind of widget or all widgets. For example, your app might register for push notifications based on the widgets the user has configured. When your app receives a push notification that changes the state for one or more of your widgets, requesting a reload of their timelines updates their display.\n\nIf you only need to reload a certain kind of widget, you can request a reload for only that kind. For example, in response to a push notification about a change in a game’s status, you could request a reload for only the game status widgets:\n\nWidgetCenter.shared.reloadTimelines(ofKind: \"com.mygame.gamestatus\")\n\n\nTo request a reload for all of your widgets:\n\nWidgetCenter.shared.reloadAllTimelines()\n\nTopics\nGetting Widget Information\nstatic let shared: WidgetCenter\nThe shared widget center.\nfunc getCurrentConfigurations((Result<[WidgetInfo], Error>) -> Void)\nRetrieves information about user-configured widgets.\nstruct UserInfoKey\nAn object that defines keys for accessing information in a user info dictionary.\nReloading Widget Timelines\nfunc reloadTimelines(ofKind: String)\nReloads the timelines for all widgets of a particular kind.\nfunc reloadAllTimelines()\nReloads the timelines for all configured widgets belonging to the containing app.\nReloading Recommended Preconfigured Widgets\nfunc invalidateConfigurationRecommendations()\nInvalidates and refreshes the preconfigured intent configurations for user-customizable widgets.\nSee Also\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display."
  },
  {
    "title": "TimelineEntry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineentry",
    "html": "Overview\n\nA TimelineProvider creates one or more timeline entries with dates that tell WidgetKit when to display a widget. To render a widget, WidgetKit executes the content block of the widget’s configuration, passing the corresponding timeline entry.\n\nWhen you declare a structure conforming to TimelineEntry, include any additional information that the configuration’s content block requires to render the widget. The following code shows a timeline entry structure for a widget that displays a game character’s health level.\n\nstruct CharacterDetailEntry: TimelineEntry {\n    var date: Date\n    var healthLevel: Double\n}\n\n\nThe content block of the widget’s configuration receives the entry as a parameter and then passes the relevant information to the view that renders your widget.\n\nstruct CharacterDetailWidget: Widget {\n    var body: some WidgetConfiguration {\n        StaticConfiguration(\n            kind: \"com.mygame.character-detail\",\n            provider: CharacterDetailProvider()) { entry in\n            CharacterDetailView(entry: entry)\n        }\n        .configurationDisplayName(\"Character Details\")\n        .description(\"Displays a character's health and other details\")\n        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])\n    }\n}\n\nTopics\nConfiguring Timeline Entry Properties\nvar date: Date\nThe date for WidgetKit to render a widget.\n\nRequired\n\nvar relevance: TimelineEntryRelevance?\nThe relevance of a widget’s content to the user.\n\nRequired Default implementation provided.\n\nSee Also\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display."
  },
  {
    "title": "TimelineProviderContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovidercontext",
    "html": "Overview\n\nWhen requesting timelines for a widget, WidgetKit passes the TimelineProvider a context object that includes details about how the widget appears. These details include:\n\nThe WidgetFamily; for example, WidgetFamily.systemSmall and WidgetFamily.systemMedium.\n\nThe size, in points, of the widget.\n\nVariants of the environments where the widget might appear.\n\nWhether the widget appears as a preview in the widget gallery.\n\nIf your widget uses assets that take time to generate or depend on the specific environment they’re rendered in, you can use the environment variants to generate those assets in advance. Some of the common environment properties to consider include:\n\ncolorScheme, where you use different assets for light and dark schemes.\n\ndisplayScale, where your widget might appear in both @1x and @2x displays on macOS devices.\n\nTo be responsive when the environment changes, WidgetKit may render the widget’s view in advance. For example, WidgetKit renders both light and dark versions of the widget so that if the color scheme changes, the correct version is immediately available.\n\nTopics\nPreparing Preview Content\nlet isPreview: Bool\nA Boolean value that indicates when the widget appears in the widget gallery.\nAccessing Size Attributes\nlet family: WidgetFamily\nThe user-configured family of the widget: small, medium, or large.\nlet displaySize: CGSize\nThe size, in points, of the widget.\nAccessing Environment Variations\nlet environmentVariants: TimelineProviderContext.EnvironmentVariants\nAll environment values that might be set when a widget appears.\nstruct EnvironmentVariants\nA structure containing all varieties of environments where a widget could appear.\nSee Also\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display."
  },
  {
    "title": "init(intent:description:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintentrecommendation/init(intent:description:)-7zn32",
    "html": "Parameters\nintent\n\nThe intent that represents the recommended configuration.\n\ndescription\n\nA description that helps the user understand the value of the preconfigured configuration option. For example, if the configuration represents a location in a weather app, the description may be the name of one of the user’s favorite cities, such as Cupertino.\n\nDiscussion\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — AppIntentRecommendation is inactive.\n\nSee Also\nCreating a recommended widget configuration\ninit(intent: Intent, description: LocalizedStringKey)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets with a localized description.\ninit(intent: Intent, description: Text)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets."
  },
  {
    "title": "invalidateConfigurationRecommendations() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetcenter/invalidateconfigurationrecommendations()",
    "html": "Discussion\n\nIn watchOS, call this function when your app receives new data for preconfigured widgets you’d like to appear in the list of available watch complications.\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — invalidateConfigurationRecommendations() is inactive."
  },
  {
    "title": "init(kind:intent:provider:content:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintentconfiguration/init(kind:intent:provider:content:)",
    "html": "Parameters\nkind\n\nA unique string that you choose.\n\nintent\n\nA custom intent containing user-editable parameters.\n\nprovider\n\nAn object that determines the timing of updates to the widget’s views.\n\ncontent\n\nA view that renders the widget."
  },
  {
    "title": "Identifiable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetinfo/identifiable-implementations",
    "html": "Topics\nInstance Properties\nvar id: WidgetInfo\nThe stable identity of the widget."
  },
  {
    "title": "configuration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetinfo/configuration",
    "html": "See Also\nGetting Configured Widget Information\nlet kind: String\nThe string specified during creation of the widget’s configuration.\nlet family: WidgetFamily\nThe size of the widget: small, medium, or large."
  },
  {
    "title": "kind | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetinfo/kind",
    "html": "See Also\nGetting Configured Widget Information\nlet family: WidgetFamily\nThe size of the widget: small, medium, or large.\nlet configuration: INIntent?\nA SiriKit intent that contains user-edited values."
  },
  {
    "title": "family | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetinfo/family",
    "html": "See Also\nGetting Configured Widget Information\nlet kind: String\nThe string specified during creation of the widget’s configuration.\nlet configuration: INIntent?\nA SiriKit intent that contains user-edited values."
  },
  {
    "title": "Migrating widgets from SiriKit Intents to App Intents | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/migrating-from-sirikit-intents-to-app-intents",
    "html": "Overview\n\nStarting with iOS 17 and macOS 14, you use App Intents to create configurable widgets. If you have an existing configurable widgets that uses SiriKit Intents, you can add App Intents while continuing to support older operating system versions.\n\nIf the minimum version your app supports is iOS 17, macOS 14, or watchOS 10, use App Intents for your widget configurations. See Making a configurable widget for details.\n\nFor additional information about converting custom intents to App Intents, watch the Tech Talks session video Migrate custom intents to App Intents.\n\nConvert SiriKit Intents to App Intents\n\nXcode provides automatic conversion from SiriKit Intents to App Intents. Follow these steps to convert an existing intent to an app intent:\n\nIn the Project Navigator, select the Intent Definition File that contains the intent you wish to convert.\n\nChoose the Editor > Convert to App Intent… menu item.\n\nSelect one or more intent definition files from the list of intent definition files, and click Next.\n\nSelect one or more intents from the list of available intents, and click Next.\n\nSelect a location to save the new files in your project, and the targets in which to include the converted intents.\n\nXcode generates source files for new types that conform to the CustomIntentMigratedAppIntent protocol, and sets the intentClassName property to the name of the SiriKit Intent.\n\nUpdate the widget configuration\n\nIn the widget’s body method, add code that does the following:\n\nInstead of using an IntentConfiguration, create an AppIntentConfiguration.\n\nInstead of passing an INIntent type to the app configuration’s initializer, pass the newly converted intent type created as described in the steps above. This new intent type conforms to WidgetConfigurationIntent .\n\nInstead of passing an IntentTimelineProvider, pass a type that confoms to AppIntentTimelineProvider.\n\nTo continue supporting versions earlier than iOS 17, macOS 14, and watchOS 10, factor the creation of the widget’s configuration to a type-erased method that the body method calls, as shown below.\n\nstruct MyWidget: Widget {\n\n\n    // Helper method to create the appropriate configuration depending\n    // on the operating system version.\n    func makeWidgetConfiguration() -> some WidgetConfiguration {\n        if #available(iOS 17.0, macOS 14.0, watchOS 10.0, *) {\n            return AppIntentConfiguration(kind: kind, intent: MyAppIntent.self, provider: MyAppIntentProvider()) { entry in\n                MyAppIntentWidgetEntryView(entry: entry)\n            }\n        } else {\n            return IntentConfiguration(kind: kind, intent: MyIntent.self, provider: MyIntentProvider()) { entry in\n                MyIntentWidgetEntryView(entry: entry)\n            }\n        }\n    }\n\n\n    var body: some WidgetConfiguration {\n        makeWidgetConfiguration()\n            .configurationDisplayName(\"My Widget\")\n            .description(\"This is an example widget.\")\n    }\n}\n\n\nAfter you create app intent types, and switch to using AppIntentConfiguration, the system migrates the user’s widgets configured with SiriKit Intents. The system:\n\nIdentifies the name of the custom INIntent in the widget’s stored configuration.\n\nIdentifies the new app intent that conforms to CustomIntentMigratedAppIntent, in which the intentClassName matches the name of the custom INIntent.\n\nMaps the parameters from the INIntent configuration to the CustomIntentMigratedAppIntent, matching the parameter name and type.\n\nCreates an instance of the new app intent with the mapped parameters.\n\nUses the new app intent for the widget’s configuration instead of the INIntent.\n\nImportant\n\nIf the name or type of the parameters don’t match, the system omits the parameter from the app intent, and the user’s configuration is lost. For example, if the INIntent parameter is an INPerson, use IntentPerson for the app intent type. If the parameter’s type is an enum or custom object, the new type must conform to AppEnum or TransientAppEntity, respectively.\n\nImplement an app intent timeline provider\n\nTo generate timeline entries that use app intents, create a timeline provider that conforms to AppIntentTimelineProvider. The functionality of an AppIntentTimelineProvider is the same as an IntentTimelineProvider; the difference is the associated Intent type. For an AppIntentTimelineProvider, the Intent type is WidgetConfigurationIntent; for an IntentTimelinProvider, it’s an INIntent.\n\nTip\n\nIf your app supports older operating system versions, minimize code duplication by factoring common code out into a separate type used by both providers.\n\nWhen designing the timeline entries that the timeline providers generate, consider these two approaches:\n\nUse separate timeline entry types for each provider: one that includes the app intent, and another that includes a SiriKit intent.\n\nUse a single timeline entry type that includes both an app intent and a SiriKit intent.\n\nThe first approach involves maintaining separate types, possibly duplicating properties in both types, but it’s simpler conceptually. The second approach reduces any duplication, but requires optional types for the intent properties.\n\nDisplay content based on an app intent\n\nWidgetKit displays a widget’s content by calling the widget configuration’s content closure. If you have separate types for your timeline entries, you need to provide a separate content closure for each type.\n\nIf you share the same timeline entry type across both intent provider types, you can use a single content closure with logic conditional to the intent in the entry.\n\nSee Also\nConfigurable widgets\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nstruct AppIntentConfiguration\nAn object describing the content of a widget that uses a custom intent to provide user-configurable options.\nstruct WidgetInfo\nA structure that contains information about user-configured widgets.\nstruct AppIntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nstruct IntentConfiguration\nAn object describing the content of a widget that uses a custom intent definition to provide user-configurable options.\nstruct IntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget."
  },
  {
    "title": "Adding interactivity to widgets and Live Activities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/adding-interactivity-to-widgets-and-live-activities",
    "html": "Overview\n\nStarting with iOS 17, iPadOS 17, or macOS 14, widgets and Live Activities can include buttons and toggles to offer specific app functionality without launching the app. For example, a Reminders widget allows people to mark a task as completed with a toggle. On a locked device, buttons and toggles are inactive and the system doesn’t perform actions unless a person authenticates and unlocks their device.\n\nWhen you create a widget or Live Activity, think about how people interact with it. Then, make your app’s most important actions available directly in a widget or Live Activity by adding buttons or toggles.\n\nImportant\n\nAn interaction with a button or toggle should do more than open the app. If you want to offer an interaction that opens the app, use Link and widgetURL(_:) as described in Linking to specific app scenes from your widget or Live Activity.\n\nWidgets of the following sizes can include buttons and toggles:\n\nWidgetFamily.systemSmall\n\nWidgetFamily.systemMedium\n\nWidgetFamily.systemLarge\n\nWidgetFamily.systemExtraLarge\n\nWidgetFamily.accessoryCircular on iPhone and iPad\n\nWidgetFamily.accessoryRectangular on iPhone and iPad\n\nLive Activities can include buttons or toggles in the expanded and the Lock Screen presentation.\n\nFor design guidance, see Human Interface Guidelines > Widgets.\n\nRelated session from WWDC23\n\nSession 10027: Bring widgets to new places\n\nUnderstand the role of app intents\n\nWidgets offer direct interaction with your app using the App Intents framework and SwiftUI. For example, the large widget of the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project includes a button to boost the hero’s healing power.\n\nTo create widgets and watch complications, you add a widget extension to your project. As a result, any code for widgets and watch complications runs in an independent process that’s separate from your app. Based on your timeline entries, the system archives a view representation and only renders the views using these representations when applicable.\n\nAs a result of the timeline mechanism and of rendering in a separate process, the system can’t run your code or update data bindings at the time it renders your widget. This is where the App Intents framework comes into play. App intents allow you to expose actions of your app to the system and enable it to perform the actions when needed — for example, when a person interacts with a button or a toggle in a widget.\n\nNote\n\nLive Activities don’t use a timeline mechanism to update their content. However, they use WidgetKit and a widget extension with a similar cycle of view archiving and decoding. As a result, you add buttons and toggles to a Live Activity in the same way as do for your widgets, as described below.\n\nAdd an app intent that performs the action\n\nButtons and toggles you add to your widgets and Live Activities use functionality that you expose to the system by adopting the App Intents framework. Before you add a button or toggle, make the app functionality available to the system using an app intent:\n\nFor a widget, create a new structure that adopts the AppIntent protocol and add it to your app target. For a Live Activity interactive, adopt the LiveActivityIntent protocol. If the interaction starts or pauses media playback, adopt the AudioPlaybackIntent protocol.\n\nImplement the protocol’s requirements.\n\nDefine input parameters that your action needs using the @Parameter property wrapper and make sure their type conforms to the AppEntity protocol. Make sure input parameters have assigned values because, unlike app intents you define for system functionality like Siri, widgets don’t resolve parameters for app intents.\n\nIn the protocol’s required perform() function, add code for the action you want to make available to the widget.\n\nFor example, the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project includes a button in its large widget that people click or touch to give the hero a healing boost. The following code snippet shows its app intent implementation:\n\n@available(iOS 16.0, macOS 13.0, watchOS 9.0, tvOS 16.0, *)\nstruct SuperCharge: AppIntent {\n    \n    static var title: LocalizedStringResource = \"Emoji Ranger SuperCharger\"\n    static var description = IntentDescription(\"All heroes get instant 100% health.\")\n    \n    func perform() async throws -> some IntentResult {\n        EmojiRanger.superchargeHeros()\n        return .result()\n    }\n}\n\n\nIf you adopt the LiveActivityIntent or AudioPlaybackIntent protocol, the system runs the app intent in the app’s process. Make sure to add your custom app intent to your app target.\n\nIf you adopt the AppIntent protocol, add your custom app intent to your widget extension target and your app target. Adding it to the app target in addition to the widget extension target allows you to reuse the button or toggle you add to the widget in your app.\n\nImplement the perform function\n\nWhen a person interacts with a button or toggle in your widget, the system runs the perform() function in your app’s process. The function is asynchronous. As a result, you can take full advantage of Swift concurrency. To learn more about concurrency, see The Swift Programming Language > Concurrency and Concurrency.\n\nWhen you return from the perform() function, the system reloads the widget’s timeline using its timeline provider. Use this as an opportunity to update your widget with the result of the interaction. Make sure any code that’s necessary for the timeline update runs before you return from perform(). For example, use the await keyword while you store updated information in your database, and upon completion, return from perform(). Then, the system reloads the widget’s timeline and your timeline provider loads the updated data from your database.\n\nNote\n\nInteractions with a toggle or button always guarantee a timeline reload.\n\nAdditionally, note that the perform() function is marked as throws. Be sure to handle errors instead of rethrowing them, and update your app, widget, and Live Activity as needed. For example, update a widget’s interface to tell a person that it displays outdated information if it can’t load new data.\n\nTip\n\nWith the App Intents framework, you can extend your app’s custom functionality to support system-level services like Siri and the Shortcuts app. Additionally, you use app intents to make your widget configurable. By making your widget interactive, you automatically support system services for that interaction. To learn more about the App Intents framework, see App Intents and Providing your app’s capabilities to system services. To learn more about configurable widgets, see Making a configurable widget.\n\nAdd a button\n\nAfter you’ve implemented the app intent, add a Button to your widget using one of the initializers that take an app intent, for example, init(_:intent:).\n\nTip\n\nYou don’t have to create a Button implementation solely for use in a widget or Live Activity. Reuse the code that adds a button to a widget — including the app intent implementation — in your app.\n\nThe following example shows how the large Emoji Rangers: Supporting Live Activities, interactivity, and animations widget includes a button to give the heroes a healing boost. Note how the sample checks for the presence of iOS 17 before adding the button.\n\n\n\nstruct EmojiRangerWidgetEntryView: View {\n    var entry: SimpleEntry\n    \n    @Environment(\\.widgetFamily) var family\n    \n    @ViewBuilder\n    var body: some View {\n        switch family {\n\n\n        case .systemLarge:\n            VStack {\n                HStack(alignment: .top) {\n                    AvatarView(entry.hero)\n                        .foregroundColor(.white)\n                    Text(entry.hero.bio)\n                        .foregroundColor(.white)\n                }\n                .padding()\n                if #available(iOS 17.0, *) {\n                    HStack(alignment: .top) {\n                        Button(intent: SuperCharge()) {\n                            Image(systemName: \"bolt.fill\")\n                        }\n                    }\n                    .tint(.white)\n                    .padding()\n                }\n            }\n            .containerBackground(for: .widget) {\n                Color.gameBackgroundColor\n            }\n            .widgetURL(entry.hero.url)\n            \n        // Code for other widget sizes.\n    }\n}   \n\n\nAfter you’ve added a button, review views in your widget or Live Activity that change their data when a person interacts with the button. For example, a button press could cause several texts in the widget to reload. This reload may take some time, for example for interactions with an iPhone widget on Mac. To let a person know that the widget is waiting to update its content, add the invalidatableContent(_:) view modifier to views that receive updated data. Use this modifier judiciously; don’t annotate every single view that might change, and use it on views that are important to a person.\n\nNote\n\nA button indicates that a person interacted with it but it doesn’t remain in a pressed state. As a result, use Toggle to indicate on/off functionality.\n\nAdd a toggle\n\nAdd a Toggle to your view using one of the initializers that take an app intent, for example, init(isOn:intent:label:).\n\nThe following example shows how a view of a task manager widget could add a toggle. Note that the initializer’s isOn parameter receives a Boolean value instead of a Binding<Bool> value.\n\nstruct TodoItemView: View {\n    var todo: Todo\n\n\n    var body: some View {\n        Toggle(isOn: todo.complete, intent: ToggleTodoIntent(todo.id)) {\n            Text(todo.body)\n        }\n        .toggleStyle(TodoToggleStyle())\n    }\n}\n\n\nNote\n\nIf you define your own ToggleStyle, check the isOn property and add the correct appearance for on and off states.\n\nThe perform() function runs code asynchronously and may take time to complete, for example, when a person performs an interaction on an iPhone widget on Mac. Toggle updates its appearance optimistically and indicates its new state immediately — without waiting for the result of the performed action.\n\nTo accurately reflect changed state for a person’s action with a Toggle, update the widget with the result of the code you run in the app intent’s perform() function. For example, if a person taps a toggle in a task manager widget to complete a task, the toggle immediately shows the task as complete — even though the logic in perform() still runs. To make sure the widget only shows a task that was actually completed, the perform() implementation can start the following sequence of actions:\n\nMark the task as completed in a database the widget shares with the app.\n\nRun code to synchronize the database with your server.\n\nRefresh the widget’s timeline to show the correct state for the task when your server acknowledges the successful synchronization. The Toggle should show the correct state and not its earlier optimistic prediction.\n\nIn case of an error or server timeout, update the widget to reflect that the task isn’t completed. For example, set the toggle’s isOn property to false and show text in the widget that there’s a synchronization error.\n\nReview interactions in iPhone widgets on Mac\n\nIn the context of iPhone widgets on Mac, it’s important to use the invalidatableContent(_:) view modifier on views if you add a Button to a widget and also understand the optimistic behavior of a Toggle. Starting with iOS 17 and macOS 14, users can put iPhone widgets on their Mac desktop and in Notification Center. When a person interacts with the iPhone widget on Mac, the system sends the interaction to iPhone. On iPhone, the system performs the intent, generates a new timeline, and then sends the updated timeline to the iPhone widget on Mac. This process may take extra time. As a result, marking views that await updated data and making sure a toggle reflects synchronized data are especially important.\n\nSee Also\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment.\nstruct WidgetLocation\nValues that indicate different widget locations."
  },
  {
    "title": "WidgetRenderingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetrenderingmode",
    "html": "Overview\n\nThe system can modify the appearance of accessory family widgets. For example, it renders widgets on the Lock Screen on iPhone using the vibrant mode, while it renders widget-based complications in watchOS using either the fullColor or accented modes, depending on the watch face and the user’s settings.\n\nYou can read the rendering mode from the environment values using the .widgetRenderingMode key.\n\n@Environment(\\.widgetRenderingMode) var widgetRenderingMode\n\n\nYou can then customize your widget’s design based on the rendering mode.\n\nTopics\nRendering modes\nstatic let fullColor: WidgetRenderingMode\nThe system renders the widget in full color.\nstatic let accented: WidgetRenderingMode\nThe system divides the widget’s view hierarchy into an accent group and a default group, applying a different color to each group.\nstatic let vibrant: WidgetRenderingMode\nThe system desaturates the widget, making a monochrome version that it uses to create an adaptive, vibrant effect.\nRelationships\nConforms To\nCustomStringConvertible\nEquatable\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape."
  },
  {
    "title": "WidgetFamily.systemLarge | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/systemlarge",
    "html": "Discussion\n\nThe large system widget can appear on the Home Screen or in the Today View in iOS and iPadOS. In macOS, the large system widget can appear on the desktop or in Notification Center.\n\nSee Also\nAccessing system families\ncase systemSmall\nA small widget.\ncase systemMedium\nA medium-sized widget.\ncase systemExtraLarge\nAn extra-large widget."
  },
  {
    "title": "WidgetFamily.accessoryInline | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily/accessoryinline",
    "html": "Discussion\n\nThe accessory inline widget can appear as a complication in watchOS, or on the Lock Screen in iOS and iPadOS. On some watch faces, the system renders the complication along a curve.\n\nNote\n\nWidgets on the iPad Lock Screen require iPadOS 17 or later.\n\nSee Also\nAccessing accessory families\ncase accessoryCircular\nA circular widget.\ncase accessoryCorner\nA widget-based complication in the corner of a watch face in watchOS.\ncase accessoryRectangular\nA rectangular widget."
  },
  {
    "title": "Emoji Rangers: Supporting Live Activities, interactivity, and animations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/emoji_rangers_supporting_live_activities_interactivity_and_animations",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC23 sessions 10184: Meet ActivityKit, 10185: Update live activities with push notifications, 10027: Bring widgets to new places, and 10028: Bring widgets to life.\n\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nBuilding Widgets Using WidgetKit and SwiftUI\nCreate widgets to show your app’s content on the Home screen, with custom intents for user-customizable settings."
  },
  {
    "title": "Preview(_:as:using:widget:timelineProvider:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/preview(_:as:using:widget:timelineprovider:)-3df1l",
    "html": "Parameters\nname\n\nAn optional display name for the preview, which will appear in the canvas.\n\nfamily\n\nThe widget family to display.\n\nintent\n\nThe intent with which to configure the widget.\n\nwidget\n\nA closure producing the widget to be previewed.\n\ntimelineProvider\n\nA closure producing the timeline provider that will generate the preview’s timeline.\n\nOverview\n\nThe preview will allow you to step through the timeline generated by the provider. It might be helpful to instantiate your timeline provider with sample data.\n\nNote\n\nThe timeline provider must be of the type expected by the widget. (This will be enforced at run-time.)"
  },
  {
    "title": "Creating a widget extension | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension",
    "html": "Overview\n\nWidgets display relevant, glanceable content that people can quickly access for more details. Your app can provide a variety of widgets, letting people focus on the information that’s most important to them.\n\nA good way to get started with widgets and WidgetKit is by adding a static widget to your app. A static widget doesn’t need any configuration by the user. For example, a static widget might show a stock market summary, or the next event on the user’s calendar. The data the widget shows is dynamic, but the type of data it shows is fixed. Consider the information your app presents, and choose something that people would find useful to see at a glance on their device.\n\nWidgets can display data in many sizes, from small watch complications or Dynamic Island presentations, to extra large iPad and macOS widgets. The example that follows below focuses on a single size widget, the small system size, or WidgetFamily.systemSmall. The example widget displays the status of a hypothetical game, such as player turn or the health level of a character.\n\nYou build widgets using SwiftUI. While there are similarities to how you present views in your app, some aspects are unique to developing widgets. For more information about using SwiftUI, see SwiftUI. However, not all SwiftUI views work in widgets. For a list of the views that work in widgets, see SwiftUI views for widgets.\n\nAdd a widget target to your app\n\nThe Widget Extension template provides a starting point for creating your widget. The template creates an extension target that contains a single widget. Later, you can add additional widgets to the same extension to display different types of information or to support additional widget sizes.\n\nOpen your app project in Xcode and choose File > New > Target.\n\nFrom the Application Extension group, select Widget Extension, and then click Next.\n\nEnter the name of your extension.\n\nDeselect the Include Live Activity and Include Configuration App Intent checkboxes, if they’re selected.\n\nClick Finish.\n\nNote\n\nLive Activities use WidgetKit and share many aspects of their design and implementation with the widgets in your app. If your app supports Live Activities, consider implementing them at the same time you add your widgets. For more information about Live Activities, see Displaying live data with Live Activities.\n\nThe widget extension template provides an initial implementation that conforms to the Widget protocol. The widget’s body property determines the type of content that the widget presents. Static widgets use a StaticConfiguration for the body property. Other types of widget configurations include:\n\nAppIntentConfiguration that enables user customization, such as a weather widget that needs a zip or postal code for a city, or a package-tracking widget that needs a tracking number.\n\nActivityConfiguration to present live data, such as scores during a sporting event or a food delivery estimate.\n\nFor more information about these other widget configurations, see Making a configurable widget and Displaying live data with Live Activities.\n\nAdd configuration details\n\nTo configure a static widget, provide the following information:\n\nkind\n\nA string that identifies the widget. This is an identifier you choose, and should be descriptive of what the widget represents.\n\nprovider\n\nAn object that conforms to TimelineProvider and produces a timeline that tells WidgetKit when to render the widget. A timeline is a sequence that contains a custom TimelineEntry type you define. The entries in this sequence identify the date when you want WidgetKit to update the widget’s content and includes properties your widget’s view needs to render in the custom type.\n\ncontent\n\nA closure that contains SwiftUI views. WidgetKit invokes this to render the widget’s content, passing a TimelineEntry parameter from the provider.\n\nUse modifiers to provide additional configuration details, including a display name, a description, and the families the widget supports. The following code shows a widget that provides general status for a game:\n\n@main\nstruct GameStatusWidget: Widget {\n    var body: some WidgetConfiguration {\n        StaticConfiguration(\n            kind: \"com.mygame.game-status\",\n            provider: GameStatusProvider(),\n        ) { entry in\n            GameStatusView(entry.gameStatus)\n        }\n        .configurationDisplayName(\"Game Status\")\n        .description(\"Shows an overview of your game status\")\n        .supportedFamilies([.systemSmall])\n    }\n}\n\n\nThe widget’s provider generates a timeline for the widget, and includes the game-status details in each entry. When the date of each timeline entry arrives, WidgetKit invokes the content closure to display the widget’s content. Finally, the modifiers specify the name and description shown in the widget gallery, and the sizes that the widget supports.\n\nImportant\n\nFor an app’s widget to appear in the widget gallery, a person must launch the app that contains the widget at least once after the app is installed.\n\nNote the usage of the @main attribute on this widget. This attribute indicates that the GameStatusWidget is the entry point for the widget extension, implying that the extension contains a single widget. To support multiple widgets, see the WidgetBundle.\n\nProvide timeline entries\n\nThe timeline provider you define generates a sequence of timeline entries. Each specifies the date and time to update the widget’s content, and includes the data your widget needs to render its view. The game-status widget might define its timeline entry to include a string that represents the status of the game, as follows:\n\nstruct GameStatusEntry: TimelineEntry {\n    var date: Date\n    var gameStatus: String\n}\n\n\nWidgetKit calls getTimeline(in:completion:) to request a the timeline from the provider. The timeline consists of one or more timeline entries and a reload policy that informs WidgetKit when to request a subsequent timeline.\n\nThe following example shows how the game-status widget’s provider generates a timeline that consists of a single entry with the current game status from the server, and a reload policy to request a new timeline in 15 minutes:\n\nstruct GameStatusProvider: TimelineProvider {\n    func getTimeline(in context: Context, completion: @escaping (Timeline<GameStatusEntry>) -> Void) {\n        // Create a timeline entry for \"now.\"\n        let date = Date()\n        let entry = GameStatusEntry(\n            date: date,\n            gameStatus: gameStatusFromServer\n        )\n\n\n        // Create a date that's 15 minutes in the future.\n        let nextUpdateDate = Calendar.current.date(byAdding: .minute, value: 15, to: date)!\n\n\n        // Create the timeline with the entry and a reload policy with the date\n        // for the next update.\n        let timeline = Timeline(\n            entries:[entry],\n            policy: .after(nextUpdateDate)\n        )\n\n\n        // Call the completion to pass the timeline to WidgetKit.\n        completion(timeline)\n    }\n}\n\n\nIn this example, if the widget didn’t have the current status from the server, it could store a reference to the completion, perform an asynchronous request to the server to fetch the game status, and call the completion when that request completes.\n\nFor more information about generating timelines, see Keeping a widget up to date. For more information about handling network, see Making network requests in a widget extension.\n\nGenerate a preview for the widget gallery\n\nIn order for people to be able to use your widget, it needs to be available in the widget gallery. To show your widget in the widget gallery, WidgetKit asks the provider for a preview snapshot that displays generic data. WidgetKit makes this request by calling the provider’s getSnapshot(in:completion:) method with the context parameter’s isPreview property set to true.\n\nIn response, you need to create the preview snapshot quickly. If your widget would normally need assets or information that takes time to generate or fetch from a server, use sample data instead.\n\nIn the following code, the game-status widget’s provider implements the snapshot method by showing the game status if it’s available, falling back to an empty status if it doesn’t have the status from its server:\n\nstruct GameStatusProvider: TimelineProvider {\n    var hasFetchedGameStatus: Bool\n    var gameStatusFromServer: String\n\n\n    func getSnapshot(in context: Context, completion: @escaping (Entry) -> Void) {\n        let date = Date()\n        let entry: GameStatusEntry\n\n\n        if context.isPreview && !hasFetchedGameStatus {\n            entry = GameStatusEntry(date: date, gameStatus: \"—\")\n        } else {\n            entry = GameStatusEntry(date: date, gameStatus: gameStatusFromServer)\n        }\n        completion(entry)\n    }\n\nDisplay content in your widget\n\nWidgets define their content using a SwiftUI view, commonly by composing other SwiftUI views. As shown in the Add configuration details section, the widget’s configuration contains the closure that WidgetKit invokes to render the widget’s content.\n\nWhen people add your widget from the widget gallery, they choose the specific family — for example, small or medium — from the ones your widget supports. The widget’s content closure has to be capable of rendering each family the widget supports. WidgetKit sets the corresponding family and additional properties, such as the color scheme (light or dark), in the SwiftUI environment.\n\nIn the game-status widget’s configuration shown above, the content closure uses a GameStatusView to display the status. Because this widget only supports the .systemSmall family, it uses a composed GameTurnSummary SwiftUI view to display a summary of the game’s current status. For any other family size, it shows the default view, which indicates that game status is unavailable.\n\nstruct GameStatusView : View {\n    @Environment(\\.widgetFamily) var family: WidgetFamily\n    var gameStatus: GameStatus\n    var selectedCharacter: CharacterDetail\n\n\n    @ViewBuilder\n    var body: some View {\n        switch family {\n        case .systemSmall: GameTurnSummary(gameStatus)\n        default: GameDetailsNotAvailable()\n        }\n    }\n}\n\n\nIn your widget, as you add more supported families to the widget’s configuration, you would add additional cases in the widget view’s body property for each additional family.\n\nNote\n\nThe view declares its body with @ViewBuilder because the type of view it uses varies.\n\nDisplay a placeholder widget\n\nA placeholder view is similar to a preview snapshot, but instead of showing example data to let people see the type of data the widget displays, it shows a generic visual representation with no specific content. When WidgetKit renders your widget, it may need to render your content as a placeholder, for example, while you load data in the background or if you tell the system that your widget contains sensitive information.\n\nHide sensitive content\n\nWidgets and watch complications may show sensitive information and can be highly visible, especially on devices with an Always-On display. When you create your widget or watch complication, review its content and consider hiding sensitive information.\n\nTo let people decide whether a widget should show sensitive data on a locked device, mark views that contain sensitive information using the privacySensitive(_:) modifier. In iOS, people can configure whether to show sensitive data on the Lock Screen and during Always On. In Settings, they can deactivate data access for Lock Screen widgets in the ALLOW ACCESS WHEN LOCKED section of Settings > Face ID & Passcode. On Apple Watch, people can configure whether to show sensitive data during Always On by Choosing Settings > Display & Brightness > Always On > Hide Sensitive Complications. They can choose to show redacted content for all or individual complications.\n\nIf a person chooses to hide privacy sensitive content, WidgetKit renders a placeholder or redactions you configure. To configure redactions, implement the redacted(reason:) callback, read out the privacy property, and provide custom placeholder views. You can also choose to render a view as unredacted with the unredacted() view modifier.\n\nAs an alternative to marking individual views as privacy sensitive, for example, if your entire widget content is privacy sensitive, add the Data Protection capability to your widget extension. Until a person unlocks their device to match the privacy level you chose, WidgetKit displays placeholder instead of the widget content. First, enable the Data Protection capability for your widget extension in Xcode, then set the Data Protection Entitlement entitlement to the value that fits the level of privacy you want to offer:\n\nNSFileProtectionComplete\n\nWidgetKit hides widget content when the device is locked. Additionally, iOS widgets aren’t available as iPhone widgets on Mac.\n\nNSFileProtectionCompleteUnlessOpen\n\nWidgetKit hides widget content when the device is passcode locked. Additionally, iOS widgets aren’t available as iPhone widgets on Mac.\n\nIf you choose the NSFileProtectionCompleteUntilFirstUserAuthentication or NSFileProtectionNone protection level for your widget extension:\n\nWidgetKit uses its default behavior and displays a placeholder until a person authenticates after they reboot their device.\n\niOS widgets are available as iPhone widgets on Mac.\n\nAdd dynamic content to your widget\n\nWidgets typically present read-only information and don’t generally support interactive elements such as scrolling lists or text input. Starting with iOS 17 and macOS 14, widgets support some interactive elements and animations. For details on adding interactivity to your widgets, see Adding interactivity to widgets and Live Activities.\n\nFor a list of views that WidgetKit supports, see SwiftUI views for widgets. WidgetKit ignores other views when it renders the widget’s’ content.\n\nAlthough the display of a widget is based on a snapshot of your view, you can use various SwiftUI views that continue to update while your widget is visible. For more about providing dynamic content, see Keeping a widget up to date.\n\nRespond to user interactions\n\nWhen people interact with your widget, beyond interactive elements described above, the system launches your app to handle the request. When the system activates your app, navigate to the details that correspond to the widget’s content. Your widget can specify a URL to inform the app what content to display. To configure custom URLs in your widget:\n\nFor all widgets, add the widgetURL(_:) view modifier to a view in your widget’s view hierarchy. If the widget’s view hierarchy includes more than one widgetURL modifier, the behavior is undefined.\n\nFor widgets that use WidgetFamily.systemMedium, WidgetFamily.systemLarge, or WidgetFamily.systemExtraLarge, add one or more Link controls to your widget’s view hierarchy. You can use both widgetURL and Link controls. If the interaction targets a Link control, the system uses the URL in that control. For interactions anywhere else in the widget, the system uses the URL specified in the widgetURL view modifier.\n\nFor more details about adding links from your widgets to your app, see Linking to specific app scenes from your widget or Live Activity.\n\nPreview widgets in Xcode\n\nXcode allows you to look at previews of your widgets without running your app in Simulator or on a test device. The following example shows the preview code from the Emoji Rangers widget of the Building Widgets Using WidgetKit and SwiftUI sample code project. Note how it uses the widgetFamily environment value to avoid manually specifying a name for each widget.\n\n@Environment(\\.widgetFamily) var family\n        \nGroup {\n    EmojiRangerWidgetEntryView(entry: SimpleEntry(date: Date(), relevance: nil, character: .panda))\n        .previewContext(WidgetPreviewContext(family: .systemSmall))\n        .previewDisplayName(\"\\(family)\")\n}\n\n\nAs you support more widget families in your widget, you can add more preview views to see multiple sizes in a single preview.\n\nExpand your widget’s capabilities\n\nTo give people flexible access to your app’s content, you can support additional families, add additional widget types, make your widgets user-configurable, or add support for Live Activities if your app presents live data. To explore a plan to support additional features, see Developing a WidgetKit strategy.\n\nTo explore WidgetKit code for the first time, see the following sample code projects:\n\nBuilding Widgets Using WidgetKit and SwiftUI is the sample code project associated with the WWDC20 code-alongs Widgets Code-along, part 1: The adventure begins, Widgets Code-along, part 2: Alternate timelines, and Widgets Code-along, part 3: Advancing timelines, where you learn how to build your first widget.\n\nEmoji Rangers: Supporting Live Activities, interactivity, and animations expands the Emoji Rangers sample code project to include Lock Screen widgets, Live Activities, interactivity, and animations.\n\nFruta: Building a Feature-Rich App with SwiftUI and Backyard Birds: Building an app with SwiftData and widgets are sample code projects that support widgets in addition to other technologies like App Clips or SwiftData.\n\nCreate multiple widget extensions\n\nYou can include multiple widget types in your widget extension, although your app can contain multiple extensions. For example, if some of your widgets use location information and others don’t, keep the widgets that use location information in a separate extension. This allows the system to prompt someone for authorization to use location information only for the widgets from the extension that uses location information. For details about bundling multiple widgets in an extension, see WidgetBundle.\n\nSee Also\nWidget creation\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nstruct WidgetRenderingMode\nConstants that indicate the rendering mode for a widget."
  },
  {
    "title": "Preview(_:as:using:widget:timelineProvider:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/preview(_:as:using:widget:timelineprovider:)-4ljg1",
    "html": "Parameters\nname\n\nAn optional display name for the preview, which will appear in the canvas.\n\nfamily\n\nThe widget family to display.\n\nintent\n\nThe intent with which to configure the widget.\n\nwidget\n\nA closure producing the widget to be previewed.\n\ntimelineProvider\n\nA closure producing the timeline provider that will generate the preview’s timeline.\n\nOverview\n\nThe preview will allow you to step through the timeline generated by the provider. It might be helpful to instantiate your timeline provider with sample data.\n\nNote\n\nThe timeline provider must be of the type expected by the widget. (This will be enforced at run-time.)"
  },
  {
    "title": "ActivityPreviewViewKind | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activitypreviewviewkind",
    "html": "Topics\nLive Activity preview types\ncase content\nThe Live Activity presentation that appears on the Lock Screen and as a banner on devices that don’t support the Dynamic Island.\ncase dynamicIsland(ActivityPreviewViewKind.DynamicIslandPreviewViewState)\nThe Live Activity presentation that appears in the Dynamic Island.\nenum DynamicIslandPreviewViewState\nValues that represent the different presentations of a Live Activity in the Dynamic Island for use in Xcode previews.\nSee Also\nLive Activities\nstruct ActivityConfiguration\nAn object that describes the content of a Live Activity.\nstruct DynamicIsland\nThe layout and configuration for a Live Activity that appears in the Dynamic Island.\nlet NSUserActivityTypeLiveActivity: String"
  },
  {
    "title": "NSUserActivityTypeLiveActivity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/nsuseractivitytypeliveactivity",
    "html": "See Also\nLive Activities\nstruct ActivityConfiguration\nAn object that describes the content of a Live Activity.\nstruct DynamicIsland\nThe layout and configuration for a Live Activity that appears in the Dynamic Island.\nenum ActivityPreviewViewKind\nValues that represent Live Activity presentations for use in Xcode previews."
  },
  {
    "title": "DynamicIsland | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/dynamicisland",
    "html": "Topics\nCreating the view for the Dynamic Island\ninit<Expanded, CompactLeading, CompactTrailing, Minimal>(expanded: () -> DynamicIslandExpandedContent<Expanded>, compactLeading: () -> CompactLeading, compactTrailing: () -> CompactTrailing, minimal: () -> Minimal)\nCreates a configuration object with views that appear in the Dynamic Island.\nstruct DynamicIslandExpandedRegion\nA structure that defines and positions the content of an expanded Live Activity in the Dynamic Island.\nDeep linking\nfunc widgetURL(URL?) -> DynamicIsland\nSets the URL that opens the corresponding app of a Live Activity when a user taps on the Live Activity.\nSetting a tint color\nfunc keylineTint(Color?) -> DynamicIsland\nApplies a subtle tint color to the surrounding border of a Live Activity that appears in the Dynamic Island.\nSpecifying content margins\nfunc contentMargins(Edge.Set, Double, for: DynamicIslandMode) -> DynamicIsland\nOverrides default content margins for the provided content modes in the Dynamic Island.\nstruct DynamicIslandMode\nA structure that offers values that describe the content mode for a Live Activity.\nSee Also\nLive Activities\nstruct ActivityConfiguration\nAn object that describes the content of a Live Activity.\nlet NSUserActivityTypeLiveActivity: String\nenum ActivityPreviewViewKind\nValues that represent Live Activity presentations for use in Xcode previews."
  },
  {
    "title": "ActivityConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/activityconfiguration",
    "html": "Overview\n\nTo learn more about offering Live Activities for your app, see ActivityKit.\n\nTopics\nCreating a Live Activity configuration\nstruct ActivityViewContext\nA structure that describes the view context for creating the views of a Live Activity.\ninit<Content>(for: Attributes.Type, content: (ActivityViewContext<Attributes>) -> Content, dynamicIsland: (ActivityViewContext<Attributes>) -> DynamicIsland)\nCreates a configuration object for a Live Activity.\nRelationships\nConforms To\nWidgetConfiguration\nSee Also\nLive Activities\nstruct DynamicIsland\nThe layout and configuration for a Live Activity that appears in the Dynamic Island.\nlet NSUserActivityTypeLiveActivity: String\nenum ActivityPreviewViewKind\nValues that represent Live Activity presentations for use in Xcode previews."
  },
  {
    "title": "WidgetPreviewContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetpreviewcontext",
    "html": "Overview\n\nTo create a preview for a widget in Xcode, use previewContext(_:) and pass WidgetPreviewContext initialized with the appropriate WidgetFamily.\n\nstruct Widget_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            MyWidgetView()\n                .previewContext(WidgetPreviewContext(family: .systemSmall))\n        }\n    }\n}\n\nTopics\nCreating a Preview Context\ninit(family: WidgetFamily)\nCreates a context for previewing a widget or a widget’s view.\nRelationships\nConforms To\nPreviewContext\nSee Also\nWidget preview and debugging\nDebugging Widgets\nSet environment variables in Xcode to control your widget’s configuration in the debugger.\nPreview macros\nUse Swift macros to create widget previews in Xcode."
  },
  {
    "title": "Preview macros | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/preview-macros",
    "html": "Topics\nProviding a widget preview\nmacro Preview<Widget, Provider>(String?, as: WidgetFamily, widget: () -> Widget, timelineProvider: () -> Provider)\nPreview a widget with a static configuration, using the specified timeline provider.\nmacro Preview<Widget>(String?, as: WidgetFamily, widget: () -> Widget, timeline: () async -> [TimelineEntry])\nPreview a timeline-style widget.\nGenerating a Live Activity preview\nmacro Preview<Widget, Attributes>(String?, as: ActivityPreviewViewKind, using: Attributes, widget: () -> Widget, contentStates: () async -> [Attributes.ContentState])\nPreview a widget with an activity configuration, using the specified attributes and content states.\nGenerated structures\nstruct PreviewActivityBuilder\nstruct PreviewTimelineBuilder\nSee Also\nWidget preview and debugging\nDebugging Widgets\nSet environment variables in Xcode to control your widget’s configuration in the debugger.\nstruct WidgetPreviewContext\nA specification for the context of a widget preview."
  },
  {
    "title": "TimelineEntryRelevance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineentryrelevance",
    "html": "Overview\n\nWhen users put widgets into a stack, WidgetKit uses the relevance property of the entries your timeline provider generates to determine how relevant they are to the user. For each timeline entry that your provider creates, you may assign relevance that contains a score and a duration. The score is a value you choose that indicates the relevance of the widget, relative to entries across timelines that the provider creates. When the date of an entry arrives, and for the duration you specify, WidgetKit may rotate your widget to the top of the stack so it becomes visible.\n\nFor example, consider a widget that displays stock market information. During open market hours, the widget is more relevant than when the market is closed. Additionally, a stock in the user’s watchlist is more relevant than stocks not in the watchlist. As a result, the score for entries during market hours is higher, and the score for entries displaying watchlist stocks could be even higher.\n\nA different example might be a widget that displays a game character’s health level. During the time that the health level is recovering, it may be more relevant than when it has reached 100 percent. Conversely, you might decide that a character’s widget is less relevant until its health level reaches 100 percent. Only you can determine how relevant a widget’s content is to the user.\n\nAdding Relevance to Timeline Entries\n\nWhen you can determine the relative importance of timeline entries, set the relevance property on the entries you create. WidgetKit maintains the relevance information across multiple timelines, for the duration you specify. After generating a timeline entry with a relevance containing a positive score, if you create subsequent timelines and want to maintain the original relevance, set the relevance property to nil. To remove a previous relevance, or to specify that WidgetKit not consider rotating a widget to the top of a stack, set the relevance property’s score to zero (0).\n\nFor example, the stock market widget might create a timeline with a single entry at the opening of the market. This entry would include TimelineEntryRelevance, with the appropriate relevance score and a duration, in seconds, up to the closing of the market. For subsequent timelines, until the closing of the market, relevance is set to nil. This value indicates that the previous relevance, set at the opening of the market, should be maintained. When the provider generates a timeline at the close of the market, it includes a new relevance, with a score of 0 and a duration up to the next market opening time. These values indicate that the widget is no longer relevant and shouldn’t be promoted to the top of the stack.\n\nCalculating a Score\n\nTo determine a score for an individual entry, it’s preferable to decide on an absolute scale from least relevant to most relevant. The range of the scale is entirely up to you and could be 1 to 100, 50 to 5000, or any other range of positive numbers that’s meaningful to you. WidgetKit calculates the relative difference of scores between entries, so the absolute values don’t matter.\n\nBecause WidgetKit maintains relevance information across timelines, you should use a consistent scale for all of them. For simplicity, you might use an enumeration with specific values for low, medium, and high relevance. Alternatively, if your score calculations have a continuous variation, you could use floating-point precision in your scale, with consistent minimum and maximum values.\n\nA score of zero (0) or lower indicates that a widget is not relevant, and WidgetKit won’t consider rotating it to the top of the stack.\n\nTesting Widgets in Stacks\n\nWhen a widget is in a stack, and the user enables Smart Rotate for the stack, WidgetKit normally limits the number of times it considers rotating the widget to the top of the stack. To bypass this limit during development, enable the WidgetKit Developer Mode switch in Settings > Developer.\n\nTopics\nCreating a Relevance Object\ninit(score: Float, duration: TimeInterval)\nCreates an object that represents the importance of a widget and the length of time for WidgetKit to consider it for rotation to the top of the stack.\nConfiguring Relevance Properties\nvar duration: TimeInterval\nThe number of seconds, following an entry’s date, that WidgetKit considers the widget for rotation to the top of the stack.\nvar score: Float\nA value that indicates the relevance of an entry compared to other entries in the current and past timelines.\nRelationships\nConforms To\nDecodable\nEncodable\nEquatable\nHashable\nSee Also\nSmart Stacks\nIncreasing the visibility of widgets in Smart Stacks\nDonate intents and indicate relevance to automatically show your widget in Smart Stacks when it has useful information to display."
  },
  {
    "title": "Debugging Widgets | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/debugging-widgets",
    "html": "Overview\n\nTo debug your widget, select the widget-extension target in Xcode and choose Product > Run. Xcode automatically displays your widget on the target device, as follows:\n\nOn iPhone, on the Home Screen\n\nOn iPad, in the Today view\n\nOn Mac, in the WidgetKit Simulator app\n\nNote\n\nIf your Home Screen pages are full, Xcode instead uses the Today view.\n\nTo debug accessory widgets that appear on the iPhone Lock Screen or as complications on Apple Watch, build and run the app target, then manually add the widget.\n\nTo configure a specific widget configuration, use the Arguments pane of the widget extension’s scheme, shown here, to set environment variables as described below.\n\nDebug specific widget configurations\n\nTo debug a specific family of your widget that’s not an accessory widget, edit the scheme for your widget extension target and set the _XCWidgetFamily environment variable to small, medium, large, or extralarge.\n\nIf your widget extension supports multiple widgets using WidgetBundle, select the specific widget to debug by setting _XCWidgetKind to a string that matches the kind property of the widget’s configuration.\n\nDebug watch complications\n\nDebugging a watch complication you create with WidgetKit works the same as debugging a complication you create with ClockKit. To learn more about testing complications, see Creating complications for your watchOS app.\n\nDebug mac widgets\n\nThe WidgetKit Simulator app provides a flexible way to see all your widget configurations in one place. Running your widget in the WidgetKit Simulator app lets you:\n\nView your widget’s display name, description, kind, supported families, and more.\n\nView multiple entries in your widget’s timeline.\n\nView your widget’s snapshot representation.\n\nView placeholder views for all supported sizes.\n\nQuickly switch between supported sizes when viewing snapshots or timeline entries.\n\nReload your widget.\n\nTo select the default view the WidgetKit Simulator app shows when you start a debug session, edit the scheme for your Widget extension target and set the _XCWidgetDefaultView environment variable to timeline, snapshot, placeholder, or info.\n\nSee Also\nWidget preview and debugging\nstruct WidgetPreviewContext\nA specification for the context of a widget preview.\nPreview macros\nUse Swift macros to create widget previews in Xcode."
  },
  {
    "title": "Accessing location information in widgets | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/accessing-location-information-in-widgets",
    "html": "Overview\n\nWidgets can present relevant and useful information by taking a user’s location into account. Because your widget’s extension doesn’t run continually, using Location Services in your widget requires you to take a few additional steps.\n\nEnable Location Services in your widget\n\nTo use Location Services in your widget:\n\nAdd the NSWidgetWantsLocation key to your widget extension’s Info.plist file.\n\nAdd the relevant purpose strings to the Info.plist file of the app that contains the widget.\n\nImportant\n\nBefore your widget can receive location information, your app must request authorization from the user. For more information, see doc://com.apple.documentation/documentation/corelocation/requesting_authorization_for_location_services.\n\nAs described in doc://com.apple.documentation/documentation/corelocation/choosing_the_location_services_authorization_to_request, whenever possible, request When In Use authorization.\n\nAccess location information from your widget\n\nWhen the user adds a widget that uses location, the system asks whether they want to extend the app’s location authorization to the widget. Use isAuthorizedForWidgetUpdates to determine whether the widget is eligible to receive location updates. Users can change their approval choice at any time in Settings > Privacy > Location Services.\n\nAfter the user approves the widget’s use of location information, the system considers it “in use” for a short period of time after the widget is visible. If the system refreshes the widget’s view during this in-use period, the widget has access to location information. For example, immediately after a user adds a widget to their Home Screen and approves extending the app’s location authorization, the user’s location is available to the widget.\n\nWhen the widget hasn’t been visible for a period of time, the system no longer considers it in use and stops delivering location updates. When WidgetKit reloads the widget’s view, if authorizedForWidgetUpdates is true but the widget doesn’t get location updates, it’s a good practice to indicate that the user’s location is not currently available. Note, this is different from when authorizedForWidgetUpdates is false, which indicates that the user has not approved the widget to receive location updates.\n\nTest your widget in real-world scenarios\n\nDue to the timeline-based updates of widgets, and the variability of a widget’s in-use status, it’s important to test widgets that use location in real-world scenarios. For example, create test scenarios that:\n\nExtend the app’s location authorization when adding the widget.\n\nDon’t extend the app’s location authorization when adding the widget.\n\nChange the app’s authorization in Settings > Privacy > Location Services after the widget is added.\n\nChange the widget’s approval of location authorization in Settings > Privacy > Location Services after the widget is added.\n\nAdd the widget to Home Screen pages that are both frequently and infrequently viewed.\n\nBecause widgets receive a limited number of refreshes every day, test your widget over multiple days.\n\nIsolate location usage with multiple widget extensions\n\nIf your app provides multiple widgets and only some of the widgets use location, separate your widgets into multiple extensions. Add the NSWidgetWantsLocation to the extension that contains widgets that use location. This allows the system to only prompt the user for the widgets that use location information, and makes it more contextually relevant for users.\n\nFor more information, see the Declare Multiple Widgets in Your App Extension section in Creating a widget extension."
  },
  {
    "title": "Increasing the visibility of widgets in Smart Stacks | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widget-suggestions-in-smart-stacks",
    "html": "Overview\n\nSmart Stacks efficiently organize multiple widgets on the Home Screen to show useful content at just the right time. For example, if a person checks the daily weather forecast every morning, or if they frequently check the charges a family member makes on a joint credit card, then with input from your app, on-device intelligence can identify these patterns, enabling Smart Stacks to show and suggest the corresponding widgets at the right moments.\n\nWhen people configure Smart Stacks, they have two options for surfacing widgets:\n\nSmart Rotate automatically rotates widgets to the top of the stack when they have timely, relevant information to show.\n\nWidget Suggestions automatically propose widgets that a person doesn’t already have in their stack, perhaps exposing them to widgets they don’t even know exist.\n\nSmart Stacks use information from your app and widget extension to detect patterns of usage, and to promote or suggest widgets in a Smart Stack. Your app donates intents and identifies relevant shortcuts to provide a signal about how people use your app, when they use it, and what is most relevant to them. Your widget extension’s timeline entry provider generates timeline entries that contain hints about the relative importance of the widget’s content over time.\n\nUse app intents to tell the system how people use your app\n\nWhen you donate app intents, the system learns how and when people interact with your app. These donations inform much more than Smart Stacks. The system uses this information to display Spotlight search results, offer shortcuts on the Lock Screen and Siri watch face, and more. For more information about donating app intents, see Intent discovery.\n\nFor widgets based on AppIntentConfiguration, your app uses IntentDonationManager or donate() to inform Smart Rotate and Widget Suggestions in Smart Stacks. When your app donates an AppIntent, Smart Stacks consider rotating matching widgets to the top, or inserting an automatically configured widget as a suggestion.\n\nConsider a tour guide app that displays information for cities around the world, such as popular tourist attractions, restaurants, and upcoming festivals throughout the year. The app contains several widgets that display these details. The widget configurations define custom intents such as CityInfoAppIntent, AttractionAppIntent, RestaurantAppIntent, and FestivalAppIntent. As people interact with the app, the app donates these app intents using donate(). The system uses the details of the app intents when determining user intention.\n\nFor example, a person frequently uses a travel app on the weekend to plan a trip to France. As they use the app, they look for festivals in various cities they may visit. Each time they search for or view the details of a festival, the app donates a FestivalAppIntent. If the FestivalAppIntent contains location and type parameters, the system can learn that the person frequently searches for art events in Paris. Your app’s donations give the system insight into the person’s behavior and what information is important to them.\n\nTo make relevant suggestions, Smart Stacks compare app intents the app donates with app intents that configurable widgets use. If a person configures a widget that uses a FestivalAppIntent to show art festivals in Paris, Smart Stacks can automatically rotate to that widget when the person typically looks for that information. If the person hasn’t configured a matching widget in a stack, the system can automatically suggest a widget with that configuration. This raises the visibility of the app’s widgets, which they may not know about.\n\nNote\n\nTo enable Smart Stacks to suggest your app intent-based widgets, have your custom app intents conform to PredictableIntent and contain a predictionConfiguration that describes the parameters to match.\n\nSuggest shortcuts a person may find useful\n\nWhile app intent donations using IntentDonationManager or donate() give Smart Stacks insight into past user behavior, RelevantIntent informs future suggestions. These app intents may not even be based on a person’s behavior. When your app has timely information you believe is relevant to a person, and the app has a widget to display that information, suggest relevant app intents to influence Widget Suggestions. This helps people perform common or important tasks.\n\nContinuing the previous example, when the app receives details about a new outdoor art lantern festival in Paris, it can convey this new, likely relevant information to the system. Because the on-device intelligence has learned the person is interested in art festivals in Paris, it may suggest an app intent-based widget from the app that displays art festivals in a Smart Stack. The Smart Stack uses the app intent from the app to automatically configure the widget to show the details of the outdoor art lantern festival.\n\nThe app uses a RelevantIntent that contains the festival details. Because the new festival is in the future, Smart Stacks need to know when the app intent is relevant. The app conveys this information by specifying a relevant context as part of the RelevantIntent. The relevant context determines when an app intent is relevant, such as at a specific time of day or location. To specify when it’s appropriate to suggest a widget in a Smart Stack, call updateRelevantIntents(_:) and pass one or more RelevantIntent objects. On-device intelligence uses the combination of the relevant app intent and the date details from the relevant context to make a widget suggestion at the right time.\n\nTo provide a relevant app intent with a FestivalAppIntent for the Paris art lantern festival, the app does the following:\n\nCreates a FestivalAppIntent for the lantern festival with the location set to Paris and the type set to Art\n\nCreates a RelevantIntent with the FestivalAppIntent, the widget’s kind string, and a RelevantContext that specifies the start and end dates of the festival\n\nCalls updateRelevantIntents() with the RelevantIntent\n\nWith this information, Smart Stacks can suggest the preconfigured lantern festival widget with no user action. The person may not be aware that the app contains widgets, providing a great way for people to discover new features and interactions with your app.\n\nIf your widget uses a StaticConfiguration, you still use RelevantIntent for future suggestions. To provide a relevant intent for a static widget, create a custom intent type that conforms to WidgetConfigurationIntent and has no parameters, then follow the steps above.\n\nNote\n\nSmart Stacks don’t suggest widgets that rely on a person’s location information unless that person has already authorized the use of location for widgets in a widget extension. For more information about using a person’s location in widgets, see Accessing location information in widgets.\n\nIndicate when a widget is relevant from your widget extension\n\nSimilar to how a RelevantIntent gives Smart Stacks insight into future relevant information, the widget timeline providers you implement in your widget extension specify relevance for future widget updates. After a person adds a widget to the Home Screen, the widget’s timeline provider generates timelines to populate the widget. As it generates timelines, the provider indicates the relative importance of entries over time by setting the relevance property on the timeline entries. Timeline providers can specify relevance to both static and app intent-based widget configurations.\n\nFor example, if a person adds the festival tracker widget to the Home Screen, the provider might indicate a relevance score of 1 for an upcoming festival in Paris because the person browsed festivals in Paris. If the person adds the lantern festival widget from the previous example and marks it as a favorite, the timeline provider might change the relevance score for those timeline entries from 1 to 10 to indicate a significantly more relevant entry. Smart Stacks consider the changes in relevance across all of a widget’s timeline entries when deciding to automatically rotate to that widget in a Smart Stack.\n\nFor more information about using relevance in timeline entries and providing relevance scores, see TimelineEntryRelevance.\n\nTest widgets in stacks\n\nWhen a widget is in a stack, WidgetKit normally limits the number of times it considers rotating the widget to the top of the stack or inserting the widget as a suggestion. To bypass this limit during development, enable the WidgetKit Developer Mode switch in Settings > Developer.\n\nFor additional tips about debugging widgets, see Debugging Widgets.\n\nProvide backward compatibility\n\nPrior to iOS 17, macOS 14, and watchOS 10, widgets used SiriKit Intents to make donations and to indicate relevance. For details about supporting older operating system versions, see Migrating widgets from SiriKit Intents to App Intents.\n\nDonating SiriKit Intents is very similar to donating app intents. Instead of using IntentDonationManager, you use INInteraction to donate an INIntent. For more information about donating SiriKit Intents, see Donating Shortcuts and Watch and Widget Support.\n\nSee Also\nSmart Stacks\nstruct TimelineEntryRelevance\nAn object that describes the relative importance of a timeline entry compared to other entries in the current and past timelines."
  },
  {
    "title": "Making network requests in a widget extension | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/making-network-requests-in-a-widget-extension",
    "html": "Overview\n\nWidgets use a timeline mechanism to update their content. In addition to providing a timeline with new local data, you can initiate a network request that provides updated information for your widget from your server. Network requests are possible while the widget extension is active, such as when it provides a snapshot, or a new timeline. For example, the Emoji Rangers widget of the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project loads updated leaderboard data in its getTimeline(in:completion:) implementation.\n\nIn general, making a network request from a widget extension is similar to making a network request in your app: you can initiate inline or background requests. However, widgets can only access limited resources and a request may not have enough time to complete before the system halts the widget extension. To update a widget with data from your server, use background requests similar to the process described in Downloading files in the background.\n\nLoad data with a background network request\n\nWhen a widget initiates a background network request, the system delivers events related to the request directly to the widget extension instead of the containing app. To process them, do the following:\n\nAdd the onBackgroundURLSessionEvents(matching:_:) modifier to your WidgetConfiguration implementation.\n\nMaintain a reference to the URLSession object of your background network request.\n\nKeep a reference to the matching parameter to identify the session.\n\nStore a reference to the onBackgroundURLSessionEvents(matching:_:) modifier’s completion handler. You’ll invoke it after the system delivers all events for the network request.\n\nIf the system terminates your widget extension before all events complete, use the stored matching identifier to check if a corresponding URLSession object exists. If no session object exists, create a new session using the identifier.\n\nTip\n\nConsider initializing URLSession objects lazily and caching them in a central location so that your code works regardless of whether your extension remains active, is suspended, or is terminated.\n\nUpdate your widget after background network requests complete\n\nAfter invoking onBackgroundURLSessionEvents(matching:_:), the system calls the urlSession(_:downloadTask:didFinishDownloadingTo:) method of the URLSessionDelegate you supplied to the URLSession. When the system has delivered all events, it calls the delegate’s urlSessionDidFinishEvents(forBackgroundURLSession:) method.\n\nTo refresh your widget’s timeline after the network request completes, call the needed WidgetCenter methods from your implementation of SessionDidFinishEvents(forBackgroundURLSession:). Once you finish handling the events, call the completion handler of onBackgroundURLSessionEvents(matching:_:) that you previously stored."
  },
  {
    "title": "IntentTimelineProvider | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intenttimelineprovider",
    "html": "Overview\n\nAn Intent timeline provider performs the same function as TimelineProvider, but it also incorporates user-configured details into timeline entries.\n\nFor example, in a widget that displays the health status of a game character the user has chosen, the provider receives a custom intent specifying the character to display. In your Xcode project, you then define a custom SiriKit Intent Definition file. The intent definition can include the character’s details such as its name, avatar, strategic alliances, and so on.\n\nXcode generates the following INIntent custom intent:\n\npublic class SelectCharacterIntent: INIntent {\n    @NSManaged public var characterName: String?\n    @NSManaged public var avatar: String?\n    @NSManaged public var alliances: [String]?\n    @NSManaged public var healthLevel: NSNumber?\n}\n\n\nBecause users can add multiple instances of a particular widget, your provider needs a way to differentiate which instance WidgetKit is asking about. When WidgetKit calls getSnapshot(for:in:completion:) or getTimeline(for:in:completion:), it passes an instance of your custom INIntent, configured with the user-selected details. The game widget provider accesses the properties of the intent and includes them in the TimelineEntry. WidgetKit then invokes the widget configuration’s content closure, passing the timeline entry to allow the views to access the user-configured properties. For example, the provider might implement a TimelineEntry with properties corresponding to those in the custom intent:\n\nstruct CharacterDetailEntry: TimelineEntry {\n    var date: Date\n    var name: String?\n    var avatar: String?\n    var alliances: [String]?\n    var healthLevel: Double?\n}\n\n\nTo generate a snapshot, the game widget provider initializes the character detail entry using the properties from the intent.\n\nstruct CharacterDetailProvider: IntentTimelineProvider {\n    func getSnapshot(for configuration: SelectCharacterIntent, in context: Context, completion: @escaping (CharacterDetailEntry) -> Void) {\n        let entry = CharacterDetailEntry(\n            date: Date(),\n            name: configuration.characterName,\n            avatar: configuration.avatar,\n            alliances: configuration.alliances,\n            healthLevel: configuration.healthLevel?.doubleValue\n        )\n        completion(entry)\n    }\n}\n\nTopics\nGenerating Timelines\nfunc getSnapshot(for: Self.Intent, in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(for: Self.Intent, in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : INIntent\nThe intent that contains user-customized values.\n\nRequired\n\nfunc recommendations() -> [IntentRecommendation<Self.Intent>]\n\nRequired Default implementation provided.\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nSee Also\nRelated Documentation\nclass INIntent\nA request to fulfill in your app or Intents extension.\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display."
  },
  {
    "title": "TimelineProvider | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timelineprovider",
    "html": "Overview\n\nAt various times, WidgetKit requests a timeline from the provider. A timeline is an array of objects conforming to TimelineEntry. Each timeline entry has a date, and you can specify additional properties for displaying the widget.\n\nFor example, consider a widget that displays the health level of a game character. In the game, when the character’s health level is below 100 percent, it recovers at a rate of 25 percent per hour. If the character’s health level is 25 percent, the provider creates a timeline consisting of the following entries:\n\nThe following code shows the structure encapsulating this information.\n\nstruct CharacterDetailEntry: TimelineEntry {\n    var date: Date\n    var healthLevel: Double\n}\n\n\nWidgetKit asks for timeline entries in one of two ways:\n\nA single immediate snapshot, representing the widget’s current state.\n\nAn array of entries, including the current moment and, if known, any future dates when the widget’s state will change.\n\nWidgetKit makes the snapshot request when displaying the widget in transient situations, such as when the user is adding a widget. WidgetKit provides a context parameter that includes details about how to use the entry, including whether it’s a preview for the widget gallery, and the family, or size, of the widget to display. If context.isPreview is true, the widget appears in the widget gallery and requires a quick response from your provider. If the information you need to generate the snapshot is not readily available, or requires additional time to load, use sample data instead. For example, if determining the character’s health level requires fetching data from a server, the widget could show the health level at 75 percent. The following code shows how the game widget might implement its snapshot method.\n\nstruct CharacterDetailProvider: TimelineProvider {\n    func getSnapshot(in context: Context, completion: @escaping (Entry) -> Void) {\n        let date = Date()\n        let entry: CharacterDetailEntry\n\n\n        if context.isPreview && !hasHealthLevel {\n            entry = CharacterDetailEntry(date: date, healthLevel: 0.75)\n        } else {\n            entry = CharacterDetailEntry(date: date, healthLevel: currentHealthLevel)\n        }\n        completion(entry)\n    }\n}\n\n\nWidgetKit makes the timeline request after the user adds your widget from the widget gallery. Because your widget extension is not always running, WidgetKit needs to know when to activate it to update the widget. The timeline your provider generates informs WidgetKit when you would like to update the widget. The following example shows how the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project creates a timeline for its leaderboard widget.\n\nfunc getTimeline(in context: Context, completion: @escaping (Timeline<LeaderboardEntry>) -> Void) {\n    EmojiRanger.loadLeaderboardData { (heros, error) in\n        guard let heros else {\n            let timeline = Timeline(entries: [LeaderboardEntry(date: Date(), heros: EmojiRanger.availableHeros)], policy: .atEnd)\n\n\n            completion(timeline)\n\n\n            return\n        }\n        let timeline = Timeline(entries: [LeaderboardEntry(date: Date(), heros: heros)], policy: .atEnd)\n        completion(timeline)\n    }\n}\n\n\nIf your provider needs to do asynchronous work to generate the timeline, such as fetching data from a server, store a reference to the completion handler and call it when you are done with your asynchronous work.\n\nDetermine a refresh policy\n\nWhen creating the timeline, the provider specifies a refresh policy that controls when WidgetKit requests a new timeline. The default behavior is to use atEnd to request a new timeline after the last date specified by the entries in a timeline. However, if there is a different date when WidgetKit should request a new timeline, you can specify a refresh policy of after(_:). For example, a dragon will appear in 2.5 hours and might engage in battle with the game character. Because the outcome of this battle may change the character’s health level, the provider can tell WidgetKit to request a new timeline after the battle.\n\n// Request a timeline refresh after 2.5 hours.\nlet date = Calendar.current.date(byAdding: .minute, value: 150, to: Date())!\nlet timeline = Timeline(entries: entries, policy: .after(date))\ncompletion(timeline)\n\n\nOther examples of when it makes sense to use a different date include:\n\nIn a widget displaying stock market details, you might specify the next market opening or closing date because information typically doesn’t change overnight or during weekends.\n\nA flight tracking widget might continue showing a “flight landed” indication after the flight lands. In this case, you could specify a date later than when the flight lands so that its status remains visible for a while before being cleared.\n\nAlternatively, if future events are unpredictable, you can tell WidgetKit to not request a new timeline at all by specifying never for the policy. In that case, your app calls the WidgetCenter function reloadTimelines(ofKind:) when a new timeline is available. Some examples of when using never makes sense include:\n\nWhen the user has a widget configured to display the health of a character, but that character is no longer actively engaging in battle and its health level won’t change.\n\nWhen a widget’s content is dependent on the user being logged into an account and they aren’t currently logged in.\n\nIn both examples, when your app determines that the status has changed, it calls the WidgetCenter function reloadTimelines(ofKind:) and WidgetKit requests a new timeline.\n\nRefresh widgets efficiently\n\nEach configured widget receives a limited number of refreshes every day. Several factors affect how many refreshes a widget receives, such as whether the containing app is running in the foreground or background, how frequently the widget is shown onscreen, and what types of activities the containing app engages in.\n\nNote\n\nWidgetKit does not impose this limit when debugging your widget in Xcode. To verify that your widget behaves correctly, test your app and widget’s behavior outside of Xcode’s debugger.\n\nUse the following approaches to optimize your widget refreshes:\n\nHave the containing app prepare data for the widget in advance of when the widget needs it. Use a shared group container to store the data.\n\nUse background processing time in your app to keep shared data up to date. For more information, see doc://com.apple.documentation/documentation/uikit/app_and_environment/scenes/preparing_your_ui_to_run_in_the_background/updating_your_app_with_background_app_refresh.\n\nChoose the most appropriate refresh policy for the information being shown, as described in the preceding section.\n\nCall reloadTimelines(ofKind:) only when information the widget is currently displaying changes.\n\nWhen your app is in the foreground, has an active media session, or is using the standard location service, refreshes don’t count against the widget’s daily limit. For more information about media sessions and location services, see AVAudioSession and Configuring your app to use location services.\n\nTopics\nGenerating Timelines\nfunc getSnapshot(in: Self.Context, completion: (Self.Entry) -> Void)\nProvides a timeline entry that represents the current time and state of a widget.\n\nRequired\n\nfunc getTimeline(in: Self.Context, completion: (Timeline<Self.Entry>) -> Void)\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nSee Also\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display."
  },
  {
    "title": "IntentConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intentconfiguration",
    "html": "Overview\n\nThe following example shows the configuration for a game widget that displays details about a chosen character.\n\nstruct CharacterDetailWidget: Widget {\n    var body: some WidgetConfiguration {\n        IntentConfiguration(\n            kind: \"com.mygame.character-detail\",\n            intent: SelectCharacterIntent.self,\n            provider: CharacterDetailProvider(),\n        ) { entry in\n            CharacterDetailView(entry: entry)\n        }\n        .configurationDisplayName(\"Character Details\")\n        .description(\"Displays a character's health and other details\")\n        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])\n    }\n}\n\n\nEvery widget has a unique kind, a string that you choose. You use this string to identify your widget when reloading its timeline with WidgetCenter.\n\nThe intent is a custom SiriKit intent definition containing user-editable parameters.\n\nThe timeline provider is an object that determines the timeline for refreshing your widget. Providing future dates for updating your widget allows the system to optimize the refresh process.\n\nThe content closure contains the SwiftUI views that WidgetKit needs to render the widget. When WidgetKit invokes the content closure, it passes a timeline entry created by the widget provider’s getSnapshot(for:in:completion:) or getTimeline(for:in:completion:) method.\n\nModifiers let you specify the families your widget supports, and the details shown when users add or edit their widgets.\n\nTopics\nCreating a widget configuration\ninit<Provider>(kind: String, intent: Intent.Type, provider: Provider, content: (Provider.Entry) -> Content)\nCreates a configuration for a widget by using a custom intent definition to provide user-configurable options.\nAvailable when Intent inherits INIntent and Content conforms to View.\nvar body: Self.Body\nThe content and behavior of this widget.\nSetting the display name\nfunc configurationDisplayName<S>(S) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the specified string.\nfunc configurationDisplayName(Text) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the contents of a text view.\nfunc configurationDisplayName(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized name shown for a widget when a user adds or edits the widget.\nSetting the description\nfunc description(Text) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the contents of a text view.\nfunc description<S>(S) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the specified string.\nfunc description(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized description shown for a widget when a user adds or edits the widget.\nSetting the supported families\nfunc supportedFamilies([WidgetFamily]) -> some WidgetConfiguration\nSets the sizes that a widget supports.\nHandling background network requests\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some WidgetConfiguration\nRuns the given action when the system provides a background task.\nfunc onBackgroundURLSessionEvents(matching: ((String) -> Bool)?, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session identified by a closure are waiting to be processed.\nfunc onBackgroundURLSessionEvents(matching: String, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session with a matching identifier are waiting to be processed.\nRelationships\nConforms To\nWidgetConfiguration\nSee Also\nConfigurable widgets\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nMigrating widgets from SiriKit Intents to App Intents\nConfigure your widgets for backward compatibility.\nstruct AppIntentConfiguration\nAn object describing the content of a widget that uses a custom intent to provide user-configurable options.\nstruct WidgetInfo\nA structure that contains information about user-configured widgets.\nstruct AppIntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nstruct IntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget."
  },
  {
    "title": "AppIntentRecommendation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintentrecommendation",
    "html": "Overview\n\nBy adding a custom App Intent to your project and using an AppIntentTimelineProvider, you allow users to configure widgets to show data that’s most relevant to them. Some platforms don’t have a dedicated user interface to configure all of your intent parameters. For example, watchOS doesn’t offer a dedicated user interface to configure data that appears on a complication. Use intent recommendations in watchOS to offer preconfigured complications that show data that’s most relevant to the user.\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — AppIntentRecommendation is inactive.\n\nFor example, say you develop a game app that allows users to view their in-game character. With intent recommendations, you can recommend an intent configuration for a watch complication that displays character information.\n\nThe following example shows a function to create a list of recommended configurations for a game widget that shows current energy levels for a game character.\n\npublic func recommendations() -> [AppIntentRecommendation<DynamicCharacterConfiguration>] {\n    CharacterDetail.availableCharacters.map { character in\n        let intent = DynamicCharacterConfiguration()\n        intent.hero = Hero(identifier: character.name, display: character.name)\n        return AppIntentRecommendation(intent: intent, description: Text(character.name))\n    }\n}\n\nTopics\nCreating a recommended widget configuration\ninit(intent: Intent, description: LocalizedStringKey)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets with a localized description.\ninit(intent: Intent, description: Text)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets.\ninit(intent: Intent, description: some StringProtocol)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets.\nSee Also\nConfigurable widgets\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nMigrating widgets from SiriKit Intents to App Intents\nConfigure your widgets for backward compatibility.\nstruct AppIntentConfiguration\nAn object describing the content of a widget that uses a custom intent to provide user-configurable options.\nstruct WidgetInfo\nA structure that contains information about user-configured widgets.\nstruct IntentConfiguration\nAn object describing the content of a widget that uses a custom intent definition to provide user-configurable options.\nstruct IntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget."
  },
  {
    "title": "IntentRecommendation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/intentrecommendation",
    "html": "Overview\n\nBy adding a custom SiriKit intent definition to your project and using an IntentTimelineProvider, you allow users to configure widgets to show data that’s most relevant to them. Some platforms don’t have a dedicated user interface to configure all of your intent parameters. For example, watchOS doesn’t offer a dedicated user interface to configure data that appears on a complication. Use intent recommendations in watchOS to offer preconfigured complications that show data that’s most relevant to the user.\n\nNote\n\nOn platforms that offer a dedicated user interface for configuring widgets — for example, iOS or macOS — IntentRecommendation is inactive.\n\nFor example, say you develop a game app that allows users to view their in-game character. With intent recommendations, you can recommend an intent configuration for a watch complication that displays character information.\n\nThe following example shows a function to create a list of recommended configurations for a game widget that shows current energy levels for a game character.\n\npublic func recommendations() -> [IntentRecommendation<DynamicCharacterSelectionIntent>] {\n    return CharacterDetail.availableCharacters.\n        map { character in\n            let hero = Hero(identifier: character.name, display: character.name)\n            let intent = DynamicCharacterSelectionIntent()\n            intent.hero = hero\n\n\n            return IntentRecommendation(intent: intent, description: Text(character.name))\n        }\n    }\n\nTopics\nCreating a Recommended Widget Configuration\ninit(intent: T, description: LocalizedStringKey)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets with a localized description.\ninit(intent: T, description: Text)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets.\ninit<S>(intent: T, description: S)\nCreates a recommended configuration for a widget on platforms that don’t offer a dedicated user interface to customize widgets.\nSee Also\nConfigurable widgets\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nMigrating widgets from SiriKit Intents to App Intents\nConfigure your widgets for backward compatibility.\nstruct AppIntentConfiguration\nAn object describing the content of a widget that uses a custom intent to provide user-configurable options.\nstruct WidgetInfo\nA structure that contains information about user-configured widgets.\nstruct AppIntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nstruct IntentConfiguration\nAn object describing the content of a widget that uses a custom intent definition to provide user-configurable options."
  },
  {
    "title": "AppIntentConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintentconfiguration",
    "html": "Overview\n\nThe following example shows the configuration for a game widget that displays details about a chosen character.\n\nstruct CharacterDetailWidget: Widget {\n    var body: some WidgetConfiguration {\n        AppIntentConfiguration(\n            kind: \"com.mygame.character-detail\",\n            intent: SelectCharacterIntent.self,\n            provider: CharacterDetailProvider(),\n        ) { entry in\n            CharacterDetailView(entry: entry)\n        }\n        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])\n    }\n}\n\n\nEvery widget has a unique kind, a string that you choose. You use this string to identify your widget when reloading its timeline with WidgetCenter.\n\nThe intent is a custom App Intent containing user-editable parameters.\n\nThe timeline provider is an object that determines the timeline for refreshing your widget. Providing future dates for updating your widget allows the system to optimize the refresh process.\n\nThe content closure contains the SwiftUI views that WidgetKit needs to render the widget. When WidgetKit invokes the content closure, it passes a timeline entry created by the widget provider’s snapshot(for:in:) or timeline(for:in:) method.\n\nModifiers let you specify the families your widget supports, and the details shown when users add or edit their widgets.\n\nTopics\nCreating a widget configuration\ninit<Provider>(kind: String, intent: Intent.Type, provider: Provider, content: (Provider.Entry) -> Content)\nCreates a configuration for a widget by using a custom intent to provide user-configurable options.\nAvailable when Intent conforms to WidgetConfigurationIntent and Content conforms to View.\nvar body: Self.Body\nThe content and behavior of this widget.\nSetting the display name\nfunc configurationDisplayName<S>(S) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the specified string.\nfunc configurationDisplayName(Text) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the contents of a text view.\nfunc configurationDisplayName(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized name shown for a widget when a user adds or edits the widget.\nSetting the description\nfunc description(Text) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the contents of a text view.\nfunc description<S>(S) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the specified string.\nfunc description(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized description shown for a widget when a user adds or edits the widget.\nSetting the supported families\nfunc supportedFamilies([WidgetFamily]) -> some WidgetConfiguration\nSets the sizes that a widget supports.\nHandling background network requests\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some WidgetConfiguration\nRuns the given action when the system provides a background task.\nfunc onBackgroundURLSessionEvents(matching: ((String) -> Bool)?, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session identified by a closure are waiting to be processed.\nfunc onBackgroundURLSessionEvents(matching: String, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session with a matching identifier are waiting to be processed.\nRelationships\nConforms To\nWidgetConfiguration\nSee Also\nConfigurable widgets\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nMigrating widgets from SiriKit Intents to App Intents\nConfigure your widgets for backward compatibility.\nstruct WidgetInfo\nA structure that contains information about user-configured widgets.\nstruct AppIntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nstruct IntentConfiguration\nAn object describing the content of a widget that uses a custom intent definition to provide user-configurable options.\nstruct IntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget."
  },
  {
    "title": "WidgetInfo | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetinfo",
    "html": "Topics\nGetting Configured Widget Information\nlet kind: String\nThe string specified during creation of the widget’s configuration.\nlet family: WidgetFamily\nThe size of the widget: small, medium, or large.\nlet configuration: INIntent?\nA SiriKit intent that contains user-edited values.\nIdentifying Widget Information\nvar id: WidgetInfo\nThe stable identity of the widget.\nInstance Methods\nfunc widgetConfigurationIntent<Intent>(of: Intent.Type) -> Intent?\nGets the associated App Intent.\nDefault Implementations\nIdentifiable Implementations\nRelationships\nConforms To\nCustomDebugStringConvertible\nEquatable\nHashable\nIdentifiable\nSee Also\nConfigurable widgets\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nMigrating widgets from SiriKit Intents to App Intents\nConfigure your widgets for backward compatibility.\nstruct AppIntentConfiguration\nAn object describing the content of a widget that uses a custom intent to provide user-configurable options.\nstruct AppIntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nstruct IntentConfiguration\nAn object describing the content of a widget that uses a custom intent definition to provide user-configurable options.\nstruct IntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget."
  },
  {
    "title": "Making a configurable widget | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/making-a-configurable-widget",
    "html": "Overview\n\nTo make the most relevant information easily accessible to people, widgets can provide customizable properties. For example, a person can select a specific stock for a stock quote widget, or enter a tracking number for a package delivery widget. Widgets define customizable properties by using app intents, the same mechanism that Siri Suggestions and Siri Shortcuts use for customizing those interactions.\n\nTo add configurable properties to your widget:\n\nAdd custom app intent types that conform to WidgetConfigurationIntent to define the configurable properties to your Xcode project.\n\nSpecify an AppIntentTimelineProvider as your widget’s timeline provider to incorporate the person’s choices into your timeline entries.\n\nAdd code to your custom app intent types to provide the data if their properties rely on dynamic data.\n\nIf your app already supports Siri Suggestions or Siri Shortcuts and you have a custom app intent, you’ve probably done most of the work already. Otherwise, consider leveraging the work you do for your widget to add support for Siri Suggestions or Siri Shortcuts. For more information on how to get the most from app intents, see App Intents.\n\nNote\n\nPrior to iOS 17, iPadOS 17, and macOS 14, configurable widgets used SiriKit Intents. For information on migrating your configurable widgets from the SiriKit Intents to the App Intents framework, see Migrating widgets from SiriKit Intents to App Intents.\n\nAdd a custom app intent to your project\n\nTo show the character’s information, the person needs a way to select the character. The following code shows how to define a custom app intent to represent the choice the person makes:\n\nstruct SelectCharacterIntent: WidgetConfigurationIntent {\n    static var title: LocalizedStringResource = \"Select Character\"\n    static var description = IntentDescription(\"Selects the character to display information for.\")\n\n\n    @Parameter(title: \"Character\")\n    var character: CharacterDetail\n\n\n    init(character: CharacterDetail) {\n        self.character = character\n    }\n\n\n    init() {\n    }\n\n\n}\n\n\nThe static title property describes the action the intent enables the person to take. Use a title case string that combines a verb with a noun. Set the static description to a human-readable string that describes the intent.\n\nTo add parameters to the intent, add one or more @Parameter property wrappers. WidgetKit uses the parameter type information to automatically create the user interface for editing the widget. For example, if the type is String, the person enters a string value. If the type is an Int, they use a number pad. For a parameter that is a predefined, static, list of values, define a custom type that conforms to AppEnum.\n\nNote\n\nThe order of the parameters in the intent determines the order in which they appear when a person edits your widget.\n\nIn the example above, the parameter uses a custom CharacterDetail type the app defines to represent a character in the game. To use a custom type as an app intent parameter, it must conform to AppEntity. To implement the CharacterDetail parameter type, the game-status widget uses a structure that exists in the game’s project. This structure defines a list of available characters and their details, as follows:\n\nstruct CharacterDetail: AppEntity {\n    let id: String\n    let avatar: String\n    let healthLevel: Double\n    let heroType: String\n    let isAvailable = true\n    \n    static var typeDisplayRepresentation: TypeDisplayRepresentation = \"Character\"\n    static var defaultQuery = CharacterQuery()\n            \n    var displayRepresentation: DisplayRepresentation {\n        DisplayRepresentation(title: \"\\(avatar) \\(id)\")\n    }\n\n\n    static let allCharacters: [CharacterDetail] = [\n        CharacterDetail(id: \"Power Panda\", avatar: \"🐼\", healthLevel: 0.14, heroType: \"Forest Dweller\"),\n        CharacterDetail(id: \"Unipony\", avatar: \"🦄\", healthLevel: 0.67, heroType: \"Free Rangers\"),\n        CharacterDetail(id: \"Spouty\", avatar: \"🐳\", healthLevel: 0.83, heroType: \"Deep Sea Goer\")\n    ]\n}\n\n\nBecause characters might vary from game to game, the intent generates the list dynamically at runtime. WidgetKit uses the app entity’s defaultQuery property to access the dynamic values, as described below.\n\nIf your widget includes nonoptional parameters, you must supply a default value. For types such as String, Int, or enumerations that use AppEnum, one option is to supply a default value as follows:\n\n@Parameter(title: \"Title\", default: \"A Default Title\")\nvar title: String\n\n\nA second option is to use a query type that implements defaultResult(), as shown in the next section.\n\nFor custom intents with parameters that conform to AppEntity, implement initializer methods to provide default values for the nonoptional parameters, such as the init(character:) method in the code for SelectCharacterIntent shown above. In your timeline provider’s placeholder(in:) method, use one of these initializer methods to initialize the app intent that you pass to the timeline entry. These methods enable you to customize the placeholder with values that might be different from the default, if needed.\n\nImplement a query to provide dynamic values\n\nSome of the tasks that an EntityQuery performs include:\n\nMapping AppEntity identifiers to the corresponding entity instances.\n\nProviding a list of suggested values when a person edits a widget.\n\nSpecifying a default value for a parameter.\n\nWhen a person edits a widget with a custom intent that provides dynamic values, the system invokes the query object’s suggestedEntities() method to get the list of possible choices.\n\nIn the entity query, the result is an array of all the CharacterDetail types available.\n\nstruct CharacterQuery: EntityQuery {\n    func entities(for identifiers: [CharacterDetail.ID]) async throws -> [CharacterDetail] {\n        CharacterDetail.allCharacters.filter { identifiers.contains($0.id) }\n    }\n    \n    func suggestedEntities() async throws -> [CharacterDetail] {\n        CharacterDetail.allCharacters.filter { $0.isAvailable }\n    }\n    \n    func defaultResult() async -> CharacterDetail? {\n        try? await suggestedEntities().first\n    }\n}\n\n\nWith the configuration of the custom app intent done, a person can edit the widget to select a specific character to display.\n\nAfter the person edits the widget and selects a character, the next step is to incorporate that choice into the widget’s display.\n\nHandle customized values in your widget\n\nTo support configurable properties, a widget uses the AppIntentTimelineProvider configuration. For example, the character-details widget defines its configuration as follows:\n\nstruct CharacterDetailWidget: Widget {\n    var body: some WidgetConfiguration {\n        AppIntentConfiguration(\n            kind: kind,\n            intent: SelectCharacterIntent.self,\n            provider: CharacterDetailProvider()) { entry in\n            CharacterDetailView(entry: entry)\n        }\n        .configurationDisplayName(\"Character Details\")\n        .description(\"Displays a character's health and other details\")\n        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])\n    }\n}\n\n\nThe SelectCharacterIntent parameter determines the customizable properties for the widget. The configuration uses CharacterDetailProvider to manage the timeline events for the widget. For more information about timeline providers, see Keeping a widget up to date.\n\nAfter a person edits the widget, WidgetKit passes the customized values to the provider when requesting timeline entries. You typically include relevant details from the intent in the timeline entries the provider generates. In the following example, the provider uses the defaultQuery to look up the CharacterDetail using the character’s id in the intent, and then creates a timeline with an entry containing the character’s detail:\n\nstruct CharacterDetailProvider: AppIntentTimelineProvider {\n    func timeline(for configuration: SelectCharacterIntent, in context: Context) async -> Timeline<CharacterDetailEntry> {\n        // Create the timeline and return it. The .never reload policy indicates\n        // that the containing app will use WidgetCenter methods to reload the\n        // widget's timeline when the details change.\n        let entry = CharacterDetailEntry(date: Date(), detail: configuration.character)\n        let timeline = Timeline(entries: [entry], policy: .never)\n        return timeline\n    }\n}\n\n\nWhen you include the customized values in the timeline entry, your widget’s view can display the appropriate content.\n\nAccess customized values in your app\n\nWhen a person taps on a widget to open your app, WidgetKit passes the customized intent to your app in an NSUserActivity. In your app’s code that handles the user activity, such as onContinueUserActivity(_:perform:) for a SwiftUI app or scene(_:continue:) for a UIKit app, use the widgetConfigurationIntent(of:) method to access the widget’s intent.\n\nTo access the intent of any widget that the user has installed, use getCurrentConfigurations(_:) to fetch the WidgetInfo objects. Iterate over the WidgetInfo objects and call widgetConfigurationIntent(of:).\n\nOffer preconfigured complications on Apple Watch\n\nStarting in watchOS 9, iOS 16, and iPadOS 17, you can use WidgetKit to implement accessory-family widgets that appear as complications on Apple Watch. Like widgets in iOS and macOS, watch complications use custom intents to display user-configurable data, and implementing configurable widgets in watchOS works the same as in iOS or macOS. However, watchOS doesn’t offer a dedicated user interface for configuring complications. To display data that’s most relevant to the user in your watch complication, you can create preconfigured complications and recommend them to your users in the list of available complications.\n\nIn your AppIntentTimelineProvider code, implement recommendations() and return the AppIntentRecommendation objects you create using your custom intents.\n\nWhen your app receives new data that’s relevant to your recommended widget configurations, invalidate the now outdated recommendations by calling invalidateConfigurationRecommendations(). This tells WidgetKit to get new recommendations for your preconfigured complications. When you invalidate the recommendations for preconfigured complications, make sure you return updated AppIntentRecommendation objects in the recommendations() callback.\n\nSee Also\nConfigurable widgets\nMigrating widgets from SiriKit Intents to App Intents\nConfigure your widgets for backward compatibility.\nstruct AppIntentConfiguration\nAn object describing the content of a widget that uses a custom intent to provide user-configurable options.\nstruct WidgetInfo\nA structure that contains information about user-configured widgets.\nstruct AppIntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nstruct IntentConfiguration\nAn object describing the content of a widget that uses a custom intent definition to provide user-configurable options.\nstruct IntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget."
  },
  {
    "title": "WidgetLocation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetlocation",
    "html": "Topics\nSpecifying a location style\nstatic let homeScreen: WidgetLocation\nThe Home Screen, Today View, Mac desktop, or similar location.\nstatic let lockScreen: WidgetLocation\nThe Lock Screen location.\nType Properties\nstatic let iPhoneWidgetsOnMac: WidgetLocation\nThe location that indicates a widget from another device that appears on the Mac.\nstatic let standBy: WidgetLocation\nThe StandBy location.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment."
  },
  {
    "title": "SwiftUI views for widgets | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/swiftui-views",
    "html": "Overview\n\nWidgets can use many, but not all, SwiftUI views to present content. Use the views listed below to implement your widget’s view.\n\nNote\n\nWidgets can’t use UIKit or AppKit views wrapped with UIViewRepresentable or NSViewRepresentable.\n\nTopics\nDisplaying text\nDisplaying dynamic dates in widgets\nShow up-to-date, time-based information in your widget even when it isn’t running.\nstruct Text\nA view that displays one or more lines of read-only text.\nShowing images\nstruct Image\nA view that displays an image.\nAdding interaction\nstruct Button\nA control that initiates an action.\nstruct Toggle\nA control that toggles between on and off states.\nAdding labels and links\nstruct Label\nA standard label for user interface items, consisting of an icon with a title.\nstruct Link\nA control for navigating to a URL.\nStacking views\nstruct HStack\nA view that arranges its subviews in a horizontal line.\nstruct VStack\nA view that arranges its subviews in a vertical line.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nstruct LazyHStack\nA view that arranges its children in a line that grows horizontally, creating items only as needed.\nstruct LazyVStack\nA view that arranges its children in a line that grows vertically, creating items only as needed.\nArranging views in grids\nstruct LazyHGrid\nA container view that arranges its child views in a grid that grows horizontally, creating items only as needed.\nstruct LazyVGrid\nA container view that arranges its child views in a grid that grows vertically, creating items only as needed.\nstruct GridItem\nA description of a row or a column in a lazy grid.\nEnumerating lists\nstruct ForEach\nA structure that computes views on demand from an underlying collection of identified data.\nGrouping views\nstruct Group\nA type that collects multiple instances of a content type — like views, scenes, or commands — into a single unit.\nstruct GroupBox\nA stylized view, with an optional label, that visually collects a logical grouping of content.\nstruct Section\nA container view that you can use to add hierarchy within certain views.\nRepresenting hierarchies\nstruct OutlineGroup\nA structure that computes views and disclosure groups on demand from an underlying collection of tree-structured, identified data.\nAdding spacers and dividers\nstruct Spacer\nA flexible space that expands along the major axis of its containing stack layout, or on both axes if not contained in a stack.\nstruct Divider\nA visual element that can be used to separate other content.\nHandling conditional views\nstruct EmptyView\nA view that doesn’t contain any content.\nstruct EquatableView\nA view type that compares itself against its previous value and prevents its child updating if its new value is the same as its old value.\nDisplaying shapes\nstruct Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nstruct RoundedRectangle\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nstruct Circle\nA circle centered on the frame of the view containing it.\nstruct Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nstruct Capsule\nA capsule shape aligned inside the frame of the view containing it.\nstruct Path\nThe outline of a 2D shape.\nTransforming views\nstruct ScaledShape\nA shape with a scale transform applied to it.\nstruct RotatedShape\nA shape with a rotation transform applied to it.\nstruct OffsetShape\nA shape with a translation offset transform applied to it.\nstruct TransformedShape\nA shape with an affine transform applied to it.\nstruct ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nStyling views\nstruct Color\nA representation of a color that adapts to a given context.\nstruct ImagePaint\nA shape style that fills a shape by repeating a region of an image.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct LinearGradient\nA linear gradient.\nstruct AngularGradient\nAn angular gradient.\nstruct RadialGradient\nA radial gradient.\nstruct ForegroundStyle\nThe foreground style in the current context.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct BackgroundStyle\nThe background style in the current context.\nstruct SelectionShapeStyle\nA style used to visually indicate selection following platform conventional colors and behaviors.\nstruct SeparatorShapeStyle\nA style appropriate for foreground separator or border lines.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nCreating 2D graphics\nstruct Canvas\nA view type that supports immediate mode drawing.\nManaging view geometry\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct ProjectionTransform\nSubstituting views\nstruct AnyView\nA type-erased view.\nstruct TupleView\nA View created from a swift tuple of View values.\nSee Also\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment.\nstruct WidgetLocation\nValues that indicate different widget locations."
  },
  {
    "title": "AccessoryWidgetBackground | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/accessorywidgetbackground",
    "html": "Overview\n\nUse this view to provide a standardized background for your accessory widgets. Place the view in a ZStack behind your widget’s content.\n\nZStack {\n    AccessoryWidgetBackground()\n    VStack {\n        Text(\"MON\")\n            .font(.caption)\n            .widgetAccented()\n        Text(\"6\")\n            .font(.title)\n    }\n}\n\n\nThe system only displays this view inside a WidgetFamily.accessoryCircular, WidgetFamily.accessoryCorner, or WidgetFamily.accessoryRectangular widget. In any other context, the system displays an empty view instead.\n\nTopics\nCreating accessory widget backgrounds\ninit()\nCreates an instance of an accessory widget background.\nRelationships\nConforms To\nView\nSee Also\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nstruct WidgetLocation\nValues that indicate different widget locations."
  },
  {
    "title": "Animating data updates in widgets and Live Activities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/animating-data-updates-in-widgets-and-live-activities",
    "html": "Overview\n\nAnimations bring your widgets and Live Activities to life and alert a person when new information is available. Starting with iOS 17, iPadOS 17, and macOS 14, widgets and Live Activities animate data updates with default animations or SwiftUI animations you choose, bringing a person’s attention to updated data. In earlier OS versions, widgets don’t animate, and Live Activities only use a subset of SwiftUI transitions and animations.\n\nNote\n\nAnimations in widgets and Live Activities have a maximum duration of two seconds.\n\nFor example, text views animate content changes with blurred content transitions by default, and changes to images and SF Symbols animate with default content transitions. If you add or remove views from the interface based on timeline updates or other state changes, views fade in and out.\n\nRelated session from WWDC23\n\nSession 10028: Bring widgets to life\n\nTo replace default animations and transitions:\n\nConfigure built-in transitions like opacity, move(edge:), slide, push(from:), or combinations of them.\n\nAdd transition(_:), contentTransition(_:), or animation(_:value:) to views.\n\nRequest animations for timer text with numericText(countsDown:).\n\nImportant\n\nOn devices that include an Always-On display, the system doesn’t perform animations to preserve battery life in Always On. Check the isLuminanceReduced environment value to detect reduced luminance before animating content changes.\n\nFor Live Activities that appear on devices that run iOS 16 or earlier, the system ignores any animation modifiers — for example, withAnimation(_:_:) and animation(_:value:) — and uses the system’s animation timing instead. However, you can use built-in transitions like opacity, move(edge:), slide, push(from:), or combinations of them.\n\nFor more information about SwiftUI animations, see Animations.\n\nAdd transitions and animations to views that update their data\n\nIn addition to the default transitions and animations that the system performs when views update their data, you can choose other built-in SwiftUI transitions and animations. Widgets and Live Activities support all built-in SwiftUI transitions and animations. For example, you could configure a content transition for numeric text as shown in this example:\n\nText(totalCaffeine.formatCaffeine())\n\t.font(.title)\n\t.minimumScaleFactor (0.8)\n\t.contentTransition(.numericText())\n\n\nAdditionally, you could add a spring animation to the transition:\n\nText (totalCaffeine.formatCaffeine())\n\t.font(.title)\n\t.minimumScaleFactor (0.8)\n\t.contentTransition(.numericText())\n\t.animation(.spring(duration: 0.2), value: totalCaffeine)\n\nAdd transitions and animations to additional views\n\nYou can not only add transitions or animations to a view that changes its data, you can also animate a view when any widget information changes. To animate a view when a certain value changes, first associate the view you want to animate with that value’s data model object. This is easiest when your data model conforms to the Hashable protocol. If your data model doesn’t conform to Hashable, change its code accordingly. Then, associate the view with the data model using the id(_:) view modifier. Finally, add a transition or animation.\n\nThe following example shows how the LastDrinkView adds a push transition when the associated log changes.\n\nstruct LastDrinkView: View {\n    let log: CaffeineLog\n    var dateFormatStyle: Date.FormatStyle {\n        Date.FormatStyle(date: .omitted, time: .shortened)\n    }\n\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(log.drink.name)\n                .bold()\n            Text (\"\\(log.date, format: .dateformatStyle) • \\(log.drink.caffeine.formatCaffeine())\")\n        }\n        .font (.caption)\n        .id(log) // Associate the view with the data model.\n        .transition(.push(from: .bottom))\n    }\n}\n\nDisable animations\n\nIf a content update changes many views in your widget or Live Activity, consider disabling transitions and animations for some views to direct a person’s attention to the most important updates. To disable animations for a view, including default animations, pass identity to transition(_:) or nil to the animation parameter of withAnimation(_:_:) and animation(_:value:).\n\nNote\n\nThe Transaction isn’t available to widgets and Live Activities, so you can’t cancel or deactivate an animation by setting the transaction’s animation property to nil.\n\nSee Also\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment.\nstruct WidgetLocation\nValues that indicate different widget locations."
  },
  {
    "title": "Linking to specific app scenes from your widget or Live Activity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/linking-to-specific-app-scenes-from-your-widget-or-live-activity",
    "html": "Overview\n\nPeople interact with a widget or Live Activity to launch a scene in the corresponding app with matching content and functionality. For example, when people click or tap a Stocks widget, the Stocks app opens to a page that displays information about that stock price.\n\nWhen you create widgets and Live Activities, think about how people interact with them. Make sure interactions launch the scene in your app that fits the widget’s content or the Live Activity.\n\nLaunch a specific screen in your app\n\nBy default, tapping or clicking your widget or Live Activity opens its corresponding app. To provide a good experience and not make people navigate to get to the right place in your app, open the app at a scene that matches the content of the widget or Live Activity. To open a specific screen in your app, add the widgetURL(_:) modifier to a view in the view hierarchy of your widget or Live Activity.\n\nImportant\n\nIf the view hierarchy includes more than one widgetURL modifier, the behavior is undefined.\n\nFor example, the following code snippet from the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project shows how the small widget uses widgetURL(_:) to allow people to open the app and show a character’s detail information:\n\nstruct EmojiRangerWidgetEntryView: View {\n    var entry: SimpleEntry\n    \n    @Environment(\\.widgetFamily) var family\n    \n    @ViewBuilder\n    var body: some View {\n        switch family {\n\n\n        case .systemSmall:\n            AvatarView(entry.hero)\n                .widgetURL(entry.hero.url)\n                .foregroundColor(.white)\n                .containerBackground(for: .widget) {\n                    Color.gameBackgroundColor\n                }\n                .widgetURL(entry.hero.url)\n            \n        // Code for other widget sizes.\n    }\n}\n\n\nFor widgets with enough space for more than one interaction target — WidgetFamily.accessoryRectangular, WidgetFamily.systemSmall, and larger system family sizes — add one or more Link controls to your view hierarchy. You can use one widgetURL and additional Link controls. If an interaction targets a Link control, the system uses the URL in that control. For interactions anywhere else in the widget, the system uses the URL you specify in the widgetURL(_:) view modifier.\n\nFor example, the leaderboard widget of the Emoji Rangers: Supporting Live Activities, interactivity, and animations app displays a list of characters. Each item in the list uses a Link control to launch the scene in the app for the specific character that the item represents.\n\nNote\n\nWhen the widget or Live Activity receives an interaction, the system activates the containing app and passes the URL to onOpenURL(perform:), application(_:open:options:), or application(_:open:), depending on the life cycle your app uses.\n\nDetect the originating widget by accessing the user activity object\n\nIf a widget doesn’t specify a deep link URL with widgetURL(_:) or Link and a person interacts with it, the system opens the containing app and passes an NSUserActivity to onContinueUserActivity(_:perform:), application(_:continue:restorationHandler:), or application(_:continue:restorationHandler:). The user activity’s userInfo dictionary contains details about the widget the person interacted with. Use the keys in WidgetCenter.UserInfoKey to access these values from Swift code. To access the userInfo values from Objective-C, use the keys WGWidgetUserInfoKeyKind and WGWidgetUserInfoKeyFamily instead. Then, update your app’s interface to match the widget so people don’t have to navigate to the right place in your app.\n\nNote\n\nIf you use an AppIntentConfiguration to configure your widget, use the widgetConfigurationIntent(of:) function to access the widget’s intent. Similarly, if you use an IntentConfiguration, the user activity’s interaction property contains the associated INIntent.\n\nSee Also\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment.\nstruct WidgetLocation\nValues that indicate different widget locations."
  },
  {
    "title": "Preparing widgets for additional platforms, contexts, and appearances | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/preparing-widgets-for-additional-contexts-and-appearances",
    "html": "Overview\n\nWidgets change their appearance to best fit their context. For example, widgets on the Home Screen, Today View, or the macOS Notification Center use full colors and rich images to represent your brand and encourage people to feature your widget on their devices. In contrast, Lock Screen widgets and WidgetKit complications use more restrained colors because they’re smaller, always visible, and support tinted modes for each platform. Since all widgets appear in more than one context, make sure your widgets and their SwiftUI views support all applicable rendering modes.\n\nWidgetKit uses three different rendering modes:\n\nvibrant\n\nDesaturates text, images, and gauges into monochrome and creates a vibrant effect by coloring your content appropriately for the Lock Screen background or the macOS desktop. Note that people can also color the Lock Screen to a colored tint and WidgetKit uses a red tint for widgets that appear on iPhone in StandBy in low-light conditions.\n\nfullColor\n\nDoesn’t change the color of your complication’s views in this rendering mode. Use gradients and full-color images, text, and gauges.\n\naccented\n\nRenders complications in the accented rendering mode when people customize their watch face to use a tint color or choose certain watch faces. watchOS divides the widget’s view hierarchy into an accent group and a default group, and then applies a solid color to each group. Use the widgetAccentable(_:) view modifier to group views into the accented group. Note that this rendering mode isn’t available in iOS or macOS.\n\nThe following table shows the rendering modes for each widget you need to support:\n\nWidget size\n\n\t\n\nfullColor\n\n\t\n\naccented\n\n\t\n\nvibrant\n\n\n\n\nWidgetFamily.systemSmall\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nWidgetFamily.systemMedium\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nWidgetFamily.systemLarge\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nWidgetFamily.systemExtraLarge\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nWidgetFamily.accessoryCircular\n\n\t\n\nNo\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nWidgetFamily.accessoryCorner\n\n\t\n\nNo\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nWidgetFamily.accessoryRectangular\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nWidgetFamily.accessoryInline\n\n\t\n\nNo\n\n\t\n\nYes\n\n\t\n\nYes\n\nNote\n\nFor design guidance, see Human Interface Guidelines > Complications and Human Interface Guidelines > Widgets.\n\nIn your code, read the widgetRenderingMode environment variable to create SwiftUI views for each applicable rendering mode, as shown in the following example:\n\nvar body: some View {\n   ZStack {\n       switch renderingMode {\n       case .fullColor:\n           // Create views for full-color widgets and watch complications.\n       case .accented:\n           // Create views and group applicable views in the accented group.\n           VStack {\n               // ...\n           }\n           .widgetAccentable()\n           // Additional views that you don't group in the accented group.\n       case .vibrant:\n           // Create views for Lock Screen widgets on iPhone and iPad, and for the receded appearance on the Mac desktop.\n   }\n}\n\nSupport Always On\n\nIf you create accessory widgets and WidgetKit complications, make sure to use SwiftUI’s isLuminanceReduced environment variable to detect Always On and color your views to look great with reduced luminance. For design guidance, see Human Interface Guidelines > Always On and Human Interface Guidelines > Widgets.\n\nAdd support for StandBy to your small widget\n\nOn iPhone in StandBy, the Lock Screen shows two widgets side by side on a dark background. WidgetKit uses your WidgetFamily.systemSmall widget and scales it to fit one half of the screen. To support this appearance:\n\nMake the widget’s background removable with a container background, as described below.\n\nUpdate the widget’s layout to take advantage of the larger appearance and smaller content margins and to make the widget easier to read from a larger distance.\n\nChange the widget background\n\nWidgets appear differently based on their context, including their background view. In the vibrant appearance, the system removes the background of your widget or renders it in semitranslucent appearance.\n\nMark your background views as removable for the following widget sizes:\n\nWidgetFamily.systemSmall\n\nWidgetFamily.systemMedium\n\nWidgetFamily.systemLarge\n\nWidgetFamily.systemExtraLarge\n\nWidgetFamily.accessoryRectangular\n\nAll system widgets need to support removable background views because contexts like iPhone in StandBy and the receded appearance on the Mac desktop require it.\n\nIf you support the accessory rectangular widget size, marking the background view as removable allows you to use the same layout and view for the rectangular accessory widget across contexts. For example, in the Smart Stack on Apple Watch, WidgetKit renders it with a rich, full-color background and without a background as a watch complication or on the Lock Screen of iPhone and iPad.\n\nNote\n\nOn Apple Watch, rectangular widgets in the Smart Stack use a default dark material background. By adding a container background, the widget renders with a background that visually ties it to your app and makes it more recognizable to people.\n\nTo make sure your widgets appear correctly:\n\nAdd the containerBackground(_:for:) modifier to your background views to define the background appearance of your widget and tell WidgetKit that it can remove the view where applicable.\n\nMove code that declares any background color or views inside the containerBackground(for:) view modifier and pass widget to it. This makes sure WidgetKit automatically removes the background as needed.\n\nThe following code snippet is for the accessory rectangular widget for the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project. It uses a gameBackground color for the widget’s container background so it appears with or without the background color where needed.\n\nvar body: some View {\n    switch family {\n    // Logic for additional widget sizes.\n    case .accessoryRectangular:\n        HStack(alignment: .center, spacing: 0) {\n            VStack(alignment: .leading) {\n                Text(entry.hero.name)\n                    .font(.headline)\n                    .widgetAccentable()\n                Text(\"Level \\(entry.hero.level)\")\n                Text(entry.hero.fullHealthDate, style: .timer)\n            }.frame(maxWidth: .infinity, alignment: .leading)\n            Avatar(hero: entry.hero, includeBackground: false)\n        }\n        .containerBackground(for: .widget) {\n            Color.gameBackground\n        }\n\t\t// Logic for additional widget sizes.\n}\n\n\nTo detect whether a widget appears with or without a background, use the showsWidgetContainerBackground environment variable.\n\nImportant\n\nSome widgets, like the Photos and Maps widgets, don’t use distinct foreground content, so background removal removes the functionality of the widget. If this applies to your widget, add the containerBackgroundRemovable(_:) modifier to your widget configuration. However, this excludes your widget from appearing on the iPad Lock Screen.\n\nSet the background color of accessory widgets\n\nDepending on your accessory widget or complication, you may need to set a consistent background for your accessory widget. Use AccessoryWidgetBackground to draw a consistent background for your widget, as shown in the following example. It creates a view that’s similar to the circular Lock Screen widget that the Calendar app offers:\n\nZStack {\n     AccessoryWidgetBackground()\n     VStack {\n        Text(“MON”)\n        Text(“6”)\n         .font(.title)\n    }\n}\n\nSee Also\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment.\nstruct WidgetLocation\nValues that indicate different widget locations."
  },
  {
    "title": "WidgetFamily | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/widgetfamily",
    "html": "Overview\n\nWidgets can support one or more sizes, giving users the flexibility to configure their widgets however they like. Each widget size provides a different amount of space for detail, so consider which sizes work best for the type of information the widget displays. For more information about designing widgets, see Widgets or Complications.\n\nNote\n\nThe sizes of widgets may vary across devices. Your widget content should be flexible and avoid using fixed values.\n\nYou specify the sizes your widget supports using the supportedFamilies(_:) property modifier when defining your widget’s configuration.\n\nstruct GameStatusWidget: Widget {\n    var body: some WidgetConfiguration {\n        StaticConfiguration(\n            kind: \"com.mygame.game-status\",\n            provider: GameStatusProvider(),\n            placeholder: GameStatusPlaceholderView()\n        ) { entry in\n            GameStatusView(entry.gameStatus)\n        }\n        .configurationDisplayName(\"Game Status\")\n        .description(\"Shows an overview of your game status\")\n        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])\n    }\n}\n\n\nWhen WidgetKit needs to load a widget’s timeline, it calls the TimelineProvider class’s getTimeline(in:completion:) method. The system passes a TimelineProviderContext instance to the method’s context parameter. Use the context’s family property to determine the widget’s size and shape. For example, the WidgetFamily.systemSmall family represents a small, square widget on the Home Screen or Today View in iOS or iPadOS, while, in watchOS theWidgetFamily.accessoryCorner family appears as a widget-based complication in the corner of a watch face.\n\nUse the WidgetFamily value to return the appropriate content given the widget’s size. For example, a WidgetFamily.systemSmall widget may focus on showing only the most critical data, such as a single image or a simple gauge, while a WidgetFamily.systemLarge widget can contain additional details, more-complex graphs, and even small blocks of text.\n\nTopics\nAccessing system families\ncase systemSmall\nA small widget.\ncase systemMedium\nA medium-sized widget.\ncase systemLarge\nA large widget.\ncase systemExtraLarge\nAn extra-large widget.\nAccessing accessory families\ncase accessoryCircular\nA circular widget.\ncase accessoryCorner\nA widget-based complication in the corner of a watch face in watchOS.\ncase accessoryRectangular\nA rectangular widget.\ncase accessoryInline\nA flat widget that contains a single row of text and an optional image.\nRelationships\nConforms To\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nRawRepresentable\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nstruct WidgetRenderingMode\nConstants that indicate the rendering mode for a widget."
  },
  {
    "title": "StaticConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/staticconfiguration",
    "html": "Overview\n\nThe following example shows the configuration for the leaderboard widget of the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project.\n\nstruct LeaderboardWidget: Widget {\n\n\n    public var body: some WidgetConfiguration {\n        StaticConfiguration(kind: EmojiRanger.LeaderboardWidgetKind, provider: LeaderboardProvider()) { entry in\n            LeaderboardWidgetEntryView(entry: entry)\n        }\n        .configurationDisplayName(\"Ranger Leaderboard\")\n        .description(\"See all the rangers.\")\n        .supportedFamilies(LeaderboardWidget.supportedFamilies)\n    }\n}\n\n\nEvery widget has a unique kind, a string that you choose. You use this string to identify your widget when reloading its timeline with WidgetCenter.\n\nThe timeline provider is an object that determines the timeline for refreshing your widget. Providing future dates for updating your widget allows the system to optimize the refresh process.\n\nThe content closure contains the SwiftUI views that WidgetKit needs to render the widget. When WidgetKit invokes the content closure, it passes a timeline entry created by the widget provider’s getSnapshot(in:completion:) or getTimeline(in:completion:) method.\n\nModifiers let you specify the families your widget supports, and the details shown when users add or edit their widgets.\n\nTopics\nCreating a widget configuration\ninit<Provider>(kind: String, provider: Provider, content: (Provider.Entry) -> Content)\nCreates a configuration for a widget, with no user-configurable options.\nAvailable when Content conforms to View.\nvar body: Self.Body\nThe content and behavior of this widget.\nSetting the display name\nfunc configurationDisplayName<S>(S) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the specified string.\nfunc configurationDisplayName(Text) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the contents of a text view.\nfunc configurationDisplayName(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized name shown for a widget when a user adds or edits the widget.\nSetting the description\nfunc description(Text) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the contents of a text view.\nfunc description<S>(S) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the specified string.\nfunc description(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized description shown for a widget when a user adds or edits the widget.\nSetting the supported families\nfunc supportedFamilies([WidgetFamily]) -> some WidgetConfiguration\nSets the sizes that a widget supports.\nHandling background network requests\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some WidgetConfiguration\nRuns the given action when the system provides a background task.\nfunc onBackgroundURLSessionEvents(matching: ((String) -> Bool)?, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session identified by a closure are waiting to be processed.\nfunc onBackgroundURLSessionEvents(matching: String, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session with a matching identifier are waiting to be processed.\nRelationships\nConforms To\nWidgetConfiguration\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nstruct WidgetRenderingMode\nConstants that indicate the rendering mode for a widget."
  },
  {
    "title": "Creating views for widgets, Live Activities, and watch complications | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/creating-views-for-widgets-live-activities-and-watch-complications",
    "html": "Overview\n\nSwiftUI and WidgetKit power widgets, Live Activities, and watch complications. Because they use the same technology and share design similarities, plan your WidgetKit adoption before you start creating these features. Start simple and add complexity later; for example, start by adding a widget extension as described in Creating a widget extension and support one widget size. Spend time to make sure it offers a focused, glanceable experience. Then, add support for additional widget sizes and features like configurability, animations, and interactivity.\n\nRelated session from WWDC23\n\nSession 10027: Bring widgets to new places\n\nIf you’re new to using WidgetKit, see Developing a WidgetKit strategy.\n\nUse system font styles\n\nWidgets, Live Activities, and watch complications appear adjacent to other widgets or complications. As a result, a consistent look for your content that fits in well with the other elements needs to be a priority. To achieve a consistent look for your widgets and complications, use system fonts, default font parameters, and the following font styles:\n\nFont.TextStyle.headline\n\nFont.TextStyle.title\n\nFont.TextStyle.body\n\nFont.TextStyle.caption\n\nMake sure text fits the available space\n\nWidgets and watch complications offer limited space for content — especially on the Lock Screen or on Apple Watch. Give careful consideration to the amount of text you display. For example, say you support the WidgetFamily.accessoryInline widget. It can include an image and text. However, the amount of displayable characters varies depending on the context where the widget appears. On Apple Watch, the size of the inline complication varies depending on the watch face. Include it in a ViewThatFits view to make sure text always fits the available space.\n\nNote\n\nTest your widgets with every language you support, especially if you support languages that commonly have words with a lot of characters, such as German.\n\nUse content margins instead of safe areas\n\nwatchOS 9, iOS 16, iPadOS 16, macOS 13, and earlier use system-defined safe areas to keep content from getting too close to the edge of the widget, complication, or Live Activity. You likely don’t change the safe areas that the system defines. However, you might use the ignoresSafeArea(_:edges:) view modifier to extend content farther than the safe area.\n\nStarting with watchOS 10, iOS 17, iPadOS 17, and macOS 14, widgets, WidgetKit complications, and Live Activities use content margins instead of safe areas. As a result, ignoresSafeArea(_:edges:) has no effect. Instead, you need to use the contentMarginsDisabled() view modifier to define custom content margins.\n\nIf you use ignoresSafeArea(_:edges:), follow these steps:\n\nAdd the contentMarginsDisabled() view modifier to your widget configuration.\n\nFor any content that should remain inside system-defined content margins, add padding as needed using padding().\n\nTip\n\nTo access the system’s default content margins for an environment, use the widgetContentMargins environment variable.\n\nSee Also\nPresentation\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment.\nstruct WidgetLocation\nValues that indicate different widget locations."
  },
  {
    "title": "Migrating ClockKit complications to WidgetKit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/converting-a-clockkit-app",
    "html": "Overview\n\nWith watchOS 9 and later, you can create complications for your watchOS app using SwiftUI views in WidgetKit.\n\nWidgetKit provides a modern API for creating and updating glanceable elements — making it an ideal fit for watchOS complications. Because WidgetKit’s design is inspired by ClockKit, if you’ve already designed ClockKit complications for your app, the process feels familiar. Similarly, if you’re already using widgets for iOS, you can quickly set up WidgetKit complications for a watchOS app. In many cases, you can use the same code to display WidgetKit complications in watchOS and widgets on the Lock Screen on iPhone. For more information, see Creating accessory widgets and watch complications.\n\nAdd WidgetKit to your project\n\nTo convert ClockKit complications to WidgetKit, start by adding a WidgetKit extension to your watchOS project.\n\nIn Xcode, select the project icon in the Project navigator.\n\nClick the “Add a target” button.\n\nIn the watchOS tab, select the Widget Extension template and click Next.\n\nGive the new target a name.\n\nIf your app dynamically creates the set of CLKComplicationDescriptor objects to support multiple complication types, enable the Include Configuration App Intent option. If you don’t plan to configure your complications using app intents, you can disable this option.\n\nClick Finish.\n\nXcode creates a new target containing Swift files for the widget, an asset catalog, and an Info.plist file for the extension. The WidgetKit template provides you with structures that adopt the Widget and View protocols. It also includes a starting implementation for your TimelineProvider, or AppIntentTimelineProvider if you enabled Include Configuration App Intent.\n\nImportant\n\nAfter you add a WidgetKit extension to your project, the system tries to use it to generate complications for your watchOS app. As soon as your WidgetKit extension begins providing widget-based complications, the system disables your app’s ClockKit complications. It no longer wakes your app to call your CLKComplicationDataSource object’s methods to request timeline entries. However, the system may still wake your data source to call getWidgetConfiguration(from:completionHandler:), while migrating complications from ClockKit to WidgetKit.\n\nConfigure your timeline provider\n\nThe template creates a Provider structure that adopts the TimelineProvider or AppIntentTimelineProvider protocol, and provides a default implementation for the protocol’s methods. WidgetKit calls these methods to get the data needed to create the widget view.\n\nNote\n\nWidgetKit’s daily budget for reloading the timeline works differently than ClockKit’s. Your widget-based complication receives up to 75 updates per day, based on how often they’re viewed. If you have a complication on the Apple Watch face, it’s always considered viewed, so your budget tends towards the higher end of that range.\n\nIn each of the protocol methods, your app needs to create and return one or more TimelineEntry instances:\n\nplaceholder(in:)\n\nReturns a single entry for your complication’s placeholder. By default, the system redacts all the content in the placeholder’s widget.\n\ngetSnapshot(in:completion:)\n\nReturns a single timeline entry for your app.\n\ngetTimeline(in:completion:)\n\nReturns an array of timeline entries. WidgetKit uses this timeline to automatically update your complication over time.\n\nThe template provides a timeline entry that contains the date when the system should display it. Add any extra properties that you need for your complications.\n\nstruct CoffeeTrackerEntry: TimelineEntry {\n    let date: Date\n    let mgCaffeine: Double\n    let totalCups: Double\n}\n\n\nThen, begin updating the timeline provider’s methods. For the placeholder, the system automatically redacts all of the widget’s content, unless you explicitly mark items with the unredacted() view modifier in your complication’s SwiftUI view. As a result, you may want to provide generic data that fills out the redacted version.\n\nfunc placeholder(in context: Context) -> SimpleEntry {\n    \n    // Show a complication with generic data.\n    CoffeeTrackerEntry(date: Date(),\n                       mgCaffeine: 250.0,\n                       totalCups: 2.0)\n}\n\n\nThe system can display the placeholder when the watch is locked, when it’s in Always On mode, and when it can’t otherwise display a live version of your complication.\n\nFor the snapshot, return a single entry. In general, you want to return the current state of your app. However, the system also uses the snapshot when displaying your complication in the complication picker. When returning your snapshot entry, be sure to check the context parameter isPreview property. This property indicates whether the snapshot will be used in the complication picker. If this is true, provide generic data that shows your app’s typical appearance.\n\nfunc getSnapshot(in context: Context, completion: @escaping (CoffeeTrackerEntry) -> Void) {\n    \n    if context.isPreview {\n        // Show a complication with generic data.\n        let entry = CoffeeTrackerEntry(date: Date(),\n                    mgCaffeine: 250.0,\n                    totalCups: 2.0)\n        \n        completion(entry)\n        return\n    }\n    \n    Task {\n        \n        let date = Date()\n        \n        // Get the current data from the model.\n        let mgCaffeine = await data.mgCaffeine(atDate: date)\n        let totalCups = await data.totalCupsToday\n        \n        // Create the entry.\n        let entry = CoffeeTrackerEntry(date: date,\n                                mgCaffeine: mgCaffeine,\n                                totalCups: totalCups)\n        \n        // Pass the entry to the completion handler.\n        completion(entry)\n    }\n}\n\n\nFor the timeline, create an array of entries, and then create a Timeline instance from that array. You can also select a reload policy for the timeline. By default, the system reloads the timeline when you reach its end. However, in the example below, the system only reloads the timeline when you explicitly request it.\n\nfunc getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> Void) {\n    Task {\n\n\n        // Create an array to hold the events.\n        var entries: [CoffeeTrackerEntry] = []\n        \n        // The total number of cups consumed only changes when the user actively adds a drink,\n        // so it remains constant in this timeline.\n        let totalCups = await data.totalCupsToday\n\n\n        // Generate a timeline covering every 5 minutes for the next 24 hours.\n        let currentDate = Date()\n        for minuteOffset in stride(from: 0, to: 60 * 24, by: 5) {\n            let entryDate = Calendar.current.date(byAdding: .minute, value: minuteOffset, to: currentDate)!\n            \n            // Get the projected data for the specified date.\n            let mgCaffeine = await data.mgCaffeine(atDate: entryDate)\n            \n            // Create the entry.\n            let entry = CoffeeTrackerEntry(date: entryDate,\n                                           mgCaffeine: mgCaffeine,\n                                           totalCups: totalCups)\n            \n            // Add the event to the array.\n            entries.append(entry)\n        }\n\n\n        // Create the timeline and pass it to the completion handler.\n        // Because the caffeine dose drops to 0.0 mg after 24 hours,\n        // there's no need to reload this timeline unless the user adds\n        // a new drink. Setting the reload policy to .never.\n        let timeline = Timeline(entries: entries, policy: .never)\n        \n        // Pass the timeline to the completion handler.\n        completion(timeline)\n    }\n}\n\n\nFor more information, see Making a configurable widget and Keeping a widget up to date.\n\nSupport multiple complications\n\nIf your app provides a static set of widgets, you can define multiple widgets using a WidgetBundle protocol. For example, the code listing below provides three complications: one that displays the user’s current caffeine dose, one that provides the total number of cups of coffee for the day, and one that provides both. Each widget can then support a different subset of the available families.\n\n@main\nstruct CoffeeTrackerWidgets: WidgetBundle {\n   var body: some Widget {\n       CaffeineComplication()\n       CupsComplication()\n       CaffeineAndCupsComplication()\n   }\n}\n\n\nHowever, if you need to dynamically configure a set of complications, provide a custom app intent. For example, a weather app may let people install complications for any cities in their favorites list.\n\nWidgetKit uses app intents for customizable properties, the same method that Siri Suggestions and Siri Shortcuts use to customize those interactions. In iOS, the app intents describe elements that the user can customize. For WidgetKit complications in watchOS, these intents aren’t user configurable. Instead, they represent items that your app can dynamically configure.\n\nTo customize the widgets, implement your AppIntentTimelineProvider structure’s recommendations() method to return an array of AppIntentRecommendation instances.\n\nfunc recommendations() -> [AppIntentRecommendation<ConfigurationAppIntent>] {\n    var recommendations = [AppIntentRecommendation<ConfigurationAppIntent>]()\n    \n    for cityID in favoriteCityIDs {\n        let intent = ConfigurationAppIntent()\n        intent.cityID = cityID\n        recommendations.append(AppIntentRecommendation(intent: intent, description: cityName(id: cityID)))\n    }\n\n\n    return recommendations\n}\n\n\nFor more information, see Making a configurable widget.\n\nDesign the complication using SwiftUI\n\nUse SwiftUI static views, such as text, shapes, or images, to create your complication’s content. You can also add render effects like blurs and gradients, but keep in mind that complications only have one or two frames in which to render the effect.\n\nBecause complications show a snapshot of the app’s data at a particular point in time, they don’t support features like animation. Additionally, if the user touches your complication, the system launches your app instead of passing the touch event to the SwiftUI views, so a complication can’t use interactive elements like buttons or switches.\n\nStart by updating your Widget structure.\n\nstruct CaffeineComplication: Widget {\n    \n    // Create a unique string to identify the complication.\n    let kind: String = \"Caffeine-Complication\"\n\n\n    var body: some WidgetConfiguration {\n        StaticConfiguration(kind: kind, provider: Provider()) { entry in\n            CoffeeTrackerComplicationsEntryView(entry: entry)\n        }\n        .configurationDisplayName(\"Coffee Tracker\")\n        .description(\"Shows the current caffeine dose in your system.\")\n        .supportedFamilies([.accessoryCorner, .accessoryCircular, .accessoryInline])\n    }\n}\n\n\nThe body of the widget contains either a static or intent configuration, depending on whether your app uses custom app intent definitions. Use the configuration to set items like the complication’s display name and the supported families. The configuration also takes a closure that returns a SwiftUI view for the specified entry.\n\nWidgetKit reduces the number of families you need to support. In some cases, a WidgetKit accessory family covers more than one ClockKit family, which reduces the number of supported families from 12 to 4.\n\nClockKit family\n\n\t\n\nWidgetKit family\n\n\n\n\nCLKComplicationFamily.graphicRectangular\n\n\t\n\nWidgetFamily.accessoryRectangular\n\n\n\n\nCLKComplicationFamily.graphicCorner\n\n\t\n\nWidgetFamily.accessoryCorner\n\n\n\n\nCLKComplicationFamily.graphicCircular, CLKComplicationFamily.graphicBezel, CLKComplicationFamily.graphicExtraLarge\n\n\t\n\nWidgetFamily.accessoryCircular\n\n\n\n\nCLKComplicationFamily.utilitarianSmallFlat, CLKComplicationFamily.utilitarianLarge\n\n\t\n\nWidgetFamily.accessoryInline\n\nNote\n\nwatchOS 9 and later no longer shows families like CLKComplicationFamily.circularSmall, CLKComplicationFamily.modularSmall, or CLKComplicationFamily.modularLarge on watch faces.\n\nUse the widgetFamily environment value to determine the complication’s family. You can provide a different SwiftUI view for each family. You can also get the family from the context passed to your timeline provider’s getTimeline(in:completion:), getSnapshot(in:completion:), and placeholder(in:) methods.\n\nstruct CaffeineComplicationView: View {\n    \n    // Get the widget's family.\n    @Environment(\\.widgetFamily) private var family\n    \n    var entry: Provider.Entry\n    \n    var body: some View {\n        switch family {\n        case .accessoryCircular:\n            MyCircularComplication(mgCaffeine: entry.mgCaffeine,\n                                   totalCups: entry.totalCups)\n            \n        case .accessoryCorner:\n            MyCornerComplication(mgCaffeine: entry.mgCaffeine,\n                                 totalCups: entry.totalCups)\n            \n        case .accessoryInline:\n            MyInlineComplication(mgCaffeine: entry.mgCaffeine,\n                                 totalCups: entry.totalCups)\n            \n        default:\n            Image(\"AppIcon\")\n        }\n    }\n}\n\n\nThen, check the WidgetRenderingMode environmental value to determine whether your complication is rendered in full color or using accent colors. Modify your design to best suit the current rendering mode.\n\nstruct MyCircularComplication: View {\n    // Get the rendering mode.\n    @Environment(\\.widgetRenderingMode) var renderingMode\n    \n    var mgCaffeine: Double\n    var totalCups: Double\n    let maxMG = 500.0\n    \n    var body: some View {\n        Gauge( value: min(mgCaffeine, maxMG), in: 0.0...maxMG ) {\n            Text(\"mg\")\n        } currentValueLabel: {\n            if renderingMode == .fullColor {\n                // Add a foreground color to the label.\n                Text(mgCaffeine.formatted(myFloatFormatter))\n                    .foregroundColor(.doseColor(for: mgCaffeine))\n            }\n            else {\n                // Otherwise, use the default text color.\n                Text(mgCaffeine.formatted(myFloatFormatter))\n            }\n        }\n        .gaugeStyle(\n            // Add a gradient to the gauge.\n            CircularGaugeStyle(tint: Gradient(stops: myStops)))\n    }\n}\n\n\nIn accented mode, you can explicitly partition your view into an accented group and the default group by adding the widgetAccentable(_:) view modifier to part of your complication’s view hierarchy. For more information, see Creating accessory widgets and watch complications and Creating views for widgets, Live Activities, and watch complications.\n\nWhen designing your WidgetKit complications, build your complication views so that they can adapt to different sizes. For example, you can use ViewThatFits to provide a set of different-sized views, letting the system pick the best fit for the current context.\n\nYou can add a standard background to your complication by adding a AccessoryWidgetBackground in a ZStack behind your widget’s content, and you can also add additional information to circular and corner complications using a widgetLabel(label:). Use the widget label to add gauges, progress views, or text along the inside curve of the corner view, or to add an image and text along the bezel of the Infograph watch face.\n\nFinally, consider how Always On affects your complications. You may need to redact sensitive information, or adjust the widget’s appearance for reduced luminance. You can explicitly redact sensitive information using the privacySensitive(_:) view modifier. If you do, the system displays the redacted version of your view during Always On. For more information, see Designing your app for the Always On state.\n\nNote\n\nIf you don’t use the privacySensitive(_:) view modifier anywhere in your view hierarchy, the system displays a placeholder instead of a live complication. By default, the placeholder redacts all of your complication’s content.\n\nMigrate complications on a watch face\n\nWhen users upgrade your app, you need to transition them from the old ClockKit complications to your new WidgetKit complications. Start by implementing your CLKComplicationDataSource type’s widgetMigrator method. Use your implementation to return an instance that conforms to the CLKComplicationWidgetMigrator protocol.\n\nFor example, update your data source so that it conforms to the CLKComplicationWidgetMigrator protocol.\n\nclass ComplicationController: NSObject, CLKComplicationDataSource, CLKComplicationWidgetMigrator {\n   // ...\n}\n\n\nThen, have the widgetMigrator property return self.\n\nvar widgetMigrator: CLKComplicationWidgetMigrator {\n    self\n}\n\n\nFinally, implement the getWidgetConfiguration(from:completionHandler:) method. This method determines the best WidgetKit configuration for the given complication descriptor. The following example uses the Swift async version of the method.\n\nfunc widgetConfiguration(from complicationDescriptor: CLKComplicationDescriptor) async -> CLKComplicationWidgetMigrationConfiguration? {\n    \n    switch complicationDescriptor.identifier {\n    case caffeineDoseIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"Caffeine_Complications\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n\n    case cupTotalIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"CupTotal_Complications\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n\n    case cupAndCaffeineIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"CupAndCaffeine_Complications\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n\n    default:\n        return nil\n    }\n}\n\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nstruct WidgetRenderingMode\nConstants that indicate the rendering mode for a widget."
  },
  {
    "title": "Developing a WidgetKit strategy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/developing-a-widgetkit-strategy",
    "html": "Overview\n\nUse WidgetKit to build widgets, watch complications, and Live Activities. With these features, you can create an ecosystem across platforms and devices, expanding the reach of your app. Widgets, complications, and Live Activities use WidgetKit and a set of related frameworks, including SwiftUI and App Intents, to take up limited but effective, eye-catching space. Because their design, functionality, and code are similar, they’re perfect candidates for code and design component reuse.\n\nTo avoid costly changes in your app’s development process, plan your WidgetKit adoption before you create designs and write code. As you make your plans, take into account:\n\nFeature availability for each platform\n\nFrameworks to use in addition to WidgetKit\n\nRequired appearances and available sizes for widgets, watch complications, and Live Activities\n\nTechnology that powers content updates\n\nAnimation\n\nInteractivity with your app through deep links, buttons, and toggles\n\nConfiguration options for widgets and watch complications\n\nVisibility in Smart Stacks\n\nFunctional constraints\n\nOffer glanceable experiences in various sizes and across platforms\n\nWidgets come in many different sizes, from circular accessory widgets on the Lock Screen and complications on Apple Watch to extra-large widgets on iPad and the Mac. It’s up to you to choose the sizes and complications you want to support, but consider supporting as many sizes and complications as possible.\n\nThis table shows the functionality available for each platform:\n\nWidget size or technology\n\n\t\n\niPhone\n\n\t\n\niPad\n\n\t\n\nApple Watch\n\n\t\n\nMac\n\n\n\n\nSmall system widgets\n\n\t\n\nHome Screen, Today View and in StandBy\n\n\t\n\nHome Screen, Today View, and on the Lock Screen\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nMedium system widgets\n\n\t\n\nHome Screen and Today View\n\n\t\n\nHome Screen and Today View\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nLarge system widgets\n\n\t\n\nHome Screen and Today View\n\n\t\n\nHome Screen and Today View\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nExtra large system widgets\n\n\t\n\nNo\n\n\t\n\nHome Screen and Today View\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nCircular accessory widgets\n\n\t\n\nLock Screen\n\n\t\n\nLock Screen\n\n\t\n\nWatch complications and in the Smart Stack\n\n\t\n\nNo\n\n\n\n\nCorner accessory widgets\n\n\t\n\nNo\n\n\t\n\nNo\n\n\t\n\nWatch complications\n\n\t\n\nNo\n\n\n\n\nRectangular accessory widgets\n\n\t\n\nLock Screen\n\n\t\n\nLock Screen\n\n\t\n\nWatch complications and in the Smart Stack\n\n\t\n\nNo\n\n\n\n\nInline accessory widgets\n\n\t\n\nLock Screen\n\n\t\n\nLock Screen\n\n\t\n\nWatch complications\n\n\t\n\nNo\n\n\n\n\nLive Activities\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nNo\n\nLive Activities are available on iPhone and iPad and appear on the Lock Screen. On devices that support the Dynamic Island, Live Activities appear in the Dynamic Island in compact, minimal, and extended appearances. On devices that don’t support the Dynamic Island, Live Activities appear briefly on the Home Screen, and as an overlay in other apps to notify people of updated data if you choose to alert people about the update.\n\nImportant\n\nYou must support all Live Activity appearances, from minimal and compact presentations to larger extended and Lock Screen presentations.\n\nApproach WidgetKit adoption iteratively. For example, start with a nonconfigurable WidgetFamily.systemSmall widget as described in Creating a widget extension because it gives your content broad exposure in the WidgetKit ecosystem on iPhone, iPad, and the Mac. Then, add support for configuration, additional widget sizes, and — depending on your app’s features — Live Activities or a watchOS app with watch complications.\n\nLeverage additional frameworks\n\nWidgets, watch complications, and Live Activities use a widget extension you add to your Xcode project. The role of WidgetKit is to provide the infrastructure and configuration for the features it enables. Depending on features and platforms you support, you use WidgetKit in combination with other frameworks:\n\nTo create the user interface for each feature, use SwiftUI.\n\nTo add interactivity to widgets and Live Activities, use SwiftUI and the App Intents framework.\n\nTo offer watch complications, create a watchOS app.\n\nTo make widgets configurable, offer preconfigured watch complications, and to enable functionalities like Smart Stacks and Widget Suggestions, use App Intents and SiriKit intents.\n\nTo start, update, and end Live Activities, use ActivityKit.\n\nSupport different appearances\n\nDepending on the context, a widget or Live Activity changes its appearance to best fit its context. For example, a WidgetFamily.systemSmall widget appears as follows:\n\nOn the Home Screen of iPhone and iPad, it takes on the fullColor appearance and appears in Light or Dark Mode.\n\nOn the Lock Screen of iPad and iPhone, it takes on the vibrant appearance that provides a vibrant, blurred appearance. On the Lock Screen of iPhone in StandBy and StandBy in Night Mode, it renders scaled up in size using the vibrant appearance.\n\nOn the Mac, it takes on the fullColor appearance in Notification Center in Light and Dark Mode. On the desktop, the widget appears receded with the vibrant appearance and changes to the fullColor appearance when a person interacts with it.\n\nSimilarly, the WidgetFamily.accessoryRectangular widget appears as follows:\n\nOn the Lock Screen of iPhone and iPad, it takes on the vibrant appearance.\n\nOn Apple Watch, it appears as a watch complication without a background and the accented appearance and in a fullColor appearance in the Smart Stack.\n\nWith each feature you add to your app, make sure your widget, watch complication, or Live Activity supports all applicable contexts and appearances well.\n\nFor more information, see Preparing widgets for additional platforms, contexts, and appearances.\n\nFor design guidance, see Human Interface Guidelines > Widgets.\n\nAnimate content updates\n\nOn devices that run iOS 16, macOS 13, or earlier, widgets don’t use animations. However, Live Activities use the system’s animation timing to animate dynamic content and the addition or removal of views. For example, you can use built-in transitions for content or state changes such as move(edge:).\n\nStarting with iOS 17 and macOS 14, widgets can use animations, and both widgets and Live Activities can use custom animations. For more information, see Animating data updates in widgets and Live Activities.\n\nProvide up-to-date information with a timeline\n\nWidgets and watch complications use a mechanism to update their content that’s different from your app: They use a timeline of data updates that you create in your app and hand to WidgetKit. You maintain this timeline as your app receives new data, but, to optimize battery life for a device, each app has a budget to update its widgets or complications. Additionally, the system batches and schedules updates to preserve power. For more information on how timelines work and how you can keep your widgets and watch complications up to date, see Keeping a widget up to date and Making network requests in a widget extension.\n\nLive Activities don’t use timelines to update their content. Instead, they use ActivityKit and the Apple Push Notification service (APNs) to send ActivityKit push notifications. For more information, see ActivityKit.\n\nAdd specific app functionality to your widgets and Live Activities\n\nBy default, people tap a widget, watch complication, or Live Activity to launch its corresponding app. To make the experience more intuitive and require fewer interactions, you can use deep linking to launch the scene of your app that matches the widget’s visible content. Widgets that offer enough space, such as WidgetFamily.systemSmall or larger — and Live Activities in the extended or the Lock Screen appearance — add SwiftUI’s Link to your views and allow people to open different screens in your app.\n\nNote\n\nIn iOS 16 and macOS 13 or earlier versions, only large and extra-large widgets can use Link.\n\nStarting with iOS 17 and macOS 14, widgets offer direct interaction with your app using the App Intents framework and SwiftUI. Both Button and Toggle offer dedicated initializers for this purpose. For more information, see Adding interactivity to widgets and Live Activities.\n\nOffer configurable widgets and watch complications\n\nMake it possible for people to select the information they want to view in the widget by offering configurable iOS and macOS widgets that provide customizable properties. For example, people could choose to stay informed about a specific stock in a stock market widget, or enter a tracking number for a package delivery widget. Configurable widgets use the App Intents framework and custom intents you define, the same mechanism you use to support system-level services like Siri and the Shortcuts app. For information about creating a configurable widgets, see Making a configurable widget.\n\nOn Apple Watch, offer preconfigured watch complications to people with WidgetKit and the App Intents framework.\n\nIncrease visibility in Smart Stacks\n\nOn iPhone and iPad, people create stacks of widgets, swipe through them manually, and use Smart Rotate to create Smart Stacks. In a Smart Stack, WidgetKit shows the widget at the top of a stack that matches a person’s context. For example, a weather widget could appear on the top of a Smart Stack every time a person leaves their home. To make sure the system shows your widget at the top of a Smart Stack at the right moment, use the App Intents framework.\n\nOn Apple Watch, the Smart Stack displays a list of default widgets and widgets a person adds to it. Like on iPhone and iPad, you use the App Intents framework to make sure people can add your widget to the Smart Stack.\n\nFor more information, see Increasing the visibility of widgets in Smart Stacks.\n\nConsider user privacy\n\nThe Lock Screen and watch faces are always visible, and people can configure widgets and complications to hide sensitive information when the device is locked or supports Always On. Review data that appears on your widget, Live Activity, or complication, and make sure you support redaction of sensitive data.\n\nStore shared data in a group container\n\nTo add widgets, watch complications, and Live Activities, you create a widget extension and add it to your app, and the extension target and your app are part of the same app group. As a result, you can store files and data in a shared container that’s accessible to the app and the widget extension. For example, your app could download data, store it in a database in the shared container, and a widget could access the database.\n\nFor additional information about app groups and accessing a shared container, see Configuring App Groups and Configuring App Groups.\n\nRespect functional constraints\n\nWidgets, watch complications, and Live Activities are always visible. To preserve battery life and user privacy, they follow certain constraints. For example, Live Activities can’t access a person’s location. The following table shows availability features that impact battery life or user privacy for each feature:\n\nFunctionality\n\n\t\n\nWidgets\n\n\t\n\nWatch complications\n\n\t\n\nLive Activities\n\n\n\n\nNetwork access\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nNo\n\n\n\n\nLocation access\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nNo\n\nFor additional information, see Accessing location information in widgets."
  },
  {
    "title": "Creating accessory widgets and watch complications | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/creating-accessory-widgets-and-watch-complications",
    "html": "Overview\n\nWidgetKit allows you to extend the reach of your app to the Lock Screen on iPhone and iPad, and to the Smart Stack on Apple Watch as accessory widgets. Accessory widgets also appear as watch complications on Apple Watch. They display your app’s most relevant, glanceable content in highly visible contexts and let people quickly access your app for more details.\n\nWidgets and watch complications use WidgetKit and SwiftUI views, enabling you to:\n\nUpdate your existing widgets’ code to support accessory widgets.\n\nOffer WidgetKit complications for your watchOS app, replace ClockKit complications, and share more code between your iOS and watchOS apps.\n\nCreate watch complications and Lock Screen widgets simultaneously.\n\nAdd support for iOS or watchOS to your app — in addition to platforms you already support — and offer widgets or complications.\n\nYour path to creating accessory widgets and WidgetKit complications depends on your project. Before you start coding, make sure to review options available to you and carefully plan your software development project. If you’re new to WidgetKit development, see Developing a WidgetKit strategy.\n\nRelated sessions from WWDC22\n\nSession 10050: Complications and widgets: Reloaded and Session 10051: Go further with complications in WidgetKit\n\nRelated sessions from WWDC23\n\nSession 10309:Design widgets for the Smart Stack on Apple Watch and Session 10027: Bring widgets to new places\n\nCreate a new app that offers widgets and watch complications\n\nIf you create a new app, support iOS and watchOS and offer widgets and complications right from the start. This allows you to create a shared code base and reduces the need for costly code changes later in the app development process.\n\nTo get started:\n\nOpen Xcode and create a new project.\n\nChoose the watchOS app template and select Watch App with New Companion iOS App in the “Choose options for your new project” sheet.\n\nAdd a new watchOS widget extension target to your project.\n\nAdd a new iOS widget extension target to your project.\n\nAdd code for your iOS and watchOS apps, and create iOS widgets — including for the Lock Screen — and watchOS complications simultaneously using SwiftUI views and WidgetKit.\n\nTo learn more about creating widgets and building apps with SwiftUI, see Creating a widget extension and SwiftUI. For more information on creating watchOS apps, see watchOS apps.\n\nAdd accessory widgets to your existing iOS App\n\nIf your app supports widgets, adding accessory widgets works like supporting any other widget size. To learn more, see Supporting additional widget sizes.\n\nIf you don’t offer widgets in your app, add a widget extension to your app and support accessory widgets from the start. To learn more about adding a widget extension to your project, see Creating a widget extension.\n\nAdditionally, consider adding support for watchOS with WidgetKit complications by adding a watchOS app target and a watchOS widget extension target. To learn more about creating a watchOS app, see watchOS apps.\n\nAdd WidgetKit complications to your existing watchOS app\n\nIf your existing watchOS app doesn’t offer complications, add a watchOS widget extension to your project in Xcode, and create complications with WidgetKit. Implementing WidgetKit complications works like creating widgets. For more information about creating a widget extension, see Creating a widget extension.\n\nIf your watchOS app offers ClockKit complications, continue to use these to support watchOS 8 and earlier. However, plan to migrate your existing ClockKit complications to WidgetKit as described in Migrating ClockKit complications to WidgetKit.\n\nImportant\n\nAs soon as you offer a widget-based complication, the system stops calling ClockKit APIs. For example, it no longer calls your CLKComplicationDataSource object’s methods to request timeline entries. The system may still wake your data source for migration requests.\n\nAdditionally, consider adding support for iOS by adding an iOS app target to your Xcode project if your watchOS app doesn’t come with an iOS companion app.\n\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nstruct WidgetRenderingMode\nConstants that indicate the rendering mode for a widget."
  },
  {
    "title": "Building Widgets Using WidgetKit and SwiftUI | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/building_widgets_using_widgetkit_and_swiftui",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC20 session 10034: Widgets Code-Along, Part 1: The Adventure Begins; session 10035: Widgets Code-Along, Part 2: Alternate Timelines; and session 10036: Widgets Code-Along, Part 3: Advancing Timelines.\n\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nEmoji Rangers: Supporting Live Activities, interactivity, and animations\nOffer Live Activities, animate data updates, and add interactivity to widgets."
  },
  {
    "title": "Supporting additional widget sizes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/supporting-additional-widget-sizes",
    "html": "Overview\n\nAfter you add a widget extension to your app and create your first widget, add code to declare additional widgets your app supports using the supportedFamilies(_:) property modifier. The sizes you use depend on the devices your app supports. If your app supports more than one platform, make sure to conditionally declare supported widget families.\n\nThe following example from the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project shows how you declare several widgets sizes in your Widget implementation. The app supports accessory widgets in both watchOS and iOS and WidgetFamily.systemSmall and WidgetFamily.systemMedium widgets in iOS. Note the usage of the #if os(watchOS) macro to make sure you declare the correct supported widget families for each platform.\n\npublic var body: some WidgetConfiguration {\n    makeWidgetConfiguration()\n        .configurationDisplayName(\"Ranger Detail\")\n        .description(\"See your favorite ranger.\")\n#if os(watchOS)\n        .supportedFamilies([.accessoryCircular,\n                            .accessoryRectangular, .accessoryInline])\n#else\n        .supportedFamilies([.accessoryCircular,\n                            .accessoryRectangular, .accessoryInline,\n                            .systemSmall, .systemMedium, .systemLarge])\n#endif\n}\n\nUpdate SwiftUI views to support additional sizes\n\nAfter you’ve declared support for additional widget sizes in your Widget, update the views of your widget to support the additional family sizes. In your view code:\n\nUse the widgetFamily environment variable to detect different widget families.\n\nConstruct the view for each size and include code to handle appearances like vibrant and Dark Mode, as applicable. To learn more, see Preparing widgets for additional platforms, contexts, and appearances.\n\nThe following example shows an abbreviated code snippet from the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project. It conditionally returns the right SwiftUI view for each widget family.\n\nstruct EmojiRangerWidgetEntryView: View {\n    var entry: Provider.Entry\n    \n    @Environment(\\.widgetFamily) var family\n\n\n    @ViewBuilder\n    var body: some View {\n        switch family {\n        case .accessoryCircular:\n            // Code to construct the view for the circular accessory widget or watch complication.\n        case .accessoryRectangular:\n            // Code to construct the view for the rectangular accessory widget or watch complication.\n        case .accessoryInline:\n            // Code to construct the view for the inline accessory widget or watch complication.\n        case .systemSmall:\n            // Code to construct the view for the small widget.\n        case .systemLarge:\n            // Code to construct the view for the large widget.\n        case .systemMedium\n            // Code to construct the view for the medium widget.\n        default:\n            // Code to construct the view for other widgets, for example, the extra large widget.\n        }\n    }\n}\n\n\nTip\n\nUse Xcode previews to view your widget designs without running your app in Simulator or on a device. For more information, see Preview widgets in Xcode.\n\nSee Also\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nstruct WidgetRenderingMode\nConstants that indicate the rendering mode for a widget."
  },
  {
    "title": "AppIntentTimelineProvider | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/appintenttimelineprovider",
    "html": "Overview\n\nAn App Intent timeline provider performs the same function as TimelineProvider, but it also incorporates user-configured details into timeline entries.\n\nFor example, in a widget that displays the health status of a game character the user has chosen, the provider receives a custom intent specifying the character to display. In your app code, you then define a custom App Intent. The intent can include the character’s details such as its name, avatar, strategic alliances, and so on.\n\nstruct CharacterConfiguration: WidgetConfigurationIntent {\n    static var title: LocalizedStringResource = \"Character\"\n\n\n    @Parameter(title: \"Name\")\n    var name: String\n\n\n    @Parameter(title: \"Avatar\", default: \"Player 1\")\n    var avatar: String\n\n\n    @Parameter(title: \"Alliances\", default: [])\n    var alliances: [String]\n\n\n    @Parameter(title: \"Health\", default: 100.0)\n    var healthLevel: Double\n}\n\n\nBecause users can add multiple instances of a particular widget, your provider needs a way to differentiate which instance WidgetKit is asking about. When WidgetKit calls snapshot(for:in:) or timeline(for:in:), it passes an instance of your configuration intent, configured with the user-selected details. The game widget provider accesses the properties of the intent and includes them in the TimelineEntry. WidgetKit then invokes the widget configuration’s content closure, passing the timeline entry to allow the views to access the user-configured properties. For example, the provider might implement a TimelineEntry with properties corresponding to those in the custom intent:\n\nstruct CharacterDetailEntry: TimelineEntry {\n    var date: Date\n    var name: String\n    var avatar: String\n    var alliances: [String]\n    var healthLevel: Double\n}\n\n\nTo generate a snapshot, the game widget provider initializes the character detail entry using the properties from the intent.\n\nstruct CharacterDetailProvider: AppIntentTimelineProvider {\n    func snapshot(for configuration: CharacterConfiguration, in context: Context) async -> CharacterDetailEntry {\n        return CharacterDetailEntry(\n            date: Date(),\n            name: configuration.characterName,\n            avatar: configuration.avatar,\n            alliances: configuration.alliances,\n            healthLevel: configuration.healthLevel?.doubleValue\n        )\n    }\n}\n\nTopics\nGenerating timelines\nfunc placeholder(in: Self.Context) -> Self.Entry\nProvides a timeline entry representing a placeholder version of the widget.\n\nRequired\n\nfunc recommendations() -> [AppIntentRecommendation<Self.Intent>]\nReturns a set of intent recommendations you use to offer pre-configured widgets on platforms that don’t offer a dedicated user interface for customizing widget intents.\n\nRequired Default implementation provided.\n\nfunc snapshot(for: Self.Intent, in: Self.Context) async -> Self.Entry\nProvides a timeline entry representing the current time and state of a widget.\n\nRequired\n\nfunc timeline(for: Self.Intent, in: Self.Context) async -> Timeline<Self.Entry>\nProvides an array of timeline entries for the current time and, optionally, any future times to update a widget.\n\nRequired\n\ntypealias Context\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nassociatedtype Entry : TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\n\nRequired\n\nassociatedtype Intent : WidgetConfigurationIntent\nThe intent that contains user-customized values.\n\nRequired\n\nSee Also\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines."
  },
  {
    "title": "Timeline | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/widgetkit/timeline",
    "html": "Overview\n\nTo tell WidgetKit when to update a widget’s view, TimelineProvider generates a timeline. The timeline contains an array of timeline entry objects and a refresh policy.\n\nTo create timeline entries, declare a custom type that conforms to TimelineEntry. Each entry specifies the date you would like WidgetKit to update the widget’s view, and any additional information that your widget needs to render the view. Timeline entries may also include information about their relevance compared to other entries in timelines for the same widget kind. WidgetKit uses this relevance information when considering whether a widget should be promoted in a stack. For more about supplying relevance information, see TimelineEntryRelevance.\n\nThe timeline’s refresh policy specifies the earliest date for WidgetKit to request a new timeline from the provider. The default refresh policy, atEnd, tells WidgetKit to request a new timeline after the last date in the array of timeline entries you provide. However, you can use after(_:) to indicate a different date either earlier or later than the default date. Specify an earlier date if you know there’s a point in time before the end of your timeline entries that may alter the timeline. Conversely, specify a later date if you know that after the last date, your timeline won’t change for some period of time. Alternatively, use never to tell WidgetKit not to request a new timeline at all. In that case, your app uses WidgetCenter to prompt WidgetKit to request a new timeline.\n\nNote\n\nWidgetKit may not update the widget’s view exactly at a timeline entry’s date. The update may occur at a later date.\n\nFor more information about generating timelines, see TimelineProvider.\n\nTopics\nCreating a Timeline\ninit(entries: [EntryType], policy: TimelineReloadPolicy)\nCreates a timeline for when you want WidgetKit to update a widget’s view.\nGetting Timeline Properties\nlet entries: [EntryType]\nAn array of timeline entries.\nlet policy: TimelineReloadPolicy\nThe policy that determines the earliest date and time WidgetKit requests a new timeline from a timeline provider.\nstruct TimelineReloadPolicy\nA type that indicates the earliest date WidgetKit requests a new timeline from the widget’s provider.\nSee Also\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display."
  },
  {
    "title": "WidgetKit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/WidgetKit",
    "html": "Overview\n\nUsing WidgetKit, you can make your app’s content available in contexts outside the app and extend its reach by building an ecosystem of glanceable, up-to-date experiences.\n\nThe ecosystem that WidgetKit enables consists of:\n\nWidgets\n\nWidgets elevate a small amount of timely, personally relevant information from your app, display it where people can see it at a glance, and offer specific app functionality without launching the app. On iPhone and iPad, people put widgets in Today View, on the Home Screen, and on the Lock Screen. On the Mac, people put native Mac app widgets on the desktop and in Notification Center. Starting with iOS 17 and macOS 14, people can also place iPhone widgets on the Mac desktop and in Notification Center. On Apple Watch, widgets appear in the Smart Stack.\n\nSmart Stacks\n\nOn iPhone, people stack widgets and create Smart Stacks. In Smart Stacks, WidgetKit uses on-device intelligence and functionality offered by the App Intents framework for Smart Rotate. Smart Rotate displays the widget at the top of a stack that fits a person’s current context. On Apple Watch, people place widgets in the Smart Stack and can pin them to a fixed position or let the system sort them to best fit a person’s context.\n\nWatch complications\n\nPeople place watch complications on the Apple Watch face to view timely, relevant information when they lift their wrist. Additionally, the Smart Stack on Apple Watch offers space for up to three complications.\n\nLive Activities\n\nLive Activities display up-to-date content from your app such as event and task information on the Lock Screen or in the Dynamic Island. Live Activities use ActivityKit for updates and optionally the Apple Push Notification service (APNs) to send ActivityKit push notifications. For more information, see ActivityKit.\n\nNote\n\nvisionOS doesn’t load WidgetKit extensions found in compatible iPad and iPhone apps.\n\nDevelop glanceable features iteratively\n\nWidgetKit enables features across iPad, iPhone, the Mac, and Apple Watch, but only in a way that best fits a person’s device and personal needs. For example, WidgetKit powers widgets on all platforms in various sizes. It also powers Live Activities, a feature that’s only available on iPhone and iPad.\n\nEven though not every feature that WidgetKit powers is available on every platform or device, widgets, Live Activities, and watch complications share technology and design similarities. This makes it easy to develop features in tandem and to expand usage across contexts.\n\nUse an iterative approach and start with support for one feature or select sizes of widgets — for example, start with a small widget as described in Creating a widget extension, but plan and design additional sizes and features across platforms from the beginning. Then allow people to view your content in as many contexts as possible. For more information, see Developing a WidgetKit strategy.\n\nUnderstand interactivity and personalization\n\nThe WidgetKit ecosystem enables people to view your app content in new contexts and offers specific interactions with your app when and where they need it:\n\nPeople tap a widget, watch complication, or Live Activity to launch the corresponding app or the app’s scene with matching information or functionality. For example, tapping an Emoji Ranger widget or watch complication launches the scene in the app that matches the displayed hero.\n\nStarting with iOS 17, iPadOS 17, and macOS 14, people use buttons and toggles in widgets and Live Activities to interact with your app without launching it. For example, the large widget of the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project includes a button that people tap to give the healing capability of their hero a temporary boost.\n\nIn addition to offering relevant information and specific interactivity at a glance, people use widgets, watch complications, and Live Activities to personalize their devices:\n\nPeople configure widgets and watch complications to display details specific to their needs. For example, a widget of the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project allows people to configure the hero that appears on the widget.\n\nPeople arrange widgets and watch complications in the way that works best for them. When they stack widgets and enable Smart Rotate on iPhone or iPad, WidgetKit automatically rotates the most relevant widget to the top, making sure people see the most important details at the right time. On Apple Watch, the Smart Stack displays default widgets or people place widgets at a fixed position in the Smart Stack.\n\nUpdate content with a timeline\n\nWidgets and watch complications use a special mechanism to update their content: You create a timeline of data updates and hand it to WidgetKit. WidgetKit then makes sure the widget or complication updates its content in an energy-efficient way. For more information on timelines, see Keeping a widget up to date.\n\nLive Activities don’t use timelines to update their content. Instead, they use ActivityKit and the Apple Push Notification service (APNs) to send ActivityKit push notifications. For more information, see ActivityKit.\n\nCreate a focused, glanceable design\n\nWidgets, watch complications, and Live Activities are small and require a focused, glanceable design. For design guidance, see Human Interface Guidelines > Widgets, Human Interface Guidelines > Complications, and Human Interface Guidelines > Live Activities.\n\nTopics\nEssentials\nDeveloping a WidgetKit strategy\nExplore features, tasks, related frameworks, and constraints as you make a plan to implement widgets, watch complications, and Live Activities.\nWidget creation\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nSupporting additional widget sizes\nOffer widgets in additional contexts by adding support for various widget sizes.\nCreating accessory widgets and watch complications\nSupport accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\nMigrating ClockKit complications to WidgetKit\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\nBuilding Widgets Using WidgetKit and SwiftUI\nCreate widgets to show your app’s content on the Home screen, with custom intents for user-customizable settings.\nEmoji Rangers: Supporting Live Activities, interactivity, and animations\nOffer Live Activities, animate data updates, and add interactivity to widgets.\nBackyard Birds: Building an app with SwiftData and widgets\nCreate an app with persistent data, interactive widgets, and an all new in-app purchase experience.\nFruta: Building a Feature-Rich App with SwiftUI\nCreate a shared codebase to build a multiplatform app that offers widgets and an App Clip.\nprotocol Widget\nThe configuration and content of a widget to display on the Home screen or in Notification Center.\nprotocol WidgetBundle\nA container used to expose multiple widgets from a single widget extension.\nstruct StaticConfiguration\nAn object describing the content of a widget that has no user-configurable options.\nenum WidgetFamily\nValues that define the widget’s size and shape.\nstruct WidgetRenderingMode\nConstants that indicate the rendering mode for a widget.\nPresentation\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nPreparing widgets for additional platforms, contexts, and appearances\nCreate widgets that support additional platforms and adapt to their context.\nAdding interactivity to widgets and Live Activities\nInclude buttons or toggles in a widget or Live Activity to offer app functionality without launching the app.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app.\nSwiftUI views for widgets\nPresent your app’s content in widgets with SwiftUI views.\nIntroducing SwiftUI\nSwiftUI is a modern way to declare user interfaces for any Apple platform. Create beautiful, dynamic apps faster than ever before.\nstruct AccessoryWidgetBackground\nAn adaptive background view that provides a standard appearance based on the the widget’s environment.\nstruct WidgetLocation\nValues that indicate different widget locations.\nConfigurable widgets\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nMigrating widgets from SiriKit Intents to App Intents\nConfigure your widgets for backward compatibility.\nstruct AppIntentConfiguration\nAn object describing the content of a widget that uses a custom intent to provide user-configurable options.\nstruct WidgetInfo\nA structure that contains information about user-configured widgets.\nstruct AppIntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nstruct IntentConfiguration\nAn object describing the content of a widget that uses a custom intent definition to provide user-configurable options.\nstruct IntentRecommendation\nAn object that describes a recommended intent configuration for a user-customizable widget.\nTimeline management\nKeeping a widget up to date\nPlan your widget’s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nprotocol TimelineProvider\nA type that advises WidgetKit when to update a widget’s display.\nprotocol IntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nstruct TimelineProviderContext\nAn object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.\nprotocol TimelineEntry\nA type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget’s content.\nstruct Timeline\nAn object that specifies a date for WidgetKit to update a widget’s view.\nclass WidgetCenter\nAn object that contains a list of user-configured widgets and is used for reloading widget timelines.\nprotocol AppIntentTimelineProvider\nA type that advises WidgetKit when to update a user-configurable widget’s display.\nAccessibility\nAdding accessible descriptions to widgets and Live Activities\nDescribe the interface elements of your widgets and Live Activities to help people understand what they represent.\nNetworking\nMaking network requests in a widget extension\nUpdate your widget with new information you fetch with a network request.\nLocation services in widgets\nAccessing location information in widgets\nIncorporate location information into your widget presentation to make it more relevant and contextual.\nNetworking\nMaking network requests in a widget extension\nUpdate your widget with new information you fetch with a network request.\nSmart Stacks\nIncreasing the visibility of widgets in Smart Stacks\nDonate intents and indicate relevance to automatically show your widget in Smart Stacks when it has useful information to display.\nstruct TimelineEntryRelevance\nAn object that describes the relative importance of a timeline entry compared to other entries in the current and past timelines.\nWidget preview and debugging\nDebugging Widgets\nSet environment variables in Xcode to control your widget’s configuration in the debugger.\nstruct WidgetPreviewContext\nA specification for the context of a widget preview.\nPreview macros\nUse Swift macros to create widget previews in Xcode.\nLive Activities\nstruct ActivityConfiguration\nAn object that describes the content of a Live Activity.\nstruct DynamicIsland\nThe layout and configuration for a Live Activity that appears in the Dynamic Island.\nlet NSUserActivityTypeLiveActivity: String\nenum ActivityPreviewViewKind\nValues that represent Live Activity presentations for use in Xcode previews.\nMacros\nmacro Preview<Widget, Provider>(String?, as: WidgetFamily, using: Provider.Intent, widget: () -> Widget, timelineProvider: () -> Provider)\nPreview a widget with an intent configuration, using the specified timeline provider.\nmacro Preview<Widget, Provider>(String?, as: WidgetFamily, using: Provider.Intent, widget: () -> Widget, timelineProvider: () -> Provider)\nPreview a widget with an app intent configuration, using the specified timeline provider."
  }
]