[
    {
        "title": "hash(into:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype/hash(into:)",
        "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
    },
    {
        "title": "!=(_:_:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype/!=(_:_:)",
        "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
    },
    {
        "title": "fileProvider",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype/fileprovider",
        "html": "Discussion\n\nUse file provider notifications to update your File Provider extension\u2019s content from your server. For more information, see Tracking Your File Provider's Changes.\n\nSee Also\nNotification Types\nstatic let complication: PKPushType\nA push type for watchOS complications.\nstatic let voIP: PKPushType\nA push type for Voice-over-IP (VoIP) call invitations."
    },
    {
        "title": "pushRegistry(_:didReceiveIncomingPushWith:for:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistrydelegate/pushregistry(_:didreceiveincomingpushwith:for:)",
        "html": "Deprecated\n\nUse pushRegistry(_:didReceiveIncomingPushWith:for:completion:) instead.\n\nParameters\nregistry\n\nThe PKPushRegistry instance responsible for the delegate callback.\n\npayload\n\nThe push payload sent by a developer via APNS server API.\n\ntype\n\nThis is a PKPushType constant, which is present in [registry desiredPushTypes].\n\nDiscussion\n\nThis method is invoked when a push notification has been received for the specified push type."
    },
    {
        "title": "pushToken(for:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistry/pushtoken(for:)",
        "html": "Parameters\ntype\n\nA push type requested by this push registry object. For a list of possible types, see PKPushType.\n\nReturn Value\n\nThe push token used to send pushes to the device or nil if no token is available for the specified type.\n\nDiscussion\n\nIf registration for a specific push type is successful, the push registry delivers the corresponding push token to its delegate and adds a copy of the token to its local cache. Use this method to retrieve the token at a later time.\n\nSee Also\nManaging the Push Registry\nvar desiredPushTypes: Set<PKPushType>?\nRegisters the push types for this push registry object."
    },
    {
        "title": "desiredPushTypes",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistry/desiredpushtypes",
        "html": "Discussion\n\nWhen you assign a value to this property, the push registry object makes a registration request with the PushKit server. This request is asynchronous, and the success or failure of the request is reported to your registry\u2019s delegate object. For a successful registration, PushKit delivers a push token to the delegate. Use that token to generate push requests from your server.\n\nFor a list of push types that you may include in the set, see PKPushType.\n\nSee Also\nManaging the Push Registry\nfunc pushToken(for: PKPushType) -> Data?\nRetrieves the locally cached push token for the specified push type."
    },
    {
        "title": "pushRegistry(_:didInvalidatePushTokenFor:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistrydelegate/pushregistry(_:didinvalidatepushtokenfor:)",
        "html": "Parameters\nregistry\n\nThe PKPushRegistry instance responsible for the delegate callback.\n\ntype\n\nThis is a PKPushType constant, which is present in [registry desiredPushTypes].\n\nDiscussion\n\nThe system calls this method when a previously provided push token is no longer valid for use. No action is necessary on your part to reregister the push type. Instead, use this method to notify your server not to send push notifications using the matching push token.\n\nSee Also\nResponding to Registration Events\nfunc pushRegistry(PKPushRegistry, didUpdate: PKPushCredentials, for: PKPushType)\nTells the delegate that the system updated the credentials for the specified type of push notification.\n\nRequired"
    },
    {
        "title": "delegate",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistry/delegate",
        "html": "Discussion\n\nYou must assign a valid object to this property before modifying the desiredPushTypes property. A valid delegate object is required to receive push tokens and payload data from incoming pushes.\n\nFor more information about the methods of the PKPushRegistryDelegate protocol, see PKPushRegistryDelegate.\n\nSee Also\nReceiving the Notification Data\nprotocol PKPushRegistryDelegate\nThe methods that you use to handle incoming PushKit notifications and registration events."
    },
    {
        "title": "init(queue:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistry/init(queue:)",
        "html": "Parameters\nqueue\n\nThe dispatch queue on which to execute the delegate methods. It is recommended that you specify a serial queue for this parameter. Specify nil to execute the delegate methods on the app\u2019s main queue.\n\nReturn Value\n\nA PKPushRegistry object that you can use to register for push tokens and use to receive notifications."
    },
    {
        "title": "pushRegistry(_:didUpdate:for:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistrydelegate/pushregistry(_:didupdate:for:)",
        "html": "Required\n\nParameters\nregistry\n\nThe PKPushRegistry instance responsible for the delegate callback.\n\ncredentials\n\nThe push credentials that can be used to send pushes to the device for the specified push type.\n\ntype\n\nOne of the requested notification types. This type is present in the desiredPushTypes property of the push registry.\n\nDiscussion\n\nThe system calls this method when it receives new credentials (including a push token) for the specified push type.\n\nSee Also\nResponding to Registration Events\nfunc pushRegistry(PKPushRegistry, didInvalidatePushTokenFor: PKPushType)\nTells the delegate that the system invalidated the push token for the specified type."
    },
    {
        "title": "token",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushcredentials/token",
        "html": "Discussion\n\nForward this token to the server you use to generate push notifications. When preparing to deliver a push notification to the current device, include the token in the HTTP request you send to Apple Push Notification service (APNs).\n\nSee Also\nGetting the Token\nvar type: PKPushType\nThe push type constant associated with the token."
    },
    {
        "title": "type",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushcredentials/type",
        "html": "Discussion\n\nFor possible values, see PKPushType.\n\nSee Also\nGetting the Token\nvar token: Data\nA unique device token to use when sending push notifications to the current device."
    },
    {
        "title": "Supporting PushKit Notifications in Your App",
        "url": "https://developer.apple.com/documentation/pushkit/supporting-pushkit-notifications-in-your-app",
        "html": "Overview\n\nYou must configure your app to handle PushKit-related notifications, and you must supply a server to generate those notifications. In your app, you tell PushKit what types of push notifications your app handles, and you write code to respond when a notification arrives. You use your server to generate the push notifications that your app receives. When a user initiates a call with your service, your server creates a push notification request for that call and sends it to Apple Push Notification service (APNs), which delivers that notification to the user\u2019s device.\n\nFor information about how to set up a server to generate push notifications, see Setting up a remote notification server.\n\nEnable Push Notification Support for Your App\n\nApps must have the proper entitlements to receive push notifications. To create these entitlements, add the push notifications capability to your Xcode project. When you add this capability, Xcode adds the APS Environment Entitlement to your app and configures your App ID with the push notification service for development purposes.\n\nNote\n\nIf you create an explicit App ID for your app, you can also add the push notification service manually by configuring the App ID from your Developer Account page.\n\nRegister Your App with PushKit at Launch Time\n\nThe system can\u2019t deliver push notifications to your app until you create a PKPushRegistry object and specify the types of notifications you support. Typically, you create this object at launch time and store a reference to it for the duration of your app\u2019s runtime. The following example shows how to create this object and configure it with the Voice-over-IP (VoIP) push type. During configuration, always specify a delegate object to receive notifications.\n\nSwift\nObjective-C\nfunc registerForVoIPPushes() {\n    self.voipRegistry = PKPushRegistry(queue: nil)\n    self.voipRegistry.delegate = self\n    self.voipRegistry.desiredPushTypes = [.voIP]\n}\n\n\nAssigning a value to the desiredPushTypes property begins the registration process, so always update that property last. The server reports the success or failure of the registration process to your delegate object.\n\nSend the Device Token to Your Server\n\nIn order to deliver notifications to a user device, your server must know the address of that device. PushKit provides the address to you in the form of a device token, which is an opaque data object. When you register your app\u2019s supported push types, the PKPushRegistry object creates a PKPushCredentials object and delivers it to your delegate\u2019s pushRegistry(_:didUpdate:for:) method. The credentials object contains the device token for the current device.\n\nUpon receiving a device token, forward it to your server along with any other information you need to identify the user, such as their account unique identifier. To ensure the security of the user\u2019s information, always encrypt the token and all user data before sending it over the network. On your server, store device tokens securely with the user\u2019s other account details. Because users can run your app on multiple devices, be prepared to handle multiple tokens for each notification type your app supports.\n\nFor information about how to set up your server to handle push notifications, see Setting up a remote notification server.\n\nGenerate Push Notifications Using the Device Token\n\nWhen you have data to send to the user, generate an appropriate POST request and send it to APNs. A VoIP service generates a request each time it receives an incoming call for the user. An app with a complication might generate a request whenever it receives urgent updates for that complication.\n\nEach POST request contains a JSON payload with the data you want to send to the user. For most notification types, you may send up to 4 KB (4096 bytes) of data in your payload, but for VoIP notifications, the limit is 5 KB (5120 bytes). Include information in the payload that your app needs to respond. For example, include the new data you want your watchOS complication to display. If you cannot fit all of the data in the payload, your app can open a network connection and fetch any additional data it needs.\n\nFor information about how to construct and send POST requests to APNs, see Sending notification requests to APNs. For specific information on how to configure VoIP push notifications, see Responding to VoIP Notifications from PushKit.\n\nSee Also\nRegistration\nclass PKPushRegistry\nAn object that requests the delivery and handles the receipt of PushKit notifications.\nprotocol PKPushRegistryDelegate\nThe methods that you use to handle incoming PushKit notifications and registration events.\nclass PKPushCredentials\nAn object that encapsulates the device token you use to deliver push notifications to your app."
    },
    {
        "title": "complication",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype/complication",
        "html": "Discussion\n\nUse this type of notification to deliver updated data related for your watchOS app\u2019s complication. The watchOS app\u2019s complication must be active on the user\u2019s current clock face. If it is not, the system does not deliver pushes of this type. For watchOS 6 and later, send the push notification directly to Apple Watch. For watchOS 5 and earlier, you must send it to the iOS companion instead.\n\nThe time your watchOS app spends processing these push notifications counts against the budget allotted to your complication for updating itself. Don\u2019t start any long-running tasks when processing the notification payload. In fact, it is recommended that you include all needed data in the payload so that your app can process that data quickly.\n\nThe system limits you to 50 push notifications per day. If you exceed the limit, subsequent pushes are not delivered.\n\nSee Also\nNotification Types\nstatic let fileProvider: PKPushType\nA push type for file provider updates.\nstatic let voIP: PKPushType\nA push type for Voice-over-IP (VoIP) call invitations."
    },
    {
        "title": "voIP",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype/voip",
        "html": "Discussion\n\nUse this type of notification to initiate live voice calls over the network. Apps receiving VoIP push notifications must report the call quickly to CallKit, so it can alert the user to the presence of the incoming call. For apps linked against the iOS 13 SDK or later, the system terminates your app if you fail to report these notifications to CallKit. If your app repeatedly fails to report VoIP notifications to CallKit, the system stops launching your app for VoIP push notifications.\n\nDon\u2019t use this type of notification for anything other than initiating VoIP calls. If you don\u2019t want to post the CallKit call interface, handle notifications with the User Notifications framework instead of PushKit. When sending encrypted content, use a Notification Service Extension to decrypt that content before displaying it to the user. You can also use a Notification Content Extension to display a custom interface for your app\u2019s notifications. For more information, see Modifying content in newly delivered notifications and Customizing the Appearance of Notifications.\n\nSee Also\nNotification Types\nstatic let complication: PKPushType\nA push type for watchOS complications.\nstatic let fileProvider: PKPushType\nA push type for file provider updates."
    },
    {
        "title": "_SwiftNewtypeWrapper Implementations",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype/_swiftnewtypewrapper-implementations",
        "html": "Topics\nInstance Properties\nvar hashValue: Int\nThe hash value.\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
    },
    {
        "title": "Equatable Implementations",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype/equatable-implementations",
        "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
    },
    {
        "title": "pushRegistry(_:didReceiveIncomingPushWith:for:completion:)",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistrydelegate/pushregistry(_:didreceiveincomingpushwith:for:completion:)",
        "html": "Required\n\nParameters\nregistry\n\nThe PKPushRegistry instance responsible for the delegate callback.\n\npayload\n\nThe push payload sent by a developer via APNs server API.\n\ntype\n\nThis is a PKPushType constant, which is present in [registry desiredPushTypes].\n\ncompletion\n\nThe notification\u2019s completion handler. Execute this block when you finish processing the notification.\n\nDiscussion\n\nConcurrency note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\noptional func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThe system calls this method when it receives a push notification for the specified push type. Use this method to extract data from the notification\u2019s payload and to perform the relevant task for that data. For example, use this method to update the complication data of your watchOS app. When you finish the task, execute the provided completion handler block to let PushKit know you are finished.\n\nWhen linking against the iOS 13 SDK or later, your implementation of this method must report notifications of type voIP to the CallKit framework by calling the reportNewIncomingCall(with:update:completion:) method of your app\u2019s CXProvider object. When you call that method, the system displays the standard incoming call interface to the user unless an error occurs. For example, the system reports an error if the user enabled Do Not Disturb. You may establish a connection to your VoIP server in tandem with notify CallKit.\n\nImportant\n\nOn iOS 13.0 and later, if you fail to report a call to CallKit, the system will terminate your app. Repeatedly failing to report calls may cause the system to stop delivering any more VoIP push notifications to your app. If you want to initiate a VoIP call without using CallKit, register for push notifications using the User Notifications framework instead of PushKit. For more information, see User Notifications."
    },
    {
        "title": "type",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushpayload/type",
        "html": "Discussion\n\nFor possible values, see PKPushType.\n\nSee Also\nPayload Data\nvar dictionaryPayload: [AnyHashable : Any]\nThe contents of the received payload."
    },
    {
        "title": "dictionaryPayload",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushpayload/dictionarypayload",
        "html": "Discussion\n\nFor VoIP pushes, the sender is free to specify any fields for the contained data as long as it is provided in a text-encodable JSON format.\n\nSee Also\nPayload Data\nvar type: PKPushType\nThe type value indicating how to interpret the payload."
    },
    {
        "title": "PKPushRegistry",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistry",
        "html": "Overview\n\nA PKPushRegistry object manages only certain types of notifications, such as high-priority notifications needed by a VoIP app. PushKit wakes up your app as needed to deliver incoming notifications and delivers the notifications directly to the push registry object that requested them.\n\nEvery time your app launches, whether in the foreground or in the background, create a push registry object and configure it. Typically, you keep the push registry object running for the duration of your app. Each push registry object delivers incoming notifications to its delegate object, which also handles the responses for registration requests. Listing 1 shows how to create a push registry object and request VoIP notifications. Always assign an appropriate delegate object before modifying the desiredPushTypes property.\n\nListing 1. Creating and configuring a push registry object\n\nSwift\nObjective-C\nfunc registerForVoIPPushes() {\n    self.voipRegistry = PKPushRegistry(queue: nil)\n    self.voipRegistry.delegate = self\n    self.voipRegistry.desiredPushTypes = [PKPushTypeVoIP]\n}\n\n\nAssigning a new value to the desiredPushTypes property registers the push registry object with the PushKit servers. The server reports the success or failure of your registration attempts asynchronously to the push registry, which then reports those results to its delegate object. The push registry also delivers all received notifications to the delegate object. For more information about the delegate methods, see PKPushRegistryDelegate.\n\nTopics\nInitializing a Push Registry\ninit(queue: dispatch_queue_t?)\nCreates a push registry with the specified dispatch queue.\nReceiving the Notification Data\nvar delegate: (any PKPushRegistryDelegate)?\nThe delegate object that receives notifications coming from the push registry object.\nprotocol PKPushRegistryDelegate\nThe methods that you use to handle incoming PushKit notifications and registration events.\nManaging the Push Registry\nvar desiredPushTypes: Set<PKPushType>?\nRegisters the push types for this push registry object.\nfunc pushToken(for: PKPushType) -> Data?\nRetrieves the locally cached push token for the specified push type.\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSObjectProtocol\nSee Also\nRegistration\nSupporting PushKit Notifications in Your App\nDeclare the types of PushKit notifications your app supports and configure objects to respond to them.\nprotocol PKPushRegistryDelegate\nThe methods that you use to handle incoming PushKit notifications and registration events.\nclass PKPushCredentials\nAn object that encapsulates the device token you use to deliver push notifications to your app."
    },
    {
        "title": "PKPushRegistryDelegate",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushregistrydelegate",
        "html": "Overview\n\nImplement the methods of this protocol in an object of your app and assign that object to the delegate property of your PKPushRegistry object. Use the methods of this protocol to process incoming notifications and to react to token registration and invalidation.\n\nTopics\nResponding to Registration Events\nfunc pushRegistry(PKPushRegistry, didUpdate: PKPushCredentials, for: PKPushType)\nTells the delegate that the system updated the credentials for the specified type of push notification.\n\nRequired\n\nfunc pushRegistry(PKPushRegistry, didInvalidatePushTokenFor: PKPushType)\nTells the delegate that the system invalidated the push token for the specified type.\nHandling an Incoming Notification\nfunc pushRegistry(PKPushRegistry, didReceiveIncomingPushWith: PKPushPayload, for: PKPushType, completion: () -> Void)\nTells the delegate that a remote push notification arrived.\n\nRequired\n\nDeprecated Methods\nfunc pushRegistry(PKPushRegistry, didReceiveIncomingPushWith: PKPushPayload, for: PKPushType)\nNotifies the delegate that a remote push has been received.\nDeprecated\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nRegistration\nSupporting PushKit Notifications in Your App\nDeclare the types of PushKit notifications your app supports and configure objects to respond to them.\nclass PKPushRegistry\nAn object that requests the delivery and handles the receipt of PushKit notifications.\nclass PKPushCredentials\nAn object that encapsulates the device token you use to deliver push notifications to your app."
    },
    {
        "title": "PKPushCredentials",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushcredentials",
        "html": "Overview\n\nWhen registering your app\u2019s push types, PushKit creates a PKPushCredentials object for each type your app supports and delivers it to your delegate\u2019s pushRegistry(_:didUpdate:for:) method. Don\u2019t create PKPushCredentials objects yourself.\n\nTopics\nGetting the Token\nvar token: Data\nA unique device token to use when sending push notifications to the current device.\nvar type: PKPushType\nThe push type constant associated with the token.\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSObjectProtocol\nSee Also\nRegistration\nSupporting PushKit Notifications in Your App\nDeclare the types of PushKit notifications your app supports and configure objects to respond to them.\nclass PKPushRegistry\nAn object that requests the delivery and handles the receipt of PushKit notifications.\nprotocol PKPushRegistryDelegate\nThe methods that you use to handle incoming PushKit notifications and registration events."
    },
    {
        "title": "PKPushType",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushtype",
        "html": "Topics\nNotification Types\nstatic let complication: PKPushType\nA push type for watchOS complications.\nstatic let fileProvider: PKPushType\nA push type for file provider updates.\nstatic let voIP: PKPushType\nA push type for Voice-over-IP (VoIP) call invitations.\nInitializers\ninit(rawValue: String)\nDefault Implementations\nEquatable Implementations\n_SwiftNewtypeWrapper Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nPush Types\nResponding to VoIP Notifications from PushKit\nReceive incoming Voice-over-IP (VoIP) push notifications and use them to display the system call interface to the user."
    },
    {
        "title": "Responding to VoIP Notifications from PushKit",
        "url": "https://developer.apple.com/documentation/pushkit/responding-to-voip-notifications-from-pushkit",
        "html": "Overview\n\nIf your app provides Voice-over-IP (VoIP) phone services, you may use PushKit to handle incoming calls on user devices. PushKit provides an efficient way to manage calls that doesn\u2019t require your app to be running to receive calls. When it detects a call for a specific user, your server sends a push notification to the user\u2019s device with information about that call. Upon receiving the notification, the device wakes up your app and gives it time to notify the user and connect to your call service.\n\nFor apps built using the iOS 13 SDK or later, PushKit requires you to use CallKit when handling VoIP calls. CallKit ensures that apps providing call-related services on a user\u2019s device work seamlessly together on the user\u2019s device, and respect features like Do Not Disturb. CallKit also operates the system\u2019s call-related UIs, including the incoming or outgoing call screens. Use CallKit to present these interfaces and manage interactions with them.\n\nImportant\n\nIf you are unable to support CallKit in your app, you cannot use PushKit to handle push notifications. Instead, configure your app\u2019s push notification support with the User Notifications framework. If you need to do work in response to an incoming notification\u2014for example, to decrypt content\u2014use a notification service extension to perform that work. For more information about handling notifications and implementing a notification service extension, see User Notifications.\n\nFor information about how to configure your app to app to support PushKit, see Supporting PushKit Notifications in Your App.\n\nCreate a Call Provider Object to Manage Calls in Your App\n\nVoIP apps must use CallKit to present the system\u2019s call-related interfaces. You present these interfaces using a CXProvider object, which manages user interactions for both incoming and outgoing calls. Create a provider object early in your app\u2019s life cycle and make it available to your app\u2019s call-related code.\n\nThe following code example shows how to create a provider object and assign a custom delegate to it. Initialize the CXProvider object with a configuration object containing the details about your service. Assign one of your app\u2019s custom objects as a delegate, and use that object to respond to user actions and telephony-related changes.\n\n// Configure the app's CallKit provider object.\nlet config = CXProviderConfiguration(localizedName: \"VoIP Service\")\nconfig.supportsVideo = true\nconfig.supportedHandleTypes = [.phoneNumber]\nconfig.maximumCallsPerCallGroup = 1\n\n\n// Create the provider and attach the custom delegate object\n// used by the app to respond to updates.\ncallProvider = CXProvider(configuration: config)\ncallProvider?.setDelegate(callManager, queue: nil)\n\n\nEach provider object represents a single instance of your app\u2019s phone service and facilitates interactions with the system. Apps need only one provider object to manage phone calls for the current user. If your service allows multiple users or multiple accounts per user, you are responsible for mapping incoming calls to the appropriate user accounts.\n\nGenerate Push Notifications from Your Server\n\nYour servers handle most of the call-related work required to connect users. Each time the user opens your app on a device, create a connection from that app to your server. When the user initiates a phone call, use that connection to communicate the details of the call back to your server. Your server must then try to connect the call initiator with the call recipient. If the recipient\u2019s app is running and has an active connection with the server, communicate directly with the app using your existing connection. If the app is not running, generate a push notification to wake up the app.\n\nEach push notification consists of a device token and a payload with the details of the call. You bundle this information into an HTTP request, which you then send to Apple Push Notification service (APNs). PushKit provides the device token that you use as the target address for the user\u2019s device at configuration time.\n\nWhen configuring the HTTP request for VoIP push notifications, always configure your requests with the following information:\n\nSet the value of the apns-expiration header field to 0, or to only a few seconds. Doing so prevents the system from delivering the notification at a much later time.\n\nInclude information about the incoming call to the JSON payload. For example, include the unique call identifier that your server uses to track the call. Your app can use this identifier to check in with the server later. You might also want to include information about the caller, so that you can display that information in the incoming call UI.\n\nFor information about configuring a custom server to generate push notifications, see Setting up a remote notification server. For information about how to send push notifications, see Sending notification requests to APNs.\n\nRespond to VoIP Push Notifications in Your App\n\nWhen one of your users initiates a phone call, your server must connect to your app on the recipient\u2019s device. If your server doesn\u2019t have an active network connection to the app, you can ask the app to check in by sending it a push notification. Construct the push notification request on your server and send it to APNs for delivery to the user\u2019s device. For VoIP push notifications, the system launches or wakes your app and delivers the notification to your app\u2019s PKPushRegistry object, which calls the pushRegistry(_:didReceiveIncomingPushWith:for:completion:) method of its delegate. Use that method to display the incoming call UI and to establish a connection to your VoIP server.\n\nThe following code example shows how you might process an incoming VoIP push notification in your pushRegistry(_:didReceiveIncomingPushWith:for:completion:) method. After extracting the call data from the notification\u2019s payload dictionary, create a CXCallUpdate object and pass it to the reportNewIncomingCall(with:update:completion:) method of your app\u2019s CXProvider object. While CallKit processes your request, establish a connection to your VoIP server in parallel; you can always notify CallKit later if you run into problems. If CallKit handles the call successfully, the completion block creates some custom data structures to manage that call within the app.\n\nfunc pushRegistry(_ registry: PKPushRegistry, \n          didReceiveIncomingPushWith payload: PKPushPayload, \n          for type: PKPushType, \n          completion: @escaping () -> Void) {\n   if type == .voIP {\n      // Extract the call information from the push notification payload\n      if let handle = payload.dictionaryPayload[\"handle\"] as? String,\n            let uuidString = payload.dictionaryPayload[\"callUUID\"] as? String,\n            let callUUID = UUID(uuidString: uuidString) {\n\n\n         // Configure the call information data structures.\n         let callUpdate = CXCallUpdate()\n         let phoneNumber = CXHandle(type: .phoneNumber, value: handle)\n         callUpdate.remoteHandle = phoneNumber\n                \n         // Report the call to CallKit, and let it display the call UI.\n         callProvider?.reportNewIncomingCall(with: callUUID, \n                     update: callUpdate, completion: { (error) in\n            if error == nil {\n               // If the system allows the call to proceed, make a data record for it.\n               let newCall = VoipCall(callUUID, phoneNumber: phoneNumber)\n               self.callManager.addCall(newCall)\n            }\n\n\n            // Tell PushKit that the notification is handled.\n            completion()\n         })\n                \n         // Asynchronously register with the telephony server and \n         // process the call. Report updates to CallKit as needed.\n         establishConnection(for: callUUID)\n      }\n   }\n}\n\n\n\n\nIf the system allows your call to proceed, the reportNewIncomingCall(with:update:completion:) method executes its completion block and CallKit displays the incoming call interface. At that point, use the delegate of your CXProvider object to respond to user interactions with the interface. For example, use your delegate to respond when the user answers or ends the call.\n\nNote\n\nIf you didn\u2019t put caller information in your notification\u2019s payload, call the reportCall(with:updated:) method of your app\u2019s provider object to update the calling interface. You can call that method at any time to update calls. For example, call it after your app fetches updated caller information from your VoIP server.\n\nFor more information about how to handle user interactions with the call interface, see the methods of CXProviderDelegate.\n\nRespond to Call Hang Ups and Failures\n\nMany things can go wrong when connecting a VoIP call, and CallKit makes it easy to handle problems when they occur.\n\nIf the person who initiated the call hangs up, use the network connection between your app and server to notify the app. In your app, call the reportCall(with:endedAt:reason:) method of its CXProvider object, specifying CXCallEndedReason.remoteEnded as the reason for the end of the call. If the incoming call interface is onscreen, CallKit updates the interface to reflect the end of the call, and dismisses the interface.\n\nIf the recipient of a call answers before the app establishes a connection to your server, don\u2019t fulfill the CXAnswerCallAction object sent to the provider(_:perform:) method of your delegate immediately. Instead, wait until you establish a connection and then fulfill the object. While it waits for your app to fulfill the request, the incoming call interface lets the user know that the call is connecting, but not yet ready.\n\nIf your app fails to establish a connection to your server, call the reportCall(with:endedAt:reason:) method with the CXCallEndedReason.failed option. If the incoming call interface is currently onscreen, the system updates it to indicate a failed call.\n\nAfter sending the initial push notification, don\u2019t send additional push notifications to cancel the call or communicate new details to your app. Instead, communicate with the app directly over the network connection you established between it and your server. Using an existing network connection is generally faster than sending a push notification, and if network conditions are poor, APNs may be unable to deliver push notifications to the device anyway.\n\nSee Also\nPush Types\nstruct PKPushType\nConstants reflecting the push types you want to support."
    },
    {
        "title": "PKPushPayload",
        "url": "https://developer.apple.com/documentation/pushkit/pkpushpayload",
        "html": "Topics\nPayload Data\nvar dictionaryPayload: [AnyHashable : Any]\nThe contents of the received payload.\nvar type: PKPushType\nThe type value indicating how to interpret the payload.\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSObjectProtocol"
    },
    {
        "title": "Exporting delivery metrics logs",
        "url": "https://developer.apple.com/documentation/pushkit/exporting-delivery-metrics-logs",
        "html": "Overview\n\nUse the CloudKit Console to export Apple Push Notification service (APNs) delivery metrics logs for your apps. To download the push notification metrics report, create a data export token, request data from iCloud Web Services, and download the results when the request completes. For more information about CloudKit and CloudKit Console, see Build apps using CloudKit.\n\nThe push-notification metrics report includes aggregated, rounded metrics on notification states as your notifications pass through APNs. It shows multiple notification statuses, such as delivered, stored, and discarded. It also provides insights into various statistics for notifications, including a detailed breakdown based on push type.\n\nNote\n\nIf you have any questions about the data made available in this API, including about how Apple applies privacy measures to protect user privacy and complies with legal obligations, contact Apple through Feedback Assistant by selecting the following option:\n\nDeveloper Tools & Resources > CloudKit Console > Data Export\n\nLearn more about how to use Feedback Assistant.\n\nCreate a data export token\n\nTo access log data for your apps, create a data export token by following these steps:\n\nNavigate to CloudKit Console settings and log in.\n\nClick Tokens.\n\nClick Create Data Export Token.\n\nGive the token a name and an optional description.\n\nChoose the bundle identifier for the app for which you want to download data.\n\nChoose the Delivery Metrics dataset.\n\nSet an expiration date for the token, up to a maximum of six months in the future.\n\nClick Create Data Export Token.\n\nSecurely store the token that you created in step 8.\n\nNote\n\nIf you navigate back to the CloudKit console later, you won\u2019t be able to see the data export token\u2019s value again.\n\nThe token you create is restricted to your developer account, and only gives you access to the APNs data set for the specified app.\n\nCreate a data export request\n\nMake an HTTPS POST request to the data export request endpoint at:\n\nhttps://api.icloud.apple.com/v1/dataExports/apns/teams/{teamId}/appId/{appId}/datasetName/deliverymetrics/request\n\nSubstitute these values:\n\n{teamId}\n\nYour Apple Developer team identifier.\n\n{appId}\n\nYour app\u2019s bundle identifier.\n\nSupply your data export token in the X-Apple-CloudKit-Management-Token header, and provide a JSON object in the body with these fields:\n\nstartDate\n\nThe earliest date for which to include data, in the format yyyy-MM-dd, at most 30 days in the past.\n\nendDate\n\nThe latest date for which to include data, in the format yyyy-MM-dd. This date must be later than startDate, and at least one day in the past.\n\ndataDownloadUrlExpiresInMinutes\n\nThe number of minutes after you receive the download for which the download URL needs to remain valid, between 20 and 60.\n\nThe server responds with a JSON object that contains these fields:\n\nstatusUrl\n\nA URL you use to check the status of your request.\n\nrequestedAt\n\nThe time at which you requested the data export, in ISO8601 format.\n\nExample request\nResponse\ncurl -X POST \\\n-H \"Content-Type: application/json\" \\\n-H \"X-Apple-CloudKit-Management-Token: {data-export-token}\" \\\n-d \\\n'{\n    \"startDate\": \"2024-01-01\",\n    \"endDate\": \"2024-01-26\",\n    \"dataDownloadUrlExpiresInMinutes\": 60\n}' \\\nhttps://api.icloud.apple.com/v1/dataExports/apns/teams/{teamId}/appId/{appId}/datasetName/deliverymetrics/request \n\n\nThe data export request endpoint might return the following HTTP status codes that represent errors:\n\n400\n\nThe request is badly formed.\n\n401\n\nThe data export token is invalid.\n\n500\n\nAn internal error occurred.\n\nYou can request a download that covers the same date range as a previous download. If you make a repeat request within 24 hours, the server returns the same status URL as the original request. If you make a repeat request after 24 hours, the server creates a new request with a new status URL, and any events within the requested time range that are logged after the original request was made are included in the new report.\n\nNote\n\nThe status URLs for all requests are available for 6 months after you make the request. Make sure you use the latest URLs for checking status and downloading reports.\n\nCheck the status of your data export\n\nMake an HTTPS GET request to the status URL, passing your data export token in the X-Apple-CloudKit-Management-Token header. The server responds with a JSON object that contains these fields:\n\nstatus\n\nOne of PROCESSING, FAILED, EXPIRED, or SUCCESS.\n\nrequestedAt\n\nThe time at which you requested the data export, in ISO8601 format.\n\ndownloadDetails\n\nIf the status is PROCESSING, EXPIRED, or FAILED, this key isn\u2019t set. If the status is SUCCESS, it\u2019s a JSON object that contains these fields:\n\ndataURL\n\nThe URL you use to get the exported data.\n\nexpiresAt\n\nThe time at which the data URL expires.\n\nExample Request\nResponse\ncurl -X GET -H \"X-Apple-CloudKit-Management-Token: {data-export-token}\" \\\nhttps://example.com/statusURL\n\n\nThe data export status endpoint might return the following HTTP status codes that represent errors:\n\n400\n\nThe request is badly formed.\n\n404\n\nThe data export token is invalid.\n\n500\n\nAn internal error occurred.\n\nDownload the exported data\n\nMake an HTTPS GET request to URL in the status object\u2019s downloadDetails.dataUrl field to receive a CSV file that contains your exported data:\n\ncurl --compressed -X GET \"https://example.com/download/data.csv\" -o export.csv\n\n\nThe CSV file contains these fields:\n\nPush Type\n\nA string that identifies the type of your push notification\u2019s payload.\n\nStatus\n\nA string that identifies the current state of the push notifications.\n\nDate (UTC)\n\nThe date at which APNs reported the metrics.\n\nCount\n\nAn integer that counts the total number of push notifications of this type in this state.\n\nApple\u2019s servers retain the exported data for six months. To re-download the data, make another GET request to the status URL and download the data from the new download URL."
    },
    {
        "title": "PushKit",
        "url": "https://developer.apple.com/documentation/pushkit",
        "html": "Overview\n\nThe PushKit framework supports specialized notifications for updating your watchOS complications, responding to file provider changes, and receiving incoming Voice-over-IP (VoIP) calls. PushKit notifications differ from the ones you handle with the User Notifications framework. Instead of displaying an alert, badging your app\u2019s icon, or playing a sound, PushKit notifications wake up or launch your app and give it time to respond. Both PushKit and User Notifications use the Apple Push Notification service (APNs) to deliver push notifications to user devices.\n\nTo receive PushKit notifications, your app creates a PKPushRegistry object and uses it to configure the notification types it supports. When registration is successful, PushKit delivers a unique data token to your app that contains the identity of the current device and the push type. Forward that token along to the server, and include it in any notifications you send to the user. APNs uses the token to deliver the correct type of notification to the user\u2019s device.\n\nFor information about how to configure your server to work with APNs, see Setting up a remote notification server.\n\nNote\n\nPushKit doesn\u2019t support some special use cases in which access to Apple Push Notification service (APNs) isn\u2019t possible. For information about when you might need to support these cases, see iOS 10 and the Legacy VoIP Architecture.\n\nTopics\nRegistration\nSupporting PushKit Notifications in Your App\nDeclare the types of PushKit notifications your app supports and configure objects to respond to them.\nclass PKPushRegistry\nAn object that requests the delivery and handles the receipt of PushKit notifications.\nprotocol PKPushRegistryDelegate\nThe methods that you use to handle incoming PushKit notifications and registration events.\nclass PKPushCredentials\nAn object that encapsulates the device token you use to deliver push notifications to your app.\nPush Types\nResponding to VoIP Notifications from PushKit\nReceive incoming Voice-over-IP (VoIP) push notifications and use them to display the system call interface to the user.\nstruct PKPushType\nConstants reflecting the push types you want to support.\nPayload\nclass PKPushPayload\nAn object that contains information about a received PushKit notification.\nData export\nExporting delivery metrics logs\nDownload and analyze push-notification metrics."
    }
]