[
  {
    "title": "Investigating memory access crashes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/investigating-memory-access-crashes",
    "html": "Overview\n\nA crash due to a memory access issue occurs when an app uses memory in an unexpected way. Memory access problems have numerous causes, such as dereferencing a pointer to an invalid memory address, writing to read-only memory, or jumping to an instruction at an invalid address. These crashes are most often identified by the EXC_BAD_ACCESS (SIGSEGV) or EXC_BAD_ACCESS (SIGBUS) exceptions in the crash report:\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000\n\n\nOn macOS, bad memory access crashes are occasionally identified only by a signal, such as SIGSEGV, SEGV_MAPERR, or SEGV_NOOP:\n\nException Type: SIGSEGV\nException Codes: SEGV_MAPERR at 0x41e0af0c5ab8\n\n\nXcode provides several tools that can help identify the source of a memory access issue. Further analysis of each section in the crash report may provide further insight and clues to help you diagnose the problem.\n\nInvestigate the crash with Xcode\n\nOnce you’ve identified that a crash report is for a memory access issue through the exception type, use Xcode to continue your investigation. Xcode contains a suite of debugging tools you can use to identify memory access issues as your app runs. These tools are most effective when your tests execute as many code branches in the app as possible:\n\nAddress Sanitizer\n\nUndefined Behavior Sanitizer\n\nThread Sanitizer\n\nIf your app contains code in Objectice-C, C, or C++, run the static analyzer, and fix all issues it discovers. The static analyzer analyzes your app’s code at build time, and identifies common programming mistakes, including some types of memory management issues. See Analyze your code for potential flaws.\n\nBeyond the exception type in the crash report, other sections of the crash report may contain additional clues that suggest applying additional debugging tools. For example, if a zombie object caused the crash, telltale signs are in the crash report. See Check the crashed thread’s backtrace for clues about the source of the memory access issue for information on the specific clues.\n\nFor difficult to diagnose memory access crashes, the malloc debugging features, such as Guard Malloc, can help. See Enabling the Malloc Debugging Features for information about these tools. You enable these tools through the Xcode scheme editor, as described by Run your app with sanitizers, API checks, and memory management diagnostics.\n\nExamine the exception subtype to determine why access was invalid\n\nThe Exception Subtype field in the crash report contains a kern_return_t value describing the error and the address of the memory that was incorrectly accessed, such as:\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000\n\n\nOn macOS, the Exception Codes field contains the exception subtype:\n\nException Type:        EXC_BAD_ACCESS (SIGBUS)\nException Codes:       KERN_MEMORY_ERROR at 0x00000001098c1000\n\n\nThere are several exception subtypes:\n\nKERN_INVALID_ADDRESS. The crashed thread accessed unmapped memory, either by accessing data or an instruction fetch. Identify the type of memory access that caused the issue describes how to tell the difference.\n\nKERN_PROTECTION_FAILURE. The crashed thread tried to use a valid memory address that’s protected. Some types of protected memory include read-only memory regions, or nonexecutable memory regions. See Use VM Region Info to locate the memory in your app’s address space for how to distinguish the type of protected memory.\n\nKERN_MEMORY_ERROR. The crashed thread tried to access memory that couldn’t return data at that moment, such as a memory-mapped file that became unavailable.\n\nEXC_ARM_DA_ALIGN. The crashed thread tried to access memory that isn’t appropriately aligned. This exception code is rare because 64-bit ARM CPUs work with misaligned data. However, you may see this exception subtype if the memory address is both misaligned and located in an unmapped memory region. You may have other crash reports that show a memory access issue with a different exception subtype, which are likely caused by the same underlying memory access issue.\n\nThe arm64e CPU architecture uses pointer authentication codes with cryptographic signatures to detect and guard against unexpected changes to pointers in memory. A crash due to a possible pointer authentication failure uses the KERN_INVALID_ADDRESS exception subtype with an additional message on the end:\n\nException Type:  EXC_BAD_ACCESS (SIGBUS)\nException Subtype: KERN_INVALID_ADDRESS at 0x00006f126c1a9aa0 -> 0x000000126c1a9aa0 (possible pointer authentication failure)\n\n\nAn invalid memory access, where high-order bits are erroneously set, can look like a pointer authentication failure, even if the cause is due to a memory corruption problem in the app.\n\nSee Preparing your app to work with pointer authentication for more information about pointer authentication.\n\nUse VM Region Info to locate the memory in your app’s address space\n\nThe VM Region Info field of the crash report shows the location of the specific memory that your app incorrectly accessed in relation to other sections of the app’s address space. Consider this example:\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000\nVM Region Info: 0 is not in any region.  Bytes before following region: 4307009536\n      REGION TYPE                      START - END             [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->  \n      __TEXT                 0000000100b7c000-0000000100b84000 [   32K] r-x/r-x SM=COW  ...pp/MyGreatApp\n\n\nHere, a dereference to unmapped memory triggered the crash, at 0x0000000000000000. This is an invalid address, specifically a NULL pointer, so the exception subtype indicates this with the KERN_INVALID_ADDRESS value. The VM Region Info field shows the location of this invalid address is 4,307,009,536 bytes before a valid region of memory in the app’s address space.\n\nConsider a different example, for a KERN_PROTECTION_FAILURE:\n\nException Type:  EXC_BAD_ACCESS (SIGBUS)\nException Subtype: KERN_PROTECTION_FAILURE at 0x000000016c070a30\nVM Region Info: 0x16c070a30 is in 0x16c070000-0x16c074000;  bytes after start: 2608  bytes before end: 13775\n      REGION TYPE                      START - END             [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      Stack                  000000016bfe8000-000000016c070000 [  544K] rw-/rwx SM=COW  thread 12\n--->  STACK GUARD            000000016c070000-000000016c074000 [   16K] ---/rwx SM=NUL  ...for thread 11\n      Stack                  000000016c074000-000000016c0fc000 [  544K] rw-/rwx SM=COW  thread 11\n\n\nIn this example, the dereferenced memory address is 0x000000016c070a30, with the region containing this memory address identified by the arrow. The address is located in a special memory region called the stack guard, which is a memory region that buffers the stack of a thread from the stack of another thread. The PRT column shows the current permission attributes for the memory regions, with r indicating the memory is readable, w indicating the memory is writable, and x indicating the memory is executable.\n\nBecause the stack guard region has no permissions, all memory accesses to this region are invalid, and the crash report is identifying this memory access as a violation of the memory protection attributes. The stack guard is just one example of protected memory—there are others types of protected memory regions, with different combinations of the protection attributes.\n\nSee Interpreting vmmap’s Output for more information on the VM Region Info field.\n\nCheck the crashed thread’s backtrace for clues about the source of the memory access issue\n\nConsult the crashed thread’s backtrace for clues on where the memory access issue is occurring. Some types of memory access issues, such as dereferencing a NULL pointer, are easy to identify when looking at the backtrace and comparing it to the source code. Other memory access issues are identified by the stack frame at the top of the crashed thread’s backtrace:\n\nIf objc_msgSend, objc_retain, or objc_release is at the top of the backtrace, the crash is due to a zombie object. See Investigating crashes for zombie objects.\n\nIf gpus_ReturnNotPermittedKillClient is at the top of the backtrace, the operating system terminated the process because it attempted to do rendering with OpenGL ES while in the background. To resolve a crash with this symbol in the backtrace, migrate your OpenGL ES code to Metal. See Migrating OpenGL Code to Metal.\n\nIn other cases, the cause of a memory access issue isn’t present in the backtrace. Memory corruption occurs when a memory location is unexpectedly modified. After this modification, another part of your app may crash when it tries to use that memory location. The backtrace shows the code accessing the modified memory, but not the code that unexpectedly modified the memory. The unexpected modification may have occurred a long time before the crash, so the source of the issue isn’t visible in the backtrace. If you have numerous crash reports with signs of a memory access issue, but with different backtraces, you may have a memory corruption issue. The information in Investigate the crash with Xcode can help identify the source of the memory corruption.\n\nIdentify the type of memory access that caused the issue\n\nThere are two categories of memory access issues: invalid memory fetches and invalid instruction fetches. An invalid memory fetch occurs when code dereferences an invalid pointer. An invalid instruction fetch occurs when a function jumps to another function through a bad function pointer, or through a function call to an unexpected object. To determine which type of memory access issue caused a crash, focus on the program counter, a register that contains the address of the instruction that caused the memory access exception. On ARM CPU architectures, this is the pc register. On the x86_64 CPU architecture, this is the rip register.\n\nIf the program counter register isn’t the same as the exception address, the crash is due to an invalid memory fetch. For example, consider the following macOS crash report on an x86_64 CPU:\n\nException Type:  SIGSEGV\nException Codes: SEGV_MAPERR at 0x21474feae2c8\n...\nThread 12 crashed with X86-64 Thread State:\n   rip: 0x00007fff61f5739d    rbp: 0x00007000026c72c0    rsp: 0x00007000026c7248    rax: 0xe85e2965c85400b4 \n   rbx: 0x00006000023ee2b0    rcx: 0x00007f9273022990    rdx: 0x00007000026c6d88    rdi: 0x00006000023ee2b0 \n   rsi: 0x00007fff358aae0f     r8: 0x00000000000003ff     r9: 0x00006000023edbc0    r10: 0x000021474feae2b0 \n   r11: 0x00007fff358aae0f    r12: 0x000060000237af10    r13: 0x00007fff61f57380    r14: 0x00006000023ee2b0 \n   r15: 0x0000000000000006 rflags: 0x0000000000010202     cs: 0x000000000000002b     fs: 0x0000000000000000 \n    gs: 0x0000000000000000 \n\n\n\n\nThe program counter register is 0x00007fff61f5739d, which isn’t the same as the exception’s address of 0x21474feae2c8. This crash is due to an invalid memory fetch.\n\nIf the program counter register is the same as the exception address, the crash is due to an invalid instruction fetch. For example, consider the following iOS crash report on an arm64 CPU:\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000040\n...\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   ???                               0x0000000000000040 0 + 64\n...\nThread 0 crashed with ARM Thread State (64-bit):\n    x0: 0x0000000000000002   x1: 0x0000000000000040   x2: 0x0000000000000001   x3: 0x000000016dcfe080\n    x4: 0x0000000000000010   x5: 0x000000016dcfdc8f   x6: 0x000000016dcfdd80   x7: 0x0000000000000000\n    x8: 0x000000010210d3c8   x9: 0x0000000000000000  x10: 0x0000000000000014  x11: 0x0000000102835948\n   x12: 0x0000000000000014  x13: 0x0000000000000000  x14: 0x0000000000000001  x15: 0x0000000000000000\n   x16: 0x000000010210c0b8  x17: 0x00000001021063b0  x18: 0x0000000000000000  x19: 0x0000000102402b80\n   x20: 0x0000000102402b80  x21: 0x0000000204f6b000  x22: 0x00000001f6e6f984  x23: 0x0000000000000001\n   x24: 0x0000000000000001  x25: 0x00000001fc47b690  x26: 0x0000000102304040  x27: 0x0000000204eea000\n   x28: 0x00000001f6e78fae   fp: 0x000000016dcfdec0   lr: 0x00000001021063c4\n    sp: 0x000000016dcfdec0   pc: 0x0000000000000040 cpsr: 0x40000000\n   esr: 0x82000006 (Instruction Abort) Translation fault\n\n\nBinary Images:\n0x102100000 - 0x102107fff MyCoolApp arm64  <87760ecf8573392ca5795f0db63a44e2> /var/containers/Bundle/Application/686CA3F1-6CC5-4F84-8126-EE22D03BC161/MyCoolApp.app/MyCoolApp\n\n\n\n\nIn this example, the program counter register is 0x0000000000000040, which matches the address reported in the Exception Subtype, indicating this crash is due to a bad instruction fetch. Because this is a bad instruction fetch, frame 0 in the backtrace doesn’t contain a running function, as indicated by the ??? and memory address instead of a symbol name in the backtrace. However, the link register, lr, contains the location the code would return to after a function call under normal circumstances. The value in the link register allows you trace the origin of the jump to a bad instruction pointer.\n\nNote\n\nThe x86_64 CPU architecture stores return addresses on the stack, instead of in a link register, so you can’t trace the origin of the bad function pointer on x86_64 CPUs.\n\nThe link register contains 0x00000001021063c4, which is an instruction address in one of the binaries loaded in the app’s process. The Binary Images section of the crash report shows that this address is inside the MyCoolApp binary, because that address is in the range 0x102100000-0x102107fff listed for that binary. With this information, you can use the atos command line tool with the dSYM file for the binary, and identify the corresponding code located at 0x00000001021063c4:\n\n% atos -arch arm64 -o MyCoolApp.app.dSYM/Contents/Resources/DWARF/MyCoolApp -l 0x102100000 0x00000001021063c4\n-[ViewController loadData] (in MyCoolApp) (ViewController.m:38)\n\n\nSymbolicate the crash report with the command line discusses how to use the atos command line tool in more detail.\n\nSee Also\nRelated Documentation\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nMemory access errors\nInvestigating crashes for zombie objects\nIdentify the signature of a zombie and investigate the cause of the crash."
  },
  {
    "title": "Reading an exception message | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reading-an-exception-message",
    "html": "Overview\n\nFrameworks detect common errors associated with using their APIs and raise exceptions when they occur. If your app doesn’t handle those errors, for example by calling NSSetUncaughtExceptionHandler(_:) to install an exception handler, then it crashes. The operating system records a crash report that contains information about the app’s state at the time of the crash.\n\nThe following sections each describe common mistakes in using framework APIs and the exception messages that appear in your app’s crash reports when it encounters these cases. In each case, the exception thread trace in the crash report shows the location in your code where your app crashed. For more information, see Analyzing a crash report.\n\nAddress a crash caused by adding a null object to a collection\n\nFoundation‘s collection classes like NSArray, its mutable subclass NSMutableArray, and CoreFoundation counterparts like CFArray can’t contain nil as a value. Additionally, dictionary collections — NSDictionary, NSMutableDictionary, CFDictionary — can’t contain nil as a key. If your app adds nil to a mutable collection, it crashes, and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil'\n\n\nIf you need to add an object to a Foundation or CoreFoundation collection class that represents a lack of any valid value, use null or kCFNull. Otherwise, test an object’s value before you add it to a collection and don’t add it if the object is nil.\n\nAddress a crash caused by using a null object in APIs that require non-null parameters\n\nMany APIs expect their parameters to be non-nil and throw exceptions if they receive nil. For example, addAttribute(_:value:range:) requires both its name and value to be non-nil. If your app adds a nil attribute to an attributed string, it crashes, and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'NSConcreteMutableAttributedString addAttribute:value:range:: nil value'\n\n\nDetermine an appropriate non-nil value to use instead; otherwise, avoid setting the attribute.\n\nAPIs that require non-nil parameters include nullability designations, and you can add nullability designations to your own methods, blocks, and functions. The compiler detects when you use an object that’s potentially nil in situations where a non-nil object is required, and emits a warning. For more information, see Designating Nullability in Objective-C APIs.\n\nAddress a crash caused by sending an unrecognized selector to a class or object\n\nYou often send messages to Objective-C classes and objects by writing the method name into your source code; for example, you send addAttribute(_:value:range:) by typing [myAttributedString addAttribute:aName value:aValue range:aRange];. There are situations where you construct a method name — also known as a selector — dynamically and send that to the class or object. A common example is setting the name of a controller method as an action in a storyboard file. If the object or class receiving the message doesn’t respond to the selector and can’t forward it to another object, your app crashes and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFBoolean insertObject:atIndex:]: unrecognized selector sent to instance 0x1e75db6c0'\n\n\nCheck that the method selector is spelled correctly, including colons to indicate each of the arguments. Verify that the class of the receiving object implements the requested method or forwards it to an object that implements it.\n\nAddress a crash caused by inserting, replacing, or deleting an object in an immutable collection or sequence\n\nEach of the common Foundation collections has an immutable class, for example, NSArray, and a corresponding mutable subclass, for example, NSMutableArray. These Objective-C classes are interchangeable with the corresponding CoreFoundation types CFArray and CFMutableArray. It’s an error to try to change the contents of an immutable collection, for example, by appending an object. If your app tries to change the contents of an immutable collection, it crashes and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'\n\n\nIf you need to modify a collection that you share with other code, the source of the original collection needs to initialize a mutable collection. If you need to make changes to a local copy of the original collection, which remains immutable, use -mutableCopy to create a local, mutable version. Otherwise, remove the code that modifies the collection.\n\nNote\n\nA common cause of this exception is incorrectly interchanging Foundation and CoreFoundation collection classes, for example, casting a CFArrayRef to Objective-C using (__bridge NSMutableArray *). When you use toll-free bridging to interchange Foundation and CoreFoundation collection classes, ensure that the bridged types of Objective-C variables match the types of their CoreFoundation counterparts, including their mutability.\n\nAddress a crash caused by using an index, range, or position that’s out of bounds\n\nAPIs that take a parameter indicating the position of an object or other data in an ordered collection or a sequence raise an exception if that position is outside the containing collection. APIs that take a parameter indicating a range of values in a sequence raise an exception if either the start or end of the range is outside the containing collection.\n\nNote\n\nThe special value NSNotFound isn’t meant to be used as a position in a collection or sequence and will cause an out-of-range exception if you use it this way in your code.\n\nIf your app tries to access the content of a collection or sequence outside of its range, it crashes and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayM objectAtIndex:]: index 12 beyond bounds [0 .. 0]'\n\n\nIn the special case of requesting an object at a particular index in an empty array, the exception message is similar to this example:\n\n*** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArray0 objectAtIndex:]: index 12 beyond bounds for empty array'\n\n\nCheck that your app is using an up-to-date value for the collection’s size, and that the code that calculates the position or range is correct.\n\nAddress a crash caused by requesting a range that overflows the integer type\n\nThe NSRange structure uses the same type (NSUInteger) for both its location and its length, which is also the type that collection classes use to represent indexes into the collection. It’s possible to create a range where the end of the range is beyond the values that can be represented as indexes into the collection that’s using the range. When a collection or sequence detects this case, your app crashes and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[NSConcreteMutableData subdataWithRange:]: range {20, 18446744073709551605} causes integer overflow'\n\n\nCheck that your app is using an up-to-date value for the collection’s size, and that the code that calculates the range is correct.\n\nAddress a crash caused by incorrectly initializing a dictionary\n\nWhen you initialize an NSDictionary or NSMutableDictionary using the initializer method init(objects:forKeys:), you have to supply an equal number of keys and objects. If you supply arrays with different lengths, your app crashes and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[NSDictionary initWithObjects:forKeys:]: count of objects (1) differs from count of keys (2)'\n\n\nCheck your code to determine which array you pass — the keys or the objects — is incorrect.\n\nAddress a crash caused by attempting to encode or decode an object that isn’t codable\n\nTo serialize or deserialize an object using NSCoder, whether to store it in a file, or send it to another process or over the network, the object must conform to NSCoding. If your app attempts to encode or decode an object that doesn’t conform to NSCoding, it crashes and an exception message like this example is included in the crash report:\n\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[MyClass encodeWithCoder:]: unrecognized selector sent to instance 0x600002090040'\n\n\nReplace the object with one that conforms to NSCoding, or add NSCoding conformance to the object’s class or to a category on that class.\n\nNote\n\nWhile collection classes such as NSArray and NSDictionary are codable, each object in the collection must also conform to NSCoding for a collection to encode itself correctly.\n\nSee Also\nRuntime errors\nAddressing crashes from Swift runtime errors\nIdentify the signs of a Swift runtime error, and address the crashes runtime errors cause.\nAddressing language exception crashes\nIdentify the signs of a language exception, and address the crashes caused by uncaught language exceptions."
  },
  {
    "title": "Writing ARM64 code for Apple platforms | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/writing-arm64-code-for-apple-platforms",
    "html": "Overview\n\nThe ARM architecture defines rules for how to call functions, manage the stack, and perform other operations. If part of your code includes ARM assembly instructions, you must adhere to these rules in order for your code to interoperate correctly with compiler-generated code. Similarly, if you write a compiler, the machine instructions you generate must adhere to these rules. If you don’t adhere to them, your code may behave unexpectedly or even crash.\n\nApple platforms diverge from the standard 64-bit ARM architecture in a few specific ways. Apart from these small differences, iOS, tvOS, and macOS adhere to the rest of the 64-bit ARM specification. For information about the ARM64 specification, including the Procedure Call Standard for the ARM 64-bit Architecture (AArch64), go to https://developer.arm.com.\n\nRespect the purpose of specific CPU registers\n\nThe ARM standard delegates certain decisions to platform designers. Apple platforms adhere to the following choices:\n\nThe platforms reserve register x18. Don’t use this register.\n\nThe frame pointer register (x29) must always address a valid frame record. Some functions — such as leaf functions or tail calls — may opt not to create an entry in this list. As a result, stack traces are always meaningful, even without debug information.\n\nHandle data types and data alignment properly\n\nSome fundamental types of the C language have slightly different implementations:\n\nThe wchar_t type is 32 bit and is a signed type.\n\nThe char type is a signed type.\n\nThe long type is 64 bit.\n\nThe __fp16 type uses the IEEE754-2008 format, where applicable.\n\nThe long double type is a double precision IEEE754 binary floating-point type, which makes it identical to the double type. This behavior contrasts to the standard specification, in which a long double is a quad-precision, IEEE754 binary, floating-point type.\n\nThe following table lists the integer data types, their sizes, and their natural alignments on Apple platforms.\n\nData type\n\n\t\n\nSize (in bytes)\n\n\t\n\nNatural alignment (in bytes)\n\n\n\n\nBOOL, bool\n\n\t\n\n1\n\n\t\n\n1\n\n\n\n\nchar\n\n\t\n\n1\n\n\t\n\n1\n\n\n\n\nshort\n\n\t\n\n2\n\n\t\n\n2\n\n\n\n\nint\n\n\t\n\n4\n\n\t\n\n4\n\n\n\n\nlong\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nlong long\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\npointer\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nsize_t\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nNSInteger\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nCFIndex\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nfpos_t\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\noff_t\n\n\t\n\n8\n\n\t\n\n8\n\nRespect the stack’s red zone\n\nThe ARM64 red zone consists of the 128 bytes immediately below the stack pointer. Apple platforms don’t modify these bytes during exceptions. User-mode programs can rely on the bytes below the stack pointer to not change unexpectedly, and can potentially make use of the space for local variables.\n\nNote\n\nIf a function calls itself, the caller must assume that the callee modifies the contents of its red zone. The caller must therefore create a proper stack frame.\n\nPass arguments to functions correctly\n\nThe stack pointer on Apple platforms follows the ARM64 standard ABI and requires 16-byte alignment. When passing arguments to functions, Apple platforms diverge from the ARM64 standard ABI in the following ways:\n\nFunction arguments may consume slots on the stack that are not multiples of 8 bytes. If the total number of bytes for stack-based arguments is not a multiple of 8 bytes, insert padding on the stack to maintain the 8-byte alignment requirements.\n\nWhen passing an argument with 16-byte alignment in integer registers, Apple platforms allow the argument to start in an odd-numbered xN register. The standard ABI requires it to begin in an even-numbered xN register.\n\nThe caller of a function is responsible for signing or zero-extending any argument with fewer than 32 bits. The standard ABI expects the callee to sign or zero-extend those arguments.\n\nFunctions may ignore parameters that contain empty struct types. This behavior applies to the GNU extension in C and, where permitted by the language, in C++. The AArch64 documentation doesn’t address the issue of empty structures as parameters, but Apple chose this path for its implementation.\n\nThe following example illustrates how Apple platforms specify stack-based arguments that are not multiples of 8 bytes. On entry to the function, s0 occupies one byte at the current stack pointer (sp), and s1 occupies one byte at sp+1. The compiler still adds padding after s1 to satisfy the stack’s 16-byte alignment requirements.\n\nvoid two_stack_args(char w0, char w1, char w2, char w3, char w4, char w5, char w6, char w7, char s0, char s1) {}\n\n\nThe following example shows a function whose second argument requires 16-byte alignment. The standard ABI requires placing the second argument in the x2 and x3 registers, but Apple platforms allow it to be in the x1 and x2 registers.\n\nvoid large_type(int x0, __int128 x1_x2) {} \n\nUpdate code that passes arguments to variadic functions\n\nFor functions that contain a variable number of parameters, Apple initializes the relevant registers (Stage A) and determines how to pad or extend arguments (Stage B) as usual. When it’s time to assign arguments to registers and stack slots, Apple platforms use the following rules for each variadic argument:\n\nRound up the Next SIMD and Floating-point Register Number (NSRN) to the next multiple of 8 bytes.\n\nAssign the variadic argument to the appropriate number of 8-byte stack slots.\n\nBecause of these changes, the type va_list is an alias for char*, and not for the struct type in the generic procedure call standard. The type also isn’t in the std namespace when compiling C++ code.\n\nNote\n\nThe C language requires the promotion of arguments smaller than int before a call. Beyond that, the Apple platforms ABI doesn’t add unused bytes to the stack.\n\nHandle C++ differences\n\nThe generic ARM64 C++ ABI mirrors the Itanium C++ ABI, which many UNIX-like systems use. Apple’s C++ ABI differs from this ABI in the following ways:\n\nThe mangled name of the va_list type is Pc, and not St9__va_list. This difference occurs because va_list is an alias for char *, and uses the same name-mangling conventions.\n\nThe mangled names for NEON vector types match their 32-bit ARM counterparts, rather than using the 64-bit scheme. For example, Apple platforms use 17__simd128_int32_t instead of the generic 11_int32x4_t.\n\nWhen passing parameters to a function, Apple platforms ignore empty structures unless those structures have a nontrivial destructor or copy constructor. When passing such nontrivial structures, treat them as aggregates with one byte member in the generic manner.\n\nThe ABI requires the complete object (C1) and base-object (C2) constructors to return this to their callers. Similarly, the complete object (D1) and base-object (D2) destructors return this. This behavior matches the ARM 32-bit C++ ABI.\n\nThe ABI provides a fixed layout of two size_t words for array cookies, with no extra alignment requirements. This behavior matches the ARM 32-bit C++ ABI.\n\nObject initialization guards are nominally uint64_t, rather than int64_t. This behavior affects the prototypes of functions __cxa_guard_acquire, __cxa_guard_release, and __cxa_guard_abort.\n\nA pointer to a function declared as extern “C” isn’t interchangeable with a function declared as extern “c++”. This behavior differs from the ARM64 ABI, in which the functions are interchangeable.\n\nFor more information about the generic ARM64 C++ ABI, see “C++ Application Binary Interface Standard for the ARM 64-bit architecture” at developer.arm.com."
  },
  {
    "title": "Swift access races | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/swift-access-races",
    "html": "Overview\n\nUse this check to detect when multiple threads call a mutating method on a structure, or when they pass a reference to a shared variable without synchronization, which can result in unpredictable behavior. Available in Xcode 9 and later.\n\nAccess race with mutating structure methods\n\nIn the following example, the producer() function adds messages to a global array, and the consumer() function removes messages from the array and prints them. Because producer() executes on one thread and consumer() executes on another, and both call mutating methods on the array, there is an access race on messages.\n\nvar messages: [String] = []\n// Executed on Thread #1\nfunc producer() {\n    messages.append(\"A message\");\n}\n// Executed on Thread #2\nfunc consumer() {\n    repeat {\n        let message = messages.remove(at: 0)\n        print(\"\\(message)\")\n    } while !messages.isEmpty\n}\n\nSolution\n\nUse Dispatch APIs to coordinate access to messages across multiple threads.\n\nAccess race with in-out parameters\n\nIn the following example, the writeNumbers() function writes numbers to a global string. The writeLetters() function writes letters to the same string. Because the two functions execute on different threads and both access log by reference using inout, there is an access race on log.\n\nvar log: String = \"\"\n// Executed on Thread #1\nfunc writeNumbers() {\n    print(1, 2, 3, separator: \",\", to: &log)\n}\n// Executed on Thread #2\nfunc writeLetters() {\n    print(\"a\", \"b\", \"c\", separator:\",\", to: &log)\n}\n\nSolution\n\nUse Dispatch APIs to coordinate access to log across multiple threads.\n\nSee Also\nThread Sanitizer\nData races\nDetects unsynchronized access to mutable state across multiple threads.\nRaces on collections and other APIs\nDetects when one thread accesses a mutable object while another thread is writing to it.\nUninitialized mutexes\nDetects when you use an uninitialized mutex.\nThread leaks\nDetects when you don’t close threads after use."
  },
  {
    "title": "Overflow and underflow of buffers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/overflow-and-underflow-of-buffers",
    "html": "Overview\n\nIn Xcode 7 and later, you can use this check to detect when you access memory that’s outside of a buffer’s boundaries. The check reports overflow when accessed memory is beyond the end of the buffer, and underflow when the accessed memory is before the beginning of a buffer. Xcode sanitizes heap and stack buffers, as well as global variables. Buffer overflow and underflow can result in a crash or other unpredictable behavior.\n\nGlobal, heap, and stack overflows in C\n\nIn the following example, the global_array, heap_buffer, and stack_buffer variables each have valid indexes in the range [0, 9], but the accessed index is 10, which causes an overflow:\n\nint global_array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nvoid foo() {\n    int idx = 10;\n    global_array[idx] = 42; // Error: out of bounds access of global variable\n    char *heap_buffer = malloc(10);\n    heap_buffer[idx] = 'x'; // Error: out of bounds access of heap allocated variable\n    char stack_buffer[10];\n    stack_buffer[idx] = 'x'; // Error: out of bounds access of stack allocated variable\n}\n\nSolution\n\nAdd a bounds check before attempting to access a buffer at a specific index.\n\nSee Also\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds."
  },
  {
    "title": "Diagnosing memory, thread, and crash issues early | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/diagnosing-memory-thread-and-crash-issues-early",
    "html": "Overview\n\nIdentifying potential issues during development saves testing time later and improves the stability of your code. Xcode provides several runtime tools to identify potential issues in your code:\n\nAddress Sanitizer—The ASan tool identifies potential memory-related corruption issues.\n\nThread Sanitizer—The TSan tool detects race conditions between threads.\n\nMain Thread Checker—This tool verifies that system APIs that must run on the main thread actually do run on that thread.\n\nUndefined Behavior Sanitizer—The UBSan tool detects divide-by-zero errors, attempts to access memory using a misaligned pointer, and other undefined behaviors.\n\nThese are LLVM-based tools that add specific checks to your code. You enable them at build time using the Xcode scheme editor. Select the appropriate scheme for your project and choose Product > Scheme > Edit Scheme to display the scheme editor. Select the Run or Test schemes, navigate to the Diagnostics section, and select the sanitizers you want to run.\n\nNote\n\nThe sanitizer tools support all C-based languages. The tools also support the Swift language, with the exception of the Undefined Behavior Sanitizer tool, which supports only C-based languages.\n\nUsing the sanitizer tools is just one way to catch certain types of issues. Always test your code using a comprehensive set of unit tests, and use additional integration and UI tests to exercise your code at runtime. For more information about testing your code, see Testing your apps in Xcode.\n\nLocate memory corruption issues in your code\n\nAccessing memory improperly can introduce unexpected issues into your code, and even pose a security threat. The Address Sanitizer tool detects memory-access attempts that don’t belong to an allocated block. To enable this tool, select Address Sanitizer from the Diagnostics section of the appropriate scheme.\n\nTo enable ASan from the command line, use the following flags:\n\n-fsanitize=address (clang)\n\n-sanitize=address (swiftc)\n\n-enableAddressSanitizer YES (xcodebuild)\n\nThe Address Sanitizer tool replaces the malloc(_:) and free(_:) functions with custom implementations. The custom malloc(_:) function surrounds a requested memory block with special off-limits regions, and reports attempts to access those regions. The free(_:) function places a deallocated block into a special quarantine queue, and reports attempts to access that quarantined memory.\n\nImportant\n\nAddress Sanitizer doesn’t detect memory leaks, attempts to access uninitialized memory, or integer overflow errors. Use Instruments and the other sanitizer tools to find additional errors.\n\nFor most use cases, the overhead that Address Sanitizer adds to your code should be acceptable for daily development. Running your code with Address Sanitizer increases memory usage by two to three times, and also adds 2x to 5x slowdown of your code. To improve your code’s memory usage, compile your code with the -O1 optimization.\n\nDetect data races among your app’s threads\n\nRace conditions occur when multiple threads access the same memory without proper synchronization. Race conditions are difficult to detect during regular testing because they don’t occur consistently. However, fixing them is important because they cause your code to behave unpredictably, and may even lead to memory corruption.\n\nTo detect race conditions and other thread-related issues, enable the Thread Sanitizer tool from the Diagnostics section of the appropriate build scheme.\n\nTo enable TSan from the command line, use the following flags:\n\n-fsanitize=thread (clang)\n\n-santize=thread (swiftc)\n\n-enableThreadSanitizer YES (xcodebuild)\n\nThe Thread Sanitizer tool inserts diagnostics into your code to record each memory read or write operation. These diagnostics generate a timestamp for each operation, as well as its location in memory. The tool then reports any operations that occur at the same location at approximately the same time. The tool also detects other thread-related bugs, such as uninitialized mutexes and thread leaks.\n\nImportant\n\nYou can’t use Thread Sanitizer to diagnose iOS, tvOS, and watchOS apps running on a device. Use Thread Sanitizer only on your 64-bit macOS app, or to diagnose your 64-bit iOS, tvOS, or watchOS app running in Simulator.\n\nBecause Thread Sanitizer inserts diagnostics into your code, it increases memory usage by five to ten times. Running your code with these diagnostics also introduces a 2x to 20x slowdown of your app. To improve your code’s memory usage, compile your code with the -O1 optimization.\n\nDetect improper UI updates on background threads\n\nSome system frameworks contain APIs that you must only call from your app’s main thread. This requirement applies to most of the AppKit and UIKit user interface APIs, and also applies to some other system APIs. Calling these APIs from the main thread prevents race conditions by serializing the execution of the associated tasks. Failure to perform these operations on the main thread may result in visual defects, data corruption, or crashes.\n\nThe Main Thread Checker tool ensures that all calls that must occur on the main thread do so. To enable this tool, select Main Thread Checker from the Diagnostics section of the appropriate scheme.\n\nThe Main Thread Checker tool dynamically replaces system methods that must execute on the main thread with variants that check the current thread. The tool replaces only system APIs with well-known thread requirements, and doesn’t replace all system APIs. Because the replacements occur in system frameworks, Main Thread Checker doesn’t require you to recompile your app.\n\nNote\n\nBecause Main Thread Checker doesn’t require you to recompile your code, you can run it on an existing macOS binary. Inject the dynamic library located at /Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib into your executable.\n\nTo fix problems identified by Main Thread Checker, dispatch calls to your app’s main thread. The most common place where main thread errors occur is completion handler blocks. The following code wraps the text label modification with an asynchronous dispatch call to the main thread.\n\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n   if let data = data {\n      // Redirect to the main thread.\n      DispatchQueue.main.async {\n         self.label.text = \"\\(data.count) bytes downloaded\"\n      }\n   }\n}\ntask.resume()\n\n\n\n\nThe performance impact of Main Thread Checker is minimal. The tool adds 1–2% CPU overhead to your process, and increases process launch time by no more than 100 milliseconds. Because of this minimal impact, Xcode enables Main Thread Checker by default for your development-related schemes.\n\nDetect operations with undefined semantics\n\nCode that results in undefined behavior can lead to crashes or incorrect output. In some cases, the code may not result in any problems at all initially, making it even harder to diagnose the problem later when conditions are different. The Undefined Behavior Sanitizer tool checks C-based code for a variety of common runtime errors, including:\n\nAttempts to divide by zero\n\nAttempts to load memory from a misaligned pointer\n\nAttempts to dereference a NULL pointer\n\nMath operations that result in integer overflow\n\nTo enable this tool, select Undefined Behavior Sanitizer from the Diagnostics section of the appropriate scheme.\n\nTo enable UBSan from the command line, add the -fsanitize=undefined option in clang or the enableUndefinedBehaviorSanitizer YES option in xcodebuild. To enable individual sanitizer checks, use the following options:\n\nCompiler flag\n\n\t\n\nUBSan check\n\n\n\n\n-fsanitize=alignment\n\n\t\n\nMisaligned pointer\n\n\n\n\n-fsanitize=bool\n\n\t\n\nInvalid Boolean value\n\n\n\n\n-fsanitize=bounds\n\n\t\n\nOut-of-bounds array access\n\n\n\n\n-fsanitize=enum\n\n\t\n\nInvalid enumeration value\n\n\n\n\n-fsanitize=vptr\n\n\t\n\nDynamic type violation\n\n\n\n\n-fsanitize=integer-divide-by-zero\n\n\t\n\nDivision by zero\n\n\n\n\n-fsanitize=float-divide-by-zero\n\n\t\n\nDivision by zero\n\n\n\n\n-fsanitize=float-cast-overflow\n\n\t\n\nInvalid float cast\n\n\n\n\n-fsanitize=nonnull-attribute\n\n\t\n\nNonnull argument violation\n\n\n\n\n-fsanitize=nullability-arg\n\n\t\n\nNonnull argument violation\n\n\n\n\n-fsanitize=nullability-assign\n\n\t\n\nNonnull variable assignment violation\n\n\n\n\n-fsanitize=returns-nonnull-attribute\n\n\t\n\nNonnull return value violation\n\n\n\n\n-fsanitize-nullability-return\n\n\t\n\nNonnull return value violation\n\n\n\n\n-fsanitize=null\n\n\t\n\nNull reference creation and null pointer dereference\n\n\n\n\n-fsanitize=object-size\n\n\t\n\nInvalid object size\n\n\n\n\n-fsanitize=shift\n\n\t\n\nInvalid shift\n\n\n\n\n-fsanitize=signed-integer-overflow\n\n\t\n\nInteger overflow\n\n\n\n\n-fsanitize=unreachable\n\n\t\n\nReaching of unreachable point\n\n\n\n\n-fsanitize=vla-bound\n\n\t\n\nInvalid variable-length array\n\nThe Undefined Behavior Sanitizer tool inserts diagnostics into your code at compile time. The nature of these checks differs according to the type of operation. For example, before performing a mathematical operation on an integer value, the tool adds a check to determine if the operation triggers an integer overflow.\n\nThe performance impact of Undefined Behavior Sanitizer is minimal. The tool adds an average of 20% CPU overhead to the debug version of your app.\n\nTopics\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds.\nThread Sanitizer\nData races\nDetects unsynchronized access to mutable state across multiple threads.\nSwift access races\nDetects unsynchronized access to mutable state across multiple threads in Swift.\nRaces on collections and other APIs\nDetects when one thread accesses a mutable object while another thread is writing to it.\nUninitialized mutexes\nDetects when you use an uninitialized mutex.\nThread leaks\nDetects when you don’t close threads after use.\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds.\nSee Also\nDebugging strategies\nDiagnosing issues in the appearance of a running app\nInspect your running app to investigate issues in the appearance and placement of the content it displays.\nDetecting when your app contacts domains that may be profiling users\nUse Instruments to assess whether your app or its third-party SDKs connect to domains that may profile users."
  },
  {
    "title": "Addressing crashes from Swift runtime errors | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/addressing-crashes-from-swift-runtime-errors",
    "html": "Overview\n\nSwift uses memory safety techniques to catch programming mistakes early. Optionals require you to think about how best to handle a nil value. Type safety prevents casting an object to a type that doesn’t match the object’s actual type.\n\nIf you use the ! operator to force unwrap an optional value that’s nil, or if you force a type downcast that fails with the as! operator, the Swift runtime catches these errors and intentionally crashes the app. If you can reproduce the runtime error, Xcode logs information about the issue to the console. On ARM processors, the exception info in the crash report looks like:\n\nException Type:  EXC_BREAKPOINT (SIGTRAP)\n...\nTermination Signal: Trace/BPT trap: 5\nTermination Reason: Namespace SIGNAL, Code 0x5\n\n\nOn Intel processors (including apps for macOS, Mac Catalyst, and the simulators for iOS, watchOS and tvOS), the exception info in the crash report looks like:\n\nException Type:        EXC_BAD_INSTRUCTION (SIGILL)\n...\nException Note:        EXC_CORPSE_NOTIFY\n\n\nTermination Signal:    Illegal instruction: 4\nTermination Reason:    Namespace SIGNAL, Code 0x4\n\nIdentify the location of the error\n\nThe crash report shows the thread that encountered the runtime error, with a frame in the backtrace identifying the specific line of code.\n\nThread 0 Crashed:\n0   MyCoolApp                         0x0000000100a71a88 @objc ViewController.viewDidLoad() (in MyCoolApp) (ViewController.swift:18)\n1   MyCoolApp                         0x0000000100a71a40 @objc ViewController.viewDidLoad() (in MyCoolApp) (ViewController.swift:18)\n2   UIKitCore                         0x00000001c569e920 -[UIViewController _sendViewDidLoadWithAppearanceProxyObjectTaggingEnabled] + 100\n3   UIKitCore                         0x00000001c56a3430 -[UIViewController loadViewIfRequired] + 936\n4   UIKitCore                         0x00000001c56a3838 -[UIViewController view] + 28\n\n\nIn this example, thread 0 encountered the error. Frame 0 of this thread shows that the runtime error occurs on line 18 of ViewController.swift, in the viewDidLoad method:\n\n0   MyCoolApp                         0x0000000100a71a88 @objc ViewController.viewDidLoad() (in MyCoolApp) (ViewController.swift:18)\n\nChange your code\n\nLook at the other frames in the backtrace to identify the exact function calls that produced the error, and determine whether you used a force unwrap or a forced downcast. A force unwrap uses the ! operator. For example:\n\nlet image = UIImage(named: \"aMissingIcon\")!\nprint(\"Image size: \\(image.size)\")\n\n\nInstead of the force unwrap, gracefully handle the nil value where it first appears in your code by using optional binding:\n\nif let image = UIImage(named: \"aMissingIcon\") {\n    print(\"Image size: \\(image.size)\")\n}\n\n\nSee the Swift documentation for more information on Optionals.\n\nFor type casts, a forced downcast uses the as! operator. This example crashes if library contains something other than a Song type:\n\nfor item in library {\n    let song = item as! Song\n    print(\"Song: \\(song.name), by \\(song.artist)\")\n}\n\n\nInstead of the forced downcast, gracefully handle the scenarios where the type of the object doesn’t match the expected type by using a conditional downcast:\n\nfor item in library {\n    if let song = item as? Song {\n         print(\"Song: \\(song.name), by \\(song.artist)\")\n    }\n}\n\n\nSee the Swift documentation for more information on Type Casting.\n\nSee Also\nRelated Documentation\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nRuntime errors\nAddressing language exception crashes\nIdentify the signs of a language exception, and address the crashes caused by uncaught language exceptions.\nReading an exception message\nUnderstand and address the common reasons apps crash."
  },
  {
    "title": "Addressing language exception crashes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/addressing-language-exception-crashes",
    "html": "Overview\n\nLanguage exceptions, such as those from Objective-C, indicate programming errors discovered at runtime, such as accessing an array with an index that’s out-of-bounds or not implementing a required method of a protocol. To determine whether a crash is due to a language exception, first confirm that the crash report contains this pattern:\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\n\n\nA crash due to a language exception that isn’t caught has a Last Exception Backtrace in the crash report. Verify this backtrace is present to confirm the crash is due to a language exception.\n\nNote\n\nException backtraces to the code throwing the exception aren’t provided for C++ exceptions.\n\nIdentify the API throwing the exception\n\nIn the Last Exception Backtrace, the operating system records the full backtrace of function calls leading to the exception. This backtrace ends with frames that make it clear a language exception was thrown. Further down the backtrace, you’ll find key information about what method threw the exception, and what part of your code called the method that threw the exception. For example:\n\nLast Exception Backtrace:\n0   CoreFoundation                    0x1bf596a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x1bf2bdfa4 objc_exception_throw + 55\n2   CoreFoundation                    0x1bf49b0ec -[NSException raise] + 11\n3   Foundation                        0x1bf879170 -[NSObject+ 205168 (NSKeyValueCoding) setValue:forKey:] + 311\n4   UIKitCore                         0x1c2ffa0b4 -[UIViewController setValue:forKey:] + 99\n5   UIKitCore                         0x1c32c1234 -[UIRuntimeOutletConnection connect] + 123\n6   CoreFoundation                    0x1bf470f3c -[NSArray makeObjectsPerformSelector:] + 251\n7   UIKitCore                         0x1c32be3a4 -[UINib instantiateWithOwner:options:] + 1967\n8   UIKitCore                         0x1c3000f18 -[UIViewController _loadViewFromNibNamed:bundle:] + 363\n9   UIKitCore                         0x1c30019a4 -[UIViewController loadView] + 175\n10  UIKitCore                         0x1c3001c5c -[UIViewController loadViewIfRequired] + 171\n11  UIKitCore                         0x1c3002360 -[UIViewController view] + 27\n12  UIKitCore                         0x1c3017a98 -[UIViewController _setPresentationController:] + 107\n13  UIKitCore                         0x1c30108a4 -[UIViewController _presentViewController:modalSourceViewController:presentationController:animationController:interactionController:completion:] + 1343\n14  UIKitCore                         0x1c30122b8 -[UIViewController _presentViewController:withAnimationController:completion:] + 4255\n15  UIKitCore                         0x1c3014794 __63-[UIViewController _presentViewController:animated:completion:]_block_invoke + 103\n16  UIKitCore                         0x1c3014c90 -[UIViewController _performCoordinatedPresentOrDismiss:animated:] + 507\n17  UIKitCore                         0x1c30146e4 -[UIViewController _presentViewController:animated:completion:] + 195\n18  UIKitCore                         0x1c301494c -[UIViewController presentViewController:animated:completion:] + 159\n19  MyCoolApp                         0x104e8b1ac MyViewController.viewDidLoad() (in MyCoolApp) (MyViewController.swift:35)\n\n\nIn this example backtrace, the operating system threw an exception in frames 0-2. Frame 3 raised the exception because it couldn’t complete the connection of the @IBOutlet properties defined in an Interface Builder file loaded into memory in frames 4-7. Frames 8-17 show UIKit preparing to present this view defined in Interface Builder. Frame 18 shows this crash started from the app calling present(_:animated:completion:), called from viewDidLoad() in frame 19. Frame 19 is a key piece of information for investigating this crash; it tells you to determine which Interface Builder file contains the problem by inspecting the source code near line 35 in MyViewController.swift.\n\nImportant\n\nIf the API throwing the exception is doesNotRecognizeSelector(_:):, the crash may be due to a zombie object. See Investigating crashes for zombie objects for additional information.\n\nCheck the exception message\n\nThe uncaught exception handler provided by the operating system logs the exception message to the console before terminating the process. If you reproduce a crash resulting from a language exception with the Xcode debugger attached to your app, you can see this message:\n\nApplication Specific Information:\n*** Terminating app due to uncaught exception 'NSUnknownKeyException', \n    reason: '[<MyCoolApp.MyViewController 0x105510d50> setValue:forUndefinedKey:]: \n    this class is not key value coding-compliant for the key refreshButton.'\n\n\nContinuing the example in Identify the API throwing the exception, this exception message fills in details not visible in the exception backtrace — the Interface Builder file has an outlet named refreshButton, but the MyViewController class doesn’t declare an @IBOutlet property by that name.\n\nThe crash report excludes the exception message for some errors to prevent disclosing private information about the person using the app. The crash report includes exception messages for many of the common cases of language exceptions your app generates through its use of framework APIs. For more about these exceptions, see Reading an exception message.\n\nNote\n\nAppKit apps have a default exception handler that catches all language exceptions raised by code run from its run loop. It logs the exception message and then allows the app to continue running.\n\nIf you can reproduce a language exception crash, set an exception breakpoint to pause execution and inspect your app’s state with Xcode’s debugger, as described in Pause execution when events occur. To automatically print the exception message when the exception breakpoint pauses execution, add an action to the exception breakpoint that runs a debugger command:\n\npo $arg1\n\nAddress crashes from a system language exception\n\nAfter identifying the operating system’s API throwing the exception, consult the documentation for that API to determine what conditions trigger the exception. Also try to reproduce the crash with the Xcode debugger attached to get the additional information about the exception in the console, using the frames in the backtrace as a guide to the specific code you need to test.\n\nIf you can’t reproduce the crash, use all of the thread backtraces (not just the exception backtrace) as clues about what your app was doing at the time it crashed, and think about what that information says about your app’s state. Use those clues as a starting point for addressing the crash.\n\nHandle language exceptions thrown by your app’s code\n\n64-bit versions of iOS and iPadOS use a zero-cost exception implementation, where every function has additional data that describes how to unwind the stack, or exit each stack frame, if a function throws an exception. If the thrown exception encounters a stack frame that doesn’t have unwind data, exception handling can’t proceed and the process halts. There might be an exception handler further up the stack, but without the unwind data for a frame, there’s no way to reach the exception handler from the stack frame throwing the exception.\n\nIf you find that exceptions thrown by your app within an exception handling domain aren’t caught, verify that the build settings for your app and libraries allow the compiler to create the unwind tables:\n\nDon’t specify the -no_compact_unwind flag.\n\nSpecify the -funwind-tables flag if you’re including plain C code.\n\nSee Also\nRelated Documentation\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nRuntime errors\nAddressing crashes from Swift runtime errors\nIdentify the signs of a Swift runtime error, and address the crashes runtime errors cause.\nReading an exception message\nUnderstand and address the common reasons apps crash."
  },
  {
    "title": "Investigating crashes for zombie objects | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/investigating-crashes-for-zombie-objects",
    "html": "Overview\n\nOnce an Objective-C or Swift object no longer has any strong references to it, the object is deallocated. Attempting to further send messages to the object as if it were still a valid object is a “use after free” issue, with the deallocated object still receiving messages called a zombie object.\n\nDetermine whether a crash report has signs of a zombie\n\nThe Objective-C runtime can’t message objects deallocated from memory, so crashes often occur in the objc_msgSend, objc_retain, or objc_release functions. For example, a crash where the Objective-C runtime can’t send a message to the deallocated object looks like this:\n\nThread 0 Crashed:\n0   libobjc.A.dylib                   0x00000001a186d190 objc_msgSend + 16\n1   Foundation                        0x00000001a1f31238 __NSThreadPerformPerform + 232\n2   CoreFoundation                    0x00000001a1ac67e0 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24\n\n\nHere’s another example, where the Objective-C runtime tries to release an object that’s already released:\n\nThread 2 Crashed:\n0   libobjc.A.dylib                 0x00007fff7478bd5c objc_release + 28\n1   libobjc.A.dylib                 0x00007fff7478cc8c (anonymous namespace)::AutoreleasePoolPage::pop(void*) + 726\n2   com.apple.CoreFoundation        0x00007fff485feee6 _CFAutoreleasePoolPop + 22\n\n\nAnother pattern that indicates a zombie object is a stack frame for an unrecognized selector, which is a method that an object doesn’t implement. Often this kind of crash looks like code where an unexpected type of object is asked to do something it obviously can’t do, such as a number formatter class trying to play a sound. This is because the operating system reused memory that once held the deallocated object, and that memory now contains a different kind of object. A zombie identified by an unrecognized selector has a call stack with the doesNotRecognizeSelector(_:) method:\n\nLast Exception Backtrace:\n0   CoreFoundation                    0x1bf596a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x1bf2bdfa4 objc_exception_throw + 55\n2   CoreFoundation                    0x1bf49a5a8 -[NSObject+ 193960 (NSObject) doesNotRecognizeSelector:] + 139\n\n\nIf you reproduce a crash like this when debugging, the console logs additional information:\n\nTerminating app due to uncaught exception 'NSInvalidArgumentException',\n    reason: '-[NSNumberFormatter playSound]: \n    unrecognized selector sent to instance 0x28360dac0'\n\n\nIn this example, a message was sent to a NumberFormatter to perform the playSound selector, but NumberFormatter doesn’t implement a method with that name, so the app crashed. An object was previously allocated at the same memory address as the current NumberFormatter that did implement the playSound method, but that object was deallocated, and the unrelated NumberFormatter object is now using the same memory address. The playSound selector is a clue for debugging. If you identify the class implementing the playSound selector, you can identify the code paths that call it and determine why the expected object deallocated too early.\n\nInvestigate the source of the zombie\n\nIn cases where a crash is caused by a zombie object, stack frames from the app may be in the backtrace, but not always. Even if no backtrace frames reference code in your app, your code contributed to the creation of the zombie, so investigate the source of the zombie with the Zombies instrument, as described in Finding zombies. As you use the Zombies instrument, look for answers to the following questions, so you have the information needed to modify your code and remove the zombie:\n\nWhat was the type of the deallocated object, and what message was sent to it?\n\nWhen was the object actually deallocated?\n\nHow was the object used after it was deallocated?\n\nWhen modifying your code, pay attention to the expected lifetime of the objects involved. Consider which objects use strong references, and which objects use weak or unowned references, so that objects are deallocated only when no longer needed and not too soon. See ARC Overview for information about Automatic Reference Counting in Objective-C, and the Swift documentation for information in Swift.\n\nSee Also\nRelated Documentation\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nMemory access errors\nInvestigating memory access crashes\nIdentify crashes that arise from memory access issues, and investigate the cause of the crash."
  },
  {
    "title": "Addressing missing framework crashes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/addressing-missing-framework-crashes",
    "html": "Overview\n\nIf you modularize your app’s functionality into frameworks, the app must link the frameworks at build time, and also embed a copy of the frameworks inside the app bundle during the build. If an app links a framework but doesn’t embed it, the app crashes at launch, because the dynamic linker can’t locate the missing framework.\n\nIdentify the missing framework\n\nThe dynamic linker, dyld, outputs detailed information about the framework it couldn’t locate, in the Termination Description of the crash report:\n\nException Type: EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note: EXC_CORPSE_NOTIFY\nTermination Description: DYLD, \n    dependent dylib '@rpath/MyFramework.framework/MyFramework' not found for '<path>/MyCoolApp.app/MyCoolApp',\n    tried but didn't find: \n    '/usr/lib/swift/MyFramework.framework/MyFramework' \n    '<path>/MyCoolApp.app/Frameworks/MyFramework.framework/MyFramework' \n    '@rpath/MyFramework.framework/MyFramework' \n    '/System/Library/Frameworks/MyFramework.framework/MyFramework'\n\n\nThe exact message depends on the operating system and operating system version. Here’s a different example:\n\nException Type: EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note: EXC_CORPSE_NOTIFY\nTermination Description: DYLD, Library not loaded: @rpath/MyFramework.framework/MyFramework \n    | Referenced from: <path>/MyCoolApp.app/MyCoolApp \n    | Reason: image not found\n\n\nNote\n\nFor readability, extra line breaks are in this example. In the original crash report file for these examples, the dyld information is on fewer lines.\n\nInspect the framework’s configuration\n\nEnsure the framework is correctly embedded in the app bundle—see Embedding Frameworks In An App.\n\nIf you can’t reproduce the crash, archive the app, export it for Development distribution, and apply app thinning, as described in Distributing your app for beta testing and releases. Test the different variants produced through app thinning to see if the framework is missing only after applying app thinning. If this reproduces the crash, do the following:\n\nVerify the framework’s build setting for Architectures (ARCHS) is the default value.\n\nVerify the framework’s build setting for Valid Architectures (VALID_ARCHS) is the default value.\n\nVerify the UIRequiredDeviceCapabilities key in the framework’s Info.plist file correctly specifies the CPU architectures the framework supports.\n\nNote\n\nIf the missing framework is from a third-party framework vendor or uses third-party development tools to integrate it in your app, contact the vendor for assistance in addressing the issue.\n\nSee Also\nRelated Documentation\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems."
  },
  {
    "title": "Configuring the Xcode project window | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/configuring-the-xcode-project-window",
    "html": "Overview\n\nThe Xcode project window is your primary interface for viewing, editing, and managing all parts of your project. You can configure it to fit your work style and adjust it as you work on different tasks.\n\nThe main window opens when you create or open a project. To open additional main windows, choose File > New > Window.\n\nThe areas of the main window are:\n\nThe toolbar for building and running your app, viewing the progress of tasks, and configuring the main window. Use the tabs at the top to organize your open files. You can reorder tabs, close them individually, or drag them out of the tab bar to create new windows.\n\nThe editor area for viewing and editing the contents of your project, including code, user interface files, property lists, project settings, and more.\n\nThe navigator area for viewing the parts of your project, including files, symbols, breakpoints, and build information.\n\nThe debug area for controlling the app execution during debugging, and for displaying variables, register, and status information.\n\nThe inspector area for viewing and editing information about the project or about the selected object in the navigator or editor area.\n\nConfigure the available editors\n\nFiles you select in the Project navigator open in the editor area. The editor that appears depends on the type of file you select. For example, if you select a source file, Xcode displays the source editor.\n\nTo add, remove, and configure editors, use the controls in the jump bar and tab bar, located at the top of the editor area. To change the information you display in the editor area, click the Adjust Editor Options button in the tab bar, and select one of the following:\n\nThe Canvas displays a preview of your SwiftUI interface. Use the Layout menu to configure the canvas’s position.\n\nThe Assistant editor displays information about what you’re editing. For example, the assistant editor for a SwiftUI view displays the canvas view, and the assistant for an Objective-C source file displays the matching header.\n\nThe Minimap view provides a miniaturized version of your source files content, which you use to navigate around the file.\n\nThe Authors view displays the commit history of a file under source control management.\n\nThe Code Coverage view displays statistics about your source code after you run tests. Use it to detect portions of your code not reached by your project’s tests.\n\nWhen showing multiple editors, click the Enable Code Review button in the tab bar to temporarily expand the current editor to fill the editor area. Click it again to collapse the editor to its original size.\n\nShow and hide areas of the main window\n\nShow and hide different parts of the main window to make more space in the editor area. The window has separate controls to hide the navigator area, inspector area, and debug area.\n\nSee Also\nNavigation\nFinding and replacing content in a project\nSearch some or all of your project for text strings or symbol names, and perform advanced searches using regular expressions."
  },
  {
    "title": "Fixing issues in your code as you type | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/fixing-issues-in-your-code-as-you-type",
    "html": "Overview\n\nXcode includes a number of features that help reduce typical coding mistakes, such as when you misspell a symbol name or forget to add a closing delimiter. By leveraging these features, you can focus more time on adding value to your app and less time fixing easily avoidable issues. With your explicit consent, Xcode can help you locate the correct symbol, fix common errors, and automatically match braces, parentheses, and brackets, by directly changing your code.\n\nAvoid syntax errors by using code completion\n\nWhen you begin typing the name of a symbol in the source editor, Xcode displays a list of suggestions for completing the name. You can dismiss this list by pressing Escape or clicking elsewhere in the source editor. If the possible completions share a common string, Xcode highlights that string. If there isn’t a common string, Xcode highlights the matching parts of the string instead.\n\nUse the Up Arrow and Down Arrow keys to navigate through the list of possible completions. Alternatively, you can click an item in the list to select it. A selected item displays its description below the list.\n\nTo insert a suggested completion into your source code, select the item and press Return. You can double-click an item to achieve the same. If you don’t see the desired completion, or the list is too long, continue typing to refine the list of suggestions.\n\nIf the inserted symbol contains parameters or arguments, Xcode adds a placeholder for each one. Use the Tab key to cycle through the placeholders, and Shift-Tab to cycle through them in reverse order. Alternatively, you can choose Navigate > Jump to Next Placeholder or Navigate > Jump to Previous Placeholder.\n\nTo prevent Xcode from suggesting completions as you type, follow these steps:\n\nChoose Xcode > Preferences or press Command-Comma.\n\nSelect Text Editing > Editing.\n\nDeselect the “Suggest completions while typing” preference.\n\nEven if you disable automatic suggestions, you can invoke code completion at any time when in the source editor by pressing Control-Space or Escape. The “Use Escape key to show completion suggestions” preference manages the behavior of the Escape key in this context.\n\nMatch braces, parentheses, and brackets automatically\n\nXcode helps you identify and balance opening and closing delimiters — braces, parentheses, and brackets — within your code. You can take advantage of this functionality by doing one or more of the following:\n\nType an opening delimiter and press Return or any character to automatically insert a closing delimiter.\n\nType a closing delimiter, or move the insertion point immediately after an existing closing delimiter, to briefly highlight the opening delimiter in the source editor.\n\nConversely, move the insertion point immediately after an opening delimiter to temporarily highlight the closing delimiter.\n\nMove the insertion point between two delimiters and choose Editor > Selection > Balance Delimiters to select those delimiters and the code in between. Alternatively, double-click one of the delimiters to achieve the same.\n\nSelect code in the source editor and type an opening delimiter to automatically enclose the selection in a pair of matching delimiters.\n\nTo prevent Xcode from automatically inserting delimiters, follow these steps:\n\nChoose Xcode > Preferences or press Command-Comma.\n\nSelect Text Editing > Editing.\n\nDeselect the “Automatically insert closing braces” and “Enclose selection in matching delimiters” preferences. If you write code in Objective-C, deselect “Automatically balance brackets in Objective-C method calls” in addition to the other two preferences.\n\nMake a Fix-It correction\n\nFix-It is an Xcode feature that offers suggested fixes for syntax errors as you write code. The source editor highlights any issues with a red underline and presents an issue summary and icon. Clicking the icon displays more information about the problem and, in many cases, presents a Fix-It that’ll repair the issue for you.\n\nImportant\n\nTo use Fix-It, you must build your target with either the LLVM or Swift compiler. Fix-It is compatible with Swift, C, Objective-C, and Objective-C++.\n\nTo apply a suggested Fix-It correction:\n\nEnter code into the source editor, which marks any issues with a red underline and displays a summary of the problem to the right.\n\nWhen a summary appears, click the icon to display a more comprehensive description of the issue, along with any suggested corrections.\n\nClick the Fix button to select a correction, and Xcode makes the necessary updates to your source code.\n\nIf your source code contains multiple issues, navigate between them by choosing Navigate > Jump to Next Issue or Navigate > Jump to Previous Issue. To dismiss the Fix-It dialog, press the Escape key."
  },
  {
    "title": "Adding identifiable symbol names to a crash report | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-identifiable-symbol-names-to-a-crash-report",
    "html": "Overview\n\nWhen an app crashes, the operating system collects diagnostic information about what the app was doing at the time of crash. One of the most important parts of the crash report are the thread backtraces, reported as hexadecimal addresses. You translate these thread backtraces into readable function names and line numbers in source code, a process called symbolication, then use that information to understand why your app crashed. In many cases, the Crashes organizer in Xcode automatically symbolicate the crash reports for you.\n\nDetermine if a crash report is symbolicated\n\nTo diagnose an app issue using a crash report, you need a fully symbolicated or partially symbolicated crash report. An unsymbolicated crash report is rarely useful.\n\nA fully symbolicated crash report has function names on every frame of the backtrace, instead of hexadecimal memory addresses. Each frame represents a single function call that’s currently running on a specific thread, and provides a view of the functions from your app and the operating system frameworks that were executing at the time your app crashed. Fully symbolicated crash reports give you the most insight about the crash. Once you have a fully symbolicated crash report, consult Analyzing a crash report for details about determing the source of the crash.\n\nAn example of a fully symbolicated crash report:\n\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n1   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n2   libswiftCore.dylib                0x00000001bd15958c _ArrayBuffer._checkInoutAndNativeTypeCheckedBounds+ 66956 (_:wasNativeTypeChecked:) + 200\n3   libswiftCore.dylib                0x00000001bd15c814 Array.subscript.getter + 88\n4   TouchCanvas                       0x00000001022cbfa8 Line.updateRectForExistingPoint(_:) (in TouchCanvas) + 656\n5   TouchCanvas                       0x00000001022c90b0 Line.updateWithTouch(_:) (in TouchCanvas) + 464\n6   TouchCanvas                       0x00000001022e7374 CanvasView.updateEstimatedPropertiesForTouches(_:) (in TouchCanvas) + 708\n7   TouchCanvas                       0x00000001022df754 ViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 304\n8   TouchCanvas                       0x00000001022df7e8 @objc ViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 120\n9   UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n10  UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n11  UIKitCore                         0x00000001b3e01e24 -[_UIEstimatedTouchRecord dispatchUpdateWithPressure:stillEstimated:] + 340\n\n\nA partially symbolicated crash report has function names for some of the backtrace frames, and hexadecimal addresses for other frames of the backtrace. A partially symbolicated crash report may contain enough information to understand the crash, depending upon the type of crash and which frames in the backtraces are symbolicated. However, you should still Symbolicate the crash report in Xcode to make the report fully symbolicated, which will give you a complete understanding of the crash.\n\nAn example of a partially symbolicated crash report:\n\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n1   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n2   libswiftCore.dylib                0x00000001bd15958c _ArrayBuffer._checkInoutAndNativeTypeCheckedBounds+ 66956 (_:wasNativeTypeChecked:) + 200\n3   libswiftCore.dylib                0x00000001bd15c814 Array.subscript.getter + 88\n4   TouchCanvas                       0x00000001022cbfa8 0x1022c0000 + 49064\n5   TouchCanvas                       0x00000001022c90b0 0x1022c0000 + 37040\n6   TouchCanvas                       0x00000001022e7374 0x1022c0000 + 160628\n7   TouchCanvas                       0x00000001022df754 0x1022c0000 + 128852\n8   TouchCanvas                       0x00000001022df7e8 0x1022c0000 + 129000\n9   UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n10  UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n11  UIKitCore                         0x00000001b3e01e24 -[_UIEstimatedTouchRecord dispatchUpdateWithPressure:stillEstimated:] + 340\n\n\nUnsymbolicated crash reports contain hexadecimal addresses of executable code within the loaded binary images. These reports don’t contain any function names in the backtraces. Because an unsymbolicated crash report is rarely useful, Symbolicate the crash report in Xcode.\n\nAn example of an unsymbolicated symbolicated crash report:\n\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 0x1bd149000 + 2378352\n1   libswiftCore.dylib                0x00000001bd38da70 0x1bd149000 + 2378352\n2   libswiftCore.dylib                0x00000001bd15958c 0x1bd149000 + 66956\n3   libswiftCore.dylib                0x00000001bd15c814 0x1bd149000 + 79892\n4   TouchCanvas                       0x00000001022cbfa8 0x1022c0000 + 49064\n5   TouchCanvas                       0x00000001022c90b0 0x1022c0000 + 37040\n6   TouchCanvas                       0x00000001022e7374 0x1022c0000 + 160628\n7   TouchCanvas                       0x00000001022df754 0x1022c0000 + 128852\n8   TouchCanvas                       0x00000001022df7e8 0x1022c0000 + 129000\n9   UIKitCore                         0x00000001b3da6230 0x1b3348000 + 10871344\n10  UIKitCore                         0x00000001b3da6230 0x1b3348000 + 10871344\n11  UIKitCore                         0x00000001b3e01e24 0x1b3348000 + 11247140\n\nSymbolicate the crash report in Xcode\n\nXcode is the preferred way to symbolicate crash reports because it uses all available dSYM files on your Mac at once. For specialized debugging situations, such as when you have an unsymbolicated stack trace in the Xcode debugger without a full crash report, you can Symbolicate the crash report with the command line to symbolicate each frame.\n\nTo symbolicate in Xcode, click the Device Logs button in the Devices and Simulators window, then drag and drop the crash report file into the list of device logs.\n\nImportant\n\nCrash reports must have the .crash file extension. If a crash report doesn’t have a file extension, or has a different file extension like .txt , rename it with the .crash extension before symbolicating it.\n\nIf the crash report does not symbolicate, or only partly symbolicates, Xcode can’t locate matching symbol information, and you’ll need to acquire symbol information in these ways:\n\nIf the operating system’s frameworks aren’t symbolicated, you need device symbol information matching the operating system version recorded in the crash report. To address this, see Acquire device symbol information.\n\nIf the frames for your app, app extension, or frameworks aren’t symbolicated, you need to locate the existing dSYM files using Spotlight. To address this, see Locate a dSYM using Spotlight. If your app uses frameworks built by a third-party, you may need to ask the framework vendor for the dSYM file.\n\nOnce you have a fully symbolicated crash report, consult Analyzing a crash report to determine the source of the crash.\n\nAcquire device symbol information\n\nTo make symbols from the operating system frameworks identifiable in a crash report, you need to collect the symbols for the system frameworks from a device. For iOS, iPadOS, watchOS, and tvOS apps, Xcode automatically copies operating system symbols from each device you connect to your Mac. For macOS and Mac Catalyst apps, symbolicate the crash log by using Xcode on a version of macOS that matches the macOS version named in the crash report.\n\nThe symbols for system frameworks are specific to the operating system release and the CPU architecture of the device. For example, the symbols for an iPhone running iOS 13.1.0 aren’t the same as the symbols for the same iPhone running iOS 13.1.2. If your app runs on operating system versions that support multiple CPU architectures, such as arm64 and arm64e, a device with an arm64 architecture will only contain the symbols for the arm64 version of the operating system frameworks; it won’t have symbols for the operating system frameworks on arm64e devices.\n\nLocate a dSYM using Spotlight\n\nTo determine whether the dSYM file you need to symbolicate a hexadecimal addresses for one of your binaries is present on your Mac:\n\nFind a frame in the backtrace that isn’t symbolicated. Note the name of the binary image in the second column.\n\nLook for a binary image with that name in the list of binary images at the bottom of the crash report. This list contains the build UUID of each binary image that was loaded into the process at the time of the crash. Use the grep command line tool to find the entry in the list of binary images:\n\n% grep --after-context=1000 \"Binary Images:\" <Path to Crash Report> | grep <Binary Name>\n\n\nAfter getting the build UUID from the binary image section:\n\nConvert the build UUID of the binary image to a 32-character string, that’s separated into groups of 8-4-4-4-12 (XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX). All letters must be uppercase.\n\nSearch for the build UUID using the mdfind command line tool query (including quotation marks):\n\n% mdfind \"com_apple_xcode_dsym_uuids == <UUID>\"\n\n\nIf Spotlight finds a dSYM file for the build UUID, mdfind prints the path to the dSYM file.\n\nUsing the information in this example, the commands to find the dSYM are:\n\n% grep --after-context=1000 \"Binary Images:\" <Path to Crash Report> | grep TouchCanvas\n0x1022c0000 - 0x1022effff TouchCanvas arm64  <9cc89c5e55163f4ab40c5821e99f05c6>\n\n\n% mdfind \"com_apple_xcode_dsym_uuids == 9CC89C5E-5516-3F4A-B40C-5821E99F05C6\"\n\n\nOnce you find the dSYM file, Match build UUIDs to confirm that its build UUID matches the binary image’s build UUID. Once you verify that build UUIDs match, either Symbolicate the crash report in Xcode or Symbolicate the crash report with the command line.\n\nIf Spotlight doesn’t find a matching dSYM, mdfind won’t print anything and you’ll need to:\n\nVerify that you still have the Xcode archive for the version of your app that crashed. If you no longer have this archive, you can’t symbolicate your app’s stack frames for that version of your app. To avoid this in the future, release a new version of your app, and retain the Xcode archive for that version. You’ll then be able to symbolicate crash reports for the new version of your app.\n\nEnsure the Xcode archive is located somewhere Spotlight can find it, such as your macOS home directory.\n\nVerify that your build produces debugging information. See Building your app to include debugging information.\n\nMatch build UUIDs\n\nIf you have a binary or a dSYM that you think can be used to symbolicate a crash report, verify that the build UUIDs match, using the dwarfdump command. If the build UUIDs don’t match each other or don’t match the build UUID listed in the Binary Images section of the crash report, you can’t use the files to symbolicate that crash report.\n\n% dwarfdump --uuid <PathToDSYMFile>/Contents/Resources/DWARF/<BinaryName>\n% dwarfdump --uuid <PathToBinary>\n\nSymbolicate the crash report with the command line\n\nFor specialized debugging situations, such as symbolicating parts of a backtrace provided by the LLDB command line, you can symbolicate a crash report using the atos command. The atos command converts hexadecimal addresses to the identifiable function name and line number from your source code, if symbol information is available. To symbolicate using atos:\n\nFind a frame in the backtrace that you want to symbolicate. Note the name of the binary image in the second column, and the address in the third column.\n\nLook for a binary image with that name in the list of binary images at the bottom of the crash report. Note the architecture and load address of the binary image.\n\nLocate the dSYM file for the binary. If you don’t know where the dSYM file is located, see Locate a dSYM using Spotlight to find the dSYM file that matches the build UUID of the binary image.\n\nSymbolicate the addresses in the backtrace using atos with the formula, substituting the information you gathered in previous steps:\n\n% atos -arch <BinaryArchitecture> -o <PathToDSYMFile>/Contents/Resources/DWARF/<BinaryName>  -l <LoadAddress> <AddressesToSymbolicate>\n\n\nNote\n\ndSYM files are macOS bundles that contain a file with the debug symbols. When invoking atos, you must provide the path to this file inside the bundle, not just to the outer dSYM bundle.\n\nAs an example, look at the highlighted sections of this crash report:\n\nUsing the information in this example, the complete atos command and its output are:\n\n% atos -arch arm64 -o TouchCanvas.app.dSYM/Contents/Resources/DWARF/TouchCanvas -l 0x1022c0000 0x00000001022df754\nViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 304\n\n\nOnce you have at least a partially symbolicated crash report by using atos, consult Analyzing a crash report for information to determine the source of the crash.\n\nSee Also\nCrash reports\nIdentifying the cause of common crashes\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nExamining the fields in a crash report\nUnderstand the structure of a crash report and the information each field contains.\nInterpreting the JSON format of a crash report\nUnderstand the structure and properties of the objects the system includes in the JSON of a crash report.\nUnderstanding the exception types in a crash report\nLearn what the exception type tells you about why your app crashed."
  },
  {
    "title": "Use of stack memory after function return | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/use-of-stack-memory-after-function-return",
    "html": "Overview\n\nUse this check to detect access to a stack variable that a function declares after that function returns. Attempting to access stack memory in this manner can lead to crashes, or result in unpredictable behavior. Available in Xcode 9 and later.\n\nNote\n\nThis check is in a disabled state by default. You can enable it under the Address Sanitizer option in the Edit Scheme dialogue.\n\nUse of stack memory after return in C\n\nIn the following example, the integer_pointer_returning_function function returns a pointer to a stack variable, and there’s an attempt to access the memory of the returned pointer:\n\nint *integer_pointer_returning_function() {\n    int value = 42;\n    return &value;\n}\n\n\nint *integer_pointer = integer_returning_function();\n*integer_pointer = 43; // Error: invalid access of returned stack memory\n\nSolution\n\nUse pointer arguments to allow a function to return values by reference.\n\nSee Also\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds."
  },
  {
    "title": "Use of deallocated memory | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/use-of-deallocated-memory",
    "html": "Overview\n\nUse this check to detect when your code accesses deallocated memory, which can lead to unpredictable behavior. Available in Xcode 7 and later.\n\nUse of deallocated memory in Objective-C\n\nIn the following example, the unsafePointer variable has __unsafe_unretained ownership. Because there are no other objects that have a strong reference to it, the autorelease pool deallocates the variable, causing it to point to invalid memory.\n\n__unsafe_unretained MyClass *unsafePointer;\n@autoreleasepool {    \n    MyClass *object = [MyClass new];\n    unsafePointer = object;\n}\nNSLog(@\"%d\", unsafePointer->instanceVariable); \n// Error: unsafePointer is deallocated in autorelease pool\n\nSolution\n\nUse a __strong or __weak reference instead of __unsafe_unretained. Strong ownership ensures that you, or the system, can only deallocate an object when no strong references exist. Weak ownership has no effect on the life cycle of the object it refers to, but ensures that a variable is nil when you deallocate the object, or the system deallocates it.\n\nUse of deallocated pointer in Objective-C\n\nThis issue exists when using pointers to nonobject types, as well. In the following example, the pointer to the instance variable invalidates when deallocating the object:\n\nint *unsafePointer;\n@autoreleasepool {    \n    MyClass *object = [MyClass new];\n    unsafePointer = &object->instanceVariable;\n}\nNSLog(@\"%d\", *unsafePointer);\n// Error: unsafePointer is invalidated when object is deallocated in autorelease pool\n\nSolution\n\nUse property accessors rather than direct access to instance variables and pointers whenever possible.\n\nSee Also\nAddress Sanitizer\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds."
  },
  {
    "title": "Deallocation of deallocated memory | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/deallocation-of-deallocated-memory",
    "html": "Overview\n\nUse this check to detect when you call free on deallocated memory, commonly referred to as a double free error. Attempting to deallocate memory more than once can result in a crash or other unpredictable behavior. Available in Xcode 7 and later.\n\nDeallocation of freed memory in C\n\nIn the following example, the code deallocates the p_int variable after the call to free its memory:\n\nint *pointer = malloc(sizeof(int));\nfree(pointer);\nfree(pointer); // Error: free called twice with the same memory address \n\nSolution\n\nEnsure that you call the free function just once for memory you allocate.\n\nSee Also\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds."
  },
  {
    "title": "Deallocation of nonallocated memory | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/deallocation-of-nonallocated-memory",
    "html": "Overview\n\nUse this check to detect when you call free on memory that you don’t allocate using malloc. Attempting to deallocate nonallocated memory can result in a crash. Available in Xcode 7 and later.\n\nDeallocation of a stack variable in C\n\nIn the following example, the value variable allocates on the stack, and deallocates when the function exits, so calling free on it is incorrect:\n\nint value = 42;\nfree(&value); // Error: free called on stack allocated variable\n\nSolution\n\nDon’t call the free function on variables that you allocate on the stack.\n\nSee Also\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds."
  },
  {
    "title": "Overflow of C++ containers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/overflow-of-c-containers",
    "html": "Overview\n\nUse this check to detect when you access a libc++ container beyond the region [container.begin(), container.end()], even when the accessed memory is in a heap-allocated buffer the container uses internally. Available in Xcode 7 and later.\n\nNote\n\nThis check is in a disabled state by default because it requires building all statically linked libraries using std::vector with an enabled Address Sanitizer. To enable this check, choose the Yes option for the Enable C++ Container Overflow Checks setting.\n\nVector overflow in C++\n\nIn the following example, the vector variable has valid indexes in the range [0,2], but the accessed index is 3, which causes an overflow:\n\nstd::vector<int> vector;\nvector.push_back(0);\nvector.push_back(1);\nvector.push_back(2);\nauto *pointer = &vector[0];\nreturn pointer[3]; // Error: out of bounds access for vector\n\nSolution\n\nAdd a bounds check before attempting to access a container at a specific index.\n\nSee Also\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries."
  },
  {
    "title": "Use of out-of-scope stack memory | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/use-of-out-of-scope-stack-memory",
    "html": "Overview\n\nUse this check to detect when you access a variable outside of its scope. Attempting to access out-of-scope memory can result in unpredictable behavior. Available in Xcode 9 and later.\n\nUse of out-of-scope stack memory in C\n\nIn the following example, the code conditionally assigns the pointer variable to the return value of the integer_returning_function function, which it then accesses out of its declaration scope:\n\nint *pointer = NULL;\nif (bool_returning_function()) {\n    int value = integer_returning_function();\n    pointer = &value;\n}\n*pointer = 42; // Error: invalid access of stack memory out of declaration scope\n\nSolution\n\nEnsure you don’t access variables outside of their declared scope, or allocate memory using the malloc function.\n\nSee Also\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds."
  },
  {
    "title": "Data races | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/data-races",
    "html": "Overview\n\nUse this check to detect when multiple threads access the same memory without synchronization, and at least one access is a write. Available in Xcode 8 and later.\n\nData race with producer and consumer functions\n\nIn the following example, the producer() function sets the global variable message, and the consumer() function waits for a flag to set before printing the message. Because producer() executes on one thread and consumer() executes on another thread, their execution can be concurrent, creating a data race.\n\nvar message: String? = nil\nvar messageIsAvailable: Bool = false\n// Executed on Thread #1\nfunc producer() {\n    message = \"hello!\"\n    messageIsAvailable = true\n}\n// Executed on Thread #2\nfunc consumer() {\n    repeat {\n        usleep(1000)\n    } while !messageIsAvailable\n    print(message)\n}\n\nSolution\n\nUse Dispatch APIs to coordinate access to message across multiple threads.\n\nSee Also\nThread Sanitizer\nSwift access races\nDetects unsynchronized access to mutable state across multiple threads in Swift.\nRaces on collections and other APIs\nDetects when one thread accesses a mutable object while another thread is writing to it.\nUninitialized mutexes\nDetects when you use an uninitialized mutex.\nThread leaks\nDetects when you don’t close threads after use."
  },
  {
    "title": "Misaligned pointer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/misaligned-pointer",
    "html": "Overview\n\nIn Xcode 9 and later, you can use this check to detect reads from, or writes to, a misaligned pointer, or when you create a misaligned reference. A pointer misaligns if its address isn’t a multiple of its type’s alignment. Dereferencing a misaligned pointer has undefined behavior, and may result in a crash or degraded performance.\n\nAlignment violations occur frequently in code that serializes or deserializes data. Avoid this issue by using a serialization format that preserves data alignment.\n\nMisaligned integer pointer assignment in C\n\nIn the following example, the pointer variable must have 4-byte alignment, but has only 1-byte alignment:\n\nint8_t *buffer = malloc(64);\nint32_t *pointer = (int32_t *)(buffer + 1);\n*pointer = 42; // Error: misaligned integer pointer assignment\n\nSolution\n\nUse an assignment function like memcpy, which can work with unaligned inputs.\n\nint8_t *buffer = malloc(64);\nint32_t value = 42;\nmemcpy(buffer + 1, &value, sizeof(int32_t)); // Correct\n\n\nNote\n\nThe compiler can often safely optimize calls to memcpy, even for unaligned arguments.\n\nMisaligned structure pointer assignment in C\n\nIn the following example, the pointer variable must have 8-byte alignment, but has only 1-byte alignment:\n\nstruct A {\n    int32_t i32;\n    int64_t i64;\n};\nint8_t *buffer = malloc(32);\nstruct A *pointer = (struct A *)(buffer + 1);\npointer->i32 = 7; // Error: pointer is misaligned\n\nSolution\n\nOne solution is to pack the structure. In the following example, the packed A structure prevents the compiler from adding padding between members:\n\nstruct A { ... } __attribute__((packed));\n\n\nImportant\n\nPacking a structure may adversely impact performance.\n\nSee Also\nUndefined Behavior Sanitizer\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Races on collections and other APIs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/races-on-collections-and-other-apis",
    "html": "Overview\n\nIn Xcode 9 and later, the Thread Sanitizer detects unsafe thread accesses of Foundation and Core Foundation framework APIs. This feature applies to the following collection types:\n\nNSMutableArray\n\nNSMutableDictionary\n\nCFMutableArray\n\nCFMutableDictionary\n\nCollection race with a mutable array\n\nIn the following example, the code enumerates a mutable array in one thread while writing to the array from another without synchronizing access:\n\nSwift\n\nlet array: NSMutableArray = []\nvar sum: Int = 0\n// Executed on Thread #1\nfor value in array {\n    sum += value as! Int\n}\n// Executed on Thread #2\narray.add(42)\n\n\nObjective-C\n\nNSMutableArray *array = [NSMutableArray new];\nNSInteger sum = 0;\n// Executed on Thread #1\nfor (id value in array) {  \n    sum += [value integerValue];\n} \n// Executed on Thread #2\n[array addObject:@42];\n\nSolution\n\nUse Dispatch APIs to coordinate access to array across multiple threads.\n\nCollection race with a mutable dictionary\n\nIn the following example, the code enumerates a mutable dictionary in one thread while writing to the dictionary from another without synchronizing access:\n\nlet dictionary: NSMutableDictionary = [:]\nvar sum: Int = 0\n// Executed on Thread #1\nfor key in dictionary.keyEnumerator() {\n    sum += dictionary[key] as! Int\n}\n// Executed on Thread #2\ndictionary[\"forty-two\"] = 42\n\n\nObjective-C\n\nNSMutableDictionary *dictionary = [NSMutableDictionary new];\nNSInteger sum = 0;\n// Executed on Thread #1\nfor (id key in dictionary) {\n    sum += [dictionary[key] integerValue];\n}\n// Executed on Thread #2\ndictionary[@\"forty-two\"] = @42;\n\nSolution\n\nUse Dispatch APIs to coordinate access to dictionary across multiple threads.\n\nSee Also\nThread Sanitizer\nData races\nDetects unsynchronized access to mutable state across multiple threads.\nSwift access races\nDetects unsynchronized access to mutable state across multiple threads in Swift.\nUninitialized mutexes\nDetects when you use an uninitialized mutex.\nThread leaks\nDetects when you don’t close threads after use."
  },
  {
    "title": "Uninitialized mutexes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/uninitialized-mutexes",
    "html": "Overview\n\nUse this check to detect when you call pthread_mutex_lock(_:) or pthread_mutex_unlock(_:) with an uninitialized pthread_mutex_t variable. Attempting to use an uninitialized mutex results in an error, and bypasses ordering conditions that exist on a locked mutex. Available in Xcode 8 and later.\n\nUse of uninitialized mutex in C\n\nIn the following example, the pthread_mutex_lock(_:) function executes with an uninitialized pthread_mutex_t variable:\n\nstatic pthread_mutex_t mutex;\nvoid performWork() {\n    pthread_mutex_lock(&mutex); // Error: uninitialized mutex\n    // ...\n    pthread_mutex_unlock(&mutex);\n}\n\nSolution\n\nUse the pthread_once(_:_:) function to initialize a mutex before you use it.\n\nstatic pthread_once_t once = PTHREAD_ONCE_INIT;\nstatic pthread_mutex_t mutex;\nvoid init() {    \n    pthread_mutex_init(&mutex, NULL);\n}\nvoid performWork() {\n    pthread_once(&once, init); // Correct\n    pthread_mutex_lock(&mutex);\n    // ...\n    pthread_mutex_unlock(&mutex);\n}\n\nSee Also\nThread Sanitizer\nData races\nDetects unsynchronized access to mutable state across multiple threads.\nSwift access races\nDetects unsynchronized access to mutable state across multiple threads in Swift.\nRaces on collections and other APIs\nDetects when one thread accesses a mutable object while another thread is writing to it.\nThread leaks\nDetects when you don’t close threads after use."
  },
  {
    "title": "Invalid Boolean value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/invalid-boolean",
    "html": "Overview\n\nUse this check to detect accesses to a Boolean variable when its value isn’t true or false. This problem can occur when using an integer or pointer without an appropriate cast. The use of out-of-range Boolean values has undefined behavior, which can be difficult to debug. Available in Xcode 9 and later.\n\nInvalid Boolean variable access in C\n\nThe intent of the following code is to call the success function when result is nonzero. However, because it uses a Boolean check, the compiler may, as an optimization, only emit instructions that check the least-significant bit of predicate, which is 0, causing a logic error.\n\nint result = 2;\nbool *predicate = (bool *)&result;\nif (*predicate) { // Error: variable is not a valid Boolean\n    success();\n}\n\nSolution\n\nUse integer comparison instead of a Boolean check.\n\nint result = 2;\nif (result != 0) { // Correct\n  success();\n}\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Invalid enumeration value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/invalid-enumeration-value",
    "html": "Overview\n\nIn Xcode 9 and later, you can use this check to detect accesses of an enumeration variable when its value isn’t within the valid range for the type. This can occur for uninitialized enumeration values, or when using an integer as an enumeration value without an appropriate cast. The use of out-of-range enumeration values has undefined behavior, and may indicate the existence of logic errors in a program.\n\nInvalid enumeration variable access in C++\n\nIn the following example, the cast to the E type is invalid because 2 isn’t within the enumeration’s range:\n\nenum E {\n    a = 1\n};\nint value = 2;\nenum E *e = (enum E *)&value;\nreturn *e; // Error: 2 is out of the valid range for E\n\nSolution\n\nEnsure that enumeration variables only use values within their defined ranges.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Out-of-bounds array access | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/out-of-bounds-array-access",
    "html": "Overview\n\nUse this check to detect attempts to access indexes that exceed the array’s bounds. Out-of-bounds array accesses have undefined behavior, and can result in crashes or incorrect program output. Available in Xcode 9 and later.\n\nNote\n\nThis check doesn’t detect out-of-bounds accesses into heap-allocated arrays.\n\nOut-of-bounds array access in C\n\nIn the following example, out-of-bounds access of array occurs on the last iteration of the loop:\n\nint array[5];\nfor (int i = 0; i <= 5; ++i) {\n    array[i] += 1; // Error: out-of-bounds access on the last iteration\n}\n\nSolution\n\nEnsure that accessed indexes don’t exceed the array’s bounds.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Thread leaks | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/thread-leaks",
    "html": "Overview\n\nUse this check to detect threads you create using the pthread_create(_:_:_:_:) function without a corresponding call to the pthread_join(_:_:) function. Leaked threads can result in decreased performance and may lead to crashes. Available in Xcode 8 and later.\n\nLeaked thread in C\n\nIn the following example, the code creates a thread variable, but doesn’t close it after use:\n\nvoid *run(){\n    pthread_exit(0);\n}\npthread_t thread;\npthread_create(&thread, NULL, run, NULL); // Error: thread leak\nsleep(1);\n\nSolution\n\nAdd a call to the pthread_join(_:_:) function.\n\nvoid *run(){\n    pthread_exit(0);\n}\npthread_t thread;\npthread_create(&thread, NULL, run, NULL);\nsleep(1);\npthread_join(thread, NULL); // Correct\n\n\nAlternatively, you can create a detached thread by passing the PTHREAD_CREATE_DETACHED attribute to pthread_create(_:_:_:_:), or calling pthread_detach(_:) on the thread after creation.\n\nSee Also\nThread Sanitizer\nData races\nDetects unsynchronized access to mutable state across multiple threads.\nSwift access races\nDetects unsynchronized access to mutable state across multiple threads in Swift.\nRaces on collections and other APIs\nDetects when one thread accesses a mutable object while another thread is writing to it.\nUninitialized mutexes\nDetects when you use an uninitialized mutex."
  },
  {
    "title": "Reaching of unreachable point | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reaching-of-unreachable-point",
    "html": "Overview\n\nUse this check to detect when control flow reaches an unreachable point in a program you create using __builtin_unreachable, which may cause abrupt program termination. Available in Xcode 9 and later.\n\nExecuting unreachable code in C\n\nIf the switch statement fails to handle a value that a function returns, the program reaches __builtin_unreachable().\n\nswitch (value_returning_function()) {\ncase ...:                  // Warning: if the cases are not exhaustive\ndefault:                   // __builtin_unreachable may be reached\n    __builtin_unreachable();\n}\n\nSolution\n\nEnsure that switch statements and other control flow statements are exhaustive.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Dynamic type violation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/dynamic-type-violation",
    "html": "Overview\n\nUse this check to detect when an object has the wrong dynamic type. Dynamic type violations can cause unintended code execution. Available in Xcode 9 and later.\n\nMember call on instance with incorrect type in C++\n\nIn the following code, reinterpret_cast creates a variable with the wrong dynamic type:\n\nstruct Animal {\n    virtual const char *speak() = 0;\n};\nstruct Cat : public Animal {\n    const char *speak() override {\n        return \"meow\";\n    }\n};\nstruct Dog : public Animal {\n    const char *speak() override {\n      return \"woof\";\n    }\n};\nauto *dog = reinterpret_cast<Dog *>(new Cat); // Error: dog has incorrect dynamic type\ndog->speak(); // Error: this call has undefined behavior\n\n\nThe method call dog->speak() is suspect. If the speak method in Dog is final override, dog->speak() may return \"woof\" because the optimizer can devirtualize the call; if not, it might return \"meow\".\n\nNote\n\nThis UBSan check requires runtime type information, and is incompatible with the -fno-rtti compiler flag.\n\nSolution\n\nUse reinterpret_cast sparingly, and only when it’s possible to verify that the cast object is an instance of the destination type.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Connecting Xcode Cloud to GitHub Enterprise | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/connecting-xcode-cloud-to-github-enterprise",
    "html": "Overview\n\nWhen you first configure your project or workspace to use Xcode Cloud, you need to allow Xcode Cloud to access your Git repository. It uses this access to automatically build and test your code when you make changes to the codebase.\n\nIf you host your code as part of a GitHub organization, the person who first configures a project to use Xcode Cloud must be an organization owner. If you don’t use a GitHub organization, the person who first configures a project to use Xcode Cloud must have the admin permission. If you don’t have the required role or permission, see Connect Xcode Cloud to an admin-managed Git repository.\n\nTo allow Xcode Cloud to access your repository on GitHub Enterprise:\n\nConfigure your project or workspace to use Xcode Cloud and create your first workflow as described in Configuring your first Xcode Cloud workflow. Xcode analyzes your project to learn which SCM provider you use and then displays the URL of your GitHub Enterprise instance on the Grant Access to Your Source Code sheet.\n\nClick Grant Access. Xcode opens your browser and takes you to the App Store Connect website.\n\nChoose GitHub Enterprise.\n\nRegister the host name of your GitHub Enterprise host. The corresponding field should already contain your instance’s URL. Check if it’s correct; for example, make sure it contains a required port.\n\nClick Complete Step 1 in GitHub Enterprise to navigate to the website of your GitHub Enterprise host.\n\nReview the name of the GitHub app, then create it. GitHub Enterprise uses this app to grant Xcode Cloud access to your repository.\n\nReview and authorize the permissions that the GitHub app requests.\n\nAuthorize Xcode Cloud to verify your identity on GitHub Enterprise to link your GitHub Enterprise account to your Apple ID.\n\nChoose to only install the GitHub app for your project’s repository. Don’t install it for every repository. When the installation finishes, GitHub Enterprise takes you back to the App Store Connect website. App Store Connect now indicates that you successfully connected Xcode Cloud to GitHub Enterprise.\n\nReturn to Xcode. It indicates that Xcode Cloud can access your source code.\n\nClick Next, complete your first workflow, and start your first build.\n\nSee Also\nGitHub and GitHub Enterprise\nConnecting Xcode Cloud to GitHub\nAllow Xcode Cloud to access your GitHub repository."
  },
  {
    "title": "Invalid object size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/invalid-object-size",
    "html": "Overview\n\nUse this check to detect pointer casts when the size of the source type is less than the size of the destination type. Using the result of such a cast to access out-of-bounds data has undefined behavior. Available in Xcode 9 and later.\n\nDowncast from type with insufficient space in C++\n\nIn the following example, the cast from Base * to Derived * is suspect because Base isn’t large enough to contain an instance of Derived:\n\nstruct Base {\n    int pad1;\n};\nstruct Derived : Base {\n    int pad2;\n};\nDerived *getDerived() {\n    return static_cast<Derived *>(new Base); // Error: invalid downcast\n}\n\n\nThe optimizer may remove an expression, such as getDerived()->pad2, because getDerived() returns a pointer to an object that isn’t large enough to contain a pad2 field.\n\nNote\n\nThis UBSan check may not trigger at low optimization levels.\n\nSolution\n\nOne way to fix this issue is to avoid the downcast, such as by using instances of the Derived object wherever you need them.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Invalid shift | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/invalid-shift",
    "html": "Overview\n\nUse this check to detect bitwise shifts with invalid shift amounts and shifts that might overflow. These shifts have undefined behavior and the optimizer may omit them. Available in Xcode 9 and later.\n\nInvalid shift amount in C\n\nThe following code shows a shift with an invalid shift amount because the destination type can’t represent the result:\n\nint32_t x = 1;\nx <<= 32; // Error: (1 << 32) can't be represented in an int32_t\n\n\nIf the optimizer can prove that a shift amount may be invalid, it may replace the result of the shift with an arbitrary value.\n\nSolution\n\nUse a larger destination type, such as an int64_t.\n\nShift overflow in C\n\nIn the following code, the second shift overflows x because int32_t can’t represent ((1U << 31) - 1) << 2:\n\nint32_t x = (1U << 31) - 1;\nx <<= 2; // Error: the shift result can't fit in x\n\nSolution\n\nUse a larger destination type, such as an int64_t.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Invalid variable-length array | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/invalid-variable-length-array",
    "html": "Overview\n\nUse this check to detect negative array bounds. Variable-length arrays with a negative length have undefined behavior, and may cause stack corruption. Available in Xcode 9 and later.\n\nNegative variable-length array bounds in C\n\nIn the following code, the call to the invalid_index_returning_function function returns a negative number that results in an invalid array:\n\nint invalid_index_returning_function() {\n    return -1;\n}\nint idx = invalid_index_returning_function();\nint array[idx]; // Error: invalid array length\n\nSolution\n\nFix the issue by checking array bounds before constructing arrays.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic."
  },
  {
    "title": "Integer overflow | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/integer-overflow",
    "html": "Overview\n\nOverflows result in undefined behavior. Use this check to detect overflows in addition, subtraction, multiplication, and division. Available in Xcode 9 and later.\n\nSigned addition overflow in C\n\nIn the following code, the x variable has the maximum int32_t value before the addition, and the result of the addition overflows x, which the optimizer may not handle in a predictable way:\n\nint32_t x = (1U << 31) - 1;\nx += 1; // Error: the add result can't fit in x\n\n\nNote\n\nWith the exception of the signed division check, enabling the -fwrapv compiler flag disables UBSan overflow checks.\n\nSolution\n\nOne way to address signed overflow is to use larger types.\n\nIf you don’t need to represent negative numbers, another option is to use unsigned types, which wrap on arithmetic overflow. Alternatively, pass the -fwrapv flag to the compiler to enable signed wraparound on overflow. However, this may adversely impact performance.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Connecting Xcode Cloud to Bitbucket Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/connecting-xcode-cloud-to-bitbucket-cloud",
    "html": "Overview\n\nWhen you first configure your project or workspace to use Xcode Cloud, you need to allow Xcode Cloud to access your Git repository. It uses this access to automatically build and test your code when you make changes to the codebase.\n\nThe person who first configures a project or workspace to use Xcode Cloud must have the administrator permission for the repository on Bitbucket Cloud. If you don’t have this permission, see Connect Xcode Cloud to an admin-managed Git repository.\n\nTo allow Xcode Cloud to access your repository on Bitbucket Cloud:\n\nConfigure your project or workspace to use Xcode Cloud and create your first workflow as described in Configuring your first Xcode Cloud workflow. Xcode analyzes your project to learn which SCM provider you use and then indicates that you use Bitbucket Cloud on the Grant Access to Your Source Code sheet.\n\nClick Grant Access. Xcode opens your browser and takes you to the App Store Connect website.\n\nClick “Complete Step 1 in Bitbucket” to connect Xcode Cloud with your Bitbucket account. This takes you to your account on the Bitbucket Cloud website.\n\nReview the permissions Xcode Cloud requests and allow it to access your repository. This takes you back to the App Store Connect website, which indicates that you successfully connected Xcode Cloud to Bitbucket Cloud.\n\nReturn to Xcode. It indicates that Xcode Cloud can access your source code.\n\nClick Next, complete the configuration of your first workflow, and start your first build.\n\nSee Also\nBitbucket Cloud and Bitbucket Server\nConnecting Xcode Cloud to Bitbucket Server\nAllow Xcode Cloud to access your Bitbucket Server repository."
  },
  {
    "title": "Connecting Xcode Cloud to GitHub | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/connecting-xcode-cloud-to-github",
    "html": "Overview\n\nWhen you first configure your project or workspace to use Xcode Cloud, you need to allow Xcode Cloud to access your Git repository. It uses this access to automatically build and test your code when you make changes to the codebase.\n\nIf you host your code as part of a GitHub organization, the person who first configures a project to use Xcode Cloud must be an organization owner. If you don’t use a GitHub organization, the person who first configures a project to use Xcode Cloud must have the admin permission. If you don’t have the required role or permission, see Connect Xcode Cloud to an admin-managed Git repository.\n\nTo allow Xcode Cloud to access your repository on GitHub:\n\nConfigure your project or workspace to use Xcode Cloud and create your first workflow as described in Configuring your first Xcode Cloud workflow. Xcode analyzes your project to learn which SCM provider you use and then indicates that you use GitHub.\n\nClick Grant Access. Xcode opens your browser and takes you to the App Store Connect website.\n\nClick Complete Step 1 in GitHub to link your Apple ID with your GitHub account to open the GitHub website.\n\nReview the permissions Xcode Cloud requests, and authorize Xcode Cloud to link your GitHub account to your Apple ID.\n\nReview the GitHub app that Apple provides on the GitHub website and choose to only install it for your project’s repository. Don’t install it for every repository. GitHub uses the app to grant Xcode Cloud access to your repository.\n\nClick Install to return to App Store Connect website. It indicates that you successfully connected Xcode Cloud to GitHub.\n\nReturn to Xcode. It indicates that Xcode Cloud can access your source code.\n\nClick Next, complete the configuration of your first workflow, and start your first build.\n\nSee Also\nGitHub and GitHub Enterprise\nConnecting Xcode Cloud to GitHub Enterprise\nAllow Xcode Cloud to access your GitHub Enterprise repository."
  },
  {
    "title": "Connecting Xcode Cloud to Bitbucket Server | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/connecting-xcode-cloud-to-bitbucket-server",
    "html": "Overview\n\nWhen you first configure your project or workspace to use Xcode Cloud, you need to allow Xcode Cloud to access your Git repository. It uses this access to automatically build and test your code when you make changes to the codebase.\n\nThe person who first configures a project or workspace to Xcode Cloud must have the administrator permission for its repository on Bitbucket Server. If you don’t have this permission, see Connect Xcode Cloud to an admin-managed Git repository.\n\nTo allow Xcode Cloud to access your repository on Bitbucket Server:\n\nConfigure your project or workspace to use Xcode Cloud and create your first workflow as described in Configuring your first Xcode Cloud workflow. Xcode analyzes your project to learn which SCM provider you use and then displays the URL of your Bitbucket Server host on the Grant Access to Your Source Code sheet.\n\nClick Grant Access. Xcode opens your browser and takes you to the App Store Connect website.\n\nEnter the host name of your Bitbucket Server instance on the App Store Connect website. When it analyzes your project, Xcode Cloud learns the host name of your Bitbucket Server instance and fills the corresponding field on the website for you.\n\nCheck if the entered host name is correct (for example, make sure it contains a required port) and click Register.\n\nClick “your Bitbucket Server host”. This opens your Bitbucket Server instance and displays your account’s “Personal access tokens” section. Don’t close the tab or window that displays the Xcode Cloud webpage.\n\nClick “Create a token” to start the creation of a personal access token that Xcode Cloud uses to access your repositories.\n\nEnter a name for the access token that’s easy to recognize; for example, Xcode Cloud.\n\nConfigure the token to have the Read permission for projects and the Admin permission for repositories.\n\nCreate the token and make sure to copy and store it in a safe place before continuing. Bitbucket Server won’t show this information again. For example, you can create a secure note in Keychain Access and add the token to it.\n\nSwitch back to the browser tab or window that displays the App Store Connect website where you started connecting Xcode Cloud to Bitbucket Server.\n\nPaste your personal access token into the corresponding field.\n\nClick Register. App Store Connect indicates that you successfully connected Xcode Cloud to Bitbucket Server.\n\nReturn to Xcode. It indicates that Xcode Cloud can access your source code.\n\nClick Next, complete the configuration of your first workflow, and start your first build.\n\nSee Also\nBitbucket Cloud and Bitbucket Server\nConnecting Xcode Cloud to Bitbucket Cloud\nAllow Xcode Cloud to access your Bitbucket Cloud repository."
  },
  {
    "title": "Connecting Xcode Cloud to a self-managed GitLab instance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/connecting-xcode-cloud-to-a-self-managed-gitlab-instance",
    "html": "Overview\n\nWhen you first configure your project or workspace to use Xcode Cloud, you need to allow Xcode Cloud to access your Git repository. It uses this access to automatically build and test your code when you make changes to the codebase.\n\nThe person who first configures a project to use Xcode Cloud must have the maintainer role for the GitLab repository. If you don’t have this role, see Connect Xcode Cloud to an admin-managed Git repository.\n\nTo allow Xcode Cloud to access your self-managed GitLab repository:\n\nConfigure your project or workspace to use Xcode Cloud and create your first workflow as described in Configuring your first Xcode Cloud workflow. Xcode analyzes your project to learn which SCM provider you use and then displays the URL of your self-managed GitLab instance on the Grant Access to Your Source Code sheet.\n\nClick Grant Access. Xcode opens your browser and takes you to the App Store Connect website.\n\nChoose self-managed GitLab to create a GitLab app that manages access to your GitLab repository.\n\nCopy the redirect URI, then click “your GitLab Self-hosted host” to open your GitLab instance’s website. It displays the page to create a new GitLab app.\n\nEnter a name for the GitLab app that’s easy to recognize; for example, Xcode Cloud.\n\nPaste the Xcode Cloud redirect URI into the field on the GitLab webpage for creating the GitLab app.\n\nSelect the checkboxes next to api, read_repository, and read_user to allow the app to access these scopes.\n\nSave the app.\n\nCopy the GitLab app’s Application ID and paste it into the corresponding field on the App Store Connect website, and then repeat this step for the Application Secret.\n\nClick Register on the App Store Connect website to connect Xcode Cloud to the GitLab app.\n\nClick “Authorize in GitLab” top open your GitLab instance’s website and install the GitLab app for your repository.\n\nReview the permissions that Xcode Cloud requests and allow it to access your account. This takes you back to the App Store Connect website, which indicates that you successfully connected Xcode Cloud to your self-managed GitLab instance.\n\nReturn to Xcode. It indicates that Xcode Cloud can access your source code.\n\nClick Next, complete the configuration of your first workflow, and start your first build.\n\nSee Also\nGitLab\nConnecting Xcode Cloud to GitLab\nAllow Xcode Cloud to access your GitLab repository."
  },
  {
    "title": "Connecting Xcode Cloud to GitLab | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/connecting-xcode-cloud-to-gitlab",
    "html": "Overview\n\nWhen you first configure your project or workspace to use Xcode Cloud, you need to allow Xcode Cloud to access your Git repository. It uses this access to automatically build and test your code when you make changes to the codebase.\n\nThe person who first configures a project or workspace to use Xcode Cloud must have the maintainer role for the GitLab repository. If you don’t have this role, see Connect Xcode Cloud to an admin-managed Git repository.\n\nTo allow Xcode Cloud to access your repository on GitLab:\n\nConfigure your project or workspace to use Xcode Cloud and create your first workflow as described in Configuring your first Xcode Cloud workflow. Xcode analyzes your project to learn which SCM provider you use and indicates that you use GitLab on the Grant Access to Your Source Code sheet.\n\nClick Grant Access. Xcode opens your browser and takes you to the App Store Connect website.\n\nClick “Authorize in GitLab” to open the GitLab website and install a GitLab app that manages access to your GitLab repository:\n\nReview the permissions that Xcode Cloud requests and allow it to access your account. This takes you back to the App Store Connect website, which indicates that you successfully connected Xcode Cloud to GitLab.\n\nReturn to Xcode. It indicates that Xcode Cloud can access your source code.\n\nClick Next, complete the configuration of your first workflow, and start your first build.\n\nSee Also\nGitLab\nConnecting Xcode Cloud to a self-managed GitLab instance\nAllow Xcode Cloud to access your self-managed GitLab repository."
  },
  {
    "title": "Defining a custom URL scheme for your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app",
    "html": "Overview\n\nCustom URL schemes provide a way to reference resources inside your app. Users tapping a custom URL in an email, for example, launch your app in a specified context. Other apps can also trigger your app to launch with specific context data; for example, a photo library app might display a specified image.\n\nWhile custom URL schemes are an acceptable form of deep linking, universal links are strongly recommended. For more information on universal links, see Allowing apps and websites to link to your content.\n\nApple supports common schemes associated with system apps, such as mailto, tel, sms, and facetime. You can define your own custom scheme and register your app to support it.\n\nWarning\n\nURL schemes offer a potential attack vector into your app, so make sure to validate all URL parameters and discard any malformed URLs. In addition, limit the available actions to those that don’t risk the user’s data. For example, don’t allow other apps to directly delete content or access sensitive information about the user. When testing your URL-handling code, make sure your test cases include improperly formatted URLs.\n\nTo support a custom URL scheme:\n\nDefine the format for your app’s URLs.\n\nRegister your scheme so that the system directs appropriate URLs to your app.\n\nHandle the URLs that your app receives.\n\nURLs must start with your custom scheme name. Add parameters for any options your app supports. For example, a photo library app might define a URL format that includes the name or index of a photo album to display. Examples of URLs for such a scheme could include the following:\n\nmyphotoapp:albumname?name=\"albumname\"\nmyphotoapp:albumname?index=1\n\n\nClients craft URLs based on your scheme and ask your app to open them by calling the open(_:options:completionHandler:) method of UIApplication. Clients can ask the system to inform them when your app opens the URL.\n\nlet url = URL(string: \"myphotoapp:Vacation?index=1\")\n\n\nUIApplication.shared.open(url!) { (result) in\n    if result {\n       // The URL was delivered successfully!\n    }\n}\n\nRegister your URL scheme\n\nURL scheme registration specifies which URLs to redirect to your app. Register your scheme in Xcode from the Info tab of your project settings. Update the URL Types section to declare all of the URL schemes your app supports, as shown in the following illustration.\n\nIn the URL Schemes box, specify the prefix you use for your URLs.\n\nChoose a role for your app: either an editor role for URL schemes you define, or a viewer role for schemes your app adopts but doesn’t define.\n\nSpecify an identifier for your app.\n\nThe identifier you supply with your scheme distinguishes your app from others that declare support for the same scheme. To ensure uniqueness, specify a reverse DNS string that incorporates your company’s domain and app name. Although using a reverse DNS string is a best practice, it doesn’t prevent other apps from registering the same scheme and handling the associated links. Use universal links instead of custom URL schemes to define links that are uniquely associated with your website.\n\nNote\n\nIf multiple apps register the same scheme, the app the system targets is undefined. There’s no mechanism to change the app or to change the order apps appear in a Share sheet.\n\nSome URL schemes are reserved for system use. The system directs well-known types of URLs to the corresponding system apps, and well-known http–based URLs to specific apps such as Maps, YouTube, and Music. For information about the schemes supported by Apple, see Apple URL Scheme Reference.\n\nHandle incoming URLs\n\nWhen another app opens a URL containing your custom scheme, the system launches your app, if necessary, and brings it to the foreground. The system delivers the URL to your app by calling your app delegate’s application(_:open:options:) method. Add code to the method to parse the contents of the URL and take appropriate actions. To ensure the URL is parsed correctly, use NSURLComponents APIs to extract the components. Obtain additional information about the URL, such as which app opened it, from the system-provided options dictionary.\n\nfunc application(_ application: UIApplication,\n                 open url: URL,\n                 options: [UIApplicationOpenURLOptionsKey : Any] = [:] ) -> Bool {\n\n\n    // Determine who sent the URL.\n    let sendingAppID = options[.sourceApplication]\n    print(\"source application = \\(sendingAppID ?? \"Unknown\")\")\n\n\n    // Process the URL.\n    guard let components = NSURLComponents(url: url, resolvingAgainstBaseURL: true),\n        let albumPath = components.path,\n        let params = components.queryItems else {\n            print(\"Invalid URL or album path missing\")\n            return false\n    }\n\n\n    if let photoIndex = params.first(where: { $0.name == \"index\" })?.value {\n        print(\"albumPath = \\(albumPath)\")\n        print(\"photoIndex = \\(photoIndex)\")\n        return true\n    } else {\n        print(\"Photo index missing\")\n        return false\n    }\n}\n\n\nThe system also uses your app delegate’s application(_:open:options:) method to open custom file types that your app supports.\n\nIf your app has opted into Scenes, and your app isn’t running, the system delivers the URL to the scene(_:willConnectTo:options:) delegate method after launch, and to scene(_:openURLContexts:) when your app opens a URL while running or suspended in memory.\n\nfunc scene(_ scene: UIScene, \n           willConnectTo session: UISceneSession, \n           options connectionOptions: UIScene.ConnectionOptions) {\n\n\n    // Determine who sent the URL.\n    if let urlContext = connectionOptions.urlContexts.first {\n\n\n        let sendingAppID = urlContext.options.sourceApplication\n        let url = urlContext.url\n        print(\"source application = \\(sendingAppID ?? \"Unknown\")\")\n        print(\"url = \\(url)\")\n\n\n        // Process the URL similarly to the UIApplicationDelegate example.\n    }\n\n\n    /*\n     *\n     */\n}\n"
  },
  {
    "title": "Analyzing your Metal workload | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-your-metal-workload",
    "html": "Overview\n\nThe Metal debugger provides useful tools for analyzing many aspects of how your app uses the GPU.\n\nAfter capturing a Metal workload (see Capturing a Metal workload in Xcode) or replaying a GPU trace (see Replaying a GPU trace file), the Metal debugger presents the Summary viewer. The Summary viewer includes a preview of the last presented drawable in your app on the left, several statistics on the right, and a list of automatically generated recommendations, called Insights, at the bottom.\n\nTo the left of the Summary viewer is the Debug navigator, which enables quick access to top-level information about your Metal workload. You can explore all of the GPU commands in your capture, as well as all of the pipeline states it uses.\n\nView statistics for your Metal workload\n\nThe Metal debugger automatically calculates several statistics and displays them on the right side of the Summary viewer.\n\nThe Overview section includes the number of command buffers, command encoders, and draw commands or compute dispatches. It takes CPU time to encode commands, and GPU time to execute them. If your app is creating too many command buffers or command encoders that start to have a significant impact on performance, consider reducing the workload. You can click the Show Dependencies button to open the Dependencies viewer and learn how your command encoders connect with one another (see Analyzing resource dependencies).\n\nThe Performance section includes the total GPU time and the number of vertices. If your workload has a high GPU time, consider optimizing its performance (see Optimizing GPU performance). You can also click the Show Performance button to display the Performance timeline and discover which aspects of your Metal workload are taking the most time (see Analyzing Apple GPU performance using a visual timeline).\n\nNote\n\nIf you don’t select the Profile after Replay checkbox in the Metal Capture popover (see Capturing a Metal workload in Xcode) or the Profile GPU Trace checkbox in the Replay window (see Replaying a GPU trace file), the performance section doesn’t show any statistics. To see the statistics, click the Profile button and wait for profiling to finish.\n\nThe Memory section includes a brief overview of GPU memory for various resource types, such as textures and buffers. If your Metal workload is using a large amount of memory, consider optimizing the memory use. You can also click the Show Memory button to open the Memory viewer and discover which aspects of your Metal workload are using the most memory (see Analyzing memory usage).\n\nBrowse API calls\n\nBy default, the Metal debugger shows an outline of captured Metal commands — grouped by command buffers, passes, and debug groups — in the Debug navigator. In addition, for render passes, the outline includes a list of render attachment thumbnail images.\n\nIt’s common for a render pass to issue a massive number of draw commands. You can skim through the draw commands by moving your pointer over the rows to quickly locate a draw command of interest. The Metal debugger shows a preview of the first attachment in the popover.\n\nBrowse pipeline states\n\nInstead of viewing the hierarchy of Metal commands, you can begin exploring your captured Metal workload from pipeline states. Click the Outline popup menu and select Group by Pipeline State.\n\nThe Metal debugger shows a list of pipeline states. Expanding a pipeline state allows you to see its shaders. Further expansion shows all the draw commands and compute dispatches that use that pipeline state.\n\nWith profiling data, the Debug navigator displays the percentage of samples from the shaders of each pipeline state when running the workload with overlap. In a shader-bound workload, this sorted list of pipeline states is helpful in identifying the most expensive pipeline state.\n\nImprove your Metal workload with Insights\n\nThe Metal debugger automatically generates a number of recommendations, called Insights, and includes them at the bottom of the Summary viewer to help you improve your Metal workload. The Insights information includes the following categories:\n\nMemory\n\nMemory insights provide recommendations to reduce the amount of GPU memory that your workload uses. By default, Xcode sorts the recommendations by the amount of memory saved, so you can focus on the biggest potential wins first. In the following example, setting the wrong storage mode results in an additional 10.2 MB of GPU memory usage. The developer of this app can save that memory by following the advice and switching to memoryless.\n\nBandwidth\n\nBandwidth insights provide recommendations to reduce the amount of memory bandwidth, which is particularly important on Apple GPUs. Transfers to and from external memory often result in decreased power efficiency and slower performance. To learn more, see Tailor Your Apps for Apple GPUs and Tile-Based Deferred Rendering.\n\nPerformance\n\nPerformance insights provide recommendations to increase your app’s performance by avoiding expensive and redundant operations in the rendering pipeline.\n\nAPI Usage\n\nAPI Usage insights provide recommendations to improve your Metal API usage. Fewer API calls can lead to less CPU time. In the following example, you can see that the vertex and fragment buffers are redundantly bound for each draw command:\n\nClick the Insights button next to the command in the Debug navigator to see in-depth details and recommendations that may improve your command.\n\nLimit your scope with filters\n\nUse the filter bar at the bottom of the Debug navigator to adjust filtering criteria. You can type filter terms into the filter bar’s text field, and the outline in the Debug navigator shows only rows with labels that match those filter terms.\n\nWhen there are two or more filter terms, you can click the filter button to choose whether to match any or all of the terms. For any filter term, you can click it to choose to include or exclude resources that match that term.\n\nThe following additional filter tools appear to the right:\n\nShow only related stack frames\n\nAfter capturing a fresh GPU trace, you can inspect the call stack for each Metal command. This allows filtering for the stack frames in your project.\n\nShow only calls with issues\n\nThis allows filtering for just the Metal commands with insights from the Metal debugger.\n\nShow only markers and commands\n\nThis allows filtering for Metal commands like draw commands, compute dispatches, and blit operations.\n\nSee Also\nMetal workload analysis\nAnalyzing resource dependencies\nAvoid unnecessary work in your Metal app by understanding the relationships between resources.\nAnalyzing memory usage\nManage your Metal app’s memory usage by inspecting its resources.\nAnalyzing Apple GPU performance using a visual timeline\nLocate performance issues using the Performance timeline.\nAnalyzing Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands.\nAnalyzing non-Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands."
  },
  {
    "title": "Capturing a Metal workload programmatically | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/capturing-a-metal-workload-programmatically",
    "html": "Overview\n\nUse the MTLCaptureManager to programmatically capture information about commands you send to a specific device object. For example, you can capture a specific frame or part of a frame, depending on your needs, by implementing a custom UI that triggers a capture, or by programmatically triggering a capture at runtime from within your app.\n\nEnable capturing programmatically\n\nTo enable Metal capture in your app, add the MetalCaptureEnabled key to your Info.plist file with a value of YES. In Xcode’s property list editor, this key appears as Metal Capture Enabled.\n\nAlternatively, in macOS 14 and later, you can set the environment variable on your Metal app: MTL_CAPTURE_ENABLED=1.\n\nTip\n\nEnabling Metal capture has a tiny, but measurable, effect on your app’s CPU processing time. You may want to set the value of this key using a build setting in your project so that you can enable it for some builds, but not for your final release build.\n\nCapture a device or command queue\n\nCreate an MTLCaptureDescriptor object that defines which commands you want to record and what needs to happen after the capture is complete. To capture commands for a specific MTLDevice or MTLCommandQueue, set the capture descriptor’s captureObject property to point at the specific object to track, and call the startCapture(with:) method. To stop capturing commands, call the stopCapture() method.\n\nfunc triggerProgrammaticCapture(device: MTLDevice) {\n    let captureManager = MTLCaptureManager.shared()\n    let captureDescriptor = MTLCaptureDescriptor()\n    captureDescriptor.captureObject = self.device\n    do {\n        try captureManager.startCapture(with: captureDescriptor)\n    } catch {\n        fatalError(\"error when trying to capture: \\(error)\")\n    }\n}\n\n\nfunc runMetalCommands(commandQueue: MTLCommandQueue) {\n    let commandBuffer = commandQueue.makeCommandBuffer()!\n    // Do Metal work.\n    commandBuffer.commit()\n    let captureManager = MTLCaptureManager.shared()\n    captureManager.stopCapture()\n}\n\n\nThe capture manager captures commands only within MTLCommandBuffer objects that you create after the capture starts and commit before the capture stops.\n\nTip\n\nWhen you capture a frame programmatically, you can capture Metal commands that span multiple frames. For example, by calling startCapture at the start of frame 1 and stopCapture after frame 3, the traces contain command data from all the buffers that the system commits in the three frames.\n\nCapture specific commands with a capture scope\n\nTo learn how to add custom scopes to your app, see Creating and using custom capture scopes. To capture commands using a custom scope, create an MTLCaptureScope object and set the capture descriptor’s captureObject property to point to it.\n\nImportant\n\nSet the file extension of the outputURL to .gputrace to ensure that you can replay it later in the Metal debugger. For more information on replaying GPU trace files, see Replaying a GPU trace file.\n\nfunc setupProgrammaticCaptureScope(device: MTLDevice) {\n    myCaptureScope = MTLCaptureManager.shared().makeCaptureScope(device: device)\n    myCaptureScope?.label = \"My Capture Scope\"\n}\n\n\nfunc triggerProgrammaticCaptureScope() {\n    guard let captureScope = myCaptureScope else { return }\n    let captureManager = MTLCaptureManager.shared()\n    let captureDescriptor = MTLCaptureDescriptor()\n    captureDescriptor.captureObject = captureScope\n    do {\n        try captureManager.startCapture(with: captureDescriptor)\n    } catch {\n        fatalError(\"error when trying to capture: \\(error)\")\n    }\n}\n\n\nTo define boundaries for the scoped capture, call the MTLCaptureScope object’s begin() and end() methods just before and after the commands that you want to capture. Xcode automatically stops capturing when your app reaches the corresponding end() method of the capture scope.\n\nfunc runMetalCommands(commandQueue: MTLCommandQueue) {\n    myCaptureScope?.begin()\n    let commandBuffer = commandQueue.makeCommandBuffer()!\n    // Do Metal work.\n    commandBuffer.commit()\n    myCaptureScope?.end()\n}\n\n\nImportant\n\nThe capture scope captures commands only within MTLCommandBuffer objects that you create after the scope begins and commit before the scope ends.\n\nSave the capture to your computer\n\nIf you want to analyze the capture later, you can skip launching the Metal debugger and save the GPU command information to a GPU trace file. Call supportsDestination(_:) on the capture manager to make sure the feature is available before attempting to record a trace file.\n\nlet captureManager = MTLCaptureManager.shared()\n\n\nguard captureManager.supportsDestination(.gpuTraceDocument) else {\n    print(\"Capturing to a GPU trace file isn't supported.\")\n    return\n}\n\n\nThen, set the capture descriptor’s destination property to MTLCaptureDestination.gpuTraceDocument and specify the file’s destination.\n\nlet captureDescriptor = MTLCaptureDescriptor()\ncaptureDescriptor.captureObject = self.device\ncaptureDescriptor.destination = .gpuTraceDocument\ncaptureDescriptor.outputURL = self.traceURL\n...\n\n\nFor more information on replaying GPU trace files, see Replaying a GPU trace file.\n\nSee Also\nEssentials\nCapturing a Metal workload in Xcode\nAnalyze your app’s performance by configuring your project to leverage the Metal debugger.\nReplaying a GPU trace file\nDebug and profile your app’s performance using a GPU trace file in the Metal debugger.\nInvestigating visual artifacts\nDiscover, diagnose, and fix visual artifacts in your app with the Metal debugger.\nOptimizing GPU performance\nFind and address performance bottlenecks using the Metal debugger."
  },
  {
    "title": "Supporting associated domains | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/supporting-associated-domains",
    "html": "Overview\n\nAssociated domains establish a secure association between domains and your app so you can share credentials or provide features in your app from your website. For example, an online retailer may offer an app to accompany their website and enhance the user experience.\n\nShared web credentials, universal links, Handoff, and App Clips all use associated domains. Associated domains provide the underpinning to universal links, a feature that allows an app to present content in place of all or part of its website. Users who don’t download the app get the same information in a web browser instead of the native app.\n\nTo associate a website with your app, you need to have the associated domain file on your website and the appropriate entitlement in your app. The apps in the apple-app-site-association file on your website must have a matching Associated Domains Entitlement.\n\nAdd the associated domain file to your website\n\nWhen a user installs your app, the system attempts to download the associated domain file and verify the domains in your entitlement.\n\nNote\n\nIf your site uses multiple subdomains (such as example.com, www.example.com, and support.example.com), each requires its own entry in the Associated Domains Entitlement, and each must serve its own apple-app-site-association file.\n\nTo add the associated domain file to your website, create a file named apple-app-site-association (without an extension). Update the JSON code in the file for the services you support on the domain. For universal links, be sure to list the app identifiers for your domain in the applinks service. Similarly, if you create an App Clip, be sure to list your App Clip’s app identifier using the appclips service.\n\nThe following JSON code represents the contents of a simple association file:\n\n{\n  \"applinks\": {\n      \"details\": [\n           {\n             \"appIDs\": [ \"ABCDE12345.com.example.app\", \"ABCDE12345.com.example.app2\" ],\n             \"components\": [\n               {\n                  \"#\": \"no_universal_links\",\n                  \"exclude\": true,\n                  \"comment\": \"Matches any URL with a fragment that equals no_universal_links and instructs the system not to open it as a universal link.\"\n               },\n               {\n                  \"/\": \"/buy/*\",\n                  \"comment\": \"Matches any URL with a path that starts with /buy/.\"\n               },\n               {\n                  \"/\": \"/help/website/*\",\n                  \"exclude\": true,\n                  \"comment\": \"Matches any URL with a path that starts with /help/website/ and instructs the system not to open it as a universal link.\"\n               },\n               {\n                  \"/\": \"/help/*\",\n                  \"?\": { \"articleNumber\": \"????\" },\n                  \"comment\": \"Matches any URL with a path that starts with /help/ and that has a query item with name 'articleNumber' and a value of exactly four characters.\"\n               }\n             ]\n           }\n       ]\n   },\n   \"webcredentials\": {\n      \"apps\": [ \"ABCDE12345.com.example.app\" ]\n   },\n\n\n    \"appclips\": {\n        \"apps\": [\"ABCED12345.com.example.MyApp.Clip\"]\n    }\n}\n\n\nThe appIDs and apps keys specify the application identifiers for the apps that are available for use on this website along with their service types. Use the following format for the values in these keys:\n\n<Application Identifier Prefix>.<Bundle Identifier>\n\n\nThe details dictionary only applies to the applinks service type; other service types don’t use it. The components key is an array of dictionaries that provides pattern matching for components of the URL.\n\nAfter you construct the association file, place it in your site’s .well-known directory. The file’s URL should match the following format:\n\nhttps://<fully qualified domain>/.well-known/apple-app-site-association\n\n\nYou must host the file using https:// with a valid certificate and with no redirects.\n\nAdd the associated domains entitlement to your app\n\nTo set up the entitlement in your app, open the target’s Signing & Capabilities tab in Xcode and add the Associated Domains capability. If they’re not already present, this step adds the Associated Domains Entitlement to your app and the associated domains feature to your app ID.\n\nImportant\n\nFor a single-target watchOS apps, add the Associated Domains capability to the watchOS app target. For watchOS apps with separate WatchKit extensions, you must add the Associated Domains capability to the WatchKit Extension target.\n\nTo add your domain to the entitlement, click Add (+) at the bottom of the Domains table to add a placeholder domain. Replace the placeholder with the appropriate prefix for the service your app supports and your site’s domain. Make sure to only include the desired subdomain and the top-level domain. Don’t include path and query components or a trailing slash (/).\n\nAdd the domains that share credentials with your app. For services other than appclips, you can prefix a domain with *. to match all of its subdomains.\n\nEach domain you specify uses the following format:\n\n<service>:<fully qualified domain>\n\n\nStarting with macOS 11 and iOS 14, apps no longer send requests for apple-app-site-association files directly to your web server. Instead, they send these requests to an Apple-managed content delivery network (CDN) dedicated to associated domains.\n\nWhile you’re developing your app, if your web server is unreachable from the public internet, you can use the alternate mode feature to bypass the CDN and connect directly to your private domain.\n\nYou enable an alternate mode by adding a query string to your associated domain’s entitlement as follows:\n\n<service>:<fully qualified domain>?mode=<alternate mode>\n\n\nFor more information about alternate modes, see Associated Domains Entitlement. For information about universal links, see Allowing apps and websites to link to your content. For information about Handoff, see Implementing Handoff in Your App. For information about App Clips, see Configuring the launch experience of your App Clip.\n\nImportant\n\nApple’s content delivery network requests the apple-app-site-association file for your domain within 24 hours. Devices check for updates approximately once per week after app installation.\n\nTopics\nEntitlements\nAssociated Domains Entitlement\nThe associated domains for specific services, such as shared web credentials, universal links, and App Clips.\nServices\napplinks\nThe root object for a universal links service definition."
  },
  {
    "title": "Analyzing draw command and compute dispatch performance with pipeline statistics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-draw-command-and-compute-dispatch-performance-with-pipeline-statistics",
    "html": "Overview\n\nThe Pipeline Statistics viewer displays each shader stage in your pipeline state, the amount of time it took to complete, and the GPU activities it performed during that time.\n\nInterpret the GPU activities\n\nVarious GPU activities appear with bar charts for compiler statistics and runtime profiling statistics.\n\nGPU activity\n\n\t\n\nExplanation and recommendations\n\n\n\n\nALU\n\n\t\n\nThe amount of time that the GPU spends in the arithmetic logic unit. Change floats to half-floats where possible to reduce the time in the ALU. Also, try to minimize your use of complex instructions like sqrt, sin, cos, and recip.\n\n\n\n\nMemory\n\n\t\n\nThe amount of time that the GPU spends waiting for access to your app’s buffers or texture memory. Reduce time by downsampling textures, or, if you’re not spending much time in memory, improve your texture resolution instead.\n\n\n\n\nControl flow\n\n\t\n\nThe amount of time that the GPU spends in conditional, increment, or jump instructions as a result of branches or loops in your shader. Use a constant iteration count to minimize control flow time for loops because the Metal compiler can generate optimized code in those cases.\n\n\n\n\nSynchronization\n\n\t\n\nThe amount of time that the GPU spends waiting for a required resource or event before execution can begin. Synchronization types are described below.\n\n\n\n\nSynchronization (wait memory)\n\n\t\n\nThe amount of time that the GPU spends waiting for dependent memory accesses, such as texture sampling or buffer read/write.\n\n\n\n\nSynchronization (wait pixel)\n\n\t\n\nThe amount of time that the GPU spends waiting for underlying pixels to release resources. In addition to color attachments, pixels can come from depth or stencil buffers or user-defined resources. Blending is a common cause of pixel waiting. Use raster order groups to reduce the wait time.\n\n\n\n\nSynchronization (barrier)\n\n\t\n\nThe amount of time that the GPU spends when a thread reaches a barrier and the GPU waits for remaining threads in the same group to arrive at the barrier before proceeding.\n\n\n\n\nSynchronization (atomics)\n\n\t\n\nThe amount of time that the GPU spends on atomic instructions.\n\nInspect the GPU time of the commands in the pass\n\nThe bottom portion of the Pipeline Statistics viewer displays the GPU time in the Total column for each command in the pass so you can compare their respective elapsed times.\n\nSee Also\nMetal command analysis\nInspecting the bound resources for a command\nDiscover issues by examining the bound resources at any point in an encoder.\nInspecting the geometry of a draw command\nFind problems in your app’s vertex, object, or mesh function by examining the current geometry.\nInspecting the attachments of a draw command\nDiscover attachment issues by inspecting individual pixels and samples.\nDebugging the shaders within a draw command or compute dispatch\nIdentify and fix problematic shaders in your app using the shader debugger.\nAnalyzing draw command and compute dispatch performance with GPU counters\nIdentify issues within your frame capture by examining performance counters."
  },
  {
    "title": "Configuring start conditions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-start-conditions",
    "html": "Overview\n\nXcode Cloud watches your Git repository for changes, checks whether a change meets start conditions you configure for your workflows, and starts a build when a change meets one of the conditions. This makes configuring start conditions a key task when you create custom Xcode Cloud workflows.\n\nYou can configure your Xcode Cloud workflow with any of the following start conditions:\n\nBranch Changes\n\nXcode Cloud starts a new build if any branch, a specific branch, or several configured branches change.\n\nPull Request Changes\n\nXcode Cloud starts a new build if you create a new pull request (PR) or if you update an existing PR.\n\nTag Changes\n\nXcode Cloud starts a new build if you create or update a Git tag.\n\nOn a Schedule for a Branch\n\nXcode Cloud starts a new build on a configured schedule.\n\nManual Start\n\nXcode Cloud starts a new build when you manually request it.\n\nBy configuring several start conditions for one workflow and reusing the workflow at different moments in your development life cycle, you can reduce the number of workflows you need to maintain. For example, you can configure one workflow to perform verifications for each change to a branch or a pull request — you don’t need to configure two separate workflows.\n\nFor additional information about Xcode Cloud workflows, see Xcode Cloud workflow reference, WWDC21: Explore Xcode Cloud workflows, and WWDC21: Customize your Advanced Xcode Cloud workflows.\n\nEdit, add, and remove start conditions\n\nTo make changes to a workflow’s start conditions, open your workflow in Xcode, choose an already configured start condition in the Start Conditions section, or add a new start condition using the Add button (+) next to Start Conditions.\n\nAdditionally, configure your workflow and its start conditions in the Xcode Cloud tab on the App Store Connect website. This is especially convenient if you manage Xcode Cloud workflows but don’t have access to the Xcode project — a common case in a corporate context.\n\nNote\n\nYou need to use Xcode to initially configure your project or workspace to use Xcode Cloud. After you’ve started your first build, you can manage workflows in either Xcode or App Store Connect.\n\nReview the default start condition\n\nWhen you create a new workflow, Xcode configures a default workflow that uses the Branch Changes start condition for each change to your repository’s default branch. Even if the workflow doesn’t take a lot of time to complete, starting a new build for every change from your repository’s default branch can be impractical. For example, a workflow that runs UI tests on many simulated devices can take a significant amount of time and slow your development cycle. To start builds less frequently, use a different start condition or configure Xcode Cloud to monitor or ignore changes to specific files or folders as described in Monitor or ignore specific files and folders below.\n\nMonitor custom branches for changes\n\nBy default, workflows use the Branch Changes start condition for your Git repository’s default branch. However, you might want to configure Xcode Cloud to monitor a different branch, several branches, or every branch for changes.\n\nFirst, open your workflow in Xcode or App Store Connect. Select or add the Branch Changes start condition, then choose from the following settings:\n\nChoose the Any Branch setting to monitor every branch for changes. Note that this setting can start a lot of builds unless you set the Auto-cancel Builds setting or configure custom conditions.\n\nChoose the Custom Branches setting to add one or more custom branches. Existing branches appear as you type, and both Xcode and App Store Connect display a warning if you enter a branch that doesn’t exist in your remote Git repository.\n\nTip\n\nInstead of specifying several custom branches, configure a workflow to start a build from every branch that starts with a custom string. For example, enter feature and choose “Branches beginning with feature”.\n\nYou can further customize the Branch Changes start condition with the Custom Conditions setting. For more information, see Monitor or ignore specific files and folders below.\n\nStart builds for changes to a pull request\n\nBy using pull requests, you use a collaborative software development process that helps with identifying errors. To help detect issues in a PR, add the Pull Request Changes start condition to a workflow. Xcode Cloud starts a new build when you create or update a PR.\n\nWhen it detects a new or updated PR, Xcode Cloud checks out the PR’s source branch — the branch that contains your changes — and the PR’s target branch. It then merges both branches in a temporary environment and performs the workflow’s configured actions.\n\nBy default, the Pull Request Changes condition starts a new build for each new or updated PR. However, you can choose from the following settings for the Pull Request Changes start condition to limit when Xcode Cloud performs the workflow:\n\nConfigure the Source Branch setting. Choose Custom Branches and specify one or more custom branches. Xcode Cloud only performs the workflow if a pull request change involves the specified source branches.\n\nConfigure the Target Branch setting. Choose Custom Branches to only start a build if the PR involves one or more custom target branches.\n\nInstead of specifying several custom source and target branches, configure a workflow to start a build if a PR involves branches that start with a custom string. For example, use Any Branch for the Source Branch setting. Then, change the Target Branch setting to Custom Branches and enter release. As a result, Xcode Cloud starts a build from every PR that targets branches that start with release.\n\nYou can further customize the Pull Request Changes start condition with the Custom Conditions setting. For more information, see Monitor or ignore specific files and folders below.\n\nStart builds for new or updated Git tags\n\nSimilar to how you can configure a workflow that starts a new build if a branch changes, configure Xcode Cloud to start a build if you create or update a Git tag. Add the Tag Changes start condition in Xcode or App Store Connect to a workflow and choose between:\n\nAny Tag\n\nThis setting tells Xcode Cloud to start a new build every time you create or update a tag.\n\nCustom Tags\n\nThis setting tells Xcode Cloud to monitor one or more custom tags for changes. Both Xcode and App Store Connect display a warning if you enter a tag that doesn’t exist on your remote Git repository.\n\nTip\n\nInstead of specifying several custom tags, configure a workflow to start a build from every tag that starts with a given string. For example, enter v1 and choose “Tags beginning with v1”.\n\nYou can further customize the Branch Changes start condition with the Custom Conditions setting.\n\nMonitor or ignore specific files and folders\n\nIf you add the Branch Changes, Pull Request Changes, or Tag Changes start condition to a workflow, there’s a chance Xcode Cloud starts new builds too often. For example, your team may use a single repository for all of your team’s code and not every change affects your app. In contrast, you might want Xcode Cloud to only start a build if a specific file or folder changes. To accommodate these use cases, further configure start conditions to ignore changes to custom files and folders or to only start a build if a specified file or folder changes.\n\nFirst, open a workflow in Xcode or App Store Connect and select a start condition. Change the Files and Folders setting to Custom Conditions. Then, add one or more custom conditions to tell Xcode Cloud to ignore changes to specific files and folders, or to start a build in response to changes to specific files or folders.\n\nYou can configure a custom condition to either start or skip a build if:\n\nAny file in any folder or a custom folder changes.\n\nA specific file in any folder or in a custom folder changes.\n\nFiles with a provided file extension in any folder or in a custom folder change.\n\nFor example:\n\nChoose Start a Build, choose Any File, then choose a folder to start a build if the contents of the selected folder change.\n\nChoose Don’t Start a Build, choose Filename, enter a filename, and then choose any folder to configure a workflow to not start a build for any files that match the name.\n\nChoose Start a Build, choose File Extension, enter a file extension, and then choose a folder to start a build if files with the entered file extension change.\n\nIf you choose Filename, don’t include a wildcard like * in the filename. For example, don’t enter Release-Notes-*.md. If you tell Xcode Cloud to monitor a specific folder for changes, it recursively monitors files contained in the given folder. For example, if you organize your code in a Source folder and tell Xcode Cloud to monitor it for changes, changes to files in Source/iOS start a new Xcode Cloud build.\n\nNote\n\nA start condition’s Custom Conditions setting can either start or skip a build, not both.\n\nSkip a build\n\nWhen you push changes to your Git repository in quick succession — for example, in early development of your app — you may want Xcode Cloud to ignore a change and not start a build. To tell Xcode Cloud to skip a build when you push changes, include [ci skip] in the title or message of the latest commit you push to your remote repository.\n\nIf you require Xcode Cloud builds or actions to succeed before users can merge a PR, the website for a PR indicates that Xcode Cloud skipped a build for the most recent change. To learn more about configuring requirements for PRs, see Configuring requirements for merging a pull request.\n\nSet a schedule\n\nIn addition to starting a build when a change meets a start condition, you can configure a workflow to start a build based on a schedule. For example, distributing a new version of your app to testers with TestFlight for every branch or pull request change will overwhelm your testers. Instead, distribute a new version based on a schedule; for example, once per week.\n\nTo configure a workflow to start a build based on a schedule, add the On a Schedule for a Branch start condition and specify the frequency, time, and branch.\n\nThe following screenshot shows a workflow that starts a build on every business day at 10:00 p.m. Central European Time from the main branch:\n\nManually start a build\n\nTeam members can manually start an Xcode Cloud build for workflows you configure with specific start conditions. To support starting a build manually without tying it to a Git event or a schedule, add a Manual Start condition and configure the specific branches, tags, and pull requests to which it applies."
  },
  {
    "title": "Configuring your Xcode Cloud workflow’s actions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-your-xcode-cloud-workflow-s-actions",
    "html": "Overview\n\nWith Xcode Cloud, you can create custom workflows to adopt a flexible continuous integration and delivery (CI/CD) practice. For example, configure a workflow that verifies changes by building and testing your app or framework, a workflow that performs in-depth verifications, another workflow to regularly deliver a new version of your app to testers, and so on. At the core of each workflow are the actions Xcode Cloud performs during a build.\n\nIf you’re new to creating custom workflows, see Developing a workflow strategy for Xcode Cloud. For more information on other workflow settings, see Xcode Cloud workflow reference.\n\nYou need to use Xcode to initially configure your project or workspace to use Xcode Cloud. However, after you’ve started your first build, you can edit and create workflows in either Xcode or App Store Connect.\n\nFor additional information about Xcode Cloud workflows, see WWDC21: Explore Xcode Cloud workflows and WWDC21: Customize your advanced Xcode Cloud workflows.\n\nReview actions\n\nA workflow can perform one or many actions that match your project or workflow’s scheme actions. Choose from the following actions:\n\nBuild\n\nTest\n\nAnalyze\n\nArchive\n\nFor example, configure a workflow to perform the build, test, and archive actions for each platform.\n\nA good practice to follow when using Xcode Cloud is to create a set of workflows with each performing different actions. For example, you could have one workflow for building and testing actions whenever there’s a change to a branch or pull request, and you could have a second workflow that performs build, test, analyze, and archive actions whenever you merge code into your main branch.\n\nWhen Xcode Cloud performs an action, it:\n\nCreates a temporary build environment.\n\nClones your source code from the connected repository.\n\nResolves dependencies.\n\nRuns custom build scripts, if applicable, as described in Writing custom build scripts.\n\nPerforms the action.\n\nSaves artifacts.\n\nNote\n\nXcode Cloud performs each action separately in a temporary build environment. As a result, an action’s artifacts might not be available to other actions. For example, a test action’s test result bundle isn’t available to other actions.\n\nAdd an action to a workflow\n\nTo add an action to a workflow, first open or create a workflow in Xcode or in the Xcode Cloud tab on the App Store Connect website. Click the Add button (+) next to Actions, choose an action, enter required information, choose from available settings, and save the workflow. Then, manually start a new build or wait for Xcode Cloud to start a new build.\n\nThe following screenshot shows Xcode’s Edit Workflow sheet for a workflow that performs all four available actions:\n\nAdd a build action\n\nVerifying that a change always compiles is one of the key tasks of a CI/CD. With Xcode Cloud, you can perform this verification automatically with a build action.\n\nTo configure a workflow’s build action to a workflow:\n\nOpen or create a workflow in Xcode or in the Xcode Cloud tab on the App Store Connect website.\n\nClick the Add button next to Actions, and choose Build.\n\nChoose a platform and a scheme; for example, choose macOS and your macOS app’s corresponding scheme to build your Mac app.\n\nChoose whether you want to build the app for any device or any simulator destinations. For a Mac app, choose between building macOS and Mac Catalyst destinations.\n\nThe following screenshot shows an Xcode Cloud workflow for the Fruta app. It includes two build actions: one action builds the iOS app, and the other action builds the macOS app:\n\nWhen Xcode Cloud performs a build action, it accesses your source code and runs the xcodebuild build command to create the build product. Upon completion, Xcode Cloud makes the following artifacts available: the build product, build logs, and the result bundle.\n\nAdd a test action\n\nVerifying a change by running your tests is another key task of a CI/CD practice. While every project comes with its unique requirements, it usually makes sense to configure two workflows that perform a test action:\n\nA workflow that frequently runs basic, short running tests.\n\nA workflow that runs more extensive, long-running tests less frequently.\n\nNote\n\nAdding a test action builds your app or framework for testing. You don’t need to add a build action to run your tests.\n\nTo add a test action to a workflow:\n\nOpen or create a workflow in Xcode or in the Xcode Cloud tab on the App Store Connect website.\n\nClick the Add button next to Actions, and choose Test.\n\nChoose a platform and a scheme for the test action.\n\nDecide if you want a build to fail when the test action fails, then choose “Required To Pass” or “Not Required to Pass,” accordingly.\n\nChoose Use Scheme Settings if you want the test action to use the selected scheme’s configuration. Alternatively, choose a test plan if you use them. For more information on test plans, see WWDC19: Testing in Xcode and WWDC20: Get your test results faster.\n\nAdd at least one destination by clicking the Add button. Available destinations depend on the workflow’s environment setting. A higher number of destinations increases the time it takes Xcode Cloud to complete a build.\n\nThe following screenshot shows an Xcode Cloud workflow for the Fruta app. It includes two test actions: one action tests the iOS app, and the other action tests the macOS app.\n\nA test action runs in two separate phases: In the first phase, Xcode Cloud accesses your source code and creates test products using the xcodebuild build-for-testing command. In the second phase, Xcode Cloud uses the test products it creates in the first phase to run your tests using the xcodebuild test-without-building command.\n\nNote\n\nThe source code isn’t available when Xcode Cloud runs your tests in the second phase.\n\nWhen Xcode Cloud completes the test action, it makes test products and the result bundle with the test results available as artifacts.\n\nFor additional information on using Xcode Cloud to run your tests, see WWDC22: Author fast and reliable tests for Xcode Cloud.\n\nAdd an analyze action\n\nIn addition to building and testing your code, analyzing it with Xcode can help you verify that your code is free from memory leaks and other issues. However, because analyzing code takes time, you might not do it regularly, causing issues to accumulate. Adding an analyze action to an Xcode Cloud workflow ensures you regularly analyze your code to identify errors before they become issues.\n\nTo add an analyze action to a workflow:\n\nOpen or create a workflow in Xcode or in the Xcode Cloud tab on the App Store Connect website.\n\nClick the Add button next to Actions, and choose Analyze.\n\nChoose a platform and a scheme for the analyze action.\n\nDecide if you want a build to fail if the analyze action fails and choose Required To Pass or Not Required to Pass accordingly.\n\nWhen Xcode Cloud performs the analyze action, it accesses your source code and runs the xcodebuild analyze command to perform static code analysis. Upon completion, Xcode Cloud makes the build logs available as artifacts.\n\nAdd an archive action\n\nWhen you’re ready to distribute your app or framework to testers or to release it, you typically archive your app or framework with Xcode. To automate this task, add the archive action to an Xcode Cloud workflow. In fact, the archive action is a requirement for distributing a new version of your app to testers with TestFlight or for release on the App Store.\n\nIf you configure a workflow to archive an app, the Deployment Preparation setting is a key setting. It determines how Xcode Cloud signs your app.\n\nChoose from the following options:\n\nNone\n\nThe exported app archive isn’t eligible for distribution with TestFlight or for release on the App Store. Use this setting if you don’t configure the workflow to distribute an app.\n\nTestFlight (Internal Testing Only)\n\nThe exported app archive is eligible for distribution to testers with TestFlight. Because the app archive isn’t eligible for release on the App Store, use this setting to prepare the exported app archive for distribution within your developer team or for distribution to internal testers with TestFlight. For example, choose it for nightly builds, pull requests, or development branches.\n\nTestFlight and App Store\n\nThe exported app archive is eligible for distribution to testers with TestFlight and for release on the App Store. Choose this option for builds you distribute to external testers and that you plan to make available on the App Store. Note that external testing is subject to beta app review.\n\nTo add an archive action to a workflow:\n\nOpen or create a workflow in Xcode or in the Xcode Cloud tab in App Store Connect.\n\nClick the Add button next to Actions, and choose Archive.\n\nChoose a platform and a scheme.\n\nChoose the option for the Deployment Preparation setting that fits your needs.\n\nWhen Xcode Cloud performs the archive action, it accesses your code and runs the xcodebuild archive command to create an exported app archive or framework bundle. Upon completion, Xcode Cloud makes the exported app archive or framework bundle and the build logs available as artifacts."
  },
  {
    "title": "Adding unit tests to your existing project | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-unit-tests-to-your-existing-project",
    "html": "Overview\n\nUnit tests, that you write using XCTest, can increase the speed of your development work, by giving you confidence that changes and additions don’t cause regressions in app functionality. Adding unit tests to existing projects can be difficult, because design choices made without considering testability can couple together distinct classes or subsystems, making it impossible to test them in isolation. Coupling in software design manifests as a class or function that can only be used successfully when connected to other code that works in a specific way. Sometimes, this coupling means your tests will attempt network connections or interact with the filesystem, which will make the tests slow and their results non-deterministic. Removing the coupling makes it possible to introduce unit tests, but requires code changes in places where you don’t already have test coverage, which can be risky.\n\nImprove the test coverage of your project by identifying a component you’d like to test, and writing a test case that covers the behavior you want to assert. Use a risk-focused approach to prioritization that covers logic in features which have received a high number of user bug reports, or where a regression would have the highest impact.\n\nWhen the code you’re testing is coupled to another part of your project or a framework class, make the smallest possible change to the code that isolates the component without changing its behavior. Improve the ability to use the class in a test context with reduced coupling, and keep the changes small to reduce the risk associated with each change.\n\nThe following sections propose changes that remove couplings in situations where coupling between the code under consideration and another component blocks testing. Each solution demonstrates how an XCTest case works with the changed code to assert its behavior.\n\nReplace concrete type with protocol\n\nWhen your code relies on a specific class whose behavior makes testing difficult, create a protocol that lists the methods and properties used by your code. Examples of such problematic dependencies include those that access external state, including user documents or databases, or those that don’t have deterministic results, including network connections or random value generators.\n\nThe following listing shows a class in a Cocoa app that uses NSWorkspace to open a file, which represents an attachment to an email or instant message. The outcome of the openAttachment(file:with:) method depends on whether the user has an application installed that can handle files of the requested type, and whether the application successfully opens the file. All of these variables could introduce test failures, which would slow down development as you investigate “errors” that turn out to be transient problems unrelated to your code.\n\nSwift\n\nimport Cocoa\n\n\nenum AttachmentOpeningError : Error {\n  case UnableToOpenAttachment\n}\n\n\nclass AttachmentOpener {\n  func openAttachment(file location: URL, with workspace: NSWorkspace) throws {\n    if (!workspace.open(location)) {\n      throw AttachmentOpeningError.UnableToOpenAttachment\n    }\n  }\n}\n\n\nObjective-C\n\n// AttachmentOpener.h\n#import <Cocoa/Cocoa.h>\n\n\nNS_ASSUME_NONNULL_BEGIN\n@interface AttachmentOpener : NSObject\n\n\n- (BOOL)openAttachmentAtLocation:(NSURL *)file\n                   withWorkspace:(NSWorkspace *)workspace\n                           error:(NSError * __autoreleasing _Nullable *)error;\n\n\n@end\n\n\nextern NSErrorDomain const AttachmentOpenerErrorDomain;\n\n\ntypedef NS_ERROR_ENUM(AttachmentOpenerErrorDomain, AttachmentOpenerErrorCode) {\n    AttachmentOpenerErrorUnableToOpenAttachment,\n};\nNS_ASSUME_NONNULL_END\n\n\n// AttachmentOpener.m\n#import \"AttachmentOpener.h\"\n\n\n@implementation AttachmentOpener\n\n\n- (BOOL)openAttachmentAtLocation:(NSURL *)file\n                   withWorkspace:(NSWorkspace *)workspace\n                           error:(NSError *__autoreleasing  _Nullable *)error {\n    BOOL result = [workspace openURL:file];\n    if (!result && error) {\n        *error = [NSError errorWithDomain:AttachmentOpenerErrorDomain\n                                     code:AttachmentOpenerErrorUnableToOpenAttachment\n                                 userInfo:nil];\n    }\n    return result;\n}\n\n\n@end\n\n\nconst NSErrorDomain AttachmentOpenerErrorDomain = @\"AttachmentOpenerErrorDomain\";\n\n\nTo test code with this coupling, introduce a protocol that describes how your code interacts with the problematic dependency. Use that protocol in your code, so your class depends on the existence of the methods in the protocol, but not their specific implementation. Write an alternative implementation of the protocol that doesn’t perform the stateful or non-deterministic tasks, and use that implementation to write tests with controlled behavior.\n\nIn this listing, a protocol that includes the open(_:) method is defined, along with an extension to NSWorkspace that makes it conform to the protocol.\n\nSwift\n\nimport Cocoa\n\n\nenum AttachmentOpeningError: Error {\n  case UnableToOpenAttachment\n}\n\n\nprotocol URLOpener {\n  func open(_ file: URL) -> Bool\n}\n\n\nextension NSWorkspace : URLOpener {}\n\n\nclass AttachmentOpener {\n  func openAttachment(file location: URL, with workspace: URLOpener) throws {\n    if (!workspace.open(location)) {\n      throw AttachmentOpeningError.UnableToOpenAttachment\n    }\n  }\n}\n\n\nObjective-C\n\n// URLOpener.h\n#import <Cocoa/Cocoa.h>\n\n\n@protocol URLOpener <NSObject>\n- (BOOL)openURL:(NSURL *)url;\n@end\n\n\n@interface NSWorkspace (URLOpener) <URLOpener>\n@end\n\n\n// AttachmentOpener.h\n#import <Cocoa/Cocoa.h>\n#import \"URLOpener.h\"\n\n\nNS_ASSUME_NONNULL_BEGIN\n\n\n@interface AttachmentOpener : NSObject\n\n\n- (BOOL)openAttachmentAtLocation:(NSURL *)file\n                   withWorkspace:(id <URLOpener>)workspace\n                           error:(NSError * __autoreleasing _Nullable *)error;\n\n\n@end\n\n\n// The rest of AttachmentOpener.h, and AttachmentOpener.m remains unchanged.\n\n\nIn tests, write a different implementation of the URLOpener protocol that doesn’t depend on the apps installed on the user’s computer.\n\nSwift\n\nclass StubWorkspace: URLOpener {\n  var isSuccessful = true\n\n\n  func open(_ file: URL) -> Bool {\n    return isSuccessful\n  }\n}\n\n\nclass AttachmentOpenerTests: XCTestCase {\n  var workspace: StubWorkspace! = nil\n  var attachmentOpener: AttachmentOpener! = nil\n  let location = URL(fileURLWithPath: \"/tmp/a_file.txt\")\n\n\n  override func setUp() {\n    workspace = StubWorkspace()\n    attachmentOpener = AttachmentOpener()\n  }\n\n\n  override func tearDown() {\n    workspace = nil\n    attachmentOpener = nil\n  }\n\n\n  func testWorkspaceCanOpenAttachment() {\n    workspace.isSuccessful = true\n    XCTAssertNoThrow(try attachmentOpener.openAttachment(file: location, with: workspace))\n  }\n\n\n  func testThrowIfWorkspaceCannotOpenAttachment() {\n    workspace.isSuccessful = false\n    XCTAssertThrowsError(try attachmentOpener.openAttachment(file: location, with: workspace))\n  }\n}\n\n\nObjective-C\n\n#import <XCTest/XCTest.h>\n#import \"AttachmentOpener.h\"\n#import \"URLOpener.h\"\n\n\n@interface StubWorkspace: NSObject <URLOpener>\n@property (nonatomic, assign, getter=isSuccessful) BOOL successful;\n@end\n\n\n@implementation StubWorkspace\n\n\n- (BOOL)openURL:(NSURL *)url\n{\n    return self.isSuccessful;\n}\n\n\n@end\n\n\n@interface AttachmentOpenerTests : XCTestCase\n@end\n\n\n@implementation AttachmentOpenerTests\n{\n    StubWorkspace *workspace;\n    AttachmentOpener *opener;\n    NSURL *location;\n}\n\n\n- (void)setUp {\n    workspace = [[StubWorkspace alloc] init];\n    opener = [[AttachmentOpener alloc] init];\n    location = [NSURL fileURLWithPath:@\"/tmp/a_file.txt\"];\n}\n\n\n- (void)tearDown {\n    workspace = nil;\n    opener = nil;\n    location = nil;\n}\n\n\n- (void)testWorkspaceCanOpenAttachment {\n    workspace.successful = YES;\n    NSError *error = nil;\n    XCTAssertTrue([opener openAttachmentAtLocation:location\n                                     withWorkspace:workspace\n                                             error:&error],\n                  @\"Opening attachment should have succeeded but failed with %@\", error);\n}\n\n\n- (void)testErrorIfWorkspaceCannotOpenAttachment {\n    workspace.successful = NO;\n    NSError *error = nil;\n    XCTAssertFalse([opener openAttachmentAtLocation:location\n                                      withWorkspace:workspace\n                                              error:&error],\n                   @\"Opening attachment should not have succeeded\");\n}\n\n\n@end\n\nReplace named type with metatype value\n\nWhen one class in your app creates and uses instances of another class, and the created objects introduce testing difficulties, it can be hard to test the class where they’re created. Parameterize the type of the created object and use a required initializer to create an instance. Examples of this difficult testing situation include a controller that creates a new document on the filesystem in response to a user action, or a method that interprets JSON received from a web service and creates new Core Data managed objects that represent the received data.\n\nIn each of these cases, because the objects are created by the code you want to test, you can’t pass in a different object as a parameter to the method. The object doesn’t exist until it’s created by your code, at which point it’s of the type that has the untestable behavior.\n\nThe listing below shows a UIDocumentBrowserViewControllerDelegate that creates and opens a document object when the user picks a document in the browser. The document object it creates reads and writes data to the file system, so its behavior is not easy to control in a unit test.\n\nSwift\n\nclass DocumentBrowserDelegate: NSObject, UIDocumentBrowserViewControllerDelegate {\n  func documentBrowser(_ controller: UIDocumentBrowserViewController, didPickDocumentsAt documentURLs: [URL]) {\n    guard let sourceURL = documentURLs.first else { return }\n    let storyBoard = UIStoryboard(name: \"Main\", bundle: nil)\n    let documentViewController = storyBoard.instantiateViewController(withIdentifier: \"DocumentViewController\") as! DocumentViewController\n    documentViewController.document = Document(fileURL: sourceURL)\n    documentViewController.modalPresentationStyle = .fullScreen\n\n\n    controller.present(documentViewController, animated: true, completion: nil)\n  }\n}\n\n\nObjective-C\n\n// DocumentBrowserDelegate.h\n#import <UIKit/UIKit.h>\n\n\nNS_ASSUME_NONNULL_BEGIN\n@interface DocumentBrowserDelegate : NSObject <UIDocumentBrowserViewControllerDelegate>\n@end\nNS_ASSUME_NONNULL_END\n\n\n// DocumentBrowserDelegate.m\n#import \"DocumentBrowserDelegate.h\"\n#import \"DocumentViewController.h\"\n#import \"Document.h\"\n\n\n@implementation DocumentBrowserDelegate\n\n\n- (void)documentBrowser:(UIDocumentBrowserViewController *)controller\n didPickDocumentsAtURLs:(NSArray<NSURL *> *)documentURLs {\n    NSURL *sourceURL = [documentURLs firstObject];\n    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\"Main\"\n                                                         bundle:nil];\n    DocumentViewController *documentViewController = [storyboard instantiateViewControllerWithIdentifier:@\"DocumentViewController\"];\n    documentViewController.document = [[Document alloc] initWithFileURL:sourceURL];\n    documentViewController.modalPresentationStyle = UIModalPresentationFullScreen;\n    [controller presentViewController:documentViewController\n                             animated:YES\n                           completion:nil];\n}\n\n\n@end\n\n\nTo remove the coupling between the code you’re trying to test and the objects it creates, define a variable on the class under test that represents the type of object it should construct. Such a variable is called a metatype value. Set the default value to the type the class already uses. You’ll need to ensure that the initializer used to construct instances is marked required. This listing shows the document browser view controller delegate with that variable introduced. The delegate creates documents with the type defined by the metatype value.\n\nSwift\n\nclass DocumentBrowserDelegate : NSObject, UIDocumentBrowserViewControllerDelegate {\n  var DocumentClass = Document.self\n\n\n  func documentBrowser(_ controller: UIDocumentBrowserViewController, didPickDocumentsAt documentURLs: [URL]) {\n    guard let sourceURL = documentURLs.first else { return }\n    let storyBoard = UIStoryboard(name: \"Main\", bundle: nil)\n    let documentViewController = storyBoard.instantiateViewController(withIdentifier: \"DocumentViewController\") as! DocumentViewController\n    documentViewController.document = DocumentClass.init(fileURL: sourceURL)\n    documentViewController.modalPresentationStyle = .fullScreen\n\n\n    controller.present(documentViewController, animated: true, completion: nil)\n  }\n}\n\n\nObjective-C\n\n// DocumentBrowserDelegate.h\n\n\n#import <UIKit/UIKit.h>\n\n\nNS_ASSUME_NONNULL_BEGIN\n@interface DocumentBrowserDelegate : NSObject <UIDocumentBrowserViewControllerDelegate>\n@property (nonatomic, assign) Class DocumentClass;\n@end\nNS_ASSUME_NONNULL_END\n\n\n// DocumentBrowserDelegate.m\n\n\n#import \"DocumentBrowserDelegate.h\"\n#import \"DocumentViewController.h\"\n#import \"Document.h\"\n\n\n@implementation DocumentBrowserDelegate\n\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        self.DocumentClass = [Document class];\n    }\n    return self;\n}\n\n\n- (void)documentBrowser:(UIDocumentBrowserViewController *)controller\n didPickDocumentsAtURLs:(NSArray<NSURL *> *)documentURLs {\n    NSURL *sourceURL = [documentURLs firstObject];\n    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\"Main\"\n                                                         bundle:nil];\n    DocumentViewController *documentViewController = [storyboard instantiateViewControllerWithIdentifier:@\"DocumentViewController\"];\n    documentViewController.document = [[self.DocumentClass alloc] initWithFileURL:sourceURL];\n    documentViewController.modalPresentationStyle = UIModalPresentationFullScreen;\n    [controller presentViewController:documentViewController\n                             animated:YES\n                           completion:nil];\n}\n\n\n@end\n\n\nSet a different value for the metatype in tests, so your code constructs an object that doesn’t have the same untestable behavior. In tests, create a “test dummy” version of the document class: a class with the same interface, but which doesn’t implement the behavior that makes it hard to test. In this case, a dummy document class should not interact with the file system.\n\nSwift\n\nclass DummyDocument : Document {\n  static var opensSuccessfully = true\n  static var savesSuccessfully = true\n  static var closesSuccessfully = true\n\n\n  override func save(to url: URL, for saveOperation: UIDocument.SaveOperation, completionHandler: ((Bool) -> Void)? = nil) {\n    // don't save anything, just call the completion handler\n    guard let handler = completionHandler else { return }\n    handler(StubDocument.savesSuccessfully)\n  }\n\n\n  override func close(completionHandler: ((Bool) -> Void)? = nil) {\n    guard let handler = completionHandler else { return }\n    handler(StubDocument.closesSuccessfully)\n  }\n\n\n  override func open(completionHandler: ((Bool) -> Void)? = nil) {\n    guard let handler = completionHandler else { return }\n    handler(StubDocument.opensSuccessfully)\n  }\n}\n\n\nObjective-C\n\n@interface DummyDocument : Document\n@property (nonatomic, assign) BOOL savesSuccessfully;\n@property (nonatomic, assign) BOOL opensSuccessfully;\n@property (nonatomic, assign) BOOL closesSuccessfully;\n@end\n\n\n@implementation DummyDocument\n\n\n- (void)saveToURL:(NSURL *)url\n forSaveOperation:(UIDocumentSaveOperation)saveOperation\ncompletionHandler:(void (^)(BOOL))completionHandler {\n    // don't save anything, just call the completion handler\n    if (completionHandler) {\n        completionHandler(self.savesSuccessfully);\n    }\n}\n\n\n- (void)openWithCompletionHandler:(void (^)(BOOL))completionHandler {\n    if (completionHandler) {\n        completionHandler(self.opensSuccessfully);\n    }\n}\n\n\n- (void)closeWithCompletionHandler:(void (^)(BOOL))completionHandler {\n    if (completionHandler) {\n        completionHandler(self.closesSuccessfully);\n    }\n}\n\n\n@end\n\n\nReplace the document type with the dummy type in your test case’s setUp() method, so the delegate being tested creates instances of the dummy document type, which behave deterministically in the tests.\n\nSwift\n\nclass DocumentBrowserDelegateTests: XCTestCase {\n  var delegate: DocumentBrowserDelegate! = nil\n\n\n  override func setUp() {\n    delegate = DocumentBrowserDelegate()\n    delegate.DocumentClass = StubDocument.self\n  }\n\n\n  override func tearDown() {}\n\n\n  // Add test methods here.\n}\n\n\nObjective-C\n\n@implementation DocumentBrowserDelegateTests\n{\n    DocumentBrowserDelegate *delegate;\n}\n\n\n- (void)setUp {\n    delegate = [[DocumentBrowserDelegate alloc] init];\n    delegate.DocumentClass = [DummyDocument class];\n}\n\n\n- (void)tearDown {\n    delegate = nil;\n}\n\n\n// Add test methods here.\n\n\n@end\n\nSubclass and override untestable methods\n\nWhen a class combines custom logic with interactions or behavior that make the class hard to test, introduce a subclass that overrides some of the class’s methods to make the others easier to test. It’s common to design classes that contain both app-specific logic, and interactions with the environment or frameworks that render behavior difficult to control in tests. A common example is a UIViewController subclass, which has app-specific code in its action methods and also loads views or presents other view controllers.\n\nIntroducing tests for the custom app logic is desirable, to ensure that this logic works as expected and to protect against regressions. The complexity of controlling or working around the interactions between the class and the environment make testing the logic difficult.\n\nAs an example, the following iOS view controller populates a label with a user name found in a profile object (and, in principle, it could populate other UI elements with other fields in the profile). It uses UserDefaults to find the path to a file, tries to load that as a dictionary, then uses the values in that dictionary to populate the UI.\n\nSwift\n\nstruct UserProfile {\n    let name: String\n}\n\n\nclass ProfileViewController: UIViewController {\n    @IBOutlet var nameLabel: UILabel!\n\n\n    override func viewDidLoad() {\n        self.loadProfile() { [weak self] user in\n            self?.nameLabel.text = user?.name ?? \"Unknown User\"\n        }\n    }\n\n\n    func loadProfile(_ completion: (UserProfile?) -> ()) {\n        let path = UserDefaults.standard.string(forKey: \"ProfilePath\")\n        guard let thePath = path else {\n            completion(nil)\n            return\n        }\n        let profileURL = URL(fileURLWithPath: thePath)\n        let profileDict = NSDictionary(contentsOf: profileURL)\n        guard let profileDictionary = profileDict else {\n            completion(nil)\n            return\n        }\n        guard let userName = profileDictionary[\"Name\"] else {\n            completion(nil)\n            return\n        }\n        let profile = UserProfile(name: userName as! String)\n        completion(profile)\n    }\n}\n\n\n\n\nObjective-C\n\n// ProfileViewController.h\n#import <UIKit/UIKit.h>\n\n\n@interface ProfileViewController\n@property (nonatomic, weak) IBOutlet UILabel *nameLabel;\n- (void)loadProfileWithCompletion:(void(^)(Profile *))completion;\n@end\n\n\n// ProfileViewController.m\n#import \"ProfileViewController.h\"\n#import \"Profile.h\"\n\n\n@implementation ProfileViewController\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self loadProfileWithCompletion:^(Profile *profile) {\n        if (profile) {\n            self.nameLabel.text = profile.username;\n        } else {\n            self.nameLabel.text = @\"Unknown User\";\n        }\n    }];\n}\n\n\n- (void)loadProfileWithCompletion:(void (^)(Profile *))completion {\n    NSString *path = [[NSUserDefaults standardUserDefaults] stringForKey:@\"ProfilePath\"];\n    if (!path) {\n        completion(nil);\n        return;\n    }\n    NSURL *profileLocation = [NSURL fileURLWithPath:path];\n    NSDictionary *profileData = [NSDictionary dictionaryWithContentsOfURL:profileLocation];\n    if (!profileData) {\n        completion(nil);\n        return;\n    }\n    NSString *username = profileData[@\"username\"];\n    if (!username) {\n        completion(nil);\n        return;\n    }\n    Profile *profile = [[Profile alloc] initWithUsername:username];\n    completion(profile);\n}\n\n\n@end\n\n\nTo overcome this complexity, subclass your view controller and “stub out” the methods that produce complex, untestable interactions, by overriding them with simpler methods. Use the subclass in your tests to verify the behavior of the custom logic, which you don’t override. You may also need to introduce a metatype value, if the code under test creates an instance of the target type.\n\nThe following listing introduces a subclass, StubProfileViewController, which doesn’t have all of the coupling to UserDefaults and the file system in its parent class. Instead, it uses a UserProfile object that’s configured by the caller. Tests using this subclass can easily provide exactly the object needed to trigger the logic they’re testing.\n\nSwift\n\nclass StubProfileViewController: ProfileViewController {\n    var loadedProfile: UserProfile? = nil\n\n\n    override func loadProfile(_ completion: (UserProfile?) -> ()) {\n        completion(loadedProfile)\n    }\n}\n\n\n\n\nObjective-C\n\n@interface StubProfileViewController: ProfileViewController\n@property (nonatomic, strong) Profile *loadedProfile;\n@end\n\n\n@implementation StubProfileViewController\n\n\n- (void)loadProfileWithCompletion: (void (^)(Profile *))completion {\n    completion(self.loadedProfile);\n}\n\n\n@end\n\n\nTwo tests are needed to fully cover the behavior of viewDidLoad(). One test checks whether the name is correctly set from the profile, if the profile can be loaded. The other test checks whether the placeholder value for the name is used, if the profile is not loaded.\n\nSwift\n\nclass ProfileViewControllerTests: XCTestCase {\n    var profileVC: StubProfileViewController! = nil\n\n\n    override func setUp() {\n        profileVC = StubProfileViewController()\n        // configure the label, in lieu of loading a storyboard\n        profileVC.nameLabel = UILabel(frame: CGRect.zero)\n    }\n\n\n    override func tearDown() {}\n\n\n    func testSuccessfulProfileLoadingSetsNameLabel() {\n        profileVC.loadedProfile = UserProfile(name: \"User Name\")\n        profileVC.viewDidLoad()\n        XCTAssertEqual(profileVC.nameLabel.text, \"User Name\")\n    }\n\n\n    func testFailedProfileLoadingUsesPlaceholderLabelValue() {\n        profileVC.loadedProfile = nil\n        profileVC.viewDidLoad()\n        XCTAssertEqual(profileVC.nameLabel.text, \"Unknown User\")\n    }\n}\n\n\n\n\nObjective-C\n\n@interface ProfileViewControllerTests: XCTestCase\n@end\n\n\n@implementation ProfileViewControllerTests\n{\n    StubProfileViewController *profileVC;\n}\n\n\n- (void)setUp {\n    profileVC = [[StubProfileViewController alloc] init];\n    // configure the label, in lieu of loading a storyboard\n    profileVC.nameLabel = [[UILabel alloc] initWithFrame:CGRectZero];\n}\n\n\n- (void)tearDown {\n    profileVC = nil;\n}\n\n\n- (void)testSuccessfulProfileLoadingSetsNameLabel {\n    profileVC.loadedProfile = [[Profile alloc] initWithUsername:\"User Name\"];\n    [profileVC viewDidLoad];\n    XCTAssertEqualObjects(profileVC.nameLabel.text, \"User Name\");\n}\n\n\n- (void)testFailedProfileLoadingUsesPlaceholderLabelValue {\n    profileVC.loadedProfile = nil\n    [profileVC viewDidLoad];\n    XCTAssertEqualObjects(profileVC.nameLabel.text, \"Unknown User\");\n}\n\n\n@end\n\n\nNote\n\nThis pattern helps you to test existing classes that combine multiple responsibilities, but isn’t a good practice to follow in designing testable code from scratch. Separate code that handles different concerns into different classes; for example, creating a controller class that contains your app logic and a separate view controller that mediates between UIKit and the app-specific behavior. Add UI tests to verify the behavior of the real class in an end-to-end workflow covering the logic you stubbed out in the unit tests.\n\nSubclassing and overriding untestable methods is the first step in redesigning existing code so app logic and integration with frameworks or external data are separated. Dividing the code this way makes it easier to understand which parts of your project implement the app’s features and which integrate with the rest of the system, and it also reduces the chance of introducing logic bugs when you change your code to take advantage of new APIs or adopt different technologies.\n\nInject a singleton\n\nIf your code uses a singleton object to gain access to globally-available state or behavior, turn the singleton into a parameter that can be replaced to support isolation for testing. Singleton use can be spread throughout a codebase, which makes it hard to know the singleton’s state when it’s used by the component you’re trying to test. Running tests in different orders may produce different outcomes.\n\nCommonly-used singletons, including NSApplication and the default FileManager, have behavior that’s dependent on external state. Components that use these singletons directly introduce more complications for reliable testing.\n\nIn this example, a Cocoa view controller represents part of a document inspector in a news app. When the view controller’s represented object changes, it posts a notification to the default notification center, to which other components in the app subscribe.\n\nSwift\n\nlet InspectedArticleDidChangeNotificationName: String = \"InspectedArticleDidChange\"\n\n\nclass ArticleInspectorViewController: NSViewController {\n  var article: Article! = nil\n\n\n  override var representedObject: Any? {\n    didSet {\n      article = representedObject as! Article?\n      NotificationCenter.default.post(name: NSNotification.Name(rawValue:\n        InspectedArticleDidChangeNotificationName), object: article, userInfo: [\"Article\": article!])\n    }\n  }\n}\n\n\nObjective-C\n\n// ArticleInspectorViewController.h\n#import <Cocoa/Cocoa.h>\nNS_ASSUME_NONNULL_BEGIN\n@interface ArticleInspectorViewController : NSViewController\n@end\nextern const NSNotificationName InspectedArticleDidChangeNotificationName;\nNS_ASSUME_NONNULL_END\n\n\n// ArticleInspectorViewController.m\n#import \"ArticleInspectorViewController.h\"\n\n\n@implementation ArticleInspectorViewController\n\n\n- (void)setRepresentedObject:(id)representedObject {\n    [super setRepresentedObject:representedObject];\n    [[NSNotificationCenter defaultCenter] postNotificationName: InspectedArticleDidChangeNotificationName\n                                                        object: self\n                                                      userInfo: @{ @\"Article\" : representedObject }];\n}\n\n\n@end\n\n\nconst NSNotificationName InspectedArticleDidChangeNotificationName = @\"InspectedArticleDidChange\";\n\n\nWhile a test could register with the default notification center to observe this notification, the use of the singleton notification center makes it possible for other components in the app to interfere with the test outcome. Other code could post the notification, remove observers, or run its own code in response to the notification, all of which may interfere with the outcome of the test.\n\nReplace direct access to the singleton object with a parameter or property that can be controlled from outside the component under test. In the app, continue to use the singleton as the collaborator for the component. In tests, supply an alternative object that’s easier to control.\n\nThe following listing shows the result of applying this change to the article inspector view controller listed above. The view controller posts to the notification center defined in its notificationCenter property, which is initialized to be the default center.\n\nSwift\n\nlet InspectedArticleDidChangeNotificationName = \"InspectedArticleDidChange\"\n\n\nclass ArticleInspectorViewController: NSViewController {\n  var article: Article! = nil\n  var notificationCenter: NotificationCenter = NotificationCenter.default\n\n\n  override var representedObject: Any? {\n    didSet {\n      article = representedObject as! Article?\n      notificationCenter.post(name: NSNotification.Name(rawValue: \n        InspectedArticleDidChangeNotificationName), object: self, userInfo: [\"Article\": article!])\n    }\n  }\n}\n\n\nObjective-C\n\n// ArticleInspectorViewController.h\n@interface ArticleInspectorViewController : NSViewController\n@property (nonatomic, strong) NSNotificationCenter *notificationCenter;\n@end\n\n\n// ArticleInspectorViewController.m\n@implementation ArticleInspectorViewController\n\n\n- (instancetype)initWithNibName:(NSNibName)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {\n    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];\n    if (self) {\n        self.notificationCenter = [NSNotificationCenter defaultCenter];\n    }\n    return self;\n}\n\n\n- (void)setRepresentedObject:(id)representedObject {\n    [super setRepresentedObject:representedObject];\n    [self.notificationCenter postNotificationName: InspectedArticleDidChangeNotificationName\n                                                        object: self\n                                                      userInfo: @{ @\"Article\" : representedObject }];\n}\n\n\n@end\n\n\nIn a test case you can substitute a different notification center, which is not used elsewhere in the test suite or the app, and therefore is isolated from the behavior of other tests and modules.\n\nSwift\n\nclass ArticleInspectorViewControllerTests: XCTestCase {\n\n\n  var viewController: ArticleInspectorViewController! = nil\n  var article: Article! = nil\n  var notificationCenter: NotificationCenter! = nil\n  var articleFromNotification: Article! = nil\n  var observer: NSObjectProtocol? = nil\n\n\n  override func setUp() {\n    notificationCenter = NotificationCenter()\n    viewController = ArticleInspectorViewController()\n    viewController.notificationCenter = notificationCenter\n    article = Article()\n    observer = notificationCenter.addObserver(forName: NSNotification.Name(InspectedArticleDidChangeNotificationName), object: viewController, queue: nil) { note in\n      let observedArticle = note.userInfo?[\"Article\"]\n      self.articleFromNotification = observedArticle as? Article\n    }\n  }\n\n\n  override func tearDown() {\n    notificationCenter.removeObserver(observer!)\n  }\n\n\n  func testNotificationSentOnChangingInspectedArticle() {\n    viewController.representedObject = self.article\n    XCTAssertEqual(self.articleFromNotification, self.article, \"Notification should have been posted\")\n  }\n}\n\n\nObjective-C\n\n@implementation ArticleInspectorViewControllerTests\n{\n    ArticleInspectorViewController *viewController;\n    NSNotificationCenter *center;\n    Article *article;\n    Article *articleFromNotification;\n    id <NSObject> observer;\n}\n\n\n- (void)setUp {\n    center = [[NSNotificationCenter alloc] init];\n    viewController = [[ArticleInspectorViewController alloc] initWithNibName:nil\n                                                                      bundle:nil];\n    viewController.notificationCenter = center;\n    article = [[Article alloc] init];\n    observer = [center addObserverForName:InspectedArticleDidChangeNotificationName\n                                   object:viewController\n                                    queue:nil\n                               usingBlock:^(NSNotification * _Nonnull note) {\n        self->articleFromNotification = [note userInfo][@\"Article\"];\n    }];\n}\n\n\n- (void)tearDown {\n    [center removeObserver:observer];\n    observer = nil;\n    center = nil;\n    article = nil;\n    articleFromNotification = nil;\n    viewController = nil;\n}\n\n\n- (void)testNotificationSentOnChangingInspectedArticle {\n    viewController.representedObject = article;\n    XCTAssertEqualObjects(articleFromNotification, article, @\"Notification should have been posted\");\n}\n\n\n@end\n\n\nYou may need to combine this change with those described in the article sections: Replace Concrete Type with Protocol, and Subclass and Override Untestable Methods, to create the alternative object you use in the test in place of the singleton. You’ll need to do this where the singleton supplies behavior that’s difficult to control in a test, like FileManager or NSApplication.\n\nSee Also\nTest development\nImproving code assessment by organizing tests into test plans\nControl the information you receive from your tests at different stages in the software engineering process by creating and configuring test plans."
  },
  {
    "title": "Validating your app’s Metal API usage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/validating-your-apps-metal-api-usage",
    "html": "Overview\n\nThe API Validation layer checks for code that calls the Metal API incorrectly, including errors in creating resources, encoding Metal commands, and performing other common tasks. You can enable API Validation using the runtime diagnostics options in Xcode, or by using environment variables.\n\nImportant\n\nThe API Validation layer has a small, but measureable, impact on CPU performance.\n\nEnable API Validation in Xcode\n\nFollow these steps to enable API Validation using the runtime diagnostics options in the scheme settings:\n\nIn the Xcode toolbar, choose Edit Scheme from the Scheme menu. Alternatively, choose Product > Scheme > Edit Scheme.\n\nIn the scheme action panel, select Run.\n\nIn the action setting tab, click Diagnostics.\n\nSelect API Validation to enable it, and click Close.\n\nNow, the API Validation runtime is enabled each time you run your scheme.\n\nEnable API Validation with environment variables\n\nYou can also enable API Validation by setting the following environment variables on your Metal app:\n\nMTL_DEBUG_LAYER=1\n\nEnables all API Validation tests.\n\nMTL_DEBUG_LAYER_ERROR_MODE\n\nSets the behavior for when a debug layer error occurs. Possible values are assert (default), ignore, and nslog. assert causes the debug layer to log and then assert on error. ignore causes the debug layer to ignore errors, which may cause undefined behavior. nslog causes the debug layer to log errors using NSLog, which may also cause undefined behavior.\n\nMTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS=1\n\nConverts any MTLLoadAction.dontCare to MTLLoadAction.clear using a fuchsia color, which you can use to locate and debug incorrect load action modes or assumptions on MTLLoadAction.dontCare behavior.\n\nMTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS=1\n\nWrites an alternating red-and-white checkerboard into each render target with a store action of MTLStoreAction.dontCare, which you can use to debug incorrect store action modes or assumptions on MTLStoreAction.dontCare behavior.\n\nMTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES\n\nThis option takes a bitfield of modes to enable. The default is 0x1. The bitfield values are:\n\n0x1\n\nEnabling this flag causes the command buffer to tag any objects bound to it, which the system doesn’t retain internally. If the system deallocates a tagged object before the command buffer completes, an error occurs.\n\n0x2\n\nEnabling this flag causes the command buffer to tag objects that it internally retains. This flag is generally unnecessary because the system can’t deallocate an object while the command buffer itself isn’t complete.\n\n0x4\n\nEnabling this flag causes the system to treat deallocated tagged objects as errors even before committing the command buffer. This leads to a more immediate error (for example, in the call stack of the deallocation), which is more debuggable than at commit.\n\nMTL_DEBUG_LAYER_WARNING_MODE\n\nSets the behavior for when a debug layer warning occurs. Possible values are assert, ignore (default), and nslog. assert causes the debug layer to log and then assert on warning. ignore causes the debug layer to ignore warnings. nslog causes the debug layer to log warnings using NSLog.\n\nFor a complete list of settings, run man MetalValidation in Terminal.\n\nSee Also\nRuntime diagnostics\nInspecting live resources at runtime\nValidate your resources by viewing the contents of your textures and buffers while debugging your Metal app.\nValidating your app’s Metal shader usage\nCatch common shader runtime issues using Shader Validation while your app is running.\nMonitoring your Metal app’s graphics performance\nCatch performance issues using the Metal Performance HUD while your app is running."
  },
  {
    "title": "Measuring the GPU’s use of memory bandwidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/measuring-the-gpus-use-of-memory-bandwidth",
    "html": "Overview\n\nThe Instruments developer tool and the Metal debugger’s Performance timeline provide bandwidth counters (see Analyzing the performance of your Metal app and Analyzing Apple GPU performance using a visual timeline, respectively). The GPU bandwidth counters measure how much, in gigabytes per second, the GPU reads and writes, or accesses memory.\n\nYou may want your app to use a high amount of bandwidth for some activities — such as copying data quickly to save time — and lower bandwidth for others to save energy or to let the CPU and other processes access memory. If the GPU’s memory bandwidth usage is high when you don’t expect it to be, it may impede the CPU’s memory accesses.\n\nYou can reduce a GPU’s memory bandwidth with the following strategies in your passes:\n\nRead only the data your pass needs.\n\nWrite only the data that a subsequent pass needs.\n\nLoad and store only the attachments that a render pass needs.\n\nCreate textures that use only the appropriate MTLTextureUsage attributes.\n\nMetal can reduce your app’s memory bandwidth by optimizing the memory accesses to your textures that have the correct usage attributes. To set a texture’s usage appropriately, configure an MTLTextureDescriptor instance’s usage property and create a texture with it.\n\nBuffer and texture operations can also increase your app’s memory bandwidth. To check whether the limiter counters for buffer or texture operations are too high, and to learn what you can do to reduce their impact, see Reducing shader bottlenecks.\n\nTip\n\nThe Dependencies viewer in the Metal debugger can help you find opportunities to reduce memory bandwidth in your render and compute passes. See Analyzing resource dependencies.\n\nSee Also\nCounters\nFinding your Metal app’s GPU occupancy\nUnderstand the GPU usage for executing shaders by using occupancy.\nReducing shader bottlenecks\nIdentify and minimize congestion points in a GPU’s subsystems by checking its limiter and utilization counters."
  },
  {
    "title": "Examining the fields in a crash report | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/examining-the-fields-in-a-crash-report",
    "html": "Overview\n\nEach section of a crash report contains information to help you diagnose the source of a crash.\n\nHeader\n\nA crash report begins with a header section that describes the environment the crash occurred in.\n\nIncident Identifier: 6156848E-344E-4D9E-84E0-87AFD0D0AE7B\nCrashReporter Key:   76f2fb60060d6a7f814973377cbdc866fffd521f\nHardware Model:      iPhone8,1\nProcess:             TouchCanvas [1052]\nPath:                /private/var/containers/Bundle/Application/51346174-37EF-4F60-B72D-8DE5F01035F5/TouchCanvas.app/TouchCanvas\nIdentifier:          com.example.apple-samplecode.TouchCanvas\nVersion:             1 (3.0)\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           com.example.apple-samplecode.TouchCanvas [1806]\n\n\nDate/Time:           2020-03-27 18:06:51.4969 -0700\nLaunch Time:         2020-03-27 18:06:31.7593 -0700\nOS Version:          iPhone OS 13.3.1 (17D50)\n\n\nThe fields in the header can contain the following information. No single crash report contains all of these fields.\n\nIncident Identifier: A unique identifier for the report. Two reports never share the same Incident Identifier.\n\nCrashReporter Key: An anonymized per-device identifier. Two reports from the same device contain identical values. This identifier is reset upon erasing the device.\n\nBeta Identifier: A unique identifier for the combination of the device and vendor of the crashed application. Two reports for apps from the same vendor and from the same device contain identical values. This field is only present for TestFlight builds of an app, and replaces the CrashReporter Key field.\n\nHardware Model: The specific device model the app was running on.\n\nProcess: The executable name for the process that crashed. This matches the CFBundleExecutable value in the app’s information property list. The number in brackets is the process ID.\n\nPath: The location of the executable on disk. macOS replaces user-identifable path components with placeholder values to protect privacy.\n\nIdentifier: The CFBundleIdentifier of the process that crashed. If the binary doesn’t have a CFBundleIdentifier, this field contains either the process name or a placeholder value.\n\nVersion: The version of the process that crashed. The value is a concatenation of the app’s CFBundleVersion and CFBundleShortVersionString.\n\nAppStoreTools: The version of Xcode used to compile your app’s bitcode and to thin your app to device specific variants.\n\nAppVariant: The specific variant of your app produced by app thinning. This field contains multiple values, described later in this section.\n\nCode Type: The CPU architecture of the process that crashed. The value is one of ARM-64, ARM, X86-64, or X86.\n\nRole: The task_role assigned to the process at the time of termination. This field is generally not helpful when you analyze a crash report.\n\nParent Process: The name and process ID (in square brackets) of the process that launched the crashed process.\n\nCoalition: The name of the process coalition containing the app. Process coalitions track resource usage among groups of related processes, such as an operating system process supporting a specific API’s functionality in an app. Most processes, including app extensions, form their own coalition.\n\nDate/Time: The date and time of the crash.\n\nLaunch Time: The date and time the app launched.\n\nOS Version: The operating system version, including the build number, on which the crash occurred.\n\nThe AppVariant field contains three values separated by colons, for example, 1:iPhone10,6:12.2. These fields represent:\n\nAn internal system value. This value isn’t useful for diagnosing a crash. In the example, this value is 1.\n\nThe name of the thinning variant. The variant represents a class of devices with similar characteristics, such as screen scale, memory class, and Metal GPU family. The thinning variant’s name doesn’t indicate the exact hardware model the crash report is from, and may differ from the Hardware Model field. In the example, this value is iPhone10,6.\n\nThe operating system version variant. For each class of devices, app thinning creates additional variants for different versions of the operating system. In the example, this value is 12.2, indicating this variant targets iOS devices running iOS 12.2 or higher.\n\nException information\n\nEvery crash report contains exception information. This information section tells you how the process terminated, but it may not fully explain why the app terminated. This information is important, but is often overlooked.\n\nException Type:  EXC_BREAKPOINT (SIGTRAP)\nException Codes: 0x0000000000000001, 0x0000000102afb3d0\n\n\nNote\n\nThis exception information doesn’t refer to language exceptions thrown by an API or language features in Objective-C or C++. Crash reports record language exception information separately.\n\nThe following fields provide information about the exception. No single crash report contains all of these fields.\n\nException Type: The name of the Mach exception that terminated the process, along with the name of the corresponding BSD termination signal in parentheses. See Understanding the exception types in a crash report.\n\nException Codes: Processor specific information about the exception encoded into one or more 64-bit hexadecimal numbers. Typically, this field isn’t present because the operating system presents the information as human-readable information in the other fields of this section.\n\nException Subtype: The human-readable description of the exception codes.\n\nException Message: Additional human-readable information extracted from the exception codes.\n\nException Note: Additional information that isn’t specific to one exception type. If this field contains EXC_CORPSE_NOTIFY, the crash didn’t originate from a hardware trap, either because the process was explicitly terminated by the operating system or the process called abort(). If this field contains SIMULATED (this is NOT a crash), the process didn’t crash, but the operating system might have subsequently requested termination of the process. If this field contains NON-FATAL CONDITION (this is NOT a crash), the process didn’t terminate, because the issue that created the crash report wasn’t fatal.\n\nTermination Reason: Exit reason information specified when the operating system terminates a process. Key operating system components, both inside and outside of a process, terminate the process upon encountering a fatal error and record the reason in this field. Examples of the information you can find in this field are messages about an invalid code signature, a missing dependent library, or accessing privacy sensitive information without a purpose string.\n\nTriggered by Thread or Crashed Thread: The thread on which the exception originated.\n\nDiagnostic messages\n\nThe operating system sometimes includes additional diagnostic information. This information uses a variety of formats, depending on reason for the crash, and isn’t present in every crash report.\n\nFramework error messages occurring just before the process terminated appear in the Application Specific Information field. In this example, the Dispatch framework logged an error about incorrect use of a dispatch queue:\n\nApplication Specific Information:\nBUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread\n\n\nNote\n\nApplication Specific Information is sometimes elided from a crash report to avoid logging privacy-sensitive information in the message.\n\nTerminations due to a watchdog violation contain a Termination Description field with information about why the watchdog triggered.\n\nTermination Description: SPRINGBOARD, \n    scene-create watchdog transgression: application<com.example.MyCoolApp>:667\n    exhausted real (wall clock) time allowance of 19.97 seconds \n\n\nAddressing watchdog terminations goes into more detail about watchdog terminations and how to interpret this information.\n\nTerminations due to a memory access issue contain information about the virtual memory regions in the VM Region Info field.\n\nVM Region Info: 0 is not in any region.  Bytes before following region: 4307009536\n      REGION TYPE                      START - END             [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->  \n      __TEXT                 0000000100b7c000-0000000100b84000 [   32K] r-x/r-x SM=COW  ...pp/MyGreatApp\n\n\nInvestigating memory access crashes goes into more detail about this information.\n\nBacktraces\n\nEach thread of the crashed proces is captured as a backtrace, documenting the code running on the thread when the process terminated. The backtraces are similar to what you see when you pause the process with the debugger. Crashes caused by a language exception include an additional backtrace, the Last Exception Backtrace, located before the first thread. If your crash report contains a Last Exception Backtrace, see Addressing language exception crashes for information specific to language exception crashes.\n\nThe first line of each backtrace lists the thread number and the thread name. For privacy reasons, crash reports delivered through the Crashes Organizer in Xcode don’t contain thread names. This example shows the backtraces for three threads; Thread 0 crashed, and is identified as the app’s main thread by its name:\n\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   TouchCanvas                       0x0000000102afb3d0 CanvasView.updateEstimatedPropertiesForTouches(_:) + 62416 (CanvasView.swift:231)\n1   TouchCanvas                       0x0000000102afb3d0 CanvasView.updateEstimatedPropertiesForTouches(_:) + 62416 (CanvasView.swift:231)\n2   TouchCanvas                       0x0000000102af7d10 ViewController.touchesMoved(_:with:) + 48400 (<compiler-generated>:0)\n3   TouchCanvas                       0x0000000102af80b8 @objc ViewController.touchesMoved(_:with:) + 49336 (<compiler-generated>:0)\n4   UIKitCore                         0x00000001ba9d8da4 forwardTouchMethod + 328\n5   UIKitCore                         0x00000001ba9d8e40 -[UIResponder touchesMoved:withEvent:] + 60\n6   UIKitCore                         0x00000001ba9d8da4 forwardTouchMethod + 328\n7   UIKitCore                         0x00000001ba9d8e40 -[UIResponder touchesMoved:withEvent:] + 60\n8   UIKitCore                         0x00000001ba9e6ea4 -[UIWindow _sendTouchesForEvent:] + 1896\n9   UIKitCore                         0x00000001ba9e8390 -[UIWindow sendEvent:] + 3352\n10  UIKitCore                         0x00000001ba9c4a9c -[UIApplication sendEvent:] + 344\n11  UIKitCore                         0x00000001baa3cc20 __dispatchPreprocessedEventFromEventQueue + 5880\n12  UIKitCore                         0x00000001baa3f17c __handleEventQueueInternal + 4924\n13  UIKitCore                         0x00000001baa37ff0 __handleHIDEventFetcherDrain + 108\n14  CoreFoundation                    0x00000001b68a4a00 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24\n15  CoreFoundation                    0x00000001b68a4958 __CFRunLoopDoSource0 + 80\n16  CoreFoundation                    0x00000001b68a40f0 __CFRunLoopDoSources0 + 180\n17  CoreFoundation                    0x00000001b689f23c __CFRunLoopRun + 1080\n18  CoreFoundation                    0x00000001b689eadc CFRunLoopRunSpecific + 464\n19  GraphicsServices                  0x00000001c083f328 GSEventRunModal + 104\n20  UIKitCore                         0x00000001ba9ac63c UIApplicationMain + 1936\n21  TouchCanvas                       0x0000000102af16dc main + 22236 (AppDelegate.swift:12)\n22  libdyld.dylib                     0x00000001b6728360 start + 4\n\n\nThread 1:\n0   libsystem_pthread.dylib           0x00000001b6645758 start_wqthread + 0\n\n\nThread 2:\n0   libsystem_pthread.dylib           0x00000001b6645758 start_wqthread + 0\n...\n\n\nAfter the thread number, each line of a backtrace represents a stack frame in the backtrace.\n\n0   TouchCanvas                       0x0000000102afb3d0 CanvasView.updateEstimatedPropertiesForTouches(_:) + 62416 (CanvasView.swift:231)\n\n\nEach column of the stack frame contains information about the code executing at the time of the crash. The following list uses the components of stack frame 0 from the example above.\n\n0. The stack frame number. Stack frames are in calling order, where frame 0 is the function that was executing at the time execution halted. Frame 1 is the function that called the function in frame 0, and so on.\n\nTouchCanvas. The name of the binary containing the function that is executing.\n\n0x0000000102afb3d0. The address of the machine instruction that is executing. For frame 0 in each backtrace, this is the address of the machine instruction executing on a thread when the process terminated. For other stack frames, this is the address of first machine instruction that executes after control returns to that stack frame.\n\nCanvasView.updateEstimatedPropertiesForTouches(_:). In a fully symbolicated crash report, the name of the function that is executing. For privacy reasons, the function name is sometimes limited to the first 100 characters.\n\n62416. The number after the + is the byte offset from the function’s entry point to the current instruction in the function.\n\nCanvasView.swift:231. The file name and line number containing the code, if you have a dSYM file for the binary.\n\nIn some situations, the file name or the line number information won’t correspond to the orginial source code:\n\nIf the source file name is <compiler-generated>, the compiler created the code for that frame, and the code isn’t in your source files. If this is top frame in the crashed thread, look at the preceeding few stack frames for clues.\n\nIf the line number for a source file is 0, this means the backtrace doesn’t map to a specific line of code in the original code. This is because the compiler optimized the code, such as by inlining functions, and the code executing at the time of the crash doesn’t correspond to an exact line in the orignial code. The function name for the frame is still a clue in this situation.\n\nThread state\n\nThe thread state section of a crash report lists the CPU registers and their values for the crashed thread when the app terminated. Understanding the thread state is an advanced topic that requires understanding of the application binary interface (ABI). See Writing ARM64 code for Apple platforms.\n\nThread 0 crashed with ARM Thread State (64-bit):\n    x0: 0x0000000000000001   x1: 0x0000000000000000   x2: 0x0000000000000000   x3: 0x000000000000000f\n    x4: 0x00000000000001c2   x5: 0x000000010327f6c0   x6: 0x000000010327f724   x7: 0x0000000000000120\n    x8: 0x0000000000000001   x9: 0x0000000000000001  x10: 0x0000000000000001  x11: 0x0000000000000000\n   x12: 0x00000001038612b0  x13: 0x000005a102b075a7  x14: 0x0000000000000100  x15: 0x0000010000000000\n   x16: 0x00000001c3e6c630  x17: 0x00000001bae4bbf8  x18: 0x0000000000000000  x19: 0x0000000282c14280\n   x20: 0x00000001fe64a3e0  x21: 0x4000000281f1df10  x22: 0x0000000000000001  x23: 0x0000000000000000\n   x24: 0x0000000000000000  x25: 0x0000000282c14280  x26: 0x0000000103203140  x27: 0x00000001bacf4b7c\n   x28: 0x00000001fe5ded08   fp: 0x000000016d311310   lr: 0x0000000102afb3d0\n    sp: 0x000000016d311200   pc: 0x0000000102afb3d0 cpsr: 0x60000000\n   esr: 0xf2000001  Address size fault\n\n\nRegisters provide extra information for crashes caused by memory access issues. Understand the crashed thread’s registers discusses that scenario further.\n\nBinary images\n\nThe binary images section of a crash report lists all code loaded in the process at the time of termination, such as the app executable and system frameworks. Each line in the Binary Images section represents a single binary image. iOS, watchOS, and tvOS use the following format:\n\nBinary Images:\n0x102aec000 - 0x102b03fff TouchCanvas arm64  <fe7745ae12db30fa886c8baa1980437a> /var/containers/Bundle/Application/51346174-37EF-4F60-B72D-8DE5F01035F5/TouchCanvas.app/TouchCanvas\n...\n\n\nThis list contains the components from the preceding example:\n\n0x102aec000 - 0x102b03fff. The binary image’s address range within the process. The first address is the binary’s load address. See Symbolicate the crash report with the command line for how to use this value.\n\nTouchCanvas. The binary name.\n\narm64. The CPU architecture from the binary image that the operating system loaded into the process.\n\nfe7745ae12db30fa886c8baa1980437a. A build UUID that uniquely identifies the binary image. Use this value to locate the corresponding dSYM file when symbolicating the crash report. See Building your app to include debugging information for more information on build UUIDs.\n\n/var/containers/.../TouchCanvas.app/TouchCanvas. The path to the binary on disk. macOS replaces user-identifable path components with placeholder values to protect privacy.\n\nmacOS uses the following format for this section:\n\nBinary Images:\n       0x1025e5000 -        0x1025e6ffb +com.example.apple-samplecode.TouchCanvas (1.0 - 1) <5ED9BD63-2A55-3DDD-B3FF-EFCF61382F6F> /Users/USER/*/TouchCanvas.app/Contents/MacOS/TouchCanvas\n\n\nThis list contains the components from the preceding example:\n\n0x105f97000 - 0x105f98ffb. The binary image’s address range within the process. The first address is the binary’s load address. See Symbolicate the crash report with the command line for how to use this value.\n\n+com.example.apple-samplecode.TouchCanvas. The CFBundleIdentifier of the binary. The + prefix indicates the binary is not part of macOS.\n\n1.0 - 1. The binary’s CFBundleShortVersionString and CFBundleVersion.\n\n5ED9BD63-2A55-3DDD-B3FF-EFCF61382F6F. A build UUID that uniquely identifies the binary image. Use this value to locate the corresponding dSYM file when symbolicating the crash report. See Building your app to include debugging information for more information on build UUIDs.\n\n/Users/USER/*/TouchCanvas.app/Contents/MacOS/TouchCanvas. The path to the binary on disk. macOS replaces user-identifable path components with placeholder values to protect privacy.\n\nSee Also\nCrash reports\nAdding identifiable symbol names to a crash report\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\nIdentifying the cause of common crashes\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nInterpreting the JSON format of a crash report\nUnderstand the structure and properties of the objects the system includes in the JSON of a crash report.\nUnderstanding the exception types in a crash report\nLearn what the exception type tells you about why your app crashed."
  },
  {
    "title": "Interpreting the JSON format of a crash report | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/interpreting-the-json-format-of-a-crash-report",
    "html": "Overview\n\nStarting with iOS 15 and macOS 12, apps that generate crash reports store the data as JSON in files with an .ips extension. Tools for viewing these files, such as Console, translate the JSON to make it easier to read and interpret. The translated content uses field names the article Examining the fields in a crash report describes. Use the following information to understand the structure of the JSON the system uses for these crash reports and how the data maps to the field names found in the translated content.\n\nTypical JSON parsers expect a single JSON object in the body of the file. The IPS file for a crash report contains two JSON objects: an object containing IPS metadata about the report incident and an object containing the crash report data. When parsing the file, extract the JSON for the metadata object from the first line. If the bug_type property of the metadata object is 309, the log type for crash reports, you can extract the JSON for the crash report data from the remainder of the text.\n\nThe following example reads the contents of a crash report into a dictionary:\n\n    do {\n        let content = try String(contentsOfFile: filePath, encoding: String.Encoding.utf8)\n\n\n        /// Read the first line, the metadata object, into a dictionary.\n        let metadataRange = content.lineRange(for: ..<content.startIndex)\n        let metadataJSON = content[metadataRange].data(using: .utf8)\n        let metadata = try JSONSerialization.jsonObject(with: metadataJSON!) as! Dictionary<String, Any>\n\n\n        /// Check the `bug_type` property of the metadata for type `309`, the log type for crash reports.\n        let logType = \"\\(metadata[\"bug_type\"] ?? \"(unknown)\")\"\n        guard logType == \"309\" else {\n            // Handle the error.        \n            fatalError(\"Log type \\(logType) is not a crash report.\")\n        }\n\n\n        /// Read the remainder of the file, the crash report object, into a dictionary.\n        let reportRange = content.lineRange(for: metadataRange.upperBound..<content.endIndex)\n        let reportJSON = content[reportRange].data(using: .utf8)\n        let report = try JSONSerialization.jsonObject(with: reportJSON!) as! Dictionary<String, Any>\n\n\n        return report\n    } catch {\n        // Handle the error.\n        fatalError(\"*** An error occurred while reading the crash report: \\(error.localizedDescription) ***\")\n    }\n\n\nThe crash report data is made up of additional objects pertaining to OS version, bundle, store, exception, termination, threads, frames, and binary images. The properties of all these objects are outlined below.\n\nIPS metadata\n\nThe IPS metadata object contains the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nname\n\n\t\n\nString\n\n\t\n\nThe name of the process the report applies to. Usually the process executable name.\n\n\n\n\nbug_type\n\n\t\n\nString\n\n\t\n\nThe identifier for the type of log captured by the report. Type 309 for the crash reports this article describes. You might encounter other types. Type 288, for instance, is a stackshot.\n\n\n\n\nbundleID\n\n\t\n\nString\n\n\t\n\nThe bundle identifier of the process the report applies to; see CFBundleIdentifier.\n\n\n\n\nbuild_version\n\n\t\n\nString\n\n\t\n\nThe bundle version string of the process the report applies to; see CFBundleVersion.\n\n\n\n\nincident_id\n\n\t\n\nString\n\n\t\n\nA unique identifier for the report. Two reports never share the same identifier.\n\n\n\n\nplatform\n\n\t\n\nNumber\n\n\t\n\nA number identifying the platform the process was running on. For the meaning of these values, see Platforms.\n\n\n\n\ntimestamp\n\n\t\n\nString\n\n\t\n\nA date and time the log system generates for report tracking. Use the procLaunch and captureTime properties from the crash report object to determine launch and termination time for the process.\n\nCrash report\n\nThe crash report object can contain the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nasi\n\n\t\n\nDictionary\n\n\t\n\nAdditional application-specific logging. The properties of this object include an array of log strings. For more information, see Diagnostic messages. This appears in a translated report under Application Specific Information.\n\n\n\n\nbundleInfo\n\n\t\n\nDictionary\n\n\t\n\nBundle information for the process that crashed. For a description of this object‘s properties, see Bundle info.\n\n\n\n\ncaptureTime\n\n\t\n\nString\n\n\t\n\nThe date and time of the crash. This appears in a translated report under Date/Time.\n\n\n\n\ncoalitionID\n\n\t\n\nString\n\n\t\n\nThe ID of the coalition containing the process. Process coalitions track resource usage among groups of related processes, such as an operating system process supporting a specific API’s functionality in an app. Most processes, including app extensions, form their own coalition. This appears in a translated report under Coalition.\n\n\n\n\ncoalitionName\n\n\t\n\nString\n\n\t\n\nThe name of the coalition containing the process. For more details, see the description above on coalitionID.\n\n\n\n\ncpuType\n\n\t\n\nString\n\n\t\n\nThe CPU architecture of the process that crashed. The value is one of ARM-64, ARM, X86-64, or X86. This appears in a translated report under Code Type.\n\n\n\n\ncrashReporterKey\n\n\t\n\nString\n\n\t\n\nAn anonymized per-device identifier. Two reports from the same device contain identical values. This identifier is reset upon erasing the device. This appears in a translated report under CrashReporter Key.\n\n\n\n\nDTAppStoreToolsBuild\n\n\t\n\nString\n\n\t\n\nThe version of Xcode used to compile your app’s bitcode and to thin your app to device-specific variants. This appears in a translated report under AppStoreTools.\n\n\n\n\nexception\n\n\t\n\nDictionary\n\n\t\n\nInformation about how the process terminated. For a description of this object‘s properties, see Exception.\n\n\n\n\nfaultingThread\n\n\t\n\nNumber\n\n\t\n\nThe index of the thread that crashed. The object at this index in the threads array contains information about this thread, such as the state of its registers. For a description of this object‘s properties, see Threads.\n\n\n\n\nincident\n\n\t\n\nString\n\n\t\n\nA unique identifier for the report. Two reports never share the same identifier. This appears in a translated report under Incident Identifier.\n\n\n\n\nisCorpse\n\n\t\n\nBoolean\n\n\t\n\nA Boolean with a true value if the crash didn’t originate from a hardware trap, either because the process was explicitly terminated by the operating system or the process called abort(). This appears in a translated report under Exception Note as EXC_CORPSE_NOTIFY.\n\n\n\n\nisNonFatal\n\n\t\n\nString\n\n\t\n\nA Boolean with a true value if the process didn’t terminate, because the issue that created the crash report wasn’t fatal. This appears in a translated report under Exception Note as NON-FATAL CONDITION (this isn’t a crash).\n\n\n\n\nisSimulated\n\n\t\n\nString\n\n\t\n\nA Boolean with a true value if the process didn’t crash, but the operating system might have subsequently requested termination of the process. This appears in a translated report under Exception Note as SIMULATED (this isn’t a crash).\n\n\n\n\nlastExceptionBacktrace\n\n\t\n\nString\n\n\t\n\nBacktrace information for the crashed process documenting the code running on the thread where a language exception occurs. For a description of this object‘s properties, see Threads. This appears in a translated report under Last Exception Backtrace.\n\n\n\n\nmodelCode\n\n\t\n\nString\n\n\t\n\nThe specific device model the process was running on. This appears in a translated report under Hardware Model.\n\n\n\n\nosVersion\n\n\t\n\nDictionary\n\n\t\n\nVersion information for the OS the process was running under. For a description of this object‘s properties, see OS version. This appears in a translated report under OS Version.\n\n\n\n\nparentPid\n\n\t\n\nNumber\n\n\t\n\nThe identifier of the process that launched the crashed process. This appears in a translated report under Parent Process in square brackets after the process name.\n\n\n\n\nparentProc\n\n\t\n\nString\n\n\t\n\nThe name of the process that launched the crashed process. This appears in a translated report under Parent Process.\n\n\n\n\npid\n\n\t\n\nNumber\n\n\t\n\nThe identifier of the process that crashed. This appears in a translated report under Process as the text before the parenthesis.\n\n\n\n\nprocLaunch\n\n\t\n\nString\n\n\t\n\nThe date and time the process launched. This appears in a translated report under Launch Time.\n\n\n\n\nprocName\n\n\t\n\nString\n\n\t\n\nThe executable name of the process that crashed. This appears in a translated report under Process as the text before the parenthesis.\n\n\n\n\nprocPath\n\n\t\n\nString\n\n\t\n\nThe location of the executable on disk. macOS replaces user-identifable path components with placeholder values to protect privacy. This appears in a translated report under Path.\n\n\n\n\nprocRole\n\n\t\n\nString\n\n\t\n\nThe task role assigned to the process at the time of termination; see task_role_t. This appears in a translated report under Role.\n\n\n\n\nstoreInfo\n\n\t\n\nDictionary\n\n\t\n\nStore information about the process that crashed. For a description of this object‘s properties, see Store info.\n\n\n\n\ntermination\n\n\t\n\nDictionary\n\n\t\n\nInformation about the termination of a process by another. For a description of this object‘s properties, see Termination.\n\n\n\n\nthreads\n\n\t\n\nDictionary\n\n\t\n\nBacktrace information for the crashed process documenting the code running on each thread when the process terminated. For a description of this object‘s properties, see Threads. The backtrace for each thread appears in its own section.\n\n\n\n\ntranslated\n\n\t\n\nBoolean\n\n\t\n\nA Boolean with a true value for a process with X86-64 instructions running translated under Rosetta on Apple silicon.\n\n\n\n\nuptime\n\n\t\n\nNumber\n\n\t\n\nThe time, in seconds, the system has been running since it booted. This appears in a translated report under Time Awake Since Boot.\n\n\n\n\nusedImages\n\n\t\n\nArray\n\n\t\n\nEach dictionary entry in this array contains information about a binary image loaded in the process at the time of termination, such as the app executable and system frameworks. For a description of this object’s properties, see Binary images. This appears in a translated report under Binary Images.\n\n\n\n\nversion\n\n\t\n\nNumber\n\n\t\n\nCrash report schema version.\n\n\n\n\nvmSummary\n\n\t\n\nString\n\n\t\n\nSummary of the virtual memory in use by the process. Similar to the output from executing vmmap <pid> --summary. This appears in a translated report under VM Region Summary.\n\n\n\n\nvmregioninfo\n\n\t\n\nString\n\n\t\n\nInformation about the virtual memory regions for terminations due to a memory access issue. This appears in a translated report under VM Region Info.\n\nPlatforms\n\nThe numeric values for platform include:\n\n1 for macOS\n\n2 for iOS (includes iOS apps running under macOS on Apple silicon)\n\n3 for tvOS\n\n4 for watchOS\n\n6 for Mac Catalyst\n\n7 for iOS Simulator\n\n8 for tvOS Simulator\n\n9 for watchOS Simulator\n\nOS version\n\nA report includes OS version information in an object that can contain the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nbuild\n\n\t\n\nString\n\n\t\n\nThe build number of the operating system. Appears in a translated report inside the parentheses under OS Version.\n\n\n\n\nisEmbedded\n\n\t\n\nBoolean\n\n\t\n\nA Boolean with a true value if the operating system is for an embedded platform.\n\n\n\n\nreleaseType\n\n\t\n\nString\n\n\t\n\nThe type of release: User for a release version and Beta for a prerelease versions. Appears in a translated report under Release Type.\n\n\n\n\ntrain\n\n\t\n\nString\n\n\t\n\nA string containing the platform and OS version number. Appears in a translated report under OS Version.\n\nBundle info\n\nA report includes bundle information in an object with the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nCFBundleIdentifier\n\n\t\n\nString\n\n\t\n\nThe bundle identifier for the process that crashed. Appears in a translated report under Identifier.\n\n\n\n\nCFBundleShortVersionString\n\n\t\n\nString\n\n\t\n\nThe bundle version string (short) for the process that crashed; see CFBundleShortVersionString. Appears in a translated report under Version.\n\n\n\n\nCFBundleVersion\n\n\t\n\nString\n\n\t\n\nThe bundle version for the process that crashed; see CFBundleVersion. Appears in a translated report under Version.\n\nStore info\n\nA report includes store information in an object with the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\napplicationVariant\n\n\t\n\nString\n\n\t\n\nThe specific variant of your app produced by app thinning. Appears in a translated report under App Variant.\n\n\n\n\ndeviceIdentifierForVendor\n\n\t\n\nString\n\n\t\n\nA unique identifier for the combination of the device and vendor of the crashed app. Two reports for apps from the same vendor and from the same device contain identical values. This field is only present for TestFlight builds of an app, and replaces the CrashReporter Key field. Appears in a translated report under Beta Identifier.\n\n\n\n\nitemID\n\n\t\n\nString\n\n\t\n\nThe Apple ID, a unique record for titles in the store.\n\nException\n\nA report includes exception information in an object with the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\ncodes\n\n\t\n\nString\n\n\t\n\nProcessor-specific information about the exception encoded into one or more 64-bit hexadecimal numbers. This appears in a translated report under Exception Codes.\n\n\n\n\nmessage\n\n\t\n\nString\n\n\t\n\nAdditional human-readable information extracted from the exception codes. This appears in a translated report under Exception Message.\n\n\n\n\nsignal\n\n\t\n\nString\n\n\t\n\nThe BSD termination signal; see Understanding the exception types in a crash report. This appears in a translated report under Exception Type as the text inside the parentheses.\n\n\n\n\nsubtype\n\n\t\n\nString\n\n\t\n\nThe human-readable description of the exception codes. This appears in a translated report under Exception Subtype.\n\n\n\n\ntype\n\n\t\n\nString\n\n\t\n\nThe name of the Mach exception that terminated the process; see Understanding the exception types in a crash report. This appears in a translated report under Exception Type as the text before the parenthesis.\n\nFor more information, see Exception information.\n\nNote\n\nThis exception information doesn’t refer to language exceptions thrown by an API or language features in Objective-C or C++. Crash reports record language exception information separately.\n\nTermination\n\nA report includes termination information in an object that can contain the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nbyPid\n\n\t\n\nNumber\n\n\t\n\nThe identifier of the terminating process. This appears in a translated report under Terminating Process as the number in brackets after the terminating process name.\n\n\n\n\nbyProc\n\n\t\n\nString\n\n\t\n\nThe name of the terminating process. This appears in a translated report under Terminating Process before the PID in brackets.\n\n\n\n\ncode\n\n\t\n\nNumber\n\n\t\n\nA code the system uses to identify the reason for termination or a BSD termination signal the system used. For a list of possible reason codes, see EXC_CRASH (SIGKILL). This appears in a translated report under Termination Reason.\n\n\n\n\nflags\n\n\t\n\nNumber\n\n\t\n\nOptions set by the terminating process for how the process should terminate; see reason_flags.\n\n\n\n\nindicator\n\n\t\n\nString\n\n\t\n\nHuman-readable description of the termination code, if available. This appears in a translated report under Termination Reason.\n\n\n\n\nnamespace\n\n\t\n\nString\n\n\t\n\nA namespace the system uses to categorize the reason for termination; see reason_namespace. This appears in a translated report under Termination Reason.\n\nFor details on how to use this information, see Exception information.\n\nJSON stores numeric values as decimal numbers. The value the system stores in the code property is intended to be viewed in its hexadecimal form; see Convert numeric values to hexadecimal numbers.\n\nThreads\n\nA report includes thread information in objects that can contain the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nframes\n\n\t\n\nArray\n\n\t\n\nAn array of dictionaries describing each frame of the thread’s backtrace. Stack frames are in calling order, where frame 0 is the function that was executing at the time execution halted. Frame 1 is the function that called the function in frame 0, and so on. For a description of this object‘s properties, see Frames.\n\n\n\n\nid\n\n\t\n\nNumber\n\n\t\n\nThe thread’s index number.\n\n\n\n\nqueue\n\n\t\n\nString\n\n\t\n\nA string that identifies the dispatch queue of the crashing thread, if applicable. This appears in a translated report in the label above the backtrace of each thread under Dispatch Queue.\n\n\n\n\nthreadState\n\n\t\n\nDictionary\n\n\t\n\nA JSON representation of the CPU registers and their values for the thread as well as other useful runtime data from when the process terminated. The structure and properties of this object depend on the flavor. This appears in its own section of the formatted report after the backtraces for all the threads.\n\n\n\n\ntriggered\n\n\t\n\nBoolean\n\n\t\n\nA Boolean with a true value if this thread is responsible for the crash. This appears in a translated report as Triggered by Thread.\n\nFor details on how to use this information, see Backtraces and Thread state.\n\nJSON contains numbers for memory addresses in frame and thread state objects as decimal digits. To view the numbers contained in these fields in their more common hexadecimal form, see Convert numeric values to hexadecimal numbers.\n\nFrames\n\nA report includes information about frames in objects with the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nimageIndex\n\n\t\n\nNumber\n\n\t\n\nThe index of the binary image containing the code this frame in the backtrace is executing. The object at this index in the usedImages array contains information about this image. For a description of this object‘s properties, see Binary images.\n\n\n\n\nimageOffset\n\n\t\n\nNumber\n\n\t\n\nThe byte offset from the start of the binary image to the current instruction. If you add this value to the base value from the binary images list, you’ll get the runtime memory address of the instruction that’s executing. For frame 0 in each backtrace, this is the address of the machine instruction executing on a thread when the process terminated. For other stack frames, this is the address of the first machine instruction that executes after control returns to that stack frame. This runtime memory address is the value that appears next to each frame in the backtraces of the formatted report.\n\n\n\n\nsymbol\n\n\t\n\nString\n\n\t\n\nIn a fully symbolicated crash report, the name of the function that is executing.\n\n\n\n\nsymbolLocation\n\n\t\n\nNumber\n\n\t\n\nThe number of bytes from the executing instruction’s entry point. This is the value that appears after the ‘+’ next to each frame in the backtraces of the formatted report.\n\nFor details on how to use this information, see Backtraces.\n\nJSON contains numbers for the memory locations and offsets as decimal digits. To convert the numbers contained in these fields to their more common hexadecimal form, see Convert numeric values to hexadecimal numbers.\n\nBinary images\n\nA report includes information about binary images loaded in the process at the time of termination in objects with the following properties:\n\nKey\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\narch\n\n\t\n\nString\n\n\t\n\nThe CPU architecture from the binary image that the operating system loaded into the process.\n\n\n\n\nbase\n\n\t\n\nNumber\n\n\t\n\nThe binary image’s load address. This is the start of the memory address range for the loaded image that appears in a translated report.\n\n\n\n\nname\n\n\t\n\nString\n\n\t\n\nThe binary name.\n\n\n\n\npath\n\n\t\n\nString\n\n\t\n\nThe path to the binary on disk. macOS replaces user-identifable path components with placeholder values to protect privacy.\n\n\n\n\nsize\n\n\t\n\nNumber\n\n\t\n\nThe size of the image. If you add this value to the base value, you’ll get the end of the memory address range for the loaded image that appears in a translated report.\n\n\n\n\nsource\n\n\t\n\nString\n\n\t\n\nA character that indicates the binary image’s region type: P (process), S (shared cache), C (shared cache library), K (kernel), U (kernel cache), T (kernel text exec), A (absolute).\n\n\n\n\nuuid\n\n\t\n\nString\n\n\t\n\nA build UUID that uniquely identifies the binary image you can use to locate the corresponding dSYM file when symbolicating the crash report. For more information, see Building your app to include debugging information.\n\nFor details on how to use this information, see Binary images.\n\nConvert numeric values to hexadecimal numbers\n\nJSON stores numeric values as decimal numbers. Many of these numeric values, such as error codes and memory addresses, appear in a translated report as hexadecimal numbers to make them easier to interpret.\n\nYou can use the following to print a hexadecimal representation of the numbers from the decimal representation found in the JSON.\n\nimport Foundation\n\n\nlet decimal = 2343432205\n\n\nprint(String(format: \"0x%lx\", decimal))\n// Prints \"0x8badf00d\".\n\nSee Also\nCrash reports\nAdding identifiable symbol names to a crash report\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\nIdentifying the cause of common crashes\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nExamining the fields in a crash report\nUnderstand the structure of a crash report and the information each field contains.\nUnderstanding the exception types in a crash report\nLearn what the exception type tells you about why your app crashed."
  },
  {
    "title": "Analyzing a crash report | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-a-crash-report",
    "html": "Overview\n\nA crash report is a detailed log of an app’s state when it crashed, making it a crucial resource for identifying a problem before attempting to fix it. If you’re investigating a crash that isn’t resolved by the techniques discussed in Identifying the cause of common crashes, you need to do a careful analysis of the complete crash report.\n\nImportant\n\nAlways analyze a fully symbolicated crash report generated by the operating system. See Determine if a crash report is symbolicated to verify your crash report is fully symbolicated.\n\nWhen analyzing a crash report, read the information in all sections. As you formulate the hypothesis about the cause of a crash, ask questions about what the data in each section of the crash report says to refine or disprove the hypothesis. Some clues are explicitly captured by fields in the crash report, but other clues are subtle, and require you to uncover them by noticing small details. Performing a thorough analysis of a crash report and formulating a hypothesis takes time and practice to develop, but is a critical tool for making your app more robust.\n\nNote\n\nIf you request help from Apple analyzing a crash report, such as through bug reports, the Apple Developer Forums, or Developer Technical Support, always include the crash report from the operating system in its entirety. Partial crash reports from the operating system, as well as crash reports generated by third-party analytics libraries included in your app, don’t include all of the necessary information.\n\nStart from the user’s perspective\n\nFind a starting point from the crash report’s information to think about the crash from the user’s perspective to refine the hypothesis. For example, a frame in the backtrace may indicate a particular feature of the app is in use, and you can think about how other information in the crash report relates to that feature.\n\nGroup multiple crash reports according to similar and unique details\n\nIf you have many crash reports, try organizing them into groups to clarify the source of a crash. If many crash reports contain the exact same information, the problem likely is consistently reproducible, and the common details in the crash reports help you isolate the issue. If you have crash reports that all appear different, but you suspect the underlying cause is the same, pay attention to any detail that looks unusual. Place any crash reports with unusual details into their own group. By grouping crash reports based on similar and dissimilar details, you sometimes uncover insights into the cause of a crash that aren’t visible when looking at crash reports individually.\n\nCheck the header to identify the crash environment\n\nIf you have multiple crash reports that are similar, use the header information to help understand the scope of the problem, and to target the specific operating system versions and devices you need to reproduce the problem. Some questions that can help refine your hypothesis about the crash are:\n\nDoes the crash occur in multiple versions of your app, or just one?\n\nDoes the crash occur on multiple versions of the operating system?\n\nIs the crash from only one type of device, such as an iPad but not an iPhone?\n\nDid the crash originate from your main app, or from one of your app extensions?\n\nIs the crash from a TestFlight beta of your app?\n\nAre all of the crashes from the same app thinning variant? Are you able to reproduce the crash if you export the specific app variant? To export a specific app variant, see Distributing your app for beta testing and releases.\n\nWhat device model did the app crash on? How much testing did you do on a device with similar capabilities?\n\nDo multiple users experience the crash, or only a small number of unique users? Use the CrashReporter Key or the Beta Identifier fields to determine this.\n\nHow long was the app running before it crashed? Use the Date/Time and Launch Time fields to determine this.\n\nIf you’re unfamiliar with a specific field or its value in this section of crash report, consult Header.\n\nIdentify the exception information\n\nEvery crash report records exception information that shows the exact mechanism by which the app’s process terminated. Termination is always the last step in error handling, but it starts when an unrecoverable condition occurs in the app or the frameworks it uses. For example, the app may request termination directly, such as by calling abort(). As a different example, the operating system may terminate the process to enforce a system policy, such as through a watchdog that ensures app responsiveness.\n\nException information narrows the sources for the crash you’re analyzing, and helps identify the clues you look for in other sections of the crash report. See Understanding the exception types in a crash report for details on the specific exception type in the crash report you’re analyzing, and then answer the following questions:\n\nWhat is the exception type? What category of error does the exception define?\n\nWhat thread triggered the crash? What relationship do you see between the frames in the crashed thread’s backtrace and the information communicated by the exception type?\n\nWhat types of underlying issues does the exception type rule out? For example, the EXC_BAD_ACCESS exception rules out that a crash is due to an uncaught language exception.\n\nAre there any additional codes in the Termination Reason field? What does the code mean?\n\nDoes the exception type indicate specific diagnostic tools are useful for discovering the issue?\n\nIs the exception related to a specific type of system resource?\n\nIf you’re unfamiliar with a field in this section, see Exception information.\n\nLook for diagnostic messages\n\nFor certain types of problems, a crash report may contain additional diagnostic information between the Exception Information section and the Backtraces section. This information is directly related to the exception type.\n\nBased on the exception type, is the crash due to an uncaught language exception? If so, what additional information about the API throwing the exception is in the message? See Addressing language exception crashes for additional information.\n\nBased on the exception type, is the crash due to a memory access issue? See Investigating memory access crashes for how to decode the provided VM Region Info.\n\nIs there a Termination Description field indicating the involvement of a specific part of the operating system? Is there an additional code in the Termination Reason field? What hints to the source of the problem does the message provide?\n\nIs there an Application Specific Information field? Is there a specific API named in that message? Where do you use that API in your code?\n\nIf you’re unfamiliar with a field in this section, see Diagnostic messages.\n\nRead the backtraces\n\nThe backtraces in a crash report show the exact methods executing at the time of the crash—see Backtraces for a breakdown of what each column in this section means. As a starting point, look at the crashed thread, as well as the Last Exception Backtrace if one is present. Answer these questions about the backtrace:\n\nWhat function is this thread serving in the app? Is it the main thread or another thread with a specific purpose?\n\nWas a language exception thrown? What does the Last Exception Backtrace show?\n\nWhat parts of the app use this thread and the functions that appear in this thread’s backtrace?\n\nWhat mix of binaries in your app and Apple’s system frameworks are in the backtrace?\n\nEven if the functions in the backtrace aren’t ones you directly call, they contain key clues. For example, this backtrace contains only system frameworks except for the app’s main function, but the crash is due to an invalid popover configuration in an iPadOS app:\n\nLast Exception Backtrace:\n0   CoreFoundation                    0x1a1801190 __exceptionPreprocess + 228\n1   libobjc.A.dylib                   0x1a09d69f8 objc_exception_throw + 55\n2   UIKitCore                         0x1cd5d0af0 -[UIPopoverPresentationController presentationTransitionWillBegin] + 2739\n3   UIKitCore                         0x1cd5d9358 __71-[UIPresentationController _initViewHierarchyForPresentationSuperview:]_block_invoke + 2175\n4   UIKitCore                         0x1cd5d6ea4 __56-[UIPresentationController runTransitionForCurrentState]_block_invoke + 463\n5   UIKitCore                         0x1cdc5c0ac _runAfterCACommitDeferredBlocks + 295\n6   UIKitCore                         0x1cdc4abfc _cleanUpAfterCAFlushAndRunDeferredBlocks + 351\n7   UIKitCore                         0x1cdc77a6c _afterCACommitHandler + 115\n8   CoreFoundation                    0x1a179250c __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 31\n9   CoreFoundation                    0x1a178d234 __CFRunLoopDoObservers + 411\n10  CoreFoundation                    0x1a178d7b0 __CFRunLoopRun + 1227\n11  CoreFoundation                    0x1a178cfc4 CFRunLoopRunSpecific + 435\n12  GraphicsServices                  0x1a398e79c GSEventRunModal + 103\n13  UIKitCore                         0x1cdc50c38 UIApplicationMain + 211\n14  MyGreatApp                        0x10079600c main (in MyGreatApp) (AppDelegate.swift:12)\n15  libdyld.dylib                     0x1a124d8e0 start + 3\n\n\nFrames 3 and 4 provide a clue that this crash relates to presenting a view controller, and frame 2 is a clue that the app is presenting a popover. This information narrows down what parts of your app’s code to focus on, even when no code from the app is in the backtrace.\n\nYou can frequently determine the purpose of a thread based on the bottom frames in the thread’s backtrace. An app’s main thread has NSApplicationMain(_:_:) or UIApplicationMain(_:_:_:_:) in the bottom frames. Threads created through the Dispatch framework have start_wqthread in the bottom frames. As you look closer at the crashed thread’s backtrace, consider whether your app appears in a coherent state that matches your expectations about how your app functions:\n\nShould the code from the app be running on this specific thread?\n\nIs the crashed thread a background thread?\n\nDo any of the backtraces show the app manipulating UI elements on any thread except the main thread? Have you tested your app with the Main Thread Checker enabled?\n\nIf your code uses an API that takes a completion handler, does that API guarantee the specific queue the completion handler uses? Is your code expecting that queue?\n\nIf your code uses an API where you provide a DispatchQueue to the API, does the crash report show you’re using the queue you expect?\n\nIn addition to the backtrace for the crashed thread or language exception, other thread backtraces provide additional clues about what state the app is in. These clues are subtle:\n\nDo any of the other threads help indicate what state the app is in? For example, if you see threads with frames from the Contacts framework and you only access contacts in one part of your app, you can focus your investigation on the crash to that part of the app.\n\nDo any of the other thread backtraces contain frames related to the frames in the crashed thread’s backtrace? What does that say about the state of the app?\n\nAre there many threads that have similar state, such as the same set of functions from your app before frames that are waiting on system resources?\n\nIn some types of crashes, the crashed thread’s backtrace doesn’t consistently contain the source of the issue. Addressing watchdog terminations describes situations where this happens for watchdog terminations, and Investigating memory access crashes describes this scenario for memory corruption crashes.\n\nUnderstand the crashed thread’s registers\n\nAnalysis of most crash reports don’t need to consider the register state. However, if you’re investigating a difficult memory access issue, the registers provide information not found elsewhere in the crash report.\n\nIs the memory access a memory fetch, or an instruction fetch?\n\nDo the program counter, link registers, and stack pointer register contain valid addresses in your program’s address space?\n\nIf you use atos to symbolicate the address in the link register, what function is it? Does that function jump to other code through function pointers? Symbolicate the crash report with the command line describes how to use atos.\n\nIdentify the type of memory access that caused the issue describes how to use these questions to diagnose a memory access crash.\n\nVerify your frameworks are present in the binary images\n\nUse the Binary Images section of the crash report to take stock of the frameworks your app loads. You can identify the frameworks in your app by the file paths.\n\nWhat frameworks had the app loaded at the time of the crash? Are any frameworks provided by your app missing?\n\nIf a framework is missing, were you expecting the system to automatically load the framework when the app launched, or do you manually load it by calling dlopen(_:_:)?\n\nHow many frameworks are from your app? If you’re investigating a watchdog termination, a high number of frameworks inside your app can consume a significant part of the app’s launch time budget.\n\nFor the meaning of each column in this section, see Binary images.\n\nSee Also\nCrash reports\nAdding identifiable symbol names to a crash report\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\nIdentifying the cause of common crashes\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\nExamining the fields in a crash report\nUnderstand the structure of a crash report and the information each field contains.\nInterpreting the JSON format of a crash report\nUnderstand the structure and properties of the objects the system includes in the JSON of a crash report.\nUnderstanding the exception types in a crash report\nLearn what the exception type tells you about why your app crashed."
  },
  {
    "title": "Understanding the exception types in a crash report | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/understanding-the-exception-types-in-a-crash-report",
    "html": "Overview\n\nThe exception type in a crash report describes how the app terminated. It’s a key piece of information that guides how to investigate the source of the problem.\n\nException Type: EXC_BAD_ACCESS (SIGSEGV)\n\n\nNote\n\nThe exception information in this article doesn’t refer to language exceptions thrown by an API or language features in Objective-C or C++. Crash reports record language exception information separately.\n\nThe exception types are summarized here. See the sections that follow for more information.\n\nEXC_BREAKPOINT (SIGTRAP) and EXC_BAD_INSTRUCTION (SIGILL). A trace trap interrupted the process.\n\nEXC_BAD_ACCESS. The crash is due to a memory access issue. See Investigating memory access crashes.\n\nEXC_CRASH (SIGABRT). The process terminated because it received a SIGABRT.\n\nEXC_CRASH (SIGKILL). The operating system terminated the process.\n\nEXC_CRASH (SIGQUIT). The process terminated at the request of another process.\n\nEXC_GUARD. The process violated a guarded resource protection.\n\nEXC_RESOURCE. The process exceeded a resource consumption limit.\n\nEXC_ARITHMETIC. The crashed thread performed an invalid arithmetic operation, such as division by zero or a floating point error.\n\nEXC_BREAKPOINT (SIGTRAP) and EXC_BAD_INSTRUCTION (SIGILL)\n\nThe breakpoint exception type indicates a trace trap interrupted the process. A trace trap gives an attached debugger the chance to interrupt the process at a specific point in its execution. On ARM processors, this appears as EXC_BREAKPOINT (SIGTRAP). On x86_64 processors, this appears as EXC_BAD_INSTRUCTION (SIGILL).\n\nThe Swift runtime uses trace traps for specific types of unrecoverable errors—see Addressing crashes from Swift runtime errors for information on those errors. Some lower-level libraries, such as Dispatch, trap the process with this exception upon encountering an unrecoverable error, and log additional information about the error in the Additional Diagnostic Information section of the crash report. See Diagnostic messages for information about those messages.\n\nIf you want to use the same technique in your own code for unrecoverable errors, call the __builtin_trap() function. This allows the system to generate a crash report with thread backtraces that show how you reached the unrecoverable error.\n\nEXC_CRASH (SIGABRT)\n\nEXC_CRASH (SIGABRT) indicates the process terminated because it received the SIGABRT signal. Typically, this signal is sent because a function in the process called abort(), such as when an app encounters an uncaught Objective-C or C++ language exception. Addressing language exception crashes explains how to handle uncaught language exceptions in more detail.\n\nIf there isn’t a Last Exception Backtrace indicating a langauge exception triggered the crash, look at the crashed thread’s backtrace to determine if code in the process called abort().\n\nWhen an app extension takes too much time to initialize, the operating system sends a SIGABRT to the app extension process. These crashes include an Exception Subtype field with the value LAUNCH_HANG. Because extensions don’t have a main function, any time spent initializing occurs within static constructors and load() methods present in your extension and dependent libraries. Although the exception information is different in a watchdog termination, investigate the LAUNCH_HANG with the same techniques discussed in Addressing watchdog terminations.\n\nEXC_CRASH (SIGKILL)\n\nEXC_CRASH (SIGKILL) indicates the operating system terminated the process. The crash report contains a Termination Reason field with a code that explains the reason for the crash. In the following example, that code is 0xdead10cc:\n\nException Type:  EXC_CRASH (SIGKILL)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\nTermination Reason: Namespace RUNNINGBOARD, Code 0xdead10cc\n\n\nThe code is one of the following values:\n\n0x2182bad2 (562215634)\n\nThe operating system terminated the app due to a background task failing to complete in time.\n\n0x2182bad3 (562215635)\n\nThe operating system terminated the app due to a background URL session failing to complete in time.\n\n0x2182bad4 (562215636)\n\nThe operating system terminated the app due to a background fetch failing to complete in time.\n\n0x8badf00d (2343432205) — pronounced “ate bad food”\n\nThe operating system’s watchdog terminated the app. See Addressing watchdog terminations.\n\n0xc00010ff (3221229823) — pronounced “cool off”\n\nThe operating system terminated the app due to a thermal event. This can be an issue with the particular device that this crash occurred on, or the environment it operated in. For tips on making your app run more efficiently, watch the iOS Performance and Power Optimization with Instruments WWDC session.\n\n0xdead10cc (3735883980) — pronounced “dead lock”\n\nThe operating system terminated the app because it held on to a file lock or SQLite database lock during suspension. Request additional background execution time on the main thread with beginBackgroundTask(withName:expirationHandler:). Make this request well before starting to write to the file in order to complete those operations and relinquish the lock before the app suspends. In an app extension, use beginActivity(options:reason:) to manage this work.\n\n0xbaadca11 (3131951633) — pronounced “bad call”\n\nThe operating system terminated the app for failing to report a CallKit call in response to a PushKit notification.\n\n0xbad22222 (3134333474)\n\nThe operating system terminated a VoIP application because it resumed too frequently.\n\n0xbaddd15c (3135099228) — pronounced “bad disc”\n\nThe operating system terminated the app to delete caches in an attempt to reclaim disk space. Many factors contribute to low disk space. You may be able to help by minimizing what you write to disk and managing the entire life cycle of your files.\n\n0xc51bad01 (3306925313)\n\nwatchOS terminated the app because it used too much CPU time while performing a background task. Optimize the code performing the background task to be more CPU efficient, or decrease the amount of work that the app performs while running in the background to resolve this crash.\n\n0xc51bad02 (3306925314)\n\nwatchOS terminated the app because it failed to complete a background task within the allocated time. Decrease the amount of work that the app performs while running in the background to resolve this crash.\n\n0xc51bad03 (3306925315)\n\nwatchOS terminated the app because it failed to complete a background task within the allocated time, but the system was sufficiently busy overall that the app may not have received much CPU time to perform the background task. Although you may be able to avoid the issue by reducing the amount of work your app performs in background tasks, 0xc51bad03 doesn’t indicate that the app did anything wrong. More likely, the app wasn’t able to complete its work because of overall system load.\n\n0xd00d2bad (3490524077)\n\nThe operating system terminated the app due to excessive use of key system resources. You might be able to avoid the issue by reducing parallelization and insuring that your app completes operations for preceding tasks before starting new tasks.\n\nEXC_CRASH (SIGQUIT)\n\nEXC_CRASH (SIGQUIT) indicates the process terminated at the request of another process with privileges to manage its lifetime. SIGQUIT doesn’t mean that the process crashed, but it likely misbehaved in a detectable manner.\n\nWith iOS and iPadOS keyboard extensions, the host app terminates the keyboard extension if it takes too long to load. Although the exception information is different in a watchdog termination, investiage EXC_CRASH (SIGQUIT) with the same techniques discussed in Addressing watchdog terminations.\n\nEXC_GUARD\n\nEXC_GUARD indicates the process violated a guarded resource protection. Although there are multiple types of guarded system resources, most guarded resource crashes are from guarded file descriptors, which have the GUARD_TYPE_FD value in the Exception Subtype field. The operating system marks a file descriptor as guarded so that normal file descriptor APIs can’t modify them. For example, if an app closes the file descriptor used to access the SQLite file backing a Core Data store, Core Data could mysteriously crash much later on. The guard file description identifies these problems when they happen, making them easier to identify and address.\n\nThe Exception Message field contains the specific violation:\n\nCLOSE\n\nThe process attempted to invoke close() on a guarded file descriptor.\n\nDUP\n\nThe process attempted to invoke dup(), dup2(), or fcntl() with the F_DUPFD or F_DUPFD_CLOEXEC commands on a guarded file descriptor.\n\nNOCLOEXEC\n\nThe process attempted to remove the FD_CLOEXEC flag from a guarded file descriptor.\n\nSOCKET_IPC\n\nThe process attempted to send a guarded file descriptor through a socket.\n\nFILEPORT\n\nThe process attempted to obtain a Mach send right for a guarded file descriptor.\n\nWRITE\n\nThe process attempted to write to a guarded file descriptor.\n\nThe Exception Message field also identifies the specific guarded file descriptor that the process attempted to modify. To understand the context triggering this exception, consult the backtrace of the crashed thread.\n\nEXC_RESOURCE\n\nEXC_RESOURCE is a notification from the operating system that the process exceeded a resource consumption limit. If the Exception Note field contains NON-FATAL CONDITION, then the process wasn’t terminated even though the operating system generated a crash report. The Exception Message field describes the amount of resources consumed over a specific time interval.\n\nThe crash report lists the specific resource in the Exception Subtype field:\n\nCPU and CPU_FATAL\n\nA thread in the process used too much CPU over a short period of time.\n\nMEMORY\n\nThe process crossed a memory limit imposed by the system. This may be a precursor to termination for excess memory usage.\n\nIO\n\nThe process caused an excessive amount of disk writes over a short period of time.\n\nWAKEUPS\n\nThreads in the process woke up too many times per second, which consumes battery life. Thread-to-thread communication APIs, such as perform(_:on:with:waitUntilDone:), async(execute:), or dispatch_async, cause this when unwittingly called far more often than expected. Because the communication that triggers this exception is happening so frequently, there usually are multiple background threads with very similar backtraces that indicate the origin of the thread communication. See Modernizing Grand Central Dispatch Usage for how to manage concurrent workloads more efficiently.\n\nSee Also\nCrash reports\nAdding identifiable symbol names to a crash report\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\nIdentifying the cause of common crashes\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nExamining the fields in a crash report\nUnderstand the structure of a crash report and the information each field contains.\nInterpreting the JSON format of a crash report\nUnderstand the structure and properties of the objects the system includes in the JSON of a crash report."
  },
  {
    "title": "Acquiring crash reports and diagnostic logs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/acquiring-crash-reports-and-diagnostic-logs",
    "html": "Overview\n\nAfter your app is distributed to customers, learn ways to improve it by collecting crash reports and diagnostic logs. If a customer reports an issue with your app, use the Crashes organizer in Xcode to get a report about the issue, as described in How are reports created? If the Crashes organizer doesn’t contain the diagnostic information you need or is unavailable to you, the customer can collect logs from their device and share them directly with you to resolve the issue. Once you have a crash report, you may need to add identifiable symbol information to the crash report—see Adding identifiable symbol names to a crash report for more information.\n\nFor issues that aren’t crashes, inspect the operating system’s console log to find important information for diagnosing the issue’s source.\n\nCollect crash reports from TestFlight and the App Store\n\nTestFlight and the App Store collect crash reports for every submitted version of your app. Crash reports automatically contain identifiable symbol information if you include symbol information when submitting a build to the App Store. Review Building your app to include debugging information for the recommended settings.\n\nCrash reports from customers who send diagnostic and usage information are presented in the Crashes organizer, as described in Share crash, energy, and metrics data with developers. TestFlight users of your app automatically share crash reports with you, regardless of the device settings for sharing diagnostic and use data. If no crash reports appear in the Crashes organizer, see If no crash, energy, or metrics reports appear in the organizer to enable collection of crash reports from your customers.\n\nThe following crash report types aren’t available through the Crashes organizer, but are available by other means. See Transfer crash reports and device logs to a Mac and Locate crash reports and memory logs on the device.\n\nWatchdog events, such as those from slow app launch times\n\nInvalid code-signature crashes\n\nThermal events, where a device overheats because an app uses too much CPU\n\nJetsam events, where an app has high memory use\n\nTransfer crash reports and device logs to a Mac\n\nIf you have access to the device on which your app crashes, you can transfer diagnostic logs by connecting the device to your Mac. You can view these logs using the Devices and Simulators window in Xcode, described in About Devices and Simulators window.\n\nIf a customer reports a crash, they can transfer the crash report to either a Mac or Windows computer. See Find device crash and energy logs on a Mac or Windows computer.\n\nLocate crash reports and memory logs on the device\n\nIf a customer reports a crash in your app and you don’t have a crash report for it in the Crashes organizer, ask the customer to e-mail you the crash report from their device.\n\nNote\n\nCrash reports from watchOS are available on the paired iPhone.\n\nTo locate and email crash reports for iOS, iPadOS, watchOS, and tvOS apps:\n\nOpen the Analytics & Improvements section of Settings on the device. See Share analytics, diagnostics, and usage information with Apple.\n\nTap Analytics Data.\n\nLocate the log for your app. The log name starts with <AppBinaryName>_<DateTime> for crash reports, or JetsamEvent_<DateTime> for high-memory use crashes.\n\nSelect the desired log.\n\nTap the Share icon, and select Mail to send the crash report as a mail attachment.\n\nTo locate and email crash reports for macOS and Mac Catalyst apps:\n\nOpen the Console app, from Applications > Utilities in Finder.\n\nSelect Crash Reports.\n\nLocate crash reports for your app in the list. Logs are listed by your app’s binary name.\n\nRight-click the desired log’s file name.\n\nSelect Reveal in Finder.\n\nDrag the file displayed in Finder to Mail to send the crash report as a mail attachment.\n\nCreate a crash report while debugging\n\nIf you encounter a crash while debugging your app using Xcode, the debugger intercepts the crash so you can inspect your app’s state. If you’d like to gather the full crash report for the issue, detach the debugger, either by using the Debug > Detach menu item in Xcode, or by issuing the detach command in the debugging console. This allows the app to finish crashing and lets the operating system generate the crash report. See Locate crash reports and memory logs on the device for how to collect the crash report file.\n\nAccess device console logs\n\nIf a customer reports an issue in your app that isn’t a crash, look at the device’s console log for additional information about the issue.\n\nTo access a device’s console logs:\n\nFor iOS, iPadOS, and tvOS issues, connect the device to your Mac. For watchOS issues, install the logging profile to the paired iPhone and then connect the iPhone to your Mac. See Profiles and Logs to download the profile. For macOS issues, proceed to the next step.\n\nOn the Mac, open the Console app, from Applications > Utilities in Finder.\n\nSelect the device in the Console sidebar.\n\nReproduce the issue and note the exact time.\n\nLook for logs that pertain to the issue from around the time you reproduced the issue.\n\nUse information from the log as clues to further guide your investigation of the issue.\n\nSee Also\nRelated Documentation\nAdding identifiable symbol names to a crash report\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\nIdentifying the cause of common crashes\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nIdentifying high-memory use with jetsam event reports\nDiscover why the operating system terminated your app when available memory was low."
  },
  {
    "title": "Reporting feedback for Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reporting-feedback-for-xcode-cloud",
    "html": "Overview\n\nYou can file feedback about Xcode Cloud directly from a build in the Report Navigator. When you file feedback from a build, the system prepopulates the feedback form with build-specific context that Apple can use to triage a bug.\n\nThe prepopulated information includes details describing the build as well as logs and build artifacts that may provide clues about the causes of a bug.\n\nImportant\n\nThese artifacts and logs might contain personal data and intellectual property. You can opt out of providing any or all of these files before submitting feedback.\n\nInitiate feedback\n\nTo report feedback that’s not related to a specific build, select Help > Provide Feedback in Xcode or launch the Feedback Assistant app. In cases where you need to report feedback that includes build-specific context:\n\nNavigate to the specific build number in the Report Navigator’s outline view.\n\nControl-click on the build number to open a context menu.\n\nChoose Send Feedback.\n\nAlternatively, to issue a report from an issue banner inside a build in Xcode, click the Report Issue button.\n\nBy initiating feedback from a specific build, Xcode prepopulates the feedback form with relevant information, details describing the build (such as team name, product name, and build number) and the system-generated logs and artifacts relevant to triaging issues related to builds.\n\nReview the attachments\n\nText logs from commands initiated by Xcode Cloud, result bundles, and sysdiagnose logs are very useful when triaging a build-related issue. Provide these logs to help make bugs more actionable, but review the logs before you submit feedback.\n\nTo review a specific attachment, select the magnifying glass icon on the right of the item listed under Attachments. This opens Finder to the location of the attachment on disk.\n\nAt a high level, there are 5 different types of logs and build artifacts:\n\nExecutable build artifacts\n\nThese are the products of building an app or its tests to be run on a specific kind of device or simulator. Examples of these include: product archives and test products. Product archives, such as App Store archive exports, represent the app that you install on a device. Test products, on the other hand, represent executables that run during the testing process.\n\nText logs from scripts you provide\n\nThese are the logs for the custom scripts you provide. These logs can contain network requests, entries of subcommands that run, as well as credentials used to authenticate to other services.\n\nText logs from commands initiated by Xcode Cloud\n\nXcode Cloud relies on certain command-line tools when processing a build. An example of such a command-line tool is xcodebuild which Xcode Cloud uses to archive exports, build products, and run tests. These logs contain the output command-line tools and network requests generate. These logs can contain information from the product source code such as names of classes and methods.\n\nResult bundles\n\nThese are special artifacts that xcodebuild subcommands such as archive, build, and test generate. Result bundles contain a summary of events that occur during an xcodebuild subcommand and can contain traces of intellectual property. To learn more about bundles, see Bundle.\n\nSysdiagnose logs\n\nThese are special artifacts Xcode Cloud generates in exceptional scenarios, such as a Simulator or virtual machine crash. Sysdiagnose logs contain a collection of logs from diagnostic tools available on different Apple platforms. These logs provide context about the state of the machine just before the crash such as the number of open file handles and the state of different processes.\n\nRemove attachments and submit feedback\n\nOnly include attachments you want to share. To remove an attachment you don’t want to share:\n\nSelect the trash icon next to the item listed under Attachments.\n\nTo confirm the removal, select Remove from the Feedback Assistant dialog.\n\nWhen the report reflects the feedback you would like to share, click the Submit button to send the feedback to Apple.\n\nSee Also\nTroubleshooting\nResolving common configuration and build issues\nReview common configuration and build issues and learn how you can resolve them.\nResolve GitHub Enterprise connection issues\nVerify that Xcode Cloud can access your GitHub Enterprise repository and fix configuration issues."
  },
  {
    "title": "Inspecting live resources at runtime | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-live-resources-at-runtime",
    "html": "Overview\n\nYou can preview contents of textures and buffers while debugging your app in Xcode by pausing on a breakpoint, inspecting a variable that references the resource, and then clicking the Preview button. This is one quick way to validate that your resources have the correct contents while debugging at runtime.\n\nImportant\n\nIf you disable GPU Frame Capture, you can’t inspect resource content while your app is running. See Capturing a Metal workload in Xcode to learn how to reenable it.\n\nInspect your textures and buffers\n\nFirst, pause the app inside a scope that contains a variable referencing the resource. You can achieve this by setting a breakpoint on a line that references the resource. To set a breakpoint, click the line number to the left of the source editor. The example below shows a breakpoint for the line where _skyMap is bound to the render encoder:\n\nThen, when yor app pauses at the breakpoint, move the pointer over the variable referencing the resource to reveal the Value inspector.\n\nFinally, click the Preview button to show the contents of the resource.\n\nIf the resource is a texture and has multiple slices, like the sky map above, you can drag the slider at the bottom of the Preview popover to see each slice. If the resource has any unexpected values, you can investigate further with the Metal debugger (see Investigating visual artifacts).\n\nSee Also\nRuntime diagnostics\nValidating your app’s Metal API usage\nCatch runtime issues in your Metal app using API Validation.\nValidating your app’s Metal shader usage\nCatch common shader runtime issues using Shader Validation while your app is running.\nMonitoring your Metal app’s graphics performance\nCatch performance issues using the Metal Performance HUD while your app is running."
  },
  {
    "title": "Nonnull return value violation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/nonnull-return-value-violation",
    "html": "Overview\n\nUse this check to detect when a function with the returns_nonnull attribute, or a function with a return type that has the _Nonnull annotation, returns null. Available in Xcode 9 and later.\n\nNote\n\nThe nonnull violation check for return types with the _Nonnull annotation is off by default. You can turn it on by enabling the -fsanitize=nullability-return compiler flag.\n\nViolation of the nonnull attribute for a function in C\n\nIn the following code, there is a violation of the returns_nonnull attribute of the nonnull_returning_function function:\n\n__attribute__((returns_nonnull)) int *nonnull_returning_function(int *p) {\n    return p; // Warning: NULL can be returned here\n}\nnonnull_returning_function(NULL); // Error: nonnull return value attribute violation\n\nSolution\n\nCorrect logic errors, add any necessary null guards to the function, or remove the returns_nonnull attribute and rework the function caller logic accordingly.\n\nViolation of the nonnull annotation for a return type in C\n\nThe following code violates the _Nonnull annotation of the return type for the nonnull_returning_function function:\n\nint *_Nonnull nonnull_returning_function(int *p) {\n    return p; // Warning: NULL can be returned here\n}\nnonnull_returning_function(NULL); // Error: nonnull return value attribute violation\n\nSolution\n\nCorrect logic errors, add any necessary null guards to the function, or remove the _Nonnull annotation and rework the function caller logic accordingly.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Nonnull argument violation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/nonnull-argument-violation",
    "html": "Overview\n\nUse this check to detect when a function that has an argument with the nonnull attribute or the _Nonnull annotation receives a null value. Available in Xcode 9 and later.\n\nNote\n\nThe nonnull violation check for arguments with the _Nonnull annotation is off by default. You can turn it on by enabling the -fsanitize=nullability-arg compiler flag.\n\nViolation of the nonnull parameter attribute in C\n\nIn the following example, the call to the has_nonnull_argument function breaks the nonnull attribute of the parameter p:\n\nvoid has_nonnull_argument(__attribute__((nonnull)) int *p) { \n     // ... \n}\nhas_nonnull_argument(NULL); // Error: nonnull parameter attribute violation\n\nSolution\n\nCorrect logic errors, or remove the nonnull attribute and rework the called function’s logic accordingly.\n\nViolation of the nonnull annotation for an argument in C\n\nIn the following example, the call to the has_nonnull_argument function breaks the _Nonnull annotation of the parameter p:\n\nvoid has_nonnull_argument(int * _Nonnull p) { \n     // ... \n}\nhas_nonnull_argument(NULL); // Error: _Nonnull annotation violation\n\nSolution\n\nCorrect logic errors, or remove the _Nonnull attribute and rework the called function’s logic accordingly.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Invalid float cast | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/invalid-float-cast",
    "html": "Overview\n\nUse this check to detect out-of-range casts to, from, or between floating-point types. Invalid casts have undefined behavior, and typically yield arbitrary values. These values may differ from platform to platform. Available in Xcode 9 and later.\n\nInvalid assignment of a double to a float in C\n\nThe cast from n to m results in undefined behavior because the destination type can’t represent its value.\n\ndouble n = 10e50;\nfloat m = (float)n; // Error: 10e50 can't be represented as a float.\n\nSolution\n\nUse a different destination type or avoid the cast altogether.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Division by zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/division-by-zero",
    "html": "Overview\n\nUse this check to detect integer and float division where the divisor is zero. Division by zero has undefined behavior, and can result in crashes or incorrect program output. Available in Xcode 9 and later.\n\nInteger division by zero in C\n\nIn the following code, the for loop performs division by zero on its first iteration:\n\nint sum = 10;\nfor (int i = 0; i < 64; ++i) {\n    sum /= i; // Error: division by zero on the first iteration\n}\n\n\nNote\n\nThe optimizer may remove parts of a loop if it determines that undefined behavior might trigger in any of its iterations.\n\nSolution\n\nModify the logic to check for and avoid division when the divisor might equal zero.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Null reference creation and null pointer dereference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/null-reference-creation-and-null-pointer-dereference",
    "html": "Overview\n\nIn Xcode 9 and later, you can use this check to detect the creation of null references and null pointer dereferences. Dereferencing a null pointer always results in undefined behavior and can cause crashes. If the compiler finds a pointer dereference, it treats that pointer as nonnull. As a result, the optimizer may remove null equality checks for dereferenced pointers.\n\nCreating a null reference in C++\n\nThe following example demonstrates how to create a null reference. References in C++ must be nonnull:\n\nint &x = *(int *)nullptr; // Error: null reference\n\nSolution\n\nUse a pointer instead.\n\nint *x = nullptr; // Correct\n\nMember access through a null pointer in C++\n\nThe following code makes a member call on an object with a null address. The compiler may remove the null check on the this pointer because it requires the pointer to be nonnull.\n\nstruct A {\n    int x;\n    int getX() {\n        if (!this) { // Warning: redundant null check may be removed\n            return 0;\n        }\n        return x; // Warning: 'this' pointer is null, but is dereferenced here\n    }\n};\nA *a = nullptr;\nint x = a->getX(); // Error: member access through null pointer\n\n\nImportant\n\nAlways avoid null checks on the this pointer.\n\nSolution\n\nAvoid calling methods on null objects.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Nonnull variable assignment violation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/nonnull-variable-assignment-violation",
    "html": "Overview\n\nUse this check to detect when you assign null to a variable with the _Nonnull annotation. Available in Xcode 9 and later.\n\nNote\n\nThe nonnull violation check for variable assignment is off by default. You can turn it on by enabling the -fsanitize=nullability-assign compiler flag.\n\nViolation of nonnull annotation with variable assignment in C\n\nIn the following example, the call to assigns_a_value breaks the _Nonnull annotation of the variable q:\n\nvoid assigns_a_value(int *p) {     \n    int *_Nonnull q = p; // Warning: null can be assigned\n}\nassigns_a_value(NULL); // Error: _Nonnull variable violation\n\nSolution\n\nCorrect logic errors, or remove the _Nonnull annotation.\n\nSee Also\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds."
  },
  {
    "title": "Doing basic optimization to reduce your app’s size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/doing-basic-optimization-to-reduce-your-app-s-size",
    "html": "Overview\n\nAfter you’ve measured your app’s size, you can do some basic optimizations to make it smaller. If you’re starting a new app project, create a solid foundation for your app by adopting technologies like asset catalogs. By adopting these technologies early, you may reduce the possibility of needing costly optimizations later.\n\nCheck your target’s build settings for release builds\n\nAfter you’ve measured your app’s size, you may discover that it’s larger than you expected. This can happen if you’ve unintentionally changed the project’s settings. The default optimization level for the Release configuration is Fastest, Smallest [-Os], which can make your compiled binary very small. Check your target’s build settings, and be sure you’re using this optimization level.\n\nIdentify and remove unused assets\n\nNext, look inside your app’s IPA file to find out if your app contains unused assets or unnecessary files. First follow the steps described in Reducing your app’s size to create a thinned IPA file for each of your app’s variants. Then do the following:\n\nOpen Finder and navigate to the IPA file that you want to inspect.\n\nChange the extension of the IPA file to ZIP. (An IPA file is just a ZIP archive that has a particular structure when unzipped.)\n\nUnzip the file to show the app bundle inside the Payloads directory. You can either open the ZIP file in Finder, or run unzip -lv /path/to/your/app.zip in the Terminal app.\n\nRight-click the app bundle, and choose Show Package Contents.\n\nWhere appropriate, remove any unused files from your Xcode project or targets. For example, make sure you’re not adding your app’s README file to a target, remove any unused image assets and header files, and so on.\n\nAdopt asset catalogs for your app’s resources\n\nAsset catalogs allow Xcode and the App Store to optimize your app’s assets, which can significantly reduce the size of your app. Use asset catalogs instead of putting your assets in your app bundle directly; then do the following:\n\nTag each asset—for example images, textures, or data assets—with relevant metadata to indicate which devices the asset is for. Doing so maximizes the size reduction that app thinning provides, which can be significant for apps with assets that aren’t required by every device.\n\nDefine a resizable center area of an image with optional end caps to reduce its size. To learn more, see Add a resizable area to an image.\n\nSet the level of compression for each asset type. In particular, for apps using wide color images or textures with Metal, consider the ASTC compression options. For more information on compressing wide color images or textures, watch the WWDC session Working With Wide Color.\n\nTo learn more about asset catalogs, see Adding images to your Xcode project and Managing assets with asset catalogs, and watch App Thinning in Xcode.\n\nUse asset files for data that ships with your app\n\nAs you inspect your app’s IPA file, you may find that your app’s binaries take up a lot of space. If you ship your app with data, consider using asset files instead of putting the data into your code. For example, use a property list for bundling any data with your app instead of using strings in code. Also, some developers use source code to ship other resources; for example, images. Consider using asset files instead, and put them in an asset catalog. Moving data and assets out of your source code and into asset files significantly reduces the size of your app’s binary. It also allows App Store Connect to more efficiently compress your app.\n\nSee Also\nSize optimization\nDoing advanced optimization to further reduce your app’s size\nOptimize your app’s asset files, adopt on-demand resources, and reduce the size of app updates."
  },
  {
    "title": "Addressing watchdog terminations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/addressing-watchdog-terminations",
    "html": "Overview\n\nUsers expect apps to launch quickly, and are responsive to touches and gestures. The operating system employs a watchdog that monitors launch times and app responsiveness, and terminates unresponsive apps. Watchdog terminations use the code 0x8badf00d (pronounced “ate bad food”) in the Termination Reason of a crash report:\n\nException Type:  EXC_CRASH (SIGKILL)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\nTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00d\n\n\nThe watchdog terminates apps that block the main thread for a significant time. There are many ways to block the main thread for an extended time, such as:\n\nSynchronous networking\n\nProcessing large amouts of data, such as large JSON files or 3D models\n\nTriggering lightweight migration for a large Core Data store synchronously\n\nAnalysis requests with Vision\n\nTo understand why blocking the main thread is an issue, consider the most common example, loading data into the UI from a synchronous network call. If the main thread is busy with a network request, the system can’t handle UI events, such as multiple scroll events, until after completing the network call. If the network call takes a long time, there’s a significant time from when the user scrolls to when the app responds to the scroll events. This makes the app feel unresponsive.\n\nInterpret the app responsiveness watchdog information\n\nWhen an app is slow to launch or respond to events, the termination information in the crash report contains important information about how the app spent its time. For example, an iOS app that doesn’t render the UI quickly after launch has the following in the crash report:\n\nTermination Description: SPRINGBOARD, \n    scene-create watchdog transgression: application<com.example.MyCoolApp>:667\n    exhausted real (wall clock) time allowance of 19.97 seconds \n    | ProcessVisibility: Foreground \n    | ProcessState: Running \n    | WatchdogEvent: scene-create \n    | WatchdogVisibility: Foreground \n    | WatchdogCPUStatistics: ( \n    |  \"Elapsed total CPU time (seconds): 15.290 (user 15.290, system 0.000), 28% CPU\", \n    |  \"Elapsed application CPU time (seconds): 0.367, 1% CPU\" \n    | )\n\n\nNote\n\nFor readability, this example includes extra line breaks. In the original crash report file for this example, the watchdog information is on fewer lines.\n\nWhen scene-create appears in the Termination Description, the app didn’t render the first frame of its UI to the screen within the allowed wall clock time. If scene-update appears in the Termination Description instead of scene-create, the app didn’t update its UI quick enough because the main thread is too busy.\n\nNote\n\nThe scene-create and scene-update terminology used in the crash report refers to any content drawn to the device’s screen. This terminology has no relation to UIScene in a scene-based UIKit app.\n\nThe Elapsed total CPU time shows how much time the CPU ran for all processes on the system within the wall clock time. This CPU time, as well as the application CPU time, is for the total CPU utilization across CPU cores, which can exceed 100%. For example, if one CPU core is at 100% utilization and a second CPU core is at 20% utilization, the total CPU utalization is 120%.\n\nThe Elapsed application CPU time shows how much time the app spent running on the CPU within the wall clock time. If this number is at either extreme, it is a hint to the problem. If this number is high, the app is performing significant work across all of its threads—the number aggregates all threads, and isn’t specific to the main thread. If this number is low, the app is mostly idle, because it is waiting on system resources, such as a network connection.\n\nInterpret background task watchdog information (watchOS)\n\nIn addition to the app responsiveness watchdog, watchOS has a watchdog for background tasks. In this example, an app didn’t complete handling a Watch Connectivity background task within the time allowance:\n\nTermination Reason: CAROUSEL, WatchConnectivity watchdog transgression. \n    Exhausted wall time allowance of 15.00 seconds.\nTermination Description: SPRINGBOARD,\n    CSLHandleBackgroundWCSessionAction watchdog transgression: xpcservice<com.example.MyCoolApp.watchkitapp.watchextension>:220:220 \n    exhausted real (wall clock) time allowance of 15.00 seconds \n    | <FBExtensionProcess: 0x16df02a0; xpcservice<com.example.MyCoolApp.watchkitapp.watchextension>:220:220; typeID: com.apple.watchkit> \n      Elapsed total CPU time (seconds): 24.040 (user 24.040, system 0.000), 81% CPU \n    | Elapsed application CPU time (seconds): 1.223, 6% CPU, lastUpdate 2020-01-20 11:56:01 +0000\n\n\nNote\n\nFor readability, this example includes extra line breaks. In the original crash report file for this example, the watchdog information is on fewer lines.\n\nIntrepret the information about wall clock time and CPU time as described in Interpret the app responsiveness watchdog information.\n\nIdentify the reason the watchdog triggered\n\nThe backtraces are sometimes helpful in identifying what is taking so much time on the app’s main thread. For example, if an app uses synchronous networking on the main thread, networking functions are visible in the main thread’s backtrace.\n\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libsystem_kernel.dylib            0x00000001c22f8670 semaphore_wait_trap + 8\n1   libdispatch.dylib                 0x00000001c2195890 _dispatch_sema4_wait$VARIANT$mp + 24\n2   libdispatch.dylib                 0x00000001c2195ed4 _dispatch_semaphore_wait_slow + 140\n3   CFNetwork                         0x00000001c57d9d34 CFURLConnectionSendSynchronousRequest + 388\n4   CFNetwork                         0x00000001c5753988 +[NSURLConnection sendSynchronousRequest:returningResponse:error:] + 116  + 14728\n5   Foundation                        0x00000001c287821c -[NSString initWithContentsOfURL:usedEncoding:error:] + 256\n6   libswiftFoundation.dylib          0x00000001f7127284 NSString.__allocating_init+ 680580 (contentsOf:usedEncoding:) + 104\n7   libswiftFoundation.dylib          0x00000001f712738c String.init+ 680844 (contentsOf:) + 96\n8   MyCoolApp                         0x00000001009d31e0 ViewController.loadData() (in MyCoolApp) (ViewController.swift:21)\n\n\nHowever, the main thread’s backtrace doesn’t always contain the source of the issue. For example, imagine that your app needs exactly 4 seconds to complete a task out of a total allowed wall clock time of 5 seconds. When the watchdog terminates the app after 5 seconds, the code that took 4 seconds won’t show up in the backtrace because it completed, yet it consumed almost the entire time budget. The crash report instead records the backtrace frames of what the app was doing at the time the watchdog terminated it, even though the recorded backtrace frames aren’t the source of the problem.\n\nYou may be able to use the information from all backtraces in the crash report to help identify where you are in the app’s launch process. By working backwards based on this information, you can identify what code already ran to narrow your investigation to that code.\n\nIn addition, profile your app’s performance during development to eliminate problems before releasing the app, and monitor the app’s performance after the app is released. Reducing your app’s launch time and Improving app responsiveness provide more information on these techniques.\n\nIdentify hidden synchronous networking code\n\nSynchronous networking that blocks the main thread and leads to a watchdog termination are sometimes hidden behind abstraction layers that mask the danger. The example backtrace in Identify the reason the watchdog triggered shows the app triggered the synchronous download by calling init(contentsOf:) with a https URL, in frame 7. This API implicitly makes a synchronous network request before returning from the initializer. Even if this initalizer completed quickly and wasn’t in the crash report, it still can contribute to a watchdog termination. Other classes with an initalizer that takes a URL parameter, such as XMLParser and NSData, behave in the same way.\n\nOther common examples of hidden synchronous networking include the following:\n\nSCNetworkReachability, the reachability API, operates synchronously by default. Seemingly innocuous functions like SCNetworkReachabilityGetFlags(_:_:) can trigger a termination by the watchdog.\n\nDNS functions provided by BSD, like gethostbyname(_:) and gethostbyaddr(_:_:_:), are never safe to call on the main thread. Functions like getnameinfo(_:_:_:_:_:_:_:) and getaddrinfo(_:_:_:_:) are only safe if you’re working exclusively with IP addresses and not DNS names (that is, you specify AI_NUMERICHOST and NI_NUMERICHOST, respectively).\n\nSynchronous networking issues depend a great deal on the network environment. If you always test your app in your office, where network connectivity is good, you’ll never see this type of issue. However, once you start deploying your app to users—who run apps in all sorts of network environments—synchronous networking problems become common. In Xcode, you can simulate adverse network conditions to aid testing your app under the conditions your users encounter. See Test under adverse device conditions (iOS).\n\nMove code off the main thread\n\nMove all long-running code not essential to your app’s UI to a background queue. By moving this work to a background queue, the app’s main thread can complete the app’s launch faster and process events quicker. Using a networking example, rather than performing a synchronous network call on the main thread, move it to an asynchronous background queue. By moving this work to a background queue, the main thread can process scroll events as they happen, allowing the app to be more responsive.\n\nIf the long-running code is from one of the system frameworks, determine whether the framework provides an alternate approach that moves the work off the main thread. For example, consider loading a complex 3D model in RealityKit using loadAsync(contentsOf:withName:) instead of load(contentsOf:withName:), which is synchronous. As a different example, Vision provides preferBackgroundProcessing, which is a hint that the system should move processing of analysis requests off the main thread.\n\nIf networking code is contributing to your watchdog termination, consider these common solutions:\n\nRun your networking code asynchronously using URLSession. This is the best solution. Asynchronous networking code has many advantages, including accessing the network safely without having to worry about threads.\n\nInstead of using SCNetworkReachability, use NWPathMonitor to receive updates when the network path changes. The system delivers updates on a queue that you pass in when calling start(queue:), so path updates function safely off the main thread.\n\nPerform synchronous networking on a secondary thread. If it’s prohibitively difficult to run your networking code asynchronously, such as when using a large portable code base that assumes synchronous networking, avoid the watchdog by running the synchronous networking code on a secondary thread.\n\nResolving DNS manually isn’t recommended for most situations. Use URLSession to have the system handle DNS resolution on your behalf. If it’s prohibitively difficult to switch and you continue to need to DNS addresses manually, use an asynchronous API like CFHost or the APIs in <dns_sd.h>.\n\nSee Also\nRelated Documentation\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems."
  },
  {
    "title": "Identifying high-memory use with jetsam event reports | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/identifying-high-memory-use-with-jetsam-event-reports",
    "html": "Overview\n\niOS, iPadOS, watchOS, and tvOS have a virtual memory system that relies on all apps releasing memory when the operating system encounters memory pressure, where available memory is low and the system can’t meet the demands of all running apps. Under memory pressure, apps free memory after receiving a low-memory notification. If all running apps release enough total memory to alleviate memory pressure, your app will continue to run. But, if memory pressure continues because apps haven’t relinquished enough memory, the system frees memory by terminating applications to reclaim their memory. This is a jetsam event, and the system creates a jetsam event report with information about why it chose to jettison an app.\n\nJetsam event reports differ from crash reports because they contain the overall memory use of all apps and system processes on a device, they’re in JSON format, and they don’t contain the backtraces of any threads in your app. If the system jettisons your app due to memory pressure while the app is visible, it will look like your app crashed. Use jetsam event reports to identify your app’s role in jetsam events, even if your app didn’t get jettisoned.\n\nIdentify the memory page size and largest process\n\nThe jetsam event report records how much memory each process used before jettisoning an app. The virtual memory system allocates and manages memory in chunks, called memory pages, and the report lists the memory use as the number of memory pages used. To convert the number of memory pages into the bytes of memory your app used, you need to know the page size, which is the number of bytes in one memory page.\n\nThe pageSize field in the jetsam event report header records the number of bytes in each memory page. In addition to the page size, the header of a jetsam report describes the overall device environment, such as the operating system version and hardware model. In this example, the page size is 16,384 bytes, or 16 KB.\n\n\"crashReporterKey\" : \"b9aa251a63bd9e743afbb906f43eb7ea5f206292\",\n\"product\" : \"iPad8,2\",\n\"incident\" : \"32B05E3C-CB45-40F8-BA66-5668779740E1\",\n\"date\" : \"2019-10-10 23:30:39.48 -0700\",\n\"build\" : \"iPhone OS 13.1.2 (17A860)\",\n\"memoryStatus\" : {\n   \"pageSize\" : 16384,\n},\n\"largestProcess\" : \"OneCoolApp\",\n\n\n\n\nNote\n\nThis example shows the header fields needed to diagnose a crash from a jetsam event report. The complete header information contains more fields than shown in this example.\n\nWhile inspecting the header, examine the largestProcess field—this field names the process using the highest number of memory pages on the system. If other apps in addition to yours are regularly jettisoned, and your app is the largest process, you should reduce your memory use to better cooperate with other apps’ memory needs.\n\nIdentify the jetsam reason\n\nA jetsam event report contains a processes array, with each item in the array describing a single process in the system. Search for the reason key to identify the jettisoned process and why the system jettisoned it. Only the jettisoned process has the reason key.\n\nImportant\n\nIf your app crashed, but the jettisoned process isn’t your app, then the crash isn’t due to memory pressure. To diagnose your app’s issue, see Acquiring crash reports and diagnostic logs to locate its crash report.\n\nThis example is one process entry in the processes array:\n\n{\n    \"uuid\" : \"a02fb850-9725-4051-817a-8a5dc0950872\",\n    \"states\" : [\n      \"frontmost\"\n    ],\n    \"lifetimeMax\" : 92802,\n    \"purgeable\" : 0,\n    \"coalition\" : 68,\n    \"rpages\" : 92802,\n    \"reason\" : \"per-process-limit\",\n    \"name\" : \"MyCoolApp\"\n}\n\n\nNote\n\nThis example shows the process fields needed for diagnosing a crash from a jetsam event report. The complete process information in a report contains more fields than shown in this example.\n\nIf the jettisoned process is your app, the value of the reason key explains the conditions that led to the jetsam event:\n\nper-process-limit: The process crossed the resident memory limit imposed by the system on all apps. Crossing this limit makes the process eligible for termination. If the process is an app extension from your app, note that extensions have a much lower per-process memory limit than foreground apps. Carefully consider your needs before using technologies with a high-baseline memory cost, such as SpriteKit or a MKMapView, in an extension point. Alternate solutions may be more appropriate. For example, an image created by MKMapSnapshotter has lower memory use than a MKMapView, and is a better choice for many extension-point scenarios.\n\nvm-pageshortage: The system experienced memory pressure and needed to free background process memory for the current foreground app.\n\nvnode-limit: Too many files were open across the system. The kernel has a finite number of vnodes, a memory structure backing open files, and these were almost exhausted. To avoid terminating the frontmost app when vnodes are nearly exhausted, the system may terminate your app in the background to free vnodes, even if your app isn’t the source of excess vnode use.\n\nhighwater: A system daemon exceeded its highest-expected memory footprint.\n\nfc-thrashing: A process thrashed the system file cache. This occurs when non-sequential parts of memory-mapped files are read and written too frequently. To avoid terminating the frontmost app, the system may terminate your app in the background to free space in the file cache, even if your app isn’t thrashing the file cache.\n\njettisoned: The system jettisoned the process for some other reason.\n\nTo determine the amount of memory your app is using, multiply the number of memory pages reported in the rpages field by the page size value from the pageSize field in the jetsam event report’s header. The result is the amount of memory your app is using in bytes. For example, a process with a rpages value of 92,802 multiplied by a pageSize value of 16,384 bytes is using 1,520,467,968 bytes (1.52 GB) of memory.\n\nEach item in the processes array also has the following keys, which provide additional information for diagnosing the issue.\n\nuuid: The build UUID of the binary. This helps you identify the version of your app by comparing this value to the available dSYM files for builds distributed to customers. To learn more about the build UUID, see Building your app to include debugging information.\n\nstates: Describes the app’s current memory use state, such as using memory as the frontmost app, or suspended and not actively using memory.\n\nlifetimeMax: The highest number of memory pages allocated during the lifetime of the process.\n\ncoalition: If your app’s process is part of a coalition that involves other system processes doing work on behalf of your app, use this information to identify related processes and their memory use, as your app can influence the memory use of other coalition processes.\n\nname: The process name. See if this name matches a binary from your app, or belongs to another app or system process.\n\nMake changes to your app’s memory use\n\nOnce you confirm that your app is crashing due to high-memory use, by analyzing the jetsam event report, see Gathering information about memory use to understand your app’s memory use patterns, and Making changes to reduce memory use for techniques to lower your memory use.\n\nIn addition to lowering your app’s memory use, ensure you are receiving the low-memory warnings sent by the system and acting on these warnings to cooperate with the needs of the operating system and lower your appʼs memory use—see Responding to low-memory warnings for the specific ways the system notifies your app.\n\nSee Also\nRelated Documentation\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency."
  },
  {
    "title": "Doing advanced optimization to further reduce your app’s size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/doing-advanced-optimization-to-further-reduce-your-app-s-size",
    "html": "Overview\n\nFollowing the basic optimizations described in Doing basic optimization to reduce your app’s size is a good way to decrease the size of your app. However, you can optimize your app’s size further to minimize its footprint on a device and provide a fast download, installation, and update experience.\n\nOptimize your app’s asset files\n\nAssets often make up a large portion of an app. Consider the following optimizations:\n\nUse the most efficient image and video format possible. Image and video assets are common contributors to large app sizes. Using a more efficient image file format is a good way to reduce your app’s size. For example, consider using the HEIF format for images, and the HEVC format for videos. If you’re using PNG files, consider using 8-bit instead of 32-bit PNGs. Doing so can decrease the image size to a quarter of the original size.\n\nCompress images. For 32-bit images, using Adobe Photoshop’s “Save for Web” feature can reduce the size of JPEG and PNG images considerably.\n\nCompress audio files. As a general rule, compress audio using AAC or MP3 codecs, and experiment with a reduced bit rate. Quite often, a 44.1 kHz sample rate isn’t necessary, and a lower bit rate clip won’t result in a perceptible drop in quality. Learn more about optimizing your audio assets by watching Audio Development for Games.\n\nReduce the size of app updates\n\nInstead of always downloading the whole app when an update to the app is available, the App Store creates an update package. It compares one or more prior versions of your app to the new version and creates an optimized package. This package contains only the content that has changed between versions of your app, excluding any content that didn’t change.\n\nThis comparison looks at everything in the application bundle, including the application executable, storyboards, nibs, localizations, and other assets, like images.\n\nConsider the following to reduce the size of your app’s update package:\n\nDon’t make unnecessary modifications to files. Compare the contents of the prior and new versions of your app with diff or another directory comparison tool, and verify that it doesn’t contain any unexpected changes.\n\nStore content that you expect to change in an update in separate files from content that you don’t expect to change.\n\nNote\n\nDon’t rely on the creation and modification dates of files in your application bundle. The operating system updates your app using the update package, and updates files only if their content changes. It doesn’t update files because of changes to metadata; for example, the creation and modification dates.\n\nAdopt on-demand resources\n\nAnalyze all of your app’s assets and determine which resources it uses infrequently. Group the infrequently used resources into asset packs. When you upload your app to App Store Connect, asset packs don’t become part of your app’s initial download or app updates. Instead, the app can download them separately as needed. See the On-Demand Resources Guide for more information.\n\nIf you can’t adopt on-demand resources, consider implementing a web service that provides them, and download them in the background as needed, using URLSession. To learn more, see Downloading files in the background.\n\nLeverage app thinning\n\nApp thinning is a technology that ensures that an app’s IPA file only contains resources and code that’s necessary to run the app on a particular device. Apps that are available in the App Store, and that you distribute to testers using TestFlight, already leverage app thinning. However, if you distribute an in-house enterprise app, or distribute your builds to testers without using TestFlight, you must enable app thinning when you export your app. To use app thinning:\n\nArchive your app in Xcode.\n\nSelect the archived app in the organizer window, and click Distribute App.\n\nExport your app using Xcode, and choose “All compatible device variants” for app thinning in the export sheet. If you support only a limited number of devices in your app, select the ones that apply.\n\nTo learn more about app thinning, see Distribution Options and watch App Thinning in Xcode.\n\nSee Also\nSize optimization\nDoing basic optimization to reduce your app’s size\nAdjust your project’s build settings, and use technologies like asset catalogs early in your app’s development life cycle."
  },
  {
    "title": "Analyzing responsiveness issues in your shipping app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-responsiveness-issues-in-your-shipping-app",
    "html": "Overview\n\nHitches and hangs are two types of responsiveness issues that negatively impact an app’s user experience. The system monitors for hangs and hitches for running apps, and periodically collects reports on the issues from a statistical sample. Xcode Organizer uses this data to display information about the hitch rate, the hang rate, and individual hang reports for your apps. All of this data is also available in MetricKit, so you can gather and aggregate it in your own infrastructure. For more information about hangs and hitches, see Understanding user interface responsiveness.\n\nView your app’s hitch rate\n\nThe Scrolling pane of the Xcode Organizer window displays information about the hitch rate of your app over time.\n\nBased on the scroll hitch rate for a version of your app, the bar appears in red, yellow, or green. Red bars indicate a poor scroll with a hitch rate of more than 10 milliseconds per second (ms/s), yellow bars indicate a fair scroll with a hitch rate of 5–10 ms/s, and green bars indicate a good scroll with a hitch rate of less than 5 ms/s. Aim for green bars to provide the best scroll experience for your users.\n\nHitch-rate data is only available for iOS and iPadOS devices.\n\nView your app’s hang rate\n\nXcode Organizer reports the hang rate as the number of seconds per hour that the app is unresponsive, while only counting periods of unresponsiveness of more than 250 ms. The Organizer window shows both the median hang rate of a typical user experience, and the extreme 90th percentile hang rate. MetricKit provides the same hang rate metric as a histogram.\n\nApple operating systems support a broad variety of devices with different hardware capabilities and performance characteristics. Code that performs flawlessly on one hardware model can hang on another. Use the device filter at the top of the Organizer window to filter the hang rate for specific device types and uncover hangs that only manifest in certain circumstances.\n\nHang rate data is available for iOS and macOS devices.\n\nAnalyze hang reports to determine a course of action\n\nThe hang rate provides general information about how responsive a specific app version is on average, while hang reports highlight individual causes of hangs. When the main thread is unresponsive for 1 s or longer, the system also samples the app to capture a backtrace profile, highlighting where the app is spending its time during the hang. The system sends anonymous diagnostic reports with hang stack traces to Apple for users who consent to share data with app developers. Xcode Organizer aggregates these individual hang reports and groups them by similar backtraces to identify common causes of hangs. Alternatively, you can create your own reports from logs that MetricKit collects.\n\nEach report in the Report List shows the function call that generates the hang, and the percentage of total hang time it accounts for in the release. The Report List sorts function calls in descending order of hang-time contribution to the app release. Clicking a report shows a sample main thread stack trace, as well as additional details in the Inspector, including:\n\niOS version\n\nDevice model\n\nNumber of logs received\n\n14-day reporting trend\n\nTotal hang time\n\nDetails such as iOS version, device model, number of logs received, and 14-day reporting trend refer to the report, whereas details such as total hang time refer to the function calls.\n\nIdentify the code that’s causing the hang by using the function calls for a specific report in the Report List and the corresponding stack trace.\n\nHang reports are only available for iOS and iPadOS devices.\n\nReproduce problems to analyze and fix them\n\nThe metrics in Xcode Organizer allow you to detect when your shipping app has a problem, such as the hitch rate increasing with the most recent release, but not necessarily what the cause of the problem is. To determine the source of the problem, consider the following steps:\n\nFilter the relevant metric by various dimensions, such as device type or app version, to identify whether the issue occurs only on a specific combination of device and version of your app.\n\nIdentify the first app version that has the issue you’re looking for. Then use a version control system to identify the changes between app versions, and focus your testing on those areas.\n\nAfter you narrow down the areas of the app where the issue may be occurring, focus your testing on trying to reproduce the issue. You can use the on-device hang detection in iOS and iPadOS to receive notifications about a hang that occurs while you use the device. Or you can attach your device to Instruments and profile your app using the Time Profiler template to see any hangs in the trace while also recording additional data about what happens in your app during the hang. Then, follow the steps in Improving app responsiveness to analyze and fix the issues.\n\nSee Also\nRelated Documentation\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode."
  },
  {
    "title": "Analyzing resource dependencies | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-resource-dependencies",
    "html": "Overview\n\nThe Dependencies viewer provides a graphical representation of the structure of your GPU trace and allows you to see the relationships between resources and the encoders that access them. It also highlights the manual synchronizations you use between encoders, and indicates any unnecessary work by showing you all the unused resources in your frame.\n\nInspect the graph at different levels of detail\n\nAt the highest level, the Dependencies viewer shows the overall structure of your frame. At this level, you can see the graph of command encoders inside command buffers. You can also see all of the passes in your frame. Each pass includes a thumbnail preview of its work, as well as the number of resources that it consumed or produced. At this level, you can see whether data is flowing and whether there’s synchronization between passes.\n\nAs you zoom in to the next level, the Dependencies viewer expands the resources for each pass. Additionally, each resource can have icons above and below it that indicate the consuming and producing actions. For attachments in a render pass, the icons refer to the load and store actions. Otherwise, they refer to general resource read-and-write operations. At this level, you can also view which resources are introducing data flow or synchronization between passes.\n\nAs you zoom in more, the Dependencies viewer shows larger thumbnails and metadata for the resources.\n\nView a resource’s consuming and producing actions\n\nThe consuming and producing actions above and below a resource help you understand the resource accesses in a given pass at a quick glance.\n\nFor textures in a render pass, the actions refer to the load and store actions for each attachment.\n\nFor a multisample render pass, the store action may affect the storing for both the multisample and the resolve textures. With MTLStoreAction.storeAndMultisampleResolve, the multisample texture shows a store action and the resolve texture shows a store action. With MTLStoreAction.multisampleResolve, the multisample texture shows a don’t-care action and the resolve texture shows a store action.\n\nOtherwise, the Dependencies viewer annotates the actions with generic read-and-write operations.\n\nAnalyze the data flow and synchronization dependencies\n\nThe Dependencies viewer displays two categories of dependencies between passes:\n\nSolid lines depict data flow. A previous pass produced data and a later pass consumes it.\n\nDashed lines depict synchronization. There’s no data flow, but there’s a relationship between the two passes.\n\nFor example, a compute pass reading from a texture that a previous render encoder wrote has data flow between the two passes.\n\nAdditionally, a render pass that clears an attachment on load has no data dependency on any pass that previously modified the texture. However, that render pass needs to wait until the previous passes finish modifying the texture — a synchronization.\n\nChoose a mode for viewing dependencies\n\nYou can use the Dependencies viewer to choose different modes for visualization, each with a different subset of edges:\n\nAll: Shows all edges from synchronization primitives, and tracked and untracked resources.\n\nSynchronzation: Shows dashed synchronization edges from synchronization primitives and tracked resources.\n\nData Flow: Shows solid data-flow edges from tracked or untracked resources.\n\nPin resources from the resource pile\n\nTo maintain a compact graph, the Dependencies viewer attempts to keep a few interesting resources visible on the graph and hide the rest in a pile under each pass. Clicking the pile opens a popover of the resources.\n\nYou can click the button to the right of each resource to pin or unpin it.\n\nGet more information about a pass\n\nClicking any pass in the Dependencies viewer selects it and displays additional information about the pass in the sidebar. You can also determine which resources the pass consumes or produces:\n\nFor a resource the pass consumes, the Dependencies viewer suggests the pass that most recently modified the resource.\n\nFor a resource the pass produces, the Dependencies viewer suggests the passes that later consume the data in the resource.\n\nGet more information about a resource\n\nClicking any resource in the Dependencies viewer selects it and displays additional information about the resource in the sidebar. You can also see the passes that last produced, or will later consume, the data in the resource.\n\nWhen you select a resource, the Dependencies viewer highlights any related resources. For example, when you select a texture view, it highlights the parent textures. When you select a heap, it highlights the resources from the heap.\n\nImprove your Metal workload with Insights\n\nClick the Insights button in the bottom right corner to open a popover of recommendations in the Dependencies viewer.\n\nLimit your scope with filters\n\nUse the filter field at the bottom of the Dependencies viewer to adjust the graph’s filtering criteria. Type filter terms into the field and the Dependencies viewer displays any related passes that match the filter terms. In addition, when filtering by a resource, you can find passes that consume or produce the resource.\n\nSearch for specific elements\n\nChoose Find > Find to display the search bar above the Dependencies viewer. You can type search terms into the search bar’s text field to find matching passes and resources.\n\nFor any search term, you can click it and choose to include or exclude elements that match the term.\n\nThe two arrow buttons to the right of the text field let you move to the previous or the next matching element in the Dependencies viewer.\n\nSee Also\nMetal workload analysis\nAnalyzing your Metal workload\nInvestigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.\nAnalyzing memory usage\nManage your Metal app’s memory usage by inspecting its resources.\nAnalyzing Apple GPU performance using a visual timeline\nLocate performance issues using the Performance timeline.\nAnalyzing Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands.\nAnalyzing non-Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands."
  },
  {
    "title": "Analyzing memory usage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-memory-usage",
    "html": "Overview\n\nThe Memory viewer provides comprehensive information about your app’s memory usage in Metal. The Memory viewer’s top section presents a breakdown of memory by categories, and the bottom section displays a table of resources. In the table, you can inspect resources for their memory size, configuration, and other characteristics.\n\nMetal apps create many resources, and those resources consume a lot of memory. For example, to render an animated character using a physically based renderer, you might need buffers to hold vertex and animation data, and multiple textures to provide material attributes. When you scale these requirements to multiple characters and larger scenes, your app’s memory footprint grows significantly.\n\nAdditionally, when you create Metal resources, specifying their configuration precisely has a substantial effect on performance. The Metal debugger analyzes the configuration you provide and uses it to create the underlying GPU representation of a resource. For example, if you create a resource with a private storage mode, Metal can optimize the resource for GPU access, and doesn’t need to store data in a location or format directly accessible from the CPU.\n\nExamine the bar graphs\n\nThe categories in the top section of the Memory viewer organize memory usage data and provide memory totals based on the following criteria:\n\nVolatility\n\nThis category lists volatile and nonvolatile resources. Nonvolatile memory total is a good indicator of your app’s tracked memory usage for Metal. When you mark a resource as volatile, you give Metal permission to dispose of its contents when memory is scarce. The operating system doesn’t count volatile memory in your app’s total memory footprint. For example, in iOS, a lower footprint reduces the risk that you exceed the jetsam limit and have the operating system terminate your app. If you think that you might use a resource in the future that you’re not currently using, mark it as volatile rather than simply releasing it. That way, you only need to recreate the resource’s contents if Metal discards them. For more information, see setPurgeableState(_:).\n\nType\n\nThis category lists resources by type — textures, buffers, and so on. Check this category to determine whether your app is using any particular kind of resource more than others.\n\nStorage mode\n\nThis category lists resources by the modes that you define in MTLStorageMode. Check this category to determine whether an excessive number of resources are marked as MTLStorageMode.shared or MTLStorageMode.managed.\n\nUse\n\nThis category tracks whether commands accessed resources in the captured frame. Examine this category for a large total of unused resources, which might indicate that you need to release some resources or mark them as volatile.\n\nEach bar graph consists of segments representing the largest resources that it tracks. The final segment of each bar graph shows an aggregate total for its smaller resources. Move your pointer over a segment to view a popover with the name of the resource, its size, and other information. Click a segment to get more information about that specific resource.\n\nInspect the resources table\n\nTo improve how your app creates and manages resources, you need data about how it uses them. The Memory viewer provides information about the resources that are live in your Metal app during a capture.\n\nThe resources table provides the following information for all resource types:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nLabel\n\n\t\n\nlabel\n\n\t\n\nThe label you add when creating the resource. Use this information to identify specific resources in your app. To learn how to name your resources, see Naming resources and commands.\n\n\n\n\nInsights\n\n\t\n\n\t\n\nPossible problems or optimizations that might improve memory or resource usage.\n\n\n\n\nType\n\n\t\n\n\t\n\nThe type of resource. For a texture, this information includes the texture’s subtype. For a heap, it includes the heap’s subtype.\n\n\n\n\nAllocated Size\n\n\t\n\nallocatedSize\n\n\t\n\nThe allocated memory size for the resource.\n\n\n\n\nStorage Mode\n\n\t\n\nresourceOptions or storageMode\n\n\t\n\nThe storage mode you choose when creating the resource.\n\n\n\n\nPurgeable State\n\n\t\n\n\t\n\nThe volatility of the resource. When you mark a resource as volatile, the system can purge it when free memory is low. The operating system doesn’t include volatile resources in the system memory total for your app.\n\n\n\n\nAliasable\n\n\t\n\nisAliasable()\n\n\t\n\nAn indication of whether the resource shares its associated memory with another resource on the same heap.\n\n\n\n\nCPU Access\n\n\t\n\n\t\n\nAn indication of whether your app has accessed the resource from the CPU.\n\n\n\n\nTime Since Last Bound\n\n\t\n\n\t\n\nThe amount of time since last binding the resource to a Metal command encoder. If you’ve never bound the resource or haven’t bound it for a long time, you can probably release this resource or mark it as volatile.\n\nFor textures, you can add the following columns:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nPixel Format\n\n\t\n\npixelFormat\n\n\t\n\nThe Metal pixel format you choose when creating the texture.\n\n\n\n\nWidth\n\n\t\n\nwidth\n\n\t\n\nThe width, in pixels, of the texture’s base mipmap.\n\n\n\n\nHeight\n\n\t\n\nheight\n\n\t\n\nThe height, in pixels, of the texture’s base mipmap.\n\n\n\n\nDepth\n\n\t\n\ndepth\n\n\t\n\nThe depth, in pixels, of the texture’s base mipmap.\n\n\n\n\nArray Length\n\n\t\n\narrayLength\n\n\t\n\nThe number of slices in the texture array.\n\n\n\n\nMipmaps\n\n\t\n\nmipmapLevelCount\n\n\t\n\nThe number of mipmap levels in the texture.\n\n\n\n\nSamples\n\n\t\n\nsampleCount\n\n\t\n\nThe number of samples in each pixel.\n\n\n\n\nUsage\n\n\t\n\nusage\n\n\t\n\nIndicates the actions a shader or app can perform on the texture. The more restricted the list, the more optimizations Metal can apply to the texture.\n\n\n\n\nLossless Compression\n\n\t\n\n\t\n\nIndicates whether the texture supports lossless compression.\n\nFor buffers, you can add the following column:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nLength\n\n\t\n\nlength\n\n\t\n\nThe logical length, in bytes, of the buffer. Compare this value to the allocated size. To make memory available to the GPU, Metal sometimes needs to allocate more memory than you request. If you see many small buffers, consolidate those that the system uses together into a single buffer, or allocate the buffers on a heap. These alternative allocation strategies save memory and require less work to track dependencies between commands accessing those resources.\n\nFor heaps, you can add the following columns:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nSize\n\n\t\n\nsize\n\n\t\n\nThe logical size, in bytes, of the heap.\n\n\n\n\nUsed Size\n\n\t\n\nusedSize\n\n\t\n\nThe number of bytes the heap allocates for other resources.\n\n\n\n\nHazard Tracking Mode\n\n\t\n\nresourceOptions or hazardTrackingMode\n\n\t\n\nThe hazard tracking mode of the allocated resources on the heap.\n\nFor indirect command buffers, you can add the following column:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nSize\n\n\t\n\nsize\n\n\t\n\nThe number of bytes the system uses to hold encoded commands. This total doesn’t include memory for any commands that the system resets. Compare this size to the allocated size of the indirect command buffers. Choose the size of an indirect command buffer based on the number of commands you expect to execute inside it.\n\nFor acceleration structures, you can add the following column:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nSize\n\n\t\n\nsize\n\n\t\n\nThe logical length, in bytes, of the acceleration structure.\n\nImprove your Metal workload with Insights\n\nClick the Insights button in the bottom right corner to open a popover of recommendations for the resources.\n\nLimit your scope with filters\n\nUse the filter field at the bottom of the Memory viewer to adjust filtering criteria. Type filter terms into the field, and the resources table displays any resources with labels that match those filter terms.\n\nYou can also click the filter button to add filters for specific kinds of resources, to limit the table to resources that the captured frame uses, and to limit the table to just volatile resources.\n\nWhen there are two or more filter terms, you can click the filter button to choose whether to match any or all of the terms. For any filter term, you can click it to choose to include or exclude resources that match that term.\n\nGroup and sort resources to detect patterns\n\nBy default, the resources table shows all resources in a single list. You can click a column header to sort the table by that column in ascending or descending order. You can also group the resources by certain criteria.\n\nControl-click an entry in the table to group the resources by any of the following criteria:\n\nNone\n\nRestores the behavior to the default, which shows all resources in the table without grouping them.\n\nType\n\nGroups the resources into buffers, textures, heaps, or indirect command buffers.\n\nAllocated Size\n\nGroups the resources by their actual size. The groupings are based on a logarithmic scale. Use this criteria to find the largest resources in your app.\n\nStorage Mode\n\nGroups the resources by the storage mode you select when creating each resource.\n\nCommand Buffer\n\nGroups the resources based on which command buffers reference them. Use this criteria to determine which commands are referencing which resources.\n\nCommand Encoder\n\nGroups the resources according to commands that use a specific command encoder. Use this criteria to understand the behavior of your specific compute and render passes.\n\nFrom this same context menu, you can also choose to sort by a specific criteria, which is equivalent to clicking a column heading for sorting.\n\nGet more information about a specific resource\n\nYou can also get more information about a specific resource by Control-clicking it and selecting Get Info.\n\nFor example, for a texture, the additional information shows details specific to that texture, such as its pixel format and dimensions. To see the contents of the texture, double-click it.\n\nExport a memory report\n\nTo share the data in the Memory viewer, you can export it in the following ways:\n\nExport a GPU trace: Choose File > Export and select a location to save the GPU trace file. You can then open the trace file later.\n\nExport a comma-separated values (CSV) file: Choose Editor > Export Memory Report to generate the CSV file. The resulting file has all of the columns you see in the resource view. You can open this file in Numbers or another spreadsheet app.\n\nSee Also\nMetal workload analysis\nAnalyzing your Metal workload\nInvestigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.\nAnalyzing resource dependencies\nAvoid unnecessary work in your Metal app by understanding the relationships between resources.\nAnalyzing Apple GPU performance using a visual timeline\nLocate performance issues using the Performance timeline.\nAnalyzing Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands.\nAnalyzing non-Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands."
  },
  {
    "title": "Replaying a GPU trace file | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/replaying-a-gpu-trace-file",
    "html": "Overview\n\nReplaying a GPU trace file allows you to debug and profile previously captured GPU commands using the Metal debugger. For more information, see Capturing a Metal workload in Xcode or Capturing a Metal workload programmatically.\n\nTo replay a GPU trace file, open it in Xcode. Before clicking Replay, you can configure which device to use (if there’s more than one available), as well as configure whether to run with profiling.\n\nConfigure replay\n\nIf you have multiple devices, you need to select a device before you can replay the GPU trace file. Xcode automatically selects the most compatible device, but you can select a different device using the Device popover.\n\nWarning\n\nGPU trace files are only compatible with devices of the same type, the same GPU, and the same operating system. Otherwise, performance may vary. For example, if you capture a Metal workload on a Mac with an AMD GPU, replaying the exported GPU trace file on a Mac with the Apple M1 chip may not work or behave the same.\n\nYou can optionally enable the Profile GPU Trace option to have Xcode automatically profile after replaying. Profiling has an initial performance impact on the Metal debugger, so only enable this option when debugging your app’s performance. You can always profile later as needed.\n\nSee Also\nEssentials\nCapturing a Metal workload in Xcode\nAnalyze your app’s performance by configuring your project to leverage the Metal debugger.\nCapturing a Metal workload programmatically\nAnalyze your app’s performance by invoking Metal’s frame capture.\nInvestigating visual artifacts\nDiscover, diagnose, and fix visual artifacts in your app with the Metal debugger.\nOptimizing GPU performance\nFind and address performance bottlenecks using the Metal debugger."
  },
  {
    "title": "Analyzing Apple GPU performance using a visual timeline | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-apple-gpu-performance-using-a-visual-timeline",
    "html": "Overview\n\nImportant\n\nThe Performance timeline feature is only applicable to Apple GPUs. For other GPU architectures, see Analyzing non-Apple GPU performance using counter statistics.\n\nApple GPUs run vertex, fragment, and compute tasks in parallel whenever possible. To explore the parallel nature of Apple GPUs, the Performance timeline helps you visualize the various passes and stages running simultaneously.\n\nFor information on using the Performance timeline to optimize your Metal workload and profiling your workload in different GPU execution modes, see Optimizing GPU performance.\n\nView your shaders in the timeline\n\nThe top section has the Vertex, Fragment, and Compute GPU tracks, which display the beginning time and duration of individual passes running with overlap. Below the GPU tracks are the aggregated shader tracks that combine the individual shaders. You can view the timeline of individual shaders in a waterfall-like fashion by expanding the aggregated shader tracks.\n\nThe bottom section has a separate Counters timeline, which includes GPU counters such as Occupancy, Limiter, and Bandwidth. The counters can help you diagnose performance bottlenecks. You can focus on counter subsets by switching between different counter tabs.\n\nOccupancy\n\nA GPU has a maximum number of threads that it can execute at the same time. Occupancy is a measurement of how much of this capacity the GPU is using. For more information, see Finding your Metal app’s GPU occupancy.\n\nLimiter and utilization\n\nGPUs process many different kinds of actions in parallel, including arithmetic, memory access, and rasterization. Limiter counters include time the GPU spends executing work and any stalls in a subsystem that prevent the GPU from starting new work. Utilization counters include time the GPU spends executing work in a subsystem without stalls. For more information, see Reducing shader bottlenecks.\n\nBandwidth\n\nThe GPU Read Bandwidth and GPU Write Bandwidth counters measure how much and how often the GPU is accessing system memory. For more information, see Measuring the GPU’s use of memory bandwidth.\n\nDisplay additional information\n\nClicking any track in the Performance timeline selects it and displays additional information about the track in the sidebar.\n\nGPU track\n\nSelecting a GPU track, such as Vertex, Fragment, or Compute, shows a table summarizing the elements in the track. The Performance timeline filters the elements using the current time range selection. You can click the table’s Duration column to sort the elements by duration.\n\nAggregated shader track\n\nSelecting an aggregated shader track lists all shaders with their durations. The Performance timeline filters the shaders using the current time range selection.\n\nCounter track\n\nSelecting any counter track lists all counters with their mean values in the sidebar. The Performance timeline aggregates the mean values using the current time range selection.\n\nSimilarly, clicking any element in the Performance timeline selects it and displays additional information about the element in the sidebar.\n\nEncoder\n\nSelecting an encoder shows its statistics. For a render pass, there are previews of the render attachments as well.\n\nLoad and store action\n\nSelecting a load or store action shows metadata from the relevant render pass.\n\nShader\n\nSelecting a shader shows its statistics, such as compiler statistics and runtime shader instruction costs. In addition, the compiler statistics section includes the Max Theoretical Occupancy of the shader. For more information on occupancy, see Finding your Metal app’s GPU occupancy.\n\nLimit your scope with filters\n\nAdjust the track-filtering criteria with the filter field at the bottom of the GPU timeline or Counters timeline. You can type filter terms into the field, and the GPU timeline or Counters timeline shows tracks with names that match those terms. For example, you can simplify the Counters timeline to only show limiter counters by adding “limiter” to the filter field.\n\nFor any filter term, you can click it and choose to include or exclude tracks that match that term.\n\nSearch for specific elements\n\nChoose Find > Find to display the search bar above the Performance timeline. You can type search terms into the search bar’s text field to find matching command encoders and shaders.\n\nFor any search term, you can click it and choose to include or exclude elements that match the term.\n\nThe two arrow buttons to the right of the text field let you move to the previous or the next matching element in the timeline.\n\nFocus on the time for an element\n\nFocusing on the time for an element collapses the nonrelevant time ranges in the Performance timeline:\n\nTo focus on an encoder, Control-click the element in the timeline and select Focus on Encoder.\n\nTo focus on a shader, Control-click the element in the timeline and select Focus on Shader.\n\nTo exit the focus mode, click the Expand Timeline button at the bottom of the Performance timeline.\n\nMinimize performance bottlenecks\n\nLook for abnormally long passes. Check whether the GPU time for various tasks matches your expectation or exceeds the budget time.\n\nTry overlapping GPU tasks. Apple GPUs run vertex, fragment, and compute tasks in parallel whenever possible. For example, independent render passes and compute passes can run in parallel. If you observe nonoverlapping work, check whether your GPU work is overserialized. Also, use concurrent compute passes wherever possible so dispatches that touch different resources can execute concurrently.\n\nAvoid too many small passes. There’s setup time between passes, so having small passes adds latency.\n\nUse the counters as insights for improving passes in the critical path. The counter tracks available below the GPU tracks show a few key performance metrics. Aim for higher occupancy with efficient GPU work. Use limiters as clues to offload some work to underutilized subsystems on the GPU. In addition, you can Control-click any pass in the Performance timeline and choose Reveal in Counters to view more detailed counters data for a pass. For more information on counters, see Finding your Metal app’s GPU occupancy and Reducing shader bottlenecks.\n\nPrioritize optimizing passes in the critical path. When inspecting a pass, you can focus on the running shaders in the aggregated shader track below the GPU track. In addition, you can Control-click any shader in the Performance timeline and choose Open Shader. In the Shader editor, you can find per-line shader profiling statistics for identifying hot spots.\n\nSee Also\nMetal workload analysis\nAnalyzing your Metal workload\nInvestigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.\nAnalyzing resource dependencies\nAvoid unnecessary work in your Metal app by understanding the relationships between resources.\nAnalyzing memory usage\nManage your Metal app’s memory usage by inspecting its resources.\nAnalyzing Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands.\nAnalyzing non-Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands."
  },
  {
    "title": "Capturing a Metal workload in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/capturing-a-metal-workload-in-xcode",
    "html": "Overview\n\nYou can use Xcode to capture your app’s Metal workload. First, ensure that the GPU Frame Capture option is enabled in the runtime diagnostics options. Then, when your app is running, click the Metal Capture button in the debug bar, select a scope, and click Capture.\n\nConfigure the GPU Frame Capture options\n\nXcode automatically enables the GPU Frame Capture option if your target links to the Metal framework, or any other framework that uses the Metal API. If you’re collaborating on a project, it’s possible that someone else may have disabled GPU Frame Capture. To ensure it’s enabled, follow these steps:\n\nIn the Xcode toolbar, choose Edit Scheme from the Scheme menu.\n\nSelect the Run scheme action and then click Options.\n\nChoose a GPU Frame Capture option and click Close.\n\nThe GPU Frame Capture options include the following:\n\nAutomatically\n\nCaptures Metal or OpenGL ES API usage in your app. If your target doesn’t link to the Metal framework or the OpenGL ES framework, the Metal Capture button doesn’t appear in the debug bar. If your app uses both the Metal API and the OpenGL ES API, you can click and hold the Capture GPU Frame icon to choose which API usage to capture.\n\nMetal\n\nCaptures only Metal API usage in your app. If your app doesn’t use the Metal API, Xcode disables the Metal Capture button in the debug bar.\n\nDisabled\n\nDoesn’t capture Metal usage in your app. GPU Frame Capture has a tiny, but measurable, effect on your app’s CPU processing time, so choose this option when you want to test your app’s maximum performance level.\n\nCapture your Metal workload while debugging\n\nWhile debugging your app, you can capture a GPU trace by following these steps:\n\nClick the Metal Capture button in the debug bar.\n\nSelect the scope that you want to capture. This can be a frame, Metal layer, command queue, device, or any custom scopes that you set up previously. For more information, see Creating and using custom capture scopes.\n\nSelect the capture range. Depending on the scope, this might include the number of frames or command buffers.\n\nOptionally, select Profile after Replay so that Xcode automatically profiles after capturing. Profiling has an initial performance impact on the Metal debugger, so only enable this option when debugging your app’s performance. You can always profile later as needed. For more information, see Replaying a GPU trace file.\n\nClick Capture. Xcode automatically starts capturing a GPU trace when the scope triggers it, and finishes depending on the range you select. You can also click the Finish button at any time to manually stop the capture.\n\nCapture your Metal workload after deployment\n\nYou can use Xcode to capture a GPU trace after deploying your macOS or iOS app by following these steps:\n\nIn Xcode, choose Debug > Debug Executable.\n\nSelect your app in Finder and click Choose. Xcode automatically brings up the scheme editor.\n\nClick the Options tab, choose a GPU Frame Capture option, and click Close.\n\nRun your app by choosing Product > Run.\n\nClick the Metal Capture button in the debug bar.\n\nSelect the scope and range that you want to capture. You can optionally select Profile after Replay. For more information, see Replaying a GPU trace file.\n\nClick Capture. Xcode automatically starts capturing a GPU trace when the scope triggers it, and finishes depending on the range you select. You can also click the Finish button at any time to manually stop the capture.\n\nNote\n\nYou can only capture after deployment in macOS and iOS. This feature is enabled only for your own apps when using Xcode or TestFlight to deploy them.\n\nSave the capture to your computer\n\nTo save your captured Metal workload as a GPU trace, choose File > Export. For more information on replaying GPU trace files, see Replaying a GPU trace file.\n\nSee Also\nEssentials\nCapturing a Metal workload programmatically\nAnalyze your app’s performance by invoking Metal’s frame capture.\nReplaying a GPU trace file\nDebug and profile your app’s performance using a GPU trace file in the Metal debugger.\nInvestigating visual artifacts\nDiscover, diagnose, and fix visual artifacts in your app with the Metal debugger.\nOptimizing GPU performance\nFind and address performance bottlenecks using the Metal debugger."
  },
  {
    "title": "Analyzing Apple GPU performance using counter statistics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-apple-gpu-performance-using-counter-statistics",
    "html": "Overview\n\nImportant\n\nThe Performance counters feature is only applicable to Apple GPUs. For other GPU architectures, see Analyzing non-Apple GPU performance using counter statistics.\n\nThe Performance counters show performance statistics from your app’s passes or commands in the GPU trace. These counters measure hardware-related activities on the GPU, ranging from memory bandwidth to the number of vertices, the number of rasterized fragments, and the texture-filtering limiter and utilization percentages.\n\nThe Metal debugger collects data from the passes running without overlap, so only one pass runs at a time on the device when the profiler measures the performance. Additionally, it includes deterministic counters that don’t vary by time, such as the number of vertices in a render pass.\n\nView different counter sets for passes or commands\n\nAt the top of the graph, you can click the Encoders or the GPU Commands tab to choose to view the counters by pass or command granularity. Then, you can choose which counter set to use for viewing the collection of counters. In addition, clicking the Edit Counters button on the right allows you to create counter sets or to customize existing ones to suit your performance optimization workflow.\n\nView performance counters in the assistant editor\n\nThe assistant editor allows you to see additional information for individual passes and commands. You can enable the assistant editor by clicking the Adjust Editor Options button and choosing the Assistant option.\n\nSelecting a pass or command shows its performance counters in the assistant editor. If you see something other than performance counters, you can select Performance from the drop-down menu at the top left of the editor.\n\nThe performance counters in the assistant editor let you inspect all the counters for a specific pass or command. By analyzing values that may be hotspots, counters can suggest a specific cause of your app’s performance problem. For example, if the number of vertices is twice as high as you expect, it’s likely that your code has duplicate meshes or render encoder draw calls.\n\nFor more information, see Analyzing draw command and compute dispatch performance with GPU counters.\n\nView pipeline statistics for a command\n\nSelecting a command allows you to look at its pipeline statistics in the assistant editor. You can select Pipeline Statistics from the Assistant Editor drop-down menu to view information about the pipeline state and its performance statistics.\n\nThe pipeline statistics in the assistant editor let you look at compiler metrics and execution timing. The top portion of the assistant editor area lists the time each pipeline stage took to complete in separate categories. Below, it lists the commands that use the same pipeline stage, as well as their shader GPU time.\n\nFor more information, see Analyzing draw command and compute dispatch performance with pipeline statistics.\n\nOptimize your workload\n\nThere are a few interesting metrics you can investigate when beginning to optimize your workload:\n\nCounters in the Performance Limiters counter set\n\nUse limiters as clues to offload work to underutilized subsystems on the GPU to help eliminate stalls in a particular subsystem. For more information, see Reducing shader bottlenecks.\n\nVertices counter in the Vertices counter set\n\nCheck whether the number of vertices from a render pass or a draw command matches what you expect.\n\nSometimes, counters data may only hint at a problem, and you can benefit by leveraging additional Metal tools. For example, if your fragment shader time is unexpectedly high, you can use the Shader editor to discover which specific lines in your fragment shader are slowing down the execution. For more information, see Inspecting shaders.\n\nSee Also\nMetal workload analysis\nAnalyzing your Metal workload\nInvestigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.\nAnalyzing resource dependencies\nAvoid unnecessary work in your Metal app by understanding the relationships between resources.\nAnalyzing memory usage\nManage your Metal app’s memory usage by inspecting its resources.\nAnalyzing Apple GPU performance using a visual timeline\nLocate performance issues using the Performance timeline.\nAnalyzing non-Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands."
  },
  {
    "title": "Analyzing non-Apple GPU performance using counter statistics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-non-apple-gpu-performance-using-counter-statistics",
    "html": "Overview\n\nImportant\n\nThe Counters viewer feature isn’t applicable to Apple GPUs. For Apple GPUs, see Analyzing Apple GPU performance using a visual timeline and Analyzing Apple GPU performance using counter statistics.\n\nThe Counters viewer shows performance counters from your app’s passes or commands in the GPU trace. These counters measure hardware-related activities on the GPU, ranging from memory bandwidth to the number of vertices, the number of rasterized fragments, and the texture-filtering limiter and utilization percentages.\n\nThe Metal debugger collects data from the passes running without overlap, so only one pass runs at a time on the device when the profiler measures the performance. Additionally, it includes deterministic counters that don’t vary by time, such as the number of vertices in a render pass.\n\nView different counter sets for passes or commands\n\nAt the top of the graph, you can click the Encoder or the Draw tab to choose to view the counters by pass or command granularity. Then, you can choose which counter set to use for viewing the collection of counters.\n\nFind a pass with high shader GPU time\n\nThe height of the orange bar for each pass represents its shader GPU time. The tallest bar corresponds to the pass that took the longest time to complete. Minimize the duration of the long-running passes to optimize your app’s performance.\n\nThere are three render passes in the screenshot above, with the tallest bar for shader GPU time at the GBuffer Generation pass. You can move the pointer over the bar to view the time and other information. In the screenshot above, the shader GPU time for the GBuffer Generation pass reads 657.69 microseconds (μs).\n\nView performance counters in the assistant editor\n\nThe assistant editor allows you to see additional information for individual passes and commands. You can enable the assistant editor by clicking the Adjust Editor Options button and choosing the Assistant option.\n\nSelecting a pass or command shows its performance counters in the assistant editor. If you see something other than performance counters, you can select Performance from the drop-down menu at the top left of the editor.\n\nThe performance counters in the assistant editor let you inspect all the counters for a specific pass or command. By analyzing values that may be hotspots, counters can suggest a specific cause of your app’s performance problem. For example, if the number of vertices is twice as high as you expect, it’s likely that your code has duplicate meshes or render encoder draw calls.\n\nFor more information, see Analyzing draw command and compute dispatch performance with GPU counters.\n\nView pipeline statistics for a command\n\nSelecting a command allows you to look at its pipeline statistics in the assistant editor. You can select Pipeline Statistics from the Assistant Editor drop-down menu to view information about the pipeline state and its performance statistics.\n\nThe pipeline statistics in the assistant editor let you look at compiler statistics and runtime profiling statistics. The top portion of the assistant editor area lists the time each pipeline stage took to complete in separate categories. Below, it lists the commands that use the same pipeline stage, as well as their shader GPU time.\n\nFor more information, see Analyzing draw command and compute dispatch performance with pipeline statistics.\n\nSometimes, counters data may only hint at a problem, and you can benefit by leveraging additional Metal tools. For example, if your fragment shader time is unexpectedly high, you can use the Shader editor to discover which specific lines in your fragment shader are slowing down the execution. For more information, see Inspecting shaders.\n\nSee Also\nMetal workload analysis\nAnalyzing your Metal workload\nInvestigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.\nAnalyzing resource dependencies\nAvoid unnecessary work in your Metal app by understanding the relationships between resources.\nAnalyzing memory usage\nManage your Metal app’s memory usage by inspecting its resources.\nAnalyzing Apple GPU performance using a visual timeline\nLocate performance issues using the Performance timeline.\nAnalyzing Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands."
  },
  {
    "title": "Inspecting buffers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-buffers",
    "html": "Overview\n\nIn the Metal debugger, you can validate that the content in your buffer is correct by examining it with the Buffer viewer. The Buffer viewer automatically formats the buffer content based on the current context, for example, by using the currently bound pipeline state. You can also manually configure the formatting, which may be necessary in some cases, such as when there’s no currently bound pipeline state. After adjusting the formatting, you can copy or export any values that you might need for later.\n\nNavigate your buffer\n\nThe Buffer viewer displays the contents of your buffer in a large table. If you open your buffer in the Bound Resources viewer for a particular draw command or compute dispatch, Xcode automatically lays out the contents to match any parameter it’s bound to in your shader. For more information, see Inspecting the bound resources for a command.\n\nFor example, imagine a vertex shader that takes a float3 position and a float3 normal as input, and outputs a float4 position and a float3 normal. If you open the geometry in the Bound Resources viewer, Xcode shows a column for each parameter in the table.\n\nIn the screenshot above, the in – float3 position column shows three float values, whereas the out – float4 position column shows four float values.\n\nChange the layout and initial offset\n\nYou can change the way that the Buffer viewer lays out your buffer content using the controls at the bottom. To change the column parameter type, click the Element Type drop-down. To change the number of elements per row, click the Number of Elements per Row drop-down to its right.\n\nFor example, if ushort is the element type, with 4 elements per row, the Buffer viewer displays the content with four columns of type ushort.\n\nYou can also adjust the initial offset in the buffer by changing the Offset field at the bottom. For example, in the screenshot below, changing the offset to 0x10, Row 0 becomes [4 0 2 0] instead of [2 0 1 0].\n\nCreate a custom layout\n\nYou can create your own custom layout by clicking the Element Type drop-down and choosing Custom Layout > Show Custom Layout Editor.\n\nType the raw type (such as float3) in the Layout field for the first column and press Return.\n\nType a name for your first column and press Return.\n\nRepeat this for all of the columns in your custom layout.\n\nXcode automatically calculates the row stride, but you can also configure it manually.\n\nThe custom layout editor also supports resource types to help you visualize resources in argument buffers.\n\nWhen you finish editing the buffer content with your custom layout, click Done. You can access custom layouts from the Element Type drop-down menu, just below Custom Layout > Recent Custom Layouts.\n\nConfigure columns\n\nYou can configure the Buffer viewer to display only the information you need. Position your pointer over a column header and Control-click. The context menu provides the following options:\n\nVisible: Toggles the column visibility.\n\nPinned: Pins the column to the left side of the table, keeping it visible even when scrolling horizontally.\n\nHide Other Columns: Hides all columns except the selected column and any pinned columns.\n\nView Value As: Casts the value to a different format of the same size, such as casting a float to an unsigned integer.\n\nAdditionally, you can configure any column’s options from the context menu, using the filter field to filter through their names.\n\nIf you hide any columns, you can restore your configuration by selecting Show All Columns from the context menu.\n\nSearch for specific text and values\n\nYou can search for values by using the search functionality. Press Command-F to open the search bar. The search bar uses a token system to format your search, and different options appear for different input types.\n\nIf you specify a floating-point number with an Equal or Not Equal comparison type, you get an additional token to set up the epsilon value for the comparison (defaults to 0.001). If you specify a decimal or a hexadecimal number, only the exact number appears with a highlight in the results.\n\nAdditionally, if you specify the GPU base address of a resource, or the GPU base address value of an argument buffer (with or without the offset), it appears with a highlight in the results.\n\nYou can also search for text, such as resource names, errors, and invalid numerical values (nan, inf, -inf).\n\nExport your buffer content\n\nYou can copy the buffer contents either by selecting full rows or individual cells in the table, and then choosing Edit > Copy. The system uses the current layout format to copy the values, including visibility and any type cast override.\n\nYou can also export the contents of the entire buffer by choosing Editor > Export Buffer. Then you can save it either as raw data or as a CSV file.\n\nAlternatively, you can export the buffer by Control-clicking it in the Bound Resources viewer and choosing Export. For more information, see Inspecting the bound resources for a command.\n\nSee Also\nMetal resource inspection\nInspecting acceleration structures\nReveal ray intersection bottlenecks by examining your acceleration structures.\nInspecting pipeline states\nDetermine how your render and compute passes behave by examining their properties.\nInspecting sampler states\nVerify your sampler state configurations by examining their properties.\nInspecting shaders\nImprove your app’s shader performance by examining and editing your shaders.\nInspecting textures\nDiscover issues in your textures by examining their content."
  },
  {
    "title": "Inspecting acceleration structures | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-acceleration-structures",
    "html": "Overview\n\nAn acceleration structure is a data structure that Metal uses to accelerate ray intersection tests on the GPU. The Metal debugger allows you to inspect an acceleration structure with the Acceleration Structure viewer. After opening an acceleration structure, you can view it and its associated properties, along with various highlights.\n\nNavigate your acceleration structure\n\nYou can navigate your acceleration structure using the two panes of the Acceleration Structure viewer — the structure outline on the left or the scene view on the right.\n\nThe structure outline shows the components of your acceleration structure, along with their various properties. You can click any row in the structure outline to highlight the component of your acceleration structure in the scene view, or Control-click to jump to it.\n\nThe scene view shows a 3D representation of your acceleration structure. You can navigate around the scene or interact with your acceleration structure using the following controls:\n\nAction\n\n\t\n\nResult\n\n\n\n\nW (or ↑)\n\n\t\n\nZooms in at the viewport center\n\n\n\n\nA (or ←)\n\n\t\n\nPans left\n\n\n\n\nS (or ↓)\n\n\t\n\nZooms out at the viewport center\n\n\n\n\nD (or →)\n\n\t\n\nPans right\n\n\n\n\nUp Arrow/Down Arrow\n\n\t\n\nPans up/Pans down\n\n\n\n\nOption-Up Arrow/Down Arrow\n\n\t\n\nZooms in/Zooms out on the pointer\n\n\n\n\nDrag\n\n\t\n\nRotates the camera\n\n\n\n\nControl-click\n\n\t\n\nPerforms the selection, depending on the selection mode\n\n\n\n\nShift-Control-click\n\n\t\n\nSelects a primitive acceleration structure\n\n\n\n\nOption-Control-click\n\n\t\n\nSelects the geometry\n\n\n\n\nOption-Command-Control-click\n\n\t\n\nSelects a primitive\n\n\n\n\nCommand-Control-click\n\n\t\n\nSelects an instance\n\nChange the camera mode\n\nIf you’re using the Fly camera, dragging in the scene view rotates the camera. Alternatively, when using the Orbit camera, dragging orbits the camera around any primitive beneath the pointer, or around the scene center if there’s no primitive. You can click the Camera button in the control bar to switch between modes.\n\nConfigure intersection functions\n\nXcode automatically picks an intersection function table to use when rendering the scene, depending on how you open your acceleration structure. For example, if you open your acceleration structure from the Bound Resources viewer, Xcode selects any bound intersection function tables with matching intersector tags. For more information, see Inspecting the bound resources for a command. If you open your acceleration structure from the All Resources viewer or the Memory viewer, Xcode automatically selects the last intersection function table, with matching intersector tags, in your workload. For more information, see Analyzing memory usage.\n\nYou can switch to the intersection function table outline to configure which intersection function table the Acceleration Structure viewer uses. If you select None, the Acceleration Structure viewer doesn’t use any intersection functions and relies solely on the geometry intersection. If you select an intersection function table, the system uses the intersection function corresponding to the intersection function table offset of each geometry to evaluate whether to accept an intersection. For more information, see intersectionFunctionTableOffset and accept_intersection in the Metal Shading Language Specification.\n\nConfigure acceleration structure traversal behavior\n\nYou can override the default behavior of the acceleration structure traversal by clicking the arrow in the bottom right of the control bar. The popover options let you configure the same properties as the intersector to control traversal behavior (see Metal Shading Language Specification). Match the traversal behavior with your shader to ensure that the Acceleration Structure viewer is correct.\n\nView your acceleration structure with highlights\n\nYou can view your acceleration structure with different highlights to emphasize various properties. To enable and switch between modes, click the Highlight button in the control bar.\n\nBounding Volume Traversals\n\nYou can use the Bounding Volume Traversals mode to highlight areas of your scene that are more expensive to traverse. Xcode color-codes the number of traversals it takes to intersect your acceleration structure on a scale from white (fewer traversals) to dark blue (more traversals). As you move the pointer around the viewport, the inspector (at the bottom left) updates several traversal statistics for the pixel under the pointer, along with the corresponding minimum and maximum values in the viewport.\n\nAll Node Traversal\n\nYou can use the All Node Traversal mode to highlight the expensive parts of your scene that may be occluded. Xcode uses the same color-coding as the Bounding Volume Traversals highlight, but doesn’t stop traversing when it hits a surface. In the example below, you can see the eyes inside the ninja’s head:\n\nAcceleration Structures\n\nThis mode highlights different primitive acceleration structures. The inspector shows the primitive acceleration structure index as you move the pointer around the viewport.\n\nGeometries\n\nThis mode highlights different geometries within primitive acceleration structures. The inspector shows the geometry_id attribute as you move the pointer around the viewport. For more information, see Metal Shading Language Specification.\n\nPrimitives\n\nThis mode highlights different primitives within primitive acceleration structures. The inspector shows the geometry_id and primitive_id attributes as you move the pointer around the viewport. For more information, see Metal Shading Language Specification.\n\nInstances\n\nThis mode highlights different instances of primitive acceleration structures. The inspector shows the instance_id attribute as you move the pointer around the viewport. For more information, see Metal Shading Language Specification.\n\nIntersection Functions\n\nThis mode highlights different intersection functions. The inspector shows the intersection function index as you move the pointer around the viewport.\n\nView per-primitive data\n\nTo view per-primitive data, first navigate to a primitive in the structure outline. Then, click the arrow next to the data property to open a Buffer viewer containing the per-primitive data.\n\nFor information on configuring the Buffer viewer to better interpret the data, see Inspecting buffers.\n\nTip\n\nYou can use Option-Command-Control-click at any time in the scene view to quickly reveal the primitive in the structure outline.\n\nView motion data\n\nIf your acceleration structure includes motion data, Xcode automatically shows additional motion data properties per-instance or per-geometry in the structure outline.\n\nAdditional motion controls appear in the control bar. You can drag the motion timeline playhead to change the preview time. Alternatively, you can click the Play/Pause button and Xcode repeatedly bounces the current motion time between the minimum start time and the maximum end time.\n\nSee Also\nMetal resource inspection\nInspecting buffers\nConfirm your buffer formats by examining buffer content.\nInspecting pipeline states\nDetermine how your render and compute passes behave by examining their properties.\nInspecting sampler states\nVerify your sampler state configurations by examining their properties.\nInspecting shaders\nImprove your app’s shader performance by examining and editing your shaders.\nInspecting textures\nDiscover issues in your textures by examining their content."
  },
  {
    "title": "Inspecting pipeline states | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-pipeline-states",
    "html": "Overview\n\nThe Metal debugger allows you to inspect a pipeline state with the Pipeline State viewer. Double-click a pipeline state to open it and view its associated properties in a table.\n\nIn the screenshot above, the name of the pipeline state, G-buffer Creation, appears above the table. To the right of the name, you can click the Reveal in Memory button or the Reveal in Timeline button to open the Memory viewer or the Performance timeline, respectively, which both highlight the pipeline state.\n\nThe table displays the properties of your pipeline state in a logical hierarchy. Click the disclosure controls on the left to expand the groups to view more information. Using the table, you can quickly inspect the properties of MTLRenderPipelineState or MTLComputePipelineState.\n\nLimit your scope with filters\n\nUse the filter field at the bottom of the Pipeline State viewer to adjust the filtering criteria by typing filter terms into it. Then the table displays the related pipeline state properties that match the filter terms, and highlights the matches.\n\nWhen there are two or more filter terms, you can click the filter button to choose whether to match any or all of the terms.\n\nSee Also\nMetal resource inspection\nInspecting acceleration structures\nReveal ray intersection bottlenecks by examining your acceleration structures.\nInspecting buffers\nConfirm your buffer formats by examining buffer content.\nInspecting sampler states\nVerify your sampler state configurations by examining their properties.\nInspecting shaders\nImprove your app’s shader performance by examining and editing your shaders.\nInspecting textures\nDiscover issues in your textures by examining their content."
  },
  {
    "title": "Inspecting sampler states | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-sampler-states",
    "html": "Overview\n\nThe Metal debugger allows you to inspect a sampler state with the Sampler State viewer. After opening a sampler state, you can view its associated properties and preview the sampling behavior. For more information, see Inspecting the bound resources for a command or Analyzing memory usage.\n\nNavigate your sampler state\n\nThe Sampler State viewer shows the properties of your sampler state on the left (as configured by MTLSamplerDescriptor) and a preview on the right. The preview illustrates how pixels in a texture appear when using your sampler state.\n\nThe square region in the center of the preview corresponds to UV coordinates within the range of 0.0 to 1.0.\n\nYou can use the preview to quickly verify the configuration for your sampler state. For example, if you want a texture to mirror, but it’s drawing a constant value instead, you can check the sampler state. In the screenshot below, the sampler state is configured to clamp to a border color that’s opaque black, rather than using mirror repeat as the address mode:\n\nTry various combinations\n\nThe properties you configure when creating a sampler state determine how a texture looks when sampling it. The properties related to filtering control how pixels combine when the sample footprint is either larger or smaller than a pixel, or when it’s between mipmap levels. The address mode determines the texture coordinate at each pixel when a read falls outside the bounds of a texture. You can try using different combinations of filtering and addressing modes until you achieve your desired look.\n\nProperties\n\n\t\n\nPreview\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.clampToEdge\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.mirrorClampToEdge\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.repeat\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.mirrorRepeat\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.clampToZero\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.clampToBorderColor, MTLSamplerBorderColor.opaqueBlack\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.clampToBorderColor, MTLSamplerBorderColor.opaqueWhite\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.nearest, MTLSamplerAddressMode.clampToBorderColor, MTLSamplerBorderColor.transparentBlack\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.clampToEdge\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.clampToEdge\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.repeat\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.mirrorRepeat\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.clampToZero\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.clampToBorderColor, MTLSamplerBorderColor.opaqueBlack\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.clampToBorderColor, MTLSamplerBorderColor.opaqueWhite\n\n\t\n\n\n\n\nMTLSamplerMinMagFilter.linear, MTLSamplerAddressMode.clampToBorderColor, MTLSamplerBorderColor.transparentBlack\n\n\t\n\nSee Also\nMetal resource inspection\nInspecting acceleration structures\nReveal ray intersection bottlenecks by examining your acceleration structures.\nInspecting buffers\nConfirm your buffer formats by examining buffer content.\nInspecting pipeline states\nDetermine how your render and compute passes behave by examining their properties.\nInspecting shaders\nImprove your app’s shader performance by examining and editing your shaders.\nInspecting textures\nDiscover issues in your textures by examining their content."
  },
  {
    "title": "Inspecting shaders | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-shaders",
    "html": "Overview\n\nThe Metal debugger allows you to view and edit shaders with the Shader editor. After opening a shader, you can view and edit its source code, or the source code of any other file within the Metal library that the executed function requires. For more information, see Inspecting the bound resources for a command.\n\nWhen you profile the Metal workload, you can see per-line performance metrics. As you make changes, you can reload the shader to update the Metal workload and performance numbers.\n\nImportant\n\nInclude source code when you capture a Metal workload because the Shader editor needs it to function correctly. For more information, see Building your project with embedded shader sources.\n\nNavigate your shader\n\nThe Shader editor shows your source code in the context of an executed function, and includes familiar Xcode source-editing abilities, like Fixing issues in your code as you type.\n\nIn addition to the source containing the executed function, you can also edit other files within the Metal library that the executed function requires. Click the Toggle Left Sidebar button on the bottom left to reveal the source files outline. Then, select another file.\n\nView per-line performance metrics\n\nYou can view per-line performance metrics in the Shader editor after profiling finishes. This happens automatically if you select Profile after Replay in the Metal Capture popover (see Capturing a Metal workload in Xcode) or Profile GPU Trace in the Replay window (see Replaying a GPU trace file). Alternatively, you can profile directly within the Shader editor by clicking the Generate button in the top right corner.\n\nThen, wait for profiling to finish. You can see its status in the activity bar at the top of your Xcode window.\n\nAfter profiling your Metal workload, the Shader editor shows statistics on each line. For devices with a GPU in the Apple 4 family or later, there’s a pie chart to the right of the numeric statistics to help you improve the performance for a function or a line of code. For more information on Apple GPU family 4 devices, see Tailor Your Apps for Apple GPUs and Tile-Based Deferred Rendering and Metal feature set tables.\n\nYou can hover the pointer over the pie chart to enlarge it and show more detail about the work that the GPU performed while executing the line of code. The work a GPU performs can be categorized as memory, ALU, synchronization, or control flow.\n\nBy understanding the activities that the GPU executes for each line in your shader, you can infer any necessary code changes to improve the shader performance.\n\nGPU activity\n\n\t\n\nExplanation and recommendations\n\n\n\n\nALU\n\n\t\n\nThe amount of time that the GPU spends in the arithmetic logic unit. Change floats to half-floats where possible to reduce the time in the ALU. Also, try to minimize your use of complex instructions like sqrt, sin, cos, and recip.\n\n\n\n\nMemory\n\n\t\n\nThe amount of time that the GPU spends waiting for access to your app’s buffers or texture memory. Reduce time by downsampling textures, or, if you’re not spending much time in memory, improve your texture resolution instead.\n\n\n\n\nControl flow\n\n\t\n\nThe amount of time that the GPU spends in conditional, increment, or jump instructions as a result of branches or loops in your shader. Use a constant iteration count to minimize control flow time for loops because the Metal compiler can generate optimized code in those cases.\n\n\n\n\nSynchronization\n\n\t\n\nThe amount of time that the GPU spends waiting for a required resource or event before execution can begin. Synchronization types are described below.\n\n\n\n\nSynchronization (wait memory)\n\n\t\n\nThe amount of time that the GPU spends waiting for dependent memory accesses, such as texture sampling or buffer read/write.\n\n\n\n\nSynchronization (wait pixel)\n\n\t\n\nThe amount of time that the GPU spends waiting for underlying pixels to release resources. In addition to color attachments, pixels can come from depth or stencil buffers or user-defined resources. Blending is a common cause of pixel waiting. Use raster order groups to reduce the wait time.\n\n\n\n\nSynchronization (barrier)\n\n\t\n\nThe amount of time that the GPU spends when a thread reaches a barrier and the GPU waits for remaining threads in the same group to arrive at the barrier before proceeding.\n\n\n\n\nSynchronization (atomics)\n\n\t\n\nThe amount of time that the GPU spends on atomic instructions.\n\nTo ensure you see the most up-to-date profiling numbers, set your app’s deployment target to the matching OS version, even if temporarily. The Shader editor displays a warning at the top if the deployment target doesn’t match your OS version.\n\nYou can change the deployment target in the Xcode project settings. If you change the deployment target temporarily, don’t forget to change it back before deploying your app.\n\nUpdate your shader\n\nAfter changing a shader, you can update the captured frame with the new source code by clicking the Reload Shaders button in the debug bar.\n\nAfter updating the captured frame, Xcode does the following:\n\nRedraws the app window.\n\nUpdates the profiler statistics and pie charts.\n\nRedraws attachments in the assistant editor.\n\nMaintains your place in the captured frame, providing an interactive environment to enhance your shader performance tuning.\n\nImportant\n\nTo avoid getting misleading results between different runs, using a consistent performance state is useful when iterating on your shader.\n\nYou can profile using a specific performance state by clicking the GPU Profiler button in the debug bar.\n\nThen, select your desired performance state.\n\nIf your shader is producing incorrect results, you can also debug it. For more information, see Debugging the shaders within a draw command or compute dispatch.\n\nSee Also\nMetal resource inspection\nInspecting acceleration structures\nReveal ray intersection bottlenecks by examining your acceleration structures.\nInspecting buffers\nConfirm your buffer formats by examining buffer content.\nInspecting pipeline states\nDetermine how your render and compute passes behave by examining their properties.\nInspecting sampler states\nVerify your sampler state configurations by examining their properties.\nInspecting textures\nDiscover issues in your textures by examining their content."
  },
  {
    "title": "Inspecting textures | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-textures",
    "html": "Overview\n\nThe Metal debugger allows you to view the contents of a texture in the Texture viewer. First, flip the texture to the correct orientation and adjust the colors to ensure accuracy. Then, check for pixel issues like infinite values, not-a-number values, or any values that exceed the current EDR headroom of your display. Hover over pixels within the texture to inspect their values, then find any anomalies by selecting a pixel and comparing it with others. Finally, compare across mipmap levels to check for visual issues. For more information, see Inspecting the bound resources for a command or Analyzing memory usage.\n\nNavigate your texture\n\nThe Texture viewer contains several controls for interacting with and displaying your texture. If your texture contains multiple slices, such as MTLTextureType.type2DArray, the controls in the title bar are disabled until you click a texture image. The active texture image has a system accent color border.\n\nGroups of texture slices that contain related content, such as the faces for a texture of type MTLTextureType.typeCube, are part of the same texture image.\n\nFlip your texture\n\nIf your renderer is using a different coordinate system and your texture image is upside down or flipped horizontally, you can flip it to the correct orientation in the Texture viewer. Click the texture actions button, then choose Flip Horizontally or Flip Vertically. Xcode flips groups of related texture slices, such as cubemaps, as a whole, and it flips unrelated texture slices independently.\n\nConfigure texture rendering\n\nXcode automatically configures the color properties based on your texture, but you can configure them manually by clicking the Colors button in the title bar. You configure texture rendering on a per-texture-image basis. Follow these guidelines:\n\nSet the color space to the one that the device display uses. For example, use sRGB if you’re debugging an iPhone workload.\n\nIf you’re using a display that supports extended dynamic range, you can enable the Extended Dynamic Range Content option to render the texture with extended range. When this option is enabled, Xcode draws hatching on any pixels containing values above your display EDR headroom. Consider lowering the brightness of your display to increase the available headroom.\n\nXcode shows additional controls to manually configure rendering if you select Default (No color-match) as the color space. You can then configure the range of visible colors, channel swizzling, and whether the alpha is premultiplied.\n\nView texture properties\n\nYou can view properties for the active texture image, such as width and height, by clicking the Info button in the title bar.\n\nView texture issues\n\nThe Issues button in the title bar becomes active if your texture contains any pixels (or samples) with values that are infinite, are not-a-number, or exceed the current EDR headroom of your display.\n\nYou can click the Issues button to see more information, and then click the Jump button to focus on a pixel (or sample) causing the issue.\n\nInspect, select, and compare pixel values\n\nMove the pointer over a pixel (or a sample if your texture is of type MTLTextureType.type2DMultisample or MTLTextureType.type2DMultisampleArray) to inspect its value.\n\nThen, you can select the pixel by clicking it. Alternatively, you can click and hold so that Xcode selects the pixel, zooms in, and immediately opens the value inspector.\n\nYou can also select a pixel using the coordinate input controls on the right of the control bar. Type in the coordinates for the pixel you want, such as X: 100 and Y: 100. Depending on your texture configuration, Xcode may show additional controls.\n\nClick the Jump button in the control bar to zoom in to the selected pixel or sample. Xcode automatically focuses when you click the stepper to the right of each text field.\n\nYou can also move the pointer over a different pixel (or sample) to compare the values. If the selected pixel is to the left of the pixel beneath the pointer, the values of the selected pixel appear on the left of the inspector. If it’s to the right, the values appear on the right. Xcode highlights the coordinates for the selected pixel in the inspector to show which values correspond to which pixel.\n\nIf you open multiple Attachments viewers or Texture viewers, you can compare pixels across different textures. For information on configuring editors within your Xcode workspace, see Configuring the Xcode project window.\n\nCompare mipmap levels\n\nBy default, the Texture viewer shows all of your texture’s mipmap levels side by side. However, if you want to visually compare different mipmap levels, you can enable stacking. Click the texture actions button, and then choose Stack Mips.\n\nDrag the slice slider in the control bar to visually compare different mipmap levels.\n\nNote\n\nBy default, the Texture viewer stacks 3D textures, such as MTLTextureType.type3D, using the z-coordinate. You can disable stacking to see the depth slices side by side. If your 3D texture has multiple mipmap levels, you can choose either Stack Mips or Stack Z.\n\nSee Also\nMetal resource inspection\nInspecting acceleration structures\nReveal ray intersection bottlenecks by examining your acceleration structures.\nInspecting buffers\nConfirm your buffer formats by examining buffer content.\nInspecting pipeline states\nDetermine how your render and compute passes behave by examining their properties.\nInspecting sampler states\nVerify your sampler state configurations by examining their properties.\nInspecting shaders\nImprove your app’s shader performance by examining and editing your shaders."
  },
  {
    "title": "Inspecting the bound resources for a command | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-the-bound-resources-for-a-command",
    "html": "Overview\n\nMetal’s render and compute encoders allow you to set pipeline states, bind resources, specify parameters, and encode GPU commands. The Bound Resources viewer helps you determine the bound resources at any point in an encoder.\n\nInspect bound resources\n\nThe Bound Resources viewer displays the current set of bound resources in the encoder. You can double-click a resource row to further inspect that resource.\n\nFor a render pass, the Bound Resources viewer groups the resources in the following sections:\n\nRender Pipeline: The specified render pipeline state.\n\nExecute Indirect: The indirect command buffer (ICB) that the command executes from.\n\nVertex/Object/Mesh/Tile/Fragment Stage: The resources in the corresponding stage. In addition, it includes the shader function. For the vertex and the mesh stage, it also includes the index buffer and output geometry.\n\nAttachments: The attachment textures.\n\nIndirect: The used indirect resources and those from the same heap. To use a resource, call useResource(_:usage:stages:) or useHeap(_:stages:).\n\nFor a compute pass, the Bound Resources viewer groups the resources in the following sections:\n\nCompute Pipeline: The specified compute pipeline state.\n\nExecute Indirect: The indirect command buffer (ICB) that the command executes from.\n\nCompute: The resources in the compute pass.\n\nIndirect: The used indirect resources and those from the same heap. To use a resource, call useResource(_:usage:), useResources(_:usage:), useHeap(_:), or useHeaps(_:).\n\nThe Bound Resources viewer includes the following information for all resource types:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nLabel\n\n\t\n\nlabel\n\n\t\n\nThe label you set when creating the resource. Use this information to identify specific resources in your app. To learn how to name your resources, see Naming resources and commands.\n\n\n\n\nType\n\n\t\n\n\t\n\nAn attribute to identify the location of the argument in the shader: buffer, texture, sampler, or threadgroup buffer index.\n\n\n\n\nAllocated Size\n\n\t\n\nallocatedSize\n\n\t\n\nThe actual allocated memory size for the resource.\n\n\n\n\nParameter Name\n\n\t\n\n\t\n\nThe name of the variable in the shader that binds to the resource.\n\n\n\n\nResource Usage\n\n\t\n\n\t\n\nAn indicator of whether the shader can read from or write to the resource.\n\n\n\n\nAccess\n\n\t\n\n\t\n\nAn indicator of whether the shader actually accesses the resource in the draw command or compute dispatch.\n\n\n\n\nInsights\n\n\t\n\n\t\n\nPossible problems or optimizations that might improve resource usage.\n\n\n\n\nShader Stages\n\n\t\n\n\t\n\nThe shader stages that use the resource (see MTLRenderStages).\n\nFor textures, you can add the following columns:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nPixel Format\n\n\t\n\npixelFormat\n\n\t\n\nThe Metal pixel format you choose when creating the texture.\n\n\n\n\nType\n\n\t\n\ntextureType\n\n\t\n\nThe texture’s subtype.\n\n\n\n\nWidth\n\n\t\n\nwidth\n\n\t\n\nThe width, in pixels, of the texture’s base mipmap.\n\n\n\n\nHeight\n\n\t\n\nheight\n\n\t\n\nThe height, in pixels, of the texture’s base mipmap.\n\n\n\n\nDepth\n\n\t\n\ndepth\n\n\t\n\nThe depth, in pixels, of the texture’s base mipmap.\n\n\n\n\nSlice\n\n\t\n\nslice\n\n\t\n\nThe slice of the texture for the render pass attachment.\n\n\n\n\nLevel\n\n\t\n\nlevel\n\n\t\n\nThe mipmap level of the texture for the render pass attachment.\n\n\n\n\nDepth Plane\n\n\t\n\ndepthPlane\n\n\t\n\nThe depth plane of the texture for the render pass attachment.\n\n\n\n\nArray Length\n\n\t\n\narrayLength\n\n\t\n\nThe number of slices in the texture array.\n\n\n\n\nMipmap Count\n\n\t\n\nmipmapLevelCount\n\n\t\n\nThe number of mipmap levels that the texture stores.\n\n\n\n\nSample Count\n\n\t\n\nsampleCount\n\n\t\n\nThe number of samples that each pixel stores.\n\n\n\n\nUsage\n\n\t\n\nusage\n\n\t\n\nFlags that indicate the actions a shader or app can perform on the texture. The more restricted the list, the more optimizations Metal can apply to the texture.\n\nFor buffers, you can add the following columns:\n\nColumn\n\n\t\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nLength\n\n\t\n\nlength\n\n\t\n\nThe logical length, in bytes, of the buffer.\n\n\n\n\nOffset\n\n\t\n\n\t\n\nThe location where the data begins, in bytes, from the start of the buffer.\n\nFor functions, you can add the Library column to show the library that the app uses to create the function.\n\nImprove your Metal workload with Insights\n\nClick the Insights button in the bottom right corner to open a popover of recommendations for the bound resources.\n\nInspect resources that the shaders access\n\nThe shaders don’t necessarily access every bound resource in a draw command or compute dispatch. This is very common in bindless workflows where shaders access only a small set of resources from a large heap. The Bound Resources viewer provides a top-level filter for resources that the shaders actually access.\n\nTo apply the filter, click the Accessed button above the table to view only the accessed resources.\n\nLimit your scope with filters\n\nUse the filter field at the bottom of the Bound Resources viewer to adjust the filtering criteria by typing filter terms into it. The table shows the related resources that match the filter terms.\n\nYou can also click the filter button to add filters for specific kinds of resources or for the used indirect resources.\n\nWhen there are two or more filter terms, you can click the filter button to choose whether to match any or all of the terms. For any filter term, you can click it to choose to include or exclude resources that match the term.\n\nSee Also\nMetal command analysis\nInspecting the geometry of a draw command\nFind problems in your app’s vertex, object, or mesh function by examining the current geometry.\nInspecting the attachments of a draw command\nDiscover attachment issues by inspecting individual pixels and samples.\nDebugging the shaders within a draw command or compute dispatch\nIdentify and fix problematic shaders in your app using the shader debugger.\nAnalyzing draw command and compute dispatch performance with GPU counters\nIdentify issues within your frame capture by examining performance counters.\nAnalyzing draw command and compute dispatch performance with pipeline statistics\nIdentify issues within your frame capture by examining pipeline statistics."
  },
  {
    "title": "Inspecting the geometry of a draw command | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-the-geometry-of-a-draw-command",
    "html": "Overview\n\nAfter opening a geometry, you can view the wireframe using the Geometry viewer. First, click the Camera Properties button and configure the perspective matrix. Then, using mouse and trackpad gestures, you can view the geometry at different angles to check for issues. You can also Control-click in the scene view to enable visualization of different vertex attributes. When you click an individual primitive to select it, Xcode displays the values of its corresponding vertices in the data view. In addition, you can inspect a selected primitive in the shader debugger, make changes to your shader, and see the updated results live. For more information, see Inspecting the bound resources for a command.\n\nChange the projection matrix\n\nThe Geometry viewer shows you the output geometry from your vertex or mesh shader stage. To restore your geometry from clip-space to view-space, by default, the Geometry viewer applies an inverse-projection using a perspective matrix with a near value of 0.1, a far value of 100, and an FOV of 65º. However, if you’re using a different projection matrix, your geometry may look squished or stretched.\n\nTo solve this, you can click the Options button on the bottom left in the control bar and customize the projection matrix to match the one you use in the vertex shader.\n\nView your geometry from different angles\n\nYou can navigate around your geometry in the scene view using mouse and trackpad gestures. This enables you to zoom in at a specific area to check for erroneous geometry, or find extraneous geometry that may initially be out of sight.\n\nVisualize your vertex attributes\n\nOccasionally, you might have an issue in an attribute of your geometry. In that case, the Geometry viewer can color your geometry using the attribute to make it easier to find any incorrect values. To do this, Control-click in the scene view, choose Visualize Vertex Attribute, and then select the attribute you want to display.\n\nTip\n\nYou can also Control-click to disable Show Wireframe and Show Vertices to make the attribute visualization easier to see.\n\nInspect vertex values\n\nWhen you discover a misplaced or misshaped primitive, it’s possible that the issue lies in the data you’re passing into the vertex, object, or mesh shader. Check the data view at the bottom to ensure the input and output of your shader is correct. To see all of the attributes for a specific primitive, click the primitive in the scene view to select it, and then Xcode highlights the primitive’s vertices in the data view.\n\nIf your shader has multiple outputs, refer to the additional columns to the right of the output position. You can rearrange or hide columns to make it easier to compare values.\n\nDebug your geometry\n\nSome of the geometry may be misplaced or have values that are incorrect. To determine whether the issue comes from the shader code, you can debug your vertex, object, or mesh shader using the shader debugger. In the scene view, select a misplaced or misshaped primitive and click Debug.\n\nThe shader displays in Xcode’s main editor. To discover the cause of the problem, step through each line of code and inspect each variable’s values in the right pane until you spot any anomaly. For more information on debugging shaders, see Debugging the shaders within a draw command or compute dispatch.\n\nSee Also\nMetal command analysis\nInspecting the bound resources for a command\nDiscover issues by examining the bound resources at any point in an encoder.\nInspecting the attachments of a draw command\nDiscover attachment issues by inspecting individual pixels and samples.\nDebugging the shaders within a draw command or compute dispatch\nIdentify and fix problematic shaders in your app using the shader debugger.\nAnalyzing draw command and compute dispatch performance with GPU counters\nIdentify issues within your frame capture by examining performance counters.\nAnalyzing draw command and compute dispatch performance with pipeline statistics\nIdentify issues within your frame capture by examining pipeline statistics."
  },
  {
    "title": "Inspecting the attachments of a draw command | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/inspecting-the-attachments-of-a-draw-command",
    "html": "Overview\n\nThe Metal debugger allows you to view the contents of render attachments with the Attachments viewer. You can inspect individual pixels (or samples) and debug them with the shader debugger. For more information, see Inspecting the bound resources for a command.\n\nInspect your attachments\n\nThe Attachments viewer contains several controls you can use to interact with and display your attachments. Each visible attachment has its own viewer and title bar, which contains attachment-specific controls. The control bar at the bottom of the Attachments viewer contains controls that operate on all of the attachments simultaneously.\n\nFlip your attachments\n\nIf your renderer is using a different coordinate system and your attachment is upside down or flipped horizontally, you can flip it to the correct orientation in the Attachments viewer. Click the attachment actions button, then choose Flip Horizontally or Flip Vertically.\n\nConfigure visible attachments\n\nYou can configure visible attachments using the preview controls on the left of the control bar. To hide or show an attachment, move your pointer over the attachment preview and click to toggle its visibility.\n\nXcode updates the previews for the hidden attachments too, so you can see at a glance whether they contain anything interesting.\n\nToggle overlay visibility\n\nTo hide overlays, such as the fluorescent green outline, click the attachment and then click a selected overlay to deselect it.\n\nConfigure attachment rendering\n\nXcode automatically configures the color properties based on your encoder and attachment, but you can configure them manually by clicking the Colors button in the attachment-specific controls. Follow these guidelines:\n\nUse the same color space that you use for rendering. Xcode automatically configures it to the colorspace property that your app sets on the CAMetalLayer. If you don’t set this property, configure the color space in the Attachments viewer to the one that the device display uses.\nFor example, use sRGB if you’re debugging an iPhone workload.\n\nIf you’re using a display that supports extended dynamic range, you can enable the Extended Dynamic Range Content option to render the attachment with extended range. When this option is enabled, Xcode draws hatching on any pixels containing values above your display EDR headroom. Lower the brightness of your display to increase the available headroom.\n\nXcode shows additional controls to manually configure rendering if you select Default (No color-match) as the color space. You can then configure the range of visible colors, channel swizzling, and whether the alpha is premultiplied.\n\nView attachment properties\n\nYou can view properties for an attachment, such as texture width and height, by clicking the Info button in the attachment-specific controls.\n\nView attachment issues\n\nThe Issues button in the attachment-specific controls becomes active if your attachment contains any pixels (or samples) with values that are infinite, are not-a-number, or exceed the current EDR headroom of your display. For example, if you accidently divide by 0 in your fragment shader, Xcode draws hatching on any incorrect pixels (or samples).\n\nYou can click the Issues button to see more information, and then click the Jump button to focus on a pixel (or sample) causing the issue.\n\nInspect pixel values\n\nMove the pointer over a pixel or sample to inspect its value.\n\nInspect, select, and compare pixel values\n\nMove the pointer over a pixel (or sample if your render pass does multisample antialiasing) to inspect its value.\n\nThen, you can select the pixel by clicking it. Alternatively, you can click and hold so that Xcode selects the pixel, zooms in, and immediately opens the value inspector.\n\nYou can also select a pixel using the coordinate input controls on the right of the control bar. Type in the coordinates for the pixel you want, such as X: 100 and Y: 100. Depending on your texture configuration, Xcode may show additional controls, such as the sample index.\n\nIf the selected pixel is inside a debuggable region, the coordinates are highlighted in green (see “Debug a pixel” below). If the selected pixel is outside of such a region, Xcode highlights it using your system accent color instead.\n\nClick the Jump button in the control bar to zoom in to the selected pixel or sample. Xcode automatically focuses when you click the stepper to the right of each text field.\n\nYou can also move the pointer over a different pixel (or sample) to compare the values. If the selected pixel is to the left of the pixel beneath the pointer, the values of the selected pixel appear on the left of the inspector. If it’s to the right, the values appear on the right. Xcode highlights the coordinates for the selected pixel in the inspector to show which values correspond to which pixel.\n\nIf you open multiple Attachment viewers or Texture viewers, you can compare pixels across different textures. For more information, see Inspecting textures. For more information on configuring editors within your Xcode workspace, see Configuring the Xcode project window.\n\nDebug a pixel\n\nXcode outlines any regions affected by the current draw command with a fluorescent green overlay. If you notice pixels (or samples) with unexpected values inside these regions, select them and then click the Debug button on the right of the control bar to begin debugging the fragment shader. Xcode automatically opens your fragment shader source code with detailed thread execution history for the pixel. For more information on debugging shaders, see Debugging the shaders within a draw command or compute dispatch.\n\nSee Also\nMetal command analysis\nInspecting the bound resources for a command\nDiscover issues by examining the bound resources at any point in an encoder.\nInspecting the geometry of a draw command\nFind problems in your app’s vertex, object, or mesh function by examining the current geometry.\nDebugging the shaders within a draw command or compute dispatch\nIdentify and fix problematic shaders in your app using the shader debugger.\nAnalyzing draw command and compute dispatch performance with GPU counters\nIdentify issues within your frame capture by examining performance counters.\nAnalyzing draw command and compute dispatch performance with pipeline statistics\nIdentify issues within your frame capture by examining pipeline statistics."
  },
  {
    "title": "Testing a release build | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/testing-a-release-build",
    "html": "Overview\n\nTo ensure your app works in deployment, test your release build in a variety of conditions before submitting the app or app update for review, or distributing to Enterprise users. To catch commonly occurring errors or edge-case situations that might not occur during development, consider the differences between development-environment debug builds and user-environment release builds, shown below.\n\nAn app may behave differently on a particular user’s device for a variety of reasons. Different devices and operating system versions offer varying software features, and app updates involve data migrations, keychain access, or defaults data that’s not present in a fresh app installation. Disabled features, frame throttling, or other delays may result with limited device power, system memory, or network availability. Xcode allows development and release build settings to diverge, and disables watchdog timeouts.\n\nCreate an Xcode archive\n\nTo test the exact conditions your app user’s experience, create a release build. In your Xcode project’s scheme editor, set the run destination to a device and adjust the archive task to the Release configuration.\n\nThen, choose the Archive option in Xcode’s Product menu. After the archive builds, the Organizer displays. For more on creating an app archive, see Distributing your app for beta testing and releases.\n\nXcode saves app archives on disk so you can refer to a particular build later, for example, to submit the build to App Review after the app passes beta tests. The archives’ distribution workflow offers several ways to test the app:\n\nTestFlight\n\nTestFlight automates app distribution and submission to reduce the chances of submitting the wrong build to App Review. To distribute an app archive through TestFlight, choose the archive pane’s App Store Connect option. For more on TestFlight, see Distributing your app for beta testing and releases.\n\nAd Hoc\n\nTo distribute your app to testers manually, for example, by emailing them an .ipa file, choose the archive pane’s Ad Hoc option. For more information, see Distributing your app to registered devices.\n\nEnterprise\n\nEnterprise distribution is similar to Ad Hoc distribution except that you choose the Enterprise option from the Archive pane. Xcode looks for a different code signing identity for Enterprise app distribution that contains a valid Enterprise distribution certificate.\n\nDevelopment\n\nThe development distribution method signs the release build with your development credentials. This option enables testing if you lack access to team distribution identities. The debugger can attach to a development-signed release build, but be aware that it can mask watchdog timeouts.\n\nFor all distribution methods except TestFlight, choose the following options to enhance your chances of discovering a bug that manifests only in the release build:\n\nSet App Thinning to “All compatible device variants”.\n\nYou can access an app archive after distribution to debug a user-reported error. If the issue didn’t surface in beta tests, refer to crash logs and app logging to track down the cause; see Diagnosing issues using crash reports and device logs. To attempt to reproduce the issue, check the build version in the crash log (see the Version field in Examining the fields in a crash report), and test a release build from an app archive with a matching version.\n\nCompare build configuration settings\n\nThe Xcode project’s Build Settings support different values based on the active build configuration. The default build configurations are Debug and Release, which the project scheme maps to the Run task and Archive task, respectively. Since the archive task creates the release build, the release build can behave differently than the build that developers run in the debugger as it relates to build settings.\n\nBy default, most build settings match across the two configurations. To check for differences, inspect the target’s build settings thoroughly. When a setting varies across configurations, Xcode displays <Multiple values>. To see each value, expand the setting’s disclosure triangle.\n\nTo ensure the app’s behavior differs across build configurations as intended, take a moment to consider the full implications of each difference, per setting. In the figure above, the app defines a different Info.plist for the release build.\n\nDisconnect the debugger\n\nWhen Xcode launches an app, it enables a debugger that creates some differences from what users experience:\n\nThe Xcode debugger disables watchdog terminations, which can prevent testers from observing a hang issue while running the app in Xcode. The easiest way to check for watchdog terminations is to disconnect the device from the development machine and launch the app from the home screen. For more on watchdog terminations, see Addressing watchdog terminations.\n\nXcode’s debugger prevents apps from being suspended, so launch your app from the home screen to test background processes. For example, NSURLSession implements a background session, but when the app runs in the Xcode debugger, the background session never runs.\n\nTest a fresh install and app update\n\nXcode optimizes app building and installation during development by updating apps incrementally. Subsequently, as your app’s code changes during development, obsolete stored data created by a prior build may linger unless you purge the prior installation completely. Even though the app may no longer create the obsolete data, access to it may cause the app to behave differently during testing than what users experience. To prevent this transient dependency, remove the app during development to ensure that Xcode installs a fresh build. When you remove the app, choose to also remove the app’s prior data.\n\nThere are two exceptions:\n\nThe system preserves App Group data on the device as long as the app in the group is installed. To remove potentially obsolete test data from an App Group container, remove all apps that share the group.\n\nThe system preserves an app’s keychain data on the device even after you delete the app. To clear the keychain, use SecItemDelete(_:). If you create a separate utility that removes keychain data, the utility and the app need to share the same application identifier.\n\nIf the release build updates a previous version of your app, some users may have the prior version on their device. When your app update aims to support data created by the prior version, test the app update to prevent any regressions. For example, if the updated app changes a file format, or migrates prior data (for example, with Core Data migration; see Migrating your data model automatically), test the app-update scenario to ensure that the new app properly handles prior app data.\n\nRun the app on various devices and OS versions\n\nAn error may surface only on a particular device, OS version, or a particular combination of the two. To ensure a consistent user experience, test on a wide array of devices and OS versions your app supports.\n\nWhen diagnosing user-reported issues, pay attention to the user’s device and OS version. See Hardware Model and OS Version in Examining the fields in a crash report. To reproduce a user-reported issue, maintain a robust suite of test devices that vary in device model and OS version. Although it’s possible to run a release build in the Simulator, consider the Simulator a separate device that users don’t use. As such, always test release builds on an actual device.\n\nTip\n\nRaising your app’s deployment target reduces the number of combinations of device model and OS version to test. If testing all combinations is unmanageable, you can shrink the number of devices your app supports — and thus, the number of devices to test — by raising the deployment target.\n\nCheck file system access\n\nOn macOS, users can have different levels of file system access depending on their user account privilege. One way to test the difference that a user’s account privilege makes in your app is to run the app as a guest user. The file system privileges of a guest user falls under the everyone category in Finder’s Get Info pane. By default, the file system access level for everyone differs from the default admin access level.\n\nEnsure network compatibility\n\nDebug builds typically run in an isolated network during development, whereas release builds access varying networks that service your app’s users. Your app can exhibit a problem in one particular network and not another, for example, due to network congestion or network type, such as IPv6 versus IPv4.\n\nIf developers and beta testers run the app in an IPv4 network, be sure to also test an IPv6 connection to catch any potential issues related to DNS64 or NAT64.\n\nTo simulate slow or unreliable internet connections on iOS, you can use the Network Link Conditioner. Enable this feature with the Settings app > Developer > Network Link Conditioner option.\n\nTo debug high-level HTTP issues, run your release build with an HTTP debugging proxy; see Choosing a Network Debugging Tool. For low-level issues, like a TCP connection or DNS failure, examine network-level activity for causes; see Recording a Packet Trace.\n\nTo debug lost network connections, ensure that network connections reach their destination with no breakdowns along the way by reviewing your server-side logs. For private networks, consider potential blockages due to firewall configuration, network proxies, or load balancers.\n\nSome network errors are unavoidable, for example, during server or network downtime. Ensure that your app provides clear user instructions on what to do when the network doesn’t function as expected.\n\nEnable battery-saving modes\n\nDevices can behave differently based on battery level, the amount of time passed since fully charged, or whether the device battery is charging. For example, Core Location enables an app to request a desired accuracy (desiredAccuracy) but it may perform less accurately than your app requests depending on the device battery level. Alternatively, if a concurrent app or system process requests a high accuracy, Core Location might provide a higher accuracy than requested, which may consume the device battery faster. To observe an app error that might result from a lower battery level, or lower Core Location accuracy than your app expects, test under either battery-saving modes:\n\nOn macOS, run the app on a Macbook unplugged from the power source.\n\nOn iOS or iPadOS, enable Low Power Mode in Settings > Battery.\n\nTo ensure the device is in Low Power Mode, check that the battery indicator is yellow.\n\nMinimize memory use\n\nA user’s device may have less memory available at runtime than testers do either because of varying hardware specifications or the amount of apps the device runs concurrently. To simulate an array of user environments, testers need to vary the amount of memory available to your app. One way to limit available memory is to open other apps. On macOS, you can observe memory statistics using Activity Monitor. The difference between the Physical Memory and Memory Used values equals the system’s available memory.\n\nApps that crash due to memory depletion generate a different kind of crash report, called a jetsam event report. To check for and analyze jetsam events, see Identifying high-memory use with jetsam event reports.\n\nThe volatile nature of memory availability makes it difficult to judge the likelihood of a jetsam event in your app. A good strategy to guard against runtime memory depletion is to proactively minimize your app’s memory requirements using Instruments or MetricKit. For more information, see Reducing Your App's Memory Use.\n\nSupport user-defined input\n\nBecause of the wide the range of variation in user-supplied data, apps that support opening users’ files need to anticipate uncommon scenarios, like corrupt or excessively large data. To ensure a good user experience, test bad and unsupported files.\n\nFor example, if your app loads user-defined images, test loading a very large image. Today’s common image formats compress pixel data, but most systems can only display uncompressed data. Loading an image from file can require orders more space in RAM than the file’s size on disk. You can calculate the number of bytes an image requires in RAM using the formula: W x H x 4 bytes/pixel. A JPG with 4K resolution (3840 x 2160 pixels) is around 1.5 megabytes on disk. To calculate the size in memory, multiply the image dimensions to obtain the number of pixels, and multiply by 4 bytes per pixel.\n\n3840 x 2160 * 4 B = 33,177,600 B\n\nDivide by 1024^2 to convert to megabytes.\n\n33,177,600 B / 1024^2 B/MB = 31.64 MB\n\nTo calculate the percentage larger the image is in memory, divide the in-memory size (31.64 MB) by the on-disk size (1.5 MB).\n\n31.64 MB / 1.5 MB = 21.1 times larger in memory\n\nTo guard against files of unsupported file size, enforce a size limit by refusing to open files past a certain resolution you define.\n\nAs another example, if your app loads user Contacts, test extreme cases to maximize test coverage. For example, your app needs to test a large number of contacts, no contacts, and a contact that contains very little data (or no) data.\n\nTest regions and languages\n\nThe Region user preference setting determines the format of the dates that the OS provides to your app. When a user changes their Region, the system changes the format of every NSDate it supplies your app. If your app processes dates or times, test every language that your app supports to ensure your app can handle all of the possible date formats.\n\nTest with a 12-hour region, a 24-hour region, a 12-hour region that’s overridden to use 24-hour, and a 24-hour region that’s overridden to use 12 hours. Also, test with a Gregorian and non-Gregorian calendar (such as lunar or lunisolar), as well as regions that use Latin and non-Latin digits (such as Arabic). To set the region or calendar:\n\nOn iOS, use Settings > General > Language & Region.\n\nOn macOS, use System Preferences > Language & Region.\n\nIsolate persistent issues\n\nFor issues that continue to surface in only the release build, open an Apple Developer Technical Support (DTS) case by submitting a Technical Support Incident. To facilitate review of the issue, provide DTS with:\n\nDetails about the problem and the steps you followed to reproduce or resolve the error\n\nFor crashes, a log that contains human-readable function references; see Acquiring crash reports and diagnostic logs\n\nThe build UUID of the app archive you’re testing\n\nTo retrieve the archived app’s build UUID, run the Terminal command:\n\n% dwarfdump -u /Path/To/YourApp.xcarchive/Products/Applications/YourApp.app/YourApp\n\nSee Also\nTesting\nTesting a beta OS\nManage unintended differences in your app by testing beta operating-system (OS) releases."
  },
  {
    "title": "Creating a workflow that builds your app for distribution | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-a-workflow-that-builds-your-app-for-distribution",
    "html": "Overview\n\nDelivering a version of your app to testers with TestFlight, uploading a version that’s eligible for app review, or sharing a notarized version a recipient can trust are key tasks of a continuous deployment (CD) practice. Configure an Xcode Cloud workflow that does multiple tasks, or create separate workflows — depending on your preferences, requirements, and the resulting workflow strategy.\n\nIf you’re new to continuous integration and delivery (CI/CD), see About continuous integration and delivery with Xcode Cloud. For more information on developing a workflow strategy, see Developing a workflow strategy for Xcode Cloud.\n\nConfigure the workflow\n\nWhen you create a new workflow to create a new version of your app for distribution to testers with TestFlight, in the App Store, or with notarization, make sure to:\n\nRestrict editing in the General settings of the workflow. This is a required step if you want to create a build that’s eligible for app review or notarization.\n\nIn the Environments settings of the workflow, select Clean to configure the workflow so it starts builds without cached data. For more information, see Perform a clean build.\n\nConfigure an archive action for each applicable platform you want to include in this workflow. For example, add two archive actions — one for iOS and one for macOS — if you want to distribute the iOS and the macOS version of your app with one workflow.\n\nChoose TestFlight (Internal Testing Only) in the settings for the archive action if you want to distribute a development version to your team members with TestFlight.\n\nChoose TestFlight and App Store in the settings for the archive action if you want to create an app binary that’s eligible for public testing with TestFlight and for release on the App Store. Note that external testing is subject to beta app review, and similarly you need to submit your app for review before you can release it on the App Store.\n\nReview whether your new workflow includes test actions. If you use a separate workflow to run comprehensive tests, you may not want to configure a test action. If other workflows don’t run comprehensive tests, consider configuring a test action that performs comprehensive verifications.\n\nChoose start conditions that make sense for your app testing and release process. Common start conditions are branch changes to a release branch or creation of a Git tag that starts with release. If you want to start a build for the workflow manually, configure a start condition that never actually starts a build.\n\nAdd a post-action for internal or external testing with TestFlight. If you choose external testing, you can later decide to submit the version for app review using App Store Connect.\n\nIn the post-action you add, add individual testers or groups of testers in TestFlight. The people or groups you add receive the update on their test device.\n\nAdd a post-action to notarize a macOS app if you intend to distribute it through your own channels. This sends the archive to the notary service to generate a ticket and staples the ticket to the archive. For more information, see Notarizing macOS software before distribution.\n\nDownload and archive build artifacts after a completed build as described in Download and archive build artifacts.\n\nWhen Xcode Cloud successfully builds your app and makes it available to testers in TestFlight, and you configured the workflow to create a binary that’s available for submission to app review, follow the necessary steps to release an app. For more information on using App Store Connect and TestFlight and on publishing your app in the App Store, see App Store Connect Help.\n\nIf your workflow includes a post-action that notarizes your app, you can download the notarized version from the artifacts of a successful build action. Navigate to the build action’s Artifacts, then select the app to download.\n\nSee Also\nWorkflows\nDeveloping a workflow strategy for Xcode Cloud\nReview how you can best create custom Xcode Cloud workflows to refine your continuous integration and delivery practice.\nXcode Cloud workflow reference\nConfigure metadata, start conditions, actions, post-actions, and more to create custom Xcode Cloud workflows."
  },
  {
    "title": "Debugging the shaders within a draw command or compute dispatch | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/debugging-the-shaders-within-a-draw-command-or-compute-dispatch",
    "html": "Overview\n\nIf you notice any visual artifacts while running your app, such as missing geometry or invalid pixels, you can use the shader debugger to investigate problematic shaders. Step through your shader source code and inspect variable values until you discover the problem. Then, just edit the shader source and reload the shader to verify your fix.\n\nImportant\n\nInclude source code when you capture a Metal workload because the shader debugger needs it to function correctly. For more information, see Building your project with embedded shader sources.\n\nDebug your shader\n\nTo begin debugging a shader, select the draw command or compute dispatch of interest in the Debug navigator. Then, click the Shader Debugger button in the debug bar to begin debugging any of the associated shaders for the currently bound pipeline state.\n\nThe shader debugger opens a dialog that includes a tab for each shader type in use so you can easily select the shader region of interest. For example, if your draw command has a vertex and fragment shader, the dialog includes Vertex and Fragment tabs.\n\nThe Vertex tab shows the geometry of your draw command. You can immediately start debugging your vertex shader by clicking the Debug button on the bottom right because the shader debugger automatically selects the first vertex.\n\nFor more information, see Inspecting the geometry of a draw command.\n\nThe dialog includes tabs for Mesh and Object, if applicable, instead of the Vertex tab when a draw command uses a mesh-based pipeline state.\n\nThe Mesh and Object tabs show the geometry of your draw command. You can immediately start debugging your mesh or object shaders by clicking the Debug button on the bottom right because the shader debugger automatically selects the first mesh grid and its first mesh.\n\nYou can set the threadgroup position that produced a mesh in the thread selector by clicking the Mesh tab and selecting a mesh in the table or the geometry view. You can also set the thread position that produced a vertex in a mesh by choosing Thread Position for Vertex and selecting a vertex in the table or the geometry view. Alternatively, you can set the thread position that produced a primitive or an index in a mesh by choosing Thread Position for Primitive or Index.\n\nYou can set the threadgroup position that produced a mesh grid in the thread selector by clicking the Object tab and selecting a mesh grid in the table or the geometry view.\n\nFor more information, see Inspecting the geometry of a draw command.\n\nThe Fragment tab shows the first attachment of your draw command, and hides other attachments by default. You can immediately start debugging your fragment shader by clicking the Debug button on the bottom right because the shader debugger automatically selects a pixel within a debuggable region. Alternatively, you can select a different pixel, change the visible attachments, and so on.\n\nFor more information, see Inspecting the attachments of a draw command.\n\nIf you select a compute dispatch rather than a draw command, you can immediately start debugging your compute shader by clicking the Debug button on the bottom right because the shader debugger automatically selects the first threadgroup.\n\nYou can also expand the Functions to Debug option to select a subset of functions within your shader source. Using a subset of functions can dramatically decrease the amount of the shader debugger’s initial processing.\n\nYou can also select a subset of functions in the Vertex, Mesh, Object, and Fragment tabs by clicking Debug while holding down the Option key.\n\nStep through your shader code\n\nAfter you click the Debug button, the shader debugger displays the shader source in the Shader editor (see Inspecting shaders).\nThe call tree on the left shows each executed line in your shader. The values of the variables appear to the right of each shader line of source code in the Shader editor. For example, in the screenshot below, you can see that the in variable has a value containing 721.5, 815.5, and so on.\n\nIf your shader is producing incorrect results, you can examine the value of variables on each line until you see an unexpected value that indicates the cause of the problem. Use the call tree to quickly inspect your shader:\n\nWhen you select a line in the call tree, its corresponding line of source code in the Shader editor to the right appears with a green highlight. This line is also referred to as the location of the playhead. Use your keyboard arrow keys in the call tree to advance the playhead through your code one line at a time. As you step through the call tree, the playhead follows along in the source code in the Shader editor.\n\nArrow key\n\n\t\n\nStepping direction\n\n\n\n\nDown Arrow\n\n\t\n\nSteps forward\n\n\n\n\nUp Arrow\n\n\t\n\nSteps backward\n\n\n\n\nRight Arrow\n\n\t\n\nSteps in\n\n\n\n\nLeft Arrow\n\n\t\n\nSteps out\n\nAlternatively, you can change the playhead location by clicking any line in the Shader editor, and the shader debugger moves to the corresponding function in the call tree.\n\nIterate through loops\n\nUnlike a traditional CPU debugger, the shader debugger shows the value of all variables at the same time, with no need to step to the next line. If you decide not to use the call tree to iterate through loops, you can switch the visible loop iteration directly within the Shader editor. Click the Loop Iteration tab on the right above the loop, just before the variables sidebar. When you select a different iteration, the variables within the sidebar update to reflect their values during that iteration.\n\nInspect variable values\n\nTo inspect the value of a variable, move the pointer over it. For example, in the screenshot below, hovering over linearSampler shows the sampler properties in a popover.\n\nAlternatively, you can toggle the Preview button in the variables sidebar to show the value inline with the source. This is useful if you want to compare the values of multiple variables simultaneously.\n\nIf a variable has nested properties, you can disclose them in a cascading fashion.\n\nThis enables you to dive in to an object’s data by showing you more than the Shader editor can fit in the right sidebar.\n\nIn addition to the selected pixel or thread, the shader debugger also shows the variable values for nearby pixels, or other threads within the threadgroup, in what is known as the region of interest. When you expand a variable preview, the shader debugger shows the values of variables for all pixels or threads within the region of interest.\n\nTip\n\nThe region of interest appears in the Attachments viewer as a fluorescent orange square (see Inspecting the attachments of a draw command), and in the Geometry viewer as an orange vertex (see Inspecting the geometry of a draw command).\n\nUse this rendering to visually check that the variable is the value you expect. For graphical data, the visualization can be easier to verify than numerical data alone. Move the pointer over a pixel or thread to see the variable value for it. Then, you can click the pixel or thread to select it. The Shader editor automatically changes the variables in the variables sidebar to reflect their values during the execution of the shader when using the newly selected pixel or thread.\n\nIn the preview, the mask shows the pixels or threads within the region of interest that executed the line of code. Consider the example below, where the fragment shader branches depending on the vertex in-position. In the mask, the pixels within the region of interest that passed the condition appear with a white color, and pixels that didn’t pass the condition appear with a black color.\n\nUpdate your shader\n\nAfter changing a shader, you can update the captured frame with the new source code by clicking the Reload Shaders button in the debug bar.\n\nAfter updating the captured frame, the shader debugger does the following:\n\nUpdates variable views to show their new values.\n\nRedraws attachments in the assistant editor.\n\nMaintains your place in the captured frame, which provides an interactive environment to enhance your shader development and debugging.\n\nImportant\n\nChanges to your shader source only exist within the shader debugger. Your original source code doesn’t change. If your shader results look correct after reloading the shader, make sure that you copy your changes to your original shader source code.\n\nIf your shader is producing correct results, but taking a long time to run, consider profiling your Metal workload and inspecting the shader source in the Shader editor. For more information, see Inspecting shaders.\n\nSee Also\nMetal command analysis\nInspecting the bound resources for a command\nDiscover issues by examining the bound resources at any point in an encoder.\nInspecting the geometry of a draw command\nFind problems in your app’s vertex, object, or mesh function by examining the current geometry.\nInspecting the attachments of a draw command\nDiscover attachment issues by inspecting individual pixels and samples.\nAnalyzing draw command and compute dispatch performance with GPU counters\nIdentify issues within your frame capture by examining performance counters.\nAnalyzing draw command and compute dispatch performance with pipeline statistics\nIdentify issues within your frame capture by examining pipeline statistics."
  },
  {
    "title": "Setting up StoreKit Testing in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/setting-up-storekit-testing-in-xcode",
    "html": "Overview\n\nStoreKit Testing in Xcode is a local test environment for testing in-app purchases without requiring a connection to App Store servers. Set up in-app purchases in a local StoreKit configuration file in your Xcode project, or create a synced StoreKit configuration file in Xcode from your in-app purchase settings in App Store Connect. After you enable the configuration file, the test environment uses this local data when your app calls StoreKit APIs.\n\nNote\n\nEnable Developer Mode to test your app on devices running iOS 16 and later, visionOS, or watchOS 9 and later. For more information about how to enable Developer Mode, see Enabling Developer Mode on a device.\n\nAs you test transactions, the test environment displays a payment sheet with localized values, and produces receipts for you to verify.\n\nTesting in-app purchase scenarios with StoreKit in Xcode is useful for:\n\nDeveloping features that use in-app purchases before configuring them in App Store Connect.\n\nTesting locally when a network connection isn’t available.\n\nDebugging in-app purchase use cases that are harder to set up in the sandbox environment, such as eligibility for promotional offers.\n\nViewing localized product information in the payment sheet.\n\nTesting transactions end-to-end, including failed transactions.\n\nThe full functionality of StoreKit Testing in Xcode is available for automation. See StoreKit Test for information about automating in-app purchase testing. For more information about testing StoreKit at different stages of development, see Testing at all stages of development with Xcode and the sandbox.\n\nCreate a StoreKit configuration file\n\nA StoreKit configuration file contains descriptions of in-app purchases, subscription groups, auto-renewable subscriptions, and non-renewing subscriptions. When the configuration file is active, StoreKit uses this data when your app calls StoreKit APIs in the test environment. There are two types of StoreKit configuration files: local and, in Xcode 14 and later, synced.\n\nSet up a local configuration file if you haven’t set up your app in App Store Connect, or you want to try out new types of in-app purchases or subscriptions before you set them up in App Store Connect. The local data is convenient to edit in Xcode, and stands in for the data that otherwise comes from App Store Connect.\n\nSet up a synced configuration file if you have in-app purchases or subscriptions already set up in App Store Connect that you want to test in Xcode.\n\nTo create a StoreKit configuration file:\n\nLaunch Xcode, then choose File > New > File.\n\nIn the sheet that appears, enter storekit in the Filter search field.\n\nSelect StoreKit Configuration File, then click Next.\n\nIn the dialog, enter a name for the file. For a synced configuration file, select the checkbox, specify your team and app in the drop-down menus that appear, then click Next. For a local configuration, leave the checkbox unselected, then click Next.\n\nSelect a location, and click Create.\n\nSave the file to your project.\n\nIf you rename the configuration file, be sure to keep its file extension .storekit.\n\nNote\n\nYou can convert a synced configuration file to a local configuration file. If you want to sync again, create a new synced configuration file.\n\nSet up a StoreKit configuration\n\nTo edit the settings in a local StoreKit configuration file, select the file in the Project navigator to open the custom editor. Click the Add button (+) in the editor to add product details to the configuration file.\n\nNote\n\nYou can’t edit a synced configuration file unless you convert it to be a local configuration file. To convert a synced configuration file, select the file, then choose Editor > Convert to Local StoreKit Configuration from the Xcode menu. Click Convert File in the confirmation dialog. When you’re viewing a synced configuration file, click the Sync button in the bottom left corner to pull the latest updates from App Store Connect.\n\nEnter the information in your local StoreKit configuration file manually. The product names, IDs, prices, localizations, and any other data you provide in the StoreKit configuration file don’t upload to App Store Connect, and don’t appear in App Store-signed apps. App Store Connect data transfers only to a synced StoreKit configuration file, which you can’t edit in Xcode.\n\nTip\n\nIf you have a synced configuration file with items you want to test in a local configuration file, you may copy an item from your synced configuration file to your local configuration file. To do this, Control-click an item in your synced configuration file, and choose Copy. In your local configuration file, select where you want to place the item, and choose Edit > Paste from the Xcode menu.\n\nEach in-app purchase and non-renewing subscription has a reference name, product ID, and price. In-app purchases and non-renewing subscriptions optionally have localizations. This metadata shows up in the payment sheet after you click to buy a product in your app. Note that the price is a placeholder value that’s not connected to price tiers or real pricing information. However, it appears using the correct currency symbols for the storefront you’re testing.\n\nFor non-consumable in-app purchases and auto-renewable subscriptions, select Family Sharing to mark the product for sharing as the following image shows:\n\nWhen you set up the first auto-renewable subscription, Xcode prompts you to create the first subscription group. After adding subscriptions to a group, the level you assign to each subscription determines their upgrade and downgrade options. For more information, see Offer auto-renewable subscriptions.\n\nFor auto-renewable subscriptions, set up introductory offers and promotional offers with the options available in App Store Connect. To begin testing, configure at least one in-app purchase product.\n\nEnable StoreKit Testing in Xcode\n\nTo enable StoreKit Testing in Xcode, your project must have an active StoreKit configuration file. By default, StoreKit Testing in Xcode is disabled. To select a configuration file and make it active:\n\nClick the scheme to open the Scheme menu and choose Edit Scheme.\n\nIn the scheme editor, select the Run action.\n\nClick the Options tab.\n\nFor the StoreKit Configuration option, select a configuration file and click Close.\n\nYou can also add an existing StoreKit configuration file to the project from this menu. Choose a configuration file with a .storekit file extension.\n\nAn Xcode project can contain multiple StoreKit configuration files, but only one can be active at a time. When it’s active, build and run your app as usual. Instead of accessing App Store Connect or the sandbox server, your app gets StoreKit data from the test environment.\n\nDisable StoreKit Testing in Xcode\n\nTo disable StoreKit Testing in Xcode, remove the StoreKit configuration file from the scheme’s run options:\n\nClick the scheme to open the Scheme menu and choose Edit Scheme.\n\nIn the scheme editor, select the Run action.\n\nClick the Options tab.\n\nFor the StoreKit Configuration option, select None.\n\nYour app stops using the local data from the configuration file and starts using the data from App Store Connect. For more information, see Overview for configuring in-app purchases.\n\nPrepare to validate receipts in the test environment\n\nStoreKit Testing in Xcode generates locally signed receipts that your app validates locally. Obtain the certificate you need for local validation and add it to your project as follows:\n\nIn Xcode’s Project navigator, click the StoreKit configuration file.\n\nFrom the Xcode menu, choose Editor > Save Public Certificate.\n\nSelect a location in your project to save the file.\n\nNote\n\nThe test environment’s certificate is a root certificate. There’s no certificate chain to validate when you validate the receipt signature.\n\nBe sure your code uses the correct certificate in all environments. Add the following conditional compilation block to your receipt validation code to select the test certificate for testing, and the Apple root certificate, otherwise:\n\n#if DEBUG\n    let certificate = \"StoreKitTestCertificate\" \n#else\n    let certificate = \"AppleIncRootCertificate\" \n#endif\n\n\nYour code is ready to validate receipts by selecting the appropriate certificate in the test environment and in the production environment.\n\nImportant\n\nReceipts you produce in the test environment aren’t signed by the App Store and aren’t valid for apps in production.\n\nSee Also\nStoreKit\nTesting in-app purchases with StoreKit transaction manager in Xcode\nUse the transaction manager within Xcode to test in-app purchases without requiring a connection to App Store servers."
  },
  {
    "title": "Analyzing draw command and compute dispatch performance with GPU counters | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-draw-command-and-compute-dispatch-performance-with-gpu-counters",
    "html": "Overview\n\nThe Performance Statistics viewer displays counters to help you understand the automatically generated insights for hotspots and bottlenecks so you can improve GPU performance. GPU performance counters are granular statistics that relate to the specific render, compute, or blit work your app performed in the captured frame.\n\nShow columns for performance counters\n\nControl-click a column header to show and hide counter value columns for median, maximum, and total values. You can view the following columns:\n\nDraw\n\nThe statistics for a command. For percentages like Vertex Stage Time, it measures the percentage of samples that the vertex stage uses for that draw.\n\nEncoder\n\nThe statistics for a pass. For percentages like Vertex Stage Time, it measures the percentage of samples that the vertex stage uses for all draws in the render pass.\n\nMedian\n\nThe median counter value across all passes in the GPU trace.\n\nMax\n\nThe maximum counter value across all passes in the GPU trace.\n\nTotal\n\nThe total of counter values for all passes in the GPU trace.\n\nCheck counters data for anomalies\n\nMove the pointer over a counter to reveal its description.\n\nBy analyzing values that may be hotspots, counters can suggest a specific cause of your app’s performance problem. For example, if the number of vertices is twice as high as you expect, it’s likely that your code has duplicate meshes or render encoder draw calls.\n\nLimit your scope with filters\n\nUse the filter field at the bottom of the table to adjust filtering criteria by typing filter terms into it. The table shows individual counters and groups of counters with names that match those filter terms.\n\nWhen there are two or more filter terms, you can click the filter button to choose whether to match any or all of the terms. For any filter term, you can click it to choose to include or exclude counters that match the term.\n\nSee Also\nMetal command analysis\nInspecting the bound resources for a command\nDiscover issues by examining the bound resources at any point in an encoder.\nInspecting the geometry of a draw command\nFind problems in your app’s vertex, object, or mesh function by examining the current geometry.\nInspecting the attachments of a draw command\nDiscover attachment issues by inspecting individual pixels and samples.\nDebugging the shaders within a draw command or compute dispatch\nIdentify and fix problematic shaders in your app using the shader debugger.\nAnalyzing draw command and compute dispatch performance with pipeline statistics\nIdentify issues within your frame capture by examining pipeline statistics."
  },
  {
    "title": "Improving code assessment by organizing tests into test plans | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/organizing-tests-to-improve-feedback",
    "html": "Overview\n\nA mature project benefits from many tests that cover a variety of scenarios. Tests can verify code behavior or measure performance; they can test different products, or the same product on different targets or configurations. They can be long-running UI tests that exercise complex workflows or small unit tests that exercise individual functions, as described in Testing your apps in Xcode.\n\nControl the information you receive from your tests at different stages in the software engineering process by organizing these tests into test plans, and configuring how Xcode executes the test plans. For example, you can create a test plan to run only the unit tests for a module while developing and debugging that module, and a second test plan to run all unit, integration, and UI tests before submitting your app to the App Store.\n\nCreate schemes to associate test targets with products\n\nA scheme instructs Xcode to use specific targets when you invoke the building, testing, running, analyzing, profiling, and archiving actions, shown in the figure below. In the test action for a scheme, include the target for the product under test along with the test targets that contain tests relevant to that product.\n\nFor information on creating Xcode schemes and assigning targets to schemes, see Customizing the build schemes for a project.\n\nIf your product has multiple targets — like an iOS app that contains a static library and a widget extension — create a scheme for each of the individual targets in addition to an “umbrella” scheme that builds the whole product suitable for release. Developers on your team can use the more specific scheme when working on tasks in each target, running only the tests relevant to that target to get faster feedback. When they are ready to integrate their changes, developers can get better assurance that they have not introduced regressions by running the complete collection of tests in the umbrella scheme.\n\nCreate test plans to organize the tests for a scheme\n\nA test plan is a document in your Xcode project that describes which tests Xcode should run when a developer invokes the test action, shown in the figure below, and the configurations Xcode uses to run the tests. You can create multiple test plans for the same scheme and use any of them when running tests from Xcode or in Terminal. You must choose one test plan as the default plan for the scheme; Xcode uses this plan to run tests when none is explicitly specified.\n\nTo convert the current scheme to use test plans, do the following:\n\nChoose Product > Scheme > Convert Scheme to use Test Plans.\n\nSelect “Create Test Plan from scheme” from the panel shown in the figure below.\n\nClick Convert.\n\nTo create additional test plans, do the following:\n\nChoose Product > Test Plan > New Test Plan.\n\nEnter a name for the new test plan.\n\nChoose a location to save the test plan.\n\nClick Create.\n\nTo select the default test plan for the current scheme, do the following:\n\nChoose Product > Test Plan > Manage Test Plans.\n\nSelect the radio button in the Default column next to the desired test plan, as shown below:\n\nChoose the test cases and methods to run in a test plan\n\nYou can further filter the tests that Xcode runs for a given test plan by enabling or disabling test targets, cases, and methods in the plan. To choose which tests are enabled, do the following:\n\nSelect the test plan in the Project navigator.\n\nIn the Tests pane, click the Add button (+) in the lower-right to add test targets to the test plan.\n\nSelect the checkboxes in the Enabled column next to the test targets, cases, or individual test methods that Xcode should run when it follows this test plan.\n\nIf you exclude a test case or test method from a test plan, Xcode skips over the excluded tests and doesn’t provide feedback on their status. The only effect an excluded test method has on the outcome of the test action is if the test contains a build error, in which case the whole test action fails.\n\nYou can use functions in XCTest to modify the effect a test has on the outcome of a test action without ignoring its execution. To skip a test because the execution platform or configuration is inappropriate for the test, use XCTSkipIf(_:_:file:line:) or XCTSkipUnless(_:_:file:line:). To indicate that a test is expected to fail, use XCTExpectFailure(_:options:).\n\nAdjust configurations for test plans\n\nEach test plan contains one or more configurations that tell Xcode how to set up the runtime environment for the tests. In the Configurations tab of the test plan editor, shown in the figure below, you can set environment variables, enable additional checks such as the address sanitizer and memory management guards, and choose different localization settings for the code.\n\nThe values you can specify in a test plan configuration are:\n\nArguments Passed on Launch\n\nCommand-line arguments to the product under test.\n\nEnvironment Variables\n\nValues set in the tested product’s environment.\n\nTarget for Variable Expansion\n\nThe target that Xcode should use as a basis for expanding build settings. For a list of the settings available, see Build settings reference.\n\nApplication Language\n\nThe language used for localized strings in the product under test, or System Language to use the language specified in System Settings.\n\nApplication Region\n\nThe region used for locale settings in the product under test, or System Region to use the region specified in System Settings.\n\nSimulated Location\n\nThe location returned when using location services during tests. Specify a location, None to use the location of the device running test, or a GPX file to simulate traveling a route during tests.\n\nAutomatic Screenshots\n\nSpecify whether the UI Automation test runner captures screenshots as it runs tests, and whether it deletes screenshots for passing tests.\n\nLocalization Screenshots\n\nGather screenshots of your app for localizers. For more information, see Creating screenshots of your app for localizers.\n\nAttachments\n\nGather attachments with augmented information about test behavior. For more information, see attachments.\n\nCollect Test Diagnostics on Failure\n\nCollect diagnostic information in any situation where a test fails, only when testing with xcodebuild, or never.\n\nExecution Order\n\nControl whether Xcode runs tests in alphabetical order, or picks a random order each time. Running tests in a random order can uncover situations where one test’s behavior depends on actions taken in other tests.\n\nTest Timeouts\n\nControl whether tests automatically fail after a set amount of time.\n\nDefault Test Execution Time Allowance (s)\n\nThe number of seconds a test runs for by default before it automatically fails. The minimum value you can set is 60 seconds. Override this setting for an individual test by calling executionTimeAllowance. This value is ignored if Test Timeouts is set to No.\n\nMaximum Test Execution Time Allowance (s)\n\nThe maximum number of seconds a test can run for before it automatically fails. The minimum value you can set is 60 seconds. A test times out after the maximum test execution time allowance has elapsed, even if the test requests a longer execution time using executionTimeAllowance. This value is ignored if Test Timeouts is set to No.\n\nTest Repetition Mode\n\nChoose whether tests are run once, repeated until they fail, repeated until they pass, or run a set number of times.\n\nMaximum Test Repetitions\n\nThe highest number of times a test is repeatedly run.\n\nRelaunch Tests for Each Repetition\n\nWhether Xcode launches a new process for each test repetition.\n\nCode Coverage\n\nCollect code coverage metrics during test runs.\n\nAddress Sanitizer\n\nDetect out-of-bounds access to memory, memory used after it has been freed, and other incorrect memory use.\n\nThread Sanitizer\n\nDetect thread-related race conditions.\n\nUndefined Behavior Sanitizer\n\nDetect issues related to undefined behavior in the C programming language.\n\nMain Thread Checker\n\nDetect issues caused by using API on background threads that should only be used on the main thread.\n\nMalloc Scribble\n\nWrite a specific value to freed memory, to support detecting incorrect use of freed memory.\n\nMalloc Guard Edges\n\nAdd guard pages before and after large allocations, to support detecting out-of-bounds memory use.\n\nGuard Malloc\n\nUse a substitute version of the memory allocator with additional detection for incorrect memory uses.\n\nZombie Objects\n\nReplace deallocated objects with zombies that crash your app when they receive Objective-C messages.\n\nMalloc Stack Logging\n\nRecord the function call stack whenever memory is allocated.\n\nFor more information on the address sanitizer, thread sanitizer, undefined behavior sanitizer, and main thread checker, see Diagnosing memory, thread, and crash issues early.\n\nTo create additional test plan configurations, click the Add button. Xcode runs the tests specified in a test plan once for each of that plan’s configurations.\n\nAdd a test plan to a scheme\n\nYou can associate a test plan with more than one scheme, to get the same test cases and methods included with the same configurations in multiple schemes. To add an existing test plan to a scheme, do the following:\n\nChoose Product > Test Plan > Manage Test Plans.\n\nClick the Add button below the list of test plans.\n\nChoose Add existing Test Plan.\n\nSelect the test plan you want to add to the scheme.\n\nRun the tests specified in a test plan in Xcode\n\nWhen Xcode runs the test action, it executes the tests in the active test plan once for each configuration in the test plan. To set the active test plan and run the tests specified in that plan, do the following:\n\nChoose Product > Test Plan.\n\nSelect the test plan you want to run.\n\nChoose Product > Test.\n\nFor information about interpreting the results of tests in Xcode, see Running tests and interpreting results.\n\nRun tests from the command-line\n\nTo run tests using a specific test plan from the command-line, you must explicitly name the test plan to use. To discover the test plans for SampleApp, run the following:\n\n% xcodebuild -scheme SampleApp -showTestPlans\n\n\nTo run the tests specified in the “Performance Tests” test plan, run the following:\n\n% xcodebuild -scheme SampleApp test -testPlan Performance\\ Tests\n\n\nTo run the tests in the “Performance Tests” test plan, using only the configuration called “My Config”, run the following:\n\n% xcodebuild -scheme SampleApp test -testPlan Performance\\ Tests --only-test-configuration My\\ Config\n\n\nTo run the tests in the “Performance Tests” test plan, using all configurations except “My Config”, run the following:\n\n% xcodebuild -scheme SampleApp test -testPlan Performance\\ Tests --skip-test-configuration My\\ Config\n\nSee Also\nTest development\nAdding unit tests to your existing project\nRemove coupling between components to increase test coverage and reliability."
  },
  {
    "title": "Testing complex hardware device scenarios in Simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/testing-complex-hardware-device-scenarios-in-simulator",
    "html": "Overview\n\nSome features that you support in your app can be challenging to test thoroughly on a hardware device. For example:\n\nFace ID and Touch ID each require a setup process. To test how your app handles the case when Face ID or Touch ID isn’t set up on a device, you would have to remove fingerprints or faces from your device, and then set them up again after that test.\n\nFall detection requires significant setup and preparation to do repeated tests safely.\n\nTo trigger a memory warning in your app on a device, you need to open up a number of other apps that consume memory, and coordinate it in such a way that your app receives the memory warning.\n\niCloud syncing on a device may not happen as frequently as you need during your testing.\n\nTesting how your app responds to different locations or how it responds as you traverse a route can be time-consuming and difficult, especially in areas with poor cellular service.\n\nTest these and other scenarios with Simulator’s hardware device feature support.\n\nTest Face ID or Touch ID authentication\n\nSince Face ID and Touch ID each require a setup process, you need to test both how your app handles authentication when the user hasn’t configured Face ID or Touch ID yet, and when the user has configured them. To test the preconfigured state, choose Features > Face ID or Features > Touch ID, and deselect the Enrolled option. Select the Enrolled option to test the configured state.\n\nWhen your app requests authentication, try a matching ID with Features > Face ID > Matching Face or Features > Touch ID > Matching Touch, or a non-matching ID with Features > Face ID > Non-matching Face or Features > Touch ID > Non-matching Touch.\n\nTest a simulated fall\n\nTo test how your app responds to a detected fall in Simulator, choose Features > Simulate Fall, then choose one of the following fall response options to simulate:\n\nConfirmed\n\nDismissed\n\nRejected\n\nUnresponsive\n\nTest a memory warning\n\nNavigate to a place in your app where you’ve added code that responds to a memory warning, then choose Debug > Simulate Memory Warning. Confirm that your app responds appropriately.\n\nTest iCloud sync\n\nUse Simulator to test data synchronization between iCloud and the simulated device. Use hardware devices for performance testing.\n\nCreate and use a separate Apple ID specifically for testing iCloud in Simulator. Sign in to iCloud on the simulated device.\n\nThen, prepare your app as needed, and choose Features > Trigger iCloud Sync to trigger the system to synchronize updates with the server.\n\nNote\n\nYou must trigger synchronization manually because Simulator doesn’t support notifications that trigger automatic data synchronization.\n\nTest changing locations\n\nTest how your app handles moving to a specific location, or moving along a route in Simulator.\n\nSimulator contains some preset locations and routes. Choose Features > Location, and then select one of these options:\n\nApple\n\nSets the location to the Apple Infinite Loop campus in Cupertino.\n\nCity Bicycle Ride\n\nSimulates the user taking a bicycle ride in Cupertino. The route repeats until you change the location.\n\nCity Run\n\nSimulates the user taking a run in Cupertino. The route repeats until you change the location.\n\nFreeway Drive\n\nSimulates the user driving from Cupertino to San Francisco. The route repeats until you change the location.\n\nTo set the location to a specific latitude and longitude:\n\nChoose Features > Location > Custom Location…\n\nEnter your location’s latitude and longitude in the dialog box.\n\nClick OK to set the location.\n\nTo clear the location so that the simulated device has no location, choose Features > Location > None.\n\nView the system log\n\nUse the system log to find errors, warnings, and other issues with your application. Choose Debug > Open System Log to open the system log for the simulated device in the Console app.\n\nSee Also\nSimulator testing considerations\nTesting in Simulator versus testing on hardware devices\nReview the differences between Simulator and hardware devices to determine which you should choose to test a scenario.\nSharing data with Simulator\nEnter text directly in Simulator, or share location data, images, web addresses, files, or data from the clipboard with Simulator.\nIdentifying graphics and animations issues in Simulator\nReveal performance and display issues in your views with color overlays, and slow down animations to debug and improve them."
  },
  {
    "title": "Adding structure to your documentation pages | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-structure-to-your-documentation-pages",
    "html": "Overview\n\nBy default, when DocC generates documentation for a project, it creates a top-level page that groups the symbols by their kind. For frameworks and packages, DocC includes the public symbols, and for app targets, it includes both the internal and public symbols. You can then provide additional context to explain how your app or framework works and how different symbols relate to each other.\n\nFor a more tailored learning experience, use one or more of the following approaches:\n\nCustomize the main landing page for your documentation catalog to introduce your technology and organize its top-level symbols.\n\nAdd symbol-specific extension files that organize nested symbols, such as methods and properties.\n\nUse collections to group multiple symbols and introduce hierarchy to the navigation of your documentation pages.\n\nFor more information about how to use DocC for adding structure to the documentation, see Adding Structure to Your Documentation Pages at Swift.org.\n\nCustomize your documentation’s landing page\n\nA landing page provides an overview of your technology, introduces important terms, and organizes the resources within your documentation catalog — the files that enrich your source documentation comments. The landing page is an opportunity for you to ease the reader’s learning path, discuss key features of your technology, and offer motivation for the reader to return to when they need it.\n\nWhen you add a documentation catalog to your project, Xcode automatically includes an empty landing page. For more information, see Documenting apps, frameworks, and packages.\n\nIf you need to manually add a landing page to your documentation catalog, follow these steps:\n\nIn Xcode, select your documentation catalog in the Project navigator.\n\nChoose File > New > File to open the file template chooser.\n\nSelect the Empty template in the Documentation section and click Next.\n\nEnter a filename and click Create. Xcode creates a Markdown file that contains only a placeholder for the page title.\n\nUse a filename that matches the target’s product module name. For example, for the SlothCreator framework, the filename is SlothCreator.md.\n\nNote\n\nFor targets with spaces in the product name, Xcode replaces the spaces with underscores in the product module name. To find the product module name in an Xcode project, select the target in the project editor, click the Build Settings tab, and enter Product Module Name in the search field.\n\nArrange top-level symbols using topic groups\n\nBy default, DocC arranges the symbols in your project according to their kind. For example, the compiler generates topic groups for classes, structures, protocols, and so forth. You then add information to explain the relationships between those symbols.\n\nTo help readers more easily navigate your framework, arrange symbols into groups with meaningful names. Place important symbols higher on the page, and nest supporting symbols inside other symbols. Use group names that are unique, mutually exclusive, and clear. Experiment with different arrangements to find what works best for you.\n\nTo override the default organization and manually arrange the top-level symbols in your technology, add a Topics section to your technology’s landing page. Below any content already in the Markdown file, add a double hash (##), a space, and the Topics keyword.\n\n## Topics\n\n\nAfter the Topics header, create a named section for each group using a triple hash (###), and add one or more top-level symbols to each section. Precede each symbol with a dash (-) and encapsulate it in a pair of double backticks (``) .\n\n## Topics\n\n\n### Creating sloths\n\n\n- ``SlothGenerator``\n- ``NameGenerator``\n- ``Habitat``\n\n\n### Caring for sloths\n\n\n- ``Activity``\n- ``CareSchedule``\n- ``FoodGenerator``\n- ``Sloth/Food``\n\n\nDocC uses the double backtick format to create symbol links, and to add the symbol’s type information and summary. For more information, see Formatting Your Documentation Content Swift.org.\n\nWhen you rebuild your documentation, the documentation viewer reflects these organizational changes in the navigation pane and on the landing page, as the image above shows.\n\nArrange nested symbols in extension files\n\nNot all symbols appear on the top-level landing page. For example, classes and structures define methods and properties, and in some cases, nested classes or structures introduce additional levels of hierarchy.\n\nAs with the top-level landing page, DocC generates default topic groups for nested symbols according to their type. Use extension files to override this default organization and provide a more appropriate structure for your symbols.\n\nTo add an extension file to your documentation catalog for a specific symbol, do the following:\n\nIn Xcode, select your documentation catalog in the Project navigator.\n\nChoose File > New > File to open the file template chooser.\n\nSelect the Extension File template in the Documentation section and click Next.\n\nEnter the symbol name as the filename and click Create.\n\nIn the extension file, replace the Symbol placeholder with the absolute path to the symbol. The absolute path is the target’s product module name followed by the symbol name.\n\n# ``SlothCreator/Sloth``\n\n\nThe Extension File template includes a Topics section with a single named group, ready for you to fill out. Alternatively, if your documentation catalog already contains an extension file for a specific symbol, add a Topics section to it by following the steps in the previous section.\n\nAs with the landing page, create named sections for each topic group using a triple hash (###), and add the necessary symbols to each section using the double backtick (``) syntax.\n\n# ``SlothCreator/Sloth``\n\n\n## Topics\n\n\n### Creating a sloth\n\n\n- ``init(name:color:power:)``\n- ``SlothGenerator``\n\n\n### Activities\n\n\n- ``eat(_:quantity:)``\n- ``sleep(in:for:)``\n\n\n### Schedule\n\n\n- ``schedule``\n\n\nTip\n\nUse a symbol’s full path to include it from elsewhere in the documentation hierarchy.\n\nAfter you arrange nested symbols in an extension file, choose Product > Build Documentation to compile your changes and review them in Xcode’s documentation viewer."
  },
  {
    "title": "Distributing documentation to external developers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/distributing-documentation-to-external-developers",
    "html": "Overview\n\nAs soon as you create a project in Xcode, DocC is ready to generate structured documentation for the symbols in your project. Whether you only have documentation comments in your source files, or you craft a full learning experience that includes articles and tutorials, Xcode provides a convenient way to share the documentation in your project with other developers.\n\nTo share your documentation, you create a documentation archive, a self-contained bundle that has everything you need, including:\n\nCompiled documentation from in-source comments, articles, tutorials, and resources\n\nA single-page web app that renders the documentation\n\nDistributing your documentation involves the following steps:\n\nExport your documentation, either from Xcode’s documentation viewer, or by using the xcodebuild command-line tool.\n\nShare your documentation, either directly with Xcode users who open it in the documentation viewer, or by hosting it on a website.\n\nGenerate a publishable archive of your documentation\n\nTo create a documentation archive, you export the documentation from the documentation viewer or use the xcodebuild docbuild command-line tool. Using xcodebuild allows you to integrate with a continuous integration (CI) workflow.\n\nTo export a documentation archive from Xcode’s documentation viewer:\n\nHold the pointer over your compiled documentation catalog in the Workspace Documentation section to display the More button.\n\nClick the More button and choose the Export menu item. Alternatively, invoke the context menu on the documentation catalog item to access the Export menu.\n\nSelect a location for the documentation archive, and click Export.\n\nThe documentation archive that Xcode exports uses a .doccarchive file extension.\n\nTo export the documentation archive from the command line, run xcodebuild docbuild in Terminal and copy the resulting .doccarchive bundle from the derived data directory. Depending on your project’s configuration, you may need to pass additional command-line options. For additional information, consult the xcodebuild man page.\n\nFor example, to build a documentation archive, use a command similar to the following:\n\nxcodebuild docbuild -scheme SlothCreator -derivedDataPath ~/Desktop/SlothCreatorBuild\n\n\nTip\n\nAlthough -derivedDataPath isn’t a required option, including it makes it easier for an automated script to identify the build output and find the resulting .doccarchive bundle.\n\nAs part of the build process, xcodebuild produces many files in the derived data path. One way to locate the documentation archive in the build output is to use the find command. For example, use the following to locate the documentation archive that the xcodebuild command above produces:\n\nfind ~/Desktop/SlothCreatorBuild -type d -name '*.doccarchive`\n\nSend a documentation archive directly to developers\n\nBecause a documentation archive is a self-contained bundle, you can easily share it with other developers. For example, you can send it by email just like a regular document, include it with a binary distribution of your product, or make it downloadable from a website. When the recipient opens the documentation archive, Xcode adds it to the Imported Documentation section of the documentation viewer.\n\nTo remove an imported documentation archive, hold the pointer over the item to display the More button, and then choose Remove.\n\nHost a documentation archive on your website\n\nWhen Xcode exports a documentation archive, it includes a single-page web app in the bundle. This web app renders the documentation content as HTML, letting you host the documentation archive on a web server.\n\nFor reference documentation and articles, the web app uses a URL path that begins with /documentation. For tutorials, the URL path begins with /tutorials. For example, if a project contains a protocol with the name SlothGenerator, the URL to view the SlothGenerator documentation might resemble the following:\n\nhttps://www.example.com/documentation/SlothCreator/SlothGenerator\n\nHost a documentation archive with a file server\n\nYou can host documentation archives you create with Xcode 14.3 and later using a regular file server. By default, the server hosts the documentation at the root of the website, like the SlothCreator example above. To host the documentation at a specific subpath, configure a custom DocC Archive Hosting Base Path before you build the documentation archive.\n\nHost a documentation archive using custom routing\n\nA file server is the recommended solution to host your documentation. But, if you need more control over how the server hosts your content, you can configure the request routing of your web server so it responds to documentation requests with the data and assets within the documentation archive.\n\nNote\n\nThe following sections use Apache as an example. Other web server installations have similar mechanisms. Consult your server’s documentation for details about performing similar configurations.\n\nTo host a documentation archive on your website, do the following:\n\nCopy the documentation archive to the directory that your web server uses to serve files. In this example, the documentation archive is SlothCreator.doccarchive.\n\nAdd a rule on the server to rewrite incoming URLs that begin with /documentation or /tutorial to SlothCreator.doccarchive/index.html.\n\nAdd another rule for incoming requests to support bundled resources in the documentation archive, such as CSS files and image assets.\n\nThe following example .htaccess file defines rules suitable for use with Apache:\n\n# Enable custom routing.\nRewriteEngine On\n\n# Route documentation and tutorial pages.\nRewriteRule ^(documentation|tutorials)\\/.*$ SlothCreator.doccarchive/index.html [L]\n\n# Route files and data for the documentation archive.\n#\n# If the file path doesn't exist in the website's root ...\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\n\n# ... route the request to that file path with the documentation archive.\nRewriteRule .* SlothCreator.doccarchive/$0 [L]\n\n\nWith these rules in place, the web server provides access to the contents of the documentation archive.\n\nAfter configuring your web server to host a documentation archive, keep it up to date by using a continuous integration workflow that builds the documentation archive using xcodebuild docbuild, and copies the resulting .doccarchive to your web server."
  },
  {
    "title": "SlothCreator: Building DocC Documentation in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/slothcreator_building_docc_documentation_in_xcode",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with the WWDC23 session 10244: Create rich documentation with Swift-DocC and WWDC22 sessions 110368: What’s new in Swift-DocC and 110369: Improve the discoverability of your Swift-DocC content. It’s also associated with WWDC21 sessions 10166: Meet DocC documentation in Xcode, 10167: Elevate your DocC documentation in Xcode, 10236: Host and automate your DocC Documentation, and 10235: Build interactive tutorials in DocC.\n\nConfigure the Sample Code Project\n\nTo build documentation for this package, use Xcode 13, open the Package.swift file, and select Product > Build Documentation.\n\nSee Also\nDocumentation\nWriting documentation\nProduce rich and engaging developer documentation for your apps, frameworks, and packages."
  },
  {
    "title": "Adding supplemental content to a documentation catalog | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-supplemental-content-to-a-documentation-catalog",
    "html": "Overview\n\nThe process of crafting great documentation is an art. Your content is unique; you know which elements, beyond source documentation comments, provide the most value to your readers. For information about adding suplemental content to a documentation catalog with DocC, see Adding Supplemental Content to a Documentation Catalog Swift.Org.\n\nAdd articles to explain concepts or describe tasks\n\nIf your documentation catalog includes an article file with the name GettingStarted.md, Xcode displays this article in the documentation viewer with a document icon.\n\nThe structure of an article is similar to symbol files or a top-level landing page, with the exception that the first level 1 header is regular content instead of a symbol reference. For example, the Getting Started with Sloths article contains the following title, single-sentence abstract or summary, and Overview section:\n\n# Getting started with sloths\n\n\nCreate a sloth and assign personality traits and abilities.\n\n\n## Overview\n\n\nSloths are complex creatures that require careful creation and a suitable\nhabitat.\n...\n\n\nAfter the Overview section, additional sections and subsections use a double hash (##) for a level 2 header, and a triple hash (###) for a level 3 header. Follow the hashes with a space, and then the title for that section or subsection.\n\nTo add an article to your documentation catalog in Xcode, do the following:\n\nSelect your documentation catalog in the Project navigator.\n\nChoose File > New > File to open the file template chooser.\n\nSelect the Article File template in the Documentation section and click Next.\n\nEnter a filename and click Create. Xcode creates a new article file with a default name.\n\nModify the first line of the file to specify its title.\n\nReplace the summary and placeholders in the file with appropriate content.\n\nAdd extension files to append to or override source documentation comments\n\nDocC supports supplementing or completely replacing source documentation comments with content in extension files. To add an extension file to your documentation catalog, do the following:\n\nIn Xcode, select your documentation catalog in the Project navigator.\n\nChoose File > New > File to open the file template chooser.\n\nSelect the Extension File template in the Documentation section and click Next.\n\nEnter the symbol name as the filename and click Create.\n\nModify the first line of the file to identify the symbol that the file relates to.\n\nIn the extension file, replace the Symbol placeholder with the absolute path to the symbol. The absolute path is the target’s product module name followed by the symbol name.\n\nSee Also\nDocumentation content\nWriting symbol documentation in your source files\nAdd reference documentation to your symbols that explains how to use them."
  },
  {
    "title": "Optimizing GPU performance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/optimizing-gpu-performance",
    "html": "Overview\n\nApple GPUs run vertex, fragment, and compute tasks in parallel whenever possible. The Metal debugger offers ways to inspect the passes running with overlap, which you can use to find bottlenecking tasks in GPU-bound workloads. In addition, the profiler measures performance statistics by sampling your shaders to reveal hot spots.\n\nIf you notice any performance issues while running your app, you can use the Metal debugger to find and investigate bottlenecks. First, configure your build to include shader source code (see Building your project with embedded shader sources). Then, take a frame capture of your app when you notice the visual artifact that you want to debug (see Capturing a Metal workload in Xcode).\n\nGather performance data\n\nWhen you enable the Profile after Replay option, the Metal debugger automatically begins gathering performance data after replaying the workload. Alternatively, you can click the Profile button on the Summary viewer to gather performance data.\n\nThe performance state of the GPU is important when profiling because it affects how fast the system executes the workload. Factors that affect the performance state include thermals and system settings.\n\nBy default, the Metal debugger profiles the workload with the same GPU performance state at capture time, so the performance is typically similar to what you observe on the device. However, you can induce a specific GPU performance state as you make a profile in the Metal debugger by clicking the GPU Profiler button in the debug bar.\n\nFor more information on GPU performance state, see Discover Metal debugging, profiling, and asset creation tools.\n\nYou can switch between different GPU Execution Modes, including Concurrent and Serial, by clicking the GPU Profiler button in the debug bar. By default, the Metal debugger profiles the workload in Concurrent mode. This allows the GPU to overlap the vertex, fragment, and compute tasks so they can finish as quickly as possible. In Serial mode, the Metal debugger forces each pass to run only after the previous pass finishes, which adds precision to the data report for each pass without overlap, but it doesn’t represent runtime performance.\n\nFind performance bottlenecks with the Performance timeline\n\nThe Performance timeline in the Metal debugger can help you find expensive tasks and performance bottlenecks in the captured workload. Open the Performance timeline by clicking the Performance button in the Debug navigator.\n\nThe Timeline navigator on the left side of the window lists all profiled passes, pipeline states, and GPU Commands with their shader profiler cost.\n\nThe top section has the Vertex, Fragment, and Compute GPU tracks, which display the beginning time and duration of individual passes running with overlap. Below the GPU tracks are the aggregated shader tracks that combine the individual shaders. You can view the timeline of individual shaders in a waterfall-like fashion by expanding the aggregated shader tracks.\n\nThe bottom section has a separate Counters timeline, which includes GPU counters such as Occupancy, Limiter, and Bandwidth. The counters can help you diagnose performance bottlenecks. You can focus on counter subsets by switching between different counter tabs. For more information, see Analyzing Apple GPU performance using a visual timeline.\n\nGet detailed performance metrics for passes and draws\n\nYou can view performance counter statistics from your app’s passes or commands in the GPU trace. Open the Performance counters by clicking the Counters tab above the Performance timeline.\n\nThe Metal debugger derives the shader profiler time by sampling the shaders when running the workload with overlap. In a shader-bound workload, sorting the table by shader profiler time can point you to the overall most expensive pass or draw. In addition, the Metal debugger measures the detailed counters from each pass or command in isolation. You can also choose different sets of counters in the top bar for a more focused view. For more information, see Analyzing Apple GPU performance using counter statistics.\n\nGroup commands by pipeline states in the Debug navigator\n\nFor a different perspective in viewing the Metal commands, click the Outline popup menu in the Debug navigator and select Group by Pipeline State to view a list of pipeline states.\n\nWith profiling data, the Debug navigator displays the percentage of samples from shaders of each pipeline state when running the workload with overlap. In a shader-bound workload, this sorted list of pipeline states is helpful in identifying the most expensive pipeline state. Expanding a pipeline state allows you to find a list of commands that use that state.\n\nYou can also quickly view the shader source code and per-line profiling statistics by selecting a shader from a pipeline state in the list.\n\nFor more information on the Debug navigator, see Analyzing your Metal workload.\n\nOptimize shaders with per-line shader profiling statistics\n\nAfter opening a shader, you can find the time breakdown for the shader in the pipeline state.\n\nThe left sidebar allows you to inspect the shader source files and profiling call tree. With the call tree, you can find performance hot spots by the weights of each frame.\n\nIn the gutter of the shader source code, you can find weights next to the lines of code. The pie chart to the right of each weight contains performance statistics to help you improve the shader code.\n\nFor example, when you observe an expensive line of code with a high percentage for memory sample, it may be taking time to read texture data. To reduce the shader time, if it’s less expensive to compute the value than reading it from a texture, you can modify the code to calculate it in the shader.\n\nAfter making changes to the shader source code, click the Reload Shaders button in the debug bar to refresh the profiling statistics. You can verify whether the changes help with the overall performance by observing the new total GPU time and the tracks in the Performance timeline.\n\nImportant\n\nChanges to your shader source code exist only within the Metal debugger. Your original shader source code doesn’t change. Make sure that you copy your changes to your original shader source code.\n\nFor more information on interpreting the per-line shader profiling statistics, see Inspecting shaders.\n\nSee Also\nEssentials\nCapturing a Metal workload in Xcode\nAnalyze your app’s performance by configuring your project to leverage the Metal debugger.\nCapturing a Metal workload programmatically\nAnalyze your app’s performance by invoking Metal’s frame capture.\nReplaying a GPU trace file\nDebug and profile your app’s performance using a GPU trace file in the Metal debugger.\nInvestigating visual artifacts\nDiscover, diagnose, and fix visual artifacts in your app with the Metal debugger."
  },
  {
    "title": "Investigating visual artifacts | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/investigating-visual-artifacts",
    "html": "Overview\n\nIf you notice any visual artifacts while running your app, you can use the Metal debugger to find and investigate problematic pixels. First, configure your build to include shader source code (see Building your project with embedded shader sources). Then, take a frame capture of your app when you notice the visual artifact that you want to debug (see Capturing a Metal workload in Xcode).\n\nAfter you have a frame capture, use the Debug navigator to find the draw command that contains the visual artifact, and use the Attachments viewer to find the pixel with the issue. Debug the pixel to launch the shader debugger, then step through your shader source code and inspect variable values until you discover the problem. Then, edit the shader source and reload the shader to verify your fix.\n\nSkim through render attachments in the Debug navigator\n\nIn the Metal debugger, navigate to a draw command that has the issue. As you move your pointer over rows in the Debug navigator on the left, the Metal debugger shows a preview of the first attachment. You can use this to quickly find any draw commands that warrant further inspection.\n\nYou also can filter the navigator to show only markers and commands so it’s easier to compare draw commands.\n\nWhen you find the problematic draw command, click it to select it. The Metal debugger automatically shows your attachments in the assistant editor on the right.\n\nInspect attachments for a draw command\n\nUse the Attachments viewer to find any problematic pixels. You can scroll to zoom in, and drag to pan. For more information on the Attachments viewer, see Inspecting the attachments of a draw command.\n\nClick the problematic pixel to select it, and then click the Debug button.\n\nIf the problematic pixel isn’t inside a debuggable region, it has a nongreen selection indicator (as with the blue indicator in the screenshot below). This means that the draw command didn’t write to that pixel and, therefore, you can’t debug it. Because the Attachments viewer remembers your zoom and position, you can quickly step through different draw commands in the Debug navigator to find the right one.\n\nDebug your fragment shader\n\nThe shader debugger displays the shader source in the Shader editor (see Inspecting shaders). The call tree on the left shows each executed line in your shader. The values of the variables appear to the right of each shader line in the shader source code. For example, in the screenshot below, you can see that the in variable has a value containing 721.5, 815.5, and so forth.\n\nStep through your shader source code and inspect variable values until you discover the problem. Make changes to the shader source code, and then click the Reload Shaders button in the debug bar to refresh the variable values, along with the attachments.\n\nIf you still see visual artifacts, continue editing the shader and reloading it as needed until you solve the problem.\n\nImportant\n\nChanges to your shader source code exist only within the Metal debugger. Your original shader source code doesn’t change.\nIf your shader results look correct after reloading the shader, make sure that you copy your changes to your original shader source code.\n\nTo learn more, see Debugging the shaders within a draw command or compute dispatch.\n\nSee Also\nEssentials\nCapturing a Metal workload in Xcode\nAnalyze your app’s performance by configuring your project to leverage the Metal debugger.\nCapturing a Metal workload programmatically\nAnalyze your app’s performance by invoking Metal’s frame capture.\nReplaying a GPU trace file\nDebug and profile your app’s performance using a GPU trace file in the Metal debugger.\nOptimizing GPU performance\nFind and address performance bottlenecks using the Metal debugger."
  },
  {
    "title": "Creating and using custom capture scopes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-and-using-custom-capture-scopes",
    "html": "Overview\n\nWhen you capture a frame using the default capture scope by clicking the Metal Capture button in Xcode’s debug bar, the resulting capture contains all of the data for a single frame. In some cases, you may want to debug a partial frame rather than an entire frame. You can accomplish this by setting up and using a custom capture scope that lets you choose exactly which Metal commands to record.\n\nNote\n\nDon’t allocate custom capture scopes yourself. Instead, call one of the MTLCaptureManager methods: makeCaptureScope(device:) or makeCaptureScope(commandQueue:).\n\nDefine capture boundaries\n\nCall begin() on your capture scope to instruct the Metal debugger to record your app’s subsequent Metal activity. To stop recording a frame and to present the Metal debugger, call end().\n\n// Create myCaptureScope outside of your rendering loop.\nmyCaptureScope.begin()\n\n\nif let commandBuffer = commandQueue.makeCommandBuffer() {\n    // Do Metal work.\n    commandBuffer.commit()\n}\n\n\nmyCaptureScope.end()\n\n\nImportant\n\nCreate capture scopes outside your rendering or compute loop, situating your calls between begin() and end(). For Metal capture to work correctly, you need to hold a strong reference to an active capture scope for the duration of the work that the capture scope contains.\n\nLabel your capture scope\n\nTo identify your custom capture scope when capturing a trace from the Metal Capture popover, set your capture scope’s label property.\n\nmyCaptureScope.label = \"My Capture Scope\"\n\n\nWhen you’re ready to capture a frame, click the Metal Capture button in the debug bar. There, you can find your custom capture scope with the matching label available in the list for capturing.\n\nKeep a strong reference to the capture scope in your code for as long as you want the option to be visible in Xcode.\n\nMake a custom capture scope the default\n\nWhen you perform a capture from Xcode, it defaults to the capture scope that defaultCaptureScope specifies. If the value of this property is nil, Xcode defines the default capture scope using drawable presentation boundaries; for example, using your calls to the methods present(_:) or present().\n\nTo change the default scope, create an MTLCaptureScope instance and assign it to defaultCaptureScope.\n\nMTLCaptureManager.shared().defaultCaptureScope = myCaptureScope\n\nSee Also\nProject preparation for debugging\nBuilding your project with embedded shader sources\nPrepare to debug your project’s shaders by including source code in the build.\nNaming resources and commands\nEnhance the debugging of your Metal app using labels and grouping."
  },
  {
    "title": "Naming resources and commands | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/naming-resources-and-commands",
    "html": "Overview\n\nResource labels and command debug groups are useful when debugging and profiling your app using Metal tools. Assigning meaningful resource labels helps you find your specific resources more quickly. Logically grouping commands lets you easily navigate the workload after capturing it.\n\nNote\n\nThe properties and methods described here don’t affect the graphics-rendering or compute-processing behavior of your app.\n\nAnnotate resources\n\nMany Metal objects provide a label property where you can assign a meaningful string. These labels appear in each Metal tool, allowing you to easily identify specific objects.\n\nIn addition, for MTLBuffer, the addDebugMarker(_:range:) method allows you to mark and identify specific data ranges. You can call the removeAllDebugMarkers() method to clear the existing markers.\n\nAnnotate commands\n\nCommand buffers and command encoders provide the following methods for you to easily identify specific groups of Metal commands in your app:\n\nOn an MTLCommandBuffer object, call pushDebugGroup(_:) and popDebugGroup() to group commands within that buffer.\n\nOn an MTLCommandEncoder object, call pushDebugGroup(_:) and popDebugGroup() to group commands within that encoder. In addition, call insertDebugSignpost(_:) to mark interesting locations in the encoder.\n\nXcode pushes and pops debug groups using unique stacks that exist only within the lifetime of their associated MTLCommandBuffer or MTLCommandEncoder. You can nest debug groups by pushing multiple groups onto the stack before popping previous groups.\n\nUse these methods to simplify your app development process, particularly for tasks that involve many Metal commands per buffer or encoder.\n\nThe following example demonstrates pushing and popping multiple debug groups:\n\nfunc encodeRenderPass(commandBuffer: MTLCommandBuffer, descriptor: MTLRenderPassDescriptor) { \n    guard let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: descriptor) else { return }\n    renderEncoder.label = \"My Render Encoder\"\n    renderEncoder.pushDebugGroup(\"My Render Pass\")\n\n\n        renderEncoder.pushDebugGroup(\"Pipeline Setup\")\n        // Render pipeline commands.\n        renderEncoder.popDebugGroup() // Pops \"Pipeline Setup\".\n\n\n        renderEncoder.pushDebugGroup(\"Vertex Setup\")\n        // Vertex function commands.\n        renderEncoder.popDebugGroup() // Pops \"Vertex Setup\".\n\n\n        renderEncoder.pushDebugGroup(\"Fragment Setup\")\n        // Fragment function commands.\n        renderEncoder.popDebugGroup() // Pops \"Fragment Setup\".\n\n\n        renderEncoder.pushDebugGroup(\"Draw Calls\")\n        // Drawing commands.\n        renderEncoder.popDebugGroup() // Pops \"Draw Calls\".\n\n\n    renderEncoder.popDebugGroup() // Pops \"My Render Pass\".\n    renderEncoder.endEncoding()\n}\n\n\nThe following screenshot shows how the debug groups appear in Xcode’s Debug navigator after you capture a frame:\n\nSee Also\nProject preparation for debugging\nBuilding your project with embedded shader sources\nPrepare to debug your project’s shaders by including source code in the build.\nCreating and using custom capture scopes\nCapture specific GPU commands by using custom capture scopes."
  },
  {
    "title": "Building your project with embedded shader sources | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/building-your-project-with-embedded-shader-sources",
    "html": "Overview\n\nTo debug your shaders in Xcode, configure your build to include shader source code by changing your project’s build settings. Select your project in the Project navigator, click the Build Settings tab, and search for the Produce Debugging Information setting in the Metal Compiler Build Options section. Then, change the setting’s Debug entry to “Yes, include source code.”\n\nAlternatively, you can debug the shaders that you compile for release by generating a separate symbol file for each Metal library in your project. For more information on using this approach, see Generating and Loading a Metal Library Symbol File.\n\nImportant\n\nTo ensure you don’t include debugging information in apps you ship to customers, be sure to reset the Produce Debugging Information for Release option to No when you finish debugging.\n\nSee Also\nProject preparation for debugging\nNaming resources and commands\nEnhance the debugging of your Metal app using labels and grouping.\nCreating and using custom capture scopes\nCapture specific GPU commands by using custom capture scopes."
  },
  {
    "title": "Monitoring your Metal app’s graphics performance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/monitoring-your-metal-apps-graphics-performance",
    "html": "Overview\n\nThe Metal Performance HUD (heads-up display) adds a real-time overlay to your app that displays and, optionally, logs common graphics performance information. The overlay helps you spot subtle performance issues, such as large variations in rendering time, so you can find the perfect scope to capture in Xcode (see Capturing a Metal workload in Xcode) or in Instruments (see Analyzing the performance of your Metal app).\n\nThe GPU and resolution appear at the top of the HUD, along with the display scaling factor, refresh rate, and an indicator for whether the present mode is direct or composited.\n\nThe middle section of the HUD shows three rows of information, each with three columns:\n\nThe first column contains the mean values from the last 1.5 seconds of the frames per second (FPS), the present-to-present interval (Pre), and the GPU time (GPU).\n\nThe second column contains the minimum values from the last 1.5 seconds of FPS, Pre, and GPU.\n\nThe third column contains the maximum values from the last 1.5 seconds of FPS, Pre, and GPU.\n\nWhen minimum and maximum values vary by more than 15% from the average, they appear with a red highligt for easier identification.\n\nThe bottom section of the HUD shows the app’s overall memory footprint, the GPU memory footprint, and a graph of the last 200 frames of the present-to-present interval (Pre) and the GPU time (GPU).\n\nFor more information, see Discover Metal Performance HUD.\n\nEnable the Metal Performance HUD in Xcode\n\nFollow these steps to enable the Metal Performance HUD using the runtime diagnostics options in the scheme settings:\n\nIn the Xcode toolbar, choose Edit Scheme from the Scheme menu. Alternatively, choose Product > Scheme > Edit Scheme.\n\nIn the scheme action panel, select Run.\n\nIn the action setting tab, click Diagnostics.\n\nSelect Show Graphics Overview to enable the Metal Performance HUD, and click Close.\n\nNow, the Metal Performance HUD runtime is enabled each time you run your scheme.\n\nEnable logging in Xcode\n\nYou can also optionally enable the output of per-frame statistics to the console by selecting the Log Graphics Overview option.\n\nNote\n\nYou need to select both the Show Graphics Overview and the Log Graphics Overview options to output per-frame statistics.\n\nThen, as your app is running, once per second (or more frequently at high present rates due to vsync-off or high-refresh and VRR displays), the HUD writes data in the following format to the console:\n\nmetal-HUD: <first-frame-number-integer>,<frame-misses-integer>,<process-memory-usage-float>,<first-frame-present-interval-float>,<first-frame-gpu-time-float>,...<last-frame-present-interval-float>,<last-frame-gpu-time-float>\n\n\nFor example, the HUD wrote the following data to the console while running the Rendering a Scene with Deferred Lighting in Swift sample code project:\n\nEnable the HUD and logging with environment variables\n\nYou can enable the Metal Performance HUD and logging by setting the following environment variables on your Metal app:\n\nMTL_HUD_ENABLED=1\n\nEnables the Metal Performance HUD.\n\nMTL_HUD_LOG_ENABLED=1\n\nEnables logging of per-frame statistics. Requires MTL_HUD_ENABLED=1.\n\nAlternatively, you can enable the HUD and logging programmatically as follows:\n\nAdd MetalHudEnabled to your app’s Info.plist file.\n\nEither set MetalHUDForceEnabled=1 in your app’s UserDefaults, or configure your CAMetalLayer instance’s developerHUDProperties dictionary with the following:\n\nmyMetalLayer.developerHUDProperties = [\n    \"mode\": \"default\",\n    \"logging\": \"default\"\n]\n\nEnable the HUD and logging on a device\n\nYou can enable the Metal Performance HUD and logging on an iOS, iPadOS, or tvOS device in the Developer settings by following these steps:\n\nOpen the Settings app.\n\nSelect Developer.\n\nUnder Graphics HUD, toggle the Show Graphics HUD option to enable the Metal Performance HUD.\n\nToggle the Log Graphics Performance option to enable logging.\n\nThe Metal Performance HUD appears for apps you build and install yourself to your development devices.\n\nNote\n\nYour device needs to have a development provisioning profile for the Developer options to appear in the Settings app.\n\nThe following screenshot shows the options in iOS:\n\nThe following screenshot shows the options in tvOS:\n\nSee Also\nRuntime diagnostics\nInspecting live resources at runtime\nValidate your resources by viewing the contents of your textures and buffers while debugging your Metal app.\nValidating your app’s Metal API usage\nCatch runtime issues in your Metal app using API Validation.\nValidating your app’s Metal shader usage\nCatch common shader runtime issues using Shader Validation while your app is running."
  },
  {
    "title": "Writing symbol documentation in your source files | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/writing-symbol-documentation-in-your-source-files",
    "html": "Overview\n\nTo help the people who use your API have a better understanding of it, follow the steps in the sections below to add documentation comments to the symbols in your project. DocC compiles those comments and generates formatted documentation that you share with your users. For frameworks and packages, add the comments to the public symbols, and for apps, add the comments to both the internal and public symbols.\n\nFor a deeper understanding of how to write symbol documentation, please refer to Writing Symbol Documentation in Your Source Files Swift.org.\n\nAdd a basic description for each symbol\n\nThe first step toward writing great documentation is to add single-sentence abstracts or summaries, and where necessary, Discussion sections, to each of your public symbols.\n\nUse the Code Actions menu in Xcode to generate a template that you fill out. Command-click the symbol in the source editor and choose Add Documentation from the Code Actions menu.\n\nReplace the Description placeholder with a summary for the symbol.\n\nTip\n\nThe Add Documentation action recognizes the type of symbol and generates a template that includes placeholders for all the necessary elements, such as parameters and return values.\n\nAfter you add a summary, Option-click the symbol to review the changes in Xcode’s Quick Help. It displays the text you add directly below the Summary header.\n\nAny paragraphs you add appear below the Discussion header in Xcode’s Quick Help, and in the symbol reference page that DocC generates.\n\nAfter adding a Discussion section, invoke Quick Help to view the updated documentation comment. Alternatively, choose Product > Build Documentation to compile your documentation and open it in the documentation viewer.\n\nDescribe the parameters of a method\n\nFor methods that take parameters, document those parameters directly below the summary, or the Discussion section, if you include one. Describe each parameter in isolation. Discuss its purpose and, where necessary, the range of acceptable values.\n\n/// - Parameters:\n///   - food: The food for the sloth to eat.\n///   - quantity: The quantity of the food for the sloth to eat.\nmutating public func eat(_ food: Food, quantity: Int) throws -> Int {\n\n/// - Parameter food: The food for the sloth to eat.\n/// - Parameter quantity: The quantity of the food for the sloth to eat.\nmutating public func eat(_ food: Food, quantity: Int) throws -> Int {\n\n\nAfter you add documentation for a method’s parameters, it appears in Xcode’s Quick Help, and in the symbol reference page that DocC generates when you choose Product > Build Documentation.\n\nDescribe the return value of a method\n\nFor methods that return a value, include a Returns section in your documentation comment to describe the returned value.\n\n/// - Returns: The sloth's energy level after eating.\nmutating public func eat(_ food: Food, quantity: Int) throws -> Int {\n\n\nYou can see your Returns section in the symbol reference page that DocC generates, as well as in Xcode’s Quick Help.\n\nDescribe the thrown errors of a method\n\nIf a method can throw an error, add a Throws section to your documentation comment. Explain the circumstances that cause the method to throw an error, and list the types of possible errors.\n\n/// - Throws: `SlothError.tooMuchFood` if the quantity is more than 100.\nmutating public func eat(_ food: Food, quantity: Int) throws -> Int {\n\n\nThe Throws section appears in the symbol’s reference page, in the Quick Help pop-over, and in the Quick Help inspector that you can view using Command-Option-3.\n\nSee Also\nDocumentation content\nAdding supplemental content to a documentation catalog\nInclude articles and extension files to extend your source documentation comments or provide supporting conceptual content."
  },
  {
    "title": "Documenting apps, frameworks, and packages | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/documenting-apps-frameworks-and-packages",
    "html": "Overview\n\nDocC, or Documentation Compiler, makes it easy to produce rich and engaging developer documentation for your apps, frameworks, and packages. The compiler builds documentation by combining in-source comments with extension files, articles, and other resources that live alongside your project in Xcode.\n\nThe compiler integrates directly with Xcode to enhance your existing workflow, including code completion, Quick Help, and more.\n\nFor a deeper understanding of DocC and how to use it to document frameworks and packages, please visit the documentation available at Documenting a Swift Framework or Package Swift.org.\n\nBuild simple documentation from source comments\n\nFor DocC to compile your documentation, build your project. Xcode stores supplementary information about public APIs for frameworks, and internal APIs for app targets, alongside the compiled artifacts. DocC consumes that information and compiles the documentation into a DocC Archive. This process repeats for every framework or package your target depends on.\n\nTo build documentation for a project, choose Product > Build Documentation. DocC compiles the documentation and opens it in Xcode’s documentation viewer.\n\nBuild multi-language documentation\n\nDocC takes information from the Swift compiler and the Objective-C compiler and combines it to form a single documentation archive that displays documentation for both languages. For targets that contain both Swift and Objective-C code, DocC automatically builds multi-language documentation. Targets written in a single language but intended to be used by both Swift and Objective-C code can opt in to multi-language documentation output. To enable this, do the following:\n\nIn Xcode, select your project in the Project navigator.\n\nSelect the target in the project editor.\n\nClick the Build Settings tab.\n\nEnter “multi-language documentation” in the search field to locate the\n“Build Multi-Language Documentation for Swift Only Targets” or “Build Multi-Language Documentation for Objective-C Only Targets” setting depending on the language in which you implemented the target.\n\nChoose Yes from the setting’s pop-up button to enable the build setting.\n\nNote\n\nYou can’t use the build setting with a Swift package.\n\nConfigure a richer documentation experience\n\nDocC combines the public API information from the Swift compiler and the Objective-C compiler with the contents of the documentation catalog to generate a much richer DocC Archive.\n\nTo add a documentation catalog to an existing project, follow these steps:\n\nIn Xcode, select your project or package in the Project navigator.\n\nChoose File > New > File to open the file template chooser.\n\nSelect the Documentation Catalog template in the Documentation section and click Next.\n\nEnter a filename and click Create.\n\nIncorporate documentation into your build process\n\nIn addition to building documentation on demand by choosing Product > Build Documentation, you can automatically compile documentation whenever you build a framework by enabling a build setting that DocC provides.\n\nTo enable the documentation compiler build setting, do the following:\n\nIn Xcode, select your project in the Project navigator.\n\nSelect the target in the project editor.\n\nClick the Build Settings tab.\n\nEnter “build documentation” in the search box to locate the Build Documentation during ‘Build’ setting.\n\nChoose Yes from the setting’s pop-up button to enable the build setting.\n\nNote\n\nFor existing projects, the build setting appears only after you add a documentation catalog. You can’t use the build setting with a Swift package.\n\nDocC also integrates with xcodebuild, which means you can build documentation from the command line. This is useful if you want to incorporate documentation builds into a continuous integration process. For more information, see Distributing documentation to external developers."
  },
  {
    "title": "Validating your app’s Metal shader usage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/validating-your-apps-metal-shader-usage",
    "html": "Overview\n\nThe Shader Validation layer detects errors only discoverable during shader execution, like out-of-bounds memory accesses, attempts to access nil textures, and others. It’s similar to Address Sanitizer for general runtime issues (see Diagnosing memory, thread, and crash issues early). You can enable Shader Validation using the runtime diagnostics options in Xcode, or by using environment variables.\n\nImportant\n\nThe Shader Validation layer has a corresponding impact on GPU performance, and shaders may take longer to compile in runtime. This layer adds instrumentation code to all your GPU functions, which increases the number of times they access memory.\n\nFor more information, see Debug GPU-side errors in Metal and Discover Metal debugging, profiling, and asset creation tools.\n\nEnable Shader Validation in Xcode\n\nFollow these steps to enable Shader Validation using the runtime diagnostics options in the scheme settings:\n\nIn the Xcode toolbar, choose Edit Scheme from the Scheme menu. Alternatively, choose Product > Scheme > Edit Scheme.\n\nIn the scheme action panel, select Run.\n\nIn the action setting tab, click Diagnostics.\n\nSelect Shader Validation to enable it, and click Close.\n\nNow, Shader Validation is enabled each time you run your scheme.\n\nIn addition, you can create breakpoints for shader errors by clicking the arrow next to the Shader Validation checkbox.\n\nView Shader Validation errors\n\nAfter enabling Shader Validation, if Metal encounters errors while executing the commands in a command buffer, these details appear in Xcode.\n\nYou can find the breakpoint in the Breakpoint navigator if you want to modify or remove it in the future. For more information, see Setting breakpoints to pause your running app.\n\nIf you discover an error in your shader, consider taking a capture and investigating with the shader debugger (see Investigating visual artifacts).\n\nEnable Shader Validation with environment variables\n\nYou can also enable Shader Validation by setting the following environment variables on your Metal app:\n\nMTL_SHADER_VALIDATION=1\n\nEnables all Shader Validation tests.\n\nMTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING=1\n\nEnables Shader Validation error reporting.\n\nMTL_SHADER_VALIDATION_COMPILER_INLINING\n\nDetermines the amount of code inlining that occurs. Possible values are default and full. Setting the value to full forces inlining. Increasing inlining may result in improved runtime performance at the cost of compile time performance. Decreasing inlining may result in improved compile time performance at the cost of runtime performance.\n\nMTL_SHADER_VALIDATION_FAIL_MODE\n\nSets the behavior for handling invalid accesses. Possible values are zerofill (default) and allow. zerofill causes invalid reads to return 0, and drops any invalid writes. allow allows an invalid read or write, but may result in command buffer failure, depending on the platform. It also reduces compile and runtime performance impact.\n\nMTL_SHADER_VALIDATION_GLOBAL_MEMORY=1\n\nShader Validation checks all global memory accesses. Accessing invalid memory follows the behavior that MTL_SHADER_VALIDATION_FAIL_MODE specifies.\n\nMTL_SHADER_VALIDATION_THREADGROUP_MEMORY=1\n\nShader Validation checks all threadgroup memory accesses. Accessing invalid memory follows the behavior that MTL_SHADER_VALIDATION_FAIL_MODE specifies.\n\nMTL_SHADER_VALIDATION_TEXTURE_USAGE=1\n\nShader Validation checks all texture member functions (such as read, write, get_width). Accessing a nil texture instance follows the behavior that MTL_SHADER_VALIDATION_FAIL_MODE specifies.\n\nMTL_SHADER_VALIDATION_STACK_OVERFLOW=1\n\nShader Validation checks all indirect calls (calls by function pointer, visible functions, intersection functions, and dynamic libraries), as well as recursive calls. If the call stack depth for such functions exceeds the value in maxCallStackDepth for that stage, an error occurs and the system skips the function call.\n\nFor a complete list of settings, run man MetalValidation in Terminal.\n\nIf you discover an error in your shader, consider taking a capture (see Capturing a Metal workload programmatically) and investigating with the Metal debugger (see Debugging the shaders within a draw command or compute dispatch).\n\nSee Also\nRuntime diagnostics\nInspecting live resources at runtime\nValidate your resources by viewing the contents of your textures and buffers while debugging your Metal app.\nValidating your app’s Metal API usage\nCatch runtime issues in your Metal app using API Validation.\nMonitoring your Metal app’s graphics performance\nCatch performance issues using the Metal Performance HUD while your app is running."
  },
  {
    "title": "Finding your Metal app’s GPU occupancy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/finding-your-metal-apps-gpu-occupancy",
    "html": "Overview\n\nA GPU has a maximum number of threads that it can execute at the same time. Occupancy is a measurement of how much of this capacity the GPU is using. GPUs create new threads when they have commands with more threads to dispatch and enough internal resources. It’s generally better to have higher occupancy when the app is making efficient use of the GPU.\n\nCompute occupancy\n\nMeasures the percentage of the GPU’s total thread capacity it’s using to execute compute commands.\n\nVertex occupancy\n\nMeasures the percentage of the GPU’s total thread capacity it’s using to execute vertex threads.\n\nFragment occupancy\n\nMeasures the percentage of the GPU’s total thread capacity it’s using to execute fragment threads.\n\nThe sum of these percentages is the total percentage of the GPU’s capacity in use.\n\nYou can get shader occupancy counters in Instruments and in the Metal debugger’s Performance timeline. For more information, see Analyzing the performance of your Metal app and Analyzing Apple GPU performance using a visual timeline.\n\nDetermine whether your app has low GPU occupancy\n\nYour app may have low occupancy when the overall occupancy measurements aren’t approaching 100%. Each shader has a maximum theoretical occupancy, depending on the amount of internal resources it consumes on the device. You can get this information for each shader in the Performance timeline.\n\nNeither high nor low occupancy is automatically an indicator of a problem. For example, a low vertex shader occupancy may be OK if your fragment shaders are running concurrently with high occupancy. Ultimately, you need to correlate occupancy measurements with measurements from other counters or other Metal tools to determine a problem.\n\nWhen overall occupancy is low, it likely means one of the following is true:\n\nYour shaders have exhausted some internal resources, such as thread, threadgroup, or imageblock memory, preventing the GPU from creating more threads.\n\nYour shaders are simple enough that threads finish executing faster than the GPU can create new ones.\n\nYour app is rendering to a small area inside the render targets, or dispatching very small compute grids, such that the GPU runs out of threads to create.\n\nFor more information on the Performance timeline, see Analyzing Apple GPU performance using a visual timeline.\n\nDetermine the impact on your app\n\nIf you’re seeing overall low occupancy, your next step is to determine whether it’s negatively impacting your app. If an examination of the limiter counters also shows low values, the GPU is executing very little work.\n\nWhen overall occupancy is high, the GPU is executing many threads to hide instruction latency. High occupancy is generally good because you want to use the GPU to its full potential. However, it’s also possible that your shaders aren’t using the GPU efficiently. Optimizing them can make more of the GPU’s capacity available for other GPU commands.\n\nIn rare cases, when overall occupancy is very high, the GPU may execute its workload poorly because threads are competing for space in the GPU’s memory caches (also known as cache thrashing). In that case, you may need to scale back the amount of work you’re sending to the GPU or change how it accesses (reads or writes) memory. For example, you might try the following:\n\nReduce the number of memory accesses.\n\nReduce how much memory you access.\n\nChange the temporal or spatial access patterns you use when accessing memory.\n\nThe memory read or write limiter counters may provide more insight into whether your app has a problem. For more information, see Reducing shader bottlenecks. In addition, use the other counters to determine how effectively you’re using the GPU and where it spends the most time.\n\nSee Also\nCounters\nReducing shader bottlenecks\nIdentify and minimize congestion points in a GPU’s subsystems by checking its limiter and utilization counters.\nMeasuring the GPU’s use of memory bandwidth\nCheck whether your Metal app correctly reads and writes to memory by measuring the GPU’s memory bandwidth."
  },
  {
    "title": "Reducing shader bottlenecks | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reducing-shader-bottlenecks",
    "html": "Overview\n\nA GPU can typically run subtasks at the same time by dispatching them to various subsystems that specialize in different operations, such as memory accesses, math and logic operations, and pixel rasterization. However, the code in an app’s GPU functions (shaders functions and compute kernels) can force some of these subsystems to stall, or wait for either itself to finish an operation or until another subsystem is ready.\n\nThe GPU driver publishes its subsystems’ work time and stall times with counters that you can monitor to see how much time those subsystems spend working versus stalling:\n\nA utilization counter shows how much time the GPU subsystem is doing work, excluding stall time.\n\nA limiter counter shows how much time the GPU spends doing work, including stall time.\n\nUse the following counters as clues to help you identify which GPU subsystems might be a bottleneck at runtime:\n\nCounter\n\n\t\n\nLimiter counter\n\n\t\n\nUtilization counter\n\n\t\n\nDescription\n\n\n\n\nGPU memory read\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nMeasures the percentage of the GPU’s peak memory read performance. See Measuring the GPU’s use of memory bandwidth.\n\n\n\n\nGPU memory write\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nMeasures the percentage of the GPU’s peak memory write performance. See Measuring the GPU’s use of memory bandwidth.\n\n\n\n\nMemory managament unit (MMU)\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends in the memory management unit.\n\n\n\n\nLast level cache\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends on requests to the highest-level GPU cache.\n\n\n\n\nTile memory read\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nTile memory is local to the GPU and is synonymous with threadgroup memory and imageblock memory.\n\n\n\n\nTile memory write\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nTile memory is local to the GPU and is synonymous with threadgroup memory and imageblock memory.\n\n\n\n\nArithmetic logic unit (ALU)\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends on arithmetic, logic, and bitwise operations.\n\n\n\n\nF16\n\n\t\n\nNo\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends on 16-bit floating-point operations.\n\n\n\n\nF32\n\n\t\n\nNo\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends on 32-bit floating-point operations.\n\n\n\n\nTexture sampling\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends on sampling textures.\n\n\n\n\nTexture filtering\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nMeasures the time the GPU spends on running texture-filtering operations.\n\n\n\n\nTexture read cache\n\n\t\n\nYes\n\n\t\n\nNo\n\n\t\n\nMeasures the time the GPU spends in the texture read cache.\n\n\n\n\nTexture write\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends on writing textures.\n\n\n\n\nBuffer read\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends reading data from buffers.\n\n\n\n\nBuffer write\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends writing data to buffers, including any time a GPU function writes to memory in the device address space.\n\n\n\n\nFragment shader input interpolation\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nMeasures the time the GPU spends on interpolating inputs to a fragment shader.\n\nYou can monitor the utilization and limiter counters in Instruments’s Metal system trace and in the Metal debugger’s Performance timeline. For more information, see Analyzing the performance of your Metal app and Analyzing Apple GPU performance using a visual timeline.\n\nTo relieve pressure on specific GPU subsystems and help the GPU run commands more quickly, you can adjust how your GPU functions operate and use resources. Most code adjustments typically belong to several strategies that include the following:\n\nReducing the number of operations\n\nMoving work to another subsystem that’s working less\n\nReducing the image quality or mathematical precision of the work\n\nAccessing memory in ways that improve GPU memory cache hits\n\nSome adjustments have a trade-off, such as reducing image quality or mathematical precision, and it’s up to you to decide which adjustments are worth it for your app.\n\nTip\n\nDiscover which adjustments yield better performance by experimenting with your app.\n\nReduce the workload of the arithmetic logic unit\n\nThe arithmetic logic unit (ALU) handles your code’s arithmetic, logic, and bitwise operations. If the counters indicate the ALU may be a bottleneck, you can try each of the following adjustments and evaluate any changes:\n\nReplace formulas with approximations.\n\nReplace floating-point values with with half-floats if they have enough range and precision for your calculations.\n\nCompile your GPU functions to use the -ffast-math Metal compiler flag, which enables optimizations that run faster, but may introduce precision errors (see section 1.5 in the Metal Shading Language Specification).\n\nReplace complex calculations with lookup tables or textures.\n\nThese adjustments reduce the ALU’s workload by making the work simpler or by shifting work to another subsystem, such as a texture sampler. For example, you might eliminate a noise calculation function by creating a noise texture and sampling from it each time your code needs a value.\n\nReduce the workload for texture operations\n\nThe GPU reads texture data for each color attachment of a render pass when you set its loadAction property to MTLLoadAction.load, and each time a GPU function reads, gathers, or samples a texture. Textures that have larger dimensions, or use larger pixel formats, consume more memory and typically increase the amount of data the GPU reads to sample the texture.\n\nIf the counters indicate the texture sample operations may be a bottleneck, you can try the following adjustments and evaluate any changes in your app’s performance:\n\nSample from a mipmap for any textures your app uses with a minification filter.\n\nSelect bilinear filtering instead of trilinear filtering.\n\nCalculate values that are less expensive to compute within the GPU function than reading from a texture.\n\nWork with textures that have smaller dimensions or use smaller pixel formats.\n\nReplace reading or sampling single-channel textures with gather operations, which use the GPU more efficiently.\n\nSimilarly, the GPU saves texture data for each color attachment of a render pass when you set its storeAction property to MTLStoreAction.store, and each time a GPU function explicitly writes to a texture.\n\nIf the counters indicate the texture write operations may be a bottleneck, you can try the following adjustments and evaluate any changes in your app’s performance:\n\nWork with textures that have smaller dimensions or use smaller pixel formats.\n\nReduce the number of samples for multisample antialiasing (MSAA).\n\nRender fewer very small triangles, especially if you’re applying MSAA as well.\n\nModify textures that cluster writes in space or time (higher spatial or temporal locality), which the GPU can coalesce into fewer write transactions to memory.\n\nReduce the workload for buffer operations\n\nThe write operation counters measure the time your GPU functions store data to memory in the GPU device’s address space. The read operation counters measure the time your GPU functions fetch data from memory in both the device’s address space and the constants’ address space.\n\nGPU functions can increase the read-and-write activity when they use a lot of thread memory or access it with dynamic indexing. This can happen when a function needs to store more data than can fit in the GPU’s registers, which forces the GPU to store data to device memory and then read it at a later time.\n\nIf the counters indicate the buffer read or write operations may be a bottleneck, you can try the following adjustments and evaluate any changes in your app’s performance:\n\nPack data into buffers more tightly.\n\nPack scalar values with SIMD types, such as the float4 SIMD type instead of four separate float values.\n\nUse smaller data types, such as the packed_half3 type for positional data instead of float4.\n\nAvoid implementations that randomly index into thread-scoped arrays, which may give the compiler the flexibility to better optimize the GPU function.\n\nFor the buffer read operations, you can also try to read data from textures instead of buffers to share some of the workload with another subsystem. For the buffer write operations, try to reduce the number of atomic writes your GPU function makes to device memory.\n\nReduce the workload for threadgroup and imageblock operations\n\nApple silicon GPUs use threadgroup memory and imageblock memory (called tile memory collectively) that consists of a local, unified set of high-performance storage within the GPU itself.\n\nYou access this high-speed memory when you write to threadgroup memory in a compute shader, write to a pixel in an imageblock, use blending in a render pass, or write data to a color attachment from a fragment shader.\n\nYour app accesses this high-speed memory during a render pass that applies blending, and when:\n\nA GPU function reads or writes imageblock data\n\nA fragment shader reads from or writes to a color attachment\n\nA compute kernel reads from or writes to threadgroup memory\n\nIf the counters indicate the threadgroup and imageblock read or write operations may be a bottleneck, you can try the following adjustments in your compute kernels and evaluate any changes in your app’s performance:\n\nAlign threadgroup memory allocations to a 16-byte boundary.\n\nReduce a kernel’s atomic reads from or writes to threadgroup memory.\n\nReorder your memory access patterns so that neighboring threads in a quad group write (or read) to neighboring elements in threadgroup memory.\n\nFor the threadgroup and imageblock read operations, you can also try removing accesses to the same memory location from multiple threads in the same threadgroup.\n\nReduce the workload for fragment input interpolation\n\nDuring a render pass, a GPU interpolates the vertex stage’s output data before sending it to the fragment stage. If the counters indicate fragment input interpolation may be a bottleneck, you can try reducing the number of vertex attributes the fragment shader uses.\n\nReduce the workload of the last level cache\n\nThe last level cache counters measure how much time the GPU spends processing requests in the highest-level GPU cache. A higher value here may indicate that your shaders are requesting a lot of data that isn’t present in the cache.\n\nTip\n\nCheck and improve any bottlenecks in the texture and the buffer operations before trying the adjustments below.\n\nIf the counters indicate the last level cache may be a bottleneck, you can try the following adjustments and evaluate any changes in your app’s performance:\n\nReduce the size of the datasets your GPU functions work with.\n\nUse compressed pixel formats for the textures that your GPU functions only read or sample from.\n\nReduce the number of atomic reads from and writes to device memory by storing intermediate results in threadgroup memory and using atomic operations there instead.\n\nAccess memory that clusters reads in space or time (higher spatial or temporal locality), which can reduce cache misses and the subsystem’s workload.\n\nSee Also\nCounters\nFinding your Metal app’s GPU occupancy\nUnderstand the GPU usage for executing shaders by using occupancy.\nMeasuring the GPU’s use of memory bandwidth\nCheck whether your Metal app correctly reads and writes to memory by measuring the GPU’s memory bandwidth."
  },
  {
    "title": "Identifying the cause of common crashes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/identifying-the-cause-of-common-crashes",
    "html": "Overview\n\nYou can identify the causes for many app crashes by looking for specific patterns in the crash report and taking specific diagnostic actions based on what the pattern shows. To recognize patterns, you consult two sections available in every crash report:\n\nThe exception code in the Exception Information section identifies the specific way the app crashed.\n\nThe backtraces show what code the thread was executing at the time of the crash.\n\nSome types of common crashes have a Diagnostic Messages section or a Last Exception Backtrace in the Backtraces section, which further describe the issue. These sections aren’t present in all crash reports. Examining the fields in a crash report describes each section and field in detail.\n\nCompare the examples provided in this article to a crash report you’re investigating. Once you find a match, proceed to the more detailed article about that type of crash.\n\nDetermining whether your crash report contains a pattern for a common issue is the first step in diagnosing a problem. In some cases, the suggested diagnostic actions won’t identify the cause of the issue, requiring a more thorough analysis of the entire crash report. Analyzing a crash report describes how to perform a detailed analysis of a crash report.\n\nImportant\n\nBefore looking for specific patterns, verify that you have a fully symbolicated crash report generated by the operating system. See Determine if a crash report is symbolicated.\n\nDetermine whether the crash is a Swift runtime error\n\nSwift uses memory safety techniques to catch programming errors early. If the Swift runtime encounters a programming error, the runtime catches the error and intentionally crashes the app. These crashes have an identifiable pattern in the crash report. On ARM processors (which include iOS, iPadOS, watchOS, and tvOS devices), the exception info in the crash report looks like:\n\nException Type:  EXC_BREAKPOINT (SIGTRAP)\n...\nTermination Signal: Trace/BPT trap: 5\nTermination Reason: Namespace SIGNAL, Code 0x5\n\n\nOn Intel processors (including apps for macOS, Mac Catalyst, and the simulators for iOS, watchOS, and tvOS), the exception info in the crash report looks like:\n\nException Type:        EXC_BAD_INSTRUCTION (SIGILL)\n...\nException Note:        EXC_CORPSE_NOTIFY\n\n\nTermination Signal:    Illegal instruction: 4\nTermination Reason:    Namespace SIGNAL, Code 0x4\n\n\nAdditionally, the crash report shows the thread that encountered the error, with frame 0 in the backtrace identifying the specific line of code in your app containing the error, such as:\n\nThread 0 Crashed:\n0   MyCoolApp                         0x0000000100a71a88 @objc ViewController.viewDidLoad() (in MyCoolApp) (ViewController.swift:18)\n\n\nAddressing crashes from Swift runtime errors describes how to resolve this type of crash.\n\nLook for signs of a language exception\n\nApple’s system frameworks throw language exceptions when they encounter certain types of programming errors at runtime, such as accessing an array with an index that’s out-of-bounds. To determine whether a crash is due to a language exception, first confirm that the crash report contains this pattern:\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\n\n\nA crash due to a language exception also has a Last Exception Backtrace in the crash report:\n\nLast Exception Backtrace:\n0   CoreFoundation                    0x19aae2a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x19a809fa4 objc_exception_throw + 55\n\n\nIf your crash report contains these patterns, see Addressing language exception crashes for how to address the crash.\n\nCheck for watchdog information\n\nThe operating system employs a watchdog to monitor app responsiveness. If an app is unresponsive, the watchdog terminates it, which creates a crash report with the 0x8badf00d code in the Termination Reason:\n\nException Type:  EXC_CRASH (SIGKILL)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\nTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00d\n\n\nIn the crash report for an unresponsive app, the Termination Description contains information from the watchdog about how the app spent its time. For example:\n\nTermination Description: SPRINGBOARD, \n    scene-create watchdog transgression: application<com.example.MyCoolApp>:667\n    exhausted real (wall clock) time allowance of 19.97 seconds \n    | ProcessVisibility: Foreground \n    | ProcessState: Running \n    | WatchdogEvent: scene-create \n    | WatchdogVisibility: Foreground \n    | WatchdogCPUStatistics: ( \n    |  \"Elapsed total CPU time (seconds): 15.290 (user 15.290, system 0.000), 28% CPU\", \n    |  \"Elapsed application CPU time (seconds): 0.367, 1% CPU\" \n    | )\n\n\nNote\n\nFor readability, extra line breaks are in this example. In the original crash report file for this example, the watchdog information is on fewer lines.\n\nSee Addressing watchdog terminations to diagnose why your app is unresponsive.\n\nDetermine whether the crash report contains signs of a zombie\n\nZombie objects are objects that are messaged by the Objective-C runtime after they’re deallocated from memory and no longer exist. Messaging a deallocated object can cause a crash in the objc_msgSend, objc_retain, or objc_release functions of the Objective-C runtime, such as this example with objc_msgSend:\n\nThread 0 Crashed:\n0   libobjc.A.dylib                   0x00000001a186d190 objc_msgSend + 16\n1   Foundation                        0x00000001a1f31238 __NSThreadPerformPerform + 232\n2   CoreFoundation                    0x00000001a1ac67e0 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24\n\n\nA different pattern that also indicates a zombie object is the presence of a Last Exception Backtrace with a stack frame containing the doesNotRecognizeSelector(_:) method:\n\nLast Exception Backtrace:\n0   CoreFoundation                    0x1bf596a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x1bf2bdfa4 objc_exception_throw + 55\n2   CoreFoundation                    0x1bf49a5a8 -[NSObject+ 193960 (NSObject) doesNotRecognizeSelector:] + 139\n\n\nIf your crash report shows your app has a zombie, see Investigating crashes for zombie objects.\n\nDetermine whether there’s a memory access issue\n\nWhen your app uses memory in an unexpected way, you’ll receive a crash report about a memory access issue. These types of crash reports have a EXC_BAD_ACCESS exception type, plus additional information in the VM Region Info field. For example:\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000\nVM Region Info: 0 is not in any region.  Bytes before following region: 4307009536\n\n\n      REGION TYPE                      START - END             [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->\n      __TEXT                 0000000100b7c000-0000000100b84000 [   32K] r-x/r-x SM=COW  ...pp/MyGreatApp\n\n\nInvestigating memory access crashes contains information on the different types of memory access issues and how to investigate them.\n\nDetermine whether a framework is missing\n\nIf an app crashes because it’s missing a required framework, the crash report contains the EXC_CRASH (SIGABRT) exception code. You’ll also find a Termination Description in the crash report, identifying the specific framework that the dynamic linker, dyld, couldn’t locate. Here’s an example, with extra line breaks included for readability:\n\nException Type: EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note: EXC_CORPSE_NOTIFY\nTermination Description: DYLD, dependent dylib '@rpath/MyFramework.framework/MyFramework'\n    not found for '<path>/MyCoolApp.app/MyCoolApp', tried but didn't find: \n    '/usr/lib/swift/MyFramework.framework/MyFramework' \n    '<path>/MyCoolApp.app/Frameworks/MyFramework.framework/MyFramework' \n    '@rpath/MyFramework.framework/MyFramework' \n    '/System/Library/Frameworks/MyFramework.framework/MyFramework'\n\n\nImportant\n\nThe exact content of this message depends on the specific operating system and operating system version. In all cases, the message makes it clear that an expected framework wasn’t found.\n\nAddressing missing framework crashes discusses how to resolve this issue.\n\nTopics\nRuntime errors\nAddressing crashes from Swift runtime errors\nIdentify the signs of a Swift runtime error, and address the crashes runtime errors cause.\nAddressing language exception crashes\nIdentify the signs of a language exception, and address the crashes caused by uncaught language exceptions.\nReading an exception message\nUnderstand and address the common reasons apps crash.\nSystem terminations\nAddressing watchdog terminations\nIdentify the signature of an unresponsive app terminated by the watchdog, and address the issue.\nMemory access errors\nInvestigating crashes for zombie objects\nIdentify the signature of a zombie and investigate the cause of the crash.\nInvestigating memory access crashes\nIdentify crashes that arise from memory access issues, and investigate the cause of the crash.\nApp configuration errors\nAddressing missing framework crashes\nIdentify missing frameworks from a crash report, and adjust your app’s build to correctly include the framework.\nSee Also\nCrash reports\nAdding identifiable symbol names to a crash report\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nExamining the fields in a crash report\nUnderstand the structure of a crash report and the information each field contains.\nInterpreting the JSON format of a crash report\nUnderstand the structure and properties of the objects the system includes in the JSON of a crash report.\nUnderstanding the exception types in a crash report\nLearn what the exception type tells you about why your app crashed."
  },
  {
    "title": "Connecting Xcode Cloud to Slack | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/connecting-xcode-cloud-to-slack",
    "html": "Overview\n\nMany teams use Slack to collaborate and expect other tools to support and integrate with Slack. And because collaboration is an important part of using Xcode Cloud, you can easily connect it to Slack and receive its notifications in your team’s Slack workspace.\n\nBy connecting Xcode Cloud to Slack, you can:\n\nReceive Xcode Cloud notifications in Slack that contain a build’s status and links to the build report.\n\nConfigure Xcode Cloud to send notifications to you as direct messages, or choose a Slack channel for team-level notifications.\n\nUse different Slack channels for different workflows.\n\nUse Xcode or App Store Connect to connect Xcode Cloud to a single Slack workspace.\n\nNote\n\nDepending on your team’s Slack workspace settings, you may need to ask your team’s Slack administrator to connect Xcode Cloud to Slack. For more information, see Install the Slack app for Xcode Cloud using App Store Connect.\n\nInstall the Slack app for Xcode Cloud using Xcode\n\nTo connect Xcode Cloud to Slack, you’ll need to install the Slack app Apple provides into your Slack workspace. The app manages access to your team’s Slack workspace.\n\nTo install the Slack app using Xcode:\n\nChoose Integrate > Manage Workflows, or Product > Xcode Cloud > Manage Workflows in Xcode 14, to open the Manage Workflows sheet.\n\nDouble-click a workflow to open.\n\nClick the Add button (+) next to Post-Actions and choose Notify to add a post-action for sending notifications.\n\nClick the Add button in the Slack section of the post-action you added.\n\nProvide the name of your Slack workspace, then click Connect. This opens your team’s Slack workspace in your browser.\n\nLog in to your Slack workspace if you aren’t logged in already, and then review the permissions that the Slack app for Xcode Cloud requests.\n\nClick Allow to install the app into your Slack workspace. This takes you to Xcode where you can now configure the Notify post-action to send build notifications to your team’s Slack channels as described in Choose a Slack channel.\n\nTip\n\nConfigure Xcode Cloud to send build notifications to yourself as direct messages (DMs) in Slack. Navigate to your account in App Store Connect, select the Xcode Cloud tab, choose Notifications in the sidebar, and select the checkbox next to Slack.\n\nInstall the Slack app for Xcode Cloud using App Store Connect\n\nAnother way to configure Xcode Cloud to send notifications to Slack is by setting up that connection in App Store Connect. It’s especially convenient if you need to work with your team’s Slack administrator to connect Xcode Cloud to Slack, because they don’t need to be familiar with Xcode.\n\nIf you work with your team’s Slack administrator, add them to your Apple Development team, and assign them one of the following roles: App Manager, Admin, or Account Holder. With the proper role set in App Store Connect, they can connect Xcode Cloud to Slack.\n\nTo connect Xcode Cloud to your team’s Slack workspace in App Store Connect:\n\nNavigate to your app’s page in App Store Connect and select the Xcode Cloud tab.\n\nChoose Manage Workflows in the sidebar and open a workflow by clicking its name.\n\nClick the Add button next to Post-Actions and choose Notify to add a post-action for sending notifications.\n\nClick Edit in the Slack section of the post-action you added.\n\nEnter the name of your team’s Slack workspace, then click Connect. This opens your team’s Slack workspace.\n\nLog in to your Slack workspace if you aren’t logged in already, and then review the permissions that the Slack for Xcode Cloud requests.\n\nClick Allow to install the app into your Slack workspace. This takes you back to your workflow in App Store Connect where you can now configure the Notify post-action to send build notifications to your team’s Slack channels.\n\nYou can also connect Xcode Cloud to Slack by clicking on your account in the top-right corner of the App Store Connect website and choosing Edit Profile. In your profile settings, select the Xcode Cloud tab, then click Connect next to Slack and install the Xcode Cloud app into your Slack workspace.\n\nGrant Xcode Cloud access to your Slack account\n\nIf you personally connected Xcode Cloud to Slack, you can configure Xcode Cloud to send build status notifications to your team’s Slack channels. You can also choose to receive build status notifications as direct messages. However, someone else may have connected Xcode Cloud to Slack; for example, the administrator of your team’s Slack workspace. In this case, you’ll receive build status notifications in Slack channels that your team member configured, but you need to authorize Xcode Cloud to use your Slack account before you can make changes to a workflow’s Notify post-action.\n\nTo authorize Xcode Cloud to access your Slack account:\n\nOpen a workflow in Xcode or App Store Connect.\n\nNavigate to the Notify post-action.\n\nFollow the guidance by Xcode or App Store Connect to grand Xcode Cloud access to your Slack account.\n\nAfter authorizing Xcode Cloud to access your Slack account, you can make changes to your workflow’s Notify post-action and configure personal build notifications for Slack.\n\nChoose a Slack channel\n\nDepending on your project, you can direct all Xcode Cloud notifications to the same Slack channel or to set up different Slack channels to receive the notifications. For example, use a single Slack channel for all Xcode Cloud notifications if you’re a solo developer or your team only works on one app. In contrast, large teams may use one Slack channel per app, or use different Slack channels for builds from pull requests, for workflows that distribute nightly builds, and so on.\n\nTo configure a workflow to send a build notification to a Slack channel:\n\nOpen a workflow in Xcode or App Store Connect.\n\nAdd a post-action by clicking the Add button and choosing Notify, or choose an existing Notify post-action.\n\nClick the Add button in the post-action’s Slack section.\n\nChoose a channel in the popover and click OK. If you’re a member of many Slack channels, filter the channels to find the one you’re looking for.\n\nConfigure any notification settings; for example, choose to only receive notifications for build failures, then save your changes.\n\nNote\n\nIf you configure Xcode Cloud to send build status notifications to a private Slack channel, Xcode Cloud redacts its name for team members who aren’t members of the private channel.\n\nSee Also\nNotifications\nConfiguring webhooks in Xcode Cloud\nConfigure webhooks that connect Xcode Cloud to other services and tools."
  },
  {
    "title": "Improving your app’s performance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/improving-your-app-s-performance",
    "html": "Overview\n\nPeople using your app expect it to perform well. An app that takes a long time to launch, or responds slowly to input, may appear as if it isn’t working or is sluggish. An app that makes a lot of large network requests may increase the user’s data charges and drain the device battery. Any of these behaviors can frustrate users and lead them to uninstall the app.\n\nPlan and implement performance improvements by approaching the problem scientifically:\n\nGather information about the problems your users are experiencing.\n\nMeasure your app’s behavior to find the causes of the problems.\n\nPlan one change to improve the situation.\n\nImplement the change.\n\nObserve whether the app’s performance improves.\n\nThese activities form a cycle of continuous improvement, as the following illustration shows:\n\nMinimizing resource use benefits your users and improves their perceptions of your app. Here are some specific benefits:\n\nDecreasing app launch time improves the user experience, and reduces the chances of the iOS watchdog timer terminating the app.\n\nDecreasing overall memory use reduces the likelihood of iOS freeing your app’s memory in the background, and improves responsiveness when a user switches back to your app.\n\nReducing disk writes speeds up your app’s overall performance, makes it more responsive, and reduces wear on users’ device storage.\n\nDecreasing hang rate and hang duration improves your users’ perception of your app’s performance and responsiveness.\n\nReducing battery consumption and the use of power-hungry device features makes your app more reliable, and helps ensure that the rest of the user’s device is available when needed.\n\nEven when your measurements and observations show no pressing performance problems, it’s a good idea to run through the performance-improvement cycle and do preventive work to keep your app’s performance from regressing.\n\nGather data about your app’s current performance\n\nTo thoroughly understand your app’s performance, combine information from multiple sources:\n\nUse the Xcode Organizer to view metrics for launch time, user-interface responsiveness, writes to storage, memory use, and energy use, as well as diagnostic reports for disk writes, crashes, and energy. The Organizer lets you break down measurements by device model, app version, and user percentile. For more information, see Analyzing the performance of your shipping app.\n\nUse MetricKit to gather metrics and record them in your own tools. These metrics are in the form of histograms that record the frequency of observed values over a day. MetricKit goes beyond the metrics in the Metrics organizer to include average pixel luminance, cellular network conditions, and durations associated with custom OSSignpost events in your app.\n\nGet feedback from TestFlight testers about their experiences with beta versions of your app. Fill out the Test Information page for your beta version, and request that testers provide feedback about the performance of your app. Include an email address so that testers can report their findings.\n\nInvestigate feedback from your users about their experiences with released versions of your app. Invite users to send their feedback through email or a dedicated interface within your app. Ask them about their experiences using the app — both what works well and any problems they encounter.\n\nDetermine the most important aspect to improve\n\nUse the information from your observations and your understanding of your app’s purpose and expected use patterns to spot the greatest opportunities for improvement. Some performance issues are independent of the type of app under investigation. An app that takes a long time to launch, or is unresponsive to users’ attempts to manipulate the interface, results in users feeling they have no control over the app.\n\nThe largest value for a metric you see in the Metrics organizer or in MetricKit may not indicate the most important issue to address if that value represents expected app usage. For example, energy use associated with background-audio playing is probably not a problem for a podcast player, which users expect to play in the background. However, it would be surprising to see that metric dominate if your app is a game that has no background component to its gameplay.\n\nSeeing that value dominate the metric reports can indicate that efficiency savings are possible, but the most impactful changes may be in the use of auxiliary services that don’t impact the app’s main features. The podcast player might infrequently need to use coarse-grained location services to recommend local-interest podcasts to the listener, but the high-energy consumption associated with the frequent tracking of the user’s precise location may be a sign that a change is necessary.\n\nProfile your app\n\nUse Instruments to profile your app with a profiling template that’s relevant to the metric you’re considering:\n\nUnresponsiveness and hangs: Use the Time Profiler template.\n\nMemory issues: Use the Allocations and Leaks templates.\n\nPower-consumption issues: Use the Energy Log template.\n\nI/O issues: Use the File Activity template.\n\nNetwork-related issues: Use the Network template.\n\nYou get higher-fidelity measurements by profiling on a device instead of the simulator. If the information you gather shows that your app performs poorly on a particular class or model of device, profile on that device.\n\nFind the code that’s causing the performance problem, and create a plan for improving it. Keep in mind that your change may not be localized to a particular line or even function, and you may need to make significant architectural changes to your app. For example, to mitigate a hang that results from synchronously downloading network resources, introduce background operations to handle the networking (see Downloading files in the background), and perform a UI update on the main thread when the downloads are complete.\n\nMake the next change\n\nImplement the change you plan as a result of your investigation. Create an after profile in Instruments that you can compare with the before profile to ensure your change results in an improvement. Consider writing a performance test in XCTest to protect against future regressions in performance, and to serve as a record that the problem existed and you fixed it.\n\nCompare the changed behavior with your original data\n\nAfter you change your app to address the most important performance issue you observe, confirm that the change has the desired effect and that the level of improvement is sufficient. Use the graphs of performance metrics for each version of your app in Xcode’s Metrics organizer to see whether the change results in an improvement or a regression.\n\nFinally, decide whether the metric you’re working on is still the most important to address, or whether the data points to another metric for the next iteration of the performance improvement cycle.\n\nAdditional resources\n\nThe following articles, Xcode Help topics, and WWDC session videos contain more information about using Xcode and Instruments for measuring and improving app performance:\n\nPerformance tools and techniques\n\nDiagnose Performance Issues With the Xcode Organizer\n\nEliminate Animation Hitches With XCTest\n\nInstruments Help\n\nLogging\n\nPerformance on iOS and watchOS\n\nPractical Approaches to Great App Performance\n\nProfile your app’s performance\n\nVisual Debugging with Xcode\n\nWhat’s New in MetricKit\n\nWriting and running performance tests\n\nEnergy consumption\n\nAchieving All-day Battery Life\n\nDebugging Energy Issues\n\nEnergy Efficiency and the User Experience\n\nEnergy Efficiency Guide for iOS Apps\n\nEnergy Efficiency Guide for Mac Apps\n\nIdentify Trends With the Power and Performance API\n\nMonitor a running app using debug gauges\n\nMonitor your app’s energy usage\n\nProfile your app’s energy use\n\nWhat’s New in Energy Debugging\n\nWriting Energy Efficient Apps\n\nXcode Energy Organizer\n\nTopics\nMemory\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nApp launch time\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nDisk writes\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage.\nSee Also\nRelated Documentation\nCreating Custom Modelers for Intelligent Instruments\nCreate Custom Modelers with the CLIPS language and learn how the embedded rules engine works.\nEssentials\nAnalyzing the performance of your shipping app\nView power and performance metrics for apps you distribute through the App Store."
  },
  {
    "title": "Setting breakpoints to pause your running app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/setting-breakpoints-to-pause-your-running-app",
    "html": "Overview\n\nWhen you identify a place in your source code where you want to investigate a bug, set a breakpoint to pause the debugger so you can inspect your variables and step through your code to isolate the bug.\n\nTo locate crashes or other bugs where it is difficult to know where to set a breakpoint, use symbolic or issue breakpoints to pause on specific problem conditions and quickly identify where a bug occurs.\n\nFor bugs that occur after several iterations or only under certain circumstances, specify conditions on your breakpoint. If you want to log information at specific points in your app or receive notifications when a line of code executes, use breakpoint actions.\n\nSpecify where to pause your app\n\nNavigate to a line in your code where you want execution to pause, then click the gutter or line number in the source editor to set a breakpoint. Xcode displays a breakpoint icon to indicate the location.\n\nDrag a breakpoint up or down to move it to another location; drag it away from the gutter to remove it. Click the breakpoint icon in the debug area toolbar to activate or deactivate all breakpoints.\n\nManage breakpoints across your app\n\nWhen you have many breakpoints set across several source code files, click the Breakpoint Navigator button in the navigator area of the main window to open the Breakpoint navigator to view and manage all breakpoints.\n\nClick a breakpoint label in the Breakpoint navigator to quickly navigate to the breakpoint in the source editor. Pressing the Delete key after selecting a breakpoint label deletes the breakpoint from your code. Click a breakpoint icon in the Breakpoint navigator to enable or disable it.\n\nTo easily find a frequently used breakpoint in the navigator, Control-click the breakpoint label, choose Edit Breakpoint, and enter a name for it. Then use the filter at the bottom of the Breakpoint navigator.\n\nYou can also use the filter to find breakpoints by symbols in the line of code for the breakpoint. The filter tools provide options for showing only modified breakpoints and showing only enabled breakpoints.\n\nSpecify conditions for pausing your app\n\nFor bugs that occur after a certain number of iterations, or under limited conditions that require repetitive actions, it’s cumbersome to pause at the breakpoint and press the Continue button repeatedly until the bug occurs. There are two approaches to handle this type of situation more efficiently in the debugger.\n\nFor a bug that occurs after a certain number of iterations, set the debugger to ignore the breakpoint for some iterations. Control-click the breakpoint, choose Edit Breakpoint, and specify the number of times to ignore the breakpoint before stopping.\n\nFor a bug that occurs under limited conditions, set the debugger to pause on a breakpoint when an expression is true. Control-click the breakpoint, choose Edit Breakpoint, and enter a condition using variables available in the local scope.\n\nThe debugger evaluates the expression each time it reaches the breakpoint in execution, and pauses only if the expression is true.\n\nPause on a symbol outside your code\n\nTo debug some issues, you need to pause on a symbol that your source code doesn’t define. For example, when you encounter an Auto Layout issue, the error message recommends setting a breakpoint on UIViewAlertForUnsatisfiableConstraints. To do that, use a symbolic breakpoint.\n\nIn the Breakpoint navigator, click the Add button (+) in the lower-left corner, and choose Symbolic Breakpoint. Enter the object and symbol in the Symbol field, using the format of the example text.\n\nThe debugger pauses when the app or your code calls the symbol you specify. The example symbol UIViewAlertForUnsatisfiableConstraints typically pauses in the application’s main method and not on a line in your code. When this happens, use the console to view an Auto Layout trace with po [[UIWindow keyWindow] _autolayoutTrace].\n\nTip\n\nSome symbols receive calls very frequently and pausing on each can be unmanageable. Add a condition to the breakpoint to reduce the frequency of calls, or disable the symbolic breakpoint until you reach a breakpoint in your code where you want to start diagnosing the issue, and then enable the symbolic breakpoint.\n\nPause on an uncaught Swift error or Objective-C exception\n\nWhen your app encounters an unhandled Swift Error or Objective-C exception, it crashes. Frequently, the stack trace doesn’t point directly to where the problem occurs. Set a breakpoint to pause on an uncaught Swift Error or Objective-C exception so you can locate the problem.\n\nWhen an unhandled Swift error causes a crash, the debugger shows a fatal error on the line with the try! and not where the error originally occurs.\n\nIf the thrown error has a helpful error message, that may be enough information to resolve the problem. If not, add a Swift error breakpoint to pause on the line that throws the error. In the Breakpoint navigator, click the Add button (+) in the lower-left corner, and choose Swift Error Breakpoint. The app then pauses on the thrown error instead of the try!.\n\nWhen an uncaught Objective-C error causes a crash, the debugger shows the crash in the AppDelegate or main method.\n\nAdd an Objective-C exception breakpoint to pause on the line where the crash occurs instead of main. In the Breakpoint navigator, click the Add button (+) in the lower-left corner, and choose Exception Breakpoint.\n\nFor more information, see Identifying the cause of common crashes.\n\nPause automatically when the system detects a runtime issue\n\nXcode has tools called sanitizers to detect several different types of runtime issues: updating the user interface outside the main thread, updating variables from different threads unsafely, accessing addresses unsafely, and executing code that results in undefined behavior. Configure your scheme to enable sanitizers to detect these issues with static analysis at build time. When you disable the sanitizers and your app encounters one of these issues, your app crashes and Xcode may not clearly identify where the issue occurs.\n\nTo pause your app and investigate, click the Add button (+) in the lower-left corner of the Breakpoint navigator, choose Runtime Issue Breakpoint, and select the type of runtime issue for the breakpoint.\n\nEnable the sanitizer for the issue and run your app. The sanitizer identifies lines of code where it expects runtime issues to occur. When the app pauses at your runtime breakpoint, investigate why the issue occurs. For more information, see Diagnosing memory, thread, and crash issues early.\n\nLog variable values, run scripts, or play sounds at a breakpoint\n\nInstead of writing code to log variable values and details about your app’s execution, use breakpoint actions to log messages and to perform debugger commands that print variable values to the console.\n\nBreakpoint actions can also play sounds when the debugger reaches a breakpoint, which is useful for knowing when code executes without pausing. Breakpoint actions can execute AppleScripts or shell scripts to perform helpful debugging tasks like taking a screenshot or saving some app data for analysis.\n\nTo perform an action with a breakpoint, Control-click the breakpoint, either in the source editor or in the Breakpoint navigator, choose Edit Breakpoint, click Add Action, choose an action and provide any additional information necessary. For example, provide a message for the Log Message action, or a command and parameters for the Debugger Command action.\n\nTo perform more than one action at a breakpoint, click the Add button (+) to the right of an existing action to add another action. To continue executing your app without pausing after performing your action, select the “Automatically continue after evaluating actions” option.\n\nSee Also\nBreakpoints and variables\nStepping through code and inspecting variables to isolate bugs\nFind the cause of your bugs by watching variables change as you step through your source code in the debugger."
  },
  {
    "title": "Stepping through code and inspecting variables to isolate bugs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/stepping-through-code-and-inspecting-variables-to-isolate-bugs",
    "html": "Overview\n\nIf the root cause of a bug isn’t immediately obvious when inspecting your source code, watching your variables change as you step through the code helps you isolate where the bug is occurring so you can investigate the possible cause for it.\n\nThe Xcode debugger provides several methods to step through your code and inspect variables. You can precisely control execution of your code from a breakpoint, stepping into and out of called functions as necessary to determine where your bug occurs. You can monitor variables while stepping through code, or pause execution to inspect them more closely.\n\nStart your investigation at a breakpoint when your app is in a known good state before the bug occurs, at a point where you think the bug may be about to happen.\n\nStep through code in the debugger\n\nWhen you run your app, the debugger pauses at the first breakpoint it encounters, and, by default, updates the display to show the Debug navigator, the source editor, the debug bar, the variable viewer, and the console.\n\nCustomize what Xcode displays when running your app in the debugger by choosing Xcode > Preferences > Behaviors > Running.\n\nUse the buttons in the debug bar to control the execution of your app.\n\nContinue normal execution from the paused position until the app stops at the next breakpoint with the Continue button.\n\nPause the app without setting a breakpoint using the Pause button. The Continue button changes to the Pause button when the app is running.\n\nExecute the next instruction in the same function with the Step Over button.\n\nExecute the next instruction using the Step Into button. If the next instruction is inside another method or function, the debugger jumps to that function and continues executing it each time you click the Step Into button.\n\nClick the Step Out button to skip the rest of the function and return to the next instruction in the calling function or method after using Step Into.\n\nAs you step through your app, inspect variables relevant to your bug and watch for unexpected values.\n\nSee variable values in code and the variable viewer\n\nWhen your app pauses at a breakpoint, hover over a variable in your source code to view its current value. If the variable is an image or other type that isn’t expressible as text, click the Quick Look button at the upper-right to see a preview of the variable. Click the Print Description button to print a description of the object in the console.\n\nThe variable viewer lists the variables available in the current execution context. Select the scope of variables to view from the selector at the bottom left of the viewer: automatic, local, or all variables, registers, globals, and statics. Use the filter field to find variables matching a pattern.\n\nEach variable shows a brief summary of the variable’s type, value, and pointer location, if applicable. The variable viewer generates the summary it shows with the lldb command frame variable. If the summary for a variable isn’t available or only shows a memory pointer, see the Evaluate expressions in the console section below for more ways to inspect the variable.\n\nClick the disclosure triangles to explore instance variables for classes and structures, or internals for other data types. Select a variable and click the Quick Look button to see a preview of the variable, click the Print Description button to print a description of the object in the console.\n\nSee the call stack and navigate related code\n\nWhen the debugger pauses at a breakpoint, it shows the current active threads and the current call stack in the Debug navigator, and highlights the breakpoint. The call stack represents the relationships of function or method calls that result in the current breakpoint.\n\nSelect a line in the call stack if you suspect that your bug is in a calling function. The calling function might change an instance variable incorrectly, or may be passing an incorrect value in a parameter. The debugger shows the source code for that point and the related variables in the variable viewer, if the source code is available in the project. Otherwise, the debugger shows the assembly code for the selected line. Inspect the variables at this point for unexpected values.\n\nSelect a thread to expand or collapse the view of the call stack for that thread. Select a line in the call stack for the thread to see the source and variables.\n\nEvaluate expressions in the console\n\nTo see more information than the summary of a variable shows in the variables viewer, or to change the value of a variable in the middle of a debugging session, use the console to interact with the debugger directly.\n\nPrint the value of a variable in the current stack frame using frame variable, or the shortened alias v.\n\n(lldb) v self.fruitList.title\n(String) self.fruitList.title = \"Healthy Fruit”\n(lldb) v self.listData[0]\n(String) [0] = “Banana\"\n\n\nThe frame variable command returns only what is currently in memory and doesn’t evaluate expressions, so it returns an error if you attempt to print something more. For example, it won’t print a function or method call, an @Published variable, or a calculated variable.\n\n(lldb) v fruitList.fruit(at: indexPath)\nerror: no variable named 'fruitList' found in this frame\nerror: no variable named 'indexPath)' found in this frame\n(lldb) v self.fruitList.calculatedFruitCount\nerror: \"calculatedFruitCount\" is not a member of \"(Debugger_Demo.FruitList) self.fruitList”\n\n\nEvaluate an expression and print the result in the console with the expression command, or the aliases expr or p.\n\n(lldb) p self.fruitList.calculatedFruitCount\n(Int) $R18 = 9\n(lldb) p fruitList.fruit(at: indexPath)\n(Debugger_Demo.FruitItem) $R20 = 0x00006000013dcc90 (fruitName = \"Strawberry\", fruitDescription = \"Small red berry with seeds on the outside.”)\n(lldb) expr fruit.fruitName\n(String) $R14 = \"Strawberry\"\n(lldb) p fruit.fruitName == \"Peach\"\n(Bool) $R16 = false\n\n\nThe p command compiles code to evaluate the expression, so it handles function calls and calculated variables. Use the references that p provides as parts of other expressions.\n\n(lldb) p fruit.fruitName\n(String) $R2 = \"Banana\"\n(lldb) p fruit.fruitName\n(String) $R6 = \"Strawberry\"\n(lldb) p $R2 + \", \" + $R6\n(String) $R8 = \"Banana, Strawberry\"\n\n\nFor some classes, using p may display only a memory pointer location, or may show a fully expanded view of all the attributes of the class, which can be a lot of unnecessary information. In those cases, use po, an alias for expression —object-description. This version also compiles code to evaluate the expression, but it prints an object description for the result, which you can customize for your objects.\n\n(lldb) po cell\n<Debugger_Demo.ListTableViewCell: 0x7fca3450e520; baseClass = UITableViewCell; frame = (0 28; 414 43.5); clipsToBounds = YES; layer = <CALayer: 0x600001d3ed40>>\n(lldb) po fruitList\nYummy Fruit: 9 items starting with Banana\n\n\nTip\n\nCustomize what the debugger shows for your objects by adding a debug description. In Swift, implement the CustomDebugStringProtocol for your object. For Objective-C objects that extend NSObject, override debugDescription.\n\nChange the value of a variable in memory while you are debugging with either p or po.\n\n(lldb) po fruitList.title = \"Tasty Fruit\"\n0 elements\n\n\n(lldb) po fruitList\nTasty Fruit: 9 items starting with Banana\n\n\nWhen you print an item that you declare using a protocol, p and po print an error because they don’t perform iterative dynamic type resolution. Use v to print variables when p or po print an error.\n\n(lldb) po fruitItem.fruitName\nerror: <EXPR>:3:11: error: value of type 'FruitDisplayProtocol' has no member 'fruitName'\nfruitItem.fruitName\n~~~~~~~~~ ^~~~~~~~~\n\n\n(lldb) v fruitItem.fruitName\n(String) fruitItem.fruitName = \"Apple\"\n\nSee Also\nBreakpoints and variables\nSetting breakpoints to pause your running app\nSpecify where your app pauses when running the debugger to investigate bugs."
  },
  {
    "title": "Writing ARMv7 code for iOS | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/writing-armv7-code-for-ios",
    "html": "Overview\n\nThe calling conventions for the ARMv7 and ARMv6 environments are nearly identical. As a result, any app you build for the ARMv7 environment is capable of running in the ARMv6 environment and vice versa. However, some ARMv7 environment features deviate from, or extend, the features of the ARMv6 environment.\n\nPreserve specific registers in ARMv7\n\nThe ARMv7 architecture preserves the same registers as the ARMv6 architecture, except for the changes and additions in the following table:\n\nType\n\n\t\n\nName\n\n\t\n\nPreserved\n\n\t\n\nNotes\n\n\n\n\nVFP register\n\n\t\n\nD0-D7\n\n\t\n\nNo\n\n\t\n\nAlso known as Q0-Q3 on ARMv7. These registers are accessible from Thumb mode on ARMv7.\n\n\n\n\n\t\n\nD8-D15\n\n\t\n\nYes\n\n\t\n\nAlso known as Q4-Q7 on ARMv7. These registers are accessible from Thumb mode on ARMv7.\n\n\n\n\n\t\n\nD16-D31\n\n\t\n\nNo\n\n\t\n\nAlso known as Q8-Q15. These registers are available only in ARMv7.\n\nFor additional register preservation guidance, see Preserve specific registers in ARMv6.\n\nGenerate ARM or Thumb code from the same assembly\n\nThe version of Thumb in ARMv7 is compatible with ARM assembly instructions. Specifically, Thumb is capable of saving and restoring the contents of the VFP registers, and ARMv7 assembly uses a unified set of mnemonics.\n\nThe following example shows a prolog that saves key registers, including several VFP registers. It also allocates 36 bytes for local storage.\n\npush add  {r4-r7, lr}     // save LR, R7, R4-R6.\nadd       r7, sp, #12     // Adjust R7 to point to saved R7.\npush      {r8, r10, r11}  // Save remaining GPRs (R8, R10, R11).\nvstmdb    sp!, {d8-d15}   // Save VFP/Advanced SIMD registers D8 \n                          // (aka S16-S31, Q4-Q7).\nsub       sp, sp, #36     // Allocate space for local storage.\n\n\nThe following example shows the epilog that restores the registers saved by the preceding prolog:\n\nadd       sp, sp, #36     // Deallocate space for local storage.\nvldmia    sp!, {d8-d15}   // Restore VFP/Advanced SIMD registers.\npop       {r8, r10, r11}  // Restore R8-R11.\npop       {r4-r7, pc}     // Restore R4-R6, saved R7, and \n                          // return to saved LR\n\nSee Also\niOS interfaces\nWriting ARMv6 code for iOS\nCreate ARMv6 assembly language instructions that adhere to the application binary interface (ABI) that iOS supports."
  },
  {
    "title": "Writing ARMv6 code for iOS | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/writing-armv6-code-for-ios",
    "html": "Overview\n\nThe ARMv6 specification defines the calling conventions for passing arguments and return values between two functions. You pass arguments on the runtime stack or in registers, and the called function returns results registers or in memory. For the most part, the ARMv6 specification adopts the same conventions as those defined in the Procedure Call Standard for the ARM Architecture (release 1.07). However, the ARMv6 specification deviates in the following ways:\n\nThe stack is 4-byte aligned at the point of function calls.\n\nData types larger than 4 bytes are 4-byte aligned.\n\nRegister R7 serves as the frame pointer.\n\nRegister R9 is a volatile scratch register.\n\nNote\n\nApple defines its own procedural programming interfaces for passing arguments to functions. Object-oriented languages may use different rules for their own method calls. For example, the conventions for C++ virtual functions are typically different than the conventions for C functions.\n\nThe Procedure Call Standard for the ARM Architecture (AAPCS) is available at https://developer.arm.com.\n\nPreserve specific registers in ARMv6\n\nThe following table lists the ARM architecture registers and their volatility in procedure calls:\n\nType\n\n\t\n\nName\n\n\t\n\nPreserved\n\n\t\n\nNotes\n\n\n\n\nGeneral-purpose register\n\n\t\n\nR0-R3\n\n\t\n\nNo\n\n\t\n\nGeneral-purpose registers available for use within a routine and between function calls. Pass arguments and results using these registers.\n\n\n\n\n\t\n\nR4-R6\n\n\t\n\nYes\n\n\t\n\n\n\n\n\t\n\nR7\n\n\t\n\nYes\n\n\t\n\nThe frame pointer. This register usually points to the previously saved stack frame and saved-link register.\n\n\n\n\n\t\n\nR8\n\n\t\n\nYes\n\n\t\n\n\n\n\n\t\n\nR9\n\n\t\n\nNo\n\n\t\n\nA volatile scratch register in iOS 3 and later.\n\n\n\n\n\t\n\nR10-R11\n\n\t\n\nYes\n\n\t\n\n\n\n\n\t\n\nR12\n\n\t\n\nNo\n\n\t\n\nThe intra-procedure (IP) scratch register. The linker uses this register, and it is volatile across all function calls. However, you can use it as a scratch register between function calls.\n\n\n\n\n\t\n\nR13\n\n\t\n\nSpecial\n\n\t\n\nThe stack pointer (SP).\n\n\n\n\n\t\n\nR14\n\n\t\n\nSpecial\n\n\t\n\nThe link register (LR). This register stores the return address of a function call.\n\n\n\n\n\t\n\nR15\n\n\t\n\nSpecial\n\n\t\n\nThe program counter (PC).\n\n\n\n\nProgram status register\n\n\t\n\nCPSR\n\n\t\n\nSpecial\n\n\t\n\nThe program status register. Function calls don’t preserve the condition bits (27-31) and GE bits (16-19). The E bit must remain zero (to indicate little-endian mode) when calling or returning from a function. Set the T bit only from a branch routine. Don’t modify any other bits.\n\n\n\n\nVFP registers\n\n\t\n\nD0-D7\n\n\t\n\nNo\n\n\t\n\nAlso known as S0-S15. These registers are inaccessible from Thumb mode on ARMv6.\n\n\n\n\n\t\n\nD8-D15\n\n\t\n\nyes\n\n\t\n\nAlso known as S16-S31. These registers are inaccessible from Thumb mode on ARMv6.\n\n\n\n\nVFP status register\n\n\t\n\nFPSCR\n\n\t\n\nSpecial\n\n\t\n\nThe VFP status register. Function calls don’t preserve the condition code bits (28-31) and saturation bits (0-4). Modify the exception control bits (8-12), rounding mode bits (22-23), and flush-to-zero bit (24) only from routines that affect the app state, either directly or using framework API functions. The short vector length (16-18) and stride (20-21) bits must be zero on function entry and exit. Don’t modify any other bits.\n\nConsider the following additional behaviors with regard to register usage:\n\nThe AAPCS document defines R7 as a general-purpose, nonvolatile register, but iOS uses it as a frame pointer. Failure to use R7 as a frame pointer prevents debugging and performance tools from generating valid backtraces.\n\nSome ARM environments refer to R11 with the mnemonic FP. In iOS, R11 is a general-purpose, nonvolatile register. To avoid confusion, iOS doesn’t use the term FP.\n\nDon’t access the VFP registers from Thumb mode in ARMv6. To access the VFP registers, run your code in ARM mode. In iOS, you can switch between ARM and Thumb mode only at function boundaries.\n\nHandle data types and data alignment properly\n\nThe following table lists the ANSI C scalar data types, their sizes, and their natural alignments in the ARMv6 environment. The natural alignment represents the default alignment for values of that type.\n\nData type\n\n\t\n\nSize (in bytes)\n\n\t\n\nNatural alignment (in bytes)\n\n\n\n\nBOOL, bool\n\n\t\n\n1\n\n\t\n\n1\n\n\n\n\nunsigned char\n\n\t\n\n1\n\n\t\n\n1\n\n\n\n\nchar, signed char\n\n\t\n\n1\n\n\t\n\n1\n\n\n\n\nunsigned short\n\n\t\n\n2\n\n\t\n\n2\n\n\n\n\nsigned short\n\n\t\n\n2\n\n\t\n\n2\n\n\n\n\nunsigned int\n\n\t\n\n4\n\n\t\n\n4\n\n\n\n\nsigned int\n\n\t\n\n4\n\n\t\n\n4\n\n\n\n\nunsigned long\n\n\t\n\n4\n\n\t\n\n4\n\n\n\n\nsigned long\n\n\t\n\n4\n\n\t\n\n4\n\n\n\n\nunsigned long long\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nsigned long long\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nfloat\n\n\t\n\n4\n\n\t\n\n4\n\n\n\n\ndouble\n\n\t\n\n8\n\n\t\n\n4\n\n\n\n\nlong double\n\n\t\n\n8\n\n\t\n\n4\n\n\n\n\npointer\n\n\t\n\n4\n\n\t\n\n4\n\nThe ARMv6 environment uses little-endian byte ordering to store numeric and pointer data types. With this scheme, the least-significant byte is first, followed by the most-significant byte.\n\nAs standalone arguments, scalar data types use their natural alignment. When part of a composite data type (array, structure, or union), the system chooses the member with the largest alignment value and uses that value for the overall type alignment. An array assumes the same alignment as its elements. The overall size of a composite data type is a multiple of its alignment value, which might require extra padding to accomplish.\n\nConfigure stack frames using correct conventions\n\nin iOS, all subroutine call and return sequences must work in both the ARM and Thumb states. Specifically, you must use the appropriate BLX and BX instructions, and not the MOV instruction, for all calls to function pointers. The main difference between the ARM and Thumb instruction sets is how you set up the stacks and parameter lists.\n\nThe stack environment in ARMv6 has the following characteristics:\n\nIt’s 4-byte aligned.\n\nIt grows downward.\n\nIt contains local variables and function parameters.\n\nIn the ARMv6 environment, the stack frame size is not fixed and the stack pointer (SP) points to the bottom of the stack. Stack frames contain the following areas:\n\nThe parameter area stores the arguments, or space for the arguments, that the caller passes to the called function. This area resides in the caller’s stack frame. The type of argument, and the availability of registers, defines whether the argument resides on the stack or in registers.\n\nThe saved link register contains the address of the caller’s next instruction.\n\nThe saved frame pointer (optional) contains the base address of the caller’s stack frame.\n\nThe saved registers area contains the values of registers that the callee must restore before it returns. For more information, see Preserve specific registers in ARMv6.\n\nThe local storage area contains each subroutine’s local variables.\n\nCreate the prolog and epilog for a function\n\nWhen a function calls a subroutine, the subroutine must allocate its own stack frame. It accomplishes this task using a prolog, which is a section of code the compiler places before the body of the function. The compiler places an epilog at the end of the subroutine to restore the process to its prior state.\n\nThe prolog performs the following tasks:\n\nIt pushes the value of the link register (LR) onto the stack.\n\nIt pushes the value of the frame pointer (R7) onto the stack.\n\nIt sets the frame pointer (R7) to the value of the stack pointer (SP). (This step gives the debugger a way to find previous stack frames.)\n\nIt pushes appropriate register values onto the stack to preserve them. For more information, see Preserve specific registers in ARMv6.\n\nIt allocates space for local storage in the stack frame.\n\nThe epilog performs the following tasks:\n\nIt deallocates the local storage in the stack.\n\nIt restores any preserved registers.\n\nIt pops the saved frame pointer value and puts it back into R7.\n\nIt moves the saved link register (LR) value into the program counter (PC).\n\nYou don’t need to include any parts of the prolog or epilog that don’t apply to your code. For example, if a function doesn’t use high registers (R8, R10, R11) or nonvolatile VFP registers, you don’t need to save them. Leaf functions don’t need to use the stack at all, except to save nonvolatile registers.\n\nThe following example shows a prolog in ARM mode. This prolog saves the contents of the VFP registers and allocates an additional 36 bytes of local storage.\n\nstmfd    sp!, {r4-r7, lr}     // Save LR, R7, R4-R6.\nadd      r7, sp, #12          // Adjust R7 to point to saved R7.\nstmfd    sp!, {r8, r10, r11}  // Save remaining GPRs (R8, R10, R11)\nfstmfdd  sp!, {d8-d15}        // Save VFP registers D8-D15,\n                              //  also known as S16-S31 or Q4-Q7.\nsub      sp, sp, #36          // Allocate space for local storage\n\n\nThe following example shows the corresponding epilog in ARM mode. The epilog deallocates the local storage and restores the registers that the prolog saved.\n\nadd      sp, sp, #36         // Deallocate local storage.\nfldmfdd  sp!, {d8-d15}       // Restore VFP registers.\nldmdd    sp!, {r8, r10, r11} // Restore R8-R11.\nldmdd    sp!, {r4-r7, pc}    // Restore R4-R6, saved R7,\n                             //  and return to saved LR.\n\n\nThe following example shows a prolog in Thumb mode. This prolog doesn’t save VFP registers because Thumb-1 cannot access those registers.\n\npush   {r4-r7, lr}     // Save Lr, R7, R4-R6.\nmov    r6, r11         // Move high registers to low registers, so\nmov    r5, r10         //  they can be saved. (Skip this part if\nmov    r4, r8          //  the routine doesn’t use R8, R10, or R11.)\npush   {r4-r6)         // Save R8, R10, R11 (now in R4-R6).\nadd    r7, sp, #24     // Adjust R7 to point to saved R7.\nsub    sp, #36         // Allocate space for local storage.\n\n\nThe following example shows the corresponding epilog in Thumb mode. This example restores the registers the prolog saved.\n\nadd    sp, #36         // Deallocate space for local storage\npop    {r4-r6}         // Pop R8, R10, R11\nmov    r8, r4          // Restore high registers.\nmov    r10, r5\nmov    r11, r6\npop    {r4-r7, pc)     // Restore R4-R6, saved R7, and\n                       //  return to saved LR.\n\n\n\nPass arguments to functions and handle return values\n\nThe compiler generally adheres to the argument passing rules in the AAPCS document, but the following items are worth noting:\n\nTypically, you place the first four scalar arguments into the core registers (R0, R1, R2, and R3), and place any remaining arguments on the stack. For exceptions, see the AAPCS document at https://developer.arm.com.\n\nUse 4-byte alignment for data types larger than 4 bytes in size.\n\nUse the Base Standard variant of the procedure call standard for floating-point arguments. In this variant, you pass floating-point and vector arguments in general-purpose registers (GPRs) instead of in VFP registers.\n\nThe compiler generally returns results according to the standard rules. Specifically, it returns most values in R0 unless the size of the return value warrants a different approach.\n\nFor complete details about argument-passing and return result behaviors, see the AAPCS document at https://developer.arm.com.\n\nSee Also\niOS interfaces\nWriting ARMv7 code for iOS\nCreate ARMv7 assembly language instructions that adhere to the application binary interface (ABI) that iOS supports."
  },
  {
    "title": "Writing ARM64 code for Apple platforms | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms",
    "html": "Overview\n\nThe ARM architecture defines rules for how to call functions, manage the stack, and perform other operations. If part of your code includes ARM assembly instructions, you must adhere to these rules in order for your code to interoperate correctly with compiler-generated code. Similarly, if you write a compiler, the machine instructions you generate must adhere to these rules. If you don’t adhere to them, your code may behave unexpectedly or even crash.\n\nApple platforms diverge from the standard 64-bit ARM architecture in a few specific ways. Apart from these small differences, iOS, tvOS, and macOS adhere to the rest of the 64-bit ARM specification. For information about the ARM64 specification, including the Procedure Call Standard for the ARM 64-bit Architecture (AArch64), go to https://developer.arm.com.\n\nRespect the purpose of specific CPU registers\n\nThe ARM standard delegates certain decisions to platform designers. Apple platforms adhere to the following choices:\n\nThe platforms reserve register x18. Don’t use this register.\n\nThe frame pointer register (x29) must always address a valid frame record. Some functions — such as leaf functions or tail calls — may opt not to create an entry in this list. As a result, stack traces are always meaningful, even without debug information.\n\nHandle data types and data alignment properly\n\nSome fundamental types of the C language have slightly different implementations:\n\nThe wchar_t type is 32 bit and is a signed type.\n\nThe char type is a signed type.\n\nThe long type is 64 bit.\n\nThe __fp16 type uses the IEEE754-2008 format, where applicable.\n\nThe long double type is a double precision IEEE754 binary floating-point type, which makes it identical to the double type. This behavior contrasts to the standard specification, in which a long double is a quad-precision, IEEE754 binary, floating-point type.\n\nThe following table lists the integer data types, their sizes, and their natural alignments on Apple platforms.\n\nData type\n\n\t\n\nSize (in bytes)\n\n\t\n\nNatural alignment (in bytes)\n\n\n\n\nBOOL, bool\n\n\t\n\n1\n\n\t\n\n1\n\n\n\n\nchar\n\n\t\n\n1\n\n\t\n\n1\n\n\n\n\nshort\n\n\t\n\n2\n\n\t\n\n2\n\n\n\n\nint\n\n\t\n\n4\n\n\t\n\n4\n\n\n\n\nlong\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nlong long\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\npointer\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nsize_t\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nNSInteger\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nCFIndex\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\nfpos_t\n\n\t\n\n8\n\n\t\n\n8\n\n\n\n\noff_t\n\n\t\n\n8\n\n\t\n\n8\n\nRespect the stack’s red zone\n\nThe ARM64 red zone consists of the 128 bytes immediately below the stack pointer. Apple platforms don’t modify these bytes during exceptions. User-mode programs can rely on the bytes below the stack pointer to not change unexpectedly, and can potentially make use of the space for local variables.\n\nNote\n\nIf a function calls itself, the caller must assume that the callee modifies the contents of its red zone. The caller must therefore create a proper stack frame.\n\nPass arguments to functions correctly\n\nThe stack pointer on Apple platforms follows the ARM64 standard ABI and requires 16-byte alignment. When passing arguments to functions, Apple platforms diverge from the ARM64 standard ABI in the following ways:\n\nFunction arguments may consume slots on the stack that are not multiples of 8 bytes. If the total number of bytes for stack-based arguments is not a multiple of 8 bytes, insert padding on the stack to maintain the 8-byte alignment requirements.\n\nWhen passing an argument with 16-byte alignment in integer registers, Apple platforms allow the argument to start in an odd-numbered xN register. The standard ABI requires it to begin in an even-numbered xN register.\n\nThe caller of a function is responsible for signing or zero-extending any argument with fewer than 32 bits. The standard ABI expects the callee to sign or zero-extend those arguments.\n\nFunctions may ignore parameters that contain empty struct types. This behavior applies to the GNU extension in C and, where permitted by the language, in C++. The AArch64 documentation doesn’t address the issue of empty structures as parameters, but Apple chose this path for its implementation.\n\nThe following example illustrates how Apple platforms specify stack-based arguments that are not multiples of 8 bytes. On entry to the function, s0 occupies one byte at the current stack pointer (sp), and s1 occupies one byte at sp+1. The compiler still adds padding after s1 to satisfy the stack’s 16-byte alignment requirements.\n\nvoid two_stack_args(char w0, char w1, char w2, char w3, char w4, char w5, char w6, char w7, char s0, char s1) {}\n\n\nThe following example shows a function whose second argument requires 16-byte alignment. The standard ABI requires placing the second argument in the x2 and x3 registers, but Apple platforms allow it to be in the x1 and x2 registers.\n\nvoid large_type(int x0, __int128 x1_x2) {} \n\nUpdate code that passes arguments to variadic functions\n\nFor functions that contain a variable number of parameters, Apple initializes the relevant registers (Stage A) and determines how to pad or extend arguments (Stage B) as usual. When it’s time to assign arguments to registers and stack slots, Apple platforms use the following rules for each variadic argument:\n\nRound up the Next SIMD and Floating-point Register Number (NSRN) to the next multiple of 8 bytes.\n\nAssign the variadic argument to the appropriate number of 8-byte stack slots.\n\nBecause of these changes, the type va_list is an alias for char*, and not for the struct type in the generic procedure call standard. The type also isn’t in the std namespace when compiling C++ code.\n\nNote\n\nThe C language requires the promotion of arguments smaller than int before a call. Beyond that, the Apple platforms ABI doesn’t add unused bytes to the stack.\n\nHandle C++ differences\n\nThe generic ARM64 C++ ABI mirrors the Itanium C++ ABI, which many UNIX-like systems use. Apple’s C++ ABI differs from this ABI in the following ways:\n\nThe mangled name of the va_list type is Pc, and not St9__va_list. This difference occurs because va_list is an alias for char *, and uses the same name-mangling conventions.\n\nThe mangled names for NEON vector types match their 32-bit ARM counterparts, rather than using the 64-bit scheme. For example, Apple platforms use 17__simd128_int32_t instead of the generic 11_int32x4_t.\n\nWhen passing parameters to a function, Apple platforms ignore empty structures unless those structures have a nontrivial destructor or copy constructor. When passing such nontrivial structures, treat them as aggregates with one byte member in the generic manner.\n\nThe ABI requires the complete object (C1) and base-object (C2) constructors to return this to their callers. Similarly, the complete object (D1) and base-object (D2) destructors return this. This behavior matches the ARM 32-bit C++ ABI.\n\nThe ABI provides a fixed layout of two size_t words for array cookies, with no extra alignment requirements. This behavior matches the ARM 32-bit C++ ABI.\n\nObject initialization guards are nominally uint64_t, rather than int64_t. This behavior affects the prototypes of functions __cxa_guard_acquire, __cxa_guard_release, and __cxa_guard_abort.\n\nA pointer to a function declared as extern “C” isn’t interchangeable with a function declared as extern “c++”. This behavior differs from the ARM64 ABI, in which the functions are interchangeable.\n\nFor more information about the generic ARM64 C++ ABI, see “C++ Application Binary Interface Standard for the ARM 64-bit architecture” at developer.arm.com."
  },
  {
    "title": "Configuring webhooks in Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-webhooks-in-xcode-cloud",
    "html": "Overview\n\nYou might use custom services and tools in your development process and for project management purposes and need to connect them to Xcode Cloud. For example, you might want to show build information from Xcode Cloud on your team’s dashboard, automate the merge process for pull requests (PRs), automatically open or close issues in your issue tracking tool, and so on.\n\nTo connect Xcode Cloud with a custom tool or service, you need to configure an HTTPS endpoint that can receive HTTP requests from Xcode Cloud, referred to as a webhook. By configuring a webhook, you enable Xcode Cloud to send a rich JSON payload to another service or tool at certain moments during the build process. The service or tool can then parse the JSON payload and use the received information to provide its functionality.\n\nNote\n\nYou can configure up to five webhooks per Xcode Cloud product.\n\nXcode Cloud sends an HTTP request to each webhook’s configured HTTPS endpoint every time it creates, starts, and finishes a build.\n\nFor more information about creating webhooks in Xcode Cloud, see WWDC21: Customize your advanced Xcode Cloud workflows.\n\nCreate an Xcode Cloud webhook\n\nTo create a webhook in Xcode Cloud:\n\nIn App Store Connect, choose an app and select the Xcode Cloud tab.\n\nIn the sidebar, choose Settings > Webhooks.\n\nClick the Add button (+) to add a new webhook.\n\nChoose a unique, easily recognizable name for the webhook, like “Team Dashboard” or “Issue Tracker”.\n\nEnter the URL of an app or service that’s capable of receiving and handling HTTPS requests.\n\nWhen your service or tool receives a request from Xcode Cloud, respond with an HTTP status code that indicates success. If you return a retry-able server error or Xcode Cloud doesn’t receive a response within 30 seconds, it resends the webhook request until it receives a successful response.\n\nNote\n\nYou need to configure a project or workspace to use Xcode Cloud before you can create a webhook.\n\nDebug a webhook\n\nWhen you create a new webhook, plan to spend some time making sure your service or tool can parse the JSON payload that Xcode Cloud sends. To help you debug an integration problem, Xcode Cloud records a delivery report for each webhook request it sends. It includes detailed request and response metadata.\n\nTo access a webhook’s delivery report:\n\nIn App Store Connect choose your app and select the Xcode Cloud tab.\n\nIn the sidebar, choose Settings > Webhooks.\n\nChoose a webhook and review its delivery reports.\n\nReview the payload\n\nWith each webhook request, Xcode Cloud includes detailed information about the app you configured in App Store Connect, the workflow that started the build, the build itself, your Git repository, and more. Use this information to provide functionality in your custom tool or service. For example, use the payload information to display Xcode Cloud build information on your team’s dashboard.\n\nThe following code snippet shows the payload Xcode Cloud sends with a request:\n\n{\n    \"webhook\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"name\": \"Issue Tracker\",\n        \"url\": \"https://issues.example.com/webhooks\"\n    },\n    \"metadata\" : {\n        \"type\" : \"metadata\",\n        \"attributes\" : {\n            \"createdDate\" : \"2021-06-07T10:00:00.000000-07:00\",\n            \"eventType\" : \"BUILD_COMPLETED\"\n        }\n    },\n    \"app\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"apps\"\n    },\n    \"ciWorkflow\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"ciWorkflows\",\n        \"attributes\": {\n            \"name\": \"Pull Requests\",\n            \"description\": \"Starts Builds from Pull Requests.\",\n            \"isEnabled\": true,\n            \"isLockedForEditing\": false\n        }\n    },\n    \"ciProduct\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"ciProducts\",\n        \"attributes\": {\n            \"name\": \"Example App\",\n            \"createdDate\": \"2021-06-07T10:00:00.000000-07:00\",\n            \"productType\": \"APP\"\n        }\n    },\n    \"ciBuildRun\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"ciBuildRuns\",\n        \"attributes\": {\n            \"number\": 12,\n            \"createdDate\": \"2021-06-07T10:00:00.000000-07:00\",\n            \"sourceCommit\": {\n                \"commitSha\": \"0123456789abcdefghij01234567890abcdefghi\",\n                \"author\": {\n                    \"displayName\": \"Anne Johnson\"\n                },\n                \"committer\": {\n                    \"displayName\": \"Anne Johnson\"\n                },\n                \"htmlUrl\": \"https://example.com/commit/abcdef1234567890\"\n            },\n            \"destinationCommit\": {\n                \"commitSha\": \"abcdefghij01234567890abcdefghi0123456789\",\n                \"author\": {\n                    \"displayName\": \"Juan Chavez\"\n                },\n                \"committer\": {\n                    \"displayName\": \"Juan Chavez\"\n                },\n                \"htmlUrl\": \"https://example.com/commit/abcdef1234567890\"\n            },\n            \"isPullRequestBuild\": true,\n            \"executionProgress\": \"COMPLETE\",\n            \"completionStatus\": \"SUCCEEDED\"\n        }\n    },\n    \"ciBuildActions\": [{\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"ciBuildActions\",\n        \"attributes\": {\n            \"name\": \"analyze\",\n            \"actionType\": \"ANALYZE\",\n            \"issueCounts\": {\n                \"analyzerWarnings\": 10,\n                \"errors\": 0,\n                \"testFailures\": 0,\n                \"warnings\": 0\n            },\n            \"executionProgress\": \"COMPLETE\",\n            \"completionStatus\": \"SUCCEEDED\",\n            \"isRequiredToPass\": false\n        },\n        \"relationships\": {}\n    }, {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"ciBuildActions\",\n        \"attributes\": {\n            \"name\": \"build\",\n            \"actionType\": \"ARCHIVE\",\n            \"issueCounts\": {\n                \"analyzerWarnings\": 0,\n                \"errors\": 0,\n                \"testFailures\": 0,\n                \"warnings\": 3\n            },\n            \"executionProgress\": \"COMPLETE\",\n            \"completionStatus\": \"SUCCEEDED\",\n            \"isRequiredToPass\": true\n        },\n        \"relationships\": {\n            \"builds\": {\n                \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n                \"type\": \"builds\",\n                \"attributes\": {\n                    \"platform\": \"IOS\"\n                }\n            }\n        }\n    }],\n    \"scmProvider\": {\n        \"type\": \"scmProviders\",\n        \"attributes\": {\n            \"scmProviderType\": {\n                \"scmProviderType\": \"GITHUB_CLOUD\",\n                \"displayName\": \"GitHub\",\n                \"isOnPremise\": false\n            },\n            \"endpoint\": \"https://github.com/example/example.git\"\n        }\n    },\n    \"scmRepository\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"scmRepositories\",\n        \"attributes\": {\n            \"httpCloneUrl\": \"https://github.com/example/test.git)\",\n            \"sshCloneUrl\": \"ssh://git@github.com/example/test.git\",\n            \"ownerName\": \"example\",\n            \"repositoryName\": \"example app\"\n        }\n    },\n    \"scmPullRequest\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"scmPullRequests\",\n        \"attributes\": {\n            \"title\": \"Add accessibility labels.\",\n            \"number\": 123,\n            \"htmlUrl\": \"https://example.com/example/example-app/pull/123)\",\n            \"sourceRepositoryOwner\": \"example\",\n            \"sourceRepositoryName\": \"example source repository name\",\n            \"sourceBranchName\": \"annejohnson/new-features\",\n            \"destinationRepositoryOwner\": \"example\",\n            \"destinationRepositoryName\": \"example destination repository name\",\n            \"destinationBranchName\": \"main\",\n            \"isClosed\": false,\n            \"isCrossRepository\": false\n        }\n    },\n    \"scmGitReference\": {\n        \"id\": \"12345678-abcd-1234-5678-a12345bc4567\",\n        \"type\": \"scmGitReferences\",\n        \"attributes\": {\n            \"name\": \"annejohnson/new-feature\",\n            \"canonicalName\": \"refs/heads/annejohnson/new-feature\",\n            \"isDeleted\": false,\n            \"kind\": \"BRANCH\"\n        }\n    }\n}\n\nSee Also\nNotifications\nConnecting Xcode Cloud to Slack\nConnect Xcode Cloud to Slack to keep your team informed about the latest Xcode Cloud builds."
  },
  {
    "title": "Resolve GitHub Enterprise connection issues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/resolve-github-enterprise-connection-issues",
    "html": "Overview\n\nXcode Cloud needs to have access to your Git repository to check out your code and build your app. You grant this access when you create your first workflow, or, in an enterprise context, your team’s administrator configures the connection for you before you start using Xcode Cloud.\n\nIf you work in a large team that uses GitHub Enterprise, you may have no control over the configuration of your team’s GitHub Enterprise setup. As a result, you may run into issues where Xcode Cloud can’t access your Git repository and can’t start builds. In this case, Xcode and App Store Connect display messages that indicate configuration or permission issues.\n\nCommon reasons for these issues are:\n\nThe administrator of your GitHub Enterprise instance changed permissions; for example, permissions for the GitHub Enterprise app that Xcode Cloud uses to access your repository.\n\nThe callback URL of your GitHub Enterprise instance changed.\n\nThe GitHub Enterprise app that Xcode Cloud uses to connect to your repository received an update and requires permission updates.\n\nFixes for permission and configuration issues depend on your GitHub Enterprise instance, but common ways to re-enable Xcode Cloud to connect to your repository include:\n\nVisit your GitHub Enterprise team’s settings page and look for outstanding requested permission updates.\n\nVisit the settings page for the GitHub app that manages access to your Git repositories, and verify the callback URL. Additionally, verify that the configured permissions and events match those in the table and list below.\n\nRequired permissions:\n\nType\n\n\t\n\nValue\n\n\n\n\nChecks\n\n\t\n\nRead and write\n\n\n\n\nContents\n\n\t\n\nRead-only\n\n\n\n\nMetadata\n\n\t\n\nRead-only\n\n\n\n\nPull Requests\n\n\t\n\nRead-only\n\n\n\n\nStatuses\n\n\t\n\nRead and write\n\nRequired events:\n\nCreate\n\nCheck Run\n\nCheck Suite\n\nDelete\n\nPull Request\n\nPull Request Review\n\nPush\n\nRepository\n\nAs a last resort, you can disconnect Xcode Cloud from your GitHub Enterprise repository as described in Disconnect your Git repository in Xcode Cloud and uninstall the app that guards access to your GitHub Enterprise repository as described in Remove personal access tokens or apps. However, you have to reconnect GitHub Enterprise to Xcode Cloud and configure access to each of your repositories on GitHub Enterprise — which may take a considerable amount of time if you have a lot of repositories and projects.\n\nImportant\n\nMake sure you don’t delete your Xcode Cloud data and workflows. If you do this, you will lose access to your workflows and build data, and you’ll have to configure Xcode Cloud workflows for your project again.\n\nSee Also\nTroubleshooting\nResolving common configuration and build issues\nReview common configuration and build issues and learn how you can resolve them.\nReporting feedback for Xcode Cloud\nProvide feedback on issues you encounter when building with Xcode Cloud."
  },
  {
    "title": "Resolving common configuration and build issues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/resolving-common-configuration-and-build-issues",
    "html": "Overview\n\nXcode guides you through the process of configuring your project to use Xcode Cloud and of creating workflows. However, there’s a chance that you run into issues. This is more likely for complex codebases and projects that have many dependencies. To help you diagnose build failure, view logs in the build report in Xcode or on the App Store Connect website and download build reports.\n\nView build logs\n\nTo understand why a build failed, open your project or workspace and navigate to the Report navigator. Select a build, expand a failed action, and select Logs to see the build logs. To download the build logs and any other build artifacts — for example, a result bundle — choose Artifacts for the failed action.\n\nAlternatively, select a build in the Xcode Cloud tab on the App Store Connect website to view detailed information about the build.\n\nReproduce a build failure locally\n\nReproducing a build failure locally is often key to fixing its cause. To quickly replicate a failing build’s source state locally:\n\nOpen your Xcode project or workspace, navigate to the Report navigator, and select a build to view its Build Report overview.\n\nClick Switch To in the top-right corner of the overview and follow the on screen prompts to either switch to the latest commit of the branch or check out the specific commit of the failing build.\n\nReproduce the issue locally by performing the action that failed in Xcode Cloud and resolve the issue.\n\nIf your workflow doesn’t automatically start a new build with the latest change, manually start a new build as described in Start a new build below.\n\nResolve configuration issues\n\nTo resolve issues when first configuring your project or workspace to use Xcode Cloud:\n\nIf Xcode doesn’t list your product, enable the archive action for the scheme that builds your app or framework in Xcode.\n\nIf you can’t grant Xcode Cloud access to your Git repository, check if you have the required permission or role to connect Xcode Cloud to your Git repository. For more information, see Grant Xcode Cloud access to your source code.\n\nIf a workflow’s action doesn’t list a scheme, make sure you shared the scheme. For information on sharing a scheme, see Xcode Help.\n\nResolve build issues\n\nTo resolve build issues:\n\nControl-click your workflow in the Report navigator, click Edit Workflow, and verify that the environment setting uses the macOS and Xcode versions you require to build your project.\n\nCheck if your project or workspace uses Xcode’s new build system. For more information about the new build system, see Build System Release Notes for Xcode 10. For details about how to turn on the new build system, see Choose the build system.\n\nReview your project’s dependencies and required additional tools to make sure they are accessible to Xcode Cloud. For more information, see Making dependencies available to Xcode Cloud.\n\nIf you use CocoaPods to manage your dependencies, check if you committed your Podfile and your Podfile.lock files to Git and installed CocoaPods correctly as explained in Make CocoaPods dependencies available to Xcode Cloud.\n\nIf a third-party tool indicates networking issues, configure it to respect the HTTP_PROXY and HTTPS_PROXY environment variables and adjust its proxy settings as needed.\n\nIf your build fails with an error that indicates a missing app capability, check if the app ID you used when you configured your first Xcode Cloud workflow has all required capabilities enabled. For more information about capabilities, see Enable app capabilities.\n\nResolve Swift package dependency issues\n\nXcode Cloud supports using Swift package dependencies in your project. Be sure to read Use Swift package dependencies and Git submodules if your project requires Swift package dependencies to build successfully.\n\nA common cause of failing builds is that Xcode Cloud can’t access the Package.resolved file that it needs to resolve your Swift Package dependencies. To resolve issues related to the Package.resolved file, make sure:\n\nTo commit and push the file to your Git repository.\n\nYour .gitignore file doesn’t include the file.\n\nStart a new build\n\nWhen you’ve made changes to your project or workspace to resolve a build issue, start a new build to verify that the change resolved it:\n\nTo manually start a new build that includes any new changes, Control-click the workflow in the Report navigator and click Start Build.\n\nTo start a build from the same Git commit, Control-click the build in the Report navigator and choose Rebuild.\n\nSee Also\nTroubleshooting\nResolve GitHub Enterprise connection issues\nVerify that Xcode Cloud can access your GitHub Enterprise repository and fix configuration issues.\nReporting feedback for Xcode Cloud\nProvide feedback on issues you encounter when building with Xcode Cloud."
  },
  {
    "title": "Writing custom build scripts | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/writing-custom-build-scripts",
    "html": "Overview\n\nXcode Cloud leverages your project’s configured schemes and offers settings to create advanced workflows. However, Xcode Cloud workflows can offer even more flexibility to meet your project’s requirements. For example, you might need to install an additional third-party tool to successfully build your project, upload build artifacts to private storage, use a different app icon for nightly builds, and so on.\n\nIf you need additional flexibility in your Xcode Cloud workflows, create a custom build script to perform a specific task at a designated time. Xcode Cloud recognizes three different script types:\n\nA post-clone script that runs after Xcode Cloud clones your Git repository.\n\nA pre-xcodebuild script that runs before Xcode Cloud runs xcodebuild.\n\nA post-xcodebuild script that Xcode Cloud runs after running xcodebuild.\n\nFor Xcode Cloud to recognize your custom build scripts, you’ll need to place them at a specific location: the ci_scripts directory. Xcode Cloud runs your custom build scripts from this directory. Additionally, name the scripts according to conventions listed below. When it starts a new build, Xcode Cloud recognizes your custom build scripts automatically and runs them for every action.\n\nImportant\n\nXcode Cloud uses zsh as its default Unix shell. As a best practice, always include a shebang in the first line of your custom build script; for example #!/bin/sh.\n\nFor additional information about custom build scripts, see WWDC21: Customize your advanced Xcode Cloud workflows. For more information on installing a third-party tool, see Use a custom build script to install a third-party dependency or tool.\n\nCreate the CI scripts directory\n\nCustom build scripts reside in a directory named ci_scripts that’s located in the same directory as your Xcode project or workspace, and Xcode Cloud runs your custom build scripts with this directory as the root directory.\n\nTo create the ci_scripts directory:\n\nOpen your project or workspace in Xcode and navigate to the Project navigator.\n\nIn the Project navigator, Control-click your project and choose New Group to create the group and its corresponding directory.\n\nName the new group ci_scripts.\n\nCreate a custom build script\n\nWhen Xcode Cloud performs an action you’ve added to a workflow, it performs a series of steps. If you add a custom build script, Xcode Cloud runs it at a specific moment between these steps.\n\nThe name of a custom script’s corresponding file determines when Xcode Cloud runs the script; only use the following file names for your scripts:\n\nci_post_clone.sh\n\nThe post-clone script runs after Xcode Cloud clones your Git repository. You might use a post-clone script to install an additional tool, or to add a new entry to a property list.\n\nci_pre_xcodebuild.sh\n\nThe pre-xcodebuild script runs before Xcode Cloud runs the xcodebuild command. You might use a pre-xcodebuild script to compile additional dependencies.\n\nci_post_xcodebuild.sh\n\nThe post-xcodebuild script runs after Xcode Cloud runs the xcodebuild command — even if the xcodebuild command fails. You might use a post-xcodebuild script to upload artifacts to storage or another service.\n\nTo create a custom build script:\n\nOpen your project or workspace in Xcode and navigate to the Project navigator.\n\nControl-click the ci_scripts group you created earlier and choose New File.\n\nChoose the Shell Script template.\n\nName the shell script ci_post_clone.sh, ci_pre_xcodebuild.sh, or ci_post_xcodebuild.sh.\n\nCreate the file without adding it to a target.\n\nIn Terminal, make the shell script an executable by running chmod +x $filename.sh.\n\nAdd code to your custom build script — including a shebang in the first line; for example #!/bin/sh — and add it to your Git repository. Xcode Cloud runs it automatically when it starts the next build.\n\nXcode Cloud respects the shebang if the file is executable. If you don’t include a shebang as the first line of your custom script or forget to make the file executable, Xcode Cloud runs the script as zsh $filename, which — depending on your script — can cause a failing build.\n\nNote\n\nYou can’t obtain administrator privileges by using sudo in your custom build scripts.\n\nFiles you create with a custom build script aren’t available to other custom build scripts, and Xcode Cloud deletes any files a custom build script creates. As a result, downloadable Xcode Cloud build artifacts don’t include files you create with custom build scripts.\n\nAdd resources to the CI scripts directory\n\nCustom build scripts run in a temporary build environment where your source code may not be available. As a result, you need to place all resources your custom scripts access in the ci_scripts directory. For example, place artwork or .plist files in the directory.\n\nNote\n\nUse sub-directories inside the ci_scripts directory to organize its content. However, make sure to place the three custom build scripts ci_post_clone.sh, ci_pre_xcodebuild.sh, and ci_post_xcodebuild.sh at the top level of the ci_scripts directory.\n\nIn some cases, a custom build script needs to access a file that’s located in the repository, but placing it in the ci_scripts directory isn’t practical. In this case, create a symbolic link to the file in the ci_scripts directory. Xcode Cloud detects the symbolic link and makes it available within the ci_scripts directory in a subsequent phase of the running action.\n\nAccess environment variables\n\nEnvironment variables are key to custom scripts because they allow you to write flexible custom scripts with advanced control flows. For example, the following code snippet checks if the CI_PULL_REQUEST_NUMBER variable is present to only run a command when Xcode Cloud runs the script as part of a build from a pull request:\n\n#!/bin/sh\n\n\nif [[ -n $CI_PULL_REQUEST_NUMBER ]];\nthen\n    echo \"This build started from a pull request.\"\n\n\n    # Perform an action only if the build starts from a pull request.\nfi\n\n\nFor a list of predefined environment variables, see Environment variable reference.\n\nDefine custom environment variables\n\nIn addition to predefined environment variables, you can define custom environment variables in a workflow’s Environment section. To learn more about configuring custom environment variables, see Custom environment variables\n\nAdd debug information\n\nThe output of your custom build scripts appears in the build report’s build logs. Log information that may be helpful when you debug a custom build script. However, never log sensitive information like API keys or access tokens in your shell script output unless you use a secret custom environment variable. If you mark a custom environment variable to be a secret, Xcode Cloud replaces its value with asterisks (**********) in build logs.\n\nWrite resilient scripts\n\nCustom build scripts can perform critical tasks like installing dependencies or uploading build artifacts to storage. Write resilient code that handles errors gracefully, and, if a command fails, return a nonzero exit code. By returning a nonzero exit code in your custom build script, you let Xcode Cloud know that something went wrong and let it fail the build to let you know that there’s an issue.\n\nThe following build script sets the -e option to stop the script if a command exits with a nonzero exit code. Additionally, return a nonzero exit code in case something goes wrong:\n\n#!/bin/sh\n\n\n# Set the -e flag to stop running the script in case a command returns\n# a nonzero exit code.\nset -e\n\n\n# A command or script succeeded.\necho \"A command or script was successful.\"\nexit 0\n\n\n...\n\n\n# Something went wrong.\necho \"Something went wrong. Include helpful information here.\"\nexit 1\n\nUse helper scripts in complex custom build scripts\n\nIf your repository contains more than one project, you’ll likely need to configure several Xcode Cloud workflows. Because Xcode Cloud only recognizes one ci_scripts directory in your repository — and that directory can only contain the three custom build scripts — you’ll need to add helper scripts. Helper scripts are shell scripts you place in the ci_scripts directory that you can use to split up the tasks of the default build scripts.\n\nYou can use the helper scripts to create a more flexible build environment, where you offload most of the logic you want Xcode Cloud to perform in a custom build script into a separate shell script file. For example, you might use environment variables to determine which Xcode Cloud workflow runs the build script, what started the build, the platform of the running build, and so on, to run logic only when applicable.\n\nNote\n\nXcode Cloud uses zsh as its default Unix shell. Make your scripts executable and add a shebang line at the beginning of your scripts to avoid a failing build. For example, add #!/usr/bin/env python3 to a helper script you write in Python that uploads build artifacts to your server. If you use Swift for your helper scripts, use #!/usr/bin/env swift.\n\nWhen it comes to naming your helper scripts, use a filename that makes it easy to recognize the script’s purpose. For example, you might prefix helper scripts with the name of their intended platform and name the following script platform-detect.sh because it uses the CI_PRODUCT_PLATFORM variable to detect the platform for the current build:\n\n#!/bin/sh\n\n\nif [ $CI_PRODUCT_PLATFORM = 'macOS' ]\nthen\n    ./macos_perform_example_task.sh\nelse\n    ./iOS_perform_example_task.sh\nfi\n\n\nTo help make your helper scripts more recognizable, you should avoid prefixing the script names with ci_.\n\nSee Also\nCustom build scripts\nEnvironment variable reference\nReview predefined environment variables you use in custom build scripts."
  },
  {
    "title": "Environment variable reference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/environment-variable-reference",
    "html": "Overview\n\nWith custom workflows, you can tailor Xcode Cloud to your needs. When you create a custom workflow, you configure the temporary build environment Xcode Cloud uses, start conditions, actions, and other settings. However, you may need to perform custom tasks, for example, installing a third-party tool or uploading a build’s artifacts to your server. To achieve this, Xcode Cloud supports running custom shell scripts, referred to as custom build scripts.\n\nXcode Cloud includes a set of predefined environment variables that you can use to write flexible custom build scripts with advanced control flows. For example, access the CI_XCODEBUILD_ACTION variable in your script to determine which action is running and use this information to run a specific command. You can also use the absence of a variable to change your custom build script’s control flow.\n\nTip\n\nIn addition to predefined environment variables, you can set custom environment variables in a workflow’s Environment section and access them in your custom build scripts or test actions.\n\nFor more information on using custom build scripts and accessing environment variables, see Writing custom build scripts.\n\nVariables that are always available\n\nThe following environment variables are available every time Xcode Cloud starts a build, no matter which actions or start conditions you configure for a workflow:\n\nCI\n\nA Boolean value that evaluates to TRUE when the custom build script runs in Xcode Cloud. Use it to only run the build script when Xcode Cloud builds your project or workspace. See also CI_XCODE_CLOUD.\n\nCI_BUILD_ID\n\nA string that uniquely identifies the current build, for example, 12345678-ABCD-DEFG-1234-012345ABCDEF.\n\nCI_BUILD_NUMBER\n\nThe number of the current build, for example, 42.\n\nCI_BUILD_URL\n\nA URL to the Xcode Cloud build in App Store Connect.\n\nCI_BUNDLE_ID\n\nThe bundle ID of the product, for example, com.example.appname.\n\nCI_COMMIT\n\nThe Git commit hash that Xcode Cloud uses for the current build.\n\nCI_DERIVED_DATA_PATH\n\nThe path to the directory that contains your project’s derived data.\n\nCI_PRIMARY_REPOSITORY_PATH\n\nThe location of the source code in the temporary build environment cloned from the primary repository specified in the workflow, for example, /Volumes/workspace/repository.\n\nCI_PRODUCT\n\nThe name of the workflow’s product.\n\nCI_PRODUCT_ID\n\nA string that uniquely identifies the product, for example, 12345678-ABCD-DEFG-1234-012345ABCDEF. Use it to distinguish between products in the same project or workspace.\n\nCI_PRODUCT_PLATFORM\n\nThe platform (iOS, macOS, tvOS, or watchOS) for the current action.\n\nCI_PROJECT_FILE_PATH\n\nThe path to the Xcode project or workspace in the temporary build environment.\n\nCI_START_CONDITION\n\nThe start condition that started the build. Available values are manual, manual_rebuild, push, pr_open, pr_update, and schedule.\n\nCI_TEAM_ID\n\nThe ID of your Apple Development team, for example, ABCDE12345.\n\nCI_WORKFLOW\n\nThe name of the workflow, for example, Default Workflow. Use this variable to run commands only for a specific workflow.\n\nCI_WORKSPACE_PATH\n\nThe location of the workspace used for cloning source code and storing artifacts, for example, /Volumes/workspace.\n\nCI_XCODE_CLOUD\n\nA Boolean value that evaluates to TRUE when the custom build script runs in Xcode Cloud. Use it to only run the script content when Xcode Cloud builds your project or workspace.\n\nCI_XCODE_PROJECT\n\nThe name of the Xcode project or workspace.\n\nCI_XCODE_SCHEME\n\nThe scheme that the current action uses.\n\nCI_XCODEBUILD_ACTION\n\nThe xcodebuild command that Xcode Cloud is about to perform. Possible values are analyze, archive, build, build-for-testing, and test-without-building.\n\nCI_XCODEBUILD_EXIT_CODE\n\nThe exit code of the xcodebuild command. This variable is available after Xcode Cloud runs an action’s corresponding xcodebuild command. An exit code of 0 indicates that the xcodebuild command succeeded.\n\nNote\n\nXcode Cloud builds your project using temporary build environments that use an HTTP proxy and makes the standard HTTP_PROXY and HTTPS_PROXY environment variables available. Many tools respect those variables and use them to change their settings.\n\nVariables for specific start conditions\n\nThe availability of the following environment variables depends on the workflow’s start condition you configure. For example, the CI_PULL_REQUEST_NUMBER variable is only available if the Pull Request Change start condition started the build.\n\nVariable for branch changes\nCI_BRANCH\n\nThe name of the source branch that Xcode Cloud checked out for the current build, for example, main.\n\nVariable for tag changes\nCI_TAG\n\nThe name of the tag that Xcode Cloud checked out for the current build, for example, release-1.1.\n\nVariable for branch changes and tag changes\nCI_GIT_REF\n\nThe canonical Git reference that contains the CI_COMMIT, for example, refs/heads/bug-fix for a build from the bug-fix branch and refs/tags/release-1.0 from the release-1.0 tag.\n\nVariables for pull request changes\nCI_PULL_REQUEST_HTML_URL\n\nThe URL to the pull request’s website.\n\nCI_PULL_REQUEST_NUMBER\n\nThe pull request’s number, for example, 42.\n\nCI_PULL_REQUEST_SOURCE_BRANCH\n\nThe pull request’s source branch, for example, feature/feature-12345.\n\nCI_PULL_REQUEST_SOURCE_COMMIT\n\nThe Git commit hash of a pull request’s source. It’s the same value as CI_COMMIT.\n\nCI_PULL_REQUEST_SOURCE_REPO\n\nThe full name of a pull request’s source repository, for example, example/fork-of-example-framework. If the pull request involves only one repository, the variable’s value is the same as CI_PULL_REQUEST_TARGET_REPO.\n\nCI_PULL_REQUEST_TARGET_BRANCH\n\nThe pull request’s target branch, for example, main.\n\nCI_PULL_REQUEST_TARGET_COMMIT\n\nThe most recent Git commit hash of the pull request’s target branch. The CI service tests your changes against the merge of CI_PULL_REQUEST_TARGET_COMMIT and CI_PULL_REQUEST_SOURCE_COMMIT.\n\nCI_PULL_REQUEST_TARGET_REPO\n\nThe full name of the pull request’s target repository, for example, example/original-repository-of-example-framework. If the pull request involves only one repository, the variable’s value is the same as CI_PULL_REQUEST_SOURCE_REPO.\n\nVariables for specific actions\n\nThe availability of the following environment variables depends on the action Xcode Cloud performs. For example, the CI_ARCHIVE_PATH variable is only available when Xcode Cloud performs an archive action.\n\nVariables for test actions\nCI_RESULT_BUNDLE_PATH\n\nThe path to the test action’s result bundle (.xcresult).\n\nCI_TEST_DESTINATION_DEVICE_TYPE\n\nThe device type of the simulated device you choose as the test action’s destination, for example, iPhone 11.\n\nCI_TEST_DESTINATION_RUNTIME\n\nThe OS version of the simulated device you choose as the test action’s destination, for example, iOS 13.0.\n\nCI_TEST_DESTINATION_UDID\n\nA string that uniquely identifies the simulated device you choose as the test action’s destination.\n\nCI_TEST_PLAN\n\nThe name of the test plan that the test action uses. This variable is only available if you use test plans.\n\nCI_TEST_PRODUCTS_PATH\n\nThe path to the directory that contains your project’s test products that Xcode Cloud creates.\n\nNote\n\nXcode Cloud makes all the environment variables for test actions available to the processes that execute your tests, known as test runners. This includes environment variables set by the system as well as any custom environment variables you set in the Environment section of your workflow. When executing your test action, Xcode Cloud adds the prefix TEST_RUNNER_ to each variable’s name, which is required by xcodebuild for the test runner process to access each variable by its original name. For more information on using the TEST_RUNNER_ prefix on your environment variables when running xcodebuild, see the Environment Variables section of xcodebuild’s man page.\n\nVariables for archive actions\nCI_AD_HOC_SIGNED_APP_PATH\n\nThe path to an exported archive that’s code-signed for Ad Hoc distribution.\n\nCI_APP_STORE_SIGNED_APP_PATH\n\nThe path to an exported archive that’s code-signed for TestFlight distribution and eligible for release on the App Store.\n\nCI_ARCHIVE_PATH\n\nThe path to the exported app archive that Xcode Cloud creates when it runs an archive action.\n\nCI_DEVELOPMENT_SIGNED_APP_PATH\n\nThe path to an exported app archive that’s code-signed for development distribution.\n\nCI_DEVELOPER_ID_SIGNED_APP_PATH\n\nThe path to an exported app archive that’s code-signed using the Developer ID certificate. Use Developer ID signing only for Mac apps distributed outside the Mac App Store. For more information, see Developer ID.\n\nSee Also\nCustom build scripts\nWriting custom build scripts\nExtend your Xcode Cloud workflows with custom build scripts that perform custom tasks or install additional tools."
  },
  {
    "title": "Configuring requirements for merging a pull request | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-requirements-for-merging-a-pull-request",
    "html": "Overview\n\nWhen you configure an Xcode Cloud workflow that starts a new build for every change to a pull request (PR), Xcode Cloud reports the build status on your source code management (SCM) provider’s webpage for a PR. As a result, you can identify issues that changes in the PR caused. However, the build status doesn’t prevent you from merging a PR with a failed Xcode Cloud build.\n\nTo prevent merging PRs that contain errors, Bitbucket Cloud, Bitbucket Server, GitHub, and GitHub Enterprise allow you to configure requirements that a PR must meet before it’s possible to merge it. Xcode Cloud supports these branch protection features. You can require that an entire Xcode Cloud build must succeed before it’s possible to merge a PR, or you can require that a specific Xcode Cloud action must succeed.\n\nThe user interface for configuring requirements for PRs depends on the SCM provider:\n\nBitbucket Cloud and Bitbucket Server refer to their branch protection features as code insights. For more information about Bitbucket code insights and configuring requirements for PRs, see Bitbucket documentation.\n\nGitHub and GitHub Enterprise refer to their branch protection features as status checks. For more information about GitHub status checks and configuring requirements for PRs, see GitHub documentation.\n\nGitLab and self-managed GitLab instances don’t come with branch protection features that prevent merging PRs with errors. Instead, they only display build status information. This is a limitation of GitLab and self-managed GitLab instances and not limited to Xcode Cloud.\n\nNote\n\nTo configure requirements for PRs, you need the same permission or role that you need to initially connect Xcode Cloud to your Git repository. For information about required permissions and roles, see Source control requirements.\n\nConfigure requirements\n\nTo require a successful Xcode Cloud build or action before it’s possible to merge a PR:\n\nConfigure a workflow that starts a new build for changes to a PR. For more information, see Start builds for changes to a pull request.\n\nNavigate to the configuration section of your SCM provider’s website, and follow the instructions to add requirements for PRs.\n\nFor example, configure an Xcode Cloud workflow that starts a build for each change to a PR and performs a test and an archive action. On your SCM provider’s website, require a successful Xcode Cloud build to ensure that the target branch only receives verified changes. Alternatively, require a successful archive action and allow merging a PR even if the test action fails. A common use case for this configuration is during feature development when you consider it OK to merge PRs that target a feature branch even if they cause unit tests to fail.\n\nSee Also\nSource code management\nSource code management setup\nAllow Xcode Cloud to access your Git repository."
  },
  {
    "title": "Diagnosing memory, thread, and crash issues early | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early",
    "html": "Overview\n\nIdentifying potential issues during development saves testing time later and improves the stability of your code. Xcode provides several runtime tools to identify potential issues in your code:\n\nAddress Sanitizer—The ASan tool identifies potential memory-related corruption issues.\n\nThread Sanitizer—The TSan tool detects race conditions between threads.\n\nMain Thread Checker—This tool verifies that system APIs that must run on the main thread actually do run on that thread.\n\nUndefined Behavior Sanitizer—The UBSan tool detects divide-by-zero errors, attempts to access memory using a misaligned pointer, and other undefined behaviors.\n\nThese are LLVM-based tools that add specific checks to your code. You enable them at build time using the Xcode scheme editor. Select the appropriate scheme for your project and choose Product > Scheme > Edit Scheme to display the scheme editor. Select the Run or Test schemes, navigate to the Diagnostics section, and select the sanitizers you want to run.\n\nNote\n\nThe sanitizer tools support all C-based languages. The tools also support the Swift language, with the exception of the Undefined Behavior Sanitizer tool, which supports only C-based languages.\n\nUsing the sanitizer tools is just one way to catch certain types of issues. Always test your code using a comprehensive set of unit tests, and use additional integration and UI tests to exercise your code at runtime. For more information about testing your code, see Testing your apps in Xcode.\n\nLocate memory corruption issues in your code\n\nAccessing memory improperly can introduce unexpected issues into your code, and even pose a security threat. The Address Sanitizer tool detects memory-access attempts that don’t belong to an allocated block. To enable this tool, select Address Sanitizer from the Diagnostics section of the appropriate scheme.\n\nTo enable ASan from the command line, use the following flags:\n\n-fsanitize=address (clang)\n\n-sanitize=address (swiftc)\n\n-enableAddressSanitizer YES (xcodebuild)\n\nThe Address Sanitizer tool replaces the malloc(_:) and free(_:) functions with custom implementations. The custom malloc(_:) function surrounds a requested memory block with special off-limits regions, and reports attempts to access those regions. The free(_:) function places a deallocated block into a special quarantine queue, and reports attempts to access that quarantined memory.\n\nImportant\n\nAddress Sanitizer doesn’t detect memory leaks, attempts to access uninitialized memory, or integer overflow errors. Use Instruments and the other sanitizer tools to find additional errors.\n\nFor most use cases, the overhead that Address Sanitizer adds to your code should be acceptable for daily development. Running your code with Address Sanitizer increases memory usage by two to three times, and also adds 2x to 5x slowdown of your code. To improve your code’s memory usage, compile your code with the -O1 optimization.\n\nDetect data races among your app’s threads\n\nRace conditions occur when multiple threads access the same memory without proper synchronization. Race conditions are difficult to detect during regular testing because they don’t occur consistently. However, fixing them is important because they cause your code to behave unpredictably, and may even lead to memory corruption.\n\nTo detect race conditions and other thread-related issues, enable the Thread Sanitizer tool from the Diagnostics section of the appropriate build scheme.\n\nTo enable TSan from the command line, use the following flags:\n\n-fsanitize=thread (clang)\n\n-santize=thread (swiftc)\n\n-enableThreadSanitizer YES (xcodebuild)\n\nThe Thread Sanitizer tool inserts diagnostics into your code to record each memory read or write operation. These diagnostics generate a timestamp for each operation, as well as its location in memory. The tool then reports any operations that occur at the same location at approximately the same time. The tool also detects other thread-related bugs, such as uninitialized mutexes and thread leaks.\n\nImportant\n\nYou can’t use Thread Sanitizer to diagnose iOS, tvOS, and watchOS apps running on a device. Use Thread Sanitizer only on your 64-bit macOS app, or to diagnose your 64-bit iOS, tvOS, or watchOS app running in Simulator.\n\nBecause Thread Sanitizer inserts diagnostics into your code, it increases memory usage by five to ten times. Running your code with these diagnostics also introduces a 2x to 20x slowdown of your app. To improve your code’s memory usage, compile your code with the -O1 optimization.\n\nDetect improper UI updates on background threads\n\nSome system frameworks contain APIs that you must only call from your app’s main thread. This requirement applies to most of the AppKit and UIKit user interface APIs, and also applies to some other system APIs. Calling these APIs from the main thread prevents race conditions by serializing the execution of the associated tasks. Failure to perform these operations on the main thread may result in visual defects, data corruption, or crashes.\n\nThe Main Thread Checker tool ensures that all calls that must occur on the main thread do so. To enable this tool, select Main Thread Checker from the Diagnostics section of the appropriate scheme.\n\nThe Main Thread Checker tool dynamically replaces system methods that must execute on the main thread with variants that check the current thread. The tool replaces only system APIs with well-known thread requirements, and doesn’t replace all system APIs. Because the replacements occur in system frameworks, Main Thread Checker doesn’t require you to recompile your app.\n\nNote\n\nBecause Main Thread Checker doesn’t require you to recompile your code, you can run it on an existing macOS binary. Inject the dynamic library located at /Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib into your executable.\n\nTo fix problems identified by Main Thread Checker, dispatch calls to your app’s main thread. The most common place where main thread errors occur is completion handler blocks. The following code wraps the text label modification with an asynchronous dispatch call to the main thread.\n\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n   if let data = data {\n      // Redirect to the main thread.\n      DispatchQueue.main.async {\n         self.label.text = \"\\(data.count) bytes downloaded\"\n      }\n   }\n}\ntask.resume()\n\n\n\n\nThe performance impact of Main Thread Checker is minimal. The tool adds 1–2% CPU overhead to your process, and increases process launch time by no more than 100 milliseconds. Because of this minimal impact, Xcode enables Main Thread Checker by default for your development-related schemes.\n\nDetect operations with undefined semantics\n\nCode that results in undefined behavior can lead to crashes or incorrect output. In some cases, the code may not result in any problems at all initially, making it even harder to diagnose the problem later when conditions are different. The Undefined Behavior Sanitizer tool checks C-based code for a variety of common runtime errors, including:\n\nAttempts to divide by zero\n\nAttempts to load memory from a misaligned pointer\n\nAttempts to dereference a NULL pointer\n\nMath operations that result in integer overflow\n\nTo enable this tool, select Undefined Behavior Sanitizer from the Diagnostics section of the appropriate scheme.\n\nTo enable UBSan from the command line, add the -fsanitize=undefined option in clang or the enableUndefinedBehaviorSanitizer YES option in xcodebuild. To enable individual sanitizer checks, use the following options:\n\nCompiler flag\n\n\t\n\nUBSan check\n\n\n\n\n-fsanitize=alignment\n\n\t\n\nMisaligned pointer\n\n\n\n\n-fsanitize=bool\n\n\t\n\nInvalid Boolean value\n\n\n\n\n-fsanitize=bounds\n\n\t\n\nOut-of-bounds array access\n\n\n\n\n-fsanitize=enum\n\n\t\n\nInvalid enumeration value\n\n\n\n\n-fsanitize=vptr\n\n\t\n\nDynamic type violation\n\n\n\n\n-fsanitize=integer-divide-by-zero\n\n\t\n\nDivision by zero\n\n\n\n\n-fsanitize=float-divide-by-zero\n\n\t\n\nDivision by zero\n\n\n\n\n-fsanitize=float-cast-overflow\n\n\t\n\nInvalid float cast\n\n\n\n\n-fsanitize=nonnull-attribute\n\n\t\n\nNonnull argument violation\n\n\n\n\n-fsanitize=nullability-arg\n\n\t\n\nNonnull argument violation\n\n\n\n\n-fsanitize=nullability-assign\n\n\t\n\nNonnull variable assignment violation\n\n\n\n\n-fsanitize=returns-nonnull-attribute\n\n\t\n\nNonnull return value violation\n\n\n\n\n-fsanitize-nullability-return\n\n\t\n\nNonnull return value violation\n\n\n\n\n-fsanitize=null\n\n\t\n\nNull reference creation and null pointer dereference\n\n\n\n\n-fsanitize=object-size\n\n\t\n\nInvalid object size\n\n\n\n\n-fsanitize=shift\n\n\t\n\nInvalid shift\n\n\n\n\n-fsanitize=signed-integer-overflow\n\n\t\n\nInteger overflow\n\n\n\n\n-fsanitize=unreachable\n\n\t\n\nReaching of unreachable point\n\n\n\n\n-fsanitize=vla-bound\n\n\t\n\nInvalid variable-length array\n\nThe Undefined Behavior Sanitizer tool inserts diagnostics into your code at compile time. The nature of these checks differs according to the type of operation. For example, before performing a mathematical operation on an integer value, the tool adds a check to determine if the operation triggers an integer overflow.\n\nThe performance impact of Undefined Behavior Sanitizer is minimal. The tool adds an average of 20% CPU overhead to the debug version of your app.\n\nTopics\nAddress Sanitizer\nUse of deallocated memory\nDetects the use of deallocated memory.\nDeallocation of deallocated memory\nDetects attempts to free deallocated memory.\nDeallocation of nonallocated memory\nDetects attempts to free nonallocated memory.\nUse of stack memory after function return\nDetects when you access stack variable memory after its declaring function returns.\nUse of out-of-scope stack memory\nDetects access to variables outside of their declared scope.\nOverflow and underflow of buffers\nDetects when you access memory outside of a buffer’s boundaries.\nOverflow of C++ containers\nDetects when you access a C++ container outside its bounds.\nThread Sanitizer\nData races\nDetects unsynchronized access to mutable state across multiple threads.\nSwift access races\nDetects unsynchronized access to mutable state across multiple threads in Swift.\nRaces on collections and other APIs\nDetects when one thread accesses a mutable object while another thread is writing to it.\nUninitialized mutexes\nDetects when you use an uninitialized mutex.\nThread leaks\nDetects when you don’t close threads after use.\nUndefined Behavior Sanitizer\nMisaligned pointer\nDetects when code accesses a misaligned pointer or creates a misaligned reference.\nInvalid Boolean value\nDetects when a program accesses a Boolean variable and its value isn’t true or false.\nOut-of-bounds array access\nDetects out-of-bounds access of arrays.\nInvalid enumeration value\nDetects when an enumeration variable has an invalid value.\nReaching of unreachable point\nDetects when a program reaches an unreachable point.\nDynamic type violation\nDetects when an object has the wrong dynamic type.\nInvalid float cast\nDetects out-of-range casts to, from, or between floating-point types.\nDivision by zero\nDetects division where the divisor is zero.\nNonnull argument violation\nDetects when an argument incorrectly receives a null value.\nNonnull return value violation\nDetects when a function incorrectly returns null.\nNonnull variable assignment violation\nDetects when you incorrectly assign null to a variable.\nNull reference creation and null pointer dereference\nDetects the creation of null references and null pointer dereferences.\nInvalid object size\nDetects invalid pointer casts due to differences in the sizes of types.\nInvalid shift\nDetects invalid and overflowing shifts.\nInteger overflow\nDetects overflow in arithmetic.\nInvalid variable-length array\nDetects negative array bounds.\nSee Also\nDebugging strategies\nDiagnosing issues in the appearance of a running app\nInspect your running app to investigate issues in the appearance and placement of the content it displays.\nDetecting when your app contacts domains that may be profiling users\nUse Instruments to assess whether your app or its third-party SDKs connect to domains that may profile users."
  },
  {
    "title": "Source code management setup | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/source-code-management-setup",
    "html": "Overview\n\nWith Xcode Cloud, you can adopt a CI/CD practice that helps you develop and maintain your apps and frameworks. For Xcode Cloud to automatically build and test your code when you make changes, provide a continuous secure HTTPS connection on port 443 to the Git repository that contains your code.\n\nWhen you configure your workspace or project to use Xcode Cloud, Xcode analyzes it to detect the Source Code Management (SCM) provider you use. On the “Grant Access to Your Source Code” sheet, click Grant Access and let Xcode guide you through your SCM provider’s native authorization flow.\n\nMake sure you have the required permission or role to grant Xcode Cloud access to your Git repository. Additionally, if you use a self-hosted SCM provider — for example, Bitbucket Server — make sure Xcode Cloud can access your Git repository. For information on required permissions, roles, and IP address ranges that Xcode Cloud uses, see Source control requirements.\n\nNote\n\nXcode Cloud comes with support for Git LFS.\n\nTopics\nBitbucket Cloud and Bitbucket Server\nConnecting Xcode Cloud to Bitbucket Cloud\nAllow Xcode Cloud to access your Bitbucket Cloud repository.\nConnecting Xcode Cloud to Bitbucket Server\nAllow Xcode Cloud to access your Bitbucket Server repository.\nGitHub and GitHub Enterprise\nConnecting Xcode Cloud to GitHub\nAllow Xcode Cloud to access your GitHub repository.\nConnecting Xcode Cloud to GitHub Enterprise\nAllow Xcode Cloud to access your GitHub Enterprise repository.\nGitLab\nConnecting Xcode Cloud to GitLab\nAllow Xcode Cloud to access your GitLab repository.\nConnecting Xcode Cloud to a self-managed GitLab instance\nAllow Xcode Cloud to access your self-managed GitLab repository.\nSee Also\nSource code management\nConfiguring requirements for merging a pull request\nProtect stable branches by requiring a successful Xcode Cloud build or action before it’s possible to merge a pull request."
  },
  {
    "title": "Improving app responsiveness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/improving-app-responsiveness",
    "html": "Overview\n\nAn app that responds instantly to users’ interactions gives an impression of supporting their workflow. When the app responds to gestures and taps in real time, it creates an experience for users that they’re directly manipulating the objects on the screen. Apps with a noticeable delay in user interaction (a hang) or movement on screen that appears to jump (a hitch), shatter that illusion. This leaves the user wondering whether the app is working correctly. To avoid hangs and hitches, keep the following rough thresholds in mind as you develop and test your app.\n\n< 100 ms\n\nSynchronous main thread work in response to a discrete user interaction.\n\n< 1 display refresh interval (8 or 17ms)\n\nMain thread work and work to handle continuous user interaction.\n\nWork performed on the main thread influences both the delay between an incoming user event and the corresponding screen update as well as the maximum frequency of screen updates.\n\nIf a delay in discrete user interaction becomes longer than 100 ms, it starts to become noticeable and causes a hang. Other stages of the event handling and rendering pipeline contribute to the overall delay. Assume that less than half that time is available for your app’s main thread to do its work. A shorter delay is rarely noticeable.\n\nFor fluid, uninterrupted motion, a new frame needs to be ready whenever the screen updates. On Apple devices, this can be as often as 120 times per second, or every 8.3 ms. Another common display refresh rate for Apple devices is 60Hz, so one update every 16.7ms. Depending on system conditions and other work that your app performs, you might not have the full display refresh interval to prepare your next screen update. If the work that your app needs to perform on the main thread to update the screen is less than 5 ms, the update is usually ready in time. If it takes longer, you need to take a closer look at the specific devices you’re targeting and the display refresh rate your app needs to support. Look at the section on hitches below for tools and guidelines to determine whether you are meeting the appropriate responsiveness thresholds.\n\nSimilarly, avoid scheduling work that does not have to execute on the main thread on the main thread, not even asynchronously, e.g. via dispatch_async or awaiting the result of a function call on the main actor. As you have no control over when exactly the main thread processes your work or what the user might be doing at the time, it might come in in the middle of a continuous user interaction and cause a hitch.\n\nNote\n\nThe thresholds above are very rough guidelines to give you an understanding what execution times to aim for. There are more nuances about various interaction scenarios and sometimes you have more leeway. To learn more about these cases, the difference between hitches and hangs, how the rendering loop works, and how Apple’s developer tools detect each type of unresponsiveness, see Understanding user interface responsiveness.\n\nThis article describes several best practices to help you avoid introducing hangs and hitches in your app, as well as multiple tools to help you detect and analyze these types of responsiveness issues.\n\nAvoid hangs by keeping the main thread free from non-UI work\n\nMake sure your app uses the main thread only to interact with the user interface (UIKit, AppKit, or SwiftUI). Direct all other operations to a background thread, operation queue, or Grand Central Dispatch queue. To learn more about hangs and why it’s essential to keep the main thread free from non-UI work, see Understanding hangs in your app.\n\nWith Swift concurrency, make sure not to accidentally execute work on the MainActor. The correct approach to get work off of the main actor depends on whether you can refactor the heavy work into a non-actor-isolated asynchronous function. If you can wrap the long-running work in such a way to make it async and nonisolated, it’s easy to execute it off of the main actor with a Task and await. If this isn’t possible, execute the synchronous function inside a call to the Task.detached(priority:operation:) method.\n\nBelow there are three almost identical code examples. The first one shows how to correctly get off of the main actor if you can wrap the long-running work in a nonisolated async function. The second example shows a common mistake where the code looks as if it avoids the hang, but doesn’t. This example just causes a hang a little later due to a Task implicitly inheriting the actor-constraint from its surrounding context. The last example shows how to break this implicit actor-constraint inheritance by using a detached Task instead. The subtle differences in these examples cause completely different execution behavior. Be aware of these in your own Swift concurrency code.\n\nThe following code example shows how to successfully get your long-running work off of the main actor if the long-running function is async and nonisolated, or if you can wrap it in such a function:\n\nimport SwiftUI\n\n\nstruct ContentView: View {\n    var body: some View {\n        Button(\"I don't hang\") {\n            Task { \n                await doLongRunningWork()\n                updateUI()\n            }\n        }\n    }\n    @MainActor func updateUI() { /* ... */ }\n}\nprivate func doLongRunningWork() async { /* a lot of work */ } // Implicitly nonisolated due to being a free function\n\n\nCreating a Task in the above example allows the button action to return immediately, before the new task finishes executing. Specifically, the Task itself inherits the actor from its enclosing context and does execute on the main actor. Beginning with Swift 5.7, Swift executes nonisolated, asynchronous functions, like doLongRunningWork() in the example above, on the concurrency thread pool, off of any actors. Then execution of the updateUI() function returns to the main actor because it’s part of a Task constrained to the main actor. This is exactly what we want to happen.\n\nNote\n\nFor more information about how actors and tasks interact, and the circumstances under which isolated/nonisolated, synchronous/asynchronous functions execute on and off of an actor, see Eliminate data races using Swift concurrency.\n\nBoth the nonisolated aspect of the function and the async nature of it are essential for enabling this behavior. When the long-running work only executes synchronously, it is not enough to wrap it in a Task. For example, the following code produces a hang:\n\n// This code produces a hang. This is only for illustration purposes.\nimport SwiftUI\n\n\nstruct ContentView: View {\n    var body: some View {\n        Button(\"Hang later!\") {\n            // Don't do this. Use Task.detached {} instead or make `doLongRunningWork()` async.\n            Task {\n                doLongRunningWork()\n                updateUI()\n            }\n        }\n    }\n}\nprivate func doLongRunningWork() { /* a lot of work */ } // Nonisolated, but synchronous.\n\n\nNote that this is almost the exact code as in the previous example, except that doLongRunningWork() isn’t async, so there isn’t an await keyword before the function call. This does create a separate Swift concurrency task and allows the button’s action to return quickly without blocking the UI. However, the created task inherits the context from its enclosing context because the body property on the SwiftUI View is annotated with @MainActor, meaning it must execute on the main actor.\n\nBy default, tasks inherit their context from their enclosing context during creation. Therefore, the newly created task in the body property’s context is also constrained to the main actor, which means it can only execute on the main actor and does still block the main actor for a long amount of time. This just delays the hang until after the immediate button action finishes. Swift concurrency enqueues the task on the main actor and executes it there shortly after, which keeps the main thread busy and prevents it from handling incoming events.\n\nIf making the function async isn’t an option, wrap it in a detached task to explicitly opt out from inheriting the surrounding execution context.\n\nimport SwiftUI\n\n\nstruct ContentView: View {\n    var body: some View {\n        Button(\"Hang in UI interaction\") {\n            Task.detached {\n                doLongRunningWork()\n                await updateUI()\n            }\n        }\n    }\n}\nprivate func doLongRunningWork() { /* a lot of work */ } // Nonisolated, but synchronous.\n\n\nThis is also often appropriate for background work that can execute at a lower priority and doesn’t need to update the UI when it finishes. Choosing a detached task ensures that the task doesn’t inherit the actor context, so it can execute on any thread in the thread pool. Another difference from the previous example is that the entire task executes outside of the main actor, instead of just the one async function. Also note that the code calls updateUI() using the await keyword because the detached task doesn’t execute on the main actor, so main-actor-constrained functions must execute asynchronously.\n\nBe aware of the default priority propagation rules. A detached task doesn’t inherit any priority from its creation context and executes only with .medium priority, by default. Consider choosing a more appropriate priority using .detached(priority: .background) or a similar quality-of-service level.\n\nNote\n\nSee Visualize and optimize Swift concurrency to learn how to use Instruments to detect when your Swift concurrency tasks execute on the main actor.\n\nWhen using dispatch queues or manual thread management, dispatch the work to a background queue or thread asynchronously, and have it asynchronously signal the main thread or queue to update the UI when its background work finishes. Don’t synchronize the main thread with a background thread, or make the main thread join a background thread. Both of these actions block the main thread until the work in the background completes, which denies your app the benefit of concurrent operation.\n\nAnalyze which parts of your app need to execute on the main thread and which don’t\n\nGenerally, separate your UI updates into preparing data for display, and updating view objects to display that data when the view redraws. Your app can do the preparation in the background, and only needs to use the main thread to update its views. Indicate to the user that this preparation is underway, giving them the opportunity to cancel or perform other tasks as appropriate.\n\nFor example, a particular app uses a UIRefreshControl to allow the user to pull a table view down to refresh its content from the network. The valueChanged event on the UIRefreshControl triggers an action method on the app’s UIViewController subclass. When UIKit invokes this action method, the app makes a request to the server using URLSession and NSURLDataTask. On completion of the network task, the app checks whether the download succeeds. If it does, the app deserializes a JSON object from the downloaded data, updates properties on its model objects based on the fields in the JSON object, and reconfigures its view to reflect the updated model.\n\nOf all of these tasks, only the action method invocation from UIKit and the reconfiguration of the app’s views need to use the main thread. The app can dispatch all other tasks asynchronously to the background, as the image below shows:\n\nUse high-level concurrency constructs to avoid having too many threads\n\nAs the number of threads running on the device increases, the operating system schedules each thread less often on a CPU core. Any individual thread, including your app’s main thread, runs on a core for less time. So, it’s important to avoid creating too many threads to keep the system performant.\n\nSwift concurrency, Dispatch, and OperationQueue all maintain an internal pool of worker threads that’s tuned to the device capacity and load. Use these technologies, instead of creating your own background threads, to ensure balance between scheduling as much work as possible and allowing the operating system to run other threads, including the main thread and operating system tasks.\n\nAvoid hitches by minimizing view update time\n\nTo provide smooth animations that look like continual motion, Apple devices update the screen up to 120 times per second. When your app is in the foreground, the drawing code on the main thread needs to complete before the next frame is needed to avoid dropping frames and appearing jerky. Taking a long time to draw a frame can cause a hitch.\n\nUse standard views wherever possible to ensure efficient view drawing. Where you need a custom view or control to provide functionality unavailable from standard components, ensure that its draw(_:) method draws only into the specified rectangle. Rely on previously prepared data in draw(_:), don’t perform I/O or complex calculations in this method. Draw only into the rectangle that passes as an argument to draw(_:) to avoid expensive computations on view components that don’t draw to the screen.\n\nUIKit and AppKit only invoke a view’s draw(_:) method to update the view for a frame if there’s a call to its setNeedsDisplay() method after the most recent call to draw(_:). Only call setNeedsDisplay() when the view’s representation needs updating.\n\nOptimize your app for variable refresh rates\n\nIf your app interacts with the graphics system directly, such as when you do your own rendering, be aware of variable refresh rate displays. If you’re only using high-level UI APIs like SwiftUI, UIKit, and AppKit, those frameworks take care of adapting animations, and similar rendering work, to the display’s refresh rate. If you can’t ensure that the work necessary to prepare the next frame completes within ~5 ms, or your app can adapt its rendering performance and detail based on system conditions, consider adapting your app for variable refresh rates.\n\nIn general, it’s better to aim for a slightly lower refresh rate that your app can consistently achieve than attempt to meet a higher refresh rate that sometimes misses the frame deadline, because each missed deadline results in a hitch. Use CADisplayLink or CVDisplayLink to ensure you maximize the time for rendering by starting work on the next frame right when a vsync occurs instead of potentially starting in the middle of a vsync interval.\n\nNote\n\nSee Optimizing ProMotion refresh rates for iPhone 13 Pro and iPad Pro to learn more about working with variable refresh rates.\n\nSee Optimize for variable refresh rate displays to learn about the difference between fixed-rate and adaptive-sync displays, and how to make the most of variable refresh rate displays.\n\nWrite performance tests to ensure main-thread-bound code completes fast\n\nFor code that must execute on the main thread, create an XCTest performance test to measure the time your app spends running the code. Execute the relevant code in a measure(_:) block. You can either accept the average runtime of your code block as the baseline, or edit the baseline and set it to 100 ms. The performance test fails if the code requires significantly longer than the baseline time to execute.\n\n100 ms is the maximum delay for discrete user interaction before a delay becomes noticeable. However, be aware that some users are more sensitive to delays, so consider using a lower threshold. Also, remember that code the system runs during continuous user interaction, like table and collection view data source methods, must finish much more quickly. Consider using a limit of 5 ms for such code.\n\nNote\n\nSee Eliminate animation hitches with XCTest to learn how to use the XCTOSSignpostMetric to write performance tests measuring the hitch ratio, number of hitches, and similar metrics for a piece of code.\n\nDetect hangs and hang risks\n\nThere are various tools you can use to detect hangs proactively during development, both when you implement a new feature or make a change to an existing part of your app. These tools are also useful to track down a reported issue for a released version of your app.\n\nTurn on the Thread Performance Checker in your app’s scheme to receive notifications of priority inversions when you run your app from Xcode. Learn more at Diagnosing performance issues early.\n\nEnable on-device hang detection by opening the Settings app and navigating to Developer > Hang Detection. This notifies you of hangs that occur in apps on your device while you’re using it. Your iOS device captures a hang report that you can then analyze on your Mac. On-device hang detection works for development-signed builds and TestFlight builds on your iOS device.\n\nUse the Time Profiler, CPU Profiler, or Hang Tracing instruments in Instruments to profile your app proactively. All these instruments have specific hang-detection features that display any hangs they encounter during the recording and allow you to analyze them further. Hang detection in Instruments was introduced in Instruments 14, and requires macOS 13, iOS 16, tvOS 16, or watchOS 9, or later.\n\nFind the cause of a hang\n\nApps hang because the main thread isn’t available when it’s time for the app to draw to the screen. This can happen for two reasons: either the main thread is busy executing code, or it’s blocked waiting for a resource to become available or for a system call to complete. Use the Thread State Trace instrument to discover which situation causes hangs in your app.\n\nThe Thread State Trace instrument shows a timeline of the thread’s state, along with a narrative that details the system calls, how long they take, and when iOS schedules the thread to run. Combine this information with the System Call Trace instrument, which gives summary statistics of the number and duration of system calls that each thread makes, to see whether system calls are blocking your main thread.\n\nClick a particular invocation of a system call in the narrative to view a backtrace for the execution of that system call. Use this information to find out which functions or methods on the main thread cause it to hang.\n\nDetect and analyze hitches using Instruments\n\nTo proactively look for hitches, or to investigate a specific hitch you’re trying to fix, use the Animation Hitches template in Instruments. Start Instruments, select your app and the Animation Hitches template, and click the Record button. Then use the feature in your app that you want to investigate, and Instruments highlights any hitches that occur.\n\nGet into a habit of profiling your code using the Animation Hitches template whenever you make a change that may affect scrolling or animation behavior. Just a few milliseconds of delay can cause a hitch, so small performance differences can have a big impact. To make sure you get realistic measurements, it’s best to run your app on a real device when looking for hitches with Instruments. Also, consider using older devices that your app supports to make it easier to find issues.\n\nTo learn more about how to analyze and fix different types of hitches using Instruments, see Find and fix hitches in the commit phase and Demystify and eliminate hitches in the render phase.\n\nGet reports and metrics from the field\n\nPrerelease testing doesn’t always capture all possible issues a user may encounter. In some cases, hangs and hitches in your app escape prerelease testing and make it into the released app. Xcode Organizer bridges the gap between prerelease and postrelease by providing diagnostics for issues users are most frequently experiencing when using your app.\n\nTo get a better understanding of how your released app performs, and how many hangs and hitches your users experience, view aggregated data in Xcode Organizer or collect reports using your own infrastructure and MetricKit.\n\nThe operating systems on Apple devices monitor for hangs and hitches for running apps, and employ population subsampling to periodically collect reports for these issues. For more information about analyzing the hangs and hitches your users are experiencing, see Analyzing responsiveness issues in your shipping app.\n\nSee Also\nRelated Documentation\nAnalyzing the performance of your shipping app\nView power and performance metrics for apps you distribute through the App Store.\nTrack down hangs with Xcode and on-device detection\nExplore UI animation hitches and the render loop\nFind and fix hitches in the commit phase\nDemystify and eliminate hitches in the render phase\nEliminate animation hitches with XCTest\nResponsiveness\nUnderstanding user interface responsiveness\nMake your app more responsive by examining the event-handling and rendering loop.\nUnderstanding hangs in your app\nDetermine the cause for delays in user interactions by examining the main thread and the main run loop.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing terminations in your app\nMinimize how frequently the system stops your app by addressing common termination reasons.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage."
  },
  {
    "title": "Preparing your app to be the default web browser | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/preparing-your-app-to-be-the-default-browser",
    "html": "Overview\n\nIn iOS 14 and later, users can select an app to be their default web browser. To make your app a choice, confirm that your app meets the requirements below, then request a managed entitlement.\n\nConfigure your app to be a default browser\n\nThe system invokes the default web browser in iOS whenever the user opens an HTTP or HTTPS link. Because this app becomes the user’s primary gateway to the internet, Apple requires that web browsing apps meet specific functional criteria to protect user privacy and ensure proper access to internet resources.\n\nApps express their capability to be a default web browser by using the com.apple.developer.web-browser managed entitlement. Request permission to use this entitlement by emailing default-browser-requests@apple.com. This starts the process of generating the necessary signing permission for your app.\n\nFulfilling default browser requirements\n\nApps that register as a default web browser option must satisfy the following criteria:\n\nYour app must specify the HTTP and HTTPS schemes in its Info.plist file.\n\nYour app can’t use UIWebView.\n\nOn launch, the app must provide a text field for entering a URL, search tools for finding relevant links on the internet, or curated lists of bookmarks.\n\nWhen opening an HTTP or HTTPS URL in its default configuration:\n\nThe app must navigate directly to the specified destination and render the expected web content. Apps that redirect to unexpected locations or render content not specified in the destination’s source code don’t meet the requirements of a default web browser.\n\nApps designed to operate in a parental controls or locked down mode may restrict navigation to comply with those goals.\n\nYour app may present a “Safe Browsing” or other warning for content suspected of phishing or other problems.\n\nYour app may offer a native authentication UI for a site that also offers a native web sign-in flow.\n\nUsing default browser capabilities\n\nApps that use the com.apple.developer.web-browser managed entitlement can:\n\nBe an option for the user to choose as their default browser.\n\nLoad pages from all domains with full script access.\n\nUse Service Workers in WKWebView instances.\n\nOffer the Add to Home Screen action in a share sheet by including the current WKWebView in the activityItems array when creating a UIActivityViewController.\n\nAdhering to browser restrictions\n\nApps that have the com.apple.developer.web-browser managed entitlement may not claim to respond to Universal Links for specific domains. The system will ignore any such claims. Apps with the entitlement can still open Universal Links to other apps as usual.\n\nBecause of their privileged position in a user’s web browsing, browser apps should avoid unnecessary access to personal data. Apps that use any of the following Info.plist keys while using the com.apple.developer.web-browser managed entitlement will be rejected:\n\nNSPhotoLibraryUsageDescription — For saving images, your app should only specify NSPhotoLibraryAddUsageDescription. WKWebView can still upload photos and files without your app needing access to a user’s entire photo library. To access individual photos your app should use PHPickerViewController which doesn’t require NSPhotoLibraryUsageDescription, instead of UIImagePickerController.\n\nNSLocationAlwaysUsageDescription, NSLocationAlwaysAndWhenInUseUsageDescription — For determining the user’s location, request while in-use authorization instead (NSLocationWhenInUseUsageDescription). Browsers are restricted from always-on location access.\n\nNSHomeKitUsageDescription — Browsers can’t access the user’s HomeKit database.\n\nNSBluetoothAlwaysUsageDescription — Browsers can’t poll for Bluetooth devices when the app is in the background. Browsers should use NSBluetoothWhileInUseUsageDescription for Bluetooth features.\n\nNSHealthShareUsageDescription, NSHealthUpdateUsageDescription — Browsers can’t access the user’s health database.\n\nNote\n\nNSLocationAlwaysUsageDescription was deprecated in iOS 10. For more information, see Choosing the Location Services Authorization to Request."
  },
  {
    "title": "Gathering information about memory use | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/gathering-information-about-memory-use",
    "html": "Overview\n\nXcode and Instruments provide multiple tools for observing and exploring memory use in an app.\n\nReview the memory report\n\nWhile your app is running in Xcode, the memory report available from Xcode’s Debug navigator shows the app’s current memory use, along with the highest value seen. The yellow region of the memory gauge indicates memory use high enough to trigger a warning. The app risks termination by iOS if its memory use enters the red region.\n\nTip\n\nIf iOS repeatedly terminates your app because it’s using too much memory, you can investigate its behavior in the simulator, where it can continue to run. When you run your app in the simulator, the memory gauge always stays in the green (safe) region because macOS doesn’t issue memory warnings or out-of-memory terminations. This behavior has advantages in diagnosing problems associated with too much memory use. But keep in mind that memory use in the green region of the gauge in the simulator doesn’t necessarily mean that your app’s memory use is within safe limits.\n\nInspect the debug memory graph\n\nYou can generate a memory graph of the objects and allocations in your app by clicking the Debug Memory Graph button in Xcode’s debug area at the bottom of the workspace window.\n\nThe memory graph shows the memory regions your app is using and the size of each region. A node in the graph represents an object, a heap allocation, or a memory-mapped file. Connections between nodes, drawn as arrows, show where one memory region refers to another.\n\nThe memory graph shows where your app is using memory and how those uses are related. You can augment the graph with allocation stack traces, so that each region is associated with a call stack trace recorded at the point at which the region was allocated.\n\nTo turn on allocation stack traces, check the Malloc Stack box in the Diagnostics area of your scheme’s Run settings. With allocation stack traces enabled, the inspector for a node in the memory graph shows the stack trace recorded when that node was allocated. Use this information to associate memory allocations in the memory graph with functions and methods in your app’s source code.\n\nTo export memory graphs from Xcode, choose File > Export Memory Graph. You can share exported memory graphs with team members or explore using command-line tools, including vmmap and leaks. For more information about the command-line tools, see WWDC 2018 session 416, iOS Memory Deep Dive.\n\nProfile your app using the Allocations instrument\n\nThe Allocations instrument tracks the size and number of all heap and anonymous virtual memory (VM) allocations and organizes them by category. Use the Allocations instrument’s timeline to investigate how the total amount of memory that your app has allocated increases and decreases as you use the app’s interface. Use the statistics view to see what categories of allocations are being made, how many allocations have been made in each category, and the sizes of those allocations. Click the arrow next to a category name to see the individual allocations made in that category, along with the time at which the memory was allocated and the code responsible for the allocation.\n\nThe Generations view in the Allocations instrument is useful for investigating memory use for a particular feature of your app. Launch your app, and prepare to use the feature under investigation—for example, by navigating to the view with a particular control. Next, click the Mark Generation button in the Allocations instrument. Activate the feature in your app, and click Mark Generation again. Instruments organizes memory allocations by generation, separated at the times when you clicked Mark Generation. You can isolate memory allocations that occurred during the time that you were using the feature. Not all allocations recorded during this time are associated with the feature you’re studying, but many unrelated allocations that didn’t occur between the generation marks are removed from consideration.\n\nSee Also\nRelated Documentation\nIdentifying high-memory use with jetsam event reports\nDiscover why the operating system terminated your app when available memory was low.\nMemory and size\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nReducing your app’s size\nMeasure your app’s size, optimize its assets and settings, and adopt technologies that help streamline installation over a mobile internet connection.\nMaking changes to reduce memory use\nDecrease your app’s use of memory by addressing common causes of excessive use.\nPreventing memory-use regressions\nMeasure the memory that your app’s features use, and detect increases by using XCTest performance tests.\nResponding to low-memory warnings\nDetect when your app is using excessive memory, and bring memory use under control."
  },
  {
    "title": "Customizing the build schemes for a project | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/customizing-the-build-schemes-for-a-project",
    "html": "Overview\n\nWhen you build, run, test, profile, or archive part of your project, Xcode uses the selected build scheme to determine what to do. A build scheme contains a list of targets to build, and any configuration and environment details that affect the selected action. For example, when you build and run an app, the scheme tells Xcode what launch arguments to pass to the app. Xcode provides default schemes for most targets, and you can customize those schemes or create new ones as needed.\n\nTo view your project’s current schemes, click the scheme name in the toolbar of your project window. Xcode displays a pop-up menu with a list of current schemes at the top, and commands to edit, create, and manage schemes at the bottom.\n\nTo view and modify your project’s current schemes, select Manage Schemes. For example, disable automatic creation of schemes for new targets, and change scheme attributes such as which project contains the scheme. By default, Xcode shares schemes with other team members.\n\nSpecify the build options for a scheme’s targets\n\nWhen you tell Xcode to build a scheme, Xcode analyzes your project and generates the list of tasks required to build the targets of that scheme. To speed up builds, Xcode executes as many tasks as possible in parallel, taking advantage of whatever resources are available. To ensure that products build correctly, Xcode serializes tasks when dependencies exist between them. For example, Xcode builds a private framework before it builds the app that links against that framework.\n\nTo see a scheme’s current list of targets, edit the scheme and select the Build page. Use this page to add or remove targets and to configure additional build options.\n\nThe following table lists the build options you can configure for your schemes.\n\nBuild option\n\n\t\n\nDescription\n\n\n\n\nDependency Order\n\n\t\n\nBuild targets in parallel according to their dependencies. Choose this option, not Manual Order.\n\n\n\n\nManual Order\n\n\t\n\nBuild targets serially in the order listed in the scheme, underutilizing your Mac’s multiple processors. This option is deprecated. Don’t use it.\n\n\n\n\nFind Implicit Dependencies\n\n\t\n\nGather information about additional dependencies during a build. The build system uses this information to help schedule build-related tasks.\n\nSpecify launch arguments and environment variables\n\nIf your product configures itself using command-line arguments or environment variables, specify that information on the Arguments tab of the Run, Test, or Profile build scheme action.\n\nXcode configures and exports environment variables before it runs the process.\n\nXcode passes command-line arguments directly to the launched process.\n\nConfigure the runtime environment for built products\n\nIn the Run, Test, and Profile build scheme actions, the Info tab contains high-level information about how to launch and run your product. Some options are available for all build actions, but some options are specific to the current build action. The following table lists the available options.\n\nAction\n\n\t\n\nAttribute\n\n\t\n\nDescription\n\n\n\n\nRun, Test, Profile\n\n\t\n\nBuild Configuration\n\n\t\n\nUse configurations to allow a project to customize its build settings based on the configuration name. A debug configuration typically disables code optimizations for faster builds and enables the generation of debugging information. A release configuration enables code optimizations for better runtime performance and disables the generation of debugging information to reduce app size.\n\n\n\n\nRun, Profile\n\n\t\n\nExecutable\n\n\t\n\nThe executable to run after a successful build. For an app, this attribute contains the app itself. For other products, specify the app to launch.\n\n\n\n\nRun, Test\n\n\t\n\nDebug Executable\n\n\t\n\nAn option to attach the debugger at launch time.\n\n\n\n\nRun\n\n\t\n\nSiri Intent Query\n\n\t\n\nThe string to feed to Siri to initiate a query. Leave this field blank to initiate queries on the device using the Siri interface.\n\n\n\n\nRun, Test\n\n\t\n\nLLDB Init File\n\n\t\n\nThe LLDB settings file to load. Specify command aliases and other debugger-related settings.\n\n\n\n\nRun\n\n\t\n\nLaunch\n\n\t\n\nThe launch behavior. Typically, Xcode launches apps automatically after a successful build, but you can specify a different time to launch the app.\n\n\n\n\nTest\n\n\t\n\nDebug Process As\n\n\t\n\nThe system account to use for debugging.\n\n\n\n\nProfile\n\n\t\n\nInstrument\n\n\t\n\nThe performance metrics to gather in the Instruments app.\n\nXcode uses information in the Options tab to configure the runtime environment for a product. Use these options to override language settings or specify simulated device data such as the current location. The following table lists the available options.\n\nAction\n\n\t\n\nAttribute\n\n\t\n\nDescription\n\n\n\n\nRun\n\n\t\n\nCore Location\n\n\t\n\nOptions to simulate location data. Select a default starting location from the pop-up menu.\n\n\n\n\nRun\n\n\t\n\nApp Data\n\n\t\n\nAn .xcappdata package that contains the initial contents of the app’s container directory. Create app data packages from the Devices and Simulators window. Install the app on your device so that it appears in the window. Select the app and use the controls to download the app’s current container. Modify the contents of the downloaded .xcappdata file as needed, and add the file to your project.\n\n\n\n\nRun\n\n\t\n\nRouting App Coverage File\n\n\t\n\nA GeoJSON file that defines the geographical region the app covers.\n\n\n\n\nRun\n\n\t\n\nStoreKit Configuration\n\n\t\n\nA .storekit data file that contains the items your app makes available for purchase. Use this file to test your app’s StoreKit support. For more information, see Setting up StoreKit Testing in Xcode\n\n\n\n\nRun\n\n\t\n\nGPU Frame Capture\n\n\t\n\nAn option to capture diagnostic information about your app’s Metal usage. For more information, see Capturing a Metal workload in Xcode.\n\n\n\n\nRun\n\n\t\n\nBackground Fetch\n\n\t\n\nAn option to simulate the app’s launch from a background event. Use this option to test your background execution workflows.\n\n\n\n\nRun\n\n\t\n\nLocalization Debugging\n\n\t\n\nAn option to highlight nonlocalized strings in your app.\n\n\n\n\nRun, Test\n\n\t\n\nApp Language\n\n\t\n\nThe language to use during testing. Select System Language to use the device’s default language.\n\n\n\n\nRun, Test\n\n\t\n\nApp Region\n\n\t\n\nThe locale to use during testing. Select System Region to use the device’s default region.\n\n\n\n\nRun\n\n\t\n\nXPC Services\n\n\t\n\nOptions to debug XPC services.\n\n\n\n\nRun\n\n\t\n\nView Debugging\n\n\t\n\nAn option to collect information about an app’s view hierarchies.\n\n\n\n\nRun\n\n\t\n\nQueue Debugging\n\n\t\n\nAn option to record backtraces for dispatch queues.\n\n\n\n\nRun\n\n\t\n\nInterface Builder\n\n\t\n\nAn option to attach automatically to remote tools.\n\n\n\n\nTest\n\n\t\n\nUI Testing\n\n\t\n\nOptions to capture screenshots as part of testing your product’s UI.\n\n\n\n\nTest\n\n\t\n\nAttachments\n\n\t\n\nAn option to delete attachments when a test succeeds.\n\n\n\n\nTest\n\n\t\n\nCode Coverage\n\n\t\n\nAn option to gather code coverage metrics for your test targets.\n\n\n\n\nProfile\n\n\t\n\nTestability\n\n\t\n\nAn option to enable testability when profiling tests.\n\nRun diagnostics on your target\n\nXcode includes tools to validate the stability of your code and eliminate potential bugs. These tools annotate your code with runtime checks that examine specific types of operations. For example, one tool detects potential race conditions between your app’s threads. Enable these checks from the Diagnostics tab of your build scheme.\n\nThe following table lists the supported diagnostics.\n\nAction\n\n\t\n\nAttribute\n\n\t\n\nDescription\n\n\n\n\nRun, Test\n\n\t\n\nRuntime Sanitization\n\n\t\n\nOptions to detect memory corruption, race conditions, and code that yields undefined results. For more information, see Diagnosing memory, thread, and crash issues early.\n\n\n\n\nRun, Test\n\n\t\n\nRuntime API Checking\n\n\t\n\nAn option to detect system APIs running incorrectly on threads other than the main thread. For more information, see Diagnosing memory, thread, and crash issues early.\n\n\n\n\nRun, Test\n\n\t\n\nMemory Management\n\n\t\n\nOptions to detect buffer overflow and other memory-related errors.\n\n\n\n\nRun\n\n\t\n\nMetal\n\n\t\n\nOptions to validate your app’s usage of Metal APIs and shaders. For more information, see Metal developer workflows.\n\nTo detect memory-related issues, Xcode supports the following diagnostics:\n\nMalloc Scribble writes the value 0x55 to every byte of a released memory block. This action helps you detect code that accesses the released block.\n\nMalloc Guard Edges adds guard pages before and after large allocations. These pages detect code writes beyond the boundaries of an allocated memory block.\n\nGuard Malloc uses several techniques to crash your app at the point where a memory error occurs.\n\nZombie Objects detects code that tries to access an already released object.\n\nMalloc Stack Logging captures function call stack information at the time of each memory allocation.\n\nMemory Graph on Resource Exception captures information about your memory graph. You can view the information in the debugger.\n\nRun tasks before or after scheme actions\n\nFor each action in your scheme, you can run scripts or send emails before or after Xcode performs that action using pre-actions and post-actions. For example, you might use a post-action to log test results to a custom server each time you run your code. Unlike build phases, Xcode executes your actions only when you select the appropriate command from the Product menu.\n\nTo add a pre-action or post-action:\n\nClick the disclosure triangle for the action.\n\nSelect Pre-actions or Post-actions\n\nClick the Add button (+) and select the type of action to add.\n\nConfigure the details of the action.\n\nFor script actions, Xcode exposes the build settings for one of the scheme’s selected targets. Use environment variables to access the values of those variables. For a list of available build settings, see Build settings reference.\n\nSee Also\nBuild customization\nCustomizing the build phases of a target\nSpecify the tasks to perform during a build, including the source files to compile, the scripts to run, and the resources to include in the final product.\nCreating build rules for custom file types\nTell Xcode how to build your project’s custom file types, and provide dependency information to optimize the build process for each file.\nRunning custom scripts during a build\nExecute custom shell scripts during the build process, and run tools or other commands that your project requires.\nRunning code on a specific platform or OS version\nAdd conditional compilation markers around code that requires a particular family of devices or minimum operating system version to run."
  },
  {
    "title": "Exporting localizations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/exporting-localizations",
    "html": "Overview\n\nExport localizations for the languages and regions you’re ready to support. You can export all the files that you need to localize from your Xcode project, or export the files for specific localizations. Optionally, add files to the exported folders to provide context, and then give the files to localizers.\n\nExport localizations using Xcode\n\nIn the Project navigator, select the project, then choose Product > Export Localizations. In the dialog that appears, enter a folder name, choose a location, choose the localizations, and click Export.\n\nImportant\n\nTo include all localizable text in your export, enable the Use Compiler to Extract Swift Strings build setting for your project. This setting only impacts Swift strings. Objective-C string extraction works without any additional build settings.\n\nIf you generate screenshots when testing your localizations, provide context for localizers by clicking “Include screenshots” to include the localization-specific screenshots in the Notes folder of the exported files. To filter the screenshots, click Customize, deselect the screenshots you don’t want to include, and click Done.\n\nXcode creates an Xcode Localization Catalog (a folder with a .xcloc file extension) containing the localizable resources for each language and region. You can open and edit this file in Xcode, or use any third-party tool that supports this file type. Xcode manages the localizable strings in your app for you as follows:\n\nExtracts strings from the following file types: source code, storyboard, XIB, .strings, .stringsdict, and Siri intent definition. Adds the extracted strings to a standard XML Localization Interchange File Format (XLIFF) that’s familiar to localizers.\n\nAdds the correct .stringsdict plural variants for each exported language to the XLIFF file.\n\nCreates a strings file for the localizable properties in the information property list file.\n\nCopies all localizable resources into the Source Contents folder to provide context for localizers.\n\nXcode extracts strings that you pass to Text structures, the NSLocalizedString macro, and similar APIs in your code. For example, if you pass a string with a comment to the NSLocalizedString macro, Xcode includes the comment in the XLIFF file.\n\nIn addition, each localization folder in the catalog contains only the resources and assets that you mark as localizable. Prior to localization, the file is a copy of the development language file—a placeholder to provide context for the localizers.\n\nAdd files to the Xcode Localization Catalog\n\nBefore you give the catalog to localizers, you can add additional files to the Notes folders to provide more context. An Xcode Localization Catalog folder contains:\n\nItem\n\n\t\n\nDescription\n\n\n\n\ncontents.json\n\n\t\n\nA JSON file containing metadata about the catalog, such as the development region, the locale, the tool (Xcode) and its version number, and the catalog version number.\n\n\n\n\nLocalized Contents\n\n\t\n\nA folder containing the localizable resources, including an XLIFF file containing the localizable strings.\n\n\n\n\nNotes\n\n\t\n\nA folder containing additional information for localizers, such as screenshots, movies, or text files.\n\n\n\n\nSource Contents\n\n\t\n\nA folder containing the assets to produce the content that provides context for localizers, such as user interface files and other resources.\n\nExport localizations using commands\n\nYou can also export localization files with the xcodebuild command using the -exportLocalizations argument:\n\nxcodebuild -exportLocalizations -project <projectname> -localizationPath <dirpath> [[-exportLanguage <targetlanguage>] ...]\n\nTo include the screenshots you generate while testing localizations, add the -includeScreenshots argument to the above command.\n\nSee Also\nTranslation and adaptation\nCreating screenshots of your app for localizers\nShare screenshots of your app with localizers to provide context for translation.\nEditing XLIFF and string catalog files\nTranslate or adapt the localizable files for a language and region that you export from your project.\nImporting localizations\nImport the files that you translate or adapt for a language and region into your project.\nLocking views in storyboard and XIB files\nPrevent changes to your Interface Builder files while localizing human-facing strings."
  },
  {
    "title": "Improving the speed of incremental builds | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode/improving-the-speed-of-incremental-builds",
    "html": "Overview\n\nThe Xcode build system manages the compilation and linking of the code in targets. Common types of targets include apps, app extensions, frameworks, libraries, and test suites. A simple project might contain only one target, such as the app you want to build. A more complex project might contain multiple targets with interdependencies, such as a private framework and an app that depends on that framework.\n\nAlways ensure that your project’s inter-target dependencies and configuration details are accurate. When you build a target, Xcode does as much work as possible in parallel. Fewer dependencies leads to greater parallelization, but an accurate dependency map is necessary to prevent build and runtime errors. Similarly, providing detailed configuration data helps Xcode schedule build-time tasks correctly and efficiently.\n\nNote\n\nFollowing coding best practices can also improve Xcode’s efficiency during compilation. For more information, see Improving build efficiency with good coding practices.\n\nMeasure the time it takes for each build task\n\nBefore you perform any build optimizations, always gather timing information to see where optimizations might be most effective. Open your project in Xcode and choose Product > Perform Action > Build With Timing Summary to build your target with detailed timing information. To view the timing information for a specific build, select that build in the Report navigator.\n\nNote\n\nTo generate timing information using the xcodebuild command-line tool, pass the -showBuildTimingSummary option to the tool.\n\nThe first time you build your project, Xcode builds everything, but subsequent builds are incremental. For each incremental build, pay particular attention to the preparation section and the specific tasks that Xcode performs for each target.\n\nIf Xcode didn’t build your targets in parallel, open the Scheme Editor for your target and make sure the Build Order option is set to Dependency Order.\n\nLook for extraneous tasks, such as custom scripts, and assess whether Xcode needs to run those scripts during each incremental build.\n\nIf compilation of a particular file takes significantly longer than other files, examine the file to see if header importation issues are causing the delay.\n\nDeclare inputs and outputs for custom scripts and build rules\n\nIf you use custom build scripts in your Xcode projects, make sure Xcode runs those scripts only when needed. You might use scripts to run custom tools, set build-environment variables programmatically, or perform other target-specific tasks. For example, you might use them to generate assets or other resource files from a proprietary data source. By default, Xcode runs custom scripts during every build cycle, including incremental builds. It also executes those scripts serially with respect to other tasks.\n\nIf you don’t need Xcode to run your scripts every time you build a target, provide at least one input file and one output file for the script. Xcode uses a script’s input and output files to determine when to run it. Specifically, Xcode runs your script when any of the following conditions are true:\n\nYour script doesn’t have any input files.\n\nYour script doesn’t have any output files.\n\nYour script’s input files changed.\n\nYour script’s output files are missing.\n\nSpecify input and output files, along with the script itself, in the Run Script build-phase editor. You may specify input and output files individually or in an Xcode file list — a file with an .xcfilelist filename extension that lists the name of each file on a separate line.\n\nYou must still specify an input and output file to prevent Xcode from running the script every time, even if your script doesn’t actually require those files. For a script that requires no input, provide a file that never changes as the input file. For a script with no outputs, create a static output file from your script so Xcode has something to check.\n\nCreate module maps for custom frameworks and libraries\n\nModule maps improve source compilation times by shortening the time it takes to import header files. A module map provides the compiler with a list of headers that the framework contains. When a framework includes a module map, the compiler doesn’t preprocess header files separately for each source file. Instead, it builds a cache of the framework’s symbol information and reuses that cache during subsequent compilations, which saves significant time.\n\nThe system frameworks already include module maps, but you must provide module maps for any custom frameworks in your project. To add a module map, enable the DEFINES_MODULE build setting for your framework or library. Xcode enables this build setting automatically for new frameworks, but you might need to set it for older projects. When enabled, the compiler produces a module map with the contents of your target’s public header files.\n\nImportant\n\nTo obtain the benefit from module maps, always include the framework name in any import statements. If you don’t include the framework name, the compiler can’t determine whether a module map is present. For more information on how to import header files from a module, see Include framework names in import statements.\n\nBefore you create a module map, make sure your framework meets the following requirements:\n\nYour framework’s header files must not rely on any external contextual information. Xcode compiles your module map separately from the rest of your project’s source files. Don’t rely on source-specific information to change the meaning or values of symbols in your headers.\n\nThe module must be self contained. Because Xcode compiles module maps separately, your framework’s header files must include everything they need to compile correctly.\n\nTo get the maximum reuse benefit from module maps, compile your app’s source files with identical build options. Xcode builds your framework’s module map using the same options as the source file that imports that framework. If your app’s source files use different options, Xcode must recompile the module map for each new set of options. Using identical options allows Xcode to reuse the cache in each subsequent source file.\n\nMake sure your target’s dependencies are accurate\n\nVerifying that your targets have accurate dependencies ensures they build correctly and in a timely manner. Out-of-date dependencies might force Xcode to build targets serially when it might have built them in parallel. Missing dependencies might cause correctness issues or even build errors. For example, if your app doesn’t have an explicit dependency to a separate code module, like an app extension, Xcode might build the app with an older version of the module that doesn’t work properly.\n\nWhen you know a dependency exists between two targets in your Xcode project, create an explicit dependency between them. Xcode creates some dependencies automatically based on how you configure your project. For example, when you embed a new framework inside an existing app, Xcode automatically adds the framework to the app’s list of dependencies. At other times, you specify the dependencies yourself using the Dependencies build phase editor, as shown below. Use the + and - buttons to add or remove dependencies for your target.\n\nIf a target depends on code in a different Xcode project, create a reference to that project by dragging it into the navigator pane of your current project. The presence of the other project in the navigator pane gives Xcode the information it needs to track dependencies on items in the other project. Without this reference, Xcode doesn’t know to build your target when the remote project changes.\n\nRefactor your targets to improve parallelism\n\nInter-target dependencies require Xcode to build those targets in a specific order. When a target has many dependencies, or when it depends on large, monolithic modules, Xcode must serialize more tasks. To improve build performance, simplify your target’s dependency list, and break up monolithic targets so that Xcode can do more work in parallel.\n\nConsider the following illustration, which shows an XML engine that depends on a monolithic utilities framework. Although the XML engine relies on only a small portion of the framework, Xcode must rebuild the engine when any part of the framework changes. Breaking up the framework into smaller modules and creating more fine-grained dependencies might eliminate some unnecessary rebuilds. In the refactored version, changes to the utilities framework no longer trigger an automatic rebuild of the XML engine.\n\nWhen one target depends on many child targets, Xcode cannot start to build the target until it finishes all of the children. Consider a single Tests target that executes automated tests on an app, app extension, and private framework. Splitting up the tests by target allows Xcode to run each suite independently as soon as the corresponding target is ready, which increases parallelization.\n\nYou need to decide whether modifications to your project’s targets offer any benefit. Increasing the number of targets can improve parallelization, but it also adds complexity to your project. Always validate any target or dependency changes to ensure your code still builds correctly. In addition, always measure the speed of the resulting builds to verify that the changes lead to tangible improvements.\n\nSee Also\nPerformance\nConfiguring your project to use mergeable libraries\nUse mergeable dynamic libraries to get app launch times similar to static linking in release builds, without losing dynamically linked build times in debug builds.\nImproving build efficiency with good coding practices\nShorten compile times by reducing the number of symbols your code exports and by giving the compiler the explicit information it needs."
  },
  {
    "title": "Supporting universal links in your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/supporting-universal-links-in-your-app",
    "html": "Overview\n\nWhen a user activates a universal link, the system launches your app and sends it an NSUserActivity object. Query this object to find out how your app launched and to decide what action to take.\n\nTo support universal links in your app:\n\nCreate a two-way association between your app and your website and specify the URLs that your app handles. See Supporting associated domains.\n\nUpdate your app delegate to respond when it receives an NSUserActivity object with the activityType set to NSUserActivityTypeBrowsingWeb.\n\nWarning\n\nUniversal links offer a potential attack vector into your app, so make sure to validate all URL parameters and discard any malformed URLs. In addition, limit the available actions to those that don’t risk the user’s data. For example, don’t allow universal links to directly delete content or access sensitive information about the user. When testing your URL-handling code, make sure your test cases include improperly formatted URLs.\n\nUpdate your app delegate to respond to a universal link\n\nWhen the system opens your app as the result of a universal link, your app receives an NSUserActivity object with an activityType value of NSUserActivityTypeBrowsingWeb. The activity object’s webpageURL property contains the HTTP or HTTPS URL that the user accesses. Use NSURLComponents APIs to extract the components of the URL. See the examples that follow.\n\nThis example code shows how to handle a universal link in macOS:\n\nfunc application(_ application: NSApplication,\n                     continue userActivity: NSUserActivity,\n                     restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool\n{\n    // Get URL components from the incoming user activity.\n    guard userActivity.activityType == NSUserActivityTypeBrowsingWeb,\n        let incomingURL = userActivity.webpageURL,\n        let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true) else {\n        return false\n    }\n\n\n    // Check for specific URL components that you need.\n    guard let path = components.path,\n    let params = components.queryItems else {\n        return false\n    }    \n    print(\"path = \\(path)\")\n\n\n    if let albumName = params.first(where: { $0.name == \"albumname\" } )?.value,\n        let photoIndex = params.first(where: { $0.name == \"index\" })?.value {            \n        print(\"album = \\(albumName)\")\n        print(\"photoIndex = \\(photoIndex)\")\n        return true  \n\n\n    } else {\n        print(\"Either album name or photo index missing\")\n        return false\n    }\n}\n\n\nThis example code shows how to handle a universal link in iOS and tvOS:\n\nfunc application(_ application: UIApplication,\n                 continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool\n{\n    // Get URL components from the incoming user activity.\n    guard userActivity.activityType == NSUserActivityTypeBrowsingWeb,\n        let incomingURL = userActivity.webpageURL,\n        let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true) else {\n        return false\n    }\n\n\n    // Check for specific URL components that you need.\n    guard let path = components.path,\n    let params = components.queryItems else {\n        return false\n    }    \n    print(\"path = \\(path)\")\n\n\n    if let albumName = params.first(where: { $0.name == \"albumname\" } )?.value,\n        let photoIndex = params.first(where: { $0.name == \"index\" })?.value {\n\n\n        print(\"album = \\(albumName)\")\n        print(\"photoIndex = \\(photoIndex)\")\n        return true\n\n\n    } else {\n        print(\"Either album name or photo index missing\")\n        return false\n    }\n}\n\n\nIf your app has opted into Scenes, and your app is not running, the system delivers the universal link to the scene(_:willConnectTo:options:) delegate method after launch, and to scene(_:continue:) when the universal link is tapped while your app is running or suspended in memory.\n\nfunc scene(_ scene: UIScene, willConnectTo\n           session: UISceneSession,\n           options connectionOptions: UIScene.ConnectionOptions) {\n    \n    // Get URL components from the incoming user activity.\n    guard let userActivity = connectionOptions.userActivities.first,\n        userActivity.activityType == NSUserActivityTypeBrowsingWeb,\n        let incomingURL = userActivity.webpageURL,\n        let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true) else {\n        return\n    }\n\n\n    // Check for specific URL components that you need.\n    guard let path = components.path,\n        let params = components.queryItems else {\n        return\n    }\n    print(\"path = \\(path)\")\n\n\n    if let albumName = params.first(where: { $0.name == \"albumname\" })?.value,\n        let photoIndex = params.first(where: { $0.name == \"index\" })?.value {\n        \n        print(\"album = \\(albumName)\")\n        print(\"photoIndex = \\(photoIndex)\")\n    } else {\n        print(\"Either album name or photo index missing\")\n    }\n}\n\n\nThis example code shows how to handle a universal link in watchOS:\n\nfunc handle(_ userActivity: NSUserActivity)\n{\n    // Get URL components from the incoming user activity.\n    guard userActivity.activityType == NSUserActivityTypeBrowsingWeb,\n        let incomingURL = userActivity.webpageURL,\n        let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true) else { return }\n\n\n    // Check for specific URL components that you need.\n    guard let path = components.path,\n    let params = components.queryItems else { return }    \n    print(\"path = \\(path)\")\n\n\n    if let albumName = params.first(where: { $0.name == \"albumname\" } )?.value,\n        let photoIndex = params.first(where: { $0.name == \"index\" })?.value {            \n        print(\"album = \\(albumName)\")\n        print(\"photoIndex = \\(photoIndex)\")\n    } else {\n        print(\"Either album name or photo index missing\")\n    }\n}\n\n\nNote\n\nIn watchOS, a Safari-like interface is available for apps such as Messages and Mail. For other apps, when the user clicks a universal link that points to content in a companion app that the user doesn’t have installed, the system notifies the user to view the URL on their iPhone."
  },
  {
    "title": "Xcode Cloud workflow reference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/xcode-cloud-workflow-reference",
    "html": "Overview\n\nBy configuring a first workflow in Xcode, you started a continuous integration and delivery (CI/CD) practice with Xcode Cloud. After you’ve reviewed how you can best refine your CI/CD practice as described in Developing a workflow strategy for Xcode Cloud, create custom workflows that fit the unique needs for ensuring your app’s or framework’s quality. For example, add metadata to describe the purpose of a workflow, configure conditions that start a new build, add actions and post-actions, and more.\n\nYou need to use Xcode to initially configure your project or workspace to use Xcode Cloud. However, after you’ve started your first build, you can edit and create workflows in either Xcode or App Store Connect.\n\nFor additional information about Xcode Cloud workflows, see WWDC21: Explore Xcode Cloud workflows and WWDC21: Customize your advanced Xcode Cloud workflows.\n\nMetadata\n\nEven if you’re a solo developer, you might create several workflows. To help distinguish workflows from each other and make each workflow’s purpose easy to understand, open the workflow and provide metadata in the General section.\n\nName\n\nChoose a name that’s easy to recognize. For example, name a workflow “Nightly Builds” if it distributes a new version of your app to your team every night.\n\nDescription\n\nProvide additional context that explains the workflow’s purpose. For example, enter “A workflow that automatically archives both the iOS and the macOS app every night”.\n\nEnvironment\n\nWhen you develop and maintain your app or framework over time, you need to make sure that current and upcoming Xcode versions can successfully build it. If your product is a framework, you might need to ensure your framework supports previous Xcode versions.\n\nImportant\n\nPeriodically, Xcode Cloud may update available macOS and Xcode versions and subsequently ask you to update your workflows for them to continue to build successfully.\n\nTo reduce the work needed to perform these verifications, configure a workflow’s temporary build environment. For example, create a workflow that builds your project and runs your tests using the latest publicly released Xcode and macOS versions. Then, create another workflow that performs the same verifications with the latest beta versions of macOS and Xcode.\n\nTo configure a workflow’s temporary build environment, navigate to the workflow’s Environment section, and choose from available Xcode and macOS versions.\n\nNote\n\nThe temporary build environment that Xcode Cloud uses includes tools that are part of macOS and Xcode — for example, Python — and additionally Homebrew to support installing third-party dependencies and tools. For more information, see Making dependencies available to Xcode Cloud.\n\nPerform a clean build\n\nTo reduce the amount of time it takes to perform a build, Xcode Cloud stores each build’s derived data and other cached information for reuse in a secure and private way. However, you might need to perform a clean build that doesn’t cache data. For example, you need to configure a workflow to perform a clean build if you add a post-action that distributes a new version to external testers with TestFlight.\n\nTo configure a workflow that starts a new build without cached data:\n\nOpen the workflow in Xcode or App Store Connect and navigate to the Environment section.\n\nSelect Clean and save the workflow.\n\nNote\n\nEnabling clean builds significantly increases the time it takes to perform a build. Only perform clean builds when necessary; for example, distributing a new version to external testers with TestFlight requires a clean build.\n\nCustom environment variables\n\nIn addition to Xcode and macOS versions, you can set custom environment variables for a workflow in its Environment section. These variables are available to custom build scripts you use to extend workflows. For example, set a secret environment variable to contain an API key you use in a custom build script that uploads a workflow’s artifacts to your server.\n\nImportant\n\nTo securely store an environment variable and make sure it doesn’t appear in any logs, select the Secret checkbox.\n\nStart conditions\n\nWhen you create a new workflow, Xcode suggests the Branch Changes condition that starts a new build for every change to your Git repository’s default branch. This condition is useful when you get started with CI. However, starting a build for every change to your default branch might not be the appropriate setting for you. For example, a workflow that runs UI tests on many simulated devices can take a significant amount of time to complete, and starting a build for every branch change isn’t practical. In this case, make changes to the workflow’s start condition or add start conditions to tell Xcode Cloud to perform a workflow less often.\n\nFor more information about configuring start conditions, see Configuring start conditions.\n\nAuto-cancel builds\n\nBy default, workflows have the Auto-cancel Builds setting enabled for each start condition. As a result, Xcode Cloud automatically cancels an in-progress build if a workflow queues a new build for the same workflow. This reduces the time to verify your latest code change — a useful setting in case you push updates to a branch in quick succession.\n\nFor example, say you push five changes to a branch within five minutes. Xcode Cloud detects each change and starts a build because it meets the Branch Changes start condition, resulting in five builds. To know whether your fifth change passed the configured verifications, you’d have to wait for each build to complete, even though the fifth change supersedes the others. With Auto-cancel Builds enabled, Xcode Cloud cancels the first four builds and immediately starts the build for the latest change.\n\nTip\n\nIf you prefer not to cancel builds automatically, turn off Auto-cancel Builds for one, multiple, or each start condition in a start condition’s Options section.\n\nActions\n\nAutomatically and frequently building your project and verifying changes is key to a CI/CD practice. As a result, configuring a workflow’s actions is a fundamental task you perform in its Actions section. A workflow can perform the following actions:\n\nBuild\n\nTest\n\nAnalyze\n\nArchive\n\nNote how these actions match your project’s or workspace’s scheme actions. To create a workflow that fits your requirements, add as many actions to a workflow as needed. For example, create a workflow that performs the test and archive actions for your app.\n\nFor detailed information on actions you configure for an Xcode Cloud workflow, see Configuring your Xcode Cloud workflow’s actions. For additional information on using Xcode Cloud to run your tests, see WWDC22: Author fast and reliable tests for Xcode Cloud.\n\nPost-actions\n\nPerforming actions is at the core of a workflow. However, similar to how you configure post-actions in a scheme, you can configure post-actions for a workflow that happen after Xcode Cloud performs the workflow’s actions.\n\nBy adding post-actions, you can:\n\nConfigure custom notification settings. For example, limit email notifications to a certain build status, let Xcode Cloud email additional coworkers, or configure Xcode Cloud to send notifications to Slack.\n\nDistribute a new version of your app to testers using TestFlight.\n\nUpload a version of your app to App Store Connect that you can subsequently submit for app review.\n\nFor additional information on sending notifications to Slack, see Connecting Xcode Cloud to Slack\n\nCustom build scripts\n\nXcode Cloud uses your project’s configured schemes and offers a wide variety of workflow settings. However, you might want to perform additional custom tasks you can’t configure using a scheme or workflow. For example, you might need to install an additional tool to build your project, to upload an app archive to storage, to use a different app icon for nightly builds, and so on.\n\nTo address these use cases, you can create shell scripts, referred to as custom build scripts, that Xcode Cloud runs at a specific moment during a build. For more information, see Writing custom build scripts.\n\nAutomate workflow management\n\nUsing either Xcode or App Store Connect, you can create custom workflows to verify the quality of your apps or frameworks. However, you may need to further automate Xcode Cloud usage and create and manage numerous workflows for multiple apps — especially in a corporate context. If this applies to you, use the App Store Connect API to manage workflows, start builds, and access Xcode Cloud data. For more information, see Xcode Cloud Workflows and Builds.\n\nTopics\nStart conditions\nConfiguring start conditions\nConfigure Xcode Cloud to start a build when you update a branch, pull request, or Git tag, or based on a schedule.\nActions\nConfiguring your Xcode Cloud workflow’s actions\nAdd actions to an Xcode Cloud workflow to build, test, analyze, and archive your app or framework when it performs a build.\nSee Also\nWorkflows\nDeveloping a workflow strategy for Xcode Cloud\nReview how you can best create custom Xcode Cloud workflows to refine your continuous integration and delivery practice.\nCreating a workflow that builds your app for distribution\nConfigure a workflow to build and sign your app for distribution to testers with TestFlight, in the App Store, or as a notarized app."
  },
  {
    "title": "Developing a workflow strategy for Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/developing-a-workflow-strategy-for-xcode-cloud",
    "html": "Overview\n\nWith Xcode, you configure your project or workspace to use Xcode Cloud, create a first workflow, and start your first build. After Xcode Cloud has successfully completed the first build, review how you can best create custom Xcode Cloud workflows to practice continuous integration and delivery (CI/CD). Then, plan next steps for refining your CI/CD practice to make sure your app or framework is always in a releasable state.\n\nIf you’re new to CI/CD, see About continuous integration and delivery with Xcode Cloud to learn how CI/CD with Xcode Cloud helps you create high-quality apps and frameworks. To learn more about creating your first workflow, see Configuring your first Xcode Cloud workflow.\n\nFor additional information about Xcode Cloud workflows, see Xcode Cloud workflow reference, WWDC21: Explore Xcode Cloud workflows and WWDC21: Customize your advanced Xcode Cloud workflows.\n\nPlan next steps\n\nThe number of Xcode Cloud workflows you’ll create depends on factors like the complexity of your project and the size of your team. For example, consider a solo developer who works on an iOS app. They could create a workflow that builds their app and runs unit tests for every change to a branch. Additionally, they could create a second workflow that runs tests on additional Apple devices in Simulator, archives the app, and distributes a new version to testers with TestFlight every time they create a new Git tag.\n\nIn contrast, consider a team in a corporate context that develops an app that’s available on all Apple platforms. The team could create several workflows; for example, workflows that:\n\nBuild various projects in a workspace and run unit tests on one simulated device per platform\n\nPerform additional, long-running tests once a week\n\nAutomatically distribute nightly builds to members of the development team\n\nDistribute new versions to the QA team every two weeks\n\nWhile there is no one-size-fits-all approach to CI/CD, following an iterative approach and adopting CI/CD over time is a good strategy:\n\nIdentify what a comprehensive CI/CD practice for you looks like. For example, list all verifications you’d like Xcode Cloud to perform.\n\nTranslate your comprehensive CI/CD practice into Xcode Cloud workflows. For example, if you’d like to distribute a new version of your app to testers every week, this task could translate to one workflow.\n\nPlan the work necessary as individual tasks and work on each workflow one by one until you have a comprehensive CI/CD practice in place.\n\nEdit and create workflows\n\nBy adopting CI/CD, managing Xcode Cloud workflows becomes part of your day-to-day app development. To help you stay focused and make using Xcode Cloud convenient, edit your Xcode Cloud workflows with Xcode.\n\nTo update an existing workflow in Xcode:\n\nChoose Integrate > Manage Workflows, or Product > Xcode Cloud > Manage Workflows in Xcode 14, to open the Manage Workflows sheet.\n\nDouble-click to open the existing workflow.\n\nAlternatively, Control-click a workflow in the Report navigator and choose Edit Workflow.\n\nTo create a new workflow in Xcode:\n\nChoose Integrate > Manage Workflows, or Product > Xcode Cloud > Manage Workflows in Xcode 14, to open the Manage Workflows sheet.\n\nClick the Add button (+) to create a new workflow.\n\nThe following screenshot shows the Manage Workflows sheet in Xcode with one workflow:\n\nDeactivate a workflow instead of deleting it\n\nEventually, you might want to stop using a certain workflow. One way to do this is to delete a workflow in the Manage Workflows sheet. However, deleting a workflow permanently deletes its build history and artifacts. Only delete a workflow when you’re confident that you don’t need its build history or artifacts anymore. Instead of deleting a workflow, deactivate it to preserve its build history and artifacts.\n\nTo deactivate a workflow:\n\nControl-click the workflow in the Report navigator and choose Edit Workflow.\n\nToggle the switch next to the workflow’s name in the top-left corner of the sheet to the off position and save your changes.\n\nAlternatively, deactivate a workflow by Control-clicking it in the Manage Workflows sheet and choosing Deactivate or by deactivating it in the Xcode Cloud tab on the App Store Connect website.\n\nTo start using a deactivated workflow again, re-activate it any time in the Manage Workflows sheet or by opening the workflow and toggling the switch next to its name to the on position.\n\nDuplicate a workflow before making significant changes\n\nWhen you edit a workflow, a change might unintentionally cause the next build to fail. If this happens, edit the workflow as needed and start a build to verify you resolved it. However, it takes time to undo significant changes to a workflow.\n\nTo avoid costly mistakes and avoid impacting coworkers who may use a workflow, duplicate a workflow before you make significant changes to it. Then, use the duplicate to test a change without impacting coworkers. Alternatively, edit the original workflow and use the duplicate to help you remember what the original workflow looked like before you changed it.\n\nTo copy an existing workflow:\n\nOpen your project or workspace in Xcode, then choose Integrate > Manage Workflows, or Product > Xcode Cloud > Manage Workflows in Xcode 14, to open the Manage Workflows sheet.\n\nControl-click the workflow you want to change and choose Duplicate to open the copy.\n\nRename the copy to make sure you can distinguish it from the original.\n\nSave the duplicated workflow.\n\nNote\n\nA new workflow is active by default. As a result, Xcode Cloud runs both the original workflow and the duplicate unless you deactivate one of them or change either workflow’s start conditions.\n\nRestrict who can edit a workflow\n\nDepending on the complexity of your project, creating a new workflow and making sure Xcode Cloud can successfully build your project can take a significant amount of time. To prevent team members from making unintentional changes to a workflow that take time to undo, restrict who can edit the workflow.\n\nTo restrict who can edit a workflow:\n\nOpen the workflow in Xcode or on the App Store Connect website.\n\nNavigate to the General section, and select the checkbox next to Restrict Editing.\n\nAs a result, only members of your Apple Development Team with the Admin or App Manager role can make changes to it.\n\nManage workflows in App Store Connect\n\nIn some cases, especially for large teams and in a corporate context, a team member may be more familiar with App Store Connect. To address use cases like this, you can create and edit workflows in App Store Connect after you configured your Xcode project or workspace to use Xcode Cloud.\n\nTo manage workflows in App Store Connect:\n\nOpen your app’s page and choose the Xcode Cloud tab.\n\nSelect Manage Workflows in the sidebar to display a list of your workflows.\n\nClick the More Options button (…) next to a workflow and choose the action you’d like to perform. For example, choose Edit to make changes to a workflow.\n\nSee Also\nWorkflows\nXcode Cloud workflow reference\nConfigure metadata, start conditions, actions, post-actions, and more to create custom Xcode Cloud workflows.\nCreating a workflow that builds your app for distribution\nConfigure a workflow to build and sign your app for distribution to testers with TestFlight, in the App Store, or as a notarized app."
  },
  {
    "title": "Distributing binary frameworks as Swift packages | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/distributing-binary-frameworks-as-swift-packages",
    "html": "Overview\n\nCreating a Swift package to organize and share your code makes source files available to developers who use the Swift package as a package dependency. However, you may need to make your code available as binaries to protect your intellectual property — for example, if you’re developing proprietary, closed-source libraries.\n\nCarefully consider whether you want to distribute your code in binary form because doing so comes with drawbacks. For example, a Swift package that contains a binary is less portable because it can only support platforms that its included binaries support. In addition, binary dependencies are only available for Apple platforms, which limits the audience for your Swift package.\n\nNote\n\nA Swift package can contain a mix of both source files and binaries. This use case is common for packages that contain source code that wraps closed-source binaries.\n\nPackage binaries as an XCFramework bundle\n\nTo distribute code in binary form as a Swift package, create an XCFramework bundle, or artifact, that contains the binaries. Then, make the bundle available locally or on a server:\n\nWhen you host the binaries on a server, create a ZIP archive with the XCFramework in its root directory and make it available publicly.\n\nIf the XCFramework is available locally and included in the package’s Git repository, you don’t need to create a compressed archive and can reference the XCFramework directly.\n\nTo learn more about creating an XCFramework bundle, see Creating a multiplatform binary framework bundle.\n\nDeclare a binary target in the package manifest\n\nFirst, follow the process to create a new Swift package as described in Creating a standalone Swift package with Xcode. Next, declare a binary target in your package manifest and make it part of a product, just like a target that contains source files. Ensure that the name of the binary target in the package manifest matches the artifact’s module name.\n\nTo declare a remote, or URL-based, binary target, use binaryTarget(name:path:). To create the required checksum, open the Terminal app, navigate to the root of the package, and run swift package compute-checksum path/to/MyFramework.zip. Xcode uses the checksum to verify that the hosted archive file matches the archive you declare in the manifest file. When developers add the package as a binary dependency to their project, and the remote archive’s checksum doesn’t match the checksum in the package manifest, Xcode displays an error.\n\nTo declare a local, or path-based, binary target, use package(name:path:) and don’t generate a checksum. Instead, include the .xcframework bundle in the package’s Git repository.\n\nThe following package manifest for the MyLibrary package declares a library product that includes two binary targets: SomeRemoteBinaryPackage, a remote, URL-based binary target; and SomeLocalBinaryPackage, a local, path-based binary target.\n\n// swift-tools-version:5.3\nimport PackageDescription\n\n\nlet package = Package(\n    name: \"MyLibrary\",\n    platforms: [\n        .macOS(.v10_14), .iOS(.v13), .tvOS(.v13)\n    ],\n    products: [\n        // Products define the executables and libraries a package produces, and make them visible to other packages.\n        .library(\n            name: \"MyLibrary\",\n            targets: [\"MyLibrary\", \"SomeRemoteBinaryPackage\", \"SomeLocalBinaryPackage\"])\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages this package depends on.\n        .target(\n            name: \"MyLibrary\"\n        ),\n        .binaryTarget(\n            name: \"SomeRemoteBinaryPackage\",\n            url: \"https://url/to/some/remote/xcframework.zip\",\n            checksum: \"The checksum of the ZIP archive that contains the XCFramework.\"\n        ),\n        .binaryTarget(\n            name: \"SomeLocalBinaryPackage\",\n            path: \"path/to/some.xcframework\"\n        )\n        .testTarget(\n            name: \"MyLibraryTests\",\n            dependencies: [\"MyLibrary\"]),\n    ]\n)\n\nSee Also\nPackage creation\nCreating a standalone Swift package with Xcode\nBundle executable or shareable code into a standalone Swift package.\nBundling resources with a Swift package\nAdd resource files to your Swift package and access them in your code.\nLocalizing package resources\nEnsure that your Swift package provides localized resources for many locales.\nDeveloping a Swift package in tandem with an app\nAdd your published Swift package as a local package to your app’s project and develop the package and the app in tandem.\nOrganizing your code with local packages\nSimplify maintenance, promote modularity, and encourage reuse by organizing your app’s code into local Swift packages."
  },
  {
    "title": "Configuring your first Xcode Cloud workflow | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-your-first-xcode-cloud-workflow",
    "html": "Overview\n\nXcode helps you configure your project or workspace to use Xcode Cloud. It analyzes your project, suggests a configuration to quickly build your app or framework with Xcode Cloud, and makes it easy to refine your continuous integration practice after you’ve completed your first build.\n\nFor additional information about Xcode Cloud, see WWDC21: Meet Xcode Cloud, WWDC21: Explore Xcode Cloud workflows, WWDC21: Customize your advanced Xcode Cloud workflows, and WWDC22: Get the most out of Xcode Cloud.\n\nImportant\n\nTo avoid issues and save time when configuring your first workflow, review the requirements for using Xcode Cloud detailed in Requirements for using Xcode Cloud before you configure your project or workspace to use Xcode Cloud. Additionally, if your project requires dependencies, make sure they’re accessible to Xcode Cloud. To learn more, see Making dependencies available to Xcode Cloud.\n\nReview Xcode Cloud workflows\n\nWhen you start configuring a project or workspace to use Xcode Cloud, Xcode analyzes your project to detect its settings and lists its apps and frameworks — referred to as products. After you choose a product, Xcode suggests a first workflow for it. The workflow is the configuration for the steps you want Xcode Cloud to perform.\n\nA workflow includes the following settings:\n\nGeneral information; for example, a name and a description of the workflow.\n\nXcode and macOS versions of the temporary build environment. Note that Xcode Cloud may periodically update available macOS and Xcode versions and ask you to update your workflows subsequently for them to continue to build successfully.\n\nStart conditions that define when Xcode Cloud runs a workflow.\n\nActions that Xcode Cloud performs. You can configure several actions for a workflow. Available actions are: build, analyze, test, and archive.\n\nPost-actions that Xcode Cloud performs. For example, you can configure custom notifications or distribute a new version of your app to testers in TestFlight.\n\nCustom build scripts that perform custom tasks; for example, installing a third-party tool. For more information, see Writing custom build scripts.\n\nAfter reviewing the suggested workflow, you’ll connect Xcode Cloud to your Git repository and run the workflow, referred to as a build.\n\nNote\n\nXcode Cloud clones your repository in a private, isolated, and temporary build environment. It doesn’t store your source code and securely handles any stored data — for example, your derived data — and keeps it private. The temporary build environment that Xcode Cloud uses includes tools that are part of macOS and Xcode — for example, Python — and additionally Homebrew to support installing third-party dependencies and tools. For more information, see Making dependencies available to Xcode Cloud.\n\nWhen it completes a build, Xcode Cloud:\n\nSends an email that contains information about the build, including links to the build report in Xcode and App Store Connect.\n\nStores the build’s artifacts and makes them available for downloading in Xcode or App Store Connect.\n\nThe artifacts that Xcode Cloud creates include:\n\nDetailed build logs\n\nThe exported app archive, app binary, or framework\n\nA test result bundle, including screenshots you create in your automated user interface tests\n\nImportant\n\nYou can access build information and artifacts for 30 days from the moment Xcode Cloud completes a build. Always download and archive build artifacts for workflows that publish your app on the App Store. For more information on accessing build information and artifacts, see Download and archive build artifacts below.\n\nUse Xcode to initially configure your project or workspace to use Xcode Cloud. After you’ve started your first build, use either Xcode or App Store Connect to configure additional workflows, access build information, and more. For more information, see Edit and create workflows in App Store Connect.\n\nNote\n\nIf you use .xcconfig files to set the bundle identifier or use them to automatically change the bundle identifier, you need to take extra steps to start using Xcode Cloud. First, set the bundle identifier for your app target in the Signing & Capabilities tab of your project or workspace. Then configure your first workflow as described below. Repeat this process for each bundle identifier. Note that you’ll need to use App Store Connect to view your workflows and builds because Xcode relies on the explicitly set bundle identifier to show them.\n\nSelect the archive action\n\nFor each app or framework that you want to build with Xcode Cloud, make sure its corresponding scheme uses the archive action:\n\nTo find out which of your project’s schemes use the archive action, run the following command in Terminal:\n\nxcodebuild -project Example.xcodeproj -describeAllArchivableProducts -json\n\n\nXcode uses the same command to find available products that you can build with Xcode Cloud.\n\nChoose a product\n\nTo configure your project or workspace to use Xcode Cloud, open your project or workspace in Xcode. Make sure the Report navigator is visible, select the Cloud tab, and then click Create Workflow.\n\nImportant\n\nIf you develop a WatchKit app and a watchOS app extension, you can configure Xcode Cloud workflows for them, but they may fail if you haven’t registered their bundle ID in the Apple Developer portal. To successfully build them with Xcode Cloud, log into your Apple Developer account, navigate to the Certificates, Identifiers & Profiles section and add the bundle IDs for your WatchKit app and watchOS app extension manually before you configure Xcode Cloud workflows for them.\n\nXcode analyzes your project or workspace and lists each product it finds in the Select a Product sheet. Choose the product that matches your app or framework and click Next.\n\nIf your project contains targets that use the same bundle identifier, Xcode Cloud considers them to be one product. Note that a product can only have one bundle ID, and a bundle ID always matches exactly one Xcode Cloud product. In case your workspace or project contains several app targets:\n\nWhen possible, share the same bundle ID across versions of your app for each platform. For example, use the same bundle ID for your iOS, macOS, and watchOS versions of your app.\n\nIf each version of your app uses a different bundle ID — for example, if the iOS version uses com.example.myiosapp and the macOS app uses com.example.mymacapp — Xcode detects more than one product. Choose one of them when you create your first workflow, and later configure additional workflows for the other product.\n\nYou may be a member of more than one Apple Developer team. In this case, Xcode asks you to choose a team. Choose the team you intend to use for distribution to testers with TestFlight and for publishing the app in the App Store.\n\nReview the suggested workflow\n\nBased on the product you selected, Xcode suggests a first workflow that:\n\nStarts a build for each change to your Git repository’s default branch and for each pull request that targets your default branch\n\nUses the latest released macOS and Xcode versions for its temporary build environment\n\nUses the archive action\n\nSends an email with information about the build, including links to the build report in Xcode and App Store Connect\n\nBefore starting your first build, review the suggested workflow; for example, verify if Xcode chose the correct scheme.\n\nTo review the suggested workflow:\n\nClick Edit Workflow in the Review Workflow sheet.\n\nMake changes only if necessary in the sheet that displays the workflow information and save them.\n\nIn the Review Workflow sheet, click Next and let Xcode guide you through the process of granting Xcode Cloud access to your source code.\n\nTip\n\nKeep your first workflow simple and use the suggested settings if possible. This way, you become familiar with Xcode Cloud without worrying about misconfiguring your first workflow. When Xcode Cloud successfully finishes your first build, edit the workflow to meet your requirements or create additional workflows to refine your CI/CD practice in either Xcode or App Store Connect.\n\nGrant Xcode Cloud access to your source code\n\nXcode Cloud requires access to the Git repository containing your code. It uses this access to build and test your code automatically when you make changes. When you configure your project or workspace to use Xcode Cloud, Xcode analyzes it to detect the Source Code Management (SCM) provider you use. In the Grant Access to Your Source Code sheet, click Grant Access and let Xcode guide you through your SCM provider’s native authorization process.\n\nImportant\n\nMake sure you have the required permission or role to grant Xcode Cloud access to your Git repository. Additionally, if you use a self-hosted SCM provider — for example, Bitbucket Server — make sure Xcode Cloud can access your Git repository. For information on required permissions, roles, and IP address ranges that Xcode Cloud uses, see Source control requirements.\n\nWhen you’ve allowed Xcode Cloud to access your Git repository, Xcode indicates that it can access your source code; click Next.\n\nNote\n\nBuilding your project may require access to more than one instance of your self-hosted SCM provider — a common case for large teams. For example, you may use two different GitHub Enterprise instances where one hosts your app’s code and the other hosts your dependencies. If this scenario applies to you, finish the initial onboarding workflow for the project in Xcode and connect the instance that hosts your app’s code, then let the first build fail. After the build failure, Xcode suggests a fix to connect the other instance.\n\nFor additional guidance on granting Xcode Cloud access to your source code, see Source code management setup.\n\nCreate an app record\n\nXcode Cloud combines Xcode, TestFlight, and App Store Connect into a powerful CI/CD system. As a result, you need an app record in App Store Connect for your app.\n\nIf you previously created an app record in App Store Connect for your app, Xcode Cloud uses it automatically. If you haven’t created an app record for your app, Xcode helps you create one after you grant Xcode Cloud access to your Git repository.\n\nNote\n\nYou don’t need an app record to build a framework with Xcode Cloud.\n\nTo create an app record, you must have the App Manager, Admin, or Account Holder role for your Apple Developer Team. If you have the Developer role, you need the Create Apps permission. If you don’t have the required role or permission, see Create an app record in App Store Connect.\n\nStart your first build\n\nNow that you’ve granted Xcode Cloud access to your Git repository and — if applicable — created an app record, you’re ready to start your first build. Choose a branch and click Start Build. Xcode Cloud checks out the branch and starts building your code.\n\nTo view information about the in-progress build in the Editor pane, select the build in the Report navigator. To see detailed build logs, expand an action in the Report Outline and select Logs. If the Report Outline isn’t visible, enable it using the Adjust Editor Options button in the top-right corner of the Editor pane.\n\nWhen Xcode Cloud finishes building your project, it sends an email that contains information about the build: the build’s status, the commit it used for the build, and links to the build report in Xcode or in App Store Connect.\n\nNote\n\nIf you start using Xcode Cloud for an existing Mac app, you may need to configure Xcode Cloud to increment the build number starting with a different value than 1. For more information, see Setting the next build number for Xcode Cloud builds.\n\nUnderstand why a build failed\n\nThere’s a chance that your first build will fail. This is especially likely for complex code bases and projects with many dependencies. To understand why a build failed, select a build in the Report navigator, expand a failed action in the Report Outline, and choose Logs to see the build logs.\n\nYou can also choose Artifacts and download the build report. For additional guidance on fixing common build issues, see Resolving common configuration and build issues.\n\nIn addition to viewing build logs in Xcode, you can also explore build logs in App Store Connect.\n\nTo see build logs in App Store Connect:\n\nLog in to App Store Connect and go to your app’s page.\n\nSelect the Xcode Cloud tab.\n\nChoose Builds in the sidebar.\n\nExpand a workflow and choose a build.\n\nExpand an action in the sidebar and choose Logs.\n\nRefine your continuous integration practice\n\nAfter configuring your first workflow and successfully completing your first build, spend time planning next steps to refine your CI/CD process; for example:\n\nAsk coworkers to start using Xcode Cloud as described in Connect your personal SCM account to Xcode Cloud.\n\nChange your first workflow’s name and description.\n\nAdd a test action to your first workflow that runs your unit tests.\n\nChange your first workflow’s start conditions to only start a build if you update a custom branch or add start conditions.\n\nAdd a post-action to distribute a new version of your app to testers with TestFlight.\n\nCreate additional workflows to perform advanced verifications that take more time to complete; for example, configure a workflow that runs your automated UI tests once per week.\n\nCreate workflows for other products that Xcode detected when you created your first workflow.\n\nReceive build information in Slack, a popular collaboration tool. For information about connecting Xcode Cloud to Slack, see Connecting Xcode Cloud to Slack.\n\nRequire an Xcode Cloud build to succeed before it’s possible to merge a PR. For more information, see Configuring requirements for merging a pull request.\n\nCreate additional workflows in Xcode\n\nTo configure and create additional workflows or make changes to an existing one in Xcode:\n\nNavigate to the Cloud tab in the Report navigator.\n\nControl-click your app’s name or a workflow and choose Manage Workflows.\n\nIn the Manage Workflows sheet, double-click a workflow to make changes to it or add a new workflow using the Add button (+).\n\nFor more information on creating custom workflows, see Developing a workflow strategy for Xcode Cloud and Xcode Cloud workflow reference.\n\nEdit and create workflows in App Store Connect\n\nYou must configure your first Xcode Cloud workflow in Xcode, and the deep integration of Xcode Cloud into Xcode enables an integrated development process where you write code, review changes, view build information, and configure workflows. However, teams may have dedicated infrastructure engineers or release managers who aren’t familiar with Xcode. To accommodate them, and to offer you an additional way to configure your workflows and view build information, App Store Connect also deeply integrates with Xcode Cloud.\n\nTo view, edit, or create workflows in App Store Connect:\n\nLog in to App Store Connect and go to your app’s page.\n\nClick the Xcode Cloud tab.\n\nChoose Manage Workflows in the sidebar.\n\nClick the Add button next to Manage Workflows to create a new workflow or click a workflow to view and edit its settings.\n\nBy clicking the More button (···) for a workflow, you can also edit, duplicate, deactivate, or delete a workflow.\n\nDownload and archive build artifacts\n\nWhen Xcode Cloud completes a build for a workflow, it creates a set of artifacts that includes build information, app binaries, symbol information, test results, and more. Xcode Cloud stores artifacts for up to 30 days after it completes a build.\n\nBeyond the need to archive past builds, it’s especially important to download and archive build artifacts for a version of an app that you distribute on the App Store. This is because you may need the symbol information Xcode Cloud creates when it archives your app to diagnose issues using crash reports.\n\nTo download build information and artifacts, use Xcode or App Store Connect. Alternatively, use the App Store Connect API to automate the task of downloading the build artifacts.\n\nFor information on automating Xcode Cloud with the App Store Connect API, see Xcode Cloud Workflows and Builds. For information on symbol information and crash reports, see Diagnosing issues using crash reports and device logs.\n\nSee Also\nSetup and maintenance\nMaking dependencies available to Xcode Cloud\nReview dependencies and make them available to Xcode Cloud before you configure your project to use Xcode Cloud.\nConfiguring Xcode Cloud for your team\nStart using continuous integration and delivery with Xcode Cloud as a team.\nBuilding Swift packages and Swift Playgrounds app projects with Xcode Cloud\nAdd your Swift package or Swift Playgrounds app project to an Xcode project to build it in Xcode Cloud.\nSetting the next build number for Xcode Cloud builds\nStart numbering builds from a custom build number for your existing Mac app to avoid version collisions.\nIncluding notes for testers with a beta release of your app\nAdd text files to your Xcode project to provide notes to beta testers about what to test.\nRemoving your project from Xcode Cloud\nRemove your project from Xcode Cloud to delete app and workflow data, disconnect your Git repository, and remove the Slack integration."
  },
  {
    "title": "About continuous integration and delivery with Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/about-continuous-integration-and-delivery-with-xcode-cloud",
    "html": "Overview\n\nXcode consists of a suite of tools you use to build, test, and release apps and frameworks for Apple platforms. When you add features and support more devices and platforms, your app or framework and its codebase grow in complexity, making it harder to ensure its quality. With Xcode Cloud, you can adopt continuous integration and delivery (CI/CD), a standard practice to monitor, ensure, and improve the quality of your apps and frameworks.\n\nXcode Cloud is a CI/CD system that uses Git for source control and provides you with an integrated system that ensures the quality and stability of your codebase. It also helps you publish apps efficiently. By combining Xcode with Apple’s cloud infrastructure for building and testing your code — along with TestFlight and App Store Connect — Xcode Cloud makes it easy for you to:\n\nBuild and test your code automatically.\n\nTest your app on Apple devices in Simulator automatically and frequently.\n\nReceive notifications from Xcode Cloud to identify errors before they become serious issues.\n\nDistribute new versions of your app to team members and testers with TestFlight.\n\nMaking new versions of your app available for app review before publishing them in the App Store.\n\nDevelop your software collaboratively using Xcode and Apple’s cloud infrastructure.\n\nYou don’t need to introduce every aspect of continuous integration and delivery at once. Instead, take a slow but steady approach and start by using Git for managing your project’s source code. After you’re comfortable with Git’s workflows and processes, configure your project to use Xcode Cloud at the most basic level — for continually building and testing your projects. As you become more familiar with how Xcode Cloud works, you can start to take advantage of its CD features like delivering test builds with TestFlight.\n\nThe role of source control\n\nChanges to your app’s code can be difficult to manage. This is especially true when you work on several changes at the same time. To help you organize, manage, and document source code changes, Xcode supports source control with Git. By using source control, you improve your project’s quality by tracking and reviewing code changes.\n\nBecause source control plays such a fundamental role in CI/CD, Xcode Cloud requires your code to be in a Git repository. It supports the following source code management (SCM) providers:\n\nBitbucket Cloud and Bitbucket Server\n\nGitHub and GitHub Enterprise\n\nGitLab and self-managed GitLab\n\nNote\n\nXcode Cloud comes with support for Git LFS.\n\nTo learn more about source control with Xcode, see Source control management.\n\nThe importance of automated building and testing\n\nA typical development process starts with making changes to your code, building the project, and running your app in the Simulator or on a test device. Your process may even include verifying changes locally by running unit tests you create with XCTest, and by running integration, performance, or user interface tests.\n\nWhile Xcode can reduce the time it takes to perform these tasks, they still take a significant amount of your time. This is especially true for complex apps or frameworks that support a wide range of devices and operating systems. With Xcode Cloud, however, you can build, run, and test your project on multiple simulated devices in less time than you can traditionally.\n\nAfter verifying a change, Xcode Cloud automatically notifies you about the result via email. You can also view the results in Xcode or in App Store Connect. This helps you detect errors before they become an issue, and gives you the reassurance you need about the stability and quality of your code.\n\nFor more information about automatically building your project with Xcode Cloud, see Configuring your first Xcode Cloud workflow.\n\nFor more information about testing your code, see Testing your apps in Xcode and Adding unit tests to your existing project.\n\nContinuous delivery\n\nThe flip side to continuous integration (CI) is continuous delivery (CD). While automatic building and testing are important to developing high-quality apps and frameworks, it doesn’t replace the hands-on testing you get from team members and testers. When Xcode Cloud verifies a change to your code (CI), it can automatically deliver (CD) a new version of your app to internal testers with TestFlight. Xcode Cloud can also sign your app for external testing with TestFlight and submission to app review. You can also upload the exported app archive or a framework to your own server.\n\nCollaborative software development with Xcode Cloud\n\nSource control with Git helps you manage changes to your code. For example, Git branches enable you to make a change without affecting your verified, stable codebase. Additionally, branches are helpful when you develop your app or framework as a team. However, merging changes, resolving conflicts, and verifying code changes can be time-consuming.\n\nTo make code review and merging easier, SCM providers offer support for pull requests (PRs), also known as merge requests. When you create a PR, you inform your team that a change is ready for review, and you and your team can take a look at each other’s code changes, and provide and address feedback before merging branches.\n\nIf you develop code as a team, or if you work on several changes at the same time, a common practice to follow is to use separate branches for each change and then create PRs to receive code reviews from your peers. This introduces another verification step that helps you identify errors before they become serious issues.\n\nXcode allows you to create, view, and comment on PRs, and merge changes into your codebase if you host your Git repository with Bitbucket Server, GitHub, or GitHub Enterprise.\n\nYou can also configure Xcode Cloud to detect new PRs, or changes to an existing PR. When it detects a change, Xcode Cloud merges the involved branches in a temporary build environment, and automatically builds your project and runs your tests to verify the merged code. After verifying the changes, Xcode Cloud adds a status message to the PR to inform you of the result.\n\nTip\n\nUsing your SCM provider’s website, you can require the Xcode Cloud build to succeed before team members can complete the PR and merge branches.\n\nSee Also\nEssentials\nRequirements for using Xcode Cloud\nReview account, project, and source control requirements before configuring your project or workspace to use Xcode Cloud."
  },
  {
    "title": "Requirements for using Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/requirements-for-using-xcode-cloud",
    "html": "Overview\n\nXcode helps you configure your project or workspace to use Xcode Cloud. For a smooth configuration process, review requirements for using Xcode Cloud and make changes as needed. Then, configure your project or workspace to use Xcode Cloud and start practicing continuous integration and delivery (CI/CD).\n\nDeveloper account requirements\n\nTo use Xcode Cloud, you must:\n\nBe enrolled in the Apple Developer Program.\n\nUse Xcode 14.0.1 or later.\n\nAdd your Apple ID under Accounts in Xcode settings.\n\nHave an app record for your app in App Store Connect or have the required role or permission to create one.\n\nTo create an app record, you must have the App Manager, Admin, or Account Holder role for your Apple Developer team. If you have the Developer role, you need the Create Apps permission. If you don’t have the required role or permission, work with a team member who does. For more information, see Create an app record in App Store Connect.\n\nNote\n\nDepending on how much you use Xcode Cloud, you may need an optional Xcode Cloud subscription plan. To manage Xcode Cloud subscription plans, you must have the Account Holder role. For more information on subscription plans, see Get started with Xcode Cloud.\n\nFor more information about roles in App Store Connect, see Role permissions. For more information about creating an app record, see Add a new app.\n\nProject and workspace requirements\n\nTo use Xcode Cloud, be sure to meet the following project and workspace requirements:\n\nYou use a consistent Xcode project or workspace.\n\nYou use shared schemes. For information on sharing a scheme, see Customizing the build schemes for a project.\n\nYou’ve enabled the archive action for the scheme that builds your app or framework.\n\nYou use Xcode’s new build system. For more information about the new build system, see Build System Release Notes for Xcode 10. For details about how to turn on the new build system, see Choose the build system.\n\nYour dependencies and additional third-party tools are available to Xcode Cloud. For more information on making tools and dependencies available to Xcode Cloud, see Making dependencies available to Xcode Cloud.\n\nYou use automatic code signing. To learn more about automatic code signing, see Signing & Capabilities Workflow and Code Signing.\n\nYou set the bundle identifier for your app target in the Signing & Capabilities tab of your Xcode project or workspace. If you use .xcconfig files to set the bundle identifier, see Review Xcode Cloud workflows for more information.\n\nImportant\n\nXcode Cloud requires a consistent Xcode project or workspace that’s always present. If you use a third-party tool that dynamically generates or edits your project or workspace, the initial configuration of Xcode Cloud and subsequent builds may fail.\n\nSource control requirements\n\nUsing Git for source control is a requirement to use Xcode Cloud. To learn more about using source control with Git in Xcode, see Source control management.\n\nXcode Cloud supports the following source code management (SCM) providers:\n\nBitbucket Cloud and Bitbucket Server\n\nGitHub and GitHub Enterprise\n\nGitLab and self-managed GitLab instances\n\nNote\n\nIf you use a self-hosted SCM provider — for example, Bitbucket Server — make sure your Git server is accessible to Xcode Cloud. Check your firewall’s inbound HTTPS allow list and grant Xcode Cloud access to your Git server by adding the IP address ranges 17.58.0.0/18, 17.58.192.0/18, and 57.103.0.0/22.\n\nAdditionally, you need a certain permission or role to connect Xcode Cloud to your Git repository. The exact permission depends on the SCM provider you use:\n\nIf you host your code on Bitbucket Cloud or Bitbucket Server, you need the administrator permission.\n\nIf you host your code on GitHub or GitHub Enterprise, you need to be an organization owner or need the admin permission if you don’t use a GitHub organization.\n\nIf you host your code on GitLab, or on a self-managed GitLab instance, you need the maintainer permission.\n\nIf you don’t have the required role or permission, work with a team member who does. For more information, see Connect Xcode Cloud to an admin-managed Git repository.\n\nSee Also\nEssentials\nAbout continuous integration and delivery with Xcode Cloud\nLearn how continuous integration and delivery with Xcode Cloud helps you create high-quality apps and frameworks."
  },
  {
    "title": "Testing a beta OS | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/testing-a-beta-os",
    "html": "Overview\n\nTo catch API issues or incompatibilities, test your app on every released beta version during the beta release cycle. Beta software can introduce new issues in your app. To reduce the likelihood that these issues will impact your customers, identify, report, and address them as early in the beta release cycle as possible. As the beta release cycle progresses, and Apple promotes the beta to Release Candidate, making changes without causing other instabilities becomes more difficult, so report issues as soon as you identify them.\n\nInstall the beta OS\n\nTo begin testing your app on a beta OS, download and install the beta OS on a device you plan to use for testing. Test your app on the beta OS for each platform on which your app is available: Mac, Apple TV, Apple Watch, iPhone or iPad. To find the latest beta OS for each platform, and information about preparing to install the beta OS, see Using Apple Beta Software.\n\nInstall your app\n\nTo find the problems that your users might experience on the new version of the OS in your current app, install the current version of your app on your test device, either from the App Store or from TestFlight. Rebuilding your app using the beta SDK might introduce further changes that your customers don’t experience in the current version of your app.\n\nTest for changes in API behavior\n\nThe behavior of APIs in system frameworks that you use can change between releases. To identify changes in behavior, thoroughly test your app by exercising all code paths in your app. Test your app for each major OS version it supports, on at least one device for each family of devices that your customers use. Device families have the same architecture, screen resolution, and hardware capabilities. At a minimum, test your iOS, iPadOS, watchOS, and tvOS apps using Simulator. However, Simulator provides limited testing coverage and is not a substitute for physical hardware with real memory and performance constraints.\n\nIf you don’t notice any issues or changes in API behavior, then you don’t need to make any changes to your app, but you still need to test each beta OS release. If you notice a change in the behavior in some part of your app, it might be caused by a change in API behavior in the beta OS.\n\nOnce you identify a change in your app’s behavior, locate the portion of your code that relates to that behavior. In this portion of code, identify the system framework APIs involved, and then report the change in API behavior using Feedback Assistant. When you submit your feedback, include a runnable Xcode project that reproduces the problem, and provide a clear description of the issue with details about the differences between the observed behavior and the expected behavior.\n\nRemember to update your feedback for each subsequent beta release. Reporting issues early and often throughout the beta release cycle provides the best chance for issue resolution before the OS revision goes public.\n\nAddress changes in API behavior\n\nIf your observed change in behavior results from a bug in your code, you can directly address the issue. To debug the issue, rebuild your app using the Xcode beta that contains the SDK for the beta OS you’re testing.\n\nRebuilding your app using a new SDK can cause further changes in API behavior, so after rebuilding follow the same beta-testing procedure to identify and report new changes. Additionally, rebuilding your app using a new SDK can cause changes when your app runs on older operating systems. To avoid missing issues that might occur on a unique device configuration, test on each device configuration your customers may have whenever you rebuild your app with a new SDK.\n\nThe Developer Forums are a great resource to discuss potential workarounds and solutions for issues in your code.\n\nImportant\n\nReport all issues using Feedback Assistant. Discussing an issue on a Developer Forum is helpful as a second step after you report the issue.\n\nIf you identify a change in API behavior that reproduces on the older, non-beta OS, report the issue using Feedback Assistant. Mention all OS versions that can reproduce the issue in your feedback, and also include a runnable Xcode project that demonstrates the issue. If you require assistance while investigating a workaround for the issue, Submit a Developer Technical Support Incident to get help from Apple’s Developer Technical Support Group (DTS).\n\nSee Also\nTesting\nTesting a release build\nRun your app in simulated user environments to discover and identify deployment errors."
  },
  {
    "title": "Viewing and responding to feedback from beta testers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/viewing-and-responding-to-feedback",
    "html": "Overview\n\nWhen you distribute a beta version of your app through the TestFlight app, testers can provide you with screenshots and feedback about their experiences. This feedback can give you an important perspective on how your app functions in real-world-scenarios, and help you iterate on features, improve your UI, and address issues.\n\nYou can view people’s feedback in Xcode‘s Feedback organizer and on your app’s TestFlight page in App Store Connect. The Feedback organizer provides the ability to respond to the tester, share the feedback among your development team, take notes as you work on issues, and mark items as you resolve them.\n\nFor more information about distributing a beta version of your app, see Distributing your app for beta testing and releases.\n\nNote\n\nFeedback from testers for iOS 12 and earlier, tvOS, and watchOS doesn’t appear in the Feedback organizer. That feedback goes to the email address you provide in the Feedback Email field of your app’s Test Information page in App Store Connect.\n\nView feedback from testers\n\nTo view feedback from your app’s testers:\n\nIn Xcode, choose Window > Organizer from the menu bar.\n\nSelect Feedback from the Reports section of the sidebar.\n\nSelect your app from the pop-up button at the top of the sidebar.\n\nXcode shows the list of available apps organized by platform. The feedback for the selected app appears in a grid. To focus on specific reports, use the filter bar at the top of the window to filter by kind, app version and build, type, and run destination.\n\nThe items in the grid show previews of feedback, including screenshots when available, and a summary of the feedback text. An inspector to the right of the grid shows the details for the selected report.\n\nDouble-click a preview to display the report’s complete text and larger versions of any attached screenshots.\n\nFollow up and track progress\n\nTo follow up with a tester who provides feedback, click the email button at the top of the inspector.\n\nNote\n\nIf you send a tester an invitation email, their email address displays in the inspector. If you invite a tester with a public link, they display as anonymous unless they enter their email address when submitting feedback. The email address only displays for that particular piece of feedback.\n\nTo share a link to a report with another member of your development team, select the item you want to share from the grid and click the Share button at the trailing edge of the window‘s toobar. If the team member has the necessary authorization, they can click the shared link to open the Feedback organizer in Xcode with the preview of the report.\n\nTo rename reports to help keep them organized and to add notes, use the controls at the bottom of the inspector. Use the Mark as Resolved button in the inspector, or the checkbox next to each preview, to keep track of issues as you resolve them."
  },
  {
    "title": "Synchronizing your code signing identities with Apple Developer Portal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/sharing-your-teams-signing-certificates",
    "html": "Overview\n\nSigning your app assures people that the app comes from your organization. For many common workflows, Xcode automatically manages certificates and code signing identities. If you need to manage code signing identities yourself — for example, to integrate with an external build system — use Xcode settings to create code signing identities and distribution signing identities, share them with other team members, and keep your local identities synchronized with Apple Developer Portal. For creating, managing, and revoking certificates in Apple Developer Portal, see Developer Account Help.\n\nCreate a new code signing identity\n\nIf you need to generate a code signing identity for a particular purpose — for example to integrate with an external build system — use Xcode to create it by doing the following:\n\nOpen Xcode.\n\nChoose Xcode > Settings.\n\nIn the toolbar, click Accounts.\n\nSelect your Apple ID from the list of accounts.\n\nSelect the team to create the code signing identity for from the list of your Apple ID’s teams.\n\nClick Manage Certificates.\n\nClick the Add button (+) in the bottom corner of the signing certificates panel, shown below.\n\nChoose the type of certificate that you need.\n\nExport your signing identity to share with a team member\n\nExport an identity when another member of your team needs to use the identity and cannot generate one in Xcode. For example, if your team manually manages signing identities, export a distribution signing identity to share with the team member who distributes your team’s apps. Xcode automatically creates and shares cloud-managed certificates among your team, so you don’t need to manually export cloud-managed certificates. For more information about cloud-managed certificates, see Cloud-managed certificates.\n\nAnybody who gets access to the exported signing identity and learns (or guesses) the password can distribute signed software that appears to users and the operating system to come from your Apple Developer account. Use a strong password for exported signing identities, verify the identity of people you share the exported identity with, and use different channels to share the exported identity and the password. For example, it is better to email the exported identity and have a FaceTime call with your team member to disclose the password, than to send an email containing the password with the exported identity in an attachment.\n\nFor more information on using and protecting code signing identities for the Apple Developer Program, see Certificates.\n\nTo export a signing identity as a password-protected PKCS#12 file:\n\nOpen Xcode.\n\nChoose Xcode > Settings.\n\nIn the toolbar, click Accounts.\n\nSelect your Apple ID from the list of accounts.\n\nSelect the appropriate team from the list of your Apple ID’s teams.\n\nClick Manage Certificates.\n\nControl-click the certificate corresponding to the signing identity that you want to export in the certificates management panel, and choose Export Certificate.\n\nIn the panel that appears, choose the location to save the PKCS#12 file.\n\nEnter a file name, and a password to protect the identity’s private key.\n\nClick Save.\n\nRecover a missing private key from another team member\n\nIf you have a certificate but not the corresponding private key, you can’t use that certificate for code signing or generating other digital signatures. You must have the complete digital identity to sign code and other digital objects.\n\nIf you need to obtain the private key from another team member for a certificate stored in the Xcode certificate manager, Control-click on the certificate and choose Email Creator. This opens a new email message to the person who created the digital identity. That person can then follow the steps in the previous section to send you a PKCS#12 file that contains the code signing identity.\n\nAfter your team member sends you the exported code signing identity, import it into your keychain:\n\nDouble-click the .p12 file.\n\nEnter the password for the file when prompted by Keychain Access.\n\nKeychain Access imports the code signing identity into your login keychain.\n\nDelete a revoked certificate\n\nControl-click the certificate that you want to delete in the certificates management panel, and choose “Delete Certificate”. Xcode prompts you for confirmation, and removes the certificate and corresponding private key from your keychain.\n\nYou can only delete certificates that you or a team member have revoked in the developer portal. For more information on revoking certificates, see Revoke a certificate.\n\nSee Also\nCode signing\nUsing the latest code signature format\nUpdate legacy app code signatures so your app runs on current OS releases.\nSigning a daemon with a restricted entitlement\nWrap a daemon in an app-like structure to use an entitlement thatʼs authorized by a provisioning profile."
  },
  {
    "title": "Signing a daemon with a restricted entitlement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/signing-a-daemon-with-a-restricted-entitlement",
    "html": "Overview\n\nSome APIs are usable from a daemon but require that the daemon claim a restricted entitlement thatʼs authorized by a provisioning profile. For example, the Endpoint Security API is usable from a daemon but requires that the daemon has the com.apple.developer.endpoint-security.client entitlement, and that it’s authorized by a provisioning profile. This is problematic because a daemon is a standalone executable, so you canʼt embed a provisioning profile in it. To get around this limitation, wrap your daemon in an app-like structure.\n\nImportant\n\nIf the API youʼre using supports system extensions, avoid this issue by switching from a daemon to a system extension. System extensions readily support provisioning profiles, and Xcode automatically creates and embeds the profile in that case.\n\nCreate a minimal daemon project\n\nThe basic idea is to create an app target, rather than a command-line tool target, and then remove all of the app-specific content and replace it with your daemon code. To start, create a new project with an app target by choosing File > New > Project and selecting the macOS > App template. Set the Interface popup to Storyboard, the Life Cycle popup (if present) to AppKit App Delegate, and the Language popup to Swift.\n\nNote\n\nThis example uses Swift but this approach works just fine if you choose Objective-C.\n\nIn the General tab of the target editor, ensure that the Bundle Identifier field has the right value. This is important because your provisioning profile is tied to your App ID, and the bundle identifier is a key part of that App ID.\n\nAlso, clear the Deployment Info > Main Interface field and set the App Icons > Source popup to “Donʼt use asset catalogs”.\n\nSwitch to the Signing & Capabilities tab and configure it as follows:\n\nEnsure that “Automatically manage signing” is set.\n\nSelect your team in the Team popup.\n\nRemove the App Sandbox capability (if present). The App Sandbox is, as the name suggests, not appropriate for daemons.\n\nAdd the Hardened Runtime capability, which youʼll need to notarize your daemon.\n\nAdd the Custom Network Protocol capability, which enables the com.apple.developer.networking.custom-protocol entitlement that must be authorized by a provisioning profile. Adding it to your target triggers Xcodeʼs automatic code-signing machinery to register your App ID, create a provisioning profile for that App ID, and embed that provisioning profile in the built product.\n\nImportant\n\nIf your ultimate goal is to use the com.apple.developer.endpoint-security.client entitlement, first add the Custom Network Protocol capability to force Xcode to register your App ID and generate an initial provisioning profile. Then follow the instructions on Provisioning with managed capabilities to add the Endpoint Security additional capability to your App ID. Finally, remove the Custom Network Protocol capability, assuming your daemon doesn’t need it for other reasons.\n\nSwitch to the Build Settings tab and remove the Enable App Sandbox (ENABLE_APP_SANDBOX) build setting, if present.\n\nSwitch to the Info tab and delete all the app-specific items (NSPrincipalClass, NSMainStoryboardFile, NSSupportsSuddenTermination, NSSupportsAutomaticTermination, and CFBundleIconFile). Some of these items may not be present, depending on the exact version of Xcode youʼre using.\n\nIn the Project navigator, remove the AppDelegate.swift, ViewController.swift, Assets.xcassets, and Main.storyboard files.\n\nAdd a main.swift file and populate it with your daemon code. For a minimal daemon, use this:\n\nimport Foundation\n\n\n/// A helper for calling the Security framework from Swift.\n\n\nfunc secCall<Result>(_ body: (_ resultPtr: UnsafeMutablePointer<Result?>) -> OSStatus  ) throws -> Result {\n    var result: Result? = nil\n    let err = body(&result)\n    guard err == errSecSuccess else {\n        throw NSError(domain: NSOSStatusErrorDomain, code: Int(err), userInfo: nil)\n    }\n    return result!\n}\n\n\nfunc main() throws {\n    let me = try secCall { SecCodeCopySelf([], $0) }\n    let meStatic = try secCall { SecCodeCopyStaticCode(me, [], $0) }\n    let infoCF = try secCall { SecCodeCopySigningInformation(meStatic, [], $0) }\n    let info = infoCF as NSDictionary\n    let entitlements = info[kSecCodeInfoEntitlementsDict] as? NSDictionary\n    NSLog(\"entitlements: %@\", entitlements ?? [:])\n}\n\n\ntry! main()\n\n\nThis code logs the current processʼs entitlements, which is a good way to confirm that youʼre set up correctly.\n\nBuild and run the daemon from Xcode. The program logs its entitlements:\n\n2021-08-04 16:24:10.979941+0100 DaemonInAppsClothing[50219:4886989] entitlements: {\n    \"com.apple.application-identifier\" = \"SKMME9E2Y8.com.example.apple-samplecode.DaemonInAppsClothing\";\n    \"com.apple.developer.networking.custom-protocol\" = 1;\n    \"com.apple.developer.team-identifier\" = SKMME9E2Y8;\n    \"com.apple.security.get-task-allow\" = 1;\n}\n\n\nThe final structure of your daemon should look like this:\n\nDaemonInAppsClothing.app/\n  Contents/\n    Info.plist\n    MacOS/\n      DaemonInAppsClothing\n    PkgInfo\n    _CodeSignature/\n      CodeResources\n    embedded.provisionprofile\n\n\nNote the presence of the embedded provisioning profile; itʼs this profile that authorizes your daemon to use the com.apple.developer.networking.custom-protocol entitlement.\n\nTest your daemon\n\nTo properly test your daemon, run it in a daemon context. First, copy the built daemon to a secure location:\n\n% sudo mkdir \"/Library/Application Support/DaemonInAppsClothing\"\n% sudo cp -R \"DaemonInAppsClothing.app\" \"/Library/Application Support/DaemonInAppsClothing/\"\n\n\nNow create a launchd property list file that points to the daemonʼs main executable:\n\n% /usr/libexec/PlistBuddy -c \"Add :Label string com.example.apple-samplecode.DaemonInAppsClothing\" \"com.example.apple-samplecode.DaemonInAppsClothing.plist\"\nFile Doesn't Exist, Will Create: com.example.apple-samplecode.DaemonInAppsClothing.plist\n% /usr/libexec/PlistBuddy -c 'Add :Program string \"/Library/Application Support/DaemonInAppsClothing/DaemonInAppsClothing.app/Contents/MacOS/DaemonInAppsClothing\"' \"com.example.apple-samplecode.DaemonInAppsClothing.plist\"\n% cat com.example.apple-samplecode.DaemonInAppsClothing.plist \n…\n<dict>\n    <key>Label</key>\n    <string>com.example.apple-samplecode.DaemonInAppsClothing</string>\n    <key>Program</key>\n    <string>/Library/Application Support/DaemonInAppsClothing/DaemonInAppsClothing.app/Contents/MacOS/DaemonInAppsClothing</string>\n</dict>\n</plist>\n\n\nCopy that to /Library/LaunchDaemons and then load and start your daemon:\n\n% sudo cp com.example.apple-samplecode.DaemonInAppsClothing.plist /Library/LaunchDaemons \n% sudo launchctl load /Library/LaunchDaemons/com.example.apple-samplecode.DaemonInAppsClothing.plist \n% sudo launchctl start com.example.apple-samplecode.DaemonInAppsClothing                      \n\n\nRun the Console app and look in the system log. At the point when you started the daemon, youʼll see a log entry like this:\n\nentitlements: {\n    \"com.apple.application-identifier\" = \"SKMME9E2Y8.com.example.apple-samplecode.DaemonInAppsClothing\";\n    \"com.apple.developer.networking.custom-protocol\" = 1;\n    \"com.apple.developer.team-identifier\" = SKMME9E2Y8;\n    \"com.apple.security.get-task-allow\" = 1;\n}\n\n\nIf you miss it, run the launchctl start command to start your daemon again.\n\nIntegrate your daemon code\n\nNow that you have a working minimal daemon, itʼs time to integrate your real daemon code into the project. Add your code to the project as you would with any other Xcode project. If necessary, replace main.swift with a C, C++, Objective-C, or Objective-C++ main entry point.\n\nOr, if youʼre using an alternative build system, like a makefile, update it to create a structure that matches the one created by Xcode.\n\nSee Also\nCode signing\nUsing the latest code signature format\nUpdate legacy app code signatures so your app runs on current OS releases.\nSynchronizing your code signing identities with Apple Developer Portal\nEnsure you and other team members can sign your organization’s code and installer packages in Xcode."
  },
  {
    "title": "Using the latest code signature format | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/using-the-latest-code-signature-format",
    "html": "Overview\n\nBefore you distribute an app, you apply a code signature to it. The signature certifies that you are the app’s creator and enables the system to detect unwanted modifications — whether accidental or malicious — that happen after you sign your app. As a security measure, iOS refuses to launch an app that has a missing or invalid signature.\n\nStarting in iOS 15, iPadOS 15, tvOS 15, and watchOS 8, the system checks for a new, more secure signature format that uses Distinguished Encoding Rules, or DER, to embed entitlements into your app’s signature. Apps signed with a previous signature format will not launch.\n\nDetermine whether your app needs a new signature\n\nThis change to DER embeddded entitlements won’t affect most apps. For apps that you distribute through the App Store or TestFlight, App Store Connect first verifies your signature, and then re-signs the app using an Apple identity, before making the app available for download. Apps available through these channels already have the new signature format.\n\nFor apps that you distribute other ways, such as Ad Hoc or through the Apple Developer Enterprise Program, Xcode and the codesign utility have created signatures that use the new format for several years. If you signed your app on a Mac running macOS 10.14 through macOS 11, the app already has the new signature format, but your signature may not include the required DER entitlements. macOS 11 and later will sign app bundles with the new signature format that include the DER entitlements by default.\n\nTo check whether an app called MyApp.app has the new signature, you can use the codesign utility:\n\n% codesign -dv /path/to/MyApp.app\n\n\nLook in the output for a string such as CodeDirectory v=20500. For any value of v less than 20400, you need to re-sign your app.\n\nIf the code directory value is 20400 or higher, and the app does not install on iOS 15, iPadOS 15, tvOS 15, or watchOS 8, confirm that the system has added DER entitlements to the app’s signature. Also confirm that you have correctly signed any nested code, for example, an app extension, a framework, or a bundled watchOS app.\n\nTo check whether the app has the DER entitlements, look for the hash list under Page size in the signature. If -5 contains a value and -7 contains a zero value, or is not present, you need to re-sign your app to include the new DER entitlements.\n\nValid signature:\n\nPage size=4096\n     -7=f4c7c0ae394247097dca9b19333001200747691e1d9e25ec0cf0f35a8ade21f3\n     -6=0000000000000000000000000000000000000000000000000000000000000000\n     -5=7379374fd375633558fd972e33809c06e61f9f8191f67c71875899b0dc290945\n     -4=0000000000000000000000000000000000000000000000000000000000000000\n     -3=53cc3cc9830555e6d7bc864522fdf160b61ccc0d2fda9331368d333dfaa4fe24\n\n\nInvalid signature:\n\nPage size=4096\n     -5=7c741a970873bb7f6a05c1ad5b9425f4b5b1ac86645b2cb8c842a57f51818eb5\n     -4=0000000000000000000000000000000000000000000000000000000000000000\n     -3=f7ddc8d932def2f393dfc1719252e61b1561afeed76d32044ae0cd793e380bc6\n     -2=904f563968898c7569794e19bcd9304d46ca5c0b9f09c792081bdb8ec9c04c92\n\nDetermine whether your app needs a new provisioning profile\n\nStarting in iOS 15, iPadOS 15, tvOS 15, and watchOS 8, apps that have entitlements, and that you build outside the com.apple.developer namespace, and are not included by default in a provisioning profile (including application-identifier or get-task-allow) may require a DER-encoded version of the provisioning profile. Beginning with Xcode 13, provisioning profiles are issued with DER encoding by default. If your app successfully installs, but doesn’t launch, your app needs to be re-signed with a new provisioning profile. For more information about DER encoded provisioning profiles, see Provisioning profile updates.\n\nRe-sign your app\n\nIf your app doesn’t have the new signature format, or is missing the DER entitlements in the signature, you’ll need to re-sign the app on a Mac running macOS 11 or later, which includes the DER encoding by default.\n\nIf you’re unable to use macOS 11 or later to re-sign your app, you can re-sign it from the command-line in macOS 10.14 and later. To do so, use the following command to re-sign the MyApp.app app bundle with DER entitlements by using a signing identity named “Your Codesign Identity” stored in the keychain:\n\n% codesign -s \"Your Codesign Identity\" -f --preserve-metadata --generate-entitlement-der /path/to/MyApp.app\n\n\nFor more information on using the codesign utility, see its man page via Terminal.\n\nImportant\n\nOnly re-sign apps from the command-line as a last resort to update your code signature to include the DER entitlements. Re-signing apps from the command-line is not supported for iOS, iPadOS, watchOS and tvOS. It’s recommended that you to sign your app using macOS 11 or later as soon as you are able.\n\nIf your app contains nested code, such as an app extension, a framework, or a bundled watchOS app, sign each item separately, starting with the most deeply nested executable, and working your way out; then sign your main app last. Don’t include entitlements or profiles when signing frameworks. Including them produces an invalid code signature.\n\nFor general information about app distribution, see Distributing Your App for Beta Testing and Releases.\n\nSee Also\nCode signing\nSigning a daemon with a restricted entitlement\nWrap a daemon in an app-like structure to use an entitlement thatʼs authorized by a provisioning profile.\nSynchronizing your code signing identities with Apple Developer Portal\nEnsure you and other team members can sign your organization’s code and installer packages in Xcode."
  },
  {
    "title": "Distributing your app for beta testing and releases | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/distributing-your-app-for-beta-testing-and-releases",
    "html": "Overview\n\nAfter you thoroughly test your app in Xcode, distribute it to beta testers or release it to users to run on their personal devices. Choose a distribution method based on your app’s platform and development stage, and whether you belong to the Apple Developer Program. Before you release your app to users, distribute your final build using one of the beta test methods.\n\nIf necessary, review Preparing your app for distribution to complete the configuration of your project, before following these distribution steps.\n\nRelated sessions from WWDC23\n\nSession 10224: Simplify distribution in Xcode and Xcode Cloud\n\nJoin the Apple Developer Program\n\nDistribution methods range from exporting your app for test devices to uploading it to App Store Connect. You can use TestFlight to distribute beta builds to testers and collect feedback. If you want to distribute your app to registered devices, to beta testers using TestFlight, or through the App Store, join the Apple Developer Program. After you join the Apple Developer Program, Apple creates an App Store Connect account for you and you can start uploading builds.\n\nJoining the Apple Developer Program provides access to the distribution methods, as well as capabilities you can add to your app. A capability grants your app access to an app service provided by Apple, such as CloudKit, Game Center, or In-App Purchase. To learn more about capabilities, see Adding capabilities to your app.\n\nXcode uses cloud-managed signing certificates to automatically code sign your app. These signing certificates are associated with your Apple Developer Account, you can manage access to these certificates in App Store Connect. For information on managing access to certificate resources for your team, see Add and edit users.\n\nTo learn more about enrolling in the program, see Apple Developer Program.\n\nCombine multiplatform apps in a project or purchase\n\nIf you offer related apps on different platforms, combine them in one Xcode project or App Store purchase to make installation more convenient for users. To allow your customers to purchase related apps together from the App Store as a universal purchase or app bundle, see Offering Universal Purchase.\n\nCreate an archive of your app\n\nTo use any of the distribution methods, first create an archive of your app. An archive is a build of your app, including debugging information, that Xcode stores in a bundle. Xcode repackages the archive’s contents based on the distribution configuration you choose for your distribution.\n\nIn the main window of your Xcode project, choose a scheme and a run destination to build for from the Scheme toolbar menu. Then, choose Product > Archive to build the targets included in that scheme, for the class of device you select, and create an archive that appears in the Archives organizer.\n\nYou can open the Archives organizer directly by choosing Window > Organizer. If you want to confirm your app is ready to submit to TestFlight or the App Store without submitting it yet, select your archive and then click Validate App. Xcode will perform a limited, automated initial validation of the app and provide feedback.\n\nFor a Mac app built with Mac Catalyst, create separate archives for the iPad and Mac version. When creating the archive for the Mac version, choose My Mac as the run destination.\n\nNote\n\nEarlier versions of Xcode didn’t allow you to build an archive with a simulator set as the run destination. In Xcode 15 and later, choosing to build an archive with a simulator as the run destination builds an archive with all the CPU architectures necessary to run on that class of device.\n\nSelect a method for distribution\n\nYou can export the archive or upload it to App Store Connect. If you export the archive, you can distribute it outside of the App Store. Otherwise, upload the archive to App Store Connect to distribute it through TestFlight or the App Store.\n\nFrom the Organizer window in Xcode, select Archives in the sidebar and click Distribute App.\n\nSelect one of the following options to distribute using recommended settings:\n\nTestFlight & App Store\n\nDefault settings to distribute through TestFlight and submit to the App Store. Use this option to update the build number of the content in your archive, perform automatic code signing, and upload your app with symbols.\n\nTestFlight Internal Only\n\nDefault settings to distribute through TestFlight and restrict access to your team. Use this option to prevent a development build of your app from being submitted to the App Store.\n\nRelease Testing\n\nDefault settings to distribute a version to test before release. Use this option to perform automatic code signing similar to the App Store distribution option and export to install on devices your team registers with App Store Connect. This distribution method isn’t available for apps built for Mac.\n\nEnterprise\n\nDefault settings to distribe to members of your organization. Use this option if you’re a part of the Apple Developer Enterprise Program. This distribution method isn’t available for apps built for Mac.\n\nDirect Distribution\n\nDefault settings to distribute a macOS app directly. Use this option to notarize a Developer ID app for direct distribution. This distribution method is only available for apps built for Mac.\n\nDebugging\n\nDefault settings to distribute a version for debugging. Use this option to export a version to install and debug on devices your team registers with App Store Connect. This enables sandbox testing environments for some Capabilities that support them.\n\nAfter selecting a distribution option, click the Distribute button. Xcode begins processing, packaging, and uploading. Click the link at the at the end to access the builds page for the app on App Store Connect or click the Export button to access the assets locally.\n\nNote\n\nBefore you upload your app to the App Store for the first time, create an app record to register your app with App Store Connect. If you haven’t done this already, Xcode asks you for the information it needs to create this record for you. For more information, see Create an app record.\n\nCreate a custom distribution\n\nTo begin a custom distribution, which allows you to configure your own settings, click the Custom option.\n\nSelect from the following distribution methods:\n\nApp Store Connect\n\nDistribute using TestFlight or through the App Store.\n\nAd Hoc\n\nDistribute to a limited number of devices you register in App Store Connect. For more information on distributing to devices you register, see Distributing your app to registered devices.\n\nEnterprise\n\nDistribute to members of your organization if you’re a part of the Apple Developer Enterprise Program and are ready to release your app to users in your organization.\n\nDeveloper ID\n\nDistribute a macOS app outside the App Store that is notarized by Apple or signed with a Developer ID. This distribution method is only available for apps built for Mac.\n\nDevelopment\n\nDistribute to a limited number of devices you register in App Store Connect. For more information on distributing to devices you register, see Distributing your app to registered devices.\n\nCopy App\n\nDistribute a macOS app without code signing. This distribution method is only available for apps built for Mac.\n\nIf you choose App Store Connect or Developer ID as your distribution method, you select a destination option as well. You can choose to upload your build to the App Store, or Export your build locally to upload later.\n\nWhen distributing your app on TestFlight or the App Store, choose how to manage symbols and build numbers:\n\nStrip Swift symbols\n\nReduces the size of your app by stripping symbols from Swift standard libraries. This setting is only available if your project has embedded swift libraries.\n\nUpload your app’s symbols\n\nAllows Apple to provide you with symbolicated crash logs and other diagnostic information. A symbolicated log replaces memory addresses in logs with human-readable function names and line numbers. The symbols can also be useful in compatibility testing of your app with Apple products and services.\n\nManage version and build number\n\nAllows Xcode to update the build number of all the content in your archive.\n\nTestFlight internal testing only\n\nPrepares the app for distribution through TestFlight and restricts access to your team. Use this option to prevent a development build of your app from being submitted to the App Store.\n\nWhen selecting a distribution method that involves code signing, select a method for code signing.\n\nChoosing “Automatically manage signing” allows Xcode to manage signing for you. To manually sign your app, you use signing certificates. For information on sharing signing certificates, see Synchronizing your code signing identities with Apple Developer Portal.\n\nWhen packaging for self distribution using the Ad Hoc or Development option, choose whether to enable or disable App Thinning and configure on-demand resources settings. For more information about App Thinning and on-demand resources, see Reducing your app’s size and Doing advanced optimization to further reduce your app’s size.\n\nDistribute a beta version\n\nTo distribute a beta version of your app to offer a preview of an upcoming release, chose a distribution method that aligns with your testing resources:\n\nDistribute a beta version of your app to internal and external testers using TestFlight. The TestFlight app allows invited users to install, beta test, provide feedback, and get updates of your app. Apple distributes the beta version for you, you manage the builds and users in App Store Connect. To learn more, see TestFlight overview.\n\nDistribute a beta version to registered devices in your developer account. Choose this option only if you can reserve a portion of your limited development devices for beta testing. To learn more, see Distributing your app to registered devices.\n\nFor macOS apps, distribute an Apple-notarized build to testers before you distribute the app through the App Store. To learn more, see Notarizing macOS software before distribution.\n\nPublish on the App Store\n\nAfter beta testing your final build, submit it to App Review, then offer it on the App Store. For more information about the publishing process, see Overview of publishing an app.\n\nGo to App Review to review the App Store and Human Interface Guidelines. For platform specific guidance, see Submit your apps today.\n\nYou may need to enter additional information in App Store Connect before you can submit your app to App Review. After your app is uploaded or released, you can’t change some of this metadata, so it’s important to choose your settings carefully. For more information about this metadata, go to Required, localizable, and editable properties in App Store Connect Help.\n\nIf you used TestFlight to distribute a beta version, and entered the additional information required by App Store for a release, just submit the last build that appears in App Store Connect to App Review.\n\nIf you didn’t distribute the final build using TestFlight, prepare your app for distribution and create an archive of your app. Validate the archive and fix any validation errors before continuing. Then, upload it to App Store Connect and wait for it to pass the App Store Connect validation tests.\n\nTo submit the build to App Review, go to Submit for review.\n\nDistribute outside of the App Store\n\nFor macOS apps, you can export a notarized app for distribution outside of the App Store, but you may first need to disable capabilities that require the Apple Developer Program membership first, then distribute the app yourself to users. Notarize all software that you distribute outside of the App Store. This includes system extensions and drivers. To learn more, see Notarizing macOS software before distribution.\n\nDistribute enterprise apps\n\nThere are also several options for distributing business, customized, or in-house apps as well. For details, see Find the best way to reach your users. If you join the Apple Developer Enterprise Program, see Develop and distribute an enterprise app for enterprise-specific Xcode steps to export your app.\n\nReview crash, diagnostic, and metrics reports\n\nIf you distribute your app using TestFlight or through the App Store, you can view crash and diagnostic reports that Apple generates for you in the organizer. You can also use the organizer to review feedback from beta testers. If you distribute your app through the App Store, you can view metrics reports in the organizer too. For more information, see Acquiring crash reports and diagnostic logs and Viewing and responding to feedback from beta testers. For more information about performance improvements, see Improving your app’s performance and Analyzing the performance of your shipping app.\n\nSee Also\nDistribution and release\nDistributing your app to registered devices\nRegister devices in your developer account and deploy your app to them for testing."
  },
  {
    "title": "Distributing your app to registered devices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/distributing-your-app-to-registered-devices",
    "html": "Overview\n\nBefore Distributing your app for beta testing and releases, you can distribute progress builds to a limited set of users on known devices, without having to go through beta app review. To distribute to this group of users, register their devices in your developer account. You can register a limited number of devices, per product family per year, that your team uses for development and testing.\n\nPrepare for your build\n\nTo prepare to distribute your build, you need:\n\nAn App ID that you set up for your app in your developer account.\n\nA signing certificate with the public and private key. On iOS, iPadOS, watchOS, or tvOS you need a distribution certificate; on macOS you need a development certificate. For more information on signing certificates, see Certificates.\n\nA list of test devices registered in your developer account.\n\nA provisioning profile for your app and list of test devices. On iOS, iPadOS, watchOS, or tvOS you need a distribution profile; on macOS you need a development profile.\n\nIf you choose the default automatic signing, Xcode creates the provisioning profiles for you, that include all your registered devices; for more advanced cases like large teams with restricted access to signing assets or to only include a subset of your registered devices, prepare your provisioning assets manually. In both automatic and manual provisioning, you need to gather and add your list of test devices to your developer account. When you manually provision a profile, update your provisioning profile after adding test devices.\n\nEach iOS, iPadOS, tvOS, watchOS, and macOS device has a persistent, unique identifier referred to as a device ID. When you use automatic signing, Xcode registers the device for you. Otherwise, you need to collect the device ID and register the device in your developer account.\n\nRegister devices automatically in Xcode\n\nWhen you use automatic signing, Xcode registers the connected device or Mac for you. For iOS, iPadOS, or tvOS attach your device to your computer, and select Trust if the device asks to trust your computer. For watchOS, attach the paired phone for your watchOS device to your computer.\n\nIn Xcode, select your attached device as the run destination, and build and run your app. For more information on simulated apps, see Running your app in Simulator or on a device. If your device needs to be registered, click the Register button in the dialog that Xcode displays, and Xcode registers and adds the device to your provisioning profile.\n\nCollect device identifiers: iOS, iPadOS, tvOS, watchOS\n\nWhen you use manual signing, start by collecting the device identifier for your iOS, iPadOS, tvOS, or watchOS device by using either Finder or Xcode.\n\nAttach your device to your Mac with a cable, and select Trust if your device asks to trust your computer. For watchOS, attach the phone, to which your watch is paired, with to your Mac and use Xcode to find the identifier.\n\nUsing the Finder:\n\nLocate your device under the Locations section in the sidebar. For more information on what to do if the Locations section is not visible, see Customize the Finder toolbar and sidebar on Mac.\n\nSelect your device, then click the label below the device name in the info pane once to see the device’s serial number, UDID, and model. Additional clicks rotate through other device information, such as model and storage space, and IMEI and MEID.\n\nControl-click the label to copy the device ID, which the UI labels as UDID.\n\nUsing Xcode:\n\nSelect Windows > Devices and Simulators, then select the Devices tab.\n\nSelect your device under the Connected list.\n\nHighlight the device ID, which the UI labels as Identifier, to copy it.\n\nCollect device identifiers: macOS\n\nTo find the device ID for your Mac:\n\nChoose Apple menu > About this Mac.\n\nClick System Report.\n\nSelect Hardware to see the Hardware Overview; the UI displays the device ID as Hardware UUID (in macOS 10.15 and earlier) or Provisioning UDID (in macOS 11.0 and later).\n\nHighlight the Hardware UUID or Provisioning UDID to copy it.\n\nRegister devices in your developer account\n\nAfter you collect the device IDs, you can register them all at once by putting the device names and identifiers in a file. Sign into your developer account, then:\n\nSelect Certificates, Identifiers, and Profiles.\n\nSelect Devices.\n\nClick Download Sample File for an example file.\n\nCustomize the example file with your specific device information.\n\nUpload the device file.\n\nFor more information on multi-device registration, see Register multiple devices.\n\nAdd a single device by clicking the plus (+) button next to the Devices title. Specify the identifier and a name for the device. Use a name that makes the device easy to identify; for example, combine the owner’s name and device type, ”Ravi Patel’s iPhone 11”.\n\nYou can disable devices that you no longer permit to use your app: select the device and click Disable. Code signing doesn’t include the device while it’s disabled, but the device counts against the number of devices in the product family until your account renewal date. Disabling a device invalidates any provisioning profiles that include the device; automatic signing regenerates the profile the next time you build your app, or you can regenerate the profile manually if you’re not using automatic signing.\n\nUpdate your provisioning profile\n\nWhen you use automatic signing, Xcode automatically updates the provisioning profile when you export the app.\n\nTo use manual signing, sign into your developer account, select Certificates, Identifiers, and Profiles, then select Profiles. Click the plus sign next to the Profiles header to create a new provisioning profile. Then:\n\nSelect the type of profile by type and platform.\n\nSelect your App ID.\n\nSelect the signing certificate.\n\nSelect the device or devices to include in the profile.\n\nProvide a name for the profile.\n\nSelect Generate.\n\nYou can edit an existing profile and regenerate it to add or remove devices. Once you generate the profile, download it, then drag the downloaded profile to the Xcode dock icon and drop it to install it. You can also download it from Xcode Preferences > Accounts, using the Download Manual Profiles button when you select your account.\n\nArchive the app\n\nIn the main window of your Xcode project, choose a target and a build-only device or real device from the Scheme toolbar menu. You can’t create an archive when the target is a simulator. Choose Product > Archive to build the target and Xcode displays the archive in the Archives organizer.\n\nFor a Mac app built with Mac Catalyst, create separate archives for the iPad and Mac version. When creating the archive for the Mac version, choose My Mac as the run destination.\n\nExport the app\n\nFrom the archive, export a version of the app to distribute to users:\n\nIn the Archives organizer, select the archive, then click Distribute App.\n\nSelect the Ad-Hoc or Development method to distribute your app to registered devices.\n\nIf you’re using manual signing, select your distribution provisioning profile, otherwise let Xcode perform any updates necessary for automatic signing.\n\nSave the exported app.\n\nFor more information on solving issues with code signing, see Code Signing.\n\nInstall the app on user devices\n\nWhen you save the exported app, Xcode creates a folder that contains a few files, including the iOS App file, which is a file with an .ipa filename extension. Distribute that file to your users so they can install it on their devices by using Xcode or Apple Configurator 2.\n\nFor macOS, double-click the file to install and run it.\n\nTo install iOS, iPadOS, tvOS, or watchOS apps using Xcode:\n\nAttach the device to the computer, or attach the paired phone for a watchOS device.\n\nSelect Window > Devices and Simulators, and then select the Devices tab.\n\nSelect the attached device.\n\nClick the Add button (+) under the Installed Apps section.\n\nSelect the iOS App file to install the app.\n\nTo install iOS, iPadOS, tvOS, or watchOS apps with Apple Configurator 2:\n\nAttach the device to your Mac, or attach the paired phone for a watchOS device.\n\nSelect the attached device.\n\nClick the Add button (+).\n\nSelect the iOS App file to install the app.\n\nImportant\n\nThe first time you run your .ipa-based app on an iOS or watchOS device, you need to enable Developer Mode on that device. See Enabling Developer Mode on a device for more information.\n\nSee Also\nDistribution and release\nDistributing your app for beta testing and releases\nRelease your app to beta testers and users."
  },
  {
    "title": "Preparing your app for distribution | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/preparing-your-app-for-distribution",
    "html": "Overview\n\nPrepare your Xcode project for distribution before you upload a build to App Store Connect or export a build to distribute it outside of the App Store. Provide all the required information about your app—such as a unique bundle ID, build string, app icon, and launch screen. Choose the settings carefully because most of the information is not editable after you distribute a build through TestFlight or the App Store.\n\nFor additional information to enter in App Store Connect, see Required, localizable, and editable properties and App information (which contains more details) in App Store Connect Help.\n\nSet the bundle ID\n\nWhen you create your Xcode project from a template, the bundle ID (CFBundleIdentifier), which uniquely identifies your app throughout the system, defaults to the organization ID appended to the app name that you enter in reverse-DNS format—for example, the bundle ID becomes com.example.mycompany.HelloWorld.\n\nIf your organization ID is unique across all developers and your app name is unique within your organization, your default bundle ID should also be unique. For example, use your organization’s domain name as the organization ID to ensure that the bundle ID is unique.\n\nTo distribute your app through TestFlight and the App Store, you Create an app record in App Store Connect and enter a bundle ID that matches the one in your project. Add the bundle ID to your project in the project editor:\n\nChoose the target.\n\nClick the Signing & Capabilities pane.\n\nExpand Signing.\n\nEnter the bundle ID in the Bundle Identifier text field.\n\nAfter you upload your first build to App Store Connect, you can’t change the bundle ID, so carefully choose the organization ID when you create the project, or edit the bundle ID afterward. You can edit the name of the app until you submit the app to App Review.\n\nSet multiple bundle IDs to offer independent platform versions\n\nMultiplatform apps are built to use the same bundle ID for all platforms by default so you can offer the apps together on the App Store as a universal purchase (see Offering Universal Purchase).\n\nTo offer platform-specific versions of your app, create app records for each platform variant in App Store Connect and add a distinct bundle ID for each version. In the project editor, select the Signing & Capabilities pane and expand Signing. Under Signing, expand the region for each platform:\n\nEnter a distinct bundle ID.\n\nConfigure signing settings.\n\nIf you have In-App Purchases or Subscriptions, re-create them for each app version in App Store Connect. For more information, see Create consumable or non-consumable in-app purchases and Offer auto-renewable subscriptions in App Store Connect Help.\n\nAssign the project to a team\n\nIf you haven’t already done so, assign the project to a team. For example, if you want to distribute your app using TestFlight or through the App Store, assign all of the targets in a project to a team that belongs to the Apple Developer Program. When you upload or export your build, Xcode creates the necessary signing assets in the associated developer account.\n\nIn the project editor, select the Signing & Capabilities pane and choose a team from the Team pop-up menu.\n\nSet the supported destinations\n\nIndicate which devices and platforms your app supports. In the project editor:\n\nChoose the target.\n\nSelect the General pane.\n\nExpand the Supported Destinations section.\n\nClick the Add button (+), choose a device and platform. To remove a destination, select it and click the Remove button (-).\n\nSet the app category\n\nCategories help customers discover your app on the App Store. In App Store Connect, you set the primary and secondary categories that you want your app to appear under in the App Store. For macOS apps, you also set a category for your app in your project.\n\nSelect a category that matches or closely relates to the primary category you set in App Store Connect:\n\nChoose the target.\n\nSelect the General pane.\n\nExpand the Identity section.\n\nChoose a category from the App Category pop-up menu.\n\nFor guidance with choosing the most accurate and effective categories, see Choosing a category.\n\nSet the version number and build string\n\nThe version number (CFBundleShortVersionString) and build string (CFBundleVersion) uniquely identify the build of your app throughout the system. The version number appears in the App Store. For apps distributed through TestFlight or the App Store, the Xcode Organizer displays crashes and field reports for each build of an app version. For macOS apps, the version number and build string can also appear in the About window, see credits. The version number and build string are expected to be in the format [Major].[Minor].[Patch] where Patch is a maintenance release, as in 10.14.1. Both keys are required by the App Store. For macOS apps, you must increment the build string before you distribute a new build.\n\nIncrement the version number when you create a new version of your app. For more information, see Create a new app version in App Store Connect.\n\nXcode can update the build number when you upload a new archive to the App Store. To take advantage of this, use one of the preconfigured distribution methods from Xcode Organizer or enable the “Manage version and build number” setting from the App Store Connect distribution options for your Custom distribution method.\n\nIf you use a Custom distribution method and disable the “Manage version and build number” option, you need to manage the build string yourself and ensure that you increment this build string before archiving a build that you want to distribute. In the project editor, select the General pane, expand Identity, and set the version number and build string.\n\nNote\n\nBuild strings for Mac apps must increment across all versions of your app. Build strings for apps built for other platforms can start back over at 1 for new versions.\n\nEdit deployment info settings\n\nFor iOS and iPadOS apps, choose the device orientations your app supports.\n\nTo configure your app to support multiple windows, click the arrow next to Supports multiple windows. For details, see Specifying the scenes your app supports, and for sample code, see Supporting Multiple Windows on iPad.\n\nAdd an app icon and App Store icon\n\nAdd an icon to represent your app in various locations on a device and on the App Store.\n\nA project created from a template already contains the image set for app icons. The App Icons and Launch Images section of the General pane displays the name of the asset. Open the asset in the asset catalog to configure the icon asset.\n\nFor information on configuring your icons, see Configuring your app icon. For app icon guidance and metrics, read App icons in Human Interface Guidelines.\n\nProvide a launch screen\n\nA launch screen, is a user interface file that appears immediately when your app launches, then is quickly replaced with your app’s first screen. For apps and platforms that use them, the launch screen simply enhances the user experience by providing something for people to view while your app launches.\n\nEdit the LaunchScreen.storyboard file, which is included in your Xcode project when you create it from a template. Otherwise, you can add a launch screen file to an existing project, see Managing files and folders in your Xcode project.\n\nFor information about designing a launch screen, read Launching in Human Interface Guidelines.\n\nProvide usage descriptions to access protected resources\n\nThe first time your app attempts to access a protected resource, the system prompts for permission. It then generates a dialog that includes the name of your app and a usage description that you provide. For example, the usage description for accessing location data might be “Your location is used to provide turn-by-turn directions to your destination.” If you grant permission, the system remembers and doesn’t prompt again for that resource. If you deny permission, the access to that resource and any further attempts fail.\n\nYou must provide usage descriptions in the Information Property List for all protected resources your app accesses, such as a person‘s location, calendar, reminders, and contacts. Also provide usage descriptions for accessories, such as the camera and microphone.\n\nTo learn more, see Requesting access to protected resources.\n\nConfigure App Sandbox and hardened runtime (macOS)\n\nIf you distribute your macOS app through the App Store, you must enable App Sandbox. If you notarize your macOS app to distribute it outside of the App Store, you must enable hardened runtime and, optionally, can also enable App Sandbox.\n\nTo learn more about hardened runtime, see Hardened Runtime. For information about notarization, see Notarizing macOS software before distribution.\n\nSet the copyright key (macOS)\n\nFor macOS apps, set the copyright key (NSHumanReadableCopyright) in the information property list before you upload your app to App Store Connect.\n\nIn macOS, if you don’t pass a copyright string explicitly to the orderFrontStandardAboutPanel(_:) method that displays the About window, a localized version of the copyright key is displayed in the About window instead. For example, if you set the copyright key to @2002-2019 My Company, it appears at the bottom of the About window. You can localize the information property list for each language that you support.\n\nAdd export compliance information\n\nIf you distribute your app outside the United States or Canada, your app is subject to U.S. export laws. If your app uses encryption, it is subject to U.S. export compliance requirements. You can bypass the questions that App Store Connect asks you every time you submit your app for review by providing export compliance information in the Information Property List.\n\nTo learn more, see Complying with Encryption Export Regulations."
  },
  {
    "title": "Writing and running performance tests | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/writing-and-running-performance-tests",
    "html": "Overview\n\nPeople perceive responsiveness and efficiency as positive contributions to an app’s experience. Use performance tests to record metrics on the performance critical parts of your code, and discover when the performance regresses below an acceptable baseline.\n\nCreate a test target\n\nPerformance tests use the same XCTest framework to validate code behavior. Create a test target in your Xcode project that you can add behavior and performance tests to. To learn how to add a new target to your project, see Configuring a new target in your project.\n\nAdd a test case class and performance test methods\n\nYou organize performance tests into test case classes, which are subclasses of XCTestCase. For information on creating test case classes and test methods, see Defining Test Cases and Test Methods.\n\nA performance test method is a method on a test case class with a name that starts with test, no arguments, and no return value. The performance test calls one of the following methods to instruct XCTest to record metrics on your code’s performance:\n\nmeasure(_:)\n\nRecords the default performance metrics for the duration of execution of the block argument, using the default measure options.\n\nmeasureMetrics(_:automaticallyStartMeasuring:for:)\n\nRecords the specified performance metrics, either for the duration of execution of the block argument, or, if you pass false for the automaticallyStartMeasuring parameter, between calls to startMeasuring() and stopMeasuring() within the block argument.\n\nmeasure(metrics:block:)\n\nRecords the specified metrics for the duration of execution of the block argument, using the default measure options.\n\nmeasure(metrics:options:block:)\n\nRecords the specified metrics, either for the duration of execution of the block argument or between calls to startMeasuring() and stopMeasuring() within the block argument, depending on the specified measure options.\n\nmeasure(options:block:)\n\nRecords the default metrics, either for the duration of execution of the block argument or between calls to startMeasuring() and stopMeasuring() within the block argument, depending on the specified measure options.\n\nDetermine the performance metrics to record\n\nThe default behavior for measure(_:) and measure(options:block:) is to record the time spent in the measured code, in seconds. Change the default set of metrics collected by performance test methods in a test case class by overriding defaultPerformanceMetrics and defaultMetrics. Use a different measurement function from the list above to record different metrics in a specific test.\n\nFor information on the available metrics and on implementing your own metrics, see XCTMetric.\n\nConfigure your scheme and test plan for accurate performance measurements\n\nXcode uses test plans you create in your Xcode project to determine which tests to run for a scheme, and how to configure the tests. To ensure that you’re gathering real-world behavior metrics for your app, configure the performance test plan so it replicates the conditions under which the code runs on device. Configure your scheme to build for testing using the Release build configuration, and turn off the “Debug executable” setting.\n\nConfigure your test plan to disable code coverage and the runtime sanitization options. For more information on configuring test plans, see Improving code assessment by organizing tests into test plans.\n\nRun your performance test method\n\nRun your performance tests in the same way that you run tests to verify code behavior, as described in Running tests and interpreting results. In addition to the test outcome status icon in the source editor gutter next to the test method definition, Xcode shows an icon in the editor gutter next to any call to the performance measurement functions listed above. This icon is in one of the following states, depending on the outcome of the performance measurement:\n\nPerformance measurement status icon\n\n\t\n\nDescription\n\n\n\n\n\t\n\nA gray icon with a checkmark indicates that the recorded metrics were compared with the baseline value.\n\n\n\n\n\t\n\nA gray icon with a dot indicates that no baseline value was recorded for XCTest to compare the recorded metrics against.\n\nClick the performance measurement outcome icon to view a graph of the most recent values for the metrics recorded in the test, along with the average (mean) value for each metric recorded, as shown in the figure below.\n\nSet a baseline and tolerance\n\nDefine the threshold value for the recorded metrics in a performance test by setting a baseline value and maximum standard deviation. The test fails if the recorded metric is worse than the baseline value by more than the maximum standard deviation.\n\nTo set the baseline value for a performance test’s metric, follow these steps:\n\nIn Xcode, click the icon next to the performance measurement function call in the test to open the performance report overlay.\n\nClick Set Baseline.\n\nYou can subsequently change the baseline value by doing the following:\n\nIn Xcode, click the icon next to the performance measurement function call in the test to open the performance report overlay.\n\nClick Edit.\n\nEnter a new baseline value, or click Accept to use the current average recorded value as the new baseline.\n\nEnter a value in the Max STDDEV field to define the maximum standard deviation of the recorded metric from the baseline.\n\nClick Save.\n\nDiagnose a failing performance test\n\nIf a test fails, you can find out more details about why the test failed by Control-clicking the icon in the editor gutter next to the failing test, and choosing “Profile [the test’s name]” to open the test in Instruments. Alternatively, navigate to the failing test in the Xcode test navigator, Control-click it, and choose “Profile [the test’s name]”.\n\nFor information on how performance tests fit into an overall life cycle of improving your app’s performance, see Improving your app’s performance."
  },
  {
    "title": "Running tests and interpreting results | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/running-tests-and-interpreting-results",
    "html": "Overview\n\nAt different points in the software development workflow you will want to run subsets of your tests. While making changes to a particular method or class, running just the tests relevant to that unit gives you the fastest feedback about the state of your changes. When your change is ready for code review or integration, running all of the tests for the affected target can uncover any unexpected regressions. Finally, Xcode Cloud can run a complete set of tests with multiple configurations on a schedule, providing greater confidence in the correctness of your code while managing the increased execution time required for completing so many tests.\n\nTo run all of the tests for your project or workspace, you have two options: you can run them in Xcode (choose Product > Test), or you can run the xcodebuild command in Terminal:\n\n% xcodebuild test -scheme SampleApp\n\n\nConfigure which tests are run when you perform this action by editing your Xcode project’s scheme. For more information, see Customizing the build schemes for a project.\n\nRun all of the test methods in a test case\n\nNavigate to the Swift file containing the test case whose test methods you want to run in Xcode. Move the pointer over the diamond icon alongside the test case’s declaration in the editor gutter, shown in the figure below, and click the gray play icon.\n\nNote\n\nA test case is a subclass of XCTestCase that can contain multiple test methods. To learn how to create test cases and test methods, see Defining Test Cases and Test Methods.\n\nAlternatively, move the pointer over the test case in the Xcode Test navigator, then click the gray play icon shown in the figure below.\n\nXcode runs the selected test case and updates the icon to indicate the outcome. The possible states are:\n\nTest case status icon\n\n\t\n\nDescription\n\n\n\n\n\t\n\nA green icon with a checkmark indicates that the test methods in the test case passed.\n\n\n\n\n\t\n\nA red icon with an X indicates that at least one test method in the test case failed. The failure may also be due to a test method that should fail (marked by XCTExpectFailure(_:options:)) but didn’t.\n\n\n\n\n\t\n\nA gray icon with an X indicates that some test methods in the test case failed with expected failures, but there were no unexpected failures in the test case. You can mark a failure as expected using XCTExpectFailure(_:options:).\n\n\n\n\n\t\n\nA gray icon with an arrow indicates that Xcode skipped all test methods in the suite. You can tell Xcode to skip a test method using the XCTSkipIf(_:_:file:line:) or XCTSkipUnless(_:_:file:line:) functions, which raise instances of XCTSkip.\n\n\n\n\n\t\n\nA green icon with a minus sign (–) indicates that the test case had a mixed outcome: some test methods passed, while others failed with expected failures or were skipped.\n\n\n\n\n\t\n\nA red icon with a minus sign (–) indicates that the test case had a mixed outcome; some of the test methods failed while others failed with expected failures or were skipped.\n\nThe Xcode Log navigator contains more information about any test method failure, as shown below.\n\nTo run the test methods in a test case in Terminal, run xcodebuild by giving the test case’s identifier as the parameter to the -only-testing option. The identifier for a test case has the form target name/test case name.\n\n% xcodebuild test -scheme SampleApp -only-testing SampleAppTests/SampleAppTests\n\nRun a single test method\n\nTo run a single test method in Xcode, move the pointer over the Swift file that contains the test method you want to run, then click the diamond icon next to the test method’s name.\n\nAlternatively, locate the test method in the Xcode Test navigator by moving the pointer over the test method name, and click the gray play icon.\n\nXcode runs the selected test method and updates the icon to indicate the outcome. The possible states are:\n\nTest method status icon\n\n\t\n\nDescription\n\n\n\n\n\t\n\nA green icon with a checkmark indicates that the test method passed.\n\n\n\n\n\t\n\nA red icon with an X indicates that the test method failed. The failure may also be due to a test method that is expected to fail (marked by XCTExpectFailure(_:options:)) that didn’t fail when it ran.\n\n\n\n\n\t\n\nA gray icon with an X indicates that the test method failed with an expected failure.\n\n\n\n\n\t\n\nA gray arrow indicates that Xcode skipped the test method.\n\nTo run a single test method in Terminal, run xcodebuild by giving the test method’s identifier as the parameter to the -only-testing option. The identifier for a test method has the form target name/test case name/test method name.\n\n% xcodebuild test -scheme SampleApp -only-testing SampleAppTests/SampleAppTests/testEmptyArrayWhenNoOverlappingNotes\n\nRun test methods repeatedly to determine reliability\n\nControl-click the icon next to a test method or test case and select “Run <name of the test method or test case> Repeatedly”. In the panel that appears, choose when to stop running the test. The options are:\n\nStop after failure\n\nRun the test until the first time it fails, or the maximum repetitions are reached.\n\nStop after success\n\nRun the test until the first time it passes, or the maximum repetitions are reached.\n\nStop after maximum repetitions\n\nRun the test the specified number of times, regardless of its outcome.\n\nChoose the maximum number of times to repeat the test, whether to pause execution if the test fails, and whether to restart the test runner for each repetition. Finally, click Run to repeatedly run the test.\n\nTo repeatedly run test cases or test methods in Terminal, specify the number of repetitions with the -test-repetitions option, optionally specifying whether the tests should repeat until success or failure, and whether to restart the test runner for each repetition:\n\n% xcodebuild test -scheme SampleApp -only-testing SampleAppTests/SampleAppTests/testEmptyArrayWhenNoOverlappingNotes -run-tests-until-failure -test-iterations 20\n"
  },
  {
    "title": "Simulating location in tests | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/simulating-location-in-tests",
    "html": "Overview\n\nAutomated tests, created with XCTest, are most reliable when you control all of the inputs to the code under test. When testing code that works with location APIs, use specific values for coordinates and locations so that the outcome of the tests doesn’t depend on the physical location of the device running the tests.\n\nTest your code with different simulated locations to improve the test coverage of your location-handling code.\n\nSimulate a static device location\n\nIf your app uses Core Location or MapKit, the app’s behavior under test can depend on the device’s location. Configure your test plan to simulate a predetermined location so tests run with repeatable inputs. To set a simulated location in a test plan, follow these steps:\n\nOpen Xcode.\n\nChoose Product > Test Plan > Edit Test Plan.\n\nIn the test plan editor pane, choose Configuration.\n\nUnder Localization, click Simulated Location and choose a location from the menu.\n\nFor more information on configuring test plans, see Improving code assessment by organizing tests into test plans.\n\nNote\n\nWhen you set a simulated location in Xcode, the location changes only for code running in the test bundle. UI automation tests communicate with your app running as a separate process, so in those tests, your app doesn’t use the simulated location. To simulate location in a UI automation test, see the “Set a simulated location for UI automation” section below.\n\nReplay a previously recorded journey\n\nTest features of your app that work with changes to the device’s location by setting the simulated location to a GPX file. Xcode uses the GPX file to replay a journey while your tests are running, updating the simulated location, elevation, and velocity of the device to replicate the recorded journey. To add a GPX file to your workspace, follow these steps:\n\nOpen Xcode.\n\nChoose Product > Test Plan > Edit Test Plan.\n\nIn the test plan editor pane, choose Configuration.\n\nUnder Localization, click Simulated Location and choose Add GPX File to Workspace.\n\nNavigate to your GPX file and click Add.\n\nXcode uses the added GPX file to simulate locations in tests. You can add multiple GPX files and choose between them using the Simulated Location setting in the test plan configuration.\n\nConstruct locations for unit tests\n\nWhen testing your app’s location-handling logic, you don’t need to use CLLocationManager or get the device’s location. You can construct instances of CLLocationCoordinate2D with known values for the coordinate’s latitude and longitude in the test. Pass these instances to the code under test, and validate that your code behaves as expected for the given values.\n\nSet a simulated location for UI automation\n\nIn your UI automation tests, update the simulated device location by setting the shared XCUIDevice location to an instance of XCUILocation.\n\nimport XCTest\nimport CoreLocation\n\n\nfinal class SampleAppTests: XCTestCase {\n\n\n  func testExample() throws {\n    XCUIDevice.shared.location = XCUILocation(location: CLLocation(latitude: 37.334886, longitude: -122.008988))\n\t// Launch your app and run the test.\n  }\n}\n"
  },
  {
    "title": "Interacting with your app in the watchOS simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/interacting-with-your-app-in-the-watchos-simulator",
    "html": "Overview\n\nSimulator offers an environment to run apps in watchOS without installing them on a physical device. When running your app in Simulator, use your Mac to navigate the app’s interface.\n\nInteract with your app’s interface\n\nUse the pointer, keyboard, and menu items to make gestures on a simulated watchOS device.\n\nGesture\n\n\t\n\nTo simulate\n\n\n\n\nTap\n\n\t\n\nClick.\n\n\n\n\nDouble-tap\n\n\t\n\nDouble-click\n\n\n\n\nTouch and hold\n\n\t\n\nClick and hold\n\n\n\n\nShallow press\n\n\t\n\nChoose I/O > Touch Pressure > Shallow Press. Then, click.\n\n\n\n\nDeep press\n\n\t\n\nChoose I/O > Touch Pressure > Deep Press. Then, click.\n\n\n\n\nShallow or deep presses\n\n\t\n\nOn a Mac with a Force Touch Trackpad, choose I/O > Touch Pressure > Use Trackpad Force. Then, click with the desired pressure\n\n\n\n\nTwo-finger gestures\n\n\t\n\nPress Option to display touch points. Move the pointer while pressing the Option key to change the distance between the touch points. Move the pointer and hold the Shift and Option keys to reposition the touch points.\n\n\n\n\nTwo-finger drag\n\n\t\n\nHold the Control key and release the mouse to lock the first finger on the drag item, navigate to the drop target, then click on the drag item to move it to the target.\n\n\n\n\nTwo-finger pinch, zoom, or rotate\n\n\t\n\nClick and drag while pressing the Option key.\n\n\n\n\nActivate Siri\n\n\t\n\nChoose Device > Siri, or hold the Home button on the device bezel.\n\nInteract with hardware controls\n\nActivate device buttons using menu items or by clicking on parts of the device bezel in Simulator.\n\nButton\n\n\t\n\nTo simulate\n\n\n\n\nPush in the Digital Crown\n\n\t\n\nChoose Device > Home. Click the Digital Crown on the device bezel.\n\n\n\n\nRotate the Digital Crown clockwise\n\n\t\n\nPlace the pointer over the Digital Crown on the device bezel and scroll up using a mouse wheel or trackpad. If the bezel is hidden, move the pointer over the simulator window, then scroll up using a mouse wheel or trackpad.\n\n\n\n\nRotate the Digital Crown counter-clockwise\n\n\t\n\nPlace the pointer over the Digital Crown on the device bezel and scroll down using a mouse wheel or trackpad. If the bezel is hidden, move the pointer over the simulator window, then scroll down using a mouse wheel or trackpad.\n\n\n\n\nClick the Side button\n\n\t\n\nChoose Device > Side Button. Click the Side button on the device bezel.\n\n\n\n\nClick the Action button\n\n\t\n\nChoose Device > Side Button. Click the Action button on the device bezel.\n\nSee Also\nSimulator interactions\nInteracting with your app in the iOS and iPadOS simulator\nUse your Mac to control interactions with your iOS and iPadOS apps in Simulator.\nInteracting with your app in the tvOS simulator\nUse your Mac to control interactions with your tvOS apps in Simulator.\nConfiguring Simulator for your working environment\nAdjust Simulator settings for window or screen size, light or dark appearance, and audio settings, and restart or reset a simulated device.\nSimulating an external display or CarPlay\nTest how your app handles an external display or CarPlay from Simulator.\nCapturing screenshots and videos from Simulator\nRecord and share test results, or prepare for App Store distribution with screenshots and videos of your app from Simulator."
  },
  {
    "title": "Configuring Simulator for your working environment | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-a-simulator-for-your-environment",
    "html": "Overview\n\nWhen you’re testing your app, taking screenshots, or inspecting your user interface, you may want to configure Simulator to help accomplish your task. There are several options you can adjust:\n\nLight mode or dark mode\n\nWindow or screen size\n\nBezel display\n\nAudio settings\n\nWhen you need to test your app after a device restart, or you want to simulate loading your app in a new device, you can restart or reset a simulated device.\n\nToggle light and dark appearance\n\nTest your app in both light and dark mode on supported platforms to confirm that your user interface looks correct for both appearances. To switch appearances, choose Features > Toggle Appearance.\n\nResize a simulator window\n\nYou can change the size of the window to match the physical device characteristics. For example, display the same number of pixels as the hardware device’s screen to check alignment of controls, images, and colors used in your app.\n\nTo change the window size to the hardware device’s screen size, choose Window > Physical size.\n\nTo change the window size to the same scale factor as the physical device, choose Window > Point Accurate.\n\nTo change the window size to the same number of pixels as the physical device, choose Window > Pixel Accurate.\n\nAlternatively, hold the pointer over a corner of the window until it changes to the resize cursor, then drag the window frame to the desired size.\n\nShow the simulator bezel\n\nThe simulator bezel for iOS and watchOS devices includes elements for the buttons and switches found on those devices that you can click to simulate pressing.\n\nSelect a simulator window, then choose Window > Show Device Bezels to show or hide the simulator bezel. A checkmark next to Show Device Bezels indicates the bezel is visible.\n\nSet the audio input and output\n\nSet the audio input and audio output that simulated devices use.\n\nTo set audio input, choose a device from the I/O > Audio Input submenu. Choose System to use the same audio input as the Mac.\n\nTo set audio output, choose a device from the I/O > Audio Output submenu. Choose System to use the same audio output as the Mac.\n\nTo adjust audio volume choose I/O > Increase Volume or I/O > Decrease Volume.\n\nSimulator keeps track of the most recent selections for input and for output. Simulator attempts to connect to the previously selected device when the currently selected device is disconnected.\n\nNote\n\nWhen Bluetooth headphones are selected as the input source, playing or listening to audio in Simulator sets the headphones to phone call mode which lowers the quality of the audio. To hear sound at full quality, choose a different audio input source for Simulator.\n\nRestart or reset a simulated device\n\nRestart a simulated device to simulate turning off and turning back on a device. To do this, choose Device > Restart.\n\nReset a simulated device to factory settings to clear out all installed apps and any data you may have added to the simulated device. To do this, choose Device > Erase All Contents and Settings…, and then choose Erase from the confirmation dialog.\n\nSee Also\nSimulator interactions\nInteracting with your app in the iOS and iPadOS simulator\nUse your Mac to control interactions with your iOS and iPadOS apps in Simulator.\nInteracting with your app in the tvOS simulator\nUse your Mac to control interactions with your tvOS apps in Simulator.\nInteracting with your app in the watchOS simulator\nUse your Mac to control interactions with your watchOS apps in Simulator.\nSimulating an external display or CarPlay\nTest how your app handles an external display or CarPlay from Simulator.\nCapturing screenshots and videos from Simulator\nRecord and share test results, or prepare for App Store distribution with screenshots and videos of your app from Simulator."
  },
  {
    "title": "Testing in Simulator versus testing on hardware devices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/testing-in-simulator-versus-testing-on-hardware-devices",
    "html": "Overview\n\nWhile Simulator is useful for many types of tests, there are significant differences between Simulator and actual hardware devices that you need to consider when you choose which platform to use. These differences fall into several categories:\n\nGeneral: there are differences in processing, graphics, and network speed.\n\nDisplay: there are differences in resolution and color.\n\nSystem: there are differences in how the system handles backgrounding your app.\n\nHardware: Simulator doesn’t support some hardware features.\n\nAPI: Simulator doesn’t support some APIs.\n\nMetal: there are differences between the device GPU and your computer GPU.\n\nEvaluate the differences to help you determine what features and functionality you can test in Simulator in addition to the testing you perform on hardware devices.\n\nEvaluate general differences\n\nUse hardware devices to do performance testing for processing, graphics, and networking to ensure accurate results.\n\nSimulator is an app running on a Mac using the computer’s resources including the CPU, memory, and network connection. As a result, Simulator is not an accurate test of an app’s performance, memory usage, and networking speed. Use performance testing results in Simulator to determine relative differences in app functionality. If you encounter performance issues in Simulator but not on a hardware device, see Troubleshooting Simulator launch or animation issues.\n\nPerform user testing on hardware devices when you require real-world results, such as confirming that tap areas are large enough for users to tap, or text in your user interface is legible.\n\nUser interaction with a pointer and keyboard is different from using fingers on iOS and watchOS, hand gestures on visionOS, or the focus-based model used on tvOS. After you are satisfied that your app functions correctly in Simulator, test on devices to catch any unexpected issues with user interaction.\n\nEvaluate display differences\n\nThe resolution, or pixels per point, on the hardware device and on the Mac can differ. This results in text and images that appear jagged, especially with smaller text.\n\nIncreasing the scale of the Simulator window can make text and images appear clearer.\n\nThe color gamut of the Mac screen can differ resulting in inaccurate colors in Simulator.\n\nEvaluate system differences\n\nSimulator suspends background apps and processes on iOS 11 and later, tvOS 11 and later, and watchOS 4 and later. The debugger can resume a suspended process.\n\nSimulator treats the file system as case-sensitive on HFS+ and APFS formatted volumes.\n\nEvaluate hardware differences\n\nThere is a reliable connection between simulated watchOS and iOS devices because they are both running in the Simulator.\n\nSimulator doesn’t support the following hardware:\n\nAmbient light sensor\n\nAudio input, except for using Siri by choosing Device > Siri\n\nBarometer\n\nBluetooth\n\nCamera\n\nMotion support (accelerometer and gyroscope)\n\nProximity sensor\n\nEvaluate API differences\n\nSimulator doesn’t support the following frameworks:\n\nARKit\n\nExternal Accessory\n\nHomeKit\n\nIOSurface\n\nMedia Player\n\nMessage UI\n\nThe following features of APIs are not available in Simulator:\n\nReceiving and sending Apple push notifications. Drag and drop a JSON file with a push notification payload on the simulator to test receiving a push notification.\n\nThe UIBackgroundModes key.\n\nThe UIVideoEditorController class in UIKit.\n\nSupport for Handoff.\n\nEvaluate Metal differences\n\nSimulator includes a Metal implementation that you can use to start developing your app. For more information on how it differs from a hardware processor, see Developing Metal Apps that Run in Simulator.\n\nSee Also\nSimulator testing considerations\nSharing data with Simulator\nEnter text directly in Simulator, or share location data, images, web addresses, files, or data from the clipboard with Simulator.\nTesting complex hardware device scenarios in Simulator\nTest hardware device-specific scenarios, such as Face ID or Touch ID authentication, fall detection, getting a memory warning, or location changes.\nIdentifying graphics and animations issues in Simulator\nReveal performance and display issues in your views with color overlays, and slow down animations to debug and improve them."
  },
  {
    "title": "Creating width and device variants of strings | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-width-and-device-variants-of-strings",
    "html": "Overview\n\nImportant\n\nIn Xcode 15 and later, string catalogs are the recommended way to create width and device variants of strings. In earlier versions of Xcode, use strings and stringsdict files. For more information about string catalogs, see Localizing and varying text with a string catalog.\n\nYou can use a .stringsdict file to provide variants of a string for different view widths and for different devices. For example, display a different string for an iOS device in landscape or in portrait mode, or display a different string when your iPad app built with Mac Catalyst runs on a Mac.\n\nA .stringsdict file is a property list that defines plural, width, and device variants of localizable strings. The .stringsdict file contains a dictionary of key-value pairs where the values are either a plural, width, or device rule.\n\nThe key for a rule is the string that you pass to Text structures, the NSLocalizedString macro, and similar APIs in your code. The rule can be a plural, width, or device rule that determines which formatted string the macro returns.\n\nTo create plural variants for formatted strings that contain amounts, see Localizing strings that contain plurals.\n\nAdd a strings dictionary file to your project\n\nTo add a .stringsdict file to your project, choose File > New > File. In the sheet that appears, select the platform, enter strings in the Filter field, select Stringsdict File, and click Next. In the dialog that appears, enter a name for the file, choose a location, and click Create.\n\nProvide string variants for different widths\n\nA width rule specifies variants for different available widths in the user interface. It contains a single dictionary with a single key-value pair. The key in the dictionary is NSStringVariableWidthRuleType and the value is another dictionary with key-value pairs for each variant. The key for a variant is a width and the value is a string.\n\nIn the following .stringsdict file, for the hello string in the code,the width variations are 1, 22, and 53, and the values are Hi, Hello, and Greetings and Salutations:\n\n<plist version=\"1.0\">\n    <dict>\n        <key>hello</key>\n        <dict>\n            <key>NSStringVariableWidthRuleType</key>\n            <dict>\n                <key>1</key>\n                <string>Hi</string>\n                <key>22</key>\n                <string>Hello</string>\n                <key>53</key>\n                <string>Greetings and Salutations</string>\n            </dict>\n        </dict>\n    </dict>\n</plist>\n\n\n\n\nFor UILabel objects, the width is in em units that fit across the app window; otherwise, the width doesn’t have an associated unit.\n\nThe width rule defines variants for a range of widths:\n\nIf the width is between two numerically sequential keys, the API returns the variant with the smaller key.\n\nIf the width is less than all keys, the API returns the variant for the smallest key.\n\nIn the code above, if the width is 2, the macro returns Hi. If the width is 55, the macro returns Hello.\n\nTo get a variant for a specific width in your code, see the variantFittingPresentationWidth(_:) method.\n\nProvide device-specific string variants\n\nA device rule specifies a different string depending on the device. For example, your universal app may present different instructions to the user when running on an iOS device than when running on a Mac.\n\nA device rule contains a single dictionary with a single key-value pair. The key is NSStringDeviceSpecificRuleType and the value is a dictionary with the following optional key-value pairs:\n\nKey\n\n\t\n\nDescription\n\n\n\n\nappletv\n\n\t\n\nThe string to use on Apple TV.\n\n\n\n\napplevision\n\n\t\n\nThe string to use on Apple Vision Pro.\n\n\n\n\napplewatch\n\n\t\n\nThe string to use on Apple Watch.\n\n\n\n\nipad\n\n\t\n\nThe string to use on iPad.\n\n\n\n\niphone\n\n\t\n\nThe string to use on iPhone.\n\n\n\n\nipod\n\n\t\n\nThe string to use on iPod.\n\n\n\n\nmac\n\n\t\n\nThe string to use on Mac.\n\nIn the following .stringsdict file, when you pass UserInstructions as the string in your code, it returns Tap here when the app runs on an iPhone, Click here when it runs on a Mac, and Press here when it runs on an Apple TV:\n\n<plist version=\"1.0\">\n<dict>\n    <key>UserInstructions</key>\n    <dict>\n        <key>NSStringDeviceSpecificRuleType</key>\n        <dict>\n            <key>iphone</key>\n            <string>Tap here</string>\n            <key>mac</key>\n            <string>Click here</string>\n            <key>appletv</key>\n            <string>Press here</string>\n        </dict>\n    </dict>\n</dict>\n</plist>\n\nSee Also\nLegacy localization techniques\nLocalizing strings that contain plurals\nUse a strings dictionary file to ensure correct localization of strings that contain language plurals."
  },
  {
    "title": "Simulating an external display or CarPlay | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/simulating-an-external-display-or-carplay",
    "html": "Overview\n\nSome iPhone and iPad devices support a wired connection to an external display. When you plug your compatible device into a supported external display, the device mirrors its display to the external display.\n\nIn addition to external displays, iPhone devices running iOS 12.0 and later support connecting to CarPlay compatible vehicles. For more information on supporting CarPlay in your app, see CarPlay.\n\nTest your app’s support of external displays or CarPlay in Simulator during development, then test on actual devices.\n\nEnable an external display or CarPlay\n\nFirst, build and run your app in Simulator. For more information, see Running your app in Simulator or on a device.\n\nWhen your app is running in Simulator, choose I/O > External Displays, then select an external display size or CarPlay. The supported options are:\n\n640x480\n\n720x480\n\n1024x768\n\n1280x720 (720p)\n\n1920x1080 (1080p)\n\n3840x2160 (4K)\n\nCarPlay\n\nSimulator opens a new window for the external display with the selected size.\n\nClose the external display window, or choose I/O > External Displays > Disable to simulate unplugging from the external display.\n\nSee Also\nSimulator interactions\nInteracting with your app in the iOS and iPadOS simulator\nUse your Mac to control interactions with your iOS and iPadOS apps in Simulator.\nInteracting with your app in the tvOS simulator\nUse your Mac to control interactions with your tvOS apps in Simulator.\nInteracting with your app in the watchOS simulator\nUse your Mac to control interactions with your watchOS apps in Simulator.\nConfiguring Simulator for your working environment\nAdjust Simulator settings for window or screen size, light or dark appearance, and audio settings, and restart or reset a simulated device.\nCapturing screenshots and videos from Simulator\nRecord and share test results, or prepare for App Store distribution with screenshots and videos of your app from Simulator."
  },
  {
    "title": "Sharing data with Simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/sharing-data-with-simulator",
    "html": "Overview\n\nSome app testing scenarios require location data, specific images, or other data to be present in Simulator. In other cases, such as diagnosing an issue or confirming functionality, it’s useful to capture data from Simulator. Depending on the type of data, there are several methods to get data on your Mac into a simulated device, or to get data from a simulated device to your Mac.\n\nShare a location with Simulator\n\nSend your current location to Simulator from Maps.app on your Mac by clicking the Share button, then select Simulator from the share destination list. Choose the simulated device from the drop-down list. The simulated device updates its location to your current location.\n\nTo send a selected location from Maps.app to Simulator, first select a location in Maps.app. Then, click the Share button in the view for the location. Select Simulator from the share destination list, then choose the simulated device from the drop-down list. The simulated device updates its location to the location you shared.\n\nShare a web address with Simulator\n\nTo share a web address with Simulator from your Mac, Control-click a web link, then select Share. Alternatively, open a web link in Safari, then select Share. In the Share menu, select Simulator, then choose a simulated device from the drop-down list. The simulated device opens the web link in Safari.\n\nSync or share clipboard data with Simulator\n\nYou can sync Simulator’s clipboard with your Mac, or copy it back and forth.\n\nTo sync the Simulator clipboard with the Mac, choose Edit > Automatically Sync Pasteboard. A checkmark indicates that the clipboard is synchronized.\n\nTo copy clipboard from Simulator to the Mac, choose Edit > Get Pasteboard.\n\nTo copy the clipboard on the Mac to Simulator, choose Edit > Send Pasteboard.\n\nAdd images to Photos in Simulator\n\nTo put image in Simulator’s Photos app, select one or more images from your Mac, or from Photos.app on your Mac. Drag the images to Simulator. Alternatively, select Share, then select Simulator from the share destination list. Choose the simulated device from the drop-down list. Simulator adds the images and opens Photos to display them.\n\nAdd files to Simulator\n\nTo add files to Simulator, select one or more files in Finder on your Mac, then click the Share button. Select Simulator from the share destination list. Choose the simulated device from the drop-down list. Simulator opens the Files app, and lets you select where to save the files.\n\nEnter text using the macOS keyboard\n\nEnter text as input to the simulated device using the keyboard on your Mac.\n\nTo connect your Mac keyboard to the simulated device, select I/O > Keyboard > Connect Hardware Keyboard.\n\nTo show or hide the onscreen keyboard when a hardware keyboard is connected to the device, choose I/O > Keyboard > Toggle Software Keyboard.\n\nTo synchronize the iOS and Mac keyboard languages, select I/O > Keyboard > Use the Same Keyboard Language as macOS.\n\nNote\n\nFor Simulator to automatically switch keyboard languages when the Mac layout is changed, select both Connect Hardware Keyboard and Use the Same Keyboard Language as macOS.\n\nSee Also\nSimulator testing considerations\nTesting in Simulator versus testing on hardware devices\nReview the differences between Simulator and hardware devices to determine which you should choose to test a scenario.\nTesting complex hardware device scenarios in Simulator\nTest hardware device-specific scenarios, such as Face ID or Touch ID authentication, fall detection, getting a memory warning, or location changes.\nIdentifying graphics and animations issues in Simulator\nReveal performance and display issues in your views with color overlays, and slow down animations to debug and improve them."
  },
  {
    "title": "Capturing screenshots and videos from Simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/capturing-screenshots-and-videos-from-simulator",
    "html": "Overview\n\nScreenshots or videos of your app in action are useful for these and other needs:\n\nHelp other people on your team understand a bug or design issue.\n\nDocument how your app responds to accessibility changes.\n\nConfirm your app layout changes appropriately for localization and internationalization.\n\nPrepare and update your App Store page to show your app’s best features.\n\nUse Simulator to efficiently capture screenshots and videos of your app in action in different Simulator platforms and devices.\n\nCapture a screenshot of your app\n\nTo take a screenshot, navigate to the place in your app you would like to capture, then:\n\nChoose File > Save Screen.\n\nSimulator takes the screenshot, then displays a preview of the screenshot next to the Simulator window.\n\nIf you want to edit the screenshot, tap the preview to open it in an editor. Otherwise, Simulator saves the screenshot to your Desktop folder. Press and hold the Option key when you choose File > Save Screen to choose a location for the screen shot.\n\nSimulator creates a file name with a combination of “Simulator Screen Shot - “, the name of the Simulator device, and the date and time. Simulator captures screenshots at full resolution, regardless of the display resolution you select.\n\nRecord video of interactions in your app\n\nTo record video, set up your app in Simulator and navigate to a view where you’d like to start your video, then:\n\nChoose File > Record Screen.\n\nSimulator begins recording the screen.\n\nInteract with your app while recording.\n\nChoose File > Stop Recording, or click the stop button in the simulator device’s control bar.\n\nSimulator finishes the recording, then displays a preview of the screenshot next to the Simulator window.\n\nSimulator saves the recording to your Desktop folder. Press and hold the Option key when you choose File > Record Screen to choose a location for the recording.\n\nSimulator creates a file name with a combination of “Simulator Screen Recording - “, the name of the Simulator device, and the date and time.\n\nSee Also\nSimulator interactions\nInteracting with your app in the iOS and iPadOS simulator\nUse your Mac to control interactions with your iOS and iPadOS apps in Simulator.\nInteracting with your app in the tvOS simulator\nUse your Mac to control interactions with your tvOS apps in Simulator.\nInteracting with your app in the watchOS simulator\nUse your Mac to control interactions with your watchOS apps in Simulator.\nConfiguring Simulator for your working environment\nAdjust Simulator settings for window or screen size, light or dark appearance, and audio settings, and restart or reset a simulated device.\nSimulating an external display or CarPlay\nTest how your app handles an external display or CarPlay from Simulator."
  },
  {
    "title": "Troubleshooting Simulator launch or animation issues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/troubleshooting-simulator-launch-or-animation-issues",
    "html": "Overview\n\nWhen you run multiple simulators concurrently with Xcode and other programs on your Mac, you can run into poor performance in simulators, or even errors launching more simulators. Isolate the cause, then fix these types of issues in Simulator.\n\nFor issues that may be part of Simulator or a simulated device, please file a bug.\n\nInvestigate and address insufficient resources\n\nLaunching a simulator can result in an error alert that there are insufficient system resources. This usually occurs when launching a simulator exceeds either the maximum number of active processes or the maximum number of open files. The best solution is to free up resources by closing simulated devices and other Mac applications.\n\nIf it’s not possible to free up enough resources, raise the system limits until you restart your Mac.\n\nNote\n\nIt’s possible to exceed the maximum number of process or the maximum number of open files when you launch other programs or open other files some time after you’ve launched a simulator. If this occurs, Simulator doesn’t give you a warning. The effects depend on what program is trying to launch the process or open the file.\n\nFirst, find the current process and file limits:\n\nOpen Terminal.\n\nRun the command sudo launchctl limit. Provide your password when Terminal requests it, because you’re running the command as superuser.\n\nNote the maximum number of processes next to maxproc, and the maximum number of files next to maxfiles.\n\nRun the command ps -A | wc -l in Terminal to show the current total of running processes.\n\nIf you need to increase the maximum number of processes, run the command sudo launchctl limit maxproc <per user limit> <total limit>, replacing <per user limit> and <total limit> with numbers. For example, the command sudo launchctl limit maxproc 2000 2500 sets the maximum number of concurrent processes for any one user to 2000 and the total number of all concurrent processes to 2500.\n\nWarning\n\nSetting the maximum number of processes to a number that is too low can prevent your Mac from operating correctly. Restart your machine to restore the original limits.\n\nIf you need to increase the maximum number of open files, run the command sudo launchctl limit maxfiles <per process limit> <total limit>, replacing <per process limit> and <total limit> with numbers. For example, the command sudo launchctl limit maxfiles 2000 unlimited sets the maximum number of open files for any one process to 2000 and the total number of all open files to unlimited.\n\nInvestigate slow scrolling or animations\n\nIn some cases slow scrolling or animation is due to the simulator. Use the items in Debug > Graphics Quality Override to check if this is an issue.\n\nDevice Default\n\nUse the default graphics quality for the device.\n\nLow Quality\n\nForce low-quality graphics. This choice results in faster scrolling and animation if Simulator is the cause.\n\nHigh Quality\n\nForce high-quality graphics.\n\nReport bugs\n\nFor issues that may be part of Simulator or a simulated device, please file a bug through the Apple Developer website.\n\nWhen you file a bug, include the full version number of Xcode in the bug title and in the description. To find the version number, choose Xcode > About Xcode. The full version number including the part in parentheses is in the window that Xcode displays. If the bug is with a simulated device, attach a sysdiagnose for that device by opening Terminal and typing the following command:\n\nxcrun simctl diagnose\n\n\nPress Enter again to display the status of the capture as well as the path for the file with the sysdiagnose.\n\nFor more information on diagnose, run the following command:\n\nxcrun simctl diagnose --help\n"
  },
  {
    "title": "Identifying graphics and animations issues in Simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/identifying-graphics-and-animations-issues-in-simulator",
    "html": "Overview\n\nWhen your app encounters issues such as hitches, blurred views, or misplaced views, use Simulator’s color overlays to help you diagnose several common causes:\n\nExcess blending\n\nwhen your app draws too many views with transparency on top of each other, and the system has to perform work to blend the views together.\n\nCopying\n\nwhen Core Animation needs to make copies of your image for display.\n\nMisalignment\n\nwhen your app attempts to display an image that doesn’t divide evenly into the scale factor for a device, or an image that doesn’t fit in the size of a view, the image may be blurry or slightly out of position.\n\nOffscreen rendering\n\nwhen your app renders a view offscreen before moving it onscreen to display.\n\nWhen your app encounters issues with animations, such as unexpected jumps, hitches, or diversions from an expected course of changes, use Simulator’s tool to slow down animations so that you can examine them more closely than you can at full speed, and determine the right course of corrective action.\n\nDebug and optimize graphics using color overlays\n\nHighlight images and areas of the screen that may create issues with rendering, scrolling performance, and memory in Simulator. Choose Debug > Color and select a color overlay to show or hide in your app:\n\nColor Blended Layers\n\nSimulator overlays views in red that your app draws on top of other views and that have blending enabled. Simulator overlays other areas in green. Minimize blended layers to improve rendering and scrolling performance.\n\nColor Copied Images\n\nSimulator overlays images in blue that Core Animation must copy instead of using the original. Minimize copied images to improve memory usage and performance.\n\nColor Misaligned Images\n\nSimulator overlays images in magenta whose bounds are not aligned to the destination pixels. Fix misaligned images to avoid blurs and performance issues. Simulator overlays images in yellow that your app draws with a scale factor. Minimize images with scale factors to improve rendering and scrolling performance.\n\nColor Off-screen Rendered\n\nSimulator overlays content in yellow that is rendered offscreen. Only use off-screen rendering when you have confirmed with tests that the memory and performance tradeoffs work for your app.\n\nYou can show multiple overlays at the same time.\n\nExamine your app while you’re displaying overlays to help tune performance. For more information, see Improving your app’s performance.\n\nSlow down animations to diagnose problems\n\nUnrelated performance issues, logic issues, unforeseen layout circumstances, and other problems can interfere with smooth animations in your app. Slow down the rate of animations to examine them closely so that you can narrow down possibilities for the root cause. Repeatable issues that occur in animations are frequently a logic or layout issue, while non-repeatable issues can be caused by other issues that slow down your app’s main queue.\n\nChoose Debug > Slow Animations to slow down animations or return them to normal speed. A checkmark indicates that Simulator is running animations slowly.\n\nSee Also\nSimulator testing considerations\nTesting in Simulator versus testing on hardware devices\nReview the differences between Simulator and hardware devices to determine which you should choose to test a scenario.\nSharing data with Simulator\nEnter text directly in Simulator, or share location data, images, web addresses, files, or data from the clipboard with Simulator.\nTesting complex hardware device scenarios in Simulator\nTest hardware device-specific scenarios, such as Face ID or Touch ID authentication, fall detection, getting a memory warning, or location changes."
  },
  {
    "title": "Localizing strings that contain plurals | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/localizing-strings-that-contain-plurals",
    "html": "Overview\n\nImportant\n\nIn Xcode 15 and later, string catalogs are the recommended way to localize strings that contain plurals. In earlier versions of Xcode, use strings and stringsdict files. For more information about string catalogs, see Localizing and varying text with a string catalog.\n\nLanguages have different grammatical rules for handling plurals of nouns and units. So if you localize formatted strings that contain variable amounts, use a .stringsdict file to provide a different translation for each plural form in the language.\n\nFor example, if you pass the %d home(s) found formatted string to the NSLocalizedString macro or similar API, such as the Text structure, you can use the a .stringsdict file to return different versions of the string. In English, you can return one home found or 1 home found when d is 1, and %d homes found when d is greater than 1. For other languages, the .stringsdict file can have more or fewer plural variants of a formatted string.\n\nXcode automatically handles .stringsdict files for you when you export and import localizations. However, you need to know the format of a .stringsdict file to localize it in the development language and other languages if you don’t use a localization service.\n\nAdd a strings dictionary file to your project\n\nTo add a .stringsdict file to your project, choose File > New > File. In the sheet that appears, select the platform, enter strings in the Filter field, select Stringsdict File, and click Next. In the dialog that appears, enter a name for the file, choose a location, and click Create.\n\nA .stringsdict file is a resource file in your project, but Xcode doesn’t automatically localize it. While the file is in a selected state in the Project navigator, open the inspector, and click Localize under Localization. In the dialog that appears, choose a language and click Localize. Choose Base to localize the file in all languages.\n\nIf you previously added localizations to your project, select the other localizations in the inspector under Localization. If you select multiple localizations, the .stringsdict file becomes a group in the Project navigator that contains a version for each language.\n\nLater when you add more localizations, be sure to include the .stringsdict file when you select resources for the localization.\n\nLocalize the strings dictionary file in the development language\n\nNext, add the plural rules and variants to the development language version of the .stringsdict file.\n\nIn the Project navigator, select the .stringsdict file. If it appears as a group, select the development language version of the file (the language appears in parentheses). Because a .stringsdict file is a property list, it appears in the property editor by default. To edit the .stringsdict file using the source editor, Control-click it and choose Open As > Source Code.\n\nA new .stringsdict file contains a dictionary with plural variants for a single formatted string. For each formatted string in your app that contains a numeric value, enter the formatted string as the key and a plural variant dictionary as the value with the following key-value pairs:\n\nKey\n\n\t\n\nValue\n\n\n\n\nNSStringLocalizedFormatKey\n\n\t\n\nA formatted string that contains variables. To replace the string with a plural rule, precede the variable with the %#@ characters and follow it by the @ character, as in %#@homes@ where homes is the variable.\n\n\n\n\n[variable]\n\n\t\n\nA dictionary that specifies the plural variants for a variable in the formatted string.\n\nFor example, enter separate dictionaries for the user-facing formatted strings you use in your code. If the formatted string contains multiple variables, enter a separate subdictionary for each variable. In the following .stringsdict file, the formatted strings are: %d home(s) found, %d service hour(s), and %d award(s):\n\n<plist version=\"1.0\">\n    <dict>\n        <key>%d home(s) found</key>\n        <dict>\n            <key>NSStringLocalizedFormatKey</key>\n            <string>%#@homes@</string>\n            <key>homes</key>\n            <dict>\n                ...\n            </dict>\n        </dict>\n        <key>%d service hour(s)</key>\n        <dict>\n            …\n        </dict>\n        <key>%d award(s)</key>\n        <dict>\n            …\n        </dict>\n    </dict>\n</plist>\n\n\nThe variable dictionary for each formatted string determines which string returns from the Text structure, NSLocalizedString macro, or similar API in your code. It contains a key-value pair for each grammatical plural variant in the language, called a category.\n\nFor example, the following .stringsdict file with English localization contains plural variants for the zero, one, and other categories. For the %d home(s) found formatted string, the API returns No homes found for 0, %d home found for 1, and %d homes found for other values.\n\n<plist version=\"1.0\">\n    <dict>\n        <key>%d home(s) found</key>\n        <dict>\n            <key>NSStringLocalizedFormatKey</key>\n            <string>%#@homes@</string>\n            <key>homes</key>\n            <dict>\n                <key>NSStringFormatSpecTypeKey</key>\n                <string>NSStringPluralRuleType</string>\n                <key>NSStringFormatValueTypeKey</key>\n                <string>d</string>\n                <key>zero</key>\n                <string>No homes found</string>\n                <key>one</key>\n                <string>%d home found</string>\n                <key>other</key>\n                <string>%d homes found</string>\n            </dict>\n        </dict>\n    </dict>\n</plist>\n\n\nA variable dictionary can contain the following key-value pairs:\n\nKey\n\n\t\n\nValue\n\n\n\n\nNSStringFormatSpecTypeKey\n\n\t\n\nSpecifies the type of language rule. The only possible value is NSStringPluralRuleType, which indicates a language plural variant.\n\n\n\n\nNSStringFormatValueTypeKey\n\n\t\n\nA string format specifier for a number, as in the letter d for an integer.\n\n\n\n\nzero, one, two, few, many, other\n\n\t\n\nThe formatted string for the language-specific plural category. Using the format specifier in the string is optional. The other category is a requirement.\n\nThe meaning of the plural categories is language-dependent, and not all languages have the same categories. For example, the English language only requires the one and other categories to represent plural forms, and zero is optional. Arabic has different plural forms for the zero, one, two, few, many, and other categories. Although Russian also uses the many category, the rules for which numbers are in the many category aren’t the same as the Arabic rules.\n\nFor the categories and plural rules for each language, see CLDR Language Plural Rules.\n\nLocalize the strings dictionary file in other languages\n\nAfter you localize the .stringsdict files in the development langauge and add the other localizations to your project, you export the localizations.\n\nWhen you export localizations, Xcode automatically adds the language-specific categories for each formatted string to the exported XLIFF files. Localizers just need to enter the translations for each category in the XLIFF file. Then when you import localizations, Xcode updates the localized .stringsdict files in your project.\n\nFor example, if you export a Russian localization containing the %d home(s) found formatted string in a .stringsdict file, Xcode adds the one, many, and other categories to the Russian version of the XLIFF file. The localizer inserts the translations and when you import the localization, the .stringsdict file contains the correct variable dictionary key-value pairs for Russian.\n\n<plist version=\"1.0\">\n    <dict>\n       <key>%d home(s) found</key>\n         <dict>\n            <key>NSStringLocalizedFormatKey</key>\n            <string>%#@homes@</string>\n            <key>homes</key>\n            <dict>\n                <key>NSStringFormatSpecTypeKey</key>                \n                <string>NSStringPluralRuleType</string>\n                <key>NSStringFormatValueTypeKey</key>\n                <string>d</string>\n                <key>one</key>\n                <string>найден %d дом</string>\n                <key>many</key>\n                <string>найдены %d дома</string>\n                <key>other</key>\n                <string>найдены %d домов</string>\n            </dict>\n        </dict>\n    </dict>\n</plist>\n\n\nYou can edit the .stringsdict files in Xcode yourself, but keep in mind that all of the categories are optional except the other category. Also the localized text may be grammatically incorrect if you don’t supply a rule for all the language-specific categories. Conversely, if you provide a rule for a category that a language doesn’t use, the system ignores it and uses the other category format string instead.\n\nFurthermore, using the NSStringFormatValueTypeKey format specifier in the localized formatted strings is optional. For example, the format string for the one category in English can be One home found, while the other category can be %d homes found.\n\nYou can use the format specifier (%d)or spell out numbers (one)in the plural variants, but don’t use a numeric value (1) in the string because it may not have the correct localization if the user changes regions.\n\nSee Also\nRelated Documentation\nAdding support for languages and regions\nSelect the resources that you want to localize for each language and region you support.\nExporting localizations\nProvide the localizable files from your project to localizers.\nImporting localizations\nImport the files that you translate or adapt for a language and region into your project.\nLegacy localization techniques\nCreating width and device variants of strings\nChange a localized string for different interface widths and devices."
  },
  {
    "title": "Previewing localizations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/previewing-localizations",
    "html": "Overview\n\nYou can preview localizations early in development while you lay out your app’s interface for both SwiftUI and Interface Builder apps. For SwiftUI apps, you need to add the language or import the localization before you preview it, described in Adding support for languages and regions and Importing localizations. For Interface Builder apps, you can first preview the interface in pseudolanguages and then later in the localizations you add.\n\nAdd localizations to a SwiftUI preview\n\nFor SwiftUI apps, you can preview a localization by setting the locale environment variable in your code. Use the environment(_:_:) function to set the locale for all views in the view hierarchy of a SwiftUI preview. For example, if you add German to your project, you can set the locale to German (de):\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n                .environment(\\.locale, .init(identifier: \"de\"))\n    }\n}\n\n\nTo preview right-to-left languages, also set the layoutDirection key to LayoutDirection.rightToLeft.\n\nTo preview multiple localizations, add additional previews to your code and set the locale environment value for each. The localizations appear in the SwiftUI preview.\n\nPreview localizations in Interface Builder\n\nFor Interface Builder, you can preview localizations any time during development by choosing localizations including pseudolanguages in the preview. You don’t need to build and run your app to see the preview.\n\nIn Interface Builder, select the desired view controller. Click the Adjust Editor Options button in the upper-right corner, then choose Preview. A preview of the layout appears to the right of the canvas.\n\nIn the preview area, select a preview or click in the background to deselect all previews. If you don’t select a preview, you’ll change the language of all previews. Click the language button—for example, English—in the lower-right corner. In the pop-up menu that appears, choose a localization or pseudolanguage.\n\nSee Also\nRelated Documentation\nAdding support for languages and regions\nSelect the resources that you want to localize for each language and region you support.\nImporting localizations\nImport the files that you translate or adapt for a language and region into your project.\nstruct EnvironmentValues\nA collection of environment values propagated through a view hierarchy.\nTesting\nTesting localizations when running your app\nRun your app in each language and region you support to thoroughly test your app."
  },
  {
    "title": "Testing localizations when running your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/testing-localizations-when-running-your-app",
    "html": "Overview\n\nAfter you import localizations that contain the translated strings and resources adapted for the culture and region, test each localization in your running app by choosing the language and region in the Run scheme. You can also automate testing of localizations using continuous integration by choosing a localization when you create a bot.\n\nSelect a language and region in the scheme\n\nIn Xcode, choose Product > Scheme > Edit Scheme. In the sheet that appears, select the Run scheme action in the left column, and click Options on the right. Choose the language from the App Language pop-up menu and choose a region from the App Region pop-up menu:\n\nRegion\n\n\t\n\nDescription\n\n\n\n\nSystem Region\n\n\t\n\nThe operating system region settings.\n\n\n\n\n[Development Region]\n\n\t\n\nThe region that you’re developing the app in (the second menu item).\n\n\n\n\n[Region]\n\n\t\n\nA specific region. Choose a region from a continent submenu.\n\nClick Close in the sheet and click the Run button in the toolbar.\n\nChoose the language and region for a bot\n\nYou can test the languages and regions you support systematically using continuous integration with a bot. In Xcode, from the Language and Region action pop-up menus in the bot configuration sheet, you can choose either a localization, pseudolanguage, or Use Scheme Settings. If you choose Use Scheme Settings from the Language menu, the bot uses the localization settings you choose from the App Language and App Region pop-up menus in the scheme editor.\n\nClick Next in the sheet to complete the bot configuration.\n\nFor details on creating bots, see Continuous integration using Xcode Server in Xcode Help.\n\nSee Also\nTesting\nPreviewing localizations\nTest localizations in the SwiftUI preview or the Interface Builder preview."
  },
  {
    "title": "Configuring the hardened runtime | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-the-hardened-runtime",
    "html": "Overview\n\nThe Hardened Runtime is a collection of system-enforced restrictions that disable a set of functional capabilities, such as loading third-party frameworks, and prohibit access to restricted resources, such as the device’s built-in camera, to prevent certain classes of exploits from compromising the runtime integrity of your macOS app. If your app relies on something the Hardened Runtime restricts, you remove that specific protection by adding an entitlement to your app’s entitlements file. Xcode’s Hardened Runtime capability provides an easy way to manage those entitlements.\n\nBefore you select the required runtime exceptions and access to restricted resources that your app requires, follow the steps in the Add a capability section of Adding capabilities to your app to add the Hardened Runtime capability to the target of your macOS app. If you create a new macOS app using a template, Xcode automatically adds the Hardened Runtime capability to your app.\n\nImportant\n\nApple only notarizes macOS apps that enable the Hardened Runtime capability. For more information, see Notarizing macOS software before distribution.\n\nSpecify your app’s runtime exceptions\n\nBefore your app can perform functionality that depends upon one or more runtime exceptions, you must add the entitlements for those exceptions by performing the following:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nLocate the Runtime Exceptions section of the Hardened Runtime capability.\n\nSelect one or more runtime exceptions by checking the corresponding checkboxes.\n\nXcode automatically updates your app’s entitlements file to include the entitlements that correspond to the selected runtime exceptions, and sets the value of those entitlements to true.\n\nThe following table describes the runtime exceptions the Hardened Runtime supports:\n\nName\n\n\t\n\nFunctionality\n\n\n\n\nAllow Execution of JIT-compiled Code\n\n\t\n\nCreate writable and executable memory using the MAP_JIT flag. For more information, see Allow Execution of JIT-compiled Code Entitlement.\n\n\n\n\nAllow Unsigned Executable Memory\n\n\t\n\nCreate writable and executable memory without the imposed restrictions of the MAP_JIT flag. Useful for legacy apps. For more information, see Allow Unsigned Executable Memory Entitlement.\n\n\n\n\nAllow DYLD Environment Variables\n\n\t\n\nModify your app’s behavior at runtime using dynamic link variables. For more information, see Allow DYLD Environment Variables Entitlement.\n\n\n\n\nDisable Library Validation\n\n\t\n\nLoad frameworks and plug-ins that are written by third-party developers. For more information, see Disable Library Validation Entitlement.\n\n\n\n\nDisable Executable Memory Protection\n\n\t\n\nDisable the protections that code-signing provides. For more information, see Disable Executable Memory Protection Entitlement.\n\n\n\n\nDebugging Tool\n\n\t\n\nAttach to other processes or get task ports by indicating to the system that your app’s a debugger. For more information, see Debugging Tool Entitlement.\n\nWarning\n\nSpecific runtime exceptions, such as Disable Executable Memory Protection, remove core security barriers from your app. Always apply caution when using runtime exceptions and opt for the narrowest set of entitlements that enable the required functionality.\n\nSpecify the resource access your app requires\n\nIf your app accesses restricted or sensitive resources, such as the user’s photo library or address book, you must include the entitlements that provide access to those resources by following these steps:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nLocate the Resource Access section of the Hardened Runtime capability.\n\nSelect access to one or more resources by checking the corresponding checkboxes.\n\nAfter you select the required resource access, Xcode updates the entitlements file of your app to include the corresponding entitlements and sets the value of those entitlements to true.\n\nImportant\n\nApps that contain the necessary entitlements must still seek the user’s explicit permission before they can access restricted resources such as the camera. See each resource’s corresponding framework documentation for specific requirements.\n\nThe following table describes the resource access entitlements the Hardened Runtime supports:\n\nName\n\n\t\n\nFunctionality\n\n\n\n\nAudio Input\n\n\t\n\nRecord audio using the built-in microphone and access audio input using the Core Audio APIs. For more information, see Audio Input Entitlement.\n\n\n\n\nCamera\n\n\t\n\nCapture images and movies with the built-in and external cameras. For more information, see Camera Entitlement.\n\n\n\n\nLocation\n\n\t\n\nDetermine the user’s location using Location Services. For more information, see Location Entitlement.\n\n\n\n\nContacts\n\n\t\n\nEnable read-write access to the user’s Contacts database. For more information, see Address Book Entitlement.\n\n\n\n\nCalendar\n\n\t\n\nEnable read-write access to the user’s calendar. For more information, see Calendars Entitlement.\n\n\n\n\nPhotos Library\n\n\t\n\nEnable read-write access to the user’s photo library. For more information, see Photos Library Entitlement.\n\n\n\n\nApple Events\n\n\t\n\nPost Apple Events to other apps and processes. For more information, see Apple Events Entitlement.\n\nSee Also\nSecurity\nConfiguring the macOS App Sandbox\nProtect system resources and user data from compromised apps by restricting access to the file system, network connections, and more.\nConfiguring keychain sharing\nShare keychain items between multiple apps belonging to the same developer."
  },
  {
    "title": "Improving build efficiency with good coding practices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/improving-build-efficiency-with-good-coding-practices",
    "html": "Overview\n\nReducing build times by even a few seconds can have a significant impact over the course of development. Xcode does everything possible to build your code as fast as possible. It parallelizes build tasks and takes advantage of all available resources to output a finished product. However, you can help Xcode by making sure you’re not creating unnecessary work for the compiler.\n\nOver the years, Xcode’s compiler has introduced optimizations to speed up compile times. Most of these optimizations are automatic, but some require you to make small changes to your code. In addition, projects that support both Objective-C code to Swift may require additional optimizations to ensure fast compile times.\n\nNote\n\nYou can also optimize build times through project-level changes. For more information on optimizing build times, see Improving the speed of incremental builds.\n\nInclude framework names in import statements\n\nWhen you import headers into your source files, always include the name of the parent framework or library in your import statement. In C-based code, importing headers usually copies the contents of the header file into your source. When you include the framework name, the compiler has the option to use module maps to import the headers, which significantly reduces importation time. With module maps, the compiler loads and processes the framework’s header files once, and caches the resulting symbol information on disk. When you import the same framework from another source file, the compiler reuses the cached data, eliminating the need to again read and preprocess the header files.\n\nInclude framework names for both system frameworks and any custom frameworks you create in your projects. The following example shows import statements for both a system and custom framework, both of which have module maps. The last import statement continues to load and process the header file contents directly, rather than using an available module map.\n\n// Imports the framework’s module map\n#import <UIKit/UIKit.h>\n#import <PetKit/PetKit.h>     // Custom framework\n\n\n// Performs a textual inclusion of the header file.\n#import \"MyHeader.h\"\n\n\n\n\nFor information about how to add a module map to your custom frameworks, see Create Module Maps for Custom Frameworks and Libraries.\n\nMinimize the number of symbols you share between Swift and Objective-C\n\nWhen you mix Swift and Objective-C code in your project, your Swift code might need to know about portions of your Objective-C code, and vice versa. The compiler handles this exchange of symbol information using two special header files:\n\nThe Objective-C bridging header determines which Objective-C symbols you make available to your Swift code.\n\nThe compiler-generated Swift header is a list of all public Swift symbols you can use in your Objective-C code.\n\nReducing the size of both header files reduces the compiler’s workload and improves compilation times. A smaller file size means the compiler can process the headers more quickly. It also means faster symbol lookup times when compiling source files.\n\nWhen configuring the contents of your Objective-C bridging header, include only the headers and symbols you actually reference from your Swift source. If your Swift code uses only part of an Objective-C class, move the symbols your Swift code doesn’t use into categories in your implementation file or in an internal-only header file.\n\nThe following figure illustrates how you might separate the symbols you use externally from those your class uses internally. The MyViewController.h header contains only the subset of symbols you reference publicly from your Swift code. The MyViewController-Internal.h header includes the remaining symbols in category extensions on your class. Include both headers in your Objective-C implementation file, but include only the public header in your Objective-C bridging file.\n\nThe compiler makes all of your public Swift symbols available to your Objective-C code automatically using a generated header. To minimize the size of this generated header, update your Swift code in the following ways:\n\nMark internal methods and properties of your Swift classes as private. The presence of that keyword prevents the inclusion of the symbol in the generated header file.\n\nChoose block-based APIs over function-based APIs. Blocks are part of your implementation, and don’t generate public symbol information.\n\nSupport the most-recent version of the Swift language. Swift 3 and earlier automatically infer Objective-C type information for most symbols, which increases the size of the generated header. Later versions of Swift perform automatic type inference in fewer situations, reducing the overall size of the header.\n\nProvide the Swift compiler with explicit type information\n\nThe Swift compiler is capable of inferring the type of a variable from the value you assign to it. For simple values, the inference process is quick. For example, if you assign the value 0.0 to a property, the compiler can quickly determine that the type is a floating-point number. However, if you assign a complex value to a variable, the compiler must perform extra work to compute any type information.\n\nConsider the following structure, in which the bigNumber property has no explicit type information. To determine the type of that property, the Swift compiler must evaluate the results of the reduce(_:_:) function, which takes a nontrivial amount of time.\n\nstruct ContrivedExample {\n   var bigNumber = [4, 3, 2].reduce(1) {\n      soFar, next in\n      pow(next, soFar)\n   }\n}\n\n\nInstead of letting the compiler determine the type, the best practice is to provide the type explicitly as shown in the example below. Providing explicit type information reduces the work the compiler must do, and also allows it to do more error checking.\n\nstruct ContrivedExample {\n   var bigNumber : Double = [4, 3, 2].reduce(1) {\n      soFar, next in\n      pow(next, soFar)\n   }\n}\n\nDefine delegate methods in explicit protocols\n\nDelegates are a standard design pattern on Apple platforms, and provide a useful way to communicate between objects. Although delegation enables communication between arbitrary objects, always provide explicit type information for your delegate objects.\n\nConsider the following example of a delegate declared as an optional object of any type. Although this declaration is perfectly legal, it actually creates more work for the compiler. The compiler must assume that any object in your project or referenced frameworks contains the function, and so it searches your entire project to make sure that function exists somewhere.\n\nweak var delegate: AnyObject?\nfunc reportSuccess() {\n   delegate?.myOperationDidSucceed(self)\n}\n\n\nInstead of using any object, a better approach is to supply specific type information. Typically, you specify the type information using a delegate protocol, as shown in the example below. An explicit protocol helps the compiler find the method more quickly. It also allows the compiler to perform additional type checking for objects you assign to the delegate property.\n\nweak var delegate: MyOperationDelegate?\nfunc reportSuccess() {\n   delegate?.myOperationDidSucceed(self)\n}\n\n\nprotocol MyOperationDelegate {\n   func myOperationDidSucceed(_ operation: MyOperation)\n}\n\nSimplify complex Swift expressions\n\nThe Swift language allows you to write code in very expressive ways, but make sure your code doesn’t affect compile times. Consider an example of a function that uses the reduce function to sum a set of values. If you pass nil for all the arguments, the function returns nil, but if you pass one or more arguments, it sums the sum of those arguments. The function takes advantage of a Swift feature, in which the compiler uses the one-line expression in the closure to determine the return type of that closure.\n\nfunc sumNonOptional(i: Int?, j: Int?, k: Int?) -> Int? {\n   return [i, j, k].reduce(0) {\n      soFar, next in\n      soFar != nil && next != nil ? soFar! + next! : (soFar != nil ? soFar! : (next != nil ? next! : nil))\n   }\n}\n\n\nAlthough this function represents legal Swift syntax, the one-line closure makes the code hard to read and harder for the compiler to evaluate. In fact, the compiler aborts with an error that states it cannot type-check the expression in a reasonable amount of time. The one-line closure is also unnecessary. The definition of the reduce(_:_:) function causes it to return the same type you pass in, which in this case is an optional integer.\n\nRather than use such a complex expression, it’s better to create something simpler and more readable. The following code offers the same behavior as the single-line closure version, but is easier to read and compiles quickly.\n\nfunc sumNonOptional(i: Int?, j: Int?, k: Int?) -> Int? {\n   return [i, j, k].reduce(0) {\n      soFar, next in\n      if let soFar = soFar {\n         if let next = next { return soFar + next }\n         return soFar\n      } else {\n         return next\n      }\n   }\n}\n\nSee Also\nPerformance\nConfiguring your project to use mergeable libraries\nUse mergeable dynamic libraries to get app launch times similar to static linking in release builds, without losing dynamically linked build times in debug builds.\nImproving the speed of incremental builds\nTell the Xcode build system about your project’s target-related dependencies, and reduce the compiler workload during each build cycle."
  },
  {
    "title": "Improving the speed of incremental builds | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/improving-the-speed-of-incremental-builds",
    "html": "Overview\n\nThe Xcode build system manages the compilation and linking of the code in targets. Common types of targets include apps, app extensions, frameworks, libraries, and test suites. A simple project might contain only one target, such as the app you want to build. A more complex project might contain multiple targets with interdependencies, such as a private framework and an app that depends on that framework.\n\nAlways ensure that your project’s inter-target dependencies and configuration details are accurate. When you build a target, Xcode does as much work as possible in parallel. Fewer dependencies leads to greater parallelization, but an accurate dependency map is necessary to prevent build and runtime errors. Similarly, providing detailed configuration data helps Xcode schedule build-time tasks correctly and efficiently.\n\nNote\n\nFollowing coding best practices can also improve Xcode’s efficiency during compilation. For more information, see Improving build efficiency with good coding practices.\n\nMeasure the time it takes for each build task\n\nBefore you perform any build optimizations, always gather timing information to see where optimizations might be most effective. Open your project in Xcode and choose Product > Perform Action > Build With Timing Summary to build your target with detailed timing information. To view the timing information for a specific build, select that build in the Report navigator.\n\nNote\n\nTo generate timing information using the xcodebuild command-line tool, pass the -showBuildTimingSummary option to the tool.\n\nThe first time you build your project, Xcode builds everything, but subsequent builds are incremental. For each incremental build, pay particular attention to the preparation section and the specific tasks that Xcode performs for each target.\n\nIf Xcode didn’t build your targets in parallel, open the Scheme Editor for your target and make sure the Build Order option is set to Dependency Order.\n\nLook for extraneous tasks, such as custom scripts, and assess whether Xcode needs to run those scripts during each incremental build.\n\nIf compilation of a particular file takes significantly longer than other files, examine the file to see if header importation issues are causing the delay.\n\nDeclare inputs and outputs for custom scripts and build rules\n\nIf you use custom build scripts in your Xcode projects, make sure Xcode runs those scripts only when needed. You might use scripts to run custom tools, set build-environment variables programmatically, or perform other target-specific tasks. For example, you might use them to generate assets or other resource files from a proprietary data source. By default, Xcode runs custom scripts during every build cycle, including incremental builds. It also executes those scripts serially with respect to other tasks.\n\nIf you don’t need Xcode to run your scripts every time you build a target, provide at least one input file and one output file for the script. Xcode uses a script’s input and output files to determine when to run it. Specifically, Xcode runs your script when any of the following conditions are true:\n\nYour script doesn’t have any input files.\n\nYour script doesn’t have any output files.\n\nYour script’s input files changed.\n\nYour script’s output files are missing.\n\nSpecify input and output files, along with the script itself, in the Run Script build-phase editor. You may specify input and output files individually or in an Xcode file list — a file with an .xcfilelist filename extension that lists the name of each file on a separate line.\n\nYou must still specify an input and output file to prevent Xcode from running the script every time, even if your script doesn’t actually require those files. For a script that requires no input, provide a file that never changes as the input file. For a script with no outputs, create a static output file from your script so Xcode has something to check.\n\nCreate module maps for custom frameworks and libraries\n\nModule maps improve source compilation times by shortening the time it takes to import header files. A module map provides the compiler with a list of headers that the framework contains. When a framework includes a module map, the compiler doesn’t preprocess header files separately for each source file. Instead, it builds a cache of the framework’s symbol information and reuses that cache during subsequent compilations, which saves significant time.\n\nThe system frameworks already include module maps, but you must provide module maps for any custom frameworks in your project. To add a module map, enable the DEFINES_MODULE build setting for your framework or library. Xcode enables this build setting automatically for new frameworks, but you might need to set it for older projects. When enabled, the compiler produces a module map with the contents of your target’s public header files.\n\nImportant\n\nTo obtain the benefit from module maps, always include the framework name in any import statements. If you don’t include the framework name, the compiler can’t determine whether a module map is present. For more information on how to import header files from a module, see Include framework names in import statements.\n\nBefore you create a module map, make sure your framework meets the following requirements:\n\nYour framework’s header files must not rely on any external contextual information. Xcode compiles your module map separately from the rest of your project’s source files. Don’t rely on source-specific information to change the meaning or values of symbols in your headers.\n\nThe module must be self contained. Because Xcode compiles module maps separately, your framework’s header files must include everything they need to compile correctly.\n\nTo get the maximum reuse benefit from module maps, compile your app’s source files with identical build options. Xcode builds your framework’s module map using the same options as the source file that imports that framework. If your app’s source files use different options, Xcode must recompile the module map for each new set of options. Using identical options allows Xcode to reuse the cache in each subsequent source file.\n\nMake sure your target’s dependencies are accurate\n\nVerifying that your targets have accurate dependencies ensures they build correctly and in a timely manner. Out-of-date dependencies might force Xcode to build targets serially when it might have built them in parallel. Missing dependencies might cause correctness issues or even build errors. For example, if your app doesn’t have an explicit dependency to a separate code module, like an app extension, Xcode might build the app with an older version of the module that doesn’t work properly.\n\nWhen you know a dependency exists between two targets in your Xcode project, create an explicit dependency between them. Xcode creates some dependencies automatically based on how you configure your project. For example, when you embed a new framework inside an existing app, Xcode automatically adds the framework to the app’s list of dependencies. At other times, you specify the dependencies yourself using the Dependencies build phase editor, as shown below. Use the + and - buttons to add or remove dependencies for your target.\n\nIf a target depends on code in a different Xcode project, create a reference to that project by dragging it into the navigator pane of your current project. The presence of the other project in the navigator pane gives Xcode the information it needs to track dependencies on items in the other project. Without this reference, Xcode doesn’t know to build your target when the remote project changes.\n\nRefactor your targets to improve parallelism\n\nInter-target dependencies require Xcode to build those targets in a specific order. When a target has many dependencies, or when it depends on large, monolithic modules, Xcode must serialize more tasks. To improve build performance, simplify your target’s dependency list, and break up monolithic targets so that Xcode can do more work in parallel.\n\nConsider the following illustration, which shows an XML engine that depends on a monolithic utilities framework. Although the XML engine relies on only a small portion of the framework, Xcode must rebuild the engine when any part of the framework changes. Breaking up the framework into smaller modules and creating more fine-grained dependencies might eliminate some unnecessary rebuilds. In the refactored version, changes to the utilities framework no longer trigger an automatic rebuild of the XML engine.\n\nWhen one target depends on many child targets, Xcode cannot start to build the target until it finishes all of the children. Consider a single Tests target that executes automated tests on an app, app extension, and private framework. Splitting up the tests by target allows Xcode to run each suite independently as soon as the corresponding target is ready, which increases parallelization.\n\nYou need to decide whether modifications to your project’s targets offer any benefit. Increasing the number of targets can improve parallelization, but it also adds complexity to your project. Always validate any target or dependency changes to ensure your code still builds correctly. In addition, always measure the speed of the resulting builds to verify that the changes lead to tangible improvements.\n\nSee Also\nPerformance\nConfiguring your project to use mergeable libraries\nUse mergeable dynamic libraries to get app launch times similar to static linking in release builds, without losing dynamically linked build times in debug builds.\nImproving build efficiency with good coding practices\nShorten compile times by reducing the number of symbols your code exports and by giving the compiler the explicit information it needs."
  },
  {
    "title": "Verifying the origin of your XCFrameworks | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/verifying-the-origin-of-your-xcframeworks",
    "html": "Overview\n\nWhen you add third-party binary SDKs to your target as XCFrameworks, the behaviors of those packages become part of the behavior of your product. An attacker who’s able to inject a compromised version of the SDK into your project could change your app’s behavior and cause security and privacy issues for your developers, testers, and people who use your product.\n\nUse Xcode to inspect the information in the code signature embedded in an XCFramework when you add it to your project. The build system fails with an error if the code signature’s subsequently removed, becomes invalid, or a different developer signs an update to the framework. If any of these happens, take action to resolve the issue.\n\nInspect a dependency’s code signing identity\n\nIn Xcode, select your dependency’s XCFramework folder in the Project navigator. The File inspector shows you the XCFramework’s code signing status. If the framework is signed with an Apple Developer certificate, the inspector also shows which Apple Developer team signed the framework.\n\nIf the XCFramework is signed by a self-issued code signing identity, the inspector shows the SHA-256 fingerprint of the certificate in the framework’s code signature. Verify that the certificate fingerprint matches the value you expect.\n\nDiagnose build failures caused by code signature changes\n\nAn XCFramework’s code signature can change for legitimate reasons, like:\n\nthe provider of a third-party SDK transfers ownership of the SDK to another organization, who release a version that’s signed with the new organization’s Team ID.\n\nyou switch from a vendor-supplied distribution of an XCFramework to a version that you build and sign yourself.\n\nA changed code signature can also indicate that the XCFramework has been tampered with, or another actor has injected their own code into your system, pretending it’s a version of the XCFramework.\n\nIf the code signature for an XCFramework changes, Xcode shows the changed code signature information in the File inspector.\n\nIf you attempt to build the software without resolving the changed code signature information, the build system produces an error. Work with the XCFramework’s provider to determine whether the change is expected. If the change is expected, follow these steps:\n\nSwitch to the Issues navigator.\n\nSelect the error that says “[XCFramework name] is not signed with the expected identity and may have been compromised”.\n\nIn the dialog that appears, click Accept Change.\n\nIf your team and the SDK provider can’t account for the change to the XCFramework’s code signature, restore a version of the framework with the expected code signature, or remove the framework from your project. To restore the framework to a version with the expected code signature, do the following:\n\nIn the dialog, click Move to Trash.\n\nSwitch to or open a new Finder window.\n\nDrag a replacement copy of the XCFramework from a trusted source to the Finder folder that contained the copy you deleted.\n\nSwitch to Xcode, and verify that the XCFramework’s signature is valid in the File inspector.\n\nWarning\n\nIf you encounter an unexpected code signature change in an XCFramework, it’s possible that an attacker is exploiting a security vulnerability in your infrastructure. Audit the origins for your XCFrameworks to ensure you obtained them from official sources. You also need to audit your software development and deployment environment carefully, even if you revert the XCFramework to a correctly-signed version.\n\nXcode also warns you if the XCFramework is signed with an expired or revoked code signing identity, even if the identity hasn’t changed since you added the XCFramework to your project. If this happens, work with the SDK provider to obtain a new version of the framework that’s signed by a valid code signing identity.\n\nDiagnose failures caused when a code signature is removed\n\nIf someone removes the code signature for an XCFramework, Xcode shows the change in the File inspector.\n\nThe build system fails with an error if you attempt to build the software without resolving the removed code signature. Determine why the code signature is missing from the XCFramework. If you no longer expect the XCFramework to be signed, follow these steps:\n\nSwitch to the Issues navigator.\n\nSelect the error that says “[XCFramework name] is not signed with the expected identity and may have been compromised”.\n\nIn the dialog that appears, click Accept Change."
  },
  {
    "title": "Configuring the build settings of a target | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-the-build-settings-of-a-target",
    "html": "Overview\n\nThe Xcode build process is highly configurable, and you can change the build settings of a single target or all the targets in your project. Build settings control every aspect of the build process, including how Xcode compiles your source files, how it links your executable, whether it generates debug information, and how it packages and distributes your code. Xcode has hundreds of build settings to support the tools and steps associated with the build process.\n\nMake changes to your project or target’s settings from the Build Settings tab or with build configuration files. The following image shows the Build Settings tab for a project.\n\nNote\n\nYou can also store settings in specially formatted text files called build configuration files. These files make it easy to save your settings along with your source files in your source control management system. For information about build configuration files, see Adding a build configuration file to your project.\n\nFor a complete list of build settings, see Build settings reference.\n\nSearch and filter the list of build settings\n\nTo find a specific build setting quickly, use the filters and Search field at the top of the Build Settings tab.\n\nSelect a filter to display all settings or only the modified settings.\n\nEnter text in the search field to display settings that contain the specified string. Xcode searches all settings attributes by default.\n\nTo refine your search, click the magnifying glass and select a single attribute to match.\n\nConfigure the value of a build setting\n\nEach build setting has the following attributes.\n\nAttribute\n\n\t\n\nDescription\n\n\t\n\nExample\n\n\n\n\nTitle\n\n\t\n\nA human-readable name for the build setting.\n\n\t\n\nBuild Active Architecture Only\n\n\n\n\nName\n\n\t\n\nThe programmatic name for the build setting. This name appears in the Quick Help inspector, in build configuration (xcconfig) files, and in the xcodebuild command-line tool.\n\n\t\n\nONLY_ACTIVE_ARCH\n\n\n\n\nValue type\n\n\t\n\nCommon types include Booleans, strings, enumerations, string lists, path strings, and a list of path strings.\n\n\t\n\nBoolean\n\n\n\n\nValue\n\n\t\n\nThe current value of the setting.\n\n\t\n\nYES\n\nThe Build Settings tab displays a setting’s title or name, but not both. When titles are visible, choose Editor > Show Setting Names to display the names. When names are visible, choose Editor > Show Setting Titles to display the titles.\n\nWhen you find the setting you want to modify, click the value attribute and type the new value. Xcode applies a bold font to modified settings to help you find them later. To restore a setting’s original value, select it and press the Delete key. If you modified the setting from the Levels view, delete the setting at the level where you overrode the value. For example, if you overrode the setting in your project, delete the setting there, and not in a target belonging to that project.\n\nTo configure different values for debug and release builds, click a setting’s disclosure triangle to reveal the configuration-specific values, and make the changes there. If you modify a setting while its disclosure triangle is in the closed position, Xcode applies the change to both configurations.\n\nSome settings define their values in terms of other settings. For example, an attribute whose value is a path to a file might use the BUILD_DIR setting to specify part of the path. When a setting’s definition is visible, choose Editor > Show Values to see the computed final value — that is, the value without the environment variable. When the final value is visible, choose Editor > Show Definitions to see the definition.\n\nEvaluate how your project inherits settings\n\nEvery target inherits settings from both its parent project and the platform SDK. This inheritance model ensures that the target starts with valid baseline settings. When you create a target, Xcode changes some settings based on the target type, and you are free to make other changes based on your needs.\n\nTo help you track down the source of a setting’s value, open the build settings for your project or target and select the Levels filter. Xcode displays the current settings hierarchy in the build settings editor. This hierarchy includes the default SDK values and any other project or target values that are active. The Resolved column shows the final resolved value Xcode uses to build the item.\n\nWith levels displayed, highlighted values indicate values that take precedence. Xcode uses a target’s build settings before referring to build settings you define for the project. At each level, Xcode gives precedence to settings you provide in the project over those you provide in build configuration files. Xcode gives the lowest precedence to the default system values. The hierarchy of precedence is:\n\nTarget-level values.\n\nConfiguration settings file values mapped to a target.\n\nProject-level values.\n\nConfiguration settings file mapped to the project.\n\nSystem default values.\n\nNote\n\nWhen using the xcodebuild command-line tool, the tool gives any settings you pass to it the highest prededence.\n\nObtain additional details about a build setting\n\nTo see detailed information about a particular setting, select the setting and choose View > Inspectors > Quick Help. Xcode displays a description of the setting, along with its name and value type.\n\nSee Also\nBuild settings\nAdding a build configuration file to your project\nSpecify your project’s build settings in plain-text files, and supply different settings for debug and release builds.\nBuild settings reference\nA detailed list of individual Xcode build settings that control or change the way a target is built.\nIdentifying and addressing framework module issues\nDetect and fix common problems found in framework modules with the module verifier."
  },
  {
    "title": "Creating build rules for custom file types | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-build-rules-for-custom-file-types",
    "html": "Overview\n\nThe code and resource files in a project are typically in an editable format that a running app can’t use directly. During a build, Xcode transforms the files you’ve been editing into a suitable runtime format. For example, it compiles your code files into machine instructions for a specific device. Each transformation requires a specific tool, and Xcode uses your project’s build rules, or the built-in build rules, to select the correct tool for each file type.\n\nA build rule maps a specific file type to the tools Xcode needs to generate the required output for that file. For example, one build rule compiles .swift files into executable code using the Swift compiler. Xcode contains built-in rules for many file types, including both code files and resource files. You can create additional rules to transform other file types into an appropriate final form, or override a built-in rule to use a different tool.\n\nNote\n\nA build rule is the preferred way to process files that are independent from each other. The build system processes each file using a separate task, which allows for more parallelization. If you require the build system to process your files as a group in a single operation, create a custom Run Script build phase instead, as described in Running custom scripts during a build.\n\nAdd a new build rule for a custom file type\n\nIf your project contains file types not covered by Xcode’s built-in build rules, you can add new build rules to address those types. To create a new build rule:\n\nIn the project editor, select the target that contains your custom files.\n\nClick the Build Rules tab.\n\nClick the Add button (+) to create a new rule.\n\nIn the Process field, specify a filename matching string.\n\nIn the script text field, specify your custom script code.\n\nA build rule can use either a custom shell script or an existing tool to process files. If you use an existing tool to handle your custom file types, select that tool from the build rule’s Using field. For example, if your input files contain source code that a built-in compiler can handle, select the compiler from the list.\n\nSpecify the match criteria for source files\n\nTo match custom file types, select the “Source files with names matching” option in the Process field and specify a custom pattern string. Specify pattern strings that follow the same rules as the fnmatch function in the Standard C library. For example, to match all files with the names myfile.c and myfile.h, specify the string */myfile.c */myfile.h. During a build, Xcode compares the full path of each project file against the specified pattern. When a match occurs, the system executes your custom script code.\n\nImportant\n\nAvoid choosing filename extensions that overlap with the extensions other file types use. Xcode selects the first rule that matches a given file, so any overlap might cause Xcode to run the wrong tool.\n\nFor information about pattern matching using the fnmatch function, see the man page for that function.\n\nSpecify the input and output files for your shell script\n\nWhen Xcode detects one of your custom file types, it executes the shell script associated with the matching build rule. In your script, get the path to the source file from the SCRIPT_INPUT_FILE environment variable, and begin processing the file. If your script requires additional input data, such as build configuration files, specify those files in the Input Files section of your build rule, and access them using environment variables.\n\nYour script code takes an input source file and generates an appropriate output file. For example, a script that compiles source code might generate an object file with machine instructions. You specify the output files for your script in the Output Files section of your build rule. Most scripts generate only one output file, but you can specify multiple files when appropriate. Xcode determines when to rebuild your source files based on the output files that you declare. When the source file is newer than the output files, Xcode rebuilds it. If you don’t specify any output files, Xcode builds your source file every time, regardless of whether the source file changed.\n\nWhen you specify input and output files in your build rule, use the following variables to compose the path and filename information. For example, you might use $(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).compiledData to specify an output file based on the name of the original source file.\n\nVariable\n\n\t\n\nDescription\n\n\n\n\nPROJECT_DIR\n\n\t\n\nThe root directory of your project’s source files.\n\n\n\n\nDERIVED_FILE_DIR\n\n\t\n\nThe directory in which to place generated output files. The build system manages this directory and can clean it when needed.\n\n\n\n\nINPUT_FILE_BASE\n\n\t\n\nThe base name of the script’s input file. For example, if the path to the input file is $PROJECT_DIR/Images/Default.png, this variable contains the value Default.\n\n\n\n\nINPUT_FILE_NAME\n\n\t\n\nThe name of the input file, including the filename extension. For example, if the path to the input file is $PROJECT_DIR/Images/Default.png, this variable contains the value Default.png.\n\n\n\n\nINPUT_FILE_DIR\n\n\t\n\nThe directory that contains the input file. For example, if the path to the input file is $PROJECT_DIR/Images/Default.png, this variable points to the Images directory in your project.\n\n\n\n\nINPUT_FILE_PATH\n\n\t\n\nThe complete path to the input file.\n\nImportant\n\nPlace your script’s output files in the directory represented by the DERIVED_FILE_DIR variable. If you place them in other locations, your version-control system might not find them, or Xcode might not be able to remove them during a clean build operation.\n\nAccess script-related files from environment variables\n\nShell scripts have access to the current target’s build settings and the input and output files associated with the build rule. Before executing your build rule’s script, Xcode configures the shell environment with several environment variables. To access the build rule’s input and output files, use the environment variables in the following table.\n\nVariable\n\n\t\n\nDescription\n\n\n\n\nSCRIPT_INPUT_FILE\n\n\t\n\nThe absolute path of the file to process.\n\n\n\n\nOTHER_INPUT_FILE_FLAGS\n\n\t\n\nAdditional command-line flags you assigned to the file in the Compile Sources build phase.\n\n\n\n\nSCRIPT_INPUT_FILE_COUNT\n\n\t\n\nThe number of paths in the Input Files section of your build rule.\n\n\n\n\nSCRIPT_INPUT_FILE_n\n\n\t\n\nThe absolute path to one of the files in the Input Files section of your build rule. Xcode creates an environment variable for each file, starting with SCRIPT_INPUT_FILE_0 and increasing the number value sequentially for each subsequent file in the list.\n\n\n\n\nSCRIPT_OUTPUT_FILE_COUNT\n\n\t\n\nThe number of paths in the Output Files section of your build rule.\n\n\n\n\nSCRIPT_OUTPUT_FILE_n\n\n\t\n\nThe absolute path to one of the files in the Output Files section of your build rule. Xcode creates an environment variable for each file, starting with SCRIPT_OUTPUT_FILE_0 and increasing the number value sequentially for each subsequent file in the list.\n\n\n\n\nSCRIPT_HEADER_VISIBILITY\n\n\t\n\nA string that indicates a header’s visibility. If the current file is in the public or private section of the target’s Headers build phase, this string contains the value public or private to indicate its location.\n\n\n\n\nHEADER_OUTPUT_DIR\n\n\t\n\nThe directory in which to copy header files. If the current file is in a Headers build phase, copy the file to the location in this environment variable.\n\nImportant\n\nIn your shell scripts, place environment variables in quotation marks before you pass them as parameters to other scripts or tools. The quotation marks prevent parsing errors when a variable contains spaces or special characters.\n\nFor a list of build setting environment variables, see Build settings reference.\n\nSpecify additional build dependencies for your source file\n\nTo improve performance during incremental builds, Xcode rebuilds only the files that require a rebuild. To determine whether a file requires a rebuild, Xcode evaluates the following criteria:\n\nDid the contents of the source file change?\n\nDoes the source file depend on any other files that changed?\n\nXcode determines whether a source file changed by comparing the modification date of that file to the modification date of its output file. If the source file is newer, or if the output file doesn’t exist, Xcode builds the source file.\n\nAnalyzing the dependencies between source files is more complicated, but is important to ensure builds are correct. If a source file imports headers or other files, the tool that builds the source file reports the relationship to Xcode. For your custom file types, you report dependencies by generating a set of makefile rules for Xcode to execute.\n\nTo report dependency rules for your custom source files, enable the “Use discovered dependency file” option in your build rule. Xcode suggests a default naming pattern for your dependency files, but you can change the name to match your tool’s output. In your script code, create the dependency file during each build cycle, and save the file with the appropriate name.\n\nCreate the actual files in your script code when you build custom files. Fill the contents of each dependencies file with a set of makefile rules. The Xcode build system analyzes these rules at build time to determine whether it needs to rebuild the matching source file.\n\nSee Also\nBuild customization\nCustomizing the build schemes for a project\nSpecify which targets to build, and customize the settings Xcode uses to build, run, test, and profile those targets.\nCustomizing the build phases of a target\nSpecify the tasks to perform during a build, including the source files to compile, the scripts to run, and the resources to include in the final product.\nRunning custom scripts during a build\nExecute custom shell scripts during the build process, and run tools or other commands that your project requires.\nRunning code on a specific platform or OS version\nAdd conditional compilation markers around code that requires a particular family of devices or minimum operating system version to run."
  },
  {
    "title": "Adding a build configuration file to your project | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-a-build-configuration-file-to-your-project",
    "html": "Overview\n\nA build configuration file is a plain-text file you use to specify the build settings for a specific target or your entire project. Build configuration files make it easier to manage build settings yourself, and to change build settings automatically for different architectures and platforms. With a build configuration file, you place only the settings you want to modify in a text file. You can create multiple files, each with different combinations of build settings, and you can change the settings quickly for your target or project. Xcode layers your settings on top of other project-related settings to create the final build configuration.\n\nBuild configuration files are particularly useful in the following situations:\n\nYou want different build settings based on the current platform, architecture, or build type.\n\nYou want to store build settings in a way that is easier to inspect.\n\nYou want to edit build settings outside of Xcode.\n\nFor more information about how build configuration files integrate with your project’s other settings values, see Configuring the build settings of a target.\n\nAdd a build configuration file to your project\n\nA build configuration file is a text file with an .xcconfig filename extension that you add to your project. You can create as many build configuration files as you want, and you configure different settings in each one. For example, you might use one build configuration file for debug settings and another for release settings.\n\nTo create a build configuration file:\n\nSelect File > New File.\n\nSelect Configuration Settings File.\n\nClick Next.\n\nEnter a name and location for your build configuration file.\n\nDeselect all targets to prevent Xcode from embedding the file as a resource in the target’s bundle.\n\nClick Create to add it to your project.\n\nMap build settings to a build configuration\n\nYou can specify different build configuration files for debug and release builds, and you can specify layer configuration files on top of other settings. To specify build configuration files:\n\nSelect your project in the project editor.\n\nClick the Info tab.\n\nClick the disclosure triangles to expand the Debug and Release build configurations in the Configurations area.\n\nChoose configuration settings files for your Debug and Release builds from the pop-up menus. You can also select a file that applies to both build types.\n\nXcode applies settings from a build configuration file before the corresponding settings from the project’s or target’s Build Settings tab. For example, if you provide a build configuration file for your target, Xcode applies the project settings, then the build configuration settings, then the target settings.\n\nFor more information about the order in which Xcode applies settings, see Configuring the build settings of a target.\n\nAssign a value to a setting\n\nTo specify a new value for a setting, add that setting to your configuration file using the following format:\n\n<SettingName> = <SettingValue>\n\n\nPlace each setting on a separate line, and include only the settings you want to change in your build configuration file. Xcode ignores leading and trailing spaces, so you can indent settings as needed. If you add the same setting multiple times, Xcode uses the last instance of the setting and ignores previous instances.\n\nMany value types are possible for settings, but the following table lists the most common ones:\n\nValue type\n\n\t\n\nDescription\n\n\n\n\nBoolean\n\n\t\n\nA value of YES or NO.\n\n\n\n\nstring\n\n\t\n\nA text string.\n\n\n\n\nenumeration (string)\n\n\t\n\nA predefined text string. See the settings reference for a list of valid values.\n\n\n\n\nstring list\n\n\t\n\nA space-separated list of string values. If a string within the list contains spaces, surround that string with quotes.\n\n\n\n\npath\n\n\t\n\nA file or directory path, in POSIX form.\n\n\n\n\npath list\n\n\t\n\nA space-separated list of path values. If a path within the list contains spaces, surround the path with quotes.\n\nSome examples of settings include:\n\nONLY_ACTIVE_ARCH = YES\nMACOSX_DEPLOYMENT_TARGET = 11.0\nOTHER_LDFLAGS = -lncurses\n\n\nFor a list of build settings, see Build settings reference.\n\nAugment a setting with additional values\n\nIn some cases, you might want to extend a setting rather than overwrite its current value. For example, you might want to add more flags to a compiler instead of replacing the existing flags. To extend a setting’s existing value, add the $(inherited) keyword to the value of your setting, as shown in the following example:\n\nOTHER_SWIFT_FLAGS = $(inherited) -v\n\nRefer to the value of another setting\n\nTo reuse an existing build setting’s value, place the name of the setting in a string of the form $(SettingName). When evaluating your build settings, Xcode replaces these references with the values of the corresponding settings. For example, the following definition assigns the value of the SYMROOT build setting to the OBJROOT setting:\n\nOBJROOT = $(SYMROOT)\n\n\nWhen replacing references, Xcode inserts the setting’s value at the same location as the original reference. You can insert references in the middle of a new value, or you can define a setting using multiple other values, as shown in the following examples:\n\nDSTROOT = /tmp/$(PROJECT_NAME).dst\nCONFIGURATION_BUILD_DIR = $(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)\n\nApply a setting conditionally to a platform or architecture\n\nAdd a conditional expression after a build setting to apply that setting only when a specific platform or architecture is active. To specify a conditional expression, enclose it in square brackets after the build setting name, as shown in the following example:\n\nOTHER_LDFLAGS[arch=x86_64] = -lncurses\n\n\nXcode applies a build setting only when the setting’s conditional expression evaluates to true. Xcode supports the following conditions:\n\nCondition\n\n\t\n\nValues\n\n\n\n\nsdk\n\n\t\n\nAn SDK, such as macosx12.0 or iphoneos15.0. To match all versions of a specific platform, replace the version number with an asterisk (*). For example, specify macosx* to match any macOS SDK.\n\n\n\n\narch\n\n\t\n\nA CPU architecture, such as arm64 or x86_64.\n\n\n\n\nconfig\n\n\t\n\nThe build configuration, such as Debug or Release.\n\nTo add multiple conditions to the same build setting, place each condition in separate brackets after that setting’s name, as shown in the following example:\n\nOTHER_LDFLAGS[sdk=macos*][arch=x86_64] = -lncurses\n\nInclude settings from other build configuration files\n\nWhen you specify the build configuration file for your target, you must select only one file, but that file can include settings from other configuration files. To import the settings from a different configuration file, add an #include statement:\n\n#include \"MyOtherConfigFile.xcconfig\"\n\n\nIf Xcode can’t find an included build configuration file, it generates build warnings. To suppress these warnings, add a question mark (?) to the #include command, as shown in the following example:\n\n#include? \"MyOtherConfigFile.xcconfig\"\n\n\nXcode looks for included build configuration files in the same directory as the current file. If your build configuration file is in a different directory, specify a relative path or an absolute path, as shown in the following examples:\n\n#include \"../MyOtherConfigFile.xcconfig\"    // In the parent directory.\n#include \"/Users/MyUserName/Desktop/MyOtherConfigFile.xcconfig\" // At the specific path.\n\nAdd comments to your settings\n\nAdd comments to your build configuration files to include notes or other information that’s relevant to you. Specify your comments on a single line preceded by two forward slashes (//). The build system ignores everything from the comment delimiter to the end of the current line. For example:\n\n//\n//  Base Settings.xcconfig\n//  Base Settings\n//\n//  Created by Johnny Appleseed on 7/21/21.\n//\n\n\nYou can also place a comment at the end of a line that contains a build setting definition, as in the following example:\n\nASSETCATALOG_COMPILER_APPICON_NAME = MyAppIcon // This is a comment. \n\nSee Also\nBuild settings\nConfiguring the build settings of a target\nSpecify the options you use to compile, link, and produce a product from a target, and identify settings inherited from your project or the system.\nBuild settings reference\nA detailed list of individual Xcode build settings that control or change the way a target is built.\nIdentifying and addressing framework module issues\nDetect and fix common problems found in framework modules with the module verifier."
  },
  {
    "title": "Running custom scripts during a build | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/running-custom-scripts-during-a-build",
    "html": "Overview\n\nXcode provides many tools for turning code and resources into finished products, but sometimes you need to run custom tools for your products. For example, you might package some of your resources into an optimized format for faster runtime access. For these tasks, you use custom shell scripts to execute the code and tools you need during the build process.\n\nNote\n\nIf your script compiles or converts one or more input files to a different format, considering creating a build rule for your files instead. For more information, see Creating build rules for custom file types.\n\nAdd a run script build phase to your target\n\nTo execute a custom script at build time, add a Run Script build phase to your target. This build phase runs separately from the target’s other build phases, such as the compilation and link build phases. You may add multiple script-related build phases to your target to execute scripts at different stages of the build.\n\nTo add a Run Script build phase to a target:\n\nIn the project navigator, select your project.\n\nSelect the target you want to modify.\n\nClick the Build Phases tab.\n\nClick the Add button (+), then choose “New Run Script Phase” from the pop-up menu.\n\nClick the disclosure triangle for the newly added Run Script phase.\n\nIn the Shell text field, enter your script code.\n\nIf you have an existing shell script file, drag it onto the Shell text field to copy the script there. You may use any of the available shell environments to execute your script, and you can change the execution shell by changing the shell command above your script code.\n\nNote\n\nTo rename a script phase, double-click the Run Script title to edit it.\n\nSpecify the input and output files for your script\n\nThe Run Script build phase provides a place to enter any input and output files for your script. Use input and output files to customize your script’s behavior and to help the build system understand when to execute your script. Input files contain data you want the script to process. For example, you might pass one or more image files to the script. Output files contain any data generated by the script.\n\nSpecify input and output files in one of two ways:\n\nSpecify individual files as path strings. Typically, you use path strings only when you know the input or output files in advance and you’re sure they won’t change.\n\nSpecify files in a file list, which is a text file with an .xcfilelist filename extension. File lists make it easier to edit the set of files, and are particularly useful if you change the list of files frequently or want to annotate the list with comments.\n\nTo add files or file lists to your script, click the Add button (+) in the appropriate section of your Run Script build phase. For each entry, specify the path to the file or file list, which can include build variables. For example, the string $(PROJECT_DIR)/myFileList specifies a file list in the root directory of the current project.\n\nIf you periodically change the set of input or output files, specify them using a file list. A file list contains a list of path strings separated by newline characters. Each path string represents a single input or output file for the script. Path strings can include build variables such as $(PROJECT_DIR).\n\nNote\n\nYou don’t have to specify input and output files, but it’s highly recommended that you do. Xcode uses the set of input and output files to optimize build times, by running your script only when necessary. If you don’t specify input or output files, Xcode runs your script every time you build the target. For more information, see Improving the speed of incremental builds.\n\nAccess script-related files from environment variables\n\nXcode configures the execution environment for your script and gives your script access to the same build settings and environment variables as the target. Xcode also creates the following environment variables specifically for your script.\n\nVariable\n\n\t\n\nDescription\n\n\n\n\nSCRIPT_INPUT_FILE_COUNT\n\n\t\n\nThe total number of files available as inputs to the script.\n\n\n\n\nSCRIPT_INPUT_FILE_[#]\n\n\t\n\nEnvironment variables that contain the paths to the script’s input files. Xcode creates an environment variable for each input file, starting with SCRIPT_INPUT_FILE_0 and increasing the number value sequentially for each subsequent file.\n\n\n\n\nSCRIPT_INPUT_FILE_LIST_COUNT\n\n\t\n\nThe total number of file lists available as inputs to the script.\n\n\n\n\nSCRIPT_INPUT_FILE_LIST_[#]\n\n\t\n\nEnvironment variables that contain the paths to the script’s input file lists. Xcode creates an environment variable for each input file list, starting with SCRIPT_INPUT_FILE_LIST_0 and increasing the number value sequentially for each subsequent file list.\n\n\n\n\nSCRIPT_OUTPUT_FILE_COUNT\n\n\t\n\nThe total number of files described as script outputs.\n\n\n\n\nSCRIPT_OUTPUT_FILE_[#]\n\n\t\n\nEnvironment variables that contain the paths to the script’s output files. Xcode creates an environment variable for each output file, starting with SCRIPT_OUTPUT_FILE_0 and increasing the number value sequentially for each subsequent file.\n\n\n\n\nSCRIPT_OUTPUT_FILE_LIST_COUNT\n\n\t\n\nThe total number of file lists described as script outputs.\n\n\n\n\nSCRIPT_OUTPUT_FILE_LIST_[#]\n\n\t\n\nEnvironment variables that contain the paths to the script’s output file lists. Xcode creates an environment variable for each output file list, starting with SCRIPT_OUTPUT_FILE_LIST_0 and increasing the number value sequentially for each subsequent file list.\n\nUse the build settings and script-specific environment variables to customize your script’s behavior. For example, you might write your script’s output files to the directory in the BUILT_PRODUCTS_DIR build setting. For a complete list of build settings, see Build settings reference.\n\nLog errors and warnings from your script\n\nDuring your script’s execution, you can report errors, warnings, and general notes to the Xcode build system. Use these messages to diagnose problems or track your script’s progress. To write messages, use the echo command and format your message as follows:\n\n[filename]:[linenumber]: error | warning | note : [message]\n\n\nIf the error:, warning:, or note: string is present, Xcode adds your message to the build logs. If the issue occurs in a specific file, include the filename as an absolute path. If the issue occurs at a specific line in the file, include the line number as well. The filename and line number are optional.\n\nSome example errors and warnings include:\n\necho \"error: An expected input file was missing.\"\necho \"warning: Skipping a file of an unknown type.\"\n\nTrigger a build failure\n\nWhen your script fails and recovery isn’t possible, return a nonzero exit code from your script. Xcode treats a nonzero exit value as a build failure, and adds appropriate information to the logs.\n\nThe following example logs an error message to standard out and triggers a build failure.\n\necho \"error: A fatal error occurred in the script.\"\nexit 1\n\nSee Also\nBuild customization\nCustomizing the build schemes for a project\nSpecify which targets to build, and customize the settings Xcode uses to build, run, test, and profile those targets.\nCustomizing the build phases of a target\nSpecify the tasks to perform during a build, including the source files to compile, the scripts to run, and the resources to include in the final product.\nCreating build rules for custom file types\nTell Xcode how to build your project’s custom file types, and provide dependency information to optimize the build process for each file.\nRunning code on a specific platform or OS version\nAdd conditional compilation markers around code that requires a particular family of devices or minimum operating system version to run."
  },
  {
    "title": "Customizing the build phases of a target | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/customizing-the-build-phases-of-a-target",
    "html": "Overview\n\nWhen you build a target in your Xcode project, the build system executes a specific set of tasks to produce the resulting product. In Xcode, you specify the files and scripts for your target using build phases. The build system then uses that information and other build settings to determine the tasks required to build the target.\n\nXcode configures the initial build phases for each target at creation time, but you can add or modify those build phases later. You might add build phases to copy additional files to your app bundle, or to execute custom shell scripts. You can also examine the build phases to diagnose potential issues. For example, you might make sure that Xcode is linking your code against third-party libraries that your code uses.\n\nView and add build phases to a target\n\nTo view the build phases for a target, select the target and navigate to the Build Phases tab, as shown in the following figure. To add a new build phase, click the Add button (+) and select an appropriate build phase from the pop-up menu. Xcode disables any menu options that aren’t valid. For example, Xcode disables the Compile Sources build phase if your target already contains a build phase of that type.\n\nXcode supports the following build phases:\n\nDependencies. Specifies other targets, in the same project or a referenced project, that Xcode must build before it builds the current target. The order of the targets indicates the order in which Xcode starts building them. Xcode builds multiple dependent targets in parallel when possible. For information about how to configure a dependency, see Configuring a new target in your project.\n\nCompile Sources. Contains the list of source files to compile. This build phase typically contains Swift and Objective-C files, but it can contain any other compilable source files. You can specify distinct compiler flags for each source file. A target can include only one build phase of this type. You can’t include this build phase in Aggregate and External Build Tool targets.\n\nLink Binary with Libraries. Links your compiled sources with other frameworks and libraries. With this build phase, Xcode links your code against Apple frameworks, platform libraries, and any other frameworks and libraries you list explicitly. A target can include only one build phase of this type. You can’t include this build phase in Aggregate and External Build Tool targets. For more information, see Link Against Additional Frameworks and Libraries.\n\nCopy Bundle Resources. Copies files to the bundle directory designated for resources. On macOS, the designated resources directory is the Contents\\Resources directory. On iOS, the bundle stores global resources in the bundle’s Contents directory. As part of the copy operation, the build system can process the files first, and copy the results to the bundle. A target can include only one build phase of this type, and the target must have a bundle directory. For more information, see Copy Files to the Finished Product.\n\nHeaders. Associates public, private, or project header files with the target. Public and private headers define the API that the target exposes to external clients. Xcode copies these header files into Headers and PrivateHeaders subfolders within the built product. Project headers contain the API that the target uses, but Xcode doesn’t expose the API to external clients. A target can include only one build phase of this type. For more information, see Add Public and Private Headers to a Target.\n\nCopy Files. Copies files and other built products to the specified destination. The build system normally doesn’t process files you specify using this build phase, but you can change that behavior by enabling the APPLY_RULES_IN_COPY_FILES build setting. When copying other products, this build phase signs the products if necessary. A target can contain multiple build phases of this type. For more information, see Copy Files to the Finished Product.\n\nRun Script. Runs a custom shell script, which you might use to execute custom tools and logic at specific points in the build process. A target can contain multiple build phases of this type. For more information on creating and managing build scripts, see Running custom scripts during a build.\n\nNote\n\nFor some operations, Xcode customizes the name of an existing build phase to reflect the corresponding action. For example, when you embed a framework in an app, Xcode configures a Copy Files build phase with the title Embed Frameworks.\n\nAfter you add a build phase, configure its contents. For most build phases, you add one or more files related to the associated task. In some cases, you can also configure additional settings. For example, in the Compile Sources build phase, you can add compiler flags to individual files.\n\nXcode adds new build phases to the end of the list initially. You can rearrange build phases by dragging them in the editor, but Xcode still executes tasks according to dependency order. To remove a build phase from your target, click the close button (x) next to that build phase.\n\nLink against additional frameworks and libraries\n\nMost targets include a Link Binary with Libraries build phase, which resolves your code’s references to frameworks, libraries, external XCFrameworks, and library products in Swift packages. If your project relies on custom libraries, add them to this build phase and specify the linkage type. For each library, you can specify the following details.\n\nFor multiplatform targets, use the Filters control to specify which platforms to support.\n\nSpecify whether a library is required or optional. This option reflects legacy link options for some frameworks. Do not change this setting in modern projects.\n\nXcode automatically links your Swift code against Apple frameworks and libraries, so you don’t need to include them in this build phase. For C, C++, and Objective-C code, Xcode links against Apple frameworks and libraries only when the CLANG_MODULES_AUTOLINK build setting is enabled, which it is by default. Add any add third-party libraries or custom libraries from your own project to this build phase.\n\nAdd public and private headers to a target\n\nFrameworks and libraries typically expose APIs for external clients to call, and other targets can expose APIs too. If your target exposes any API to external clients, use a Headers build phase to add the appropriate header files to the built product. Clients use your header files to learn about and call the available APIs.\n\nIn the Headers build phase, drag files to one of three sections:\n\nDrag files with publicly supported symbols to the Public section. Public headers represent the public contract between your code and any clients that access it. Xcode places these files in a Headers directory inside the bundle.\n\nDrag files with private symbols to the Private section. Private headers contain additional interfaces that you make available to clients, but that aren’t necessarily part of the public contract between your code and clients. Xcode places these files in a PrivateHeaders directory inside the bundle.\n\nDrag files that contain internal project interfaces to the Project section. Xcode doesn’t copy these files into the built product.\n\nWhen Xcode copies files to the built product, the Headers build phase usually doesn’t modify files. However, if you enable the COPY_HEADERS_RUN_UNIFDEF build setting, Xcode runs the unifdef tool over your headers to remove preprocessor conditional code.\n\nCopy files to the finished product\n\nTo copy custom resources or data files into a bundle, add a Copy Files or Copy Bundle Resources build phase to your target. Xcode uses a Copy Bundle Resources build phase to copy storyboards and asset catalogs to the appropriate directory for resources, which differs by platform. Xcode also uses instances of the Copy Files build phase to embed frameworks, app extensions, app clips, and other content inside your bundle. You use these build phases to copy other project files into a bundle. For example, you might copy templates for new documents into your app’s bundle.\n\nThe Copy Bundle Resources build phase places files in the bundle’s designated resource directory. The Copy Files build phase supports the following destination directories:\n\nProducts Directory: Places items in the same directory as the built product.\n\nWrapper: Places items in the root of the bundle directory.\n\nExecutables: Places items in the same directory as the bundle’s main binary.\n\nResources: Places items in the platform-specific directory for resources.\n\nJava Resources: Places items in the Resources/Java subfolder.\n\nFrameworks: Places items in the Frameworks subfolder.\n\nShared Frameworks: Places items in the SharedFrameworks subfolder.\n\nShared Support: Places items in the SharedSupport subfolder.\n\nPlugins: Places items in the Plugins subfolder.\n\nXPC Services: Places items in the XPCServices subfolder.\n\nSystem Extensions: Places items in the Library/SystemExtensions subfolder.\n\nApp Clips: Places items in the AppClips subfolder.\n\nFor each build phase, you can supply a subpath string to copy files to a specific subdirectory of the target destination. For example, if you select the Resources destination for a Mac app and include the subpath string Templates, Xcode copies the files to the Resources/Templates subfolder in the app bundle.\n\nNote\n\nThe Copy Files build phase supports signing any resources you place in the bundle. Typically, you use this option when copying built products such as app extensions to your bundle.\n\nFor details on the location of platform-specific bundle directories, see Placing Content in a Bundle\n\nSee Also\nBuild customization\nCustomizing the build schemes for a project\nSpecify which targets to build, and customize the settings Xcode uses to build, run, test, and profile those targets.\nCreating build rules for custom file types\nTell Xcode how to build your project’s custom file types, and provide dependency information to optimize the build process for each file.\nRunning custom scripts during a build\nExecute custom shell scripts during the build process, and run tools or other commands that your project requires.\nRunning code on a specific platform or OS version\nAdd conditional compilation markers around code that requires a particular family of devices or minimum operating system version to run."
  },
  {
    "title": "Running code on a specific platform or OS version | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/running-code-on-a-specific-version",
    "html": "Overview\n\nWhen you invest time developing a new feature for an app, you want to get the maximum value out of the code you write. Creating a new project to support a new platform or operating system version adds unnecessary work, especially if most of your code stays the same. The best solution is to maintain one version of your app that runs on multiple platforms and operating system versions. To achieve this, compile code conditionally for the target platform, or use availability condition checks to run code based on operating system version.\n\nCompile code for a specific platform\n\nApple platforms support many of the same technologies, but some features might not be available on every platform. For example, features on iOS devices might not make sense on a macOS devices. To prevent code from compiling on an operating system that doesn’t support the corresponding feature, add a conditional compilation block to specify the target operating system.\n\n/// Swift\n/// `iOS` specifies the operating system for which this code compiles. \n/// Change `iOS` to specify another operating system.\n#if os(iOS)\n   // iOS code\n#endif\n\n/// Objective-C\n/// `IOS` specifies the operating system for which this code compiles. \n/// Change `IOS` to specify another operating system. For the list of \n/// compilation macros, see the /usr/include/TargetConditionals.h \n/// header file in the appropriate SDK.\n#if TARGET_OS_IOS\n   // iOS code\n#endif\n\n\nYou can also compile or prevent compiling for specific environments, such as Simulator or Mac Catalyst.\n\n/// Swift\n/// `simulator` specifies an environment to compile the code for. \n/// Change `simulator` to specify another environment, such as `macCatalyst`.\n#if targetEnvironment(simulator)\n    // code for Simulator\n#endif\n\n\n\n/// Objective-C\n/// `SIMULATOR` specifies an environment this code depends on. \n/// Change `SIMULATOR` to specify another environment, such as `MACCATALYST`.\n#if TARGET_OS_SIMULATOR\n    // code for Simulator\n#endif\n\n\nIf your Swift code relies on a specific Swift package or framework, you can check to see whether you can import the package or framework. This condition tests whether it’s possible to import a module, but doesn’t actually import it. This type of check has the advantage that your code uses the package or framework if a future version of the operating system makes it avialable.\n\n/// Swift\n/// `UIKit` specifies a module this code depends on. \n/// Change `UIKit` to specify another module.\n#if canImport(UIKit)\n    // code that requires UIKit\n#endif\n\n\nFor more information on the compiler control statements and the platforms conditions they support, see Compiler Control Statements in the Swift language documentation.\n\nRequire a minimum operating system version for a feature\n\nYour app’s minimum deployment target defines the range of operating system versions your app supports. Rather than require the latest system software for each app update, target one or two older operating system versions to give people time to transition gradually. When you implement features found only in the most recent operating system version, wrap your code with availability markers.\n\nIn Swift, use the #available compiler control statement to run code conditionally.\n\nIn Objective-C, use the @available compiler directive to run code conditionally.\n\nPlatform names support both major and minor revision numbers for releases, as shown in the following example:\n\n/// Swift\nif #available(iOS 15.4.1, *) {\n    // On iOS, this branch runs in versions 15.4.1 and greater. \n    // On any other OS, this branch runs in any version of that OS.\n} else {\n   // This branch runs in earlier iOS versions.\n}\n\n/// Objective-C\nif (@available(iOS 15.4.1, *)) {\n    // On iOS, this branch runs in versions 15.4.1 and greater. \n    // On any other OS, this branch runs in any version of that OS.\n} else {\n   // This branch runs in earlier iOS versions.\n}\n\n\nThe * matches any other operating system. To specify versions for multiple operating systems, include multiple operating system names separated by commas.\n\n// Swift\nif #available(iOS 15, macOS 12, *) {\n    // On iOS, this branch runs in iOS 15 or later.\n    // On macOS, this branch runs in macOS 12 or later.\n    // On any other OS, this branch will run in any version of that OS.\n} else {\n   // This branch runs in earlier iOS and macOS versions.\n}\n\n// Objective-C\nif (@available(iOS 15, macOS 12, *)) {\n    // On iOS, this branch runs in iOS 15 or later.\n    // On macOS, this branch runs in macOS 12 or later.\n    // On any other OS, this branch will run in any version of that OS.\n} else {\n   // This branch runs in earlier iOS and macOS versions.\n}\n\n\nFor more information on the availability condition statement, see Availability Condition in the Swift language documentation.\n\nAnnotate declarations in your code\n\nYou can reduce the number of conditional runtime checks your app performs by factoring code with common requirements together and annotating your declarations.\n\nIn Swift, use the @available attribute to indicate a declaration is available.\n\nIn Objective-C, use the API_AVAILABLE macro to add availability information.\n\n@available(iOS 15, macOS 12, *)\nfunc newMethod() {\n    // Use iOS 15 APIs.\n}\n\n@interface MyViewController : UIViewController\n- (void) newMethod API_AVAILABLE(ios(15));\n@end\n\n\nWith the above annotation in place, calling newMethod might still require a compiler control statement, but you remove the need to check again inside the body.\n\nFor more information about marking availability in Swift, see available.\n\nSee Also\nBuild customization\nCustomizing the build schemes for a project\nSpecify which targets to build, and customize the settings Xcode uses to build, run, test, and profile those targets.\nCustomizing the build phases of a target\nSpecify the tasks to perform during a build, including the source files to compile, the scripts to run, and the resources to include in the final product.\nCreating build rules for custom file types\nTell Xcode how to build your project’s custom file types, and provide dependency information to optimize the build process for each file.\nRunning custom scripts during a build\nExecute custom shell scripts during the build process, and run tools or other commands that your project requires."
  },
  {
    "title": "Configuring a multiplatform app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-a-multiplatform-app-target",
    "html": "Overview\n\nMultiplatform apps broaden the experience of your app to each additional platform you support. In Xcode 14 or later, you can share your app’s project settings and code across platforms using a single, multiplatform target.\n\nIn Xcode, an app target specifies project settings information like your app’s bundle identifier and display name, as well as which source code files belong to your app. By default, apps that share a multiplatform target share project settings, so you only need to set them once. You can adjust your project settings as needed for individual platforms.\n\nBefore you combine targets into a multiplatform target, check your app to determine the differences in build configuration, framework availability, and API availability.\n\nNote\n\niOS, iPadOS, macOS, visionOS, and tvOS apps can share a single target. watchOS apps remain in a separate target.\n\nEvaluate the project settings and code your apps share\n\nIf you want to bring an existing app to a new platform, consider the technologies you use on the platform you already support and the additional platforms you plan to build for. If the technologies and project settings that you plan to use overlap considerably, multiplatform app targets are a good fit. Otherwise, use a separate target for each platform. For example, if your existing app uses SwiftUI and you plan to use SwiftUI for the new platform, use one multiplatform target. However, if your existing app uses UIKit and you want to use AppKit for the Mac, use separate targets.\n\nIf your app already supports multiple platforms and shares substantial amounts of code and configuration between those projects, consider combining your multiple targets into a single target. In particular, if you’re developing your app in SwiftUI, your app targets likely already share a lot of the same code and configuration. You can use a single App structure to define the SwiftUI app life cycle for each platform.\n\nIf your app already supports multiple platforms, but you’ve been building each platform separately for a long time, the targets might not share much code or configuration. In these cases, continue using separate targets unless you have a longer term plan for converging platform support.\n\nConfigure the supported destinations for a target\n\nTo add a destination to a target, click the Add (+) button under Supported Destinations, and then select the destination you’d like to add. Depending on the platforms your app already supports, the Add (+) button brings up a different set of destinations that are available to add to the current target. To remove a destination from a target, select the destination, then click the Remove (-) button. The following shows an app target that supports iPhone and iPad:\n\nThe following shows the additional destinations available to that target:\n\nIf you’re adding a Mac or Apple Vision destination to a target, choose the destination type that matches the kind of experience you want to provide:\n\nMac\n\nChoose this option if you’re starting a new Mac app. You can use all the features and APIs from the macOS SDK, powered by AppKit and SwiftUI. This option is the default for multiplatform apps.\n\nMac Catalyst\n\nChoose this option if you’re bringing an existing iPad app to Mac. The system adjusts the appearance of standard UIKit interface elements in your app for Mac. You might need to make changes to your app’s layout to adopt Mac Catalyst.\n\nApple Vision\n\nChoose this option if you’re starting a new app or modifying your existing app for Apple Vision Pro. You can use all the features and APIs from the visionOS SDK, powered by RealityKit and SwiftUI. This option is the default for multiplatform apps.\n\nDesigned for iPad\n\nChoose this option to run an unmodified version of your iPad app on a Mac with Apple silicon or Apple Vision Pro. Standard UIKit interface elements retain their appearance when your app runs on Apple silicon or Apple Vision Pro. This option is the default Mac or Apple Vision destination type for iPad apps.\n\nCustomize project settings\n\nAdding support for another platform can reveal places in your project where you want to customize your app for one of the platforms you support or for a new build configuration. You can conditionalize build settings either by build configuration or by platform. Use the Add (+) button next to the setting you want to customize.\n\nThe following shows an app that adds “Beta” to the app’s display name in the Beta build configuration and adds “Mobile” to the iOS app’s display name in the Release configuration:\n\nResolve build issues by adding conditional statements\n\nAdding another platform can also reveal build-time issues in your app. To resolve those issues, insert conditional statements around any code that uses platform-specific APIs or frameworks. For example, an app that includes an AR experience in iOS and iPadOS likely contains code that uses ARKit. ARKit isn’t available in macOS or tvOS, so you need to separate out code that uses platform-specific APIs or frameworks.\n\nXcode identifies this sort of build-time issue when you build your project. To try a build on a new platform, pick the new run destination in the scheme menu that corresponds with the platform you added. If Xcode identifies any issues, navigate to them one-by-one and use the following steps to resolve them.\n\nAddress unavailable frameworks. If a framework isn’t available for a platform, surround the import with a canImport conditional statement:\n\n#if canImport(ARKit)\nimport ARKit\n#endif\n\n\nAddress unavailable APIs. Frameworks that are available across multiple platforms might have individual symbols likes types, methods, or enumeration cases that are restricted to a subset of platforms. To resolve these availability issues, surround the relevant code with an #if os platform compilation condition statement:\n\nToggle(isOn: $isOn) {\n    Text(\"Show Holidays calendar\")\n}\n#if os(macOS)\n.toggleStyle(.checkbox)\n#endif\n\n\nIf an entire file is platform specific, you can remove it entirely from the platforms where it’s not applicable. In the target editor for your project, go to Build Phases > Compile Sources, and deselect the source file from the Filters column.\n\nCustomize the experience of your app for each platform\n\nEnsure that your app’s user interface and experience fit the needs of each platform by adding platform-specific views and features. For example, some Mac apps include a menu bar extra that appears even when the app isn’t the frontmost app. The following adds a MenuBarExtra instance only in the macOS version of a scene:\n\nvar body: some Scene {\n    WindowGroup {\n        PrimaryView()\n    }\n    #if os(macOS)\n    MenuBarExtra(\"Inspect\", systemImage: \"eyedropper\") {\n        VStack {\n            Button(\"Action One\") {\n                // ...\n            }\n            Button(\"Action Two\") {\n                // ...\n            }\n        }\n    }\n    #endif\n}\n\n\nFor design guidance, see Human Interface Guidelines.\n\nPrepare each platform for App Store submission\n\nBuild, run, and test your app on each platform before submitting each version to the App Store separately. Each submission involves a separate build and archival process.\n\nSee Also\nEssentials\nConfiguring a new target in your project\nConfigure your project to build a new product, and add the code and resources the product requires."
  },
  {
    "title": "Configuring your project to use mergeable libraries | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-your-project-to-use-mergeable-libraries",
    "html": "Overview\n\nIn Xcode 14 or earlier, you include code from a separate library in your target using static linking or dynamic linking. You link a static library to your app when you build your target, which can increase both your build time and app size. The dynamic loader resolves dynamic symbols in the executable to point to the appropriate addresses in the dynamic libraries when you run your target, which can increase your app launch time.\n\nIn Xcode 15 or later, you can include symbols from a separate, mergeable dynamic library for macOS and iOS app and framework targets. Mergeable dynamic libraries include extra metadata so that Xcode can merge the library into another binary, similar to linking a static library with -all_load. When you enable automatic merging, Xcode enables build settings that make app launching fast and keep debugging and development build times fast.\n\nIn this context, a debug or development build is unoptimized, where either the clang debug format is -O0 or the swiftc debug format is -Onone. A release build uses optimizations. Xcode represents debug builds with a new build setting, IS_UNOPTIMIZED_BUILD.\n\nIn debug builds, Xcode 15 or later treats mergeable dependencies like normal dynamic libraries, without the overhead of creating mergeable metadata and merging all the libraries. In release builds, Xcode creates the mergeable metadata in your dynamic libraries, and merges dependencies into the target binary.\n\nIn release builds, the binary is slightly larger, but avoids the overhead of loading dynamic links at runtime.\n\nRelated sessions from WWDC23\n\nSession 10268: Meet mergeable libraries\n\nMerge libraries automatically in Xcode\n\nTo automatically merge libraries, first open your project in Xcode 15 or later. Then, add the MERGED_BINARY_TYPE build setting to your app target, and set the value to automatic. With this build setting, Xcode treats mergeable dependencies like normal dynamic libraries in debug builds, but performs steps in release mode to automatically handle merging for direct dependencies. For more information on the MERGED_BINARY_TYPE build setting, see Create Merged Binary.\n\nA direct dependency is a library that meets two criteria:\n\nThe library is listed in your target’s Link Binary with Libraries build phase.\n\nThe library is the product of another target in your project.\n\nAn indirect dependency is any other library dependency that doesn’t meet those two criteria — for example, a pre-built library, or a library’s dependencies.\n\nIn release builds:\n\nXcode builds direct dependencies of the merged binary target as mergeable. This includes framework and dynamic library (dylib) targets.\n\nXcode combines the mergeable libraries into the merged binary.\n\nXcode also combines any mergeable pre-built XCFrameworks listed in your target’s Link Binary with Libraries build phase.\n\nXcode embeds mergeable target products in either the merged binary product or into a product, such as an app, that contains the merged binary product. Xcode does not include the binaries from the libraries in the embedded copy.\n\nNote\n\nXcode does not automatically build indirect dependencies as mergeable in release builds. To configure indirect dependencies for merging, see the Manually configure merging section below.\n\nIn debug builds:\n\nXcode builds direct dependencies of the merged binary target normally, and doesn’t generate the metadata to make them mergeable.\n\nThe merged binary target links dylibs produced by direct dependencies to be reexported.\n\nXcode strips mergeable metadata from any pre-built mergeable XCFrameworks.\n\nXcode embeds those target dependency products in either the merged binary product, or into a product containing the merged binary product. Xcode doesn’t include their binaries in the embedded copy (this is the same as the release build behavior).\n\nXcode also copies the target dependency products into a special location in the merged binary product. This special location contains only the binaries of the target dependency products. The merged binary product has an additional @rpath that points to the special location.\n\nManually configure merging\n\nIn some cases, you may want to manually configure merging between your app or framework target and dependent libraries. For example, you might not want to automatically merge dependencies that you share between an app and an app extension if you’re concerned about the app extension’s binary size. To set up manual merging, configure your app or framework target, then configure your dependent libraries.\n\nIn your app or framework target, add the build setting MERGED_BINARY_TYPE and set it to manual. After you add that setting to your target:\n\nIn release builds, Xcode merges the products of any of its direct dependencies which have MAKE_MERGEABLE enabled using the linker flags -merge_framework, -merge-l, and so on.\n\nIn debug builds, Xcode links any of your target’s direct dependencies which have MERGEABLE_LIBRARY enabled, but not MAKE_MERGEABLE with the linker flags -reexport_framework, -reexport-l, and so on.\n\nXcode uses normal linking for targets that don’t have MERGEABLE_LIBRARY enabled. This is the same linking that Xcode uses for static libraries, or dynamic libraries that aren’t mergeable.\n\nFor each dependent library that you want to use merging, add the build setting MERGEABLE_LIBRARY, and set it to YES. For more information on the MERGEABLE_LIBRARY build setting, see Build Mergeable Library.\n\nReduce dependencies with a group library\n\nTo create a group library that organizes your dependencies in your top level framework or app project:\n\nCreate a new target in your project for your group library.\n\nConfirm that your group library has the build setting MERGED_BINARY_TYPE set to automatic.\n\nAdd mergeable libraries as dependencies for your group library.\n\nAdd your group library as a dependency to your app or framework’s target.\n\nRemove the individual libraries that you added to your group library as dependencies from your app or framework’s target.\n\nCreate a pre-built mergeable library\n\nTo create a mergeable library that you can distribute as a binary package rather than as source:\n\nEnable the Build Mergeable Library build setting on your library target.\n\nCreate an XCFramework from an archive of your library. For more information, see Creating a multiplatform binary framework bundle.\n\nWhen you include your mergeable library in an XCFramework, Xcode adds the key MergeableMetadata to the XCFramework’s Info.plist file to indicate to other projects that your library in the XCFramework is mergeable. You can only use XCFrameworks with mergeable metadata in Xcode 15 and later; in earlier versions, Xcode returns a build error.\n\nTo use your XCFramework that contains mergeable metadata, add it to the Link Binaries build phase of a target that you configured for automatic or manual merging. For more information, see Link against additional frameworks and libraries.\n\nSee Also\nPerformance\nImproving the speed of incremental builds\nTell the Xcode build system about your project’s target-related dependencies, and reduce the compiler workload during each build cycle.\nImproving build efficiency with good coding practices\nShorten compile times by reducing the number of symbols your code exports and by giving the compiler the explicit information it needs."
  },
  {
    "title": "Adding capabilities to your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-capabilities-to-your-app",
    "html": "Overview\n\nA capability grants your app access to an app service that Apple provides, such as CloudKit, Game Center, or In-App Purchase. To use some app services, you must provision your app, adding a capability with Xcode’s project editor that configures the app service correctly for you. Xcode edits the Entitlements and Information Property List files, adds related frameworks, and configures your signing assets.\n\nHowever, some app services — such as Game Center and In-App Purchase — require additional configuration in App Store Connect and your developer account. For example, you need to upload a geographic coverage file using App Store Connect for an app that uses Maps to provide directions for other apps.\n\nThe platform, and whether you’re a member of the Apple Developer Program, may limit the capabilities available to your app. For the supported capabilities, go to the Reference section of Developer Account Help — for example, go to Supported capabilities (iOS) for the capabilities available to iOS apps.\n\nBefore you begin, add your Apple ID account and assign the project to a team so that Xcode can provision your app. For iOS, tvOS, and watchOS apps, run your app on a device to register the device and create a development provisioning profile.\n\nImportant\n\nUse the default automatic signing when you create a project from a template. If you manually sign your app, you need to perform the capability configuration steps yourself.\n\nAdd a capability\n\nYou add capabilities to your app using the Signing & Capabilities pane of the project editor.\n\nIn the Project navigator of the main window, select the project — the root group with the same name as your app — and in the project editor that appears, select the appropriate target and then click the Signing & Capabilities tab.\n\nOptionally, select a build configuration (All, Debug, or Release). For example, if you want to add the capability to the Debug configuration only, select Debug; otherwise, select All.\n\nIn the toolbar, click the Library button (+) to open the Capabilities library. Alternatively, click + Capability to the left of the build configurations, or choose Editor > Add Capability. The Capabilities library displays only the capabilities available to the target platform and your program membership. Select a capability in the list to view its description on the right.\n\nTo add a capability to the app target, double-click the capability in the library or drag the capability from the library to the Signing & Capabilities pane. The capability appears below the Signing section. If there are more configuration steps, the capability expands to show additional controls (see Perform additional configuration steps below). To remove a capability, click the Delete (x) button in the upper-right corner of the capability in the Signing & Capabilities pane.\n\nIf errors appear in the Signing section, read the message, correct the problem, then click Try Again. For example, the bundle ID (CFBundleIdentifier) that appears in the Bundle Identifier field under Signing needs to be unique. The default value for the bundle ID is the organization identifier concatenated with the app name that you enter when creating a project.\n\nPerform additional configuration steps\n\nFor some capabilities, you may need to perform additional configuration steps in Xcode, your developer account, or App Store Connect. For other capabilities, you may need to write some code.\n\nFor more guidance on specific capabilities, see the table below:\n\nCapability\n\n\t\n\nAdditional information\n\n\n\n\nApp Groups\n\n\t\n\nConfiguring App Groups\n\n\n\n\nApp Sandbox\n\n\t\n\nConfiguring the macOS App Sandbox\n\n\n\n\nApple Pay\n\n\t\n\nConfiguring Apple Pay support\n\n\n\n\nAssociated Domains\n\n\t\n\nConfiguring an associated domain\n\n\n\n\nBackground Modes\n\n\t\n\nConfiguring background execution modes\n\n\n\n\nClassKit\n\n\t\n\nEnabling ClassKit in your app\n\n\n\n\nFonts\n\n\t\n\nConfiguring custom fonts\n\n\n\n\nGame Controllers\n\n\t\n\nConfiguring game controllers\n\n\n\n\nGroup Activities\n\n\t\n\nConfiguring Group Activities\n\n\n\n\nHardened Runtime\n\n\t\n\nConfiguring the hardened runtime\n\n\n\n\nHealthKit\n\n\t\n\nConfiguring HealthKit access\n\n\n\n\nHomeKit\n\n\t\n\nConfiguring HomeKit access\n\n\n\n\niCloud\n\n\t\n\nConfiguring iCloud services\n\n\n\n\nIn-App Purchase\n\n\t\n\nConfiguring in-app purchases\n\n\n\n\nKeychain Sharing\n\n\t\n\nConfiguring keychain sharing\n\n\n\n\nMaps\n\n\t\n\nConfiguring Maps support\n\n\n\n\nMedia Device Discovery\n\n\t\n\nConfiguring media device discovery\n\n\n\n\nNetwork Extensions\n\n\t\n\nConfiguring network extensions\n\n\n\n\nOn-Demand Install Capable\n\n\t\n\nCreating an App Clip with Xcode\n\n\n\n\nPush Notifications\n\n\t\n\nRegistering your app with APNs\n\n\n\n\nSign in with Apple\n\n\t\n\nConfiguring Sign in with Apple support\n\n\n\n\nSiri\n\n\t\n\nConfiguring Siri support\n\n\n\n\nWallet\n\n\t\n\nConfiguring Wallet support"
  },
  {
    "title": "Preventing memory-use regressions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/preventing-memory-use-regressions",
    "html": "Overview\n\nXCTest can measure the amount of memory allocated by your app while it executes a test case. To measure memory use, create a performance test in your app’s unit test target, and pass an instance of XCTMemoryMetric to measure(metrics:). Inside the block, call the code from your app that demonstrates the problematic memory use.\n\nclass MemoryTests: XCTestCase {\n    func testMemoryUse() {\n        self.measure(metrics: [XCTMemoryMetric()]) {\n          // Use the relevant app feature here\n        }\n    }\n}\n\n\nWhen you run this test, Xcode measures the peak memory use observed while the block runs, and the growth in memory allocated between the block’s beginning and end. You can observe these values by clicking the icon next to the test results. Click Set Baseline to establish a value for future comparisons. The test fails if the memory use significantly exceeds the baseline measurement.\n\nSee Also\nMemory and size\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nReducing your app’s size\nMeasure your app’s size, optimize its assets and settings, and adopt technologies that help streamline installation over a mobile internet connection.\nGathering information about memory use\nIdentify memory-use inefficiencies by measuring and profiling your app.\nMaking changes to reduce memory use\nDecrease your app’s use of memory by addressing common causes of excessive use.\nResponding to low-memory warnings\nDetect when your app is using excessive memory, and bring memory use under control."
  },
  {
    "title": "Configuring the Xcode project window | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-the-xcode-project-window",
    "html": "Overview\n\nThe Xcode project window is your primary interface for viewing, editing, and managing all parts of your project. You can configure it to fit your work style and adjust it as you work on different tasks.\n\nThe main window opens when you create or open a project. To open additional main windows, choose File > New > Window.\n\nThe areas of the main window are:\n\nThe toolbar for building and running your app, viewing the progress of tasks, and configuring the main window. Use the tabs at the top to organize your open files. You can reorder tabs, close them individually, or drag them out of the tab bar to create new windows.\n\nThe editor area for viewing and editing the contents of your project, including code, user interface files, property lists, project settings, and more.\n\nThe navigator area for viewing the parts of your project, including files, symbols, breakpoints, and build information.\n\nThe debug area for controlling the app execution during debugging, and for displaying variables, register, and status information.\n\nThe inspector area for viewing and editing information about the project or about the selected object in the navigator or editor area.\n\nConfigure the available editors\n\nFiles you select in the Project navigator open in the editor area. The editor that appears depends on the type of file you select. For example, if you select a source file, Xcode displays the source editor.\n\nTo add, remove, and configure editors, use the controls in the jump bar and tab bar, located at the top of the editor area. To change the information you display in the editor area, click the Adjust Editor Options button in the tab bar, and select one of the following:\n\nThe Canvas displays a preview of your SwiftUI interface. Use the Layout menu to configure the canvas’s position.\n\nThe Assistant editor displays information about what you’re editing. For example, the assistant editor for a SwiftUI view displays the canvas view, and the assistant for an Objective-C source file displays the matching header.\n\nThe Minimap view provides a miniaturized version of your source files content, which you use to navigate around the file.\n\nThe Authors view displays the commit history of a file under source control management.\n\nThe Code Coverage view displays statistics about your source code after you run tests. Use it to detect portions of your code not reached by your project’s tests.\n\nWhen showing multiple editors, click the Enable Code Review button in the tab bar to temporarily expand the current editor to fill the editor area. Click it again to collapse the editor to its original size.\n\nShow and hide areas of the main window\n\nShow and hide different parts of the main window to make more space in the editor area. The window has separate controls to hide the navigator area, inspector area, and debug area.\n\nSee Also\nNavigation\nFinding and replacing content in a project\nSearch some or all of your project for text strings or symbol names, and perform advanced searches using regular expressions."
  },
  {
    "title": "Managing multiple projects and their dependencies | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/managing-multiple-projects-and-their-dependencies",
    "html": "Overview\n\nAn Xcode project manages the code and resources associated with your company’s software products. Most projects are organized around a single product, but you can also use one project to manage multiple products. For example, a project might build an app, app extensions, and app-related frameworks. The organization of your projects affects how your teams work on those projects, and can also affect build performance.\n\nAlthough you can use a single project for all of your company’s content, there are advantages to distributing content among multiple projects:\n\nMultiple smaller projects are easier to navigate. With fewer files, fewer targets, and fewer products in the project, it’s easier for you to navigate the project’s content and see what’s there.\n\nMultiple projects make it easier to distribute work. If you have multiple teams, giving each one a separate project makes it easier for them to work independently.\n\nMultiple independent projects can result in faster build times. Separating content into multiple, independent projects forces you to eliminate or minimize dependencies between those projects. When you limit dependencies, Xcode has more flexibility to build projects in parallel, rather than serially.\n\nWhen you separate content into independent projects, there might still be dependencies between them. For example, if an app team and framework team are developing their content in tandem, they each need access to the latest changes from both projects. Workspaces and cross-project references help you manage these dependencies between projects.\n\nManage multiple related projects using a workspace\n\nA workspace is a container for several related projects. Use a workspace to organize multiple projects that have explicit or implicit dependencies. For example, you might use a workspace to organize one or more apps and the shared frameworks they link against.\n\nTo create a workspace and add projects to it:\n\nIn Xcode, choose File > New > Workspace.\n\nSpecify a name for the workspace and save it to the file system.\n\nIn the Project navigator, Control-click in the empty space and choose Add Files to “workspaceName”.\n\nIn the sheet that appears, select an Xcode project (a file with a .xcodeproj filename extension).\n\nClick Add to add the project to the workspace.\n\nNote\n\nYou can also add projects to a workspace by dragging them from the Finder to the Project navigator of your workspace window. Make sure you add each project at the root level of the workspace, not as a subproject of another project.\n\nWhen you add projects to a workspace, Xcode automatically detects dependencies between the targets in those projects and builds them in the correct order. For example, when you build an app that implicitly depends on a framework in a different project, Xcode automatically builds the framework before it builds the app. When you change your project, Xcode automatically updates any dependencies, so you don’t have to change them manually.\n\nRefer explicitly to targets, files, and products in another project\n\nBy default, a project in a workspace can’t refer to targets, files, or products in another project. If you need to refer to items in another project, you must create a cross-project reference:\n\nOpen your Project navigator in your Xcode project.\n\nClick the Add button (+) at the bottom of the Project navigator.\n\nChoose Add Files to “projectName”.\n\nSelect another Xcode project (.xcodeproj filename extension) from the file dialog.\n\nClick Add.\n\nAfter you add a cross-project reference, you can refer to the other project’s targets, files, and products from your original project’s Dependencies, Copy Files, and Link Binary with Library build phases. If Xcode can’t locate the other project at build time, the build system still attempts to build the product but produces missing dependency warnings.\n\nNote\n\nIt’s good practice to use a workspace to manage multiple projects. However, you can’t create explicit dependencies between two projects in the same workspace.\n\nSee Also\nFiles and workspaces\nManaging files and folders in your Xcode project\nAdd new or existing files to your project, and use groups to organize the files and folders in the Project navigator."
  },
  {
    "title": "Diagnosing issues using crash reports and device logs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/diagnosing-issues-using-crash-reports-and-device-logs",
    "html": "Overview\n\nCustomers expect apps to be stable, free of bugs, and use system resources efficiently. The operating system helps you meet these expectations by collecting different log types you can use to diagnose issues in your app:\n\nCrash reports describe how your app terminated, and document the code running on each thread at the time of the crash.\n\nJetsam event reports describe the system-memory conditions under which the operating system terminated an app.\n\nDevice console logs contain detailed information on operations that occur in both the operating system and apps.\n\nDistribution builds of your app, such as for the App Store, an enterprise environment, or a testing team, require you to use crash reports and device logs to diagnose issues encountered by your customers. Distribution builds don’t contain the necessary entitlements for debugging in Xcode.\n\nAddress stability issues using crash reports\n\nCrash reports are the most common type of log you’ll use when diagnosing an issue. When receiving crash reports for your app, use them to understand the stability problems the app is having. A crash report describes how your app terminated, and also contains the complete backtrace of each thread, which shows the code running at the time of the crash.\n\nTo debug a problem using a crash report:\n\nBuild your app with symbol information and retain the Xcode archive before distributing the app.\n\nRetrieve a crash report for an issue. See Acquiring crash reports and diagnostic logs for the different ways you can retrieve crash reports.\n\nConvert the hexadecimal addresses into symbol names for your app, as described in Adding identifiable symbol names to a crash report.\n\nDetermine if the crash fits any of the patterns in Identifying the cause of common crashes. Consult Analyzing a crash report and Examining the fields in a crash report for additional insight on the issue.\n\nUpdate your code to fix the issue.\n\nAdd tests with the XCTest framework to ensure the issue doesn’t reoccur in the future.\n\nUncover memory inefficiencies using jetsam event reports\n\nEnsure that your apps use memory efficiently. When an app on iOS, iPadOS, watchOS, or tvOS uses memory inefficiently, less memory is available for other apps to remain in memory in the background. This lower available memory limits how quickly a user can switch between apps, because apps can’t resume from memory and must first complete a full app launch.\n\nWhen the operating system experiences low-memory conditions, and requires more memory than is currently free, the device’s operating system can terminate apps to reclaim the memory they’re using. A jetsam event report describes the system-memory conditions under which the operating system terminated an app. See Locate crash reports and memory logs on the device for how to access these logs and Identifying high-memory use with jetsam event reports for information on intrepreting a jetsam event report.\n\nJetsam event reports don’t contain stack traces of executing threads in an app, but they do contain additional system information about memory use. When your app crashes due to memory pressure, see Gathering information about memory use to understand your app’s memory use patterns, and Responding to low-memory warnings to learn when to lower your memory use.\n\nDiagnose problems using device console logs\n\nApple devices maintain a continuous in-memory transcript of operations in the operating system and individual apps. These logs can be reviewed after an issue occurs. Some issues, such as problems installing an app, can be diagnosed by reviewing the operating system logs using the Console app on macOS. See Access device console logs for instructions on accessing a device’s console log.\n\nAdd log messages for your app to the operating system’s log with the Logging framework. The logs you provide can contain additional grouping and labeling information to assist with tracing an issue from the original user action. This information is useful for diagnosing complex interactions, such as debugging the interaction between your app and one of its app extensions.\n\nImportant\n\nDon’t include privacy-sensitive information in your logs.\n\nTopics\nEssentials\nAcquiring crash reports and diagnostic logs\nGather crash reports and device logs from the App Store, TestFlight, and directly from devices.\nCrash reports\nAdding identifiable symbol names to a crash report\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\nIdentifying the cause of common crashes\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\nAnalyzing a crash report\nIdentify clues in a crash report that help you diagnose problems.\nExamining the fields in a crash report\nUnderstand the structure of a crash report and the information each field contains.\nInterpreting the JSON format of a crash report\nUnderstand the structure and properties of the objects the system includes in the JSON of a crash report.\nUnderstanding the exception types in a crash report\nLearn what the exception type tells you about why your app crashed.\nDevice logs\nIdentifying high-memory use with jetsam event reports\nDiscover why the operating system terminated your app when available memory was low.\nLogging\nCapture telemetry from your app for debugging and performance analysis using the unified logging system.\nSee Also\nReports\nBuilding your app to include debugging information\nConfigure Xcode to produce the symbol information for debugging and crash reports."
  },
  {
    "title": "Preparing dates, currencies, and numbers for translation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/preparing-dates-numbers-with-formatters",
    "html": "Overview\n\nLanguages and regions have different formats for presenting dates and numbers. Some languages use the period (.) as a decimal separator, and others use the comma (,). Some place the percent sign before the number when formatting percentages. And many regions display time and date differently, despite being part of the same language.\n\nInstead of trying to account for all these variations yourself, use the formatters built into Foundation to create localizable versions of the dates and numbers you want to present.\n\nFormat dates with predefined styles\n\nTo convert a date or number into a localizable string, use the Foundation formatters and styles. These APIs take instances of your date and number objects, and convert them into localizable formatted strings according to the locale of the device your app is running on.\n\nFor example, to create a localizable string from a date object, create an instance of the Date you want to format and then call the formatted() function on the date.\n\n// The current time and date. Example output is for en_US locale.en_US locale.\nlet date = Date.now\n\n\n// A default, formatted, localizable date string.\nlet defaultFormatted = date.formatted()\n// \"8/25/2023, 12:03 PM\"\n\n\nTo vary the date components that display, or display only the time or the date, use the formatted(date:time:) method on the Date object passing in instances of Date.FormatStyle.DateStyle and Date.FormatStyle.TimeStyle.\n\n// The date you want to format.\nlet meetingDate = Date.now\n\n\n// A formatted date displaying only the date.\nlet formattedDate = meetingDate.formatted(date: .abbreviated, time: .omitted)\n// \"Aug 25, 2023\"\n\n\n// A formatted date displaying only the time.\nlet formattedTime = meetingDate.formatted(date: .omitted, time: .standard)\n// \"12:03:10 PM\"\n\n\n// A formatted date displaying both the date and time.\nlet formattedDateAndTime = meetingDate.formatted(date: .complete, time: .complete)\n// \"Friday, August 25, 2023 at 12:03:10 PM PDT\"\n\nCreate your own custom date styles\n\nTo format a date to a specific style, create your own custom date style including only the date properties you want to display.\n\nFor example, to create a date that includes only the month, day, and year:\n\nCreate an instance of the Date object you want to format.\n\nCreate a Date.FormatStyle structure or use the dateTime factory variable, and chain together the properties you want to display in successive function calls.\n\nThen pass that Date.FormatStyle structure as an input into the the formatted(_:) function on the date object.\n\n// A date string with specific attributes.\nlet myDate = Date.now\nlet formatStyle = Date.FormatStyle.dateTime.year().day().month()\nlet formatted = date.formatted(formatStyle)\n// \"Sep 7, 2023\"\n\n\nYou can also achieve the same result in one line.\n\n// Same result in one line using the `dateTime` factory variable.\nlet formatted = Date.now.formatted(.dateTime.year().day().month())\n// \"Sep 7, 2023\"\n\n\nThe order of the fields you pass into the formatted(_:) function doesn’t matter. For example, these lines of code produce the same result.\n\n// Same result.\nDate.now.formatted(.dateTime.year().month().day().hour().minute().second())\nDate.now.formatted(.dateTime.second().minute().hour().day().month().year())\n// \"Sep 7, 2023 at 10:29:52 AM\"\n\n\nCustomize the date styles you want to display by chaining together instances of Date.FormatStyle.Symbol structures along with their respective formatting properties.\n\n// A date string for a wide month format.\nlet formattedWide = date.formatted(.dateTime.year().day().month(.wide))\n// \"September 7, 2023\"\n\n\n// A date string for a wide weekday.\nlet formattedWeekday = date.formatted(.dateTime.weekday(.wide))\n// \"Thursday\"\n\n\n// A date string for the ISO 8601 time and date standard.\nlet logFormat = date.formatted(.iso8601)\n// \"2023-09-07T17:25:39Z\"\n\n\n// A date string representing a file format.\nlet fileNameFormat = date.formatted(.iso8601.year().month().day().dateSeparator(.dash))\n// \"2023-09-07\"\n\nFormat percents and scientific numbers\n\nIf you want to create a localizable string for a number (such as Int, Double, Decimal, or Float), call formatted() or formatted(_:) on the number instance, along with the format style to display.\n\nFor example, to create a formatted version of an Int, call the formatted() function on the number.\n\nlet value = 12345\n// A default, formatted, localizable date string.\nvar formatted = value.formatted()\n// \"12,345\"\n\n\nTo format the number as a percent, call formatted(_ format:) on the number you want to display with the NumberFormatter.Style.percent number format style. Integers convert directly into percentages using the whole number.\n\nlet number = 25\nlet numberFormatted = number.formatted(.percent)\n// \"25%\"\n\n\nFractions convert between the range of 0 and 1.\n\nlet fraction = 0.25\nlet fractionFormatted = fraction.formatted(.percent)\n// \"25%\"\n\n\nTo display a number using scientific notation, call formatted(_:) on the number to display using the scientific, notation(_:), and number format styles.\n\nlet scientific = 42e9\nlet scientificFormatted = scientific.formatted(.number.notation(.scientific))\n// \"4.2E10\"\n\nFormat currencies\n\nTo present a number as a localizable currency:\n\nLook up the code of the currency you want to display (such as \"CAD\" for Canada).\n\nPass that code as a parameter to the Decimal.FormatStyle.Currency format style initializer init(code:locale:).\n\nThen call formatted(_:) on the number passing in the currency format instance.\n\n// A number formatted in different currencies.\nlet amount: Decimal = 12345.67\namount.formatted(.currency(code: \"JPY\"))\n// \"¥12,346\"\namount.formatted(.currency(code: \"EUR\").presentation(.fullName))\n// \"12,345.67 euros\"\namount.formatted(.currency(code: \"USD\").grouping(.automatic))\n// \"$12,345.67\"\n\n\nNote\n\nTo ensure accuracy, don’t use Float or Double to represent currency in your app. Use Decimal instead.\n\nFormat times as intervals or durations\n\nTo display an interval of time as a localizable string:\n\nCreate two instances of the Date object — one representing the start of the time interval and the other the end.\n\nUsing these two dates, create a Range structure setting the upper and lower bounds of the interval.\n\nThen call one of the range formatters — such as formatted() or formatted(date:time:) — passing in the time and date styles you want to display.\n\n// An example of a time interval.\n\n\n// The current time and date. Example output is for en_US locale.\nlet now = Date.now\n\n\n// 5000 seconds from now.\nlet later = now + TimeInterval(5000)\n\n\n// The default formatted display for a time interval.\nlet range = (now..<later).formatted()\n// \"9/8/2023, 10:44 AM – 12:07 PM\"\n\n\n// A time interval formatted using a predefined date format.\nlet noDate = (now..<later).formatted(date: .omitted, time: .complete)\n// \"10:44:39 AM PDT – 12:07:59 PM PDT\"\n\n\nTo display time as a duration, you can similarly define a date range and convert that range into a duration.\n\n// An example of a duration.\n\n\n// Duration from a range of dates.\nlet timeDuration = (now..<later).formatted(.timeDuration)\n// \"1:23:20\"\n\n\nlet components = (now..<later).formatted(.components(style: .wide))\n// \"1 hour, 23 minutes, 20 seconds\"\n\n\nlet relative = later.formatted(.relative(presentation: .named, unitsStyle: .wide))\n// \"in 1 hour\"\n\n\nYou can also use factory methods like seconds(_:) on the Duration structure to produce localizable durations from a single number.\n\nFor example, to display a given number of seconds as a duration of time:\n\nPass in the number of seconds you want to display to the seconds(_:) function of the Duration structure.\n\nThen call formatted(_:), passing in instances of Duration.TimeFormatStyle or Duration.UnitsFormatStyle to achieve the format and style you want.\n\n// Duration formatted from a single unit of time.\nDuration.seconds(2000).formatted(.time(pattern: .hourMinute)) \n// \"0:33\"\nDuration.seconds(2000).formatted(.time(pattern: .hourMinuteSecond)) \n// \"0:33:20\"\nDuration.seconds(2000).formatted(.time(pattern: .minuteSecond)) \n// \"33:20\"\n\nFormat items as lists\n\nTo create a localizable string in the form of a list, use the ListFormatStyle structure along with either the formatted() or formatted(_:) function to create a string representation of a Sequence of items.\n\n// An array of strings formatted into a list.\nlet sizes = [\"small\", \"medium\", \"large\"]\nsizes.formatted(.list(type: .and, width: .narrow))\n// \"small, medium, large\"\nsizes.formatted(.list(type: .and, width: .standard))\n// \"small, medium, and large\"\nsizes.formatted(.list(type: .and, width: .short))\n// \"small, medium, & large\"\n\n\nYou can also create lists using different formatting styles by calling the list(memberStyle:type:width:) function along with specific list format styles.\n\n// A list of numbers formatted as percentages.\n[25, 50, 75].formatted(.list(memberStyle: .percent, type: .or))\n// \"25%, 50%, or 75%\"\n\nConvert and display measurement units across different locales\n\nUnits of measure vary significantly depending on the locale the format style uses. For example, a distance in feet for the en_US locale appears as meters using the French locale fr_FR.\n\nTo ensure your units of measure convert and display properly across different languages and regions:\n\nUse the Measurement structure to define a variable representing the unit of measure you want to display.\n\nThen call formatted(_:) or formatted(_:) on the variable to get the display style you want.\n\nFor example, say you want to convert and display the following measurements.\n\n// Measurements to display.\nlet speedLimit = Measurement(value: 110, unit: UnitSpeed.kilometersPerHour)\nlet distanceToMoon = Measurement(value: 384400, unit: UnitLength.kilometers)\nlet surfBoardLength = Measurement(value: 8, unit: UnitLength.feet)\nlet waterTemperature = Measurement(value: 61.2, unit: UnitTemperature.fahrenheit)\n\n\nTo convert them using the default format, call formatted(_:) on the measurement object.\n\n// Example output is for en_US locale.\n\n\n// Default display for a unit of measure.\nspeedLimit.formatted()\n// \"68 mph\"\ndistanceToMoon.formatted()\n// \"238,855 mi\"\nsurfBoardLength.formatted()\n// \"8 ft\"\nwaterTemperature.formatted()\n// \"61.2°F\"\n\n\nTo customize the output, call the formatted(_:) function on the measurement using the measurement(width:usage:numberFormatStyle:) factory method to create the format and style you want.\n\n// Custom display options for a unit of measure.\ndistanceToMoon.formatted(.measurement(width: .wide))\n// \"238,855 miles\"\ndistanceToMoon.formatted(.measurement(width: .abbreviated))\n// \"238,855 mi\"\ndistanceToMoon.formatted(.measurement(width: .narrow))\n// \"238,855mi\"\n\nFormat dates and numbers in SwiftUI\n\nTo format dates and numbers in SwiftUI, use the format initializers on SwiftUI view controls to customize how those strings display.\n\nFor example, here is a SwiftUI view that displays three different localizable formats of Date using the init(_:format:) initializer from the Text view.\n\n@State private var myDate = Date.now\n\n\nvar body: some View {\n    VStack {\n        Text(myDate, format: Date.FormatStyle(date: .numeric, time: .omitted))\n        Text(myDate, format: Date.FormatStyle(date: .complete, time: .complete))\n        Text(myDate, format: Date.FormatStyle().hour(.defaultDigits(amPM: .omitted)).minute())\n    }\n}\n\n\nThis example uses the init(_:value:format:prompt:) initializer of the TextField view to present a number as a percentage for a tip.\n\n@State private var tip = 0.15\n\n\nvar body: some View {\n    HStack {\n        Text(\"Tip\")\n        Spacer()\n        TextField(\"Amount\", value: $tip, format: .percent)\n    }\n}\n\nTest the formatters\n\nTo test and see how your formatters display in different languages and regions, create an instance of a Locale object, passing in the identifier of the region you want to test. Then set that locale on the output of your formatted string to see how that string displays in that language and region.\n\nFor example, you can see how your localizable strings display in French as follows.\n\n// The locale for France French.\nlet frenchLocale = Locale(identifier: \"fr_FR\")\n                        \nlet stages = [\"50\", \"75\", \"100\"]\nstages.formatted(.list(type: .and).locale(frenchLocale))\n// \"50, 75 et 100\"\nstages.formatted(.list(type: .or).locale(frenchLocale))\n// \"50, 75 ou 100\"\n\n\nTo test your formatters in SwiftUI, set the locale in the environment variable in the #Preview section of your code.\n\nstruct ContentView: View {\n    @State private var myDate = Date.now\n    @Environment(\\.locale) var locale\n\n\n    var body: some View {\n        VStack {\n            Text(myDate, format: .dateTime.second().minute().hour().day().month().year().locale(locale))\n        }\n    }\n}\n\n\n#Preview {\n    Group {\n        ContentView()\n            .environment(\\.locale, Locale(identifier: \"fr_FR\"))\n        ContentView()\n            .environment(\\.locale, Locale(identifier: \"pt_BR\"))\n    }\n}\n\nSee Also\nStrings and text\nPreparing your interface for localization\nFind text in your app that needs translation and verify that your interface adapts to translated text.\nPreparing your app’s text for translation\nMake your app’s text translatable by leveraging the localization APIs in the Foundation framework."
  },
  {
    "title": "Creating screenshots of your app for localizers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-screenshots-of-your-app-for-localizers",
    "html": "Overview\n\nWhen running UI tests of your localizations, you can generate screenshots to include in the exported localization folders that you give to localizers. The screenshots provide context for the localizable strings and resources in the interface. You can generate screenshots from your project’s test plans or Test scheme.\n\nTo include the screenshots in the Xcode Localization Catalog (a folder with a .xcloc file extension), see Exporting localizations.\n\nCreate a test plan\n\nIf you add many localizations to your project, test plans are ideal for generating screenshots because you can create a configuration for each. A test plan (a file with a .xctestplan file extension) specifies which tests to run and how to run them one or more times.\n\nYou can use an existing test plan or create a new one. To add a test plan, choose Product > Test Plan > New Test Plan in Xcode. Enter a name for the test plan and click Create.\n\nIf you want to convert your project from using schemes to test plans, choose Product > Scheme > Convert Scheme to use Test Plans, select “Create Test Plan from scheme”, then click Convert. In the next dialog, you can change the name of the test plan, then click Save. The test plan appears in the editor area.\n\nAdd localization configurations\n\nAdd a configuration for each localization to your test plan. In the Project navigator, select the test plan, then click Configurations. On the left, click the Add button (+) at the bottom. Select the new configuration that appears and enter a name for the localization.\n\nEdit the configuration file for the localization test. Under Localization, set the Application Language and Application Region settings to the corresponding language and region for the localization. Under UI Testing, switch Localization Screenshots from Off to On.\n\nRun tests to generate screenshots\n\nNext time you run your tests (choose Product > Test), Xcode saves the screenshots for each localization to disk. In the Test navigator, next to every screenshot, Xcode includes a property list (Localizable Strings Info) that maps the strings to the frame where the string appears in the screenshot. The property list includes the string IDs (that appear in the exported XLIFF file) and frame locations.\n\nGenerate screenshots using schemes\n\nAlternatively, if you don’t use test plans, you can make similar edits to the Test scheme to generate screenshots. In Xcode, choose Product > Scheme > Edit Scheme, click the Test scheme, then click Options. Choose the language and region from the pop-up menus, then select “Gather screenshots for localization.”\n\nSee Also\nTranslation and adaptation\nExporting localizations\nProvide the localizable files from your project to localizers.\nEditing XLIFF and string catalog files\nTranslate or adapt the localizable files for a language and region that you export from your project.\nImporting localizations\nImport the files that you translate or adapt for a language and region into your project.\nLocking views in storyboard and XIB files\nPrevent changes to your Interface Builder files while localizing human-facing strings."
  },
  {
    "title": "Adding resources to localizations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-resources-to-localizations",
    "html": "Overview\n\nAs you add more resources to your project, you can also add them to your localizations. Perform this step before you export localizations so that placeholder resources appear in the localization export folders.\n\nMake resources localizable\n\nIn the Project navigator, select the resource. Then in the inspector, under Localization, click Localize. In the dialog that appears, choose the localizations to add to the resource from the pop-up menu, and click Localize.\n\nIn the inspector, under Localization, you can also select or deselect localizations for the resource. If you select multiple localizations, the resource becomes a group in the Project navigator localization-specific versions of the file.\n\nNote\n\nIf you add a Settings Bundle or WatchKit Settings Bundle file to your project, it’s automatically localizable.\n\nSee Also\nResources and assets\nLocalizing assets in a catalog\nUse asset catalogs to localize colors, images, symbols, watch complications, and more."
  },
  {
    "title": "Preparing your app’s text for translation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/preparing-your-apps-text-for-translation",
    "html": "Overview\n\nBefore the system can translate your app’s text, you need to prepare your app’s strings for translation by creating localizable versions of these strings using the String(localized:) and AttributedString(localized:) APIs found in the Foundation framework.\n\nLocalizable strings are user-facing strings you present to people at runtime. These strings signal to the system that they should be considered for translation, and thus added to your string catalog file. You then export those strings from your string catalog and send them to a localizer for translation or you edit the string catalog yourself and enter the translations directly there.\n\nMake your string literals localizable\n\nString literals — strings created only with double quotes — aren’t localizable by themselves.\n\n// An example of a nonlocalizable string literal.\nlet name = \"Lightbulbs\"\n\n\nThere’s no way for the system to know whether the string literal is a user-facing string in need of translation or simply a print statement there for debugging.\n\nTo make a string localizable, create a String object using the init(localized:) initializer.\n\n// Localizable string with the same key and value.\nString(localized: \"Lightbulbs\")\n\n\nThis initializer takes the string literal passed in as a LocalizedStringResource and assigns it to a key equal to the value of the string literal itself. Your string catalog uses this key to look up translations based on the language and locale of the user’s device, and then returns the translated value associated with that key. With this initializer, the key and underlying string value are the same. This means you can use the text of your development language as the keys for your translations.\n\nTo create localizable strings with different keys and values, use the init(localized:defaultValue:options:table:bundle:locale:comment:) initializer. This initializer assigns the first string literal as the string’s key and makes the second parameter the default string value.\n\n// Localizable string with a different key and value.\nString(localized: \"LIGHTING_KEY\", defaultValue: \"Lightbulbs\")\n\n\nIf someone else translates your strings, consider adding helpful comments to your string initializers to provide additional context about how and when the string displays.\n\n// Localizable string with a comment providing additional context.\nString(localized: \"Lightbulbs\", comment: \"Label: The icon name displayed on the control screen\")\n\n\nIf the number of translations in your string catalog grows too large, consider breaking the default catalog up into several smaller catalogs. Then specify which catalog a translation comes from using the table parameter in the init(localized:defaultValue:options:table:bundle:locale:comment:) initializer.\n\n// Localizable string referenced from the Greetings.xcstrings string catalog file.\nString(localized: \"Welcome\", table: \"Greetings\")\n\n\nUse String(localized:) and AttributedString(localized:) initializers to initialize UIKit and AppKit controls as well as general Swift structures containing variables of type String.\n\nstruct Accessory {\n     // Nonlocalizable string literal.\n     let name: String\n}\n// Made localizable using the String(localized:) initializer.\nAccessory(name: String(localized: \"Welcome\"))\n\n\n// Localizable string passed into a UIKit control.\nlet label = UILabel()\nlabel.text = String(localized: \"Welcome\")\n\n\n// Localizable string passed into a AppKit UI control.\nlet textField = NSTextField()\ntextField.stringValue = String(localized: \"Welcome\")\n\nLocalize text automatically in SwiftUI\n\nSwiftUI views that accept string literals of type LocalizedStringKey are automatically considered localizable. For example, the following strings are all automatically considered localizable in SwiftUI:\n\n// Text made localizable with LocalizedStringKey.\n\n\nLabel(\"Thanks for shopping with us!\", systemImage: \"bag\")\n    .font(.title)\nHStack {\n    Button(\"Clear Cart\") {}\n    Button(\"Checkout\") {}\n}\n\n\nTo help translators better understand the context for a localized string, use the init(_:tableName:bundle:comment:) initializer of your Text view and provide a comment with additional details.\n\n// Provide additional localizable data with a `TextView`.\n\n\nStepper {\n    Text(\"Increase or decrease the item quantity\", comment: \"Lets the shopper increase or decrease the quantity for an item in their shopping cart\")\n} onIncrement: {\n    // ...\n} onDecrement: {\n    // ...\n}\n\nPass localizable strings with a localizable type\n\nWhen defining or passing localizable text in your views, use the recommended type for passing strings in Swift LocalizedStringResource.\n\n// Localizable strings in SwiftUI.\n\n\nstruct CardView: View {\n    let title: LocalizedStringResource\n    let subtitle: LocalizedStringResource\n    \n    var body: some View {\n        ZStack {\n            Rectangle()\n            VStack {\n                Text(title)\n                Text(subtitle)\n            }\n            .padding()\n        }\n    }\n}\n\n\nCardView(title: \"Recent Purchases\", subtitle: \"Items you've ordered in the past week\")\n\n\nThis type not only supports initialization using string literals, it also supports adding a comment, table name, or default value that’s different from the string key.\n\nLocalizedStringResource also works for strings defined in general Swift code. For example, here’s a structure that defines a title of type LocalizedStringResource, which is then instantiated using a string literal and an instance of LocalizedStringResource, both localizable.\n\nstruct UserAction {\n   let title: LocalizedStringResource\n}\n\n\n// Localizable text created with a string literal.\nlet action = UserAction(title: \"Order items\")\n\n\n// Localizable text created with a `LocalizedStringResource`.\nlet actionWithComment = UserAction(title: LocalizedStringResource(\"Order items\", comment: \"Action title displayed in button\"))\n\nDefine and load localizable strings from within your framework\n\nIf you define the strings that you want to localize in another module, framework, or Swift Package, use the bundle argument in their definition. For example, say you want to modularize your project and you create a framework called BirdFinderUtilities. To look up a localizable string from within that framework:\n\nIdentify the name of a class within the framework (in this case, BirdSongs).\n\nPass that class into an instance of Bundle using the init(for:) initializer.\n\nUse that Bundle to look up the localizable string.\n\n// Localizable string within a framework.\nString(localized: \"Songs\", bundle: Bundle(for: (BirdSongs.self)))\n\n\n// Localizable string within a framework in SwiftUI.\nText(\"Songs\", bundle: Bundle(for: (BirdSongs.self)))\n\n\n// Localizable string within a framework for a `LocalizedStringResource`.\nLocalizedStringResource(\"Songs\", bundle: .forClass(BirdSongs.self), comment: \"Headline above the name of the song currently playing.\")\n\n\nImportant\n\nAvoid looking up strings from bundles you don’t own. Doing so may prevent automatic string extraction from properly working in the string catalog.\n\nSee Also\nStrings and text\nPreparing your interface for localization\nFind text in your app that needs translation and verify that your interface adapts to translated text.\nPreparing dates, currencies, and numbers for translation\nEnsure that dates, currencies, and numbers display correctly across multiple languages and locales by using formatters."
  },
  {
    "title": "Adding support for languages and regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-support-for-languages-and-regions",
    "html": "Overview\n\nAdd the language and region combinations you want to support to your project. For each localization, select the resources, such as image and audio files, that you want to localize.\n\nAdd localizations\n\nIn the project editor, select the project name under Project, and click Info. Under Localizations, click the Add button (+), then choose a language and region combination from the pop-up menu.\n\nThe pop-up menu contains the language name followed by the language ID in parentheses — for example, German (de), Japanese (ja), and Arabic (ar). For regional variants and scripts, the region appears in parentheses followed by the language ID in parentheses— for example, English (India) (en-IN) where en-IN is the language ID. The Other submenu (at the bottom of the menu) contains additional languages and regions to choose from. For guidance, see Choosing localization regions and scripts.\n\nIf you have localizable resources in the project, select the resource files that you want to localize in the sheet that appears, and click Finish. For example, select images, audio, strings, and .stringsdict files that you add to your project.\n\nFor storyboard and XIB interfaces, select the user interface files (files with a .storyboard or .xib filename extension). Xcode adds a strings file to the localization folder that contains the text to translate, as well as comments that describe the user interface components. For example, if you add German to an iOS app that uses storyboards, LaunchScreen.storyboard becomes a group containing a LaunchScreen.storyboard (Base) and LaunchScreen.strings (German) file.\n\nNote\n\nXcode adds the Base and the development language to the localization table by default. Use the Base localization for resources that support string substitution at runtime, such as storyboard, XIB, and Siri intent definition files.\n\nView localizable resources\n\nYou can verify the resources for each localization in the Project navigator and Finder.\n\nThe first time you add a localization, Xcode changes every resource that you want to localize into a group containing the original file and a localization-specific version. The next time you add a localization, Xcode adds another localization-specific file to the group.\n\nIn the file system, Xcode creates a separate localization folder to store the localization-specific resources. The name of the folder is the language ID followed by the .lproj file extension — for example, de.lproj if you choose German (de) from the localization menu.\n\nSee Also\nLanguages and regions\nChoosing localization regions and scripts\nAdd a language-only localization or localizations specific to regional variants and scripts."
  },
  {
    "title": "Preparing your interface for localization | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/preparing-your-interface-for-localization",
    "html": "Overview\n\nBefore you localize your app, use Xcode to identify nonlocalized strings in your interface and to verify whether your interface adjusts to the characteristics of localized strings.\n\nFind nonlocalized strings\n\nNonlocalized strings are text that appears in your interface that Xcode won’t include in exported files. To find nonlocalized strings in your app, choose Product > Scheme > Edit Scheme in Xcode. In the sheet that appears, select the Run scheme action in the left column, and click Options on the right. Then select “Show non-localized strings” under Localization Debugging and click Close.\n\nWhen you run your app, the nonlocalized strings appear in all caps.\n\nRun your app using pseudolanguages\n\nYou can test your interface with samples of text that exhibit the characteristics of different types of languages. In Xcode, choose Product > Scheme > Edit Scheme. In the sheet that appears, select the Run scheme action in the left column, and click Options on the right. Choose one of the pseudolanguages at the bottom of the App Language pop-up menu and click Close in the sheet.\n\nPseudolanguage\n\n\t\n\nDescription\n\n\n\n\nDouble-Length Pseudolanguage\n\n\t\n\nDoubles the length of localizable strings to test whether views adjust their size and position.\n\n\n\n\nRight-to-Left Pseudolanguage\n\n\t\n\nSimulates a right-to-left writing direction to test whether views flip accordingly.\n\n\n\n\nEmotional Pseudolanguage\n\n\t\n\nSimulates emojis in a string.\n\n\n\n\nAccented Pseudolanguage\n\n\t\n\nAdds accents to localizable strings to test whether views adjust to languages that have high and low ascenders.\n\n\n\n\nBounded String Pseudolanguage\n\n\t\n\nWraps strings to identify places where localized strings may appear truncated.\n\n\n\n\nRight-to-Left Pseudolanguage With Right-to-Left Strings\n\n\t\n\nSimulates a right-to-left writing direction, using right-to-left strings.\n\nSee Also\nStrings and text\nPreparing your app’s text for translation\nMake your app’s text translatable by leveraging the localization APIs in the Foundation framework.\nPreparing dates, currencies, and numbers for translation\nEnsure that dates, currencies, and numbers display correctly across multiple languages and locales by using formatters."
  },
  {
    "title": "Localization-Friendly Layouts in macOS | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/localization-friendly_layouts_in_macos",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC 2020 session 10219: Build localization-friendly layouts using Xcode.\n\nSee Also\nContainer Views\nGrid View\nArrange views in a flexible grid, and handle the layout associated with those views.\nclass NSSplitView\nA view that arranges two or more views in a linear stack running horizontally or vertically.\nOrganize Your User Interface with a Stack View\nGroup individual views in your app’s user interface into a scrollable stack view.\nclass NSStackView\nA view that arranges an array of views horizontally or vertically and updates their placement and sizing when the window size changes.\nclass NSTabView\nA multipage interface that displays one page at a time.\nScroll View\nProvide an interface for navigating content that is too large to fit in the available space."
  },
  {
    "title": "Importing localizations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/importing-localizations",
    "html": "Overview\n\nAfter you localize the contents of a catalog, import the localizations back into your project. When you import localizations, Xcode updates the strings files in your project from the localized versions in the XLIFF file in the catalog.\n\nImport localizations using Xcode\n\nIn the Project navigator, select the project, then choose Product > Import Localizations. In the import dialog that appears, select the Xcode Localization Catalog folder, and click Import. Xcode ingests the files and warns you if there are untranslated files.\n\nIn the sheet that appears, review the warnings and errors. In the left column, click the Issues View button in the toolbar, then select a message that appears below. In the comparison editor on the right, the imported catalog version of the file appears on the left and the current project file appears on the right.\n\nTo review all the changes, click the File View button in the toolbar, and select a file in the navigator below. When you’re ready to import the files, click Import. Xcode updates the strings and .stringsdict files from the localized versions in the catalog. Xcode also updates any localizable resources and assets in an asset catalog.\n\nImport localizations using commands\n\nYou can also import the catalog with the xcodebuild command using the -importLocalizations argument:\n\nxcodebuild -importLocalizations -project <projectname> -localizationPath <dirpath>\n\nBe sure to test your app for the languages and regions in your project.\n\nSee Also\nTranslation and adaptation\nCreating screenshots of your app for localizers\nShare screenshots of your app with localizers to provide context for translation.\nExporting localizations\nProvide the localizable files from your project to localizers.\nEditing XLIFF and string catalog files\nTranslate or adapt the localizable files for a language and region that you export from your project.\nLocking views in storyboard and XIB files\nPrevent changes to your Interface Builder files while localizing human-facing strings."
  },
  {
    "title": "Autosizing Views for Localization in iOS | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/autosizing_views_for_localization_in_ios",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC20 session 10219: Build Localization-Friendly Layouts Using Xcode.\n\nSee Also\nContainer views\nCollection views\nDisplay nested views using a configurable and highly customizable layout.\nTable views\nDisplay data in a single column of customizable rows.\nclass UIStackView\nA streamlined interface for laying out a collection of views in either a column or a row.\nclass UIScrollView\nA view that allows the scrolling and zooming of its contained views."
  },
  {
    "title": "Adding images to your Xcode project | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-images-to-your-xcode-project",
    "html": "Overview\n\nXcode projects often contain many images, and need to manage multiple variations of each image to create a great visual experience for all the devices and platforms on which your app runs. For example, your app might display a different version of an image depending on the device screen size, resolution, language, appearance, gamut, and many other factors. If your app uses images, you can use asset catalogs to simplify managing those images through image sets.\n\nCreate a new image set\n\nAn image set represents one image that you intend to load at runtime. Each image set contains multiple variations of a single image that you customize to support different device characteristics. If you have multiple images in your app, you need to create an image set for each image.\n\nTo create an image set, generate an image asset outside of Xcode, then import it into an asset catalog. The system converts the image format into the most appropriate representation when you build the project.\n\nIn the Project navigator, select an asset catalog: a file with a .xcassets file extension.\n\nDrag an image from the Finder to the outline view. A new image set appears in the outline view, and the image asset appears in a well in the detail area.\n\nDouble-click the image set name in the outline view to rename the image set with a descriptive name, and press the Return key.\n\nSelect supported appearances and variations for images\n\nBy default, Xcode creates each image set with wells for @1x, @2x, and @3x resolutions. If the filename of the image you import ends in @2x or @3x, Xcode automatically places the image into the well with the corresponding resolution. Supply high-resolution images for all images in your app, for all devices your app supports.\n\nIn addition to resolution, your image assets might vary based on other device characteristics. Use the Attributes inspector to add, remove, and edit the image variations to include in your image set. You can accomplish this task in an asset catalog or in Interface Builder.\n\nIn the Project navigator, select the asset catalog.\n\nIn the outline view, select the image set.\n\nIn the inspector area, select the Attributes inspector.\n\nIn the Attributes inspector, add, remove, and edit the device characteristic settings to show additional image wells for the variations you want to customize.\n\nFor more information about image size and resolution, see Image Size and Resolution in the Human Interface Guidelines.\n\nDrag images to the variant wells\n\nAfter you select the desired characteristic settings for your image set, provide image variations by dragging additional images into the corresponding wells in the image set.\n\nIn the Project navigator, select the asset catalog.\n\nIn the outline view, select the image set.\n\nIn the Finder, drag other variations of the image to the wells in the detail area that match their resolutions or other characteristics.\n\nLoad the image asset from your code\n\nTo use the image from code, initialize an image with the name of the image set. Don’t include the file extension.\n\n// SwiftUI\nlet image = Image(\"ImageName\")\n\n\n// UIKit\nlet image = UIImage(named: \"ImageName\")\n\n\n// AppKit\nlet image = NSImage(named: \"ImageName\")\n"
  },
  {
    "title": "Creating a SpriteKit particle emitter in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-a-spritekit-particle-emitter-in-xcode",
    "html": "Overview\n\nUse the SpriteKit particle emitter editor to experiment with SpriteKit particle effects and see the results immediately. The visual interface separates the task of designing particle effects from the programming, so artists can create effects independent of your code.\n\nThe editor lets you modify many of the properties of a particle emitter, including:\n\nWhere the emitter creates particles\n\nThe number of particles the emitter creates\n\nThe rotation, size, and movement of particles\n\nHow each particle changes throughout its lifetime\n\nAdd a particle emitter resource file to your project\n\nChoose File > New > File.\n\nChoose Resource > SpriteKit Particle File, and click Next.\n\nSelect one of the preinstalled particle emitter textures, and click Next.\n\nIn the next sheet, choose a location and enter a filename.\n\nSelect the checkbox associated with your project and click Create. Xcode creates a particle emitter file with the extension .sks.\n\nSelect the new particle emitter file in the Project navigator. Xcode opens the file in the particle emitter editor.\n\nAdd a particle emitter to a scene\n\nThe SpriteKit particle emitter editor displays a preview of the emitter, but doesn’t add the emitter to your SpriteKit scene. Use code to add your particle emitter to a scene, or use the SpriteKit scene editor to create a reference node that points to your particle emitter file. When the scene is loaded, your particle emitter is rendered as child of the reference node.\n\nTo add a reference node for your particle emitter to a SpriteKit scene:\n\nIn the Project navigator, select the scene file.\n\nClick the Library button (+) in the toolbar, then drag a reference node from the library to your scene.\n\nSelect the reference node and open the Attributes inspector.\n\nEnter a name in the Name field.\n\nIn the Reference pop-up field, choose the particle emitter file.\n\nChoose the shape of a particle\n\nChoose the shape of your particle by selecting a texture. Each particle that the emitter creates is based on a texture image that can be a solid shape or a complex picture. You can use any image associated with the project as a particle texture. The system applies all the particle emitter’s modifications to the selected image.\n\nIn the Texture pop-up field, choose a particle texture. Keep in mind that the larger or more complex a particle image is, the more resources it uses. Use the smallest and least complex image possible for the desired effect.\n\nChange the particle’s color\n\nYou can change the color of a particle throughout its lifetime and determine how a particle blends in with other images.\n\nUse the Color Blend fields to control how the particle blends its color with its texture’s inherent color.\n\nIn the Color Blend fields, click the minus (—) or plus (+) button, or double-click in the fields and enter the color blend values.\n\nFactor\n\nThe average starting value of the blend factor. This value corresponds to the particle emitter’s particleColorBlendFactor property. The valid interval of values is from 0.0 up to and including 1.0. A value above or below that interval is clamped to the minimum (0.0) if below or the maximum (1.0) if above. The default value is 0.0, which means that the texture is used as is, ignoring the particle’s color. Otherwise, the texture is blended with the color.\n\nRange\n\nThe range value creating a random variance of the starting color blend for each particle. This value corresponds to the particle emitter’s particleColorBlendFactorRange property.\n\nSpeed\n\nThe rate at which to modify the color blend for each particle, measured in change per second. This value corresponds to the particle emitter’s particleColorBlendFactorSpeed property.\n\nUse the Color Ramp field to change the color of a particle throughout its life cycle. You can have a particle go through as many color changes as you want during a particle’s life cycle. The particle changes colors based on the space between color sliders.\n\nIn the Color Ramp field, click anywhere in the field to add a new color slider to the color ramp. To create an immediate change of color, place two color sliders on top of each other so there’s no space between them on the color ramp.\n\nUse the Blend Mode field to determine how each particle blends with other images in your app. This value corresponds to SKBlendMode enumeration. The default value is SKBlendMode.alpha.\n\nIn the Blend Mode pop-up field, select one of the options.\n\nUse the Alpha fields to modify the particle’s transparency. The particle’s color is the result of multiplying the particle’s alpha value with the texture and color blending state. The particle color is then blended with the parent’s framebuffer before the particle is displayed.\n\nIn the Alpha fields, click the minus (—) or plus (+) button, or double-click in the fields and enter the alpha values.\n\nStart\n\nThe average starting transparency value applied to each particle. This value corresponds to the particle emitter’s particleAlpha property. The default value is 1.0.\n\nRange\n\nThe range of allowed random values for the particle’s starting alpha value. This value corresponds to the particle emitter’s particleAlphaRange property. The default value is 0.0.\n\nSpeed\n\nThe rate at which the alpha value changes, measured in change per second. This value corresponds to the particle emitter’s particleAlphaSpeed property.\n\nUse the Background field to change the background color shown in the Xcode preview to help you visualize how the emitter will look in different environments.\n\nIn the Background pop-up menu, choose a color. If the color you want to use isn’t listed, choose Other to bring up the color picker. To create an emitter with no background color, set the opacity in the color picker to 0.\n\nThe color you pick for the background persists until you change it again. Xcode saves the background color when you build the app, but doesn’t use the color at runtime.\n\nSpecify the movement and physics reactions\n\nYou can control different aspects of where a particle is created and the speed and angle at which the particle moves after creation.\n\nThe Position Range fields define the area in which the emitter creates particles. Particles are created within the rectangle centered on the position defined in the scene and bounded by the position range values.\n\nIn the Position Range fields, click the minus (—) or plus (+) button, or double-click in the fields and enter a value.\n\nX and Y\n\nThese values create the vector corresponding to the particle emitter’s particlePositionRange property. The default value is (0.0, 0.0).\n\nZ position\n\nThe value corresponding to the particleZPosition property. The default value is 0.0.\n\nThe Angle fields control the direction, in degrees, that particles move away from the emitter. Entering 0 degrees moves the particles directly to the right. The degrees work on a counterclockwise rotation, so entering 90 in the Start field sends the particles to the top of the screen.\n\nIn the Angle fields, click the minus (—) or plus (+) button, or double-click in the fields and enter the angle values.\n\nStart\n\nThe average initial direction of a particle. This value corresponds to the particle emitter’s emissionAngle property.\n\nRange\n\nThe range of allowed random values for particle’s direction at birth. This value corresponds to the particle emitter’s emissionAngleRange property.\n\nTip\n\nDegrees versus radians — the particle emitter inspector displays degrees when presenting an angle to the user. However, these degrees are converted into radians to match the SpriteKit API when the app is built.\n\nThe Speed fields define how fast the particle is moving, in points per second, at the instance of creation.\n\nIn the Speed fields, click the minus (—) or plus (+) buttons, or double-click in the fields and enter the speed values. The start and range values correspond to the particle emitter’s particleSpeed and particleSpeedRange properties.\n\nThe Acceleration fields modify the velocity of a particle after it is created. You can use this to simulate an overall gravity effect, wind blowing smoke from a fire, or other effects.\n\nIn the Acceleration fields, click the minus (—) or plus (+) button, or double-click in the fields and enter the acceleration values.\n\nX\n\nSpecifies acceleration along the horizontal axis. This value corresponds to the particle emitter’s xAcceleration property.\n\nY\n\nSpecifies acceleration along the vertical axis. This value corresponds to the particle emitter’s yAcceleration property.\n\nUse the Field Mask field to specify the categories of physics fields that can exert forces on your particles. By default, particles are not affected by physics fields. The value you provide corresponds to the particle emitter’s fieldBitMask property.\n\nIn the Field Mask field, double-click in the field and enter a field mask value, or click the up or down arrow to change the value.\n\nAdjust the size and rotation of particles\n\nYou can adjust a particle’s size during its lifetime and control the speed and direction in which the particle rotates when the emitter creates it.\n\nThe Scale fields manipulate the default size to determine the size of each particle at birth and whether the particle expands or shrinks during its lifetime. The default size of a particle is equal to the size of the particle’s texture, measured in points.\n\nIn the Scale fields, click the minus (—) or plus (+) button, or double-click in the fields and enter the values.\n\nStart\n\nThe average starting scale for each particle, corresponding to the particle emitter’s particleScale property. The default value of 1.0 maintains the initial size of the particles. Values greater than 0.0 and less than 1.0 reduce the size of the particles, and values greater than 1.0 increase the size of the particles.\n\nRange\n\nThe range of allowed random values that modify the scale value. The range value corresponds to the particle emitter’s particleScaleRange property. The default value of 0.0 has no effect on the scale value.\n\nSpeed\n\nThe rate at which the scale factor changes per second, corresponding to the particle emitter’s particleScaleSpeed property. The default value of 0.0 has no effect on the scale value.\n\nThe Rotation fields control the speed and direction that the particles rotate when rendered in a scene. You can use these fields to simulate falling leaves, spinning snowflakes, and any object that needs to rotate.\n\nIn the Rotation fields, click the minus (—) or plus (+) button, or double-click in the fields and enter the rotation values.\n\nStart\n\nThe average initial rotation of a particle, expressed as an angle in radians. This value corresponds to the particle emitter’s particleRotation property.\n\nRange\n\nThe range of allowed random values, expressed as an angle in radians. This value corresponds to the particle emitter’s particleRotationRange property.\n\nSpeed\n\nA particle’s rate of rotation, expressed in radians per second. This value corresponds to the particleRotationSpeed property.\n\nSpecify the life cycle for particles\n\nYou can manage how many particles are created, the maximum number of particles created, and the length of time that each particle is alive.\n\nImportant\n\nThe number of particles the emitter creates and how long they are onscreen directly affect the performance of your app.\n\nThe Emitter fields control how often particles are created and the maximum number of particles created.\n\nIn the Emitter fields, the minus (—) or plus (+) button, or double-click in the fields and enter a value.\n\nBirthrate\n\nThe number of particles created per second. This value corresponds to the particle emitter’s particleBirthRate property. The default value is 0.0.\n\nMaximum\n\nThe maximum number of particles created. The default value is 0, which indicates that the emitter creates an endless stream of particles. The maximum value corresponds to the particle emitter’s numParticlesToEmit property.\n\nThe Lifetime fields control how long, in seconds, each individual particle is onscreen.\n\nIn the Lifetime fields, click the minus (—) or plus (+) button, or double-click in the fields and enter a value.\n\nStart\n\nThe average starting value, corresponding to the particle emitter’s particleLifetime property.\n\nRange\n\nThe range of allowed random values for a particle’s lifetime, corresponding to the particle emitter’s particleLifetimeRange property."
  },
  {
    "title": "Localizing and varying text with a string catalog | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/localizing-and-varying-text-with-a-string-catalog",
    "html": "Overview\n\nYour app delivers the best experience when it runs well in a person’s locale and displays content in their native language. Supporting multiple languages is more than translating text. It includes handling plurals for nouns and units, as well as displaying the right form of text on specific devices.\n\nUse a string catalog to localize and translate all your app’s text in a visual editor right in Xcode. A string catalog automatically tracks all the localizable strings from your code, and keeps your translations in one place.\n\nUse string catalogs to host translations, configure pluralization messages for different regions and locales, and change how text appears on different devices.\n\nRelated session from WWDC23\n\nSession 10155: Discover String Catalogs\n\nLocalize your app’s text\n\nBefore you can translate text, you need to make it localizable. This involves wrapping the user-facing strings in your app in constructs that make them translatable.\n\nIn SwiftUI, all string literals within a view are automatically localizable.\n\n// SwiftUI localizable text.\nText(\"Welcome\")\n\n\nMake general text localizable using the String(localized:) initializer. For apps targeting older platforms, use the NSLocalizedString macro.\n\n// General localizable text.\nString(localized: \"Buy a book\"))\n\n\nAdd comments to give context and assist localizers when translating your text.\n\n// Localizable text with comments.\nText(\"Explore\", comment: \"The title of the tab bar item that navigates to the Explore screen.\")\nString(localized: \"Get Started\", comment: \"The label on the Get Started button that appears after they sign in.\")\n\nAdd a string catalog to your project\n\nTo add a string catalog to your project, choose File > New > File.\n\nIn the sheet that appears, select the platform, enter string into the filter field, select String Catalog, and click Next. In the dialog that appears, accept the default name Localizable, choose a location, and click Create.\n\nIf your string catalog gets too big, you can create multiple string catalog files within a single Xcode project, and give each a unique name. Then choose which string catalog to use for each translation by passing the string catalog name to the tableName or table parameter to the respective localization API as follows:\n\n// A SwiftUI localization example pointing to a specific string catalog.\nText(\"Explore\", tableName: \"Navigation\")\n\n\n// A general text localization example pointing to a specific string catalog.\nString(localized: \"Get Started\", table: \"MainScreen\")\n\nAdd a language to your project\n\nTo support multiple languages in your app, add additional languages to your project. For each language, select the string catalog in the Project navigator, click the Add button (+) near the bottom of the string catalog editor, and select a language to add.\n\nAdd your localizable text to the string catalog\n\nXcode automatically keeps your string catalog and app in sync each time you build your project. To populate your string catalog with the localizable text from your app, choose Product > Build. Xcode identifies strings in your app that support localization, and then adds them to your string catalog.\n\nUse the percent symbol beside each language to track your string catalog’s percentage of translation.\n\nAdd your translations using the string catalog editor\n\nAfter identifying your localizable strings and adding them to a string catalog, you can either manually translate them, or you can export them, send them to a third-party for translation, and then import them.\n\nTo enter your app’s translations manually, select the string catalog and click the language you want to add translations for. Then click the text field of the Language column for each key in the table and enter the translation for that key.\n\nNewly added strings that require translation appear with a New icon in the State column. When you add a translation, the New icon changes to a green checkmark. As you add translations, the percent symbol beside the language updates, displaying the translation percentage for that language. When a string catalog language reaches full translation, the percent symbol changes to a green checkmark.\n\nFor information about exporting and importing translations in Xcode, see Exporting localizations and Importing localizations.\n\nAdd pluralizations\n\nLanguages have different grammatical rules for handling plurals of nouns and units. For example, in English, you can return 1 Book when the value of %lld is 1. And you can return %lld Books for all other cases. Other languages can have fewer or more plural variants, depending on their region and locale.\n\nPlural\n\n\t\n\nText\n\n\n\n\nOne\n\n\t\n\n%lld Book\n\n\n\n\nOther\n\n\t\n\n%lld Books\n\nTo add a plural variant, first localize the text using the value the string is dependent on, using string interpolation.\n\n@State private var itemCount = 0\nText(\"\\(itemCount) Books\")\n\n\nThen, in the string catalog editor, select the language you want to add pluralization for, Control-click the variant key, and select the Vary by Plural option.\n\nWhen you add a plural variant, the system does the following:\n\nAdds all the plural forms for that language into the string catalog editor.\n\nDetermines which specifier to use for the interpolated string (%lld representing a 64-bit integer in this case).\n\nPrepopulates the variant fields with the value of that key.\n\nNote\n\nIf you add pluralization to the source language (English in this case), the system propagates the variation to the other languages, if possible. If you add pluralization to a nonsource language, that change affects only that language.\n\nClick the text field in the Language column for each variation of that string key, and enter the text for the system to use when that plural displays.\n\nWhen you run the app, the pluralized variants update based on the value of the interpolated string.\n\nVary strings by device\n\nWhen you need to alter the text that displays on a device due to the available space, or because it has a different interaction, use the Vary by Device option in the string catalog editor.\n\nFor example, suppose you want to display two different messages depending on whether your app is running on iPhone or a Mac.\n\nOperating system\n\n\t\n\nMessage\n\n\n\n\niOS\n\n\t\n\nTap to learn more\n\n\n\n\nmacOS\n\n\t\n\nClick to learn more\n\nTo vary the text string based on device, select the string catalog file, along with the language and key representing the message you want to vary. Control-click the key, select Vary by Device, and then select the device you want to add a specific message for.\n\nEnter the text you want to display for that selected device, while retaining the existing text for all other devices. Add more devices if you need more variations.\n\nWhen the app runs on the selected device, the system displays the new message for that device.\n\nTest your translations\n\nTo test your translations in the simulator:\n\nChange the app language of your current scheme by choosing Product > Scheme > Edit Scheme.\n\nIn the dialog that appears, select the Run action on the left and click the Options tab.\n\nClick the App Language drop-down, select the language you want to test, and click Close.\n\nYou can also navigate to Settings on the simulated device and change the deviceʼs language there. When your app runs, the translations for the selected language appear in the simulator.\n\nSee Also\nEssentials\nSupporting multiple languages in your app\nInternationalize your app’s strings, images, and other resource types to prepare for the translation process."
  },
  {
    "title": "Specifying your app’s launch screen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/specifying-your-apps-launch-screen",
    "html": "Overview\n\nEvery iOS app must provide a launch screen, a screen that displays while your app launches. The launch screen appears instantly when your app starts up and is quickly replaced with the app’s first screen.\n\nYou create a launch screen for your app in your Xcode project in one of two ways:\n\nInformation property list\n\nUser interface file\n\nTo make the app launch experience as seamless as possible, create a launch screen with basic views that closely resemble the first screen of your app.\nFor guidelines about designing a launch screen, see Launching in the Human Interface Guidelines.\n\nConfigure a launch screen in an information property list\n\nFor apps with simple user interfaces, using the information property list in your app provides a quick and straightforward method to configure your launch screen.\n\nIn the settings for your target, select the Info tab.\n\nIn the Custom iOS Target Properties section, expand the Launch Screen key.\n\nClick the Add button (+), type in UILaunchScreen, and press Return to add the launch screen key to the property list. If the UILaunchScreen key is already present, you can skip this step.\n\nSelect the UILaunchScreen key, click the Add button (+), and add additional keys to specify configuration options for your launch screen.\n\nDefine the appearance of the launch screen by specifying a combination of launch screen options from the possible keys in UILaunchScreen.\n\nConfigure a launch screen storyboard\n\nAlternatively, you can configure your launch screen in a user interface file, a file with a .storyboard file extension. A launch screen storyboard contains basic UIKit views, and uses size classes and Auto Layout constraints to support different device sizes and resolutions.\n\nFollow these guidelines when creating a launch screen storyboard:\n\nUse only UIKit classes.\n\nUse a single root view that’s a UIView or UIViewController object.\n\nDon’t make any connections to your code, for example, don’t add actions or outlets.\n\nDon’t use deprecated views such as UIWebView.\n\nDon’t use any custom classes.\n\nDon’t use runtime attributes.\n\nIf you create your iOS app from a storyboard template, Xcode adds a default launch screen file, called LaunchScreen.storyboard, to your project. Edit LaunchScreen.storyboard to configure your launch screen.\n\nIf your project doesn’t contain a default launch screen file, add a launch screen file and set the launch screen file for the target in the project editor.\n\nChoose File > New > File.\n\nUnder User Interface, select Launch Screen, and click Next.\n\nGive the launch screen file a name, choose a location, select the target that you want to add the file to, and click Create.\n\nIn the settings for your target, select the General tab and find the “App Icons and Launch Images” section.\n\nFrom the Launch Screen File pop-up menu, choose the new launch screen file.\n\nSee Also\nApp icons and launch screen\nConfiguring your app icon\nAdd app icon variations to represent your app in places such as Settings, search results, and the App Store."
  },
  {
    "title": "Specifying your app’s color scheme | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/specifying-your-apps-color-scheme",
    "html": "Overview\n\nAn accent color, or tint color, is a broad theme color that applies to views and controls in your app. Use an accent color to quickly create a unifying color scheme for your app. You can set an accent for your app by specifying an accent color in your asset catalog.\n\nCreate an accent color set\n\nWhen you create your project from a template, it automatically includes a default asset catalog (Assets.xcassets) with an AccentColor color set. Xcode applies the color you specify in this color set as your app’s accent color.\n\nIf your app doesn’t have an AccentColor color set, create a color set manually.\n\nIn the Project navigator, select an asset catalog.\n\nClick the Add button (+) at the bottom of the outline view.\n\nIn the pop-up menu, choose Color Set. A new color set appears in the outline view, and opens in the detail area.\n\nDouble-click the color set name in the outline view to rename the color set with a descriptive name, and press the Return key.\n\nIn Build Settings, find the build setting for “Global Accent Color Name”. Double-click the build setting, type in the name of your accent color set, and press Return.\n\nSpecify accent color variations\n\nWhen you select an accent color, choose a color that works well in light and dark appearances. In your accent color set, you can specify different color values for light and dark appearances if necessary.\n\nIn the Project navigator, select an asset catalog.\n\nIn the outline view, select the accent color set.\n\nOpen the Attributes inspector. In the Appearances field, choose the appearances for which you want to specify color values. Additional wells appear in the detail area for the appearance options you specify.\n\nSelect a well, and set a color by using the Content field in the Attributes inspector. Use the Any Appearance well to specify the color value the app uses on systems that don’t differentiate between light and dark appearances.\n\nYou can also specify high-contrast versions of your colors by selecting the High Contrast checkbox.\n\nAccess the accent color from your code\n\nBy default, your accent color applies to all views and controls in your app that use a tint color, unless you override the color for a specific subset of the view hierarchy. However, you might want to incorporate the accent color into other parts of your user interface that don’t rely on a tint color, like static text elements.\n\nTo use the accent color value from an asset catalog in code, load the color like this:\n\n// SwiftUI\nText(\"Accent Color\")\n    .foregroundStyle(Color.accentColor)\n\n\n// UIKit\nlabel.textColor = UIColor.tintColor\n"
  },
  {
    "title": "Supporting multiple languages in your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/supporting-multiple-languages-in-your-app",
    "html": "Overview\n\nMultilingual apps are apps that can run in more than one language and region. Making your app multilingual doesn’t only enable your app to run natively in more regions of the world, it gives your customers a better overall experience, while bringing your app to a wider audience.\n\nTo make your app multilingual, you first need to internationalize it. This process involves preparing assets in your app so that a localizer can translate them into different languages and regional conventions. For example, dates in some countries appear in a day-month-year format, while in others, the month comes first.\n\nAfter you internationalize your app, you need to localize it. Localization is the process of translating your assets into other languages for various regions. During this process, you export the relevant strings and other resources from your app, and give them to a localizer for translation. The localizer gives you back translated versions of your assets, which you import into your app. You then test the translations in your app to make sure everything works.\n\nInternationalize your code\n\nThe first step to making your app multilingual is to internationalize your code to handle different languages and regional conventions.\n\nThis process involves writing your code in such a way that your app can automatically extract the language resources it needs based on the current language settings of your user’s device. The Foundation framework, along with other Apple frameworks, supports this internationalization process.\n\nWhen writing code for internationalization, consider the following:\n\nUser-facing text. People are more comfortable using apps when the text appears in the language and region of their device. Use localized versions of the string formatters to prepare your app’s text for localization. For more information about user-facing text, see Discover String Catalogs.\n\nDates, currencies, and numbers. Different regions have different formats for dates, currencies, and numbers. Use DateFormatter and NumberFormatter in the Foundation framework to translate these strings correctly.\n\nPluralization. Languages have different grammatical rules for handling plurals of nouns and units. Use a string catalog to localize formatted strings that contain variable amounts. For more information about pluralization, see Localizing and varying text with a string catalog.\n\nDevice type. The device your app runs on affects the text it displays. The display on an Apple Watch differs from that on a Mac. Vary the text you present depending upon the device your app is running on. For more information about localizing text for a device type, see Localizing and varying text with a string catalog.\n\nGrammatical agreement. Many languages rely on gender for their grammar. Without knowing the subject’s gender or pronoun preferences, some localized strings may have grammatical errors, resulting in a poor user experience. Use the automatic grammar agreement APIs in Foundation, such as TermOfAddress, to represent grammatical gender in localized text. For more information about grammatical agreement, see Unlock the power of grammatical agreement.\n\nText direction. European languages read left to right, and languages like Arabic and Hebrew read right to left. Use the layout tools in SwiftUI and Xcode to control text and UI element orientation, and to flip image direction when necessary. For more information about text direction, see Get it right (to left).\n\nTall languages. Languages like Arabic, Hindi, and Thai require significantly more vertical space for their characters than Latin languages do. Additionally, Chinese, German, Japanese, and Korean have language-specific conventions for wrapping and hyphenation. To prevent clipping of words and letters, and to ensure proper spacing of text, use Dynamic Type. For more information about Dynamic Type, see Scaling fonts automatically and What’s new with text and text interactions.\n\nSounds, images and assets. App assets like sounds, images, and colors can vary across language and region. Use an asset catalog to localize colors, images, and sounds in your app. For more information about adding resources to asset catalogs, see Adding resources to localizations and Localizing assets in a catalog.\n\nLocalize your assets\n\nAfter you internationalize your app, it’s ready for localization. To localize your assets, export localizable text from Xcode using standard file formats and submit them to a localization team for translation into your app’s supported languages.\n\nTo localize your app, do the following:\n\nExport your app assets.\n\nTranslate those assets into other languages and regional conventions.\n\nImport the translated assets into your project.\n\nFor more information about exporting and importing app assets, see Discover String Catalogs.\n\nTest your translations\n\nAfter you localize your app’s assets, you need to test the translations. Run your app in each language, and for each region you support, to thoroughly test the localized assets. For more information about testing, see Testing localizations when running your app.\n\nSee Also\nEssentials\nLocalizing and varying text with a string catalog\nUse a string catalog to translate text, handle plurals, and vary the text your app displays on specific devices."
  },
  {
    "title": "Publishing a Swift package with Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/publishing-a-swift-package-with-xcode",
    "html": "Overview\n\nMaking your Swift packages available online enables you to use the support for Swift package dependencies in Xcode. By publishing your Swift packages to private Git repositories, you can manage and integrate internal dependencies across your projects, allowing you to reduce duplicate code and promote maintainability. Publish your packages publicly, and share your code with developers around the world. To get started, you just need a Swift package and an account with a provider of hosted Git repositories.\n\nProvide information on your Swift package\n\nEvery newly created Swift package contains a blank README.md file for you to modify. Consider adding information to it so other developers can learn more your Swift package, for example:\n\nA description of the functionality of your Swift package\n\nLicensing information\n\nSupported platforms and versions of Swift\n\nContact information\n\nSome developers even choose to include tutorials or usage documentation as part of their README.md file.\n\nPut your local Swift package under version control\n\nWhen you create a new Swift package with Xcode, check “Create Git repository on my Mac” in the sheet for creating a new package.\n\nIf you already have a local package that’s not using version control, put it under version control using Xcode. Open your Swift package, select the Source Control menu, choose New Git Repositories, check the checkbox next to your package, and click Create. This initializes a Git repository, adds your package to the staging area, and commits your files.\n\nTag your latest commit\n\nIt’s a best practice to create a version tag for a Swift package; however, there are other ways to add a package to a project, as described in Adding package dependencies to your app. To create a version tag, tag the last commit with the package version. A package version is a three period-separated integer. An example is 1.0.0. The package version must conform to semantic versioning to ensure that your package behaves in a predictable manner when developers update their package dependency to a newer version.\n\nTo learn more about the semantic versioning standard, visit Semantic Versioning 2.0.0.\n\nNote\n\nMake sure to commit any changes that you want to include in the release of your Swift package before creating a version tag.\n\nIn the Source Code Navigator, click the disclosure triangle next to Branches to show a list of your branches, then select a branch. In the history editor, Control-click a commit, then choose Tag “Your Identifier” from the pop-up menu. In the sheet that appears, enter a tag name that follows the semantic versioning standard, such as 1.2.4. Add an optional message, then click Create.\n\nMake your Swift package publicly available\n\nEnsure the Source Control Navigator is visible and select your local repository. Right-click it, and choose Create [packageName] Remote. In case you’ve already created an empty remote repository for your Swift package, choose Add Existing Remote.\n\nImportant\n\nYou need to add a hosted Git account in Xcode’s Preferences to be able to create or connect a Git remote.\n\nNext, push your local changes and the version tag to your Git remote. Click the Source Control menu, select Push, choose the branch from the dropdown menu, check the checkbox next to Include Tags, and click Push.\n\nEnsure your Git repository is public, and let people know that the package exists. Other developers only need the package’s Git URL to get started.\n\nLearn more about adopting package dependencies in Adding package dependencies to your app."
  },
  {
    "title": "Localizing package resources | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/localizing-package-resources",
    "html": "Overview\n\nLocalizing the resources in your Swift package ensures its usefulness for as many developers as possible. Adopt localized resources early to avoid additional development costs later.\n\nDeclare a default localization\n\nTo localize your package’s resources, pass the optional defaultLocalization parameter to the package initializer in your package manifest. This example provides English as the default localization:\n\nlet package = Package(\n    name: \"MyLibrary\",\n    defaultLocalization: \"en\",\n    platforms: [\n    ],\n    products: [\n        // Products define the executables and libraries a package produces, and make them visible to other packages.\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n        // .package(url: /* package url */, from: \"1.0.0\"),\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages this package depends on.\n)\n\n\nWhen you declare a value for defaultLocalization in the package manifest, Xcode requires the package to contain localized resources.\n\nImportant\n\nWhen declaring a supported language, or naming directories that contain localized resources, use two-letter ISO 639-1 or three-letter ISO 639-2 language codes with optional region or script designators. See CFBundleDevelopmentRegion for more information.\n\nAdd resources to language-specific directories\n\nTo use Xcode’s default localization mechanism, place localized resources in language-specific directories. A language-specific directory has a name that uses an ISO 639 language code and optional designators, followed by the .lproj suffix, and doesn’t contain subdirectories. For example, resources in the English language as it’s used in the United Kingdom reside in a directory named en-GB.lproj. By placing package resources in directories that end in .lproj and using ISO 639 language codes, Xcode can infer the language automatically.\n\nPlace your .lproj directories in a parent directory named Resources so you’ll recognize that it contains package resources.\n\nWhen you build your Swift package, Xcode validates the package’s localized resources and displays warnings or errors to help prevent issues at runtime. For example, Xcode detects:\n\nSubdirectories within a .lproj directory.\n\nMissing resources for a locale.\n\nDuplicate, conflicting, or inaccessible resources.\n\nThe following screenshot shows the structure of a Swift package with localized resources.\n\nLocalize storyboards and Interface Builder files\n\nIf the Swift package includes storyboards or Interface Builder files as resources, adopt base internationalization to relieve localizers of the need to modify these files directly. To have Xcode automatically recognize base localization in the Swift package:\n\nDeclare a value for defaultLocalization in the package manifest.\n\nCreate a directory named, for example, Resources, for your localized resources.\n\nCreate a subdirectory named Base.lproj and place the package’s storyboards and Interface Builder files in it.\n\nPlace the .lproj directories for all supported languages in the Resources directory.\n\nIf you prefer to explicitly declare a resource for base internationalization, use the process rule and pass Resource.Localization.base to it. For example, use the following to declare a .xib file that supports base internationalization:\n\n.process(”path/to/MyViewController.xib”, localization: .base)\n\nFor more information about base internationalization, see Internationalizing the User Interface.\n\nAccess localized resources\n\nXcode recognizes localized resources in .lproj directories and automatically creates resource bundles. As a result, you can access localized resource files in your package’s code with APIs you may already know from app development. For example, use Foundation to access a localized string at runtime:\n\nlet localizedString = NSLocalizedString(”a_localized_string”, bundle: Bundle.module, comment: “a comment”).\n\nSimilarly, you can access localized image resources with UIImage:\n\nUIImage(named: “image name”, in: .module, with: nil).\n\nFor more information, see Access a resource in code.\n\nSee Also\nPackage creation\nCreating a standalone Swift package with Xcode\nBundle executable or shareable code into a standalone Swift package.\nBundling resources with a Swift package\nAdd resource files to your Swift package and access them in your code.\nDistributing binary frameworks as Swift packages\nMake binaries available to other developers by creating Swift packages that include one or more XCFrameworks.\nDeveloping a Swift package in tandem with an app\nAdd your published Swift package as a local package to your app’s project and develop the package and the app in tandem.\nOrganizing your code with local packages\nSimplify maintenance, promote modularity, and encourage reuse by organizing your app’s code into local Swift packages."
  },
  {
    "title": "Building Swift packages or apps that use them in continuous integration workflows | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/building-swift-packages-or-apps-that-use-them-in-continuous-integration-workflows",
    "html": "Overview\n\nContinuous integration (CI) is the process of automating and streamlining the building, analyzing, testing, archiving, and publishing of your apps to ensure that they’re always in a releasable state. Use either Xcode Cloud or the xcodebuild command directly on other CI systems to build Swift packages and apps that use them.\n\nMost projects that contain or depend on Swift packages don’t require additional configuration. However, be sure to commit your project’s Package.resolved file to your Git repository. This ensures a reliable CI workflow that always uses the expected version of a package dependency. If your project depends on packages that require authentication, or you need to use your Mac’s Git tooling instead of the tooling which comes bundled with Xcode, you may need to perform additional configuration.\n\nImportant\n\nWhile you can build a standalone Swift package locally with Xcode, Xcode Cloud requires the package to be part of a project or workspace. To learn about building Swift packages with Xcode Cloud, see Building Swift packages and Swift Playgrounds app projects with Xcode Cloud.\n\nUse the expected version of a package dependency\n\nTo ensure the CI workflow’s reliability, make sure it uses the appropriate version of package dependencies. Xcode stores the exact version of each package dependency in a file called Package.resolved. The file automatically updates when package requirements in your Xcode project or in the Package.swift manifest file change. Commit this file to your Git repository to ensure it’s always up-to-date on the CI environment to prevent the CI from building your project with unexpected versions of package dependencies.\n\nTip\n\nYou can find the Package.resolved file inside your .xcodeproj directory at [appName].xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved.\n\nIf your CI pipeline uses the xcodebuild command directly, also pass the -disableAutomaticPackageResolution flag. This flag ensures that the CI pipeline always uses the package dependencies as defined in the Package.resolved file.\n\nProvide credentials\n\nIf your Xcode project only depends on publicly available Swift packages, you don’t need to perform additional configuration steps. Xcode Cloud or the xcodebuild command automatically resolve package dependencies for you. However, to resolve package dependencies that require authentication, or private packages, you need to provide credentials to your CI setup. For information on granting Xcode Cloud access to private dependencies, see Making dependencies available to Xcode Cloud.\n\nIf you’re using the xcodebuild command directly, use SSH–based Git URLs for your packages and configure your SSH credentials. Set up your known_hosts file in the ~/.ssh directory of the macOS user that runs your CI tasks. xcodebuild honors your SSH configuration — there’s no additional setup required.\n\nIf your SSH keys are password-protected, add them to the SSH agent before invoking xcodebuild by modifying the SSH configuration file as described in Tech Note 2449.\n\nUse your system’s Git tooling\n\nWhen you use the xcodebuild directly, it uses Xcode’s built-in Git tooling to connect to repositories. In many cases, you don’t need to make changes to how xcodebuild connects to them. However, some use cases require you use the configuration you set for your Mac’s Git installation. For example:\n\nURL remapping\n\nProxy configurations\n\nAdvanced SSH configurations, for example, disabling the StrictHostKeyChecking setting\n\nTo have xcodebuild use your Mac’s Git installation and configuration, pass -scmProvider system to the xcodebuild command.\n\nFor more information on using xcodebuild, see Technical Note 2339."
  },
  {
    "title": "Developing a Swift package in tandem with an app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/developing-a-swift-package-in-tandem-with-an-app",
    "html": "Overview\n\nSwift packages are a convenient and lightweight solution for creating a modular app architecture and reusing code across your apps or with other developers. Over time, you may want to develop your published Swift package in tandem with your app, or create a sample app to showcase its features. To develop a Swift package in tandem with an app, you can leverage the behavior whereby a local package overrides a package dependency with the same name:\n\nAdd the Swift package to your app as a package dependency instead of a local package, as described in Editing a package dependency as a local package.\n\nDevelop your app and your Swift package in tandem, and push changes to their repositories.\n\nIf you release a new version of your Swift package or want to stop using the local package, remove it from the project to use the package dependency again.\n\nSee Also\nPackage creation\nCreating a standalone Swift package with Xcode\nBundle executable or shareable code into a standalone Swift package.\nBundling resources with a Swift package\nAdd resource files to your Swift package and access them in your code.\nLocalizing package resources\nEnsure that your Swift package provides localized resources for many locales.\nDistributing binary frameworks as Swift packages\nMake binaries available to other developers by creating Swift packages that include one or more XCFrameworks.\nOrganizing your code with local packages\nSimplify maintenance, promote modularity, and encourage reuse by organizing your app’s code into local Swift packages."
  },
  {
    "title": "Organizing your code with local packages | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/organizing-your-code-with-local-packages",
    "html": "Overview\n\nAs you develop your app, organize its code in a modular way to keep it maintainable by creating Swift packages and using them as local packages.\n\nFirst, identify code that’s a good candidate for modularization; for example, networking logic, source files that contain utilities, and so on. Next, move the code into a local package like this:\n\nOpen your Xcode project and create a local Swift package as part of your project by selecting File > New > Package (or Swift Package in versions earlier than Xcode 15)\n\nTo create a package pre-configured for a library, select Multiplatform from the top of the package templates dialog, choose the Library template, and click Next. Choose from the other templates in the dialog to create packages configured for other kinds of content.\n\nChoose a project and a group, but don’t create a new Git repository if your app is already under version control; then create the new Swift package.\n\nMove your code to the new package in the Project navigator and make any needed updates to the package manifest. The amount of configuration depends on your requirements. For example, you might need to vend your code as a library product and declare the package’s targets. To learn more about configuring a Swift package, see Creating a standalone Swift package with Xcode.\n\nSelect your project in the Project navigator, then select your app target and navigate to its General pane.\n\nClick the + button in the “Frameworks, Libraries, and Embedded Content” section, select the local package’s library product, and add it as a dependency.\n\nWhen you organize your app’s codebase using local packages, your Swift package’s code is part of the same repository as your app’s code. As you create more apps, consider moving local packages to their own Git repositories, and add them to your apps as a package dependency to reuse code across apps. You may even consider sharing them with other developers. For more information, see Publishing a Swift package with Xcode.\n\nSee Also\nPackage creation\nCreating a standalone Swift package with Xcode\nBundle executable or shareable code into a standalone Swift package.\nBundling resources with a Swift package\nAdd resource files to your Swift package and access them in your code.\nLocalizing package resources\nEnsure that your Swift package provides localized resources for many locales.\nDistributing binary frameworks as Swift packages\nMake binaries available to other developers by creating Swift packages that include one or more XCFrameworks.\nDeveloping a Swift package in tandem with an app\nAdd your published Swift package as a local package to your app’s project and develop the package and the app in tandem."
  },
  {
    "title": "Configuring your app icon | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-your-app-icon",
    "html": "Overview\n\nEvery app has a distinct app icon that communicates the app’s purpose and makes it easy to recognize throughout the system. Apps require multiple variations of the app icon to look great in different contexts. Xcode can help generate these variations for you using a single high-resolution image, or you can configure your app icon variations by using an app icon’s image set in your project’s asset catalog. visionOS and tvOS app icons are made up of multiple stacked image layers you configure in your project’s asset catalog.\n\nCreate an app icon\n\nWhen you create your project from a template, it automatically includes a default asset catalog (Assets.xcassets) that contains the AppIcon. If you don’t have a default asset catalog or existing AppIcon or you want to provide an alternate, you can add an app icon to an asset catalog manually:\n\nIn the Project navigator, select an asset catalog.\n\nClick the Add button (+) at the bottom of the outline view.\n\nIn the pop-up menu, choose OS variant > OS variant App Icon. Xcode creates a new app icon set or image stack with the name AppIcon.\n\nSpecify app icon variations\n\nVariations of your app icon appear throughout the system in places like the Home View, Settings, and search results. In Xcode 14 and later, for iOS, macOS or watchOS apps, you can generate all variations of your icon using a single 1024×1024 pixel image or provide variations for all sizes. Although using a single size is the default behavior for new apps or new icons in the asset catalog, you might need all sizes in order to include detail in larger variants and simplify as app size decreases. If you have an existing project that provides multiple variants, consider providing a single size when that is all your icon requires.\n\nFor each platform your app supports, choose between using a single size and providing all sizes in the Asset Catalog:\n\nIn the Project navigator, select an asset catalog.\n\nIn the Asset Catalog, select the icon.\n\nTo view and edit attributes, select Inspectors > Attributes from Xcode’s View menu.\n\nSelect Single Size or All Sizes from the pop-up menu for the platform you want to change.\n\nFor each platform your app supports, add a single image that Xcode can use to generate your icon variations, or add an image for each icon variation of an icon set in the Asset Catalog:\n\nIn the Project navigator, select an asset catalog.\n\nIn the Asset Catalog, select the icon.\n\nFrom the Finder, drag image variations of the app icon to the image wells in the detail area of the Asset Catalog in Xcode that match their resolutions and use cases. visionOS and tvOS app icons combine a stack of multiple image layers to create a sense of depth. For tvOS apps, the asset catalog contains an App Icon & Top Shelf Image folder with the different app icon and launch image sets.\n\nFor general design guidance, see App icons. For platform-specific design guidance:\n\nvisionOS\n\niOS\n\nmacOS\n\ntvOS\n\nwatchOS\n\nConfigure the layers of an image stack\n\nBy default, visionOS and tvOS app icons are constructed with three layers. This is the maximum number of layers visionOS icons support but you can use up to five layers when constructing tvOS icons. To add a layer, Click the Add button (+), choose OS variant > OS variant App Icon Layer. To remove a layer, select the layer and click the Remove button (-).\n\nAdd images to each layer by dragging them from the Finder into the image wells in the detail area of the Asset Catalog in Xcode. For information on the use of layers, see App icons visionOS and tvOS.\n\nNote\n\nYou can use Parallax Previewer app or Parallax Exporter plug-in to create and preview Layer Source Representation (.lsr and .xlsr) files that you can import into your Asset Catalog in Xcode. Save your file in the LSR file format to import a tvOS icon into Xcode, and save in the XLSR file format to import a visionOS icon. Download these from the Apple Design Resources site.\n\nSpecify an App Store icon\n\nIf you distribute your app through the App Store, you must provide app icon imagery to use in the App Store. In the Project navigator, select an asset catalog and add icon images to the appropriate image wells in an app icon set or image stack. The App Store image well location varies by platform.\n\nPlatform\n\n\t\n\nApp Store icon location\n\n\n\n\niOS\n\n\t\n\nDrag an icon image to the iOS 1,024pt image well.\n\n\n\n\niMessage\n\n\t\n\nFor the iOS target, drag an icon image to the iOS 1,024pt image well in the AppIcon set. For the iMessage Extension target, drag an icon to the Messages App Store image well in the iMessage App Icon set.\n\n\n\n\nSticker Pack\n\n\t\n\nDrag an icon image to the iOS 1,024pt image well and the Messages App Store image well.\n\n\n\n\nmacOS\n\n\t\n\nDrag an icon image to the App Store - 2x image well.\n\n\n\n\ntvOS\n\n\t\n\nDrag images to the image wells for the layers of your App Icon - App Store stack in the App Icon & Top Shelf Image folder. The App Store generates an icon from the layers of the image stack.\n\n\n\n\nvisionOS\n\n\t\n\nDrag images to the image wells for the layers of your visionOS App Icon stack. The App Store generates an icon from the layers of the image stack.\n\n\n\n\nwatchOS\n\n\t\n\nFor the iOS target, drag an icon image to the iOS 1,024pt image well. For the WatchKit App target, drag an icon image to the watchOS image well.\n\nChange the default app icon set\n\nIf you don’t create your project from a template, or you want to change your default app icon set, specify which one to use in your target’s build settings.\n\nIn the Project navigator, select the project and in the project editor, select the target.\n\nIn the App Icons and Launch Images section of the General pane, choose the app icon set from the App Icons Source pop-up menu.\n\nIf you don’t select the Include all app icon assets option, Xcode only includes the app icon set you specify in the App Icons Source pop-up menu when it builds your app. You might leave this option unselected if you want to use a different icon for the Debug and Release builds of your app without including the Debug icon in your Release app bundle. You can specialize the app icon for the Debug and Release configurations by modifying the Primary App Icon Set Name build setting in the Build Settings tab.\n\nXcode also includes any additional app icon sets you specify under the Alternate App Icon Sets build setting. Include any icon sets your app can select using setAlternateIconName(_:completionHandler:) or use in App Store product pages.\n\nFor information on configuring tests that use icons in App Store Connect, see Product Page Optimization.\n\nSee Also\nApp icons and launch screen\nSpecifying your app’s launch screen\nMake your iOS app launch experience faster and more responsive by customizing a launch screen."
  },
  {
    "title": "Configuring Your App to Use Alternate App Icons | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring_your_app_to_use_alternate_app_icons",
    "html": "Overview\n\nThe sample code project demonstrates how to configure your app so that people can change the icon that appears on the Home screen, in Spotlight, and elsewhere in the system.\n\nPeople select an alternate icon in the app interface from a collection that you provide.\n\nAdd Icon Assets for the Alternate Icons\n\nFor each alternate app icon, the project requires multiple image files that vary in size. The project organizes these files through icon assets under the asset catalog.\n\nThe system picks the correct icon image for the current context and target device from the set of options under each icon asset. This ensures that the appearance of the alternate icon remains consistent.\n\nFor information on configuring app icons in the asset catalog, see Configuring your app icon.\n\nFor design guidance, see Human Interface Guidelines > App Icon.\n\nConfigure the Asset Catalog Compiler\n\nThe system gathers information about the app’s icons from the app’s information property list file under the top-level key CFBundleIcons. Xcode adds entries to this file for the icons the project specifies through build settings under Asset Catalog Compiler - Options.\n\nFor each icon asset that the project specifies by name in the build setting Alternate App Icon Sets, Xcode adds an entry under the key CFBundleAlternateIcons.\n\nXcode enters the name of the primary app icon asset specified in the build setting Primary App Icon Set Name under the key CFBundlePrimaryIcon. This setting is also available through the App Icons and Launch Images section of the General pane.\n\nFor more information on build settings, see Build settings reference.\n\nChange the App’s Icon\n\nWhen people select an alternate icon in the app interface, the app calls setAlternateIconName(_:completionHandler:) with the name of the new icon. This tells the system to display the new icon for this app. The system automatically displays an alert notifying people of the change. Passing nil displays the app’s primary icon.\n\nUIApplication.shared.setAlternateIconName(iconName) { (error) in\n    if let error = error {\n        print(\"Failed request to update the app’s icon: \\(error)\")\n    }\n}\n\n\nThe current icon’s name is available through the property alternateIconName."
  },
  {
    "title": "Managing assets with asset catalogs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/managing-assets-with-asset-catalogs",
    "html": "Overview\n\nAsset catalogs help you quickly organize and manage your app’s resources. In an asset catalog, each asset set represents one resource — like an image, color, or data file — that your app loads at runtime. An asset set contains one or more variations of that resource for different device characteristics, for example, platform, screen size, resolution, appearance, and language. When you refer to a resource in code, the system determines the appropriate variation to display at runtime based on the characteristics of the current device.\n\nCreate a new asset set\n\nWhen you create your project from a template, it automatically includes an asset catalog with the name Assets.xcassets, which appears in the Project navigator. This default asset catalog contains empty asset sets for an app accent color and an app icon. You can add additional asset sets to this default asset catalog.\n\nTo import assets into your project, first, create a new asset set in your asset catalog.\n\nIn the Project navigator, select the asset catalog.\n\nClick the Add button (+) at the bottom of the outline view.\n\nIn the pop-up menu, choose the type of asset set to create.\n\nThe new, empty asset set appears in the outline view and opens in the detail area.\n\nAdd a new asset\n\nNext, add your resource to the empty asset set. With the new asset set selected in the outline view, drag the asset you want to import from the Finder to a well in the detail area.\n\nAsset sets contain one or more wells that let you specify variations of your asset for different device characteristics. Each well has a label that describes the specific set of characteristics that apply to it. If you want to provide more variations of your asset, drag each asset file to the corresponding well. You can show additional wells by selecting more options in the Attributes inspector.\n\nCreate a new asset catalog\n\nIf you want to create additional asset catalogs to organize larger sets of app resources, you can create an asset catalog manually.\n\nChoose File > New > File.\n\nChoose Resource > Asset Catalog, and click Next.\n\nGive the asset catalog a name, choose a location, and click Create.\n\nThe new asset catalog appears in the Project navigator and opens in the editor area."
  },
  {
    "title": "Bundling resources with a Swift package | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/bundling-resources-with-a-swift-package",
    "html": "Overview\n\nIf you declare a Swift tools version of 5.3 or later in your package manifest, you can bundle resources with your source code as Swift packages. For example, Swift packages can contain asset catalogs, storyboards, and so on.\n\nAdd resource files\n\nSimilar to source code, Xcode scopes resources to a target. Place resource files into the folder that corresponds with the target they belong to. For example, any resources for the MyLibrary target need to reside in Sources/MyLibrary. However, consider using a subfolder for resources to distinguish them from source files. For example, put all resource files into a directory named Resources, resulting in all of your resource files residing at Sources/MyLibrary/Resources.\n\nTo add resources to a Swift package, do any of the following:\n\nDrag them into the Project navigator in Xcode.\n\nFrom the File menu in Xcode, choose Add Files to [packageName].\n\nUse Finder or the Terminal app.\n\nWhen you add a resource to your Swift package, Xcode detects common resource types for Apple platforms and treats them as a resource automatically. For example, you don’t need to make changes to your package manifest for the following resources:\n\nInterface Builder files; for example, XIB files and storyboards\n\nCore Data files; for example, xcdatamodeld files\n\nAsset catalogs\n\n.lproj folders you use to provide localized resources\n\nIf you add a resource file that Xcode doesn’t treat as a resource by default, you must configure it in your package manifest, as described in the next section.\n\nExplicitly declare or exclude resources\n\nTo add a resource that Xcode can’t handle automatically, explicitly declare it as a resource in your package manifest. The following example assumes that text.txt resides in Sources/MyLibrary and you want to include it in the MyLibrary target. To explicitly declare it as a package resource, you pass its file name to the target’s initializer in your package manifest:\n\ntargets: [\n    .target(\n        name: \"MyLibrary\",\n        resources: [\n            .process(\"text.txt\")]\n    ),\n]\n\n\nNote how the example code above uses the process(_:localization:) function. When you explicitly declare a resource, you must choose one of these rules to determine how Xcode treats the resource file:\n\nProcess rule\n\nFor most use cases, use process(_:localization:) to apply this rule and have Xcode process the resource according to the platform you’re building the package for. For example, Xcode may optimize image files for a platform that supports such optimizations. If you apply the process rule to a directory’s path, Xcode applies the rule recursively to the directory’s contents. If no special processing is available for a resource, Xcode copies the resource to the resource bundle’s top-level directory.\n\nCopy rule\n\nSome Swift packages may require a resource file to remain untouched or to retain a certain directory structure for resources. Use the copy(_:) function to apply this rule and have Xcode copy the resource as is to the top level of the resource bundle. If you pass a directory path to the copy rule, Xcode retains the directory’s structure.\n\nIf a file resides inside a target’s folder and you don’t want it to be a package resource, pass it to the target initializer’s exclude parameter. The next example assumes that instructions.md is a Markdown file that contains documentation, resides at Sources/MyLibrary and shouldn’t be part of the package’s resource bundle. This code shows how you can exclude the file from the target by adding it to the list of excluded files:\n\ntargets: [\n    .target(\n        name: \"MyLibrary\",\n        exclude:[\"instructions.md\"]\n    ),\n]\n\n\nIn general, avoid placing files that aren’t resources in a target’s source folder. If that’s not feasible, avoid excluding every file individually, place all files you want to exclude in a directory, and add the directory path to the array of excluded files.\n\nAccess a resource in code\n\nWhen you build your Swift package, Xcode treats each target as a Swift module. If a target includes resources, Xcode creates a resource bundle and an internal static extension on Bundle to access it for each module. Use the extension to locate package resources. For example, use the following to retrieve the URL of a property list you bundle with your package:\n\nlet settingsURL = Bundle.module.url(forResource: \"settings\", withExtension: \"plist\")\n\nImportant\n\nAlways use Bundle.module when you access resources. A package shouldn’t make assumptions about the exact location of a resource.\n\nIf you want to make a package resource available to apps that depend on your Swift package, declare a public constant for it. For example, use the following to expose a property list file to apps that use your Swift package:\n\nlet settingsURL = Bundle.module.url(forResource: \"settings\", withExtension: \"plist\")\n\nSee Also\nPackage creation\nCreating a standalone Swift package with Xcode\nBundle executable or shareable code into a standalone Swift package.\nLocalizing package resources\nEnsure that your Swift package provides localized resources for many locales.\nDistributing binary frameworks as Swift packages\nMake binaries available to other developers by creating Swift packages that include one or more XCFrameworks.\nDeveloping a Swift package in tandem with an app\nAdd your published Swift package as a local package to your app’s project and develop the package and the app in tandem.\nOrganizing your code with local packages\nSimplify maintenance, promote modularity, and encourage reuse by organizing your app’s code into local Swift packages."
  },
  {
    "title": "Creating a standalone Swift package with Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode",
    "html": "Overview\n\nSwift packages are reusable components of Swift, Objective-C, Objective-C++, C, or C++ code. They can bundle resources, vend their code as binaries, or depend on other packages. Use Swift packages to bundle executable code, for example a script, as an executable product, or create a package to vend shareable code as a library product. Packages that vend a library product help promote modularity in your code, make it easy to share code with others, and enable other developers to add functionality to their apps.\n\nWith Xcode, you can create a new Swift package, add code, resource files, and binaries, build the Swift package, and run its unit tests.\n\nCreate a Swift package\n\nTo create a new Swift package, open Xcode and select File > New > Package. Choose a name and select a file location. Select “Create Git repository on my Mac” to put your package under version control. On completion, the Swift package opens in Xcode and looks similar to a standard Xcode project. Xcode generates all necessary files and folders as it creates a Swift package:\n\nThe README.md file resides at the root level of the package. It describes the functionality of your Swift package.\n\nThe Package.swift file, or package manifest, describes the configuration for the Swift package. You can double-click it in Finder to open the package in Xcode. The package manifest uses Swift and the PackageDescription framework to define the package’s name, products, targets, dependencies on other packages, and so on.\n\nSource files reside in a folder named Sources and are scoped per Target. A Swift package can contain several targets, and, as a convention, each target’s code resides in its own subfolder.\n\nUnit test targets reside in a folder named Tests, and, following the same convention as standard targets, each test target’s code resides in its own subfolder.\n\nConfigure your Swift package\n\nSwift packages don’t use .xcodeproj or .xcworkspace but rely on their folder structure and use the package manifest for additional configuration. The following code listing shows a simple package manifest. It declares the MyLibrary target, and vends it as a library product with the same name.\n\n// swift-tools-version:5.3\nimport PackageDescription\n\n\nlet package = Package(\n    name: \"MyLibrary\",\n    platforms: [\n        .macOS(.v10_14), .iOS(.v13), .tvOS(.v13)\n    ],\n    products: [\n        // Products define the executables and libraries a package produces, and make them visible to other packages.\n        .library(\n            name: \"MyLibrary\",\n            targets: [\"MyLibrary\", \"SomeRemoteBinaryPackage\", \"SomeLocalBinaryPackage\"])\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages this package depends on.\n        .target(\n            name: \"MyLibrary\",\n            exclude: [\"instructions.md\"],\n            resources: [\n                .process(\"text.txt\"),\n                .process(\"example.png\"),\n                .copy(\"settings.plist\")\n            ]\n        ),\n        .binaryTarget(\n            name: \"SomeRemoteBinaryPackage\",\n            url: \"https://url/to/some/remote/binary/package.zip\",\n            checksum: \"The checksum of the XCFramework inside the ZIP archive.\"\n        ),\n        .binaryTarget(\n            name: \"SomeLocalBinaryPackage\",\n            path: \"path/to/some.xcframework\"\n        )\n        .testTarget(\n            name: \"MyLibraryTests\",\n            dependencies: [\"MyLibrary\"]),\n    ]\n)\n\n\nThe package manifest must begin with the string // swift-tools-version:, followed by a version number such as // swift-tools-version:5.3.\n\nThe Swift tools version declares:\n\nThe version of the PackageDescription framework\n\nThe Swift language compatibility version to process the manifest\n\nThe required minimum version of the Swift tools to use the package\n\nEach version of Swift can introduce updates to the PackageDescription framework, but the previous API version is available to packages that declare a prior Swift tools version. This behavior allows you take advantage of new releases of Swift, the Swift tools, and the PackageDescription framework, without having to update your package manifest and without losing access to existing packages.\n\nTo learn more about the PackageDescription framework, see Package.\n\nNote\n\nXcode provides code completion when you edit the package manifest.\n\nAdd your code\n\nPer convention, source files reside in a subfolder of the package’s Sources directory that has the same name as the target they belong to. Note how the package manifest above declares the MyLibrary target. Its source files reside in Sources/MyLibrary while source files for tests reside in Tests/MyLibraryTests. You can use additional subfolders to structure them. Per default, Xcode includes all valid source files inside a target’s folder. If you prefer to declare included source files explicitly, pass them using the sources parameter when you initialize the Target. You can also pass paths to directories.\n\nTo add source files to a Swift package, use workflows that you already know. For example, you can add a source file to a package by dragging it into the Project navigator, or by using the File > Add Files to [packageName] menu. Targets can contain Swift, Objective-C/C++, or C/C++ code, but an individual target can’t mix Swift with C-family languages. For example, a Swift package can have two targets, one that contains Objective-C, Objective-C++, and C code, and a second one that contains Swift code.\n\nAdd a dependency on another Swift package\n\nJust like apps, Swift packages can have package dependencies. To declare a dependency on a remote package, use one of the functions that take the URL of the remote package as a parameter. To add a local package as a dependency, use one of the functions that take a path to the local package as a parameter. The following code snipped shows both options:\n\ndependencies: [    \n    // Dependencies declare other packages that this package depends on.\n    .package(url: \"https://url/of/another/package.git\", from: \"1.0.0\"),\n    .package(path: \"path/to/a/local/package/\", \"1.0.0\"..<\"2.0.0\")],\n\n\nSee Package.Dependency for all possible ways to declare a package dependency. When you add the dependency, you can use its vended product as a Target.Dependency or make it a part of your package’s Product.\n\nDistribute binaries as a Swift package\n\nInstead of distributing a Swift package that vends source files, you can choose to distribute binaries instead. For example, creators of proprietary closed-source libraries often make them available as binaries. See Distributing binary frameworks as Swift packages to learn more.\n\nAdd package resources\n\nDeclare a Swift tools version of 5.3 or later in your manifest file to add asset files as package resources to your Swift package. For example, Swift packages can contain user interface components that use asset catalogs, storyboards, .strings files, and so on. See Bundling resources with a Swift package to learn more.\n\nMake your Swift package cross-platform compatible\n\nWhile Swift packages are platform-independent by nature and include, for example, Linux as a target platform, Swift packages can be platform-specific. Use conditional compilation blocks to handle platform-specific code and achieve cross-platform compatibility. The following example shows how to use conditional compilation blocks:\n\n#if os(Linux)\n\n\n// Code specific to Linux\n\n\n#elseif os(macOS)\n\n\n// Code specific to macOS\n\n\n#endif\n\n\n#if canImport(UIKit)\n\n\n// Code specific to platforms where UIKit is available\n\n\n#endif\n\n\nIn addition, you may need to define a minimum deployment target. Note how the package manifest below declares minimum deployment targets by passing them in as a value to the platforms parameter of the Package initializer. However, passing minimum deployment targets to the initializer doesn’t restrict the package to the listed platforms.\n\n// swift-tools-version:5.3\nimport PackageDescription\n\n\nlet package = Package(\n    name: \"MyLibrary\",\n    platforms: [\n        .macOS(.v10_14), .iOS(.v13), .tvOS(.v13)\n    ],\n    products: [\n        // Products define the executables and libraries a package produces, and make them visible to other packages.\n        .library(\n            name: \"MyLibrary\",\n            targets: [\"MyLibrary\", \"SomeRemoteBinaryPackage\", \"SomeLocalBinaryPackage\"])\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages this package depends on.\n        .target(\n            name: \"MyLibrary\",\n            exclude: [\"instructions.md\"],\n            resources: [\n                .process(\"text.txt\"),\n                .process(\"example.png\"),\n                .copy(\"settings.plist\")\n            ]\n        ),\n        .binaryTarget(\n            name: \"SomeRemoteBinaryPackage\",\n            url: \"https://url/to/some/remote/binary/package.zip\",\n            checksum: \"The checksum of the XCFramework inside the ZIP archive.\"\n        ),\n        .binaryTarget(\n            name: \"SomeLocalBinaryPackage\",\n            path: \"path/to/some.xcframework\"\n        )\n        .testTarget(\n            name: \"MyLibraryTests\",\n            dependencies: [\"MyLibrary\"]),\n    ]\n)\n\n\nTip\n\nIf you plan to publish a Swift package that doesn’t support all platforms, consider mentioning the supported platforms in your README.md file. In addition, think about adding support for other platforms to grow its audience.\n\nBuild your targets and run unit tests\n\nXcode creates a scheme for each product in the package manifest. Select a scheme for the package’s build-and-run destination, and build it as you’d build an app target. Each source target usually has at least one corresponding test target. If your package contains multiple products, Xcode creates an additional scheme with the name [packageName]-Package to build all targets and run all unit tests.\n\nSee Also\nPackage creation\nBundling resources with a Swift package\nAdd resource files to your Swift package and access them in your code.\nLocalizing package resources\nEnsure that your Swift package provides localized resources for many locales.\nDistributing binary frameworks as Swift packages\nMake binaries available to other developers by creating Swift packages that include one or more XCFrameworks.\nDeveloping a Swift package in tandem with an app\nAdd your published Swift package as a local package to your app’s project and develop the package and the app in tandem.\nOrganizing your code with local packages\nSimplify maintenance, promote modularity, and encourage reuse by organizing your app’s code into local Swift packages."
  },
  {
    "title": "Editing source files in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-organizing-and-editing-source-files",
    "html": "Overview\n\nSet up your Xcode project window to efficiently edit multiple related files at the same time. While you edit, annotate your files so you can easily determine a file’s content with the minimap or jump bar. Then add comments that Xcode can present as Quick Help to make your code easier to understand.\n\nFor information about how to add files and folders to your project, see Managing files and folders in your Xcode project.\n\nEdit related files using tabbed windows\n\nEdit related files together using tabbed windows in Xcode. To open a new window tab with the same configuration as your current window, press Command-T. To open existing files in tabs within a single window, select one or more files, and choose File > Open in New Window. Then choose Window > Merge All Windows.\n\nNext, configure each tab for how you plan to use it. To give each tab a name that describes how you use it, choose Window > Rename Window Tab.\n\nInside a window or window tab, configure the workspace for your task:\n\nShow or hide the navigators to the left of the workspace.\n\nShow or hide the inspectors to the right of the workspace.\n\nClick the Adjust Editor Options button to show or hide the canvas for SwiftUI code, the assistant for editing related files or Interface Builder files, the minimap, authors, code coverage statistics, and invisible characters.\n\nFrom the navigators, click a file to open it in the editor area. Xcode displays the filename in italics on the tab, indicating that the next file you click opens in the same tab. Double-click a file to open it in a new tab. Xcode displays the filename in regular text on the tab, indicating that the next file you click or double-click opens in a new tab.\n\nEdit your source code\n\nTo open a source code file in the source editor, click the file in the Project navigator. Add code in the editor area. As you type, use code completion to assist with variable and function names.\n\nWhen you use code completion for a method or function with parameters, Xcode provides a placeholder for each parameter that you need to add. Navigate between the placeholders with Tab and Shift-Tab, or choose Navigate > Jump to Next Placeholder or Navigate > Jump to Previous Placeholder.\n\nFor common code structures, Xcode provides snippets you can add to your code. Click the Library button (+) in the upper-right corner of the project window, select the “Show the Snippets library” option, then select a snippet and drag it to the desired location in the editor. Navigate between the placeholders to customize the snippet for your needs.\n\nTo add your own code snippet:\n\nSelect some code for the snippet, then Control-click and choose Create Code Snippet. Alternatively, choose Editor > Create Code Snippet.\n\nSpecify a name and summary for your snippet.\n\nIf you don’t select code when creating the snippet, enter code into the snippet editor. Mark any placeholders in your snippet with <#placeholder name#>.\n\nSelect the language and platform, enter any text to use for code completion, select the scope, and click Done.\n\nAnnotate your code for visibility\n\nThe jump bar and the minimap each provide a quick visual way to navigate your code in the Xcode source editor. Annotate your code with MARK, FIXME, and TODO comments to enhance the power of these tools when organizing your code.\n\nAdd a MARK comment to add a heading to a section of code. Include a dash in the comment to instruct Xcode to show a divider line before the section in the jump bar and minimap.\n\n// MARK: - Properties\n\n\n/// A Boolean value that indicates whether the card has an account.\nvar hasAccount: Bool\n\n\nAdd a TODO comment to indicate where you want to do future work. The jump bar highlights the TODO comment with an icon for easy identification.\n\n// TODO: Make spacing and count configurable\nvar columns: [GridItem] {\n    [GridItem](repeating: GridItem(.flexible(minimum: 20), spacing: 10), count: 5)\n}\n\n\nAdd a FIXME comment to note where you need to make a fix in your code. The jump bar highlights the FIXME comment with a different icon.\n\n// FIXME: Add customization for title\nText(\"Rewards Card\", comment: \"Header for rewards card\")\n\n\nIn addition to the organizational benefits, consistent use of MARK, TODO, and FIXME comments improves your ability to search for common sections, future updates, and needed fixes.\n\nAdd Quick Help comments to your code\n\nView Quick Help comments for a symbol by selecting it and choosing View > Inspectors > Quick Help. Alternatively, Control-click a symbol and select Show Quick Help. Add Quick Help comments to your code to clarify usage for other developers.\n\nTo add Quick Help to a symbol in your code, hover over the symbol declaration, Command-click it and choose Add Documentation. Xcode adds lines of comments, preceded with ///, that have placeholders for a description, parameters, throws, and a return value, depending on the symbol declaration. Update the placeholders using Markup syntax to complete the comments and enable Quick Help for the symbol.\n\n/// Returns an item that implements `FruitDisplayProtocol`, or throws an error if the `row` of the `indexPath` parameter is out of bounds of `fruitList.`\n/// - Parameter indexPath: An instance of `IndexPath` whose `row` indicates which fruit to return.\n/// - Throws: If the `indexPath.row` is outside the bounds of the `fruitList` array, throws a `FruitListRangeError.indexOutOfRange` error with a message indicating the indexPath that is out of range.\n/// - Returns: An object that implements `FruitDisplayProtocol`.\nfunc fruit(at indexPath: IndexPath) throws -> FruitDisplayProtocol {\n    guard indexPath.row >= fruitList.startIndex && indexPath.row < fruitList.endIndex else {\n        throw FruitListRangeError.indexOutOfRange(\"Fruit not found for index path: \\(indexPath)\")\n    }\n    return fruitList[indexPath.row]\n}\n\n\nXcode formats and displays the information as Quick Help when you view it.\n\nXcode also formats Quick Help from multiline comments that begin with /** and end with */. For more information about the Markup syntax for Quick Help, see Markup Formatting Reference."
  },
  {
    "title": "Identifying binary dependencies | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/identifying-binary-dependencies",
    "html": "Overview\n\nWhen you add a source-based package dependency to your app, you can inspect the source code, contribute bug fixes, and recompile the source code if needed. However, a package author may have chosen to distribute their code in binary form. For example, a company may prefer to distribute binaries instead of source files to protect intellectual property. In general, taking on a dependency always requires careful consideration because you’re adding code to your app; even more so if you’re adding a binary dependency. As a result, it’s important you know how to identify a binary dependency.\n\nReview binary dependencies\n\nCarefully consider whether you want to add a binary dependency, because doing so comes with drawbacks. For example, a binary dependency is less portable because it can only support platforms that its included binaries support, and binary dependencies are only available for Apple platforms. If you have a choice between a source-based dependency and a binary dependency, use the source-based dependency if it provides the same functionality.\n\nIdentify a binary dependency\n\nTo find out whether a package dependency is a binary dependency or if a source-based package depends on one:\n\nOpen your app’s project in Xcode and ensure that the Project navigator is visible.\n\nExpand Swift Package Dependencies and an individual package dependency.\n\nLook for a folder called Referenced Binaries. If it exists, the package dependency distributes a binary or has a binary dependency.\n\nTo further inspect the referenced binary, Control-click the XCFramework bundle inside the Referenced Binaries folder, and open it in Finder.\n\nThe following image shows an app’s expanded Swift package dependencies, including a package dependency called SomeRemoteBinaryPackage that distributes a binary.\n\nNote\n\nTo help verify a binary dependency’s origin, its author must create a checksum and include it in the package manifest. When Xcode resolves or updates package dependencies, it doesn’t allow binary dependencies to change the checksum without also changing the version.\n\nSee Also\nPackage dependencies\nAdding package dependencies to your app\nIntegrate package dependencies to share code between projects, or leverage code from other developers.\nEditing a package dependency as a local package\nOverride a package dependency and edit its content by adding it as a local package."
  },
  {
    "title": "Editing a package dependency as a local package | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/editing-a-package-dependency-as-a-local-package",
    "html": "Overview\n\nWhen you’re using a Swift package as a package dependency in your app, you may want to make edits to it. For example, you may want to contribute a fix for a bug to an open-source package. However, you can’t directly edit the content of a package dependency. To make changes, add the Swift package as a local package to your app’s project. Don’t remove your package dependency; adding a local package overrides the package dependency with the same name. Xcode uses the package dependency again when you remove the local package from your project.\n\nTo add the Swift package as local package to your project:\n\nCheck out your package dependency’s source code from its Git repository.\n\nOpen your app’s Xcode project or workspace.\n\nSelect the Swift package’s folder in Finder and drag it into the Project navigator. This action adds your dependency’s Swift package as a local package to your project.\n\nMake changes to the local package and your app, then verify them by building and running your app.\n\nWhen you’re done editing the local package, push your changes to its remote Git repository.\n\nWhen the changes have made it into the package’s next release, remove the local package from your project, and update the package dependency to the new version.\n\nSee Also\nPackage dependencies\nAdding package dependencies to your app\nIntegrate package dependencies to share code between projects, or leverage code from other developers.\nIdentifying binary dependencies\nFind out if a package dependency references a binary and verify the binary’s authenticity."
  },
  {
    "title": "Making dependencies available to Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/making-dependencies-available-to-xcode-cloud",
    "html": "Overview\n\nXcode Cloud combines the tools you use to create apps and frameworks: Xcode, TestFlight, and App Store Connect. However, your Xcode project or workspace may require additional dependencies or third-party tools to compile your code. For example, you may use a library created by the open source community or Swift package dependencies to reuse and share code between apps.\n\nIf Xcode Cloud can’t access a private dependency or a third-party tool, it won’t be able to successfully build your project. To avoid a failing build and save time when you start using Xcode Cloud, review your dependencies and make sure that Xcode Cloud can access them before configuring your project to use Xcode Cloud.\n\nNote\n\nThe temporary build environment that Xcode Cloud uses includes tools that are part of macOS and Xcode — for example, Python — and additionally Homebrew to support installing third-party dependencies and tools. For more information, see the “Use a custom build script to install a third-party dependency or tool” section below.\n\nUse Swift package dependencies and Git submodules\n\nXcode Cloud supports Swift packages and dependencies that you manage using Git submodules without any separate configuration if their repositories are publicly accessible. If you use private dependencies, Xcode Cloud helps you access them. For more information on using them, see Grant Xcode Cloud access to private dependencies below.\n\nFollowing the best practice for using Swift package dependencies in a CI/CD environment, Xcode Cloud doesn’t use automatic package resolution and instead relies on the Package.resolved file to resolve your dependencies. If you use Swift package dependencies in your project, make sure to include the Package.resolved file in your Git repository and commit any changes to it. Don’t include the file in your .gitignore file. Additionally, make sure the the Package.resolved file resides at $filename.xcodeproj/project.workspace/xcshareddata/swiftpm/Package.resolved.\n\nNote\n\nForcing Xcode Cloud to use automatic package resolution — for example, by changing settings in a custom build script — may result in undefined behavior and failing builds.\n\nFor general information on building Swift packages in a continuous integration and delivery environment, see Building Swift packages or apps that use them in continuous integration workflows.\n\nGrant Xcode Cloud access to private dependencies\n\nWhen you configure your project or workspace to use Xcode Cloud, Xcode detects the source code management (SCM) provider you use to host your code. It also detects the SCM provider for each private Git submodule, Swift package dependency, or Git repository you access in a custom script and helps you grant Xcode Cloud access to it. For example, if you host your code with Bitbucket Server and use a private dependency you host with GitLab, Xcode helps you connect both your Bitbucket Server and your GitLab account to Xcode Cloud.\n\nIf you add a new private package dependency that Xcode Cloud can’t access, the next build fails. To resolve the issue, navigate to the failed build’s build report, and let Xcode or App Store Connect help you connect Xcode Cloud to the dependency’s SCM provider.\n\nNote\n\nYou need to host your private dependencies with one of the supported SCM providers. For more information on supported SCM providers, see Source code management setup.\n\nBuilding your project may require access to more than one instance of your self-hosted SCM provider — a common case for large teams. For example, you may use two different GitHub Enterprise instances where one hosts your app’s code and the other hosts your dependencies. If this scenario applies to you, finish the initial onboarding workflow for the project in Xcode and connect the instance that hosts your app’s code, then let the first build fail. After the build failure, Xcode suggests a fix to connect the other instance.\n\nReview third-party dependencies\n\nIf you use a third-party dependency manager like CocoaPods or Carthage, or require an additional tool to successfully build your project, you’ll need to make changes to your project or workspace before you can use Xcode Cloud.\n\nBecause third-party tools and dependencies require additional work, review and simplify your third-party dependencies before you configure your project or workspace to use Xcode Cloud. For example, you may be able to replace a dependency with a framework that Apple provides. Alternatively, see if its creator offers the dependency as a Swift package. If so, you can use the package and take advantage of the support for the Swift Package Manager without configuring Xcode Cloud to use a third-party tool.\n\nIf switching to a Swift package dependency or removing a dependency isn’t practical, follow the instructions below to ensure Xcode Cloud can access dependencies and required tooling.\n\nUse a custom build script to install a third-party dependency or tool\n\nThe temporary build environment Xcode Cloud uses to perform a build doesn’t include third-party tools or dependencies. However, it includes Homebrew, an open source package manager you can use to install additional software. For example, you can use Homebrew to install dependency managers like CocoaPods or Carthage.\n\nTo install a tool with Homebrew:\n\nCreate a directory next to your Xcode project or workspace and name it ci_scripts.\n\nCreate an executable shell script, name it ci_post_clone.sh, and save it in the ci_scripts directory. For example, use the Shell Script template in Xcode to create the file, and then make it an executable by running chmod +x ci_post_clone.sh in Terminal.\n\nOpen the custom script in Xcode and add the necessary commands to install a tool with Homebrew.\n\nNote\n\nYou can use custom build scripts to perform a variety of tasks, but you can’t obtain administrator privileges by using sudo.\n\nFor more information about custom build scripts, see Writing custom build scripts.\n\nMake CocoaPods dependencies available to Xcode Cloud\n\nCocoaPods is an open source dependency manager for Apple platforms. However, the temporary build environment that Xcode Cloud uses to perform a build doesn’t come with the tool pre-installed. If you use CocoaPods, first make sure you commit both your Podfile and the Podfile.lock file. Then, decide between one of the following options:\n\nAdd the Pods directory to your Git repository by committing it.\n\nExclude the Pods directory from source control by adding it to your .gitignore file.\n\nIf you commit the Pods directory and its contents, you won’t need to install CocoaPods to enable Xcode Cloud to build your project or workspace. It’s worth noting, however, that your source code repository takes up more space when adding the Pods directory. Additionally, remember that committing binary dependencies can affect the performance of your Git repository. It’s a general issue when using Git and not specific to Xcode Cloud.\n\nTip\n\nIf you decide to commit the Pods directory, consider using Git LFS . It’s pre-installed on the temporary build environment Xcode Cloud uses to build your project.\n\nIf you choose to exclude the Pods directory from source control, you’ll need to install CocoaPods using a custom build script. The benefit, however, is that the source code repository takes up less disk space and doesn’t slow down your Git repository. To install CocoaPods using a custom build script:\n\nCreate a post-clone script as described in Use a custom build script to install a third-party dependency or tool.\n\nAdd commands to the script that install CocoaPods with Homebrew and that download your CocoaPods dependencies. The following code snippet shows a basic script to achieve this:\n\n#!/bin/sh\n\n\n# Install CocoaPods using Homebrew.\nbrew install cocoapods\n\n\n# Install dependencies you manage with CocoaPods.\npod install\n\nMake Carthage dependencies available to Xcode Cloud\n\nCarthage is an open source dependency manager for Apple platforms. However, the temporary build environment that Xcode Cloud uses to build your project doesn’t come with the tool pre-installed. To facilitate projects that rely on the carthage copy-frameworks command — most projects do — , install Carthage using a custom build script:\n\nCreate a post-clone script as described in Use a custom build script to install a third-party dependency or tool.\n\nAdd the necessary commands to the script to install Carthage using Homebrew and build your Carthage dependencies.\n\nSee Also\nSetup and maintenance\nConfiguring your first Xcode Cloud workflow\nConfigure your project or workspace to use Xcode Cloud and adopt continuous integration and delivery.\nConfiguring Xcode Cloud for your team\nStart using continuous integration and delivery with Xcode Cloud as a team.\nBuilding Swift packages and Swift Playgrounds app projects with Xcode Cloud\nAdd your Swift package or Swift Playgrounds app project to an Xcode project to build it in Xcode Cloud.\nSetting the next build number for Xcode Cloud builds\nStart numbering builds from a custom build number for your existing Mac app to avoid version collisions.\nIncluding notes for testers with a beta release of your app\nAdd text files to your Xcode project to provide notes to beta testers about what to test.\nRemoving your project from Xcode Cloud\nRemove your project from Xcode Cloud to delete app and workflow data, disconnect your Git repository, and remove the Slack integration."
  },
  {
    "title": "Finding and refactoring code | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/finding-and-refactoring-code",
    "html": "Overview\n\nWhen writing and analyzing code, you frequently need to look up a symbol to learn how to use it and to determine how other code uses it. Use Xcode’s search capabilities to find text and symbols in your code to analyze potential changes, determine current functionality, or debug code.\n\nRename files or symbols to clarify usage with a more descriptive and meaningful name. Refactor your code when you identify duplicate code or code that you can reuse. Transform existing code into more reusable functions, methods, or variables.\n\nFind files by name or included symbols\n\nOpen a file quickly by pressing Shift-Command-O to bring up the Open Quickly dialog. Type in part of a filename or symbol name, and the dialog presents a list of potential matches.\n\nSelect an item from the search results to open it and navigate to the matched symbol or file. If the file is already open in a tab, Xcode switches to that tab, otherwise, Xcode opens the file in a new tab.\n\nWhen there are a lot of files in your project, type part of the filename into the Filter field at the bottom of the Project navigator. Xcode displays matching group names and filenames with their parent groupings so you can easily see their locations in your project.\n\nTo find a symbol in your source code, open the Symbol navigator and enter part of a symbol name into the Filter field at the bottom.\n\nXcode matches the text you enter to the names of the class, structure, enumeration, function, method, and variable entities in your code, and displays those results in the navigator. Click a matching result to navigate directly to the definition of the symbol in your source code. Use the options in the Filter field to limit or expand your search by symbol type, to indicate whether the symbol’s definition is in your source or in the SDKs, to choose whether to limit the results to containers (like classes or structures), or to show members (like variables and functions).\n\nFind text or patterns in your source code\n\nTo find text in a file, open the file in the Xcode source editor and choose Find > Find from the menu bar. Xcode displays the Find bar and its search controls at the top of the file.\n\nEnter a search term. Xcode searches the file, highlights matches, and notes how many it finds. Refine your search using the following options:\n\nClick the Find Options menu on the left to display options to replace text, run recent searches, or clear recent search history.\n\nClick the Insert Pattern button (+) to include tabs, line breaks, or special characters in your search term.\n\nToggle the Case Sensitive button to indicate whether you want Xcode to match the case of your search term.\n\nClick the Match Style button to customize how Xcode looks for your search term in your source code.\n\nNavigate between matches using the Next and Previous buttons.\n\nClose the Find bar by clicking the Done button.\n\nFind symbols in your source code\n\nTo find a symbol in your code, Control-click the variable or function name, and choose Find > Find Selected Symbol in Workspace.\n\nXcode displays the declaration of the symbol in the Find navigator, along with any places where your code references the symbol. Refine your search using the following options:\n\nChoose Find or Replace.\n\nChoose what you want to search for: text, symbol references, symbol definitions, text that matches regular expressions, or call hierarchy.\n\nSelect a match style to customize how Xcode looks for your search term.\n\nClick the magnifying glass icon to view recent searches.\n\nCustomize the scope of your search: in your project, or in any groups/folders inside your project. If you’re using a workspace, you can search across the workspace, or inside a project.\n\nSelect Ignoring Case or Matching Case.\n\nIf your search returns a large number of matches, narrow the results with another term in the Filter field.\n\nRename symbols throughout your project\n\nTo rename a function, method, class, structure, or enumeration in your project, Control-click either the declaration of the symbol or a use of the symbol, and choose Refactor > Rename. Xcode highlights the symbol, searches your project for its name, and shows everywhere that the symbol appears.\n\nType a new name into the highlighted selection and Xcode previews all the changes. Click a proposed renaming instance to toggle whether Xcode renames it. Click Rename to complete the changes, or Cancel to not make the changes.\n\nTo rename a local variable or instance variable, Command-click the variable and choose Edit All in Scope. Xcode highlights instances of the variable in scope in the source editor. Type a new name and Xcode updates all instances to the same name.\n\nRefactor code into functions\n\nWhen you have code that repeats in a function or code that you can reuse, refactor it into a function. Select the lines of code you want to refactor, then Control-click and choose Refactor > Extract to Method. Xcode creates a new function, and highlights its name so you can rename it.\n\nIf the lines of code reference parameters, Xcode includes those in the parameter list for the new function. To rename a parameter, Command-click it and choose Edit All in Scope, or Control-click it and choose Refactor > Rename."
  },
  {
    "title": "Setting the next build number for Xcode Cloud builds | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/setting-the-next-build-number-for-xcode-cloud-builds",
    "html": "Overview\n\nXcode Cloud assigns a build number to each build it performs. A build number is an integer value that Xcode Cloud automatically increases with each build, starting from 1. Your first Xcode Cloud build’s build number is 1, the second build’s build number is 2, the third build’s build number is 3, and so on.\n\nFor existing iOS, tvOS, and watchOS apps, and for new apps — no matter which platform — use the default value of 1 for Xcode Cloud builds. However, you need to configure the build number to start from a different value when you configure an existing Mac app to use Xcode Cloud.\n\nImportant\n\nXcode Cloud build numbers are always integers; for example, 42, 420, or 420000 and so on. You can’t use build numbers that are hash values, timestamps, or other strings.\n\nWhen you distribute an Xcode Cloud build with TestFlight or release it on the App Store, App Store Connect uses the build number of the Xcode Cloud build. This makes it easy to identify the Xcode Cloud build that correlates with an app’s version in TestFlight or the App Store. For example, say you use Xcode Cloud to create a workflow called Weekly Build that makes a new version available to external testers in TestFlight once per week. For your latest weekly build, it distributes version 1.2.1 (42) where 42 is the build number that Xcode Cloud set. If you need to look at detailed build information for the version, look at the version’s build number — 42 — and navigate to the corresponding Xcode Cloud build in Xcode or App Store Connect.\n\nReview build number requirements\n\nFor a new app, starting with build number 1 makes sense. When you start using Xcode Cloud for an existing app, it assigns build number 1 to your first build. For iOS, tvOS, and watchOS apps, this behavior meets build number requirements. Apps for those platforms can use a lower build number for a new version compared to a previous version because App Store Connect requires each app version to use a unique combination of CFBundleShortVersionString and CFBundleVersion.\n\nFor example, your latest app version in the App Store could be 1.2.1 (42) before you start using Xcode Cloud. When you start using Xcode Cloud, your next app version would be 1.2.2 (1) because Xcode Cloud build numbers start at 1. It’s a unique combination of the version and the build number and, as a result, App Store Connect accepts it when you submit the new version for app review.\n\nHowever, Mac apps must follow different build number requirements. To successfully submit a Mac app to app review, its build number must continuously increase, even across app versions. If the app in the previous example was a Mac app, version 1.2.2 (1) would be invalid because the build number didn’t increase compared to the previous version 1.2.1 (42). A valid build number for this Mac app would be 1.2.2 (43).\n\nTo help cases where incrementing the Xcode Cloud build number starting with 1 isn’t possible — like for an existing Mac app — use App Store Connect to configure Xcode Cloud to increment the build number starting with a custom value.\n\nSet the next build number to a custom value\n\nSetting the next build number to a custom integer value solves cases where incrementing Xcode Cloud build numbers starting with 1 leads to version collisions.\n\nImportant\n\nOnly members of your Apple Development Team with the Admin or App Manager role can set the next build number to a custom value.\n\nTo configure the next build number:\n\nStart using Xcode Cloud for your project or workspace.\n\nNavigate to your app’s page on the App Store Connect website.\n\nClick the Xcode Cloud tab and choose Settings in the sidebar.\n\nClick the Build Number tab below Settings.\n\nClick the Edit button next to Next Build Number.\n\nEnter a new build number and save your changes.\n\nThe screenshot below shows the form you use to edit the Build Number on the App Store Connect website.\n\nSee Also\nSetup and maintenance\nConfiguring your first Xcode Cloud workflow\nConfigure your project or workspace to use Xcode Cloud and adopt continuous integration and delivery.\nMaking dependencies available to Xcode Cloud\nReview dependencies and make them available to Xcode Cloud before you configure your project to use Xcode Cloud.\nConfiguring Xcode Cloud for your team\nStart using continuous integration and delivery with Xcode Cloud as a team.\nBuilding Swift packages and Swift Playgrounds app projects with Xcode Cloud\nAdd your Swift package or Swift Playgrounds app project to an Xcode project to build it in Xcode Cloud.\nIncluding notes for testers with a beta release of your app\nAdd text files to your Xcode project to provide notes to beta testers about what to test.\nRemoving your project from Xcode Cloud\nRemove your project from Xcode Cloud to delete app and workflow data, disconnect your Git repository, and remove the Slack integration."
  },
  {
    "title": "Removing your project from Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/removing-your-project-from-xcode-cloud",
    "html": "Overview\n\nWhen your app or framework is no longer under active development, you might want to do some general cleanup, like:\n\nRemove your app and any data from Xcode Cloud.\n\nDisconnect Xcode Cloud from your SCM provider.\n\nDisconnect Xcode Cloud from your team’s Slack workspace.\n\nRemove any webhooks that you’ve configured.\n\nDeleting your data from Xcode Cloud\n\nWhen you delete your data from Xcode Cloud, you can’t restore it and it becomes immediately inaccessible.\n\nSimilarly, deleting a workflow deletes the workflow’s build history and artifacts. Only delete a workflow or your data from Xcode Cloud when you’re confident that you don’t need its build history or artifacts anymore. Instead, deactivate workflows you no longer need as described in Deactivate a workflow instead of deleting it.\n\nTo stop using Xcode Cloud for your app or framework and delete its associated data:\n\nIn Xcode, navigate to the Report navigator, Control-click your app, choose Delete Xcode Cloud Data for,” and confirm that you want to permanently delete all Xcode Cloud data.\n\nIn App Store Connect, go to your app’s page, select the Xcode Cloud tab, choose Settings > Delete Xcode Cloud Data, click Delete, and confirm that you want to permanently delete all Xcode Cloud data.\n\nFor more information on the differences between deleting and deactivating a workflow, see Deactivate a workflow instead of deleting it.\n\nDisconnect your Git repository in Xcode Cloud\n\nIf you move your Git repositories to another source code management (SCM) provider, you’ll want to remove the old provider from your Xcode Cloud configuration.\n\nTo disconnect Xcode Cloud from Bitbucket Server, GitHub Enterprise, or a self-managed GitLab instances:\n\nLog in to App Store Connect and go to Users and Access.\n\nSelect the Xcode Cloud tab.\n\nMove the cursor over the SCM provider you want to remove, then click the Remove button (-) and confirm that you want to disconnect Xcode Cloud from your provider.\n\nTo disconnect Xcode Cloud from Bitbucket, GitHub, or GitLab:\n\nLog in to App Store Connect and go to your profile settings by clicking your account in the top-right corner of the website and Edit Profile.\n\nSelect the Xcode Cloud tab.\n\nChoose Integrations in the sidebar.\n\nClick Unlink next to the SCM provider you no longer use and confirm that you want to remove the connection between Xcode Cloud and your provider.\n\nRemove personal access tokens or apps\n\nTo completely remove all traces of Xcode Cloud from your SCM provider, you need to remove the app or personal access token that allowed Xcode Cloud access to the repository. The process to do this is different for each SCM provider:\n\nBitbucket Cloud\n\nSign into your Bitbucket Cloud account and go to your personal settings. Choose “App authorization” in the Access Management group and revoke the application authorization for Xcode Cloud.\n\nBitbucket Server\n\nSign in to your Bitbucket Server account and go to your account settings. Choose “HTTP access tokens” and revoke the token for Xcode Cloud using the Actions > Revoke button.\n\nGitHub\n\nSign into your GitHub account. If you use a GitHub organization and the organization owns your Git repository, follow the steps described for GitHub Enterprise. If you don’t use a GitHub organization, go to your account settings. Choose Applications, click Configure next to the Xcode Cloud app, and then click Uninstall to remove the GitHub app from your account and repositories.\n\nGitHub Enterprise\n\nSign into your GitHub Enterprise account and go to your account settings. Choose Applications > Configure, and then click Uninstall at the bottom of your GitHub app’s settings. This removes the GitHub app from your repositories. Next, choose Developer Settings > GitHub Apps and click Edit for the Xcode Cloud GitHub app. Navigate to the Advanced section and delete your app from your GitHub Enterprise account or organization.\n\nGitLab\n\nSign into your GitLab account and navigate to your user preferences. Click Applications, and then scroll down to the list of authorized apps and revoke the authorization for the Xcode Cloud app.\n\nSelf-managed GitLab Instance\n\nSign into your account for your self-managed GitLab instance and go to your account settings. Choose Applications and then delete the app for Xcode Cloud.\n\nRemove the Slack integration\n\nIf you connected your team’s Slack workspace to Xcode Cloud, the connection between Xcode Cloud and your Slack workspace remains when you delete a workflow or remove your project. To remove the Slack integration, you’ll need to uninstall the Slack app from your team’s Slack workspace:\n\nOpen your Slack workspace in your browser and click Manage. Alternatively, click on your workspace’s name in the Slack app and choose “Settings & administration” > “Manage apps”.\n\nChoose Installed Apps in the sidebar, then choose the Xcode Cloud app.\n\nRemove the app and confirm that you want to delete the Slack app for Xcode Cloud.\n\nNote\n\nDepending on the configuration of your team’s Slack workspace, you may need to ask your team’s Slack administrator to remove the Slack app.\n\nSee Also\nSetup and maintenance\nConfiguring your first Xcode Cloud workflow\nConfigure your project or workspace to use Xcode Cloud and adopt continuous integration and delivery.\nMaking dependencies available to Xcode Cloud\nReview dependencies and make them available to Xcode Cloud before you configure your project to use Xcode Cloud.\nConfiguring Xcode Cloud for your team\nStart using continuous integration and delivery with Xcode Cloud as a team.\nBuilding Swift packages and Swift Playgrounds app projects with Xcode Cloud\nAdd your Swift package or Swift Playgrounds app project to an Xcode project to build it in Xcode Cloud.\nSetting the next build number for Xcode Cloud builds\nStart numbering builds from a custom build number for your existing Mac app to avoid version collisions.\nIncluding notes for testers with a beta release of your app\nAdd text files to your Xcode project to provide notes to beta testers about what to test."
  },
  {
    "title": "Configuring Xcode Cloud for your team | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-xcode-cloud-for-your-team",
    "html": "Overview\n\nTo adopt continuous integration and delivery (CI/CD) with Xcode Cloud, you’ll need to configure your project or workspace to use Xcode Cloud, create your first workflow, and then start your first build. However, starting to use Xcode Cloud as a team may require additional steps and coordination among team members and administrators — especially in a corporate context.\n\nTo successfully configure your team’s project or workspace to use Xcode Cloud, first review required roles and permissions described in Requirements for using Xcode Cloud. Depending on your role and permissions, you may need to coordinate with others to:\n\nAllow Xcode Cloud to access your team’s Git repository.\n\nCreate an app record in App Store Connect.\n\nIf you have the required role and permissions to complete the above tasks or someone else has previously performed them, configure your team’s project or workspace to use Xcode Cloud as described in Configuring your first Xcode Cloud workflow. However, teams may limit the number of people who can administer their Git repositories and their App Store Connect account. In a corporate context, there might even be a dedicated infrastructure team, which means you need to work with them before you start using Xcode Cloud.\n\nFor additional information about using Xcode Cloud as a team, see WWDC22:Deep dive into Xcode Cloud for teams.\n\nConnect Xcode Cloud to an admin-managed Git repository\n\nTo start using Xcode Cloud, you need the permissions listed in Requirements for using Xcode Cloud to grant Xcode Cloud access to your team’s Git repository. If you don’t have the required role or permission, work with your team’s source code management (SCM) administrator and ask them to configure your project to use Xcode Cloud.\n\nYou only need to work with your team’s SCM administrator when you onboard your team’s first app or framework to Xcode Cloud. When the SCM administrator configures Xcode Cloud for one project or workspace and connects your team’s SCM provider to Xcode Cloud, other projects you host with the same provider can use the configured connection. For example, say your team hosts its repositories on Bitbucket Cloud and your team’s administrator configures one project to use Xcode Cloud. When you start using Xcode Cloud for subsequent projects that use Bitbucket Cloud, you reuse the connection to Bitbucket Cloud that your administrator configured.\n\nTo connect Xcode Cloud to an admin-managed Git Repository:\n\nAdd your team’s administrator to your Apple Developer team if they aren’t a member.\n\nLet your team’s administrator configure your project to use Xcode Cloud. If your repository’s administrator doesn’t have expertise developing for Apple platforms, it’s OK to let them configure your project or workspace to use Xcode Cloud and to allow the first build to fail.\n\nStart using Xcode Cloud, as discussed in Connect your personal SCM account to Xcode Cloud below, and fix any build issues as needed.\n\nTip\n\nIf you host your code using GitHub or GitHub Enterprise, Xcode Cloud helps you work with your GitHub organization’s administrator. Start the initial configuration as described in Configuring your first Xcode Cloud workflow. When Xcode Cloud asks for permission to access your team’s repository, you can request that the organization owner or someone with the admin role installs the Xcode Cloud GitHub app that manages access to your team’s repositories. When the they’ve installed the app, you can complete the initial configuration.\n\nCreate an app record in App Store Connect\n\nXcode Cloud combines Xcode, TestFlight, and App Store Connect into a powerful CI/CD system. As a result, you need an app record for your app in App Store Connect to use Xcode Cloud. If you haven’t created an app record for your app, Xcode helps you create one when you configure your project or workspace to use Xcode Cloud.\n\nNote\n\nYou don’t need to create an app record to build a framework with Xcode Cloud.\n\nFor more information about the requirements for creating an app record, see Developer account requirements. If you can’t create an app record, let someone who has the required role or permission create an app record in App Store Connect. Then configure your project or workspace to use Xcode Cloud as described in Configuring your first Xcode Cloud workflow.\n\nConnect your personal SCM account to Xcode Cloud\n\nXcode Cloud uses your personal SCM account to monitor the Git repository for changes. As a result, you need to connect your Xcode Cloud to your SCM account. To do this, open a project or workspace that another team member configured to use Xcode Cloud. If you haven’t connected your personal SCM account to Xcode Cloud, Xcode displays the Cloud Issues button in the toolbar. Click the button, and authorize Xcode Cloud to link your source control account with your Apple ID.\n\nSee Also\nSetup and maintenance\nConfiguring your first Xcode Cloud workflow\nConfigure your project or workspace to use Xcode Cloud and adopt continuous integration and delivery.\nMaking dependencies available to Xcode Cloud\nReview dependencies and make them available to Xcode Cloud before you configure your project to use Xcode Cloud.\nBuilding Swift packages and Swift Playgrounds app projects with Xcode Cloud\nAdd your Swift package or Swift Playgrounds app project to an Xcode project to build it in Xcode Cloud.\nSetting the next build number for Xcode Cloud builds\nStart numbering builds from a custom build number for your existing Mac app to avoid version collisions.\nIncluding notes for testers with a beta release of your app\nAdd text files to your Xcode project to provide notes to beta testers about what to test.\nRemoving your project from Xcode Cloud\nRemove your project from Xcode Cloud to delete app and workflow data, disconnect your Git repository, and remove the Slack integration."
  },
  {
    "title": "Reviewing Xcode Cloud usage data | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reviewing-xcode-cloud-usage-data",
    "html": "Overview\n\nXcode Cloud parallelizes tasks to build and verify your app and uses Apple infrastructure to build, test, and distribute your app to create a continuous integration and delivery (CI/CD) process that helps you create a high-quality app. Because Xcode Cloud performs build steps and actions in parallel to give you faster results, the time it takes to complete a build and the usage time Xcode Cloud reports are different. Depending on the subscription plan you choose, you have a certain amount of Xcode Cloud usage at your disposal. This makes it important to review your Xcode Cloud usage for yourself and your team.\n\nTo learn more about available Xcode Cloud subscription plans, see Get started with Xcode Cloud.\n\nAccess usage information and purchase subscription plans in the Apple Developer app\n\nThe Apple Developer app allows you to access Xcode Cloud usage information for your team and offers functionality to purchase additional usage time. To view your team’s usage, go to Account, then navigate to the Xcode Cloud section. If you have the Account Holder role and your team uses Xcode Cloud, use the app to purchase a subscription plan that offers additional Xcode Cloud usage time.\n\nAccess more detailed usage data in App Store Connect\n\nApp Store Connect allows you to access Xcode Cloud usage information. It shows usage trends and allows you to access detailed usage information for your team and each individual app — for example, the number of created builds and the build duration. Additionally, export usage information as a .csv file — for example, to create custom reports.\n\nAfter logging into App Store Connect:\n\nGo to Users and Access, then navigate to the Xcode Cloud tab to view your team’s overall Xcode Cloud usage.\n\nSelect an app, and navigate to the app’s Xcode Cloud tab to view Xcode Cloud usage for the app.\n\nNote\n\nEvery team member with access to App Store Connect can view usage data for the team but they can only view usage information for apps they have access to.\n\nThe following screenshot shows the usage dashboard for the Food Truck sample code app from Food Truck: Building a SwiftUI multiplatform app. It displays the number of builds and the usage for 30 days — including trends."
  },
  {
    "title": "Including notes for testers with a beta release of your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/including-notes-for-testers-with-a-beta-release-of-your-app",
    "html": "Overview\n\nYou can include notes when you distribute a beta version of your app from Xcode Cloud through TestFlight to give testers details about the changes the update includes, and to provide guidance for the areas of your app to test. Use these notes to focus testing on the areas of your app that need attention. The notes appear in the “What to test” field in the TestFlight app. The information you provide can be language- and locale-specific.\n\nFor more information about distributing a beta version of your app, see Creating a workflow that builds your app for distribution.\n\nRelated sessions from WWDC23\n\nSession 10224: Simplify distribution in Xcode and Xcode Cloud\n\nCreate a TestFlight folder\n\nXcode Cloud uses text files that you add to your Xcode project to create the notes for testers. The text files reside in a folder named TestFlight located in the same folder as your Xcode project or workspace.\n\nTo create the TestFlight folder:\n\nOpen your project or workspace in Xcode.\n\nIn the Project navigator, Control-click your project and choose New Group to create the group and its corresponding folder.\n\nName the new group TestFlight.\n\nAdd text files to the folder to include notes\n\nAdd text files to the TestFlight folder to provide notes to your testers. Provide notes in multiple languages by creating a file per language. For a list of the locales TestFlight supports, see BetaBuildLocalizationCreateRequest.Data.Attributes. For general information on language and region codes, see Choosing localization regions and scripts.\n\nTo add the text files to your project:\n\nAdd a new Empty file to the TestFlight folder. For instructions, see Managing files and folders in your Xcode project.\n\nName the file using the format WhatToTest.<LOCALE>.txt. For LOCALE, use the language and region code for the content you provide in the file. For example, use WhatToTest.en-US.txt for U.S. English.\n\nCommit and push the file to your remote repository.\n\nThe next time Xcode Cloud builds and uploads your app to TestFlight, it automatically finds this file and includes the text in your app’s “What to test” field in TestFlight.\n\nProvide useful and appropriate content\n\nInclude information that is useful to testers and relevant to the current release, such as the following:\n\nFeatures you add to your app.\n\nIssues you resolve in your code.\n\nThe commit message for the commit that triggers the build, or the past few commit messages.\n\nNote\n\nWhen Xcode Cloud deploys your app, the information you provide is available to all testers in all groups who have access to the build.\n\nWrite a script to generate content dynamically\n\nYou can use a custom build script to generate the notes during an Xcode Cloud build. The following example provides the last three commit messages from the GIT log as the tester notes:\n\n#!/bin/zsh\n#  ci_post_xcodebuild.sh\n\n\nif [[ -d \"$CI_APP_STORE_SIGNED_APP_PATH\" ]]; then\n  TESTFLIGHT_DIR_PATH=../TestFlight\n  mkdir $TESTFLIGHT_DIR_PATH\n  git fetch --deepen 3 && git log -3 --pretty=format:\"%s\" >! $TESTFLIGHT_DIR_PATH/WhatToTest.en-US.txt\nfi\n\n\nFor more information, see Writing custom build scripts.\n\nSee Also\nSetup and maintenance\nConfiguring your first Xcode Cloud workflow\nConfigure your project or workspace to use Xcode Cloud and adopt continuous integration and delivery.\nMaking dependencies available to Xcode Cloud\nReview dependencies and make them available to Xcode Cloud before you configure your project to use Xcode Cloud.\nConfiguring Xcode Cloud for your team\nStart using continuous integration and delivery with Xcode Cloud as a team.\nBuilding Swift packages and Swift Playgrounds app projects with Xcode Cloud\nAdd your Swift package or Swift Playgrounds app project to an Xcode project to build it in Xcode Cloud.\nSetting the next build number for Xcode Cloud builds\nStart numbering builds from a custom build number for your existing Mac app to avoid version collisions.\nRemoving your project from Xcode Cloud\nRemove your project from Xcode Cloud to delete app and workflow data, disconnect your Git repository, and remove the Slack integration."
  },
  {
    "title": "Building Swift packages and Swift Playgrounds app projects with Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/building-swift-packages-or-swift-playground-app-projects-with-xcode-cloud",
    "html": "Overview\n\nXcode Cloud comes with support for the Swift Package Manager, and using Swift package dependencies in your app project requires little to no configuration. However, Xcode Cloud can’t build standalone Swift packages. To build your Swift package with Xcode Cloud:\n\nCreate an app project or workspace in Xcode.\n\nAdd your Swift package as a local package as described in Organizing your code with local packages.\n\nCommit your Package.resolved file.\n\nCreate your first workflow as described in Configuring your first Xcode Cloud workflow.\n\nWhen Xcode Cloud starts a build, it builds your Swift package as part of the app project.\n\nSimilarly, Xcode Cloud can’t build standalone apps you create with Swift Playgrounds. To build an app you created with Swift Playgrounds, save the Swift Playground app project to your Mac, add it to an Xcode project as described above, then configure your first workflow for the Xcode project.\n\nNote\n\nTo learn more about building projects with Xcode Cloud that require Swift package dependencies, see Use Swift package dependencies and Git submodules.\n\nSee Also\nSetup and maintenance\nConfiguring your first Xcode Cloud workflow\nConfigure your project or workspace to use Xcode Cloud and adopt continuous integration and delivery.\nMaking dependencies available to Xcode Cloud\nReview dependencies and make them available to Xcode Cloud before you configure your project to use Xcode Cloud.\nConfiguring Xcode Cloud for your team\nStart using continuous integration and delivery with Xcode Cloud as a team.\nSetting the next build number for Xcode Cloud builds\nStart numbering builds from a custom build number for your existing Mac app to avoid version collisions.\nIncluding notes for testers with a beta release of your app\nAdd text files to your Xcode project to provide notes to beta testers about what to test.\nRemoving your project from Xcode Cloud\nRemove your project from Xcode Cloud to delete app and workflow data, disconnect your Git repository, and remove the Slack integration."
  },
  {
    "title": "Fixing issues in your code as you type | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/fixing-issues-in-your-code-as-you-type",
    "html": "Overview\n\nXcode includes a number of features that help reduce typical coding mistakes, such as when you misspell a symbol name or forget to add a closing delimiter. By leveraging these features, you can focus more time on adding value to your app and less time fixing easily avoidable issues. With your explicit consent, Xcode can help you locate the correct symbol, fix common errors, and automatically match braces, parentheses, and brackets, by directly changing your code.\n\nAvoid syntax errors by using code completion\n\nWhen you begin typing the name of a symbol in the source editor, Xcode displays a list of suggestions for completing the name. You can dismiss this list by pressing Escape or clicking elsewhere in the source editor. If the possible completions share a common string, Xcode highlights that string. If there isn’t a common string, Xcode highlights the matching parts of the string instead.\n\nUse the Up Arrow and Down Arrow keys to navigate through the list of possible completions. Alternatively, you can click an item in the list to select it. A selected item displays its description below the list.\n\nTo insert a suggested completion into your source code, select the item and press Return. You can double-click an item to achieve the same. If you don’t see the desired completion, or the list is too long, continue typing to refine the list of suggestions.\n\nIf the inserted symbol contains parameters or arguments, Xcode adds a placeholder for each one. Use the Tab key to cycle through the placeholders, and Shift-Tab to cycle through them in reverse order. Alternatively, you can choose Navigate > Jump to Next Placeholder or Navigate > Jump to Previous Placeholder.\n\nTo prevent Xcode from suggesting completions as you type, follow these steps:\n\nChoose Xcode > Preferences or press Command-Comma.\n\nSelect Text Editing > Editing.\n\nDeselect the “Suggest completions while typing” preference.\n\nEven if you disable automatic suggestions, you can invoke code completion at any time when in the source editor by pressing Control-Space or Escape. The “Use Escape key to show completion suggestions” preference manages the behavior of the Escape key in this context.\n\nMatch braces, parentheses, and brackets automatically\n\nXcode helps you identify and balance opening and closing delimiters — braces, parentheses, and brackets — within your code. You can take advantage of this functionality by doing one or more of the following:\n\nType an opening delimiter and press Return or any character to automatically insert a closing delimiter.\n\nType a closing delimiter, or move the insertion point immediately after an existing closing delimiter, to briefly highlight the opening delimiter in the source editor.\n\nConversely, move the insertion point immediately after an opening delimiter to temporarily highlight the closing delimiter.\n\nMove the insertion point between two delimiters and choose Editor > Selection > Balance Delimiters to select those delimiters and the code in between. Alternatively, double-click one of the delimiters to achieve the same.\n\nSelect code in the source editor and type an opening delimiter to automatically enclose the selection in a pair of matching delimiters.\n\nTo prevent Xcode from automatically inserting delimiters, follow these steps:\n\nChoose Xcode > Preferences or press Command-Comma.\n\nSelect Text Editing > Editing.\n\nDeselect the “Automatically insert closing braces” and “Enclose selection in matching delimiters” preferences. If you write code in Objective-C, deselect “Automatically balance brackets in Objective-C method calls” in addition to the other two preferences.\n\nMake a Fix-It correction\n\nFix-It is an Xcode feature that offers suggested fixes for syntax errors as you write code. The source editor highlights any issues with a red underline and presents an issue summary and icon. Clicking the icon displays more information about the problem and, in many cases, presents a Fix-It that’ll repair the issue for you.\n\nImportant\n\nTo use Fix-It, you must build your target with either the LLVM or Swift compiler. Fix-It is compatible with Swift, C, Objective-C, and Objective-C++.\n\nTo apply a suggested Fix-It correction:\n\nEnter code into the source editor, which marks any issues with a red underline and displays a summary of the problem to the right.\n\nWhen a summary appears, click the icon to display a more comprehensive description of the issue, along with any suggested corrections.\n\nClick the Fix button to select a correction, and Xcode makes the necessary updates to your source code.\n\nIf your source code contains multiple issues, navigate between them by choosing Navigate > Jump to Next Issue or Navigate > Jump to Previous Issue. To dismiss the Fix-It dialog, press the Escape key."
  },
  {
    "title": "Testing in-app purchases with StoreKit transaction manager in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/testing-in-app-purchases-with-storekit-transaction-manager-in-code",
    "html": "Overview\n\nXcode provides a transaction manager that you use with StoreKit Testing in Xcode. With transaction manager, you can test in-app purchases at any stage of development. Testing in-app purchases before pushing your app live helps you ensure a seamless purchase flow, test various edge cases and logic, and validate that purchases behave correctly.\n\nUse the transaction manager to change settings and initiate test conditions, inspect transactions, and simulate different kinds of purchases.\n\nNote\n\nYou need to set up StoreKit in Xcode before you can use the transaction manager for testing. For more information, see Setting up StoreKit Testing in Xcode.\n\nChange settings and initiate test conditions\n\nSelect your StoreKit configuration file in the Project navigator and choose Editor to change the following settings:\n\nDefault Storefront\n\nSets the storefront property on the transaction.\n\nDefault Localization\n\nSets the localization that affects the currency display in the payment sheet and the values that return in the localized properties of Product. You provide the localized data in your StoreKit configuration file.\n\nSubscription Renewal Rate\n\nChanges the rate at which time passes for subscriptions in the test environment compared to real time.\n\nEnable Interrupted Purchases\n\nCauses the test environment to simulate a condition that prevents the customer from completing a purchase. Conditions that cause an interrupted purchase include a payment card expiring, or a customer needing to approve updated terms and conditions. Choose the Resolve Issue option in Debug > StoreKit > Manage Transactions to simulate the customer resolving the issue.\n\nEnable Billing Retry on Renewal\n\nCauses the test environment to simulate a condition where the customer’s payment for a renewal doesn’t succeed, and the subscription enters the billing retry state. Choose the Resolve Issue option in Debug > StoreKit > Manage Transactions to simulate a successful billing retry.\n\nEnable Billing Grace Period\n\nEnables Billing Grace Period for your app in the Xcode testing environment. To test this condition, set Enable Billing Retry on Renewal. When the subscription fails to renew, it goes into the billing retry state with Billing Grace Period enabled.\n\nEnable Ask to Buy\n\nCauses the test environment to display the Ask to Buy prompt when the tester attempts a purchase. Choose the Approve Transaction or Decline Transaction option in the Debug > StoreKit > Manage Transactions menu to resolve the transaction.\n\nSubscription Offers Key\n\nProvides a key that you use for signing a subscription offer in the test environment. Use this key instead of your regular key to generate the signature on your server. See Generating a signature for promotional offers for more information.\n\nSimulate StoreKit failures\n\nCauses the test environment to apply the error conditions you specify to enable you to test your app’s error handling.\n\nInspect transactions with the transaction manager\n\nUse the options in the transaction manager to perform steps in an in-app purchase flow that normally occur outside your app, such as approving or declining Ask To Buy transactions, receiving refunds, and more. To open the transaction manager, choose Debug > StoreKit > Manage Transactions.\n\nThe transaction manager lists all the transactions for the running app. If you have multiple apps running on multiple devices, select the app in the sidebar to view its transactions. Use the transaction manager to perform these actions:\n\nFilter transactions — Type a search term in the filter box at the bottom of the dialog to narrow the number of transactions that display.\n\nInspect a transaction — Click a transaction, then view that transaction’s details in the inspector. Click the jump button next to a product or group to navigate to it in the StoreKit configuration file in Xcode.\n\nCreate a transaction — Click the plus button on the left of the filter bar. Select the product you want to create a transaction for, and then configure the transaction. Use this feature to test in-app purchases made outside of the device, and to simulate in-app purchases that customers complete on different devices. For more information about creating transactions, see Simulate a purchase.\n\nDelete a transaction — Select a transaction and click Delete to retest a scenario that the customer can perform only once. For example, customers can purchase a non-consumable product only once, so delete that transaction to retest the purchase. Delete subscription transactions to retest introductory offers. For more information, see Implementing introductory offers in your app. If your app uses the Original API for in-app purchase, refresh the receipt to get an updated receipt without the deleted transaction.\n\nSend a purchase intent — Simulate sending purchase intents to your app to ensure your app processes them correctly. For more information about receiving and handling purchase intents in your app, see PurchaseIntent. For more information about sending a purchase intent in the testing environment, see Send a purchase intent.\n\nApprove or decline a transaction — Click Approve or Decline to resolve a pending transaction that’s testing an Ask to Buy scenario.\n\nRefund a transaction — Click Refund to simulate a customer receiving a refund.\n\nResolve a transaction — Click Resolve to simulate a customer resolving an interrupted purchase. To simulate the interruption, choose Editor > Enable Interrupted Purchases.\n\nTest a price increase — Select a subscription transaction, then click the Request Price Increase Consent button in the toolbar. Test using the price increase sheet that the system presents in your app, or use the buttons to simulate the customer’s response from outside the app, such as from a push notification. Click the Approve button to indicate that the customer accepts the price increase. Click the Decline button to simulate the customer canceling the subscription.\n\nThe test environment automatically syncs the transaction changes you make. You don’t need to rebuild and run your app.\n\nSimulate a purchase\n\nThe StoreKit configuration file lets you define in-app purchases in two sections. Use the Products section to define consumable and non-consumable in-app purchases. Use the Subscriptions section to define auto-renewable subscriptions and non-renewing subscriptions.\n\nTo make a one-time in-app purchase, select the app from the left-hand side that you want to test, then click the plus button on the left of the filter bar. From the product screen that displays, select the product you want to buy, then click Next.\n\nOn the configuration pop-up that displays, you can either accept the defaults, or change the properties to reflect the purchase you want. After you configure your in-app purchase, click the Done button.\n\nIf your device or simulator aren’t running, the transaction appears as a new item at the top of the transaction manager screen in the unfinished state. Unfinished transactions appear with a warning symbol next to them. To complete the transaction, run your app on a device or simulator. You can then test that your app successfully completes the transaction.\n\nTo create a test subscription purchase, return to the transaction manager main screen, click the plus button again, but this time choose an auto-renewable subscription from the products list, and then click Next.\n\nWhen the subscription configuration pop-up appears, either accept the defaults, or change the properties to reflect the kind of subscription you want. For example, if your subscription has multiple offer types, you can optionally select an offer code from the offer drop-down menu. To test different renewal options, select Automatically Renew to test how renewals behave by default in production, or select Don’t Renew, which creates one purchase, and then cancels the subscription. Click Done to trigger the subscription purchase.\n\nTo complete the test purchase, launch the app on the device or simulator where your purchases occur, and see the purchase complete in the transaction manager and appear in the app.\n\nSend a purchase intent\n\nMaking in-app purchases isn’t the only way people can buy content for you app or game. As a developer, you can promote in-app purchases from the App Store. When a custom sees an in-app purchase in the App Store, they can initiate a purchase. The App Store then sends that purchase intent to the customer on their device. When the customer opens their device, they complete the purchase.\n\nNote\n\nTo send a purchase intent, your app needs to implement the PurchaseIntent API.\n\nThis action of sending the purchase from the App Store to your app is called a purchase intent. And you can test this interaction in the transaction manager as follows:\n\nClick the plus sign to create a new purchase.\n\nChoose the product to send a purchase intent for.\n\nChange the purchase type below the product list to Purchase Intent.\n\nClick Done and check your device to continue.\n\nOnce the customer confirms the purchase on their device, the purchase completes. After that, the transaction appears.\n\nSee Also\nStoreKit\nSetting up StoreKit Testing in Xcode\nPrepare your test environment to test in-app purchases with data you configure locally."
  },
  {
    "title": "Enabling Developer Mode on a device | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/enabling-developer-mode-on-a-device",
    "html": "Overview\n\nDeveloper Mode, available in iOS 16 and later, watchOS 9 and later, and visionOS, protects people from inadvertently installing potentially harmful software on their devices, and reduces attack vectors exposed by developer-only functionality. The feature doesn’t affect ordinary installation techniques like buying apps from the App Store, or participating in a TestFlight team. Instead, Developer Mode focuses on scenarios like performing a Build and Run in Xcode, or installing an .ipa file with Apple Configurator. In these cases, the device explicitly asks the person using it to confirm that they’re a developer, aware of the risks of installing development-signed software.\n\nEnable Developer Mode\n\nWhen you connect an iOS, visionOS, or watchOS device with Developer Mode disabled to your Mac, the Xcode scheme selector’s destination list shows it as an “Unavailable Device”.\n\nThe Devices and Simulators window shows a similar banner if you have a device connected with Developer Mode disabled.\n\nIf you attempt to build and run to the device, Xcode displays an alert to tell you the destination isn’t valid because Developer Mode is disabled.\n\nRunning your app on the device requires that you enable Developer Mode. On an iOS or visionOS device, open Settings > Privacy & Security, scroll down to the Developer Mode list item and navigate into it. On a watchOS device that you use for development, go to Settings > Privacy > Developer Mode. To toggle Developer mode, use the Developer Mode switch.\n\nTap the switch to enable Developer Mode. After you do so, Settings presents an alert to warn you that Developer Mode reduces the security of your device. To continue enabling Developer Mode, tap the alert’s Restart button.\n\nAfter the device restarts and you unlock it, the device shows an alert confirming that you want to enable Developer Mode. To acknowledge the reduction in security protection in exchange for allowing Xcode and other tools to execute code, tap Turn On, and enter your device passcode when prompted.\n\nAt this point, your device is ready to install and run apps from Xcode. After you have enabled Developer Mode the first time, Xcode doesn’t ask again unless you disable Developer Mode — as described below — or you restore the device. You can Build and Run from Xcode without further prompts to enable Developer Mode.\n\nDisable Developer Mode\n\nIf you want to disable Developer Mode, you do so directly on the device. Go to Settings > Privacy & Security > Developer Mode to show the Developer Mode toggle switch.\n\nLike enabling, disabling Developer Mode requires a device reboot before it becomes effective. After you disable Developer Mode, you can’t run apps from Xcode on the device until you reenable it, using the same switch in the device’s Settings.\n\nSee Also\nEssentials\nRunning your app in Simulator or on a device\nLaunch your app in a simulated iOS, tvOS, watchOS, or visionOS device, or on a device connected to a Mac."
  },
  {
    "title": "Running your app in Simulator or on a device | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/running-your-app-in-simulator-or-on-a-device",
    "html": "Overview\n\nTo test your app, build and run it on a simulated or real device. Use simulated devices to debug your app on a variety of hardware to which you don’t have immediate access. The tradeoff is that simulated devices run within the Simulator app on your Mac and don’t replicate the performance or features of an actual device. To verify your app runs exactly as intended, run it on one or more real devices. You can connect a real device to your Mac using a cable, or for iOS, tvOS, or visionOS apps, connect it over Wi-Fi after you pair it with Xcode.\n\nSwiftUI previews let you see your app’s interface without building and running your app. For more information on these dynamic previews, see Previews in Xcode.\n\nSelect a build scheme and run destination\n\nBefore you build and run your app, select a build scheme that includes the target for your app. A scheme is a collection of project details and settings that tell Xcode how to build and run a product from your project. Xcode determines where the resulting product can run based on the scheme you select, and populates the run destination menu in the toolbar with the list of available devices. For example, if the scheme contains a tvOS app, Xcode includes only tvOS simulators and devices as potential run destinations.\n\nTo learn more about schemes, see Customizing the build schemes for a project.\n\nImportant\n\nWhen running apps in Simulator, some hardware-specific features might not be available. Frameworks that provide access to device-specific features also provide API to tell you when those features are available. Call those APIs and handle the case where a feature isn’t available. To test the feature itself, run your code on a real device.\n\nConfigure the list of simulated devices\n\nManage real and simulated devices in the Devices and Simulators window in Xcode. To view this window, choose Window > Devices and Simulators. View and configure simulated devices from the Simulators tab.\n\nTo add a new simulated device, click the plus (+) button at the bottom of the list of simulators and specify the configuration you want. You can add new simulators to specify a different device type or operating system version than the default set. To remove a simulator from the list, select it and press Delete.\n\nNote\n\nXcode requires the Simulator runtime for each platform and system version for which you build and run Simulator. If Xcode doesn’t display device types for a platform, you might need to install that platform’s Simulator runtime. For more information on this installation, see Installing and managing Simulator runtimes.\n\nConnect real devices to your Mac\n\nTo view and manage connections to your real devices, choose the Devices tab in the Devices and Simulators window in Xcode. The Devices tab shows the currently connected and disconnected devices and can help you diagnose problems that might occur. For example, Xcode might show a device as unavailable if it’s not running an operating system version your app supports. It also shows new devices available for pairing with your Xcode installation. Pair a device with Xcode to include them in the list of run destinations for your projects.\n\nTo pair a device with a physical connection, connect the device to your Mac using an appropriate cable. Unlock the device and follow any instructions that appear in Xcode or on the device.\n\nTo pair Apple Vision Pro or Apple TV without a physical connection:\n\nEnsure that both your Mac and the device to connect are on the same Wi-Fi network. The Wi-Fi network must be compatible with Bonjour.\n\nBroadcast the device to the target Mac over the local network. To do this for a visionOS device, choose Settings > General > Remote Devices and for a tvOS device, choose Settings > Remotes and Devices > Remote App and Devices.\n\nSelect the device from the list in the Devices and Simulators window in Xcode and click the pairing button which triggers a code to appear on the target device.\n\nEnter the code on the Mac to complete the pairing process.\n\nAfter pairing is complete, the device shows up under connected devices in Devices and Simulators window in Xcode. You don’t need to keep a paired device physically connected to your Mac to install and run apps. If your device is connected to Wi-Fi on the same network as your Mac, Xcode can use that connection to install and run your app.\n\nTo pair an Apple Watch to a Mac, connect its companion iPhone to the Mac with a cable, and ensure that the iPhone is paired for development. After this step, follow any instructions on the Apple Watch to trust the Mac. When paired through an iPhone running iOS 17 or later, Xcode connects to the Apple Watch over Wi-Fi. Series 5 and older models of Apple Watch additionally require the Apple Watch and Mac to be associated with the same Bonjour-compatible Wi-Fi network. When paired through an iPhone running older versions of iOS, Xcode requires the iPhone to remain connected to the Mac in order to develop on any model of Apple Watch.\n\nBefore installing your app, perform a few additional steps:\n\nSpecify your Apple ID in the Account preferences in Xcode.\n\nSpecify a valid team in your project’s Signing & Capabilities pane.\n\nCode sign your macOS app if it includes capabilities that require code signing; see Adding capabilities to your app.\n\nRegister the device with your team if you belong to the Apple Developer Program.\n\nEnable Developer Mode on an iOS, watchOS, or visionOS device, as described in Enabling Developer Mode on a device.\n\nNote\n\nYou don’t need to configure a Mac device to run your macOS apps. Similarly, to run the macOS version of an iPad app, choose My Mac (the Mac running Xcode) as the device.\n\nRun the app\n\nClick the Run button in the toolbar or choose Product > Run to build and run the app on the selected simulated or real device. View the status of the build in the activity area of the toolbar.\n\nIf the build is successful, Xcode runs the app and opens a debugging session in the debug area. Use the controls in the debug area to step through your code, inspect variables, and interact with the debugger.\n\nIf the build is unsuccessful, click the indicators in the activity area to read the error or warning messages in the Issue navigator. Alternatively, choose View > Navigators > Show Issue Navigator to view the messages.\n\nWhen you’re done testing the app, click the Stop button in the toolbar.\n\nInteract with the simulated environment\n\nIf you choose a simulated device as the run destination, Simulator launches and displays a window that corresponds to the simulated environment. For some devices, Simulator surrounds the screen content with a shell that resembles the target device. In visionOS, it displays a synthetic space to mimic the experience someone would have when they wear the device.\n\nEach device shell and space has specific controls to support interactions. For device-specific details, see the reference on interactions.\n\nInteracting with your app in the iOS and iPadOS simulator\n\nInteracting with your app in the tvOS simulator\n\nInteracting with your app in the watchOS simulator\n\nInteracting with your app in the visionOS simulator\n\nSee Also\nEssentials\nEnabling Developer Mode on a device\nGrant or deny permission for locally installed apps to run on iOS, iPadOS, visionOS, and watchOS devices."
  },
  {
    "title": "Installing your app in many Simulator platforms and versions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/installing-your-app-in-many-simulator-platforms-and-versions",
    "html": "Overview\n\nWhen you’re ready to test your app in different devices to confirm that it handles screen size and other environmental differences correctly, you could select each Simulator run destination that you want and then choose Product > Run to install your app in that Simulator run destination. When you test across several Simulator run destinations at the same time, that can be time consuming. Instead, install your app in multiple target Simulator run destinations using drag and drop or share.\n\nPrepare your app for installation\n\nBuild your app so that you have a product you can install in a simulated device. To build your app:\n\nIn Xcode, select a build scheme and Simulator run destination.\n\nChoose Product > Build.\n\nFor more information on building and running your app in Simulator, see Running your app in Simulator or on a device.\n\nInstall your app with drag and drop or share\n\nFirst, launch each device variant you want to install your app into in Simulator. Choose File > Open Simulator, and select a device variant.\n\nThen, navigate to the built product in Finder. In Xcode, choose Product > Show Build Folder in Finder, then select the Products folder in the Finder window that Xcode displays. Select the folder for the build scheme and destination for which you built the product, then select your application file.\n\nDrag the application bundle over a Simulator window to install your app in that simulated device.\n\nAlternatively, use share to install your app:\n\nControl-click your application file and select Share…\n\nChoose Simulator from the list of sharing options.\n\nFrom the Choose Simulator drop-down, choose All Simulators to install your app in each open device, or choose a specific device.\n\nClick Send to install your app in the selected Simulator.\n\nSee Also\nSimulator management\nInstalling and managing Simulator runtimes\nKeep the Simulator platforms and versions you need to run and test your apps up to date in Xcode."
  },
  {
    "title": "Testing your apps in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/testing-your-apps-in-xcode",
    "html": "Overview\n\nXCTest facilitates your ability to write tests at different levels of abstraction. A good testing strategy combines multiple types of tests, to maximize the benefits of each.\n\nAim for a “pyramid” distribution of tests, as shown in the figure below. Include a large number of fast, well-isolated unit tests to cover your app’s logic, a smaller number of integration tests to demonstrate that smaller parts are connected together properly, and UI tests to assert the correct behavior of common use cases.\n\nUI tests are the ultimate indicator your app works for users in the way you expect, but they take longer to run than other kinds of tests. There are various app variables that can introduce a failure in the same UI test. The test pyramid balances high-fidelity tests that demonstrate that users can complete their tasks, with tightly-focused tests that give you fast feedback about the correctness of your app’s logic and the impact of changes you make.\n\nIn addition to the test pyramid, write performance tests to provide regression coverage of performance-critical regions of code. To learn about the process of identifying performance-critical code, see Improving your app’s performance.\n\nWrite a unit test\n\nEach unit test should assert the expected behavior of a single path through a method or function in your project. To cover multiple paths, write one test for each scenario. For example, if a function receives an optional parameter, you’d write a test in which the parameter is nil and a test in which it takes a non-nil value. Identify the boundary cases and logical branches in your code, and write a unit test to cover each combination of these cases.\n\nChoose the class or function to test, and create a subclass of XCTestCase that contains the tests for that class or function. Add a method to your XCTestCase subclass that takes no arguments and returns Void, giving the method a name that begins with the word “test”. In Xcode, choose New File, then select the Unit Test Case Class template to automatically create an appropriate class.\n\nThe test method should contain three steps, in the order described below:\n\nArrange. Create any objects or data structures that the code path you’re exercising uses. Replace complex dependencies with “stubs” that are easy to configure, to ensure that tests run quickly and are deterministic. Adopting protocol-oriented programming ensures that relationships between objects in your app are sufficiently flexible to enable substitution of real implementations for stubs.\n\nAct. Call the method or function that you’re testing, using parameters and properties that you configure in the Arrange phase.\n\nAssert. Use the Test Assertions in the XCTest framework to compare the behavior of the code you exercise in the Act phase with your expectations of what should happen. Any assertion whose condition is false causes a test to fail.\n\nThe resulting test method looks like this example:\n\nclass MyAPITests : XCTestCase {\n  func testMyAPIWorks() {\n    // Arrange: create the necessary dependencies.\n    // Act: call my API, using the dependencies created above.\n    XCTAssertTrue(/* … */, \"The result wasn't what I expected\")\n  }\n}\n\nWrite an integration test\n\nIntegration tests look very similar to unit tests, use the same APIs, and follow the same Arrange-Act-Assert pattern. The difference between a unit test and an integration test is one of scale. While a unit test covers a very small part of your app’s logic, an integration test examines the behavior of a larger subsystem, or combination of classes and functions. In the Arrange step of an integration test, widen the scope of real project code that’s under test, using fewer stub objects.\n\nRather than trying to cover every different condition or boundary case as with unit tests, use integration tests to assert that components work together to achieve app goals in important situations. Examples include testing that a value received from a controller is stored in the model correctly, and that an error produced by a network request gets passed to and presented by the user interface.\n\nWrite a UI test\n\nUI tests work in a different way from unit and integration tests, but they’re still organized as methods on subclasses of XCTestCase. Xcode’s UI Test Case Class template for new files contains the common starting points for UI tests. Rather than executing your app’s code directly, they use the app’s user-interface controls as a real user would, to determine whether the user can complete a specific task using the app.\n\nCreate UI tests to verify that important user tasks can be completed in the app, and that bugs haven’t been introduced that break the behavior of UI controls. UI tests that replicate real user activities provide confidence that the app can be used for its intended task. A UI test for a document-based app might verify that the user can create a new document, edit its content, then delete the document.\n\nTo create a UI test in a method on an XCTestCase subclass, record your interaction with the app using Xcode’s Record UI Test feature. Design UI tests to replicate the most critical workflows that would cause the biggest impact to your users if they broke, and to replay reported bugs so that you can avoid regressions.\n\nWhen you’ve recorded a workflow that exercises the functionality you’re testing, use the test assertion functions to ensure that the final state of the UI is what you’d expect, given the actions performed during the recorded interaction.\n\nWhere UI tests imitate complex workflows comprising multiple distinct steps, use XCTActivity to organize and name the shared steps. Create helper methods to share implementations of activities that are used in multiple tests.\n\nWrite a performance test\n\nWrite performance tests to gather information on time taken, memory used, or data written, during the execution of a region of code. XCTest runs your code multiple times, measuring the requested metrics. You can set a baseline expectation for the metric, and if the measured value is significantly worse than the baseline, XCTest reports a test failure.\n\nTo test time taken by your code, call measure(_:) inside your test method, and run your app’s code inside the block argument to measure(_:). To measure performance using other metrics, including memory use and amount of data written to disk, call measure(metrics:block:).\n\nclass PerformanceTests : XCTestCase {\n  func testCodeIsFastEnough() {\n    self.measure() {\n      // performance-sensitive code here\n    }\n  }\n}\n"
  },
  {
    "title": "Installing and managing Simulator runtimes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/installing-additional-simulator-runtimes",
    "html": "Overview\n\nA Simulator runtime is an embedded OS package that Simulator loads when running your app on a simulated device in Xcode. For example, when you test your app on a simulated iPhone running iOS 17, Simulator loads the iOS 17 Simulator runtime on the simulated device.\n\nTo minimize download size, Xcode splits the Simulator runtimes for each platform into individual installs. This allows you to install only the Simulator runtimes specific to the platform you’re developing for. Xcode requires the current versions of Simulator runtimes to build projects and to run Simulator for those platforms. To create a simulator for iPhone with a paired Apple Watch, Xcode needs the Simulator runtime for both platforms.\n\nIf you download Xcode from the Apple Developer website or the Mac App Store, you can download and install these files when you first launch Xcode, or install them later from the Xcode run destination, from Xcode Settings, or from the command line.\n\nManage the amount of storage that Xcode requires by choosing Xcode > Settings > Platforms to view the currently installed Simulator runtimes, and remove any that you don’t need. You can reinstall or install additional Simulator runtimes at any time.\n\nNote\n\nDeveloping for visionOS requires a Mac with Apple silicon.\n\nInstall Simulator runtimes during first launch\n\nWhen you launch Xcode 14 or later for the first time, Xcode presents a dialog that indicates which Simulator runtimes are built-in, and which Simulator runtimes you may download. Select the checkbox next to a downloadable Simulator runtime, and then click Continue to download and install it. Xcode displays a status dialog while it downloads and installs the files for each platform you select.\n\nYou may create a new Xcode project or work with an existing Xcode project on a platform that Xcode is installing, but you may not run or build the project until Xcode finishes downloading and installing the files.\n\nInstall a Simulator runtime from the Xcode run destination\n\nWhen you open an Xcode project for a platform that doesn’t have any installed Simulator runtimes, Xcode displays a Get button next to the run destination. Click the Get button to download and install the most current Simulator runtime for that platform.\n\nThe run destination in your Xcode project indicates when Xcode is downloading a Simulator runtime. You can select a run destination when the download and installation completes.\n\nInstall and manage Simulator runtimes in settings\n\nChoose Xcode > Settings > Platforms to see a list of Simulator runtimes that are currently installed and available to download. Xcode shows the amount of storage you can recover if you remove an installed Simulator runtime, and displays Built-In for a Simulator runtime that Xcode requires.\n\nTo recover storage space from unused Simulator runtimes, select a Simulator runtime, click the Delete button (-) in the lower left corner, and click Delete in the confirmation dialog.\n\nTo install the current version of a Simulator runtime, click its Get button. For previous versions, click the Add button (+) in the lower left corner, and then select a platform to view a list of its available versions. Select a version, and click Download & Install. You can run projects on previous versions of the Simulator runtime, but you need to install the current version to build them.\n\nInstall and manage Simulator runtimes from the command line\n\nDownload the Simulator runtime you want to install from the Apple Developer website. Then follow these steps with the command line to install it:\n\nSelect a version of Xcode.\n\nRun the first launch experience to install the required system components, including simctl.\n\nInstall the Simulator runtime with simctl.\n\nsimctl verifies the signature of the downloaded Simulator runtime, and then installs it in a secure location on your computer.\n\nFor example:\n\n    xcode-select -s /Applications/Xcode-beta.app\n    xcodebuild -runFirstLaunch\n    xcrun simctl runtime add \"~/Downloads/watchOS 9 beta Simulator Runtime.dmg\"\n\n\nTip\n\nTo learn more about additional runtime management features, run xcrun simctl runtime.\n\nTo download and install all the platforms that the Xcode version you selected supports, use the -downloadAllPlatforms option on xcodebuild.\n\n    xcodebuild -downloadAllPlatforms\n\n\nTo download and install Simulator runtimes for a specific platform, use the -downloadPlatform option and specify the platform.\n\n    xcodebuild -downloadPlatform iOS\n\nSee Also\nSimulator management\nInstalling your app in many Simulator platforms and versions\nSet up your app in multiple Simulator platforms and versions without the build-and-run cycle."
  },
  {
    "title": "Interacting with your app in the tvOS simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/interacting-with-your-app-in-the-tvos-simulator",
    "html": "Overview\n\nSimulator offers an environment to run apps in tvOS without installing them on a physical device. When running your app in Simulator, use your Mac to navigate the app’s interface.\n\nNavigate your interface\n\nUse the pointer, keyboard, and menu items to make gestures on a simulated tvOS device.\n\nGesture\n\n\t\n\nTo simulate\n\n\n\n\nMove the focus to the left\n\n\t\n\nPress the Left Arrow key.\n\n\n\n\nMove the focus to the right\n\n\t\n\nPress the Right Arrow key.\n\n\n\n\nMove the focus up\n\n\t\n\nPress the Up Arrow key.\n\n\n\n\nMove the focus down\n\n\t\n\nPress the Down Arrow key.\n\n\n\n\nTrigger the action for the current focus\n\n\t\n\nPress the Return key.\n\n\n\n\nMove up one level in the navigation hierarchy\n\n\t\n\nPress the Escape key.\n\nSimulator also provides a simulated tvOS remote, which you display by choosing Windows > Show Apple TV Remote. To simulate interactions with the touch surface, move the pointer along the surface while pressing the Option key. Select a focus item by Option-clicking. Open a contextual menu by Option-clicking and holding. Use the other buttons of the remote to simulate the corresponding functions.\n\nNavigate using a physical remote control\n\nTo use a physical Apple TV Remote or MFi controller with Simulator:\n\nUnpair the remote or controller if it is already paired with another device.\n\nTurn off the remote or controller.\n\nOn the Mac, open Bluetooth in System Preferences.\n\nIn Bluetooth Preferences, turn Bluetooth on.\n\nTurn on the remote or controller.\n\nIn Bluetooth preferences, wait for the remote to appear in the Devices list.\n\nClick the Pair button next to the device to pair it with the Mac.\n\nSome remotes and controllers don’t appear in Bluetooth preferences unless you put them into pairing mode. To enter pairing mode on an Apple TV remote, hold down the Menu and Volume Up (+) buttons for 5 seconds. For information on how to enter pairing mode on other devices, see the documentation for your device.\n\nSee Also\nSimulator interactions\nInteracting with your app in the iOS and iPadOS simulator\nUse your Mac to control interactions with your iOS and iPadOS apps in Simulator.\nInteracting with your app in the watchOS simulator\nUse your Mac to control interactions with your watchOS apps in Simulator.\nConfiguring Simulator for your working environment\nAdjust Simulator settings for window or screen size, light or dark appearance, and audio settings, and restart or reset a simulated device.\nSimulating an external display or CarPlay\nTest how your app handles an external display or CarPlay from Simulator.\nCapturing screenshots and videos from Simulator\nRecord and share test results, or prepare for App Store distribution with screenshots and videos of your app from Simulator."
  },
  {
    "title": "Interacting with your app in the iOS and iPadOS simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/interacting-with-your-app-in-the-ios-or-ipados-simulator",
    "html": "Overview\n\nSimulator offers an environment to run apps in iOS or iPadOS without installing them on a physical device. When running your app in Simulator, use your Mac to navigate the app’s interface.\n\nInteract with your interface\n\nUse your Mac’s pointer, keyboard, and menu items to make gestures on a simulated iOS or iPadOS device.\n\nGesture\n\n\t\n\nTo simulate\n\n\n\n\nTap\n\n\t\n\nClick.\n\n\n\n\nDouble-tap\n\n\t\n\nDouble-click.\n\n\n\n\nTouch and hold\n\n\t\n\nClick and hold.\n\n\n\n\n3D Touch\n\n\t\n\nOn a Mac with a Force Touch trackpad, choose I/O > Touch Pressure > Use Trackpad Force. Then, click with the desired pressure.\n\n\n\n\nTwo-finger gestures\n\n\t\n\nPress Option to display touch points. Move the pointer while pressing the Option key to change the distance between the touch points. Move the pointer and hold the Shift and Option keys to reposition the touch points.\n\n\n\n\nTwo-finger drag\n\n\t\n\nClick and drag while pressing the Shift and Option keys.\n\n\n\n\nTwo-finger pinch, zoom, or rotate\n\n\t\n\nClick and drag while pressing the Option key.\n\n\n\n\nDrag and drop\n\n\t\n\nClick and hold until the drag item appears, then drag the item to the target.\n\n\n\n\nTwo-finger drag and drop\n\n\t\n\nClick and hold until the drag item appears. Hold the Control key and release the mouse to lock the first finger on the drag item, then navigate to the drop target with the pointer. Click on the drag item and move it to the target.\n\n\n\n\nRotate the simulated device to the right\n\n\t\n\nChoose Device > Rotate Right.\n\n\n\n\nRotate the simulated device to the left\n\n\t\n\nChoose Device > Rotate Left.\n\n\n\n\nSet the orientation of the device\n\n\t\n\nChoose an orientation from the Device > Orientation submenu. Face Up and Face Down do not rotate the simulator window\n\n\n\n\nRotate the device automatically when your app requires a particular orientation\n\n\t\n\nChoose Device > Rotate Device Automatically. A checkmark indicates that automatic device rotation is on.\n\n\n\n\nShake\n\n\t\n\nChoose Device > Shake Gesture.\n\n\n\n\nActivate Siri\n\n\t\n\nChoose Device > Siri, or hold the Home button on the device bezel.\n\nInteract with hardware controls\n\nActivate device buttons using menu items or by clicking on parts of the simulator bezel.\n\nButton\n\n\t\n\nTo simulate\n\n\n\n\nClick the Home button\n\n\t\n\nChoose Device > Home, or click the Home button on the device bezel or toolbar.\n\n\n\n\nClick the Sleep/Wake button\n\n\t\n\nChoose Device > Lock, or click the Sleep/Wake button on the device bezel.\n\n\n\n\nClick or hold Volume up\n\n\t\n\nClick or hold the Volume Up button on the device bezel.\n\n\n\n\nClick or hold Volume down\n\n\t\n\nClick or hold the Volume Down button on the device bezel.\n\n\n\n\nToggle the Ring/Silent switch\n\n\t\n\nClick the Ring/Silent switch on the device bezel.\n\nSee Also\nSimulator interactions\nInteracting with your app in the tvOS simulator\nUse your Mac to control interactions with your tvOS apps in Simulator.\nInteracting with your app in the watchOS simulator\nUse your Mac to control interactions with your watchOS apps in Simulator.\nConfiguring Simulator for your working environment\nAdjust Simulator settings for window or screen size, light or dark appearance, and audio settings, and restart or reset a simulated device.\nSimulating an external display or CarPlay\nTest how your app handles an external display or CarPlay from Simulator.\nCapturing screenshots and videos from Simulator\nRecord and share test results, or prepare for App Store distribution with screenshots and videos of your app from Simulator."
  },
  {
    "title": "Configuring source control preferences in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-source-control-preferences-in-xcode",
    "html": "Overview\n\nXcode lets you customize many default options for working with source control repositories. To modify the default source control preferences, choose Xcode > Preferences > Source Control.\n\nEnable source control actions\n\nIn the General tab of Source Control settings, select the Enable Source Control option to enable the actions in the Source Control menu and the Source Control navigator. Enabling source control also displays the Git tab, which you use to configure Git integration options.\n\nChoose automatic source control behavior\n\nAfter you enable source control, you can select additional options to specify which source control tasks you want Xcode to perform for you automatically.\n\nRefresh local status automatically: Xcode automatically refreshes the status of source control managed files when they change.\n\nFetch and refresh server status automatically: For remote repositories, Xcode periodically refreshes the status of files that update on the server. (To manually refresh the status, choose Source Control > Fetch and Refresh Status.)\n\nAdd and remove files automatically: Xcode automatically updates working copies when adding or removing files in your projects.\n\nSelect files to commit automatically: Xcode automatically selects which files to stage for a commit.\n\nShow code changes in the source editor\n\nThe Text Editing settings affect whether Xcode indicates code changes in the source editor.\n\nShow Source Control changes: Xcode shows the change bar, next to the lines that changed, in the gutter of the source editor.\n\nInclude upstream changes: Xcode shows the changes committed by others (that may conflict with your edits) in the source editor gutter.\n\nCustomize the comparison view layout\n\nThe Comparison View setting specifies where the local version of the code appears in the version editor. To show the local version on the left, choose “Local Revision on Left Side” from the pop-up menu; otherwise, choose “Local Revision on Right Side.”\n\nChoose sorting options for the Source Control navigator\n\nThe Source Control Navigator setting specifies how Xcode sorts the files in the Source Control navigator. To sort by name, choose “Sort by Name” from the pop-up menu; otherwise, choose “Sort by Date.”\n\nCustomize Git settings\n\nIn the Git tab, you can configure default settings for Git repositories that you manage through Xcode.\n\nCustomize the Author Name and Author Email to use in the source control history. Users can Control-click a history entry to email the author.\n\nUse the Ignored Files list to specify the files that you don’t want Git to commit to your source control repositories. To add an ignored file, click the Add button (+). To remove an ignored type, select an item in the list, then click the Delete button (–). To edit an item, double-click it.\n\nChoose additional options for handling Git commands:\n\nPrefer to rebase when pulling: Perform a Git rebase when pulling changes instead of a merge.\n\nShow merge commits in per-file log: Show Git merge commits in the project history.\n\nSee Also\nGit\nOrganizing your code changes with source control\nStreamline your collaboration workflow by managing your Xcode project’s features and releases with Git branches and tags.\nCombining code changes in a source control repository\nIntegrate code changes from multiple sources and resolve conflicts between different versions of code using source control tools in Xcode."
  },
  {
    "title": "Configuring keychain sharing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-keychain-sharing",
    "html": "Overview\n\nSharing keychain items between multiple targets of the same app, or between different apps that belong to the same developer, relies on the concept of an access group — a collection of targets that all share a common keychain group. When a particular target wants to make a keychain item accessible to the rest of the access group, it specifies the shared keychain group when writing that item to the keychain, which can be useful for apps that need to share account credentials and other sensitive information. For more information, see Sharing access to keychain items among a collection of apps.\n\nBefore you make a keychain group accessible to your target, follow the steps in the Add a capability section of Adding capabilities to your app to add the Keychain Sharing capability to that target. For watchOS apps with separate WatchKit extensions, add the capability to the WatchKit Extension target.\n\nIf not already present, Xcode updates your target’s entitlements file to include the Keychain Access Groups Entitlement, which is an array that contains each keychain group you specify.\n\nMake a keychain group accessible to your target\n\nWhen you want two (or more) targets to share common keychain items, make the same keychain group accessible to both by following these steps:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target from the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Keychain Sharing capability.\n\nClick the Add (+) button below the Keychain Groups list.\n\nDouble-click the inserted keychain group to edit it.\n\nEnter a name for the keychain group: either the name of an existing group that’s already in use by your other apps, or a brand new group. For new groups, use reverse DNS notation for the name.\n\nPress the Return key to save the updated keychain group.\n\nNote\n\nAlthough not visible, Xcode prepends the name of each keychain group with the $(AppIdentifierPrefix) build variable, which it automatically resolves at build time.\n\nAfter you make a keychain group accessible to your target, you can later revoke that access by selecting the appropriate keychain group and clicking the Remove button (-) below the Keychain Groups list.\n\nKeychain groups you specify are then available to use with the Keychain services APIs, such as SecItemAdd(_:_:) and SecItemCopyMatching(_:_:).\n\nSpecify the default keychain group\n\nDuring compilation, the system determines the canonical list of keychain groups accessible to your app by concatenating the groups you specify with the app’s unique application identifier and any App Groups you configure; the system considers the first item in that list as the default keychain group. If you omit the kSecAttrAccessGroup attribute when writing keychain items, the system automatically populates that attribute with the default keychain group, and therefore the order in which you specify your keychain groups matters.\n\nTo change the order of your keychain groups, follow these steps:\n\nIn the Project navigator, Control-click your target’s entitlements file.\n\nChoose Open As > Property List.\n\nExpand the Keychain Access Groups key.\n\nDrag the array’s nested items into your preferred order. Each item’s value is the name of a keychain group.\n\nAfter making changes to the order, choose File > Save to store those changes and cause Xcode to update the order it displays the groups in the target’s Signing & Capabilities tab.\n\nNote\n\nAlthough you can use an App Group to share keychain items, it can never be the default keychain group because the app’s unique application identifier always takes precedence.\n\nSee Also\nSecurity\nConfiguring the hardened runtime\nProtect the runtime integrity of your macOS app by restricting access to sensitive resources and preventing common exploits.\nConfiguring the macOS App Sandbox\nProtect system resources and user data from compromised apps by restricting access to the file system, network connections, and more."
  },
  {
    "title": "Configuring HealthKit access | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-healthkit-access",
    "html": "Overview\n\nHealthKit is the central repository for health and fitness data in iOS and watchOS. Health apps that integrate with HealthKit can request a user’s permission to both read health data from and write data to this central repository. The data your app writes to the HealthKit store is visible to the user in the Health app, alongside their other health-related data.\n\nTo enable your app to access the user’s HealthKit store, you must add the HealthKit capability to your app’s target and include a short description of the app’s functionality in its target’s Info.plist file.\n\nAdd the HealthKit capability to your target\n\nFollow the steps in Add a capability to add the capability to your app’s target; be sure to select the HealthKit capability from Xcode’s Capabilities library. For watchOS apps with separate WatchKit extensions, you must add the capability to the WatchKit Extension target.\n\nNote\n\nThe HealthKit capability is available for iOS and watchOS apps. watchOS apps can only access certain health data. Clinical Health Records aren’t accessible by watchOS apps.\n\nAfter you add the HealthKit capability, Xcode links the HealthKit framework to your target and updates the target’s entitlements file to include the HealthKit Entitlement. If Xcode automatically manages the signing of your app, it also enables HealthKit for your app’s App ID.\n\nNote\n\nIf you later remove the HealthKit capability in Xcode, you must manually update your App ID’s configuration in the developer portal to disable HealthKit.\n\nRequest access to the user’s health data\n\nHealthKit uses a fine-grained authorization mechanism to help protect the user’s privacy; your app must request permission to read and, optionally, write each individual sample type it supports. For more information, see Authorizing access to health data.\n\nBefore prompting the user for their permission, you must configure your app to include one or more purpose strings, which accurately and concisely describe why the app needs to read the user’s health data, write health data to their HealthKit store, or both. The presence of these purpose strings is an App Store requirement for any app that integrates with HealthKit. The system displays this information to the user when requesting their permission, along with the specific sample types that your app needs to access, which helps them make an informed decision.\n\nFollow these steps to add the purpose string for reading health data to your app’s target:\n\nIn the Project navigator, select your target’s Info.plist file.\n\nMove the mouse pointer over the “Information Property List” key.\n\nClick the Add button (+) that appears.\n\nChoose “Privacy - Health Share Usage Description”.\n\nDouble-click the Value column to the right of the key and enter your app’s purpose string.\n\nIf your app writes health data to the HealthKit store, repeat the steps above and add the “Privacy - Health Update Usage Description” key.\n\nRemember that the user can revoke their permission at any time in the Settings app or the Health app. If your app requires access to certain health data, you must clearly display information about why your app requires access to the user’s health data and request that the user reauthorize to grant your app access to the HealthKit data.\n\nYou can check your app’s current authorization status using the authorizationStatus(for:) method. HealthKit also returns a HKError.Code.errorAuthorizationDenied error if your app attempts unauthorized access to the user’s health data.\n\nRequest access to a user’s health records\n\nHealthKit’s clinical-record support allows users to download their records in the Fast Healthcare Interoperability Resources (FHIR) format from supported healthcare institutions. HealthKit then periodically updates those records in the background.\n\nDue to the sensitive nature of health records, your app requires a special entitlement before it can access them. Follow these steps to configure that entitlement:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect your app’s target from the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the HealthKit capability.\n\nEnable the nested Clinical Health Records capability.\n\nXcode adds the HealthKit Capabilities Entitlement to your target’s entitlements file and appends the health-records value to the array it contains.\n\nAfter you enable the capability, there are additional configuration steps you must complete before your app can access the user’s health records, such as providing an additional purpose string and declaring the types of health records that your app supports. For more information, see Accessing Health Records.\n\nReceive sample updates in the background\n\nHealthKit observer queries are long-running ones that watch the HealthKit store for changes to specific sample types and deliver those changes to your app on a background thread. Typically, observer queries only provide those changes when your app is running in the foreground.\n\nHowever, by enabling Background Delivery, your app can continue to receive and process changes while it’s in the background. You pair each executed observer query with a call to enableBackgroundDelivery(for:frequency:withCompletion:) and specify the same sample type. The system then wakes your app when changes occur in the HealthKit store — at most, once per the update frequency you specify — and delivers those changes to the corresponding observer queries. For more information, see Executing Observer Queries.\n\nTo enable HealthKit to continue updating your app’s observer queries while its in the background, perform the following:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target from the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the HealthKit capability.\n\nEnable the nested Background Delivery capability.\n\nXcode adds the com.apple.developer.healthkit.background-delivery entitlement to the target’s entitlements file.\n\nSee Also\nUser data\nConfiguring HomeKit access\nDiscover compatible accessories and communicate with configured accessories and services to perform actions."
  },
  {
    "title": "Configuring HomeKit access | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-homekit-access",
    "html": "Overview\n\nApps that integrate with HomeKit can securely connect to a user’s home automation network and access compatible accessories. After an app connects to an accessory, it can read and update that accessory’s state, for example, by changing the ambient color of a smart light bulb.\n\nTo enable your app to control the user’s compatible accessories, you must add the HomeKit capability to your app’s target and include a short description of the app’s functionality in its target’s Info.plist file.\n\nAdd the HomeKit capability to your target\n\nFollow the steps in Add a capability to add the capability to your app’s target; be sure to select the HomeKit capability from Xcode’s Capabilities library. For watchOS apps with separate WatchKit extensions, you must add the capability to the WatchKit Extension target. The capability isn’t available for macOS.\n\nAfter you add the HomeKit capability, Xcode links the HomeKit framework to your target and updates its entitlements file to include the HomeKit Entitlement. If Xcode automatically manages the signing of your app, it also enables HomeKit for your app’s App ID.\n\nRequest access to a home automation network\n\nTo help protect the security and privacy of the user’s home automation network, your app requires the user’s explicit permission before it can control HomeKit accessories on that network. The system prompts the user for their permission the first time your app uses the HomeKit framework, which is when you initialize HMHomeManager.\n\nThe App Store requires your app to include a purpose string, which accurately and concisely describes the reasons the app needs access to the user’s network. The system displays this information to the user when requesting their permission, which helps them make an informed decision. Follow these steps to add the purpose string to your target:\n\nIn the Project navigator, select your target’s Info.plist file.\n\nMove the mouse pointer over the “Information Property List” key.\n\nClick the Add button (+) that appears.\n\nChoose “Privacy - HomeKit Usage Description” from the drop-down menu.\n\nDouble-click the Value column to the right of the key and enter your app’s purpose string.\n\nImportant\n\nApps that enable Homekit but don’t include a purpose string crash when attempting to use the framework’s APIs.\n\nRemember that the user can revoke their permission at any time in the Settings app, and your app must respond to this accordingly. You can check your app’s current authorization status by accessing the authorizationStatus property. HomeKit also returns a homeAccessNotAuthorized error if your app attempts to make an unauthorized call to any of the framework’s APIs.\n\nInstall the HomeKit accessory simulator\n\nIntegrating with HomeKit doesn’t require you to have physical access to each of the accessories that your app supports. Instead, you can install the HomeKit Accessory Simulator and simulate each of those accessories. To install the simulator, follow these steps:\n\nOpen the Signing & Capabilities tab in your target’s project editor.\n\nFind the HomeKit capability.\n\nClick the Download HomeKit Simulator button.\n\nOn the More Downloads webpage that opens, find and download the latest “Additional Tools for Xcode” DMG file. Your browser may ask you to sign in to your Apple developer account first.\n\nAfter the DMG file downloads, double-click it to mount the disk image in Finder.\n\nOpen the Hardware folder.\n\nDrag the HomeKit Accessory Simulator app to your Mac’s Applications folder.\n\nUse the simulator to add and remove simulated HomeKit accessories, services, and characteristics, and to simulate networked cameras and video doorbells by leveraging your Mac’s camera. For more information, see the Add Accessories, Services, and Characteristics section of Testing Your App with the HomeKit Accessory Simulator.\n\nSee Also\nUser data\nConfiguring HealthKit access\nRead and write health and activity data in the Health app."
  },
  {
    "title": "Combining code changes in a source control repository | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/combining-code-changes-in-a-source-control-repository",
    "html": "Overview\n\nIf you use source control to work on code with collaborators or to manage multiple versions of your Xcode project for different releases, eventually, you need to sync code changes between versions. Git source control provides a mechanism for combining sets of code changes by merging those changes together, and Xcode provides a visual interface for performing a merge.\n\nMerge code changes\n\nAfter you complete work in a feature or bug fix branch, you merge your changes into your main development or production branch. Alternatively, you merge other updates from your main development or production branch into your feature or bug fix branch to resolve conflicts or to sync your work with the latest updates and ensure everything functions appropriately before merging back into your main development or production branch.\n\nOpen the Source Control navigator.\n\nIn the Repositories navigator, expand your repository and the Branches folder.\n\nSelect the branch you want to merge into, and then Control-click and choose Switch to make that branch the current branch.\n\nSelect the branch you want to merge from, and then Control-click and choose “Merge [from branch] into [to branch]”.\n\nIf there are no conflicts, Xcode completes the merge.\n\nResolve conflicts with other code\n\nIn a source control repository, a conflict occurs when two commits have incompatible changes and Git can’t merge the changes automatically. For example, a conflict might occur when two developers change the same lines in the same source file.\n\nWhen you attempt to merge changes in Xcode, if there are conflicts, Xcode presents a comparison view for you to review and resolve the conflicts.\n\nTo resolve a conflict, click the numbered change for that conflict and select which option you want to use to resolve it:\n\nChoose Left\n\nChoose Right\n\nChoose Left Then Right\n\nChoose Right Then Left\n\nAfter you choose a resolution for each conflict, Xcode enables the Merge button. Click the Merge button to complete the merge, or click Cancel to abort the merge and restore your branch so you can make more changes before merging.\n\nSee Also\nGit\nOrganizing your code changes with source control\nStreamline your collaboration workflow by managing your Xcode project’s features and releases with Git branches and tags.\nConfiguring source control preferences in Xcode\nCustomize the default Xcode settings for connecting to Git repositories, applying code changes, and more options for configuring source control."
  },
  {
    "title": "Organizing your code changes with source control | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/organizing-your-code-changes-with-source-control",
    "html": "Overview\n\nMost Xcode projects need to keep track of multiple feature and release timelines simultaneously. Git provides support for organizing different versions of code into branches and annotating your project’s significant milestones with tags.\n\nOrganize new feature or bug fix changes in a branch\n\nWhen you update source code to add a new feature or to fix a bug, keep all the changes together in a branch so that you can work with them as a unit. For example, if you decide not to add a new feature after building it without using source control, it can be a significant effort to undo the work. If you organize your work in a branch, you can decide not to merge the branch and avoid having to undo work.\n\nBefore you begin new work, choose a starting point for your branch. In Xcode, open the Source Control navigator and expand the folder with your project name. Expand the Branches folder to see a list of the current local branches, or the Remotes folder to see a list of remote repositories and branches. By default, Xcode creates a branch named main when you create a new project with a Git repository. Control-click the branch you want to use as your starting point, choose “Branch from [branch name]”, and then enter a name for your branch that identifies the work you’re doing. When you click Create, Xcode creates the branch and makes it current, so any changes you make and commit are part of that branch.\n\nMake, test, and commit your changes. When your new feature or bug fix is complete and you’re ready to include your work in the main code branch, review and merge it. For more information, see Combining code changes in a source control repository.\n\nTip\n\nCreate a new branch from the current branch with uncommitted changes, and your changes become part of the new branch. You can’t switch to another branch if you have uncommitted changes, so commit your changes or stash them before switching to another branch.\n\nSet aside work in progress to make other changes\n\nWhen you have work in progress that you aren’t ready to commit and you need to switch to another branch, stash your changes to save them without committing them to the repository. Choose Source Control > Stash Changes, and optionally enter a description of your changes.\n\nXcode creates a stash entry with your changes and removes those changes from the current working environment so that you can switch branches or start working on other changes.\n\nIn the Source Control navigator, view the Stashed Changes folder under your project folder. Select a stashed change item to review the changes in the comparison view. To add the changes to your current work, Control-click the stashed change item and choose Apply Stashed Changes. Xcode updates the current working environment with the stashed changes so you can continue making updates or commit your changes to the repository.\n\nWhen you no longer need the stashed changes, Control-click the stashed change item and choose Delete to remove it.\n\nMark releases and significant milestones\n\nAdd tags to commits that represent a significant milestone, like a release or large feature addition, to make them easy to find in source control history.\n\nIn the Source Control navigator, expand the folder with your project name. Expand the Branches folder to see a list of the current local branches, select a branch, and then optionally select a commit in the history list. Control-click either the branch or the commit, and choose Tag.\n\nIf you select the branch, Xcode applies the tag to the most recent commit in the branch. Enter a short string for the tag, and, optionally, a more detailed message. Click Create, and Xcode creates the tag and marks the commit with it.\n\nIn the Source Control navigator, under the folder with your project name, expand the Tags folder to see and navigate to tagged commits.\n\nSee Also\nGit\nCombining code changes in a source control repository\nIntegrate code changes from multiple sources and resolve conflicts between different versions of code using source control tools in Xcode.\nConfiguring source control preferences in Xcode\nCustomize the default Xcode settings for connecting to Git repositories, applying code changes, and more options for configuring source control."
  },
  {
    "title": "Tracking code changes in a source control repository | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/tracking-code-changes-in-a-source-control-repository",
    "html": "Overview\n\nWhen you use a source control repository to manage your Xcode project, you save changes to your repository in incremental states called commits. A commit consists of a snapshot of your project’s state at a particular point in time, a message that describes the set of changes from the previous commit, and additional metadata like a unique hash that identifies the commit.\n\nIn Xcode, you can save your project’s current state in a commit, navigate the history of your project’s previous commits, compare changes between specific commits, and quickly restore to a previous commit.\n\nSave your project’s current state\n\nAs you make changes to your source code in a source control repository, Xcode tracks those changes and highlights them in the Project navigator and in the source editor. While you’re working on a change, look at the Project navigator to see your changes in the current branch.\n\nThe Project navigator annotates files with changes since the last commit, using an A for new files or an M for modified files. To compare changes in one source file, open the file and click the Enable Code Review button in the upper-right corner of the Xcode window.\n\nThe comparison view highlights changes between the current source code and the most recent commit. You can choose whether to view changes inline or side by side by clicking the Adjust Editor Options button.\n\nThe comparison view allows you to:\n\nNavigate between the numbered changes using the arrows at the bottom of the center column.\n\nClick a number in the center column to select and discard a change.\n\nChoose other commits to compare your current changes against.\n\nWhen you’re done making changes, commit them to save them permanently in your source control repository. Choose Source Control > Commit, and review your changes.\n\nIn the Project navigator, select a file in the list to view the code changes for that file. Click the numbered selector between the left and right sides of the comparison view, and then choose Don’t Commit to exclude an individual change from your commit, or choose Discard Change to remove a change. Select checkmarks to indicate which files to include in your commit.\n\nWarning\n\nWhen you add a new file or delete an unused file, you must commit both the file and the Xcode project file (called project.pbxproj) together for your project to remain in a consistent state.\n\nDocument your changes with a commit message that describes what your commit accomplishes. Click the “Commit [number] files” button to commit your changes, or click Cancel to continue working without committing to the repository. Xcode shows the commit message you provide when you look at the source control history.\n\nIf you don’t want to commit any of your changes, and want to remove them, choose Source Control > Discard All Changes, and click Discard. Xcode removes all the current changes and restores your source files to the most recent commit.\n\nView a history of project states\n\nXcode has a commit history view that lets you view historical changes for your source control repository when you’re investigating a bug or adding code for a new feature.\n\nOpen the Source Control navigator.\n\nIn the Repositories navigator, expand your repository and the Branches folder.\n\nSelect a branch to display a list of commits.\n\nDouble-click a specific commit to display the comparison view, and see additional information about the commit in the Source Control inspector.\n\nCompare code between specific project states\n\nTo compare code between specific commits, select the branches and commits to compare from the bottom bar in the comparison view.\n\nRestore your project to a previous state\n\nYou can quickly restore your code to a previous state in your source control repository by checking out a specific commit. Xcode restores your project files to the state that the commit you choose specifies.\n\nBefore you restore a previous commit of the code, make sure you don’t have any uncommitted changes. If you do, you can either discard the changes (Source Control > Discard All Changes) or save them to apply later by stashing them (Source Control > Stash Changes).\n\nOpen the Source Control navigator.\n\nIn the Repositories navigator, expand your repository and the Branches folder.\n\nSelect the branch that contains the commit you want to restore.\n\nIn the detail view, Control-click the desired commit and choose Switch to “[commit-hash]”.\n\nIn the confirmation dialog, click Switch. Xcode restores your project’s state to the earlier commit.\n\nTo learn more about restoring stashed changes, see Organizing your code changes with source control.\n\nSee Also\nEssentials\nConfiguring your Xcode project to use source control\nSync code changes between team members and development computers by setting up your Xcode project to use Git source control."
  },
  {
    "title": "Configuring your Xcode project to use source control | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-your-xcode-project-to-use-source-control",
    "html": "Overview\n\nWhen you’re building a project with a team, or by yourself using more than one development computer, use Xcode’s support for Git source control to coordinate code changes between team members or computers, and keep them all in sync.\n\nGit relies on a source control repository to track a history of your project’s code changes and to sync those changes across other devices. Set up your Xcode project to use Git by creating and configuring a new source control repository, or by downloading an existing source control repository.\n\nCustomize your author name and email\n\nBefore you configure a source control repository for a specific project, customize your name and email address for source control for all projects in Xcode. When you make changes to your source code and commit them to your source control repository, Xcode includes your name and email address as the author in the source control history. Users can Control-click a history entry to email the author.\n\nTo customize your name and email address for source control for all projects, choose Xcode > Preferences > Source Control and click the Git tab. Enter your preferred author name and email address in the applicable fields.\n\nTip\n\nIf the Git tab doesn’t appear, make sure you select the Enable Source Control option in the General tab.\n\nCreate a local repository with your new project\n\nWhen you create a new Xcode project, one of the final steps is to specify where you want to save your project files. At this point, you can quickly create a local Git source control repository for your project by selecting the “Create Git repository on my Mac” option and then clicking the Create button.\n\nXcode creates your project in the folder you specify, initializes a local Git source control repository for your project, and commits all the files that it creates for your project in an initial commit. For more information, see Creating an Xcode project for an app.\n\nGet a project from a remote repository\n\nYou can also create a local copy, or clone, of an existing remote Git repository to update and sync changes with. If the repository you want to clone uses Bitbucket, GitHub, or GitLab as its host, and requires authentication, you need to set up account information to access the repository. Choose Xcode > Preferences > Accounts, click the Add button (+), select the type of account to add, and click Continue.\n\nIn the dialog that appears, click the “Create a Token on [Source Control Platform]” button if you don’t have a token already. Otherwise, provide your account information and personal token to connect to the remote repository, and click Sign In.\n\nTo copy a remote repository, select Source Control > Clone.\n\nIf you add one or more source control accounts, Xcode shows a list of the projects that you can select to clone. Alternatively, get a URL for a remote repository, paste it into the repository URL field, and press Enter. If the remote repository corresponds to an Xcode project, Xcode scans the project and provides a list of branches available to clone. Select a branch to clone, and provide a location for Xcode to save the cloned project.\n\nXcode creates a copy of the project from the remote repository, saves it in the location you specify, checks out the branch you select, and opens the project.\n\nConnect to a remote repository to sync changes\n\nShare your changes with other developers on your team, or maintain a backup of your project by syncing changes with a remote repository. To sync with a remote repository, you need to configure your source control settings for your project to point to the remote repository. If you cloned your local repository from a remote repository, your project already has a connection to the remote repository. Otherwise, create a new remote repository or connect to an existing one. To accomplish these tasks, select the Source Control navigator (the second navigator from the left, next to the Project navigator). In the Source Control navigator, select the Repositories navigator.\n\nCreate a new remote repository in the Source Control navigator by Control-clicking the Remotes folder for your project and choosing New “[project name]” Remote. Provide the information and click Create to create and connect the new remote repository.\n\nAdd a connection to an existing remote repository in the Source Control navigator by Control-clicking the Remotes folder for your project and choosing Add Existing Remote. Provide a name and URL for the remote repository, and click Add to set up the connection.\n\nRetrieve changes from a remote repository\n\nGet changes from the remote repository by choosing Source Control > Pull. In the dialog that appears, select the branch with the changes you want to apply to your local repository, select the “Rebase local changes onto upstream changes” option if you want, and click Pull.\n\nAlternatively, choose Source Control > Fetch Changes to download the changes from your remote repository without applying them to your working copy.\n\nShare changes to a remote repository\n\nWhen you’re ready to share your work, choose Source Control > Push. In the dialog that appears, select the branch you want to share, select the Include Tags option if you want to push tags to the remote repository, and then click Push to sync your changes with the remote repository.\n\nTo add a collaborator to your remote repository, sign into your source control account in a web browser and add a new collaborator in your repository’s Settings.\n\nFor information about configuring additional settings for source control management in Xcode, see Configuring source control preferences in Xcode.\n\nSee Also\nEssentials\nTracking code changes in a source control repository\nCreate a history of incremental code changes to your Xcode project’s source control repository with Git commits."
  },
  {
    "title": "Configuring the macOS App Sandbox | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-the-macos-app-sandbox",
    "html": "Overview\n\nThe App Sandbox is an access control technology that macOS provides and enforces at the kernel level. The sandbox’s primary function is to contain damage to the system and the user’s data if the user executes a compromised app. While the sandbox doesn’t prevent attacks against your app, it does reduce the harm a successful attack can cause by restricting your app to the minimum set of privileges it requires to function properly.\n\nA sandboxed app must explicitly state its intent to access a restricted resource or protected file location, otherwise the system prohibits any attempts it makes at runtime. Xcode’s App Sandbox capability allows you to state that intent by enabling the privileges that your app requires.\n\nBefore you can enable those privileges, follow the steps in the Add a capability section of Adding capabilities to your app to first add the App Sandbox capability to your macOS app’s target.\n\nAfter you add the App Sandbox capability, Xcode automatically updates the entitlements file of your macOS app to include the App Sandbox Entitlement, which is an App Store requirement for any app that you submit to the Mac App Store for review.\n\nTo ensure the App Sandbox is in an enabled state, launch your macOS app using Xcode. Then, open /Applications/Utilities/Activity Monitor.app and choose View > Columns > Sandbox to display the Sandbox column. Find your app in the list of running processes and confirm the value in that column is Yes.\n\nNote\n\nWhen you use Mac Catalyst to enable your iPad app to run in macOS, Xcode automatically adds the App Sandbox and Hardened Runtime capabilities to the macOS target. For more information, see Creating a Mac version of your iPad app.\n\nEnable access to restricted resources\n\nIf your app requires access to restricted or sensitive system resources, such as network connections or connected Bluetooth devices, it must include the relevant entitlements that provide access to those resources. Follow these steps to add those entitlements:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the target of your macOS app in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nLocate the App Sandbox capability.\n\nEnable access to one or more resources by checking the relevant checkboxes.\n\nXcode updates the entitlements file of your macOS app to include the necessary entitlements and sets the value of those entitlements to true.\n\nImportant\n\nEntitlements inform the system of your app’s intent to access the related resources. In most cases, you must still seek the user’s explicit permission before the system grants that access. See the relevant framework documentation for specific requirements.\n\nThe following table describes the resource access entitlements the App Sandbox supports:\n\nCategory\n\n\t\n\nName\n\n\t\n\nDescription\n\n\n\n\nNetwork\n\n\t\n\nIncoming Connections (Server)\n\n\t\n\nYour app listens for incoming network connections. For more information, see the com.apple.security.network.server entitlement.\n\n\n\n\n\t\n\nOutgoing Connections (Client)\n\n\t\n\nYour app connects to remote servers using outgoing network connections. For more information, see the com.apple.security.network.client entitlement.\n\n\n\n\nHardware\n\n\t\n\nCamera\n\n\t\n\nYour app captures images and movies with the built-in and external cameras. For more information, see Camera Entitlement.\n\n\n\n\n\t\n\nAudio Input\n\n\t\n\nYour app captures audio with the built-in and external microphones. For more information, see the com.apple.security.device.microphone entitlement.\n\n\n\n\n\t\n\nUSB\n\n\t\n\nYour app communicates with connected USB devices. For more information, see the com.apple.security.device.usb entitlement.\n\n\n\n\n\t\n\nPrinting\n\n\t\n\nYour app prints documents and media using the system’s configured printers. For more information, see the com.apple.security.print entitlement.\n\n\n\n\n\t\n\nBluetooth\n\n\t\n\nYour app communicates with connected Bluetooth devices. For more information, see the com.apple.security.device.bluetooth entitlement.\n\n\n\n\nApp Data\n\n\t\n\nContacts\n\n\t\n\nYour app requires read-write access to the user’s Contacts database. For more information, see Address Book Entitlement.\n\n\n\n\n\t\n\nLocation\n\n\t\n\nYour app determines the user’s location using Location Services. For more information, see Location Entitlement.\n\n\n\n\n\t\n\nCalendar\n\n\t\n\nYour app requires read-write access to the user’s calendar. For more information, see Calendars Entitlement.\n\nEnable managed file access\n\nThe first time the user launches your sandboxed app, the system creates its container — a folder in ~/Library/Containers that your app has exclusive read-write access to.\n\nTo minimize the risk to user data, the system restricts your app’s file system access to just its container, but that container does include a number of symbolic links that resolve to common user folders, such as ~/Downloads and ~/Pictures. However, the system considers those sensitive folders and requires that your app include certain entitlements before it grants access to the resolved locations of the symbolic links. An unauthorized attempt to access one of those folders results in an “Operation not permitted” error.\n\nFollow these steps to add the required entitlements:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the target of your macOS app in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nLocate the App Sandbox capability.\n\nUse each option’s drop-down menu to choose None, Read Only, or Read/Write, depending on your app’s requirements.\n\nNote\n\nThe User Selected File option enables access to arbitrary locations that the user chooses with AppKit’s NSOpenPanel and NSSavePanel.\n\nAfter you configure the necessary file access, Xcode updates your app’s entitlements file to include the corresponding entitlements and sets the value of those entitlements to true.\n\nSee Also\nSecurity\nConfiguring the hardened runtime\nProtect the runtime integrity of your macOS app by restricting access to sensitive resources and preventing common exploits.\nConfiguring keychain sharing\nShare keychain items between multiple apps belonging to the same developer."
  },
  {
    "title": "Configuring network extensions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-network-extensions",
    "html": "Overview\n\nNetwork Extensions allow you to customize and extend the core networking features of iOS and macOS. For example, your app can implement a virtual private network (VPN) client for a flow-oriented or packet-oriented custom VPN protocol, which an enterprise might require to facilitate secure remote access to resources not available on the public internet.\n\nPrior to implementing a customized networking stack, follow the steps in the Add a capability section of Adding capabilities to your app to add the capability to your iOS or macOS app, and select the Network Extensions capability from Xcode’s Capabilities library.\n\nAfter you add the Network Extensions capability, Xcode updates your app’s entitlements file to include the Network Extensions Entitlement, which is an array that comprises the app capabilities you enable. If Xcode automatically manages your app’s signing, it also enables the Network Extensions capability for your app’s App ID in the developer portal.\n\nNote\n\nIf you remove the Network Extensions capability in Xcode, you must manually update the configuration of your app’s App ID in the developer portal to disable Network Extensions.\n\nEnable the required app capabilities\n\nBefore your app can use the Network Extension framework to customize and extend the core networking features of iOS and macOS by implementing specific app capabilities, you must configure your Xcode project to include the necessary entitlements by performing the following steps:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nLocate the Network Extensions capability.\n\nEnable one or more app capabilities by checking the corresponding checkboxes.\n\nXcode automatically updates the Network Extensions Entitlement array in your app’s entitlements file to include the enabled app capabilities.\n\nImportant\n\nApp capabilities may have specific restrictions and use cases, such as only being available on supervised iOS devices. For more information, see the documentation for each capability.\n\nThe following table lists the app capabilities that Network Extensions support:\n\nName\n\n\t\n\nDescription\n\n\n\n\nApp Proxy\n\n\t\n\nYour app provides a virtual private network (VPN) client for a flow-oriented, custom VPN protocol. For more information, see App proxy provider.\n\n\n\n\nContent Filter\n\n\t\n\nYour app examines user content as it passes through the network stack and determines if the system should allow it or block it. For more information, see Content filter providers and the sample code Filtering Network Traffic.\n\n\n\n\nPacket Tunnel\n\n\t\n\nYour app provides a VPN client for a packet-oriented, custom VPN protocol. For more information, see Packet tunnel provider.\n\n\n\n\nDNS Proxy\n\n\t\n\nYour app is responsible for resolving all DNS queries on-device using a custom protocol. For more information, see DNS proxy provider.\n\n\n\n\nDNS Settings\n\n\t\n\nYour app creates and manages a system-wide DNS configuration using the DNS protocols DNS-over-TLS and DNS-over-HTTP. For more information, see DNS settings.\n\nTip\n\nTo learn more about the APIs you use to create apps that extend and customize the device’s networking capabilities, see the WWDC videos Network Extensions for the Modern Mac, Advances in Networking, Part 1, and What’s New in Network Extension and VPN.\n\nSee Also\nNetwork\nConfiguring Group Activities\nLeverage FaceTime infrastructure to create coordinated experiences users can share.\nConfiguring media device discovery\nAdd a third-party media device or protocol as a streaming option in the same system menu as AirPlay."
  },
  {
    "title": "Configuring media device discovery | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-media-device-discovery",
    "html": "Overview\n\nEnable the Media Device Discovery capability in an iOS app extension to indicate its intent to search the local network or paired Bluetooth devices for a third-party media receiver. This capability corresponds to the Media Device Discovery Extension entitlement. When you enable Media Device Discovery, Xcode adds the entitlement to a code-signing entitlements file for the extension’s target.\n\nAt run-time, when a user invokes a UI to play media, the app presents an AVRoutePickerView to offer possible devices for the user to stream to. The system searches your app’s bundle for extensions with this entitlement to check whether your app provides such a device. If so, the system adds the third-party device next to any available AirPlay devices in the picker, which provides the user with a unified media streaming experience.\n\nAdd the Media Device Discovery capability to your target\n\nTo add the capability, follow the steps in the Add a capability section of Adding capabilities to your app for your extension’s target. If you add a new target in your Xcode project using the Media Device Discovery template, Xcode enables this capability automatically.\n\nCode the extension\n\nYou code the extension to search the local network or paired Bluetooth devices for a specific media receiver using the DeviceDiscoveryExtension framework. If the search succeeds, the extension passes the discovered device to the system. For an example app that demonstrates media device discovery, see Discovering a third-party media-streaming device.\n\nSee Also\nNetwork\nConfiguring network extensions\nCustomize the various capabilities of your app’s networking stack, such as proxying DNS queries or creating packet tunnels.\nConfiguring Group Activities\nLeverage FaceTime infrastructure to create coordinated experiences users can share."
  },
  {
    "title": "Configuring iCloud services | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-icloud-services",
    "html": "Overview\n\nAs an app developer, you can use one or more iCloud services to securely store your users’ data on the iCloud servers and make it available across all of their iCloud-enabled devices, thereby providing a seamless experience regardless of which device they use.\n\nXcode’s iCloud capability allows you to configure the following services:\n\nKey-value storage provides your app with 1 MB of iCloud storage that can contain up to 1024 key-value pairs, which is useful for syncing small amounts of data, such as the user’s preferences. For more information, see NSUbiquitousKeyValueStore.\n\niCloud Documents allows your app to store data as files and sync those files across devices, which is relevant if your app is already using UIDocument or NSDocument. For more information, see Designing for Documents in iCloud.\n\nCloudKit allows your app to store structured objects and relationships in remote databases and provides full control over those databases’ schemas. Users can also choose to share their data with other iCloud users. You can use the CloudKit framework directly, or if your app uses Core Data to persist its data, leverage CloudKit to sync that data across devices. For more information, see Mirroring a Core Data store with CloudKit.\n\niCloud Documents and CloudKit both use iCloud containers, although their purpose differs depending on the service. For iCloud Documents, a container — alternatively known as a ubiquity container — serves as a local representation of the corresponding iCloud storage and is a specialized location on-disk where your app stores its files. For CloudKit, a container isolates your app’s databases on the iCloud servers and manages their access and operations. For more information, see CKContainer. You can also use containers to share files and data between multiple apps belonging to the same developer.\n\nBefore you can enable an iCloud service, follow the steps in the Add a capability section of Adding capabilities to your app to add the capability to your app’s target, and select the iCloud capability from Xcode’s Capabilities library. For watchOS apps with separate WatchKit extensions, add the capability to the WatchKit Extension target. To access a public iCloud database in your App Clip, add the capability to your App Clip target and be sure to read Choosing the right functionality for your App Clip for more information about using iCloud services in your App Clip.\n\nAfter you add the iCloud capability, Xcode updates your target’s entitlements file to include the iCloud Container Identifiers Entitlement, which is an array that comprises the containers you select. If Xcode automatically manages your app’s signing, it also enables the iCloud capability for your app’s App ID in the developer portal.\n\nNote\n\nIf you later remove the iCloud capability in Xcode, you must manually update your App ID’s configuration in the developer portal to disable iCloud.\n\nEnable one or more iCloud services\n\nPrior to using an iCloud service to sync your users’ data across their devices, you must enable that service in Xcode to add the necessary entitlements to your app’s entitlements file. Use the checkbox next to the service’s name in the Services section of the iCloud capability to enable that service.\n\nDepending on the services you enable, Xcode adds the following additional entitlements (if they’re not already present).\n\nService\n\n\t\n\nEntitlement\n\n\n\n\nKey-value storage\n\n\t\n\ncom.apple.developer.ubiquity-kvstore-identifier\n\n\n\n\niCloud Documents\n\n\t\n\ncom.apple.developer.icloud-services\n\n\n\n\n\t\n\ncom.apple.developer.ubiquity-container-identifiers\n\n\n\n\nCloudKit\n\n\t\n\ncom.apple.developer.icloud-services\n\nFor more information, see iCloud Key-Value Store Entitlement and iCloud Services Entitlement.\n\nNote\n\nXcode automatically adds the Push Notifications capability to your target if you enable the CloudKit service because CloudKit uses push notifications to inform your app of server-side changes to your data. For more information, see Remote Records.\n\nManage your app’s iCloud containers\n\nAfter adding the iCloud capability, Xcode retrieves any existing iCloud containers from your developer account and displays them in the capability’s configuration section. Use the Refresh button below the list to re-fetch your account’s iCloud containers at any time.\n\nEnable one or more iCloud containers in the list using their checkboxes. Conversely, uncheck a container’s checkbox to prevent your app from using it. Xcode associates the selected iCloud containers with your app’s App ID in the developer portal and makes the following changes to your app’s entitlements file:\n\nFor apps that enable iCloud Documents, or both iCloud Documents and CloudKit, Xcode updates the following entitlements to include the selected containers:\n\ncom.apple.developer.icloud-container-identifiers\n\ncom.apple.developer.ubiquity-container-identifiers\n\nXcode updates just the com.apple.developer.icloud-container-identifiers entitlement for apps that enable only CloudKit.\n\nNote\n\nTo avoid breaking existing versions of your app that depend on the container association, Xcode doesn’t automatically dissociate a deselected container from your App ID in the developer portal.\n\nTo create a new iCloud container, perform the following steps:\n\nClick the Add button (+) below the iCloud containers list.\n\nEnter an iCloud container in the dialog that appears. You must begin the container’s name with iCloud. and use a unique string in reverse DNS notation.\n\nClick OK to save the new iCloud container.\n\nXcode automatically registers the iCloud container in the developer portal, adds it to your app’s entitlements file, and selects it in the list of containers, indicating that your app is now able to use the new container.\n\nAfter selecting the required containers, update your app to perform one or more of following:\n\nFor document-based apps, call url(forUbiquityContainerIdentifier:) to determine the location of your app’s ubiquity container.\n\nFor CloudKit apps, use init(identifier:) to initialize an instance of CKContainer that provides access to the container’s databases and executes operations against those databases.\n\nFor Core Data apps that sync with CloudKit, use NSPersistentCloudKitContainerOptions to configure your Core Data stack to use your new container.\n\nAccess the CloudKit console\n\nIf your app enables the CloudKit service, use the web-based CloudKit Console to manage all aspects of your app’s iCloud containers, including the schemas for their databases, operation logs, and performance telemetry. For more information, see Managing iCloud Containers with the CloudKit Database App.\n\nFollow these steps to access the CloudKit Console:\n\nClick the CloudKit Console button below the list of containers in the iCloud capability.\n\nIn the browser window that opens, sign in to the CloudKit Console using the same Apple ID as your developer account.\n\nAlternatively, you can access the console directly at icloud.developer.apple.com.\n\nSee Also\nData management\nConfiguring an associated domain\nCreate a two-way association between your app and your website to enable universal links, Handoff, App Clips, and shared web credentials.\nConfiguring App Groups\nEnable communication and data sharing between multiple installed apps created by the same developer."
  },
  {
    "title": "Configuring App Groups | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-app-groups",
    "html": "Overview\n\nAn App Group allows multiple apps developed by the same team to access one or more shared containers. It also enables additional inter-process communication between those apps using Mach IPC, POSIX semaphores and shared memory, and UNIX domain sockets, among other IPC mechanisms. On macOS, App Groups can facilitate communication between sandboxed apps, and between sandboxed and non-sandboxed apps. Apps can belong to one or more App Groups. You can also use an App Group to share data between an app extension or App Clip and its host app.\n\nBefore you create an App Group, follow the steps in Add a capability to add the Apps Groups capability to your app’s target.\n\nCreate App Groups for macOS apps\n\nApp Groups on macOS differ from other Apple platforms. Not using provisioning profiles means App Group names are not guaranteed to be unique. Instead, a macOS App Group uses your team’s identifier as a prefix for its name to provide that uniqueness. This also means you manage macOS App Groups locally, rather than using a centralized database like the developer portal. To create an App Group for a macOS app, follow these steps:\n\nClick the Add button (+) below the App Groups list.\n\nDouble-click the new App Group to edit it.\n\nAppend a string, in reverse DNS notation, after the $(TeamIdentifierPrefix) build variable.\n\n$(TeamIdentifierPrefix)com.example.mygroup\n\n\nPress Return to save the updated App Group.\n\nNote\n\nXcode automatically resolves the $(TeamIdentifierPrefix) build variable to your individual Team ID when it builds your app.\n\nAfter you add a macOS app an App Group, you can revoke its membership by selecting the appropriate App Group and clicking the Remove button (-) below the App Groups list.\n\nCreate App Groups for all other platforms\n\nAfter adding the App Groups capability to apps for platforms other than macOS, Xcode retrieves any existing groups from your developer account and displays them in the capability’s section. Use the Refresh button below the App Groups list to re-fetch your account’s groups at any time. Each developer account can register a maximum of 1000 App Groups.\n\nEnable one or more groups in the list by using their check-boxes to add your app as a member of those groups. Conversely, uncheck a group’s checkbox to revoke your app’s membership.\n\nTo create an App Group for an iOS, watchOS, or tvOS app, perform the following:\n\nClick the Add button (+) below the App Groups list.\n\nEnter a container ID in the dialog that appears. A container ID must begin with group. and then a custom string in reverse DNS notation.\n\nClick OK to save the new App Group.\n\nXcode automatically selects the new App Group in the App Groups list; this selection indicates that your app is now a member of that App Group.\n\nAccess an App Group’s shared container\n\nWhen your app becomes a member of an App Group, there are a number of APIs you can use to read and write data to that group’s shared container, such as:\n\nSharing preferences and other limited data by using the init(suiteName:) method to access the App Group’s shared user defaults database.\n\nRetrieving the physical location of the App Group’s shared container by calling the containerURL(forSecurityApplicationGroupIdentifier:) method, which you can later use to read and write data.\n\nSet the sharedContainerIdentifier property on the configuration of a background URL session to download files directly into the App Group’s shared container.\n\nSee Also\nData management\nConfiguring an associated domain\nCreate a two-way association between your app and your website to enable universal links, Handoff, App Clips, and shared web credentials.\nConfiguring iCloud services\nShare user or app data among multiple instances of your app running on different devices."
  },
  {
    "title": "Configuring an associated domain | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-an-associated-domain",
    "html": "Overview\n\nThe system uses associated domains to initiate a secure association between your app and specific domains so they can share saved passwords, perform Handoff activities, and support universal links that allow users to open your app in a specific context and quickly complete their current task. To create such an association, you configure your app with the necessary entitlements by using Xcode to define associated domains, and then serve a special file from your web server that the system requires in order to verify those entitlements.\n\nBefore you can define associated domains and the services they provide, follow the steps in the Add a capability section of Adding capabilities to your app to add the capability to your app’s target, making sure you select the Associated Domains capability from Xcode’s Capabilities library. For watchOS apps with separate WatchKit extensions, add the capability to the WatchKit Extension target.\n\nIf not already present, Xcode updates your target’s entitlements file to include the Associated Domains Entitlement, which is an array that contains each associated domain you define. If you enable the “Automatically manage signing” option for your target, Xcode also updates your app’s App ID in the developer portal and generates and downloads an updated provisioning profile.\n\nNote\n\nIf you later remove the Associated Domains capability in Xcode, you must manually update your App ID’s configuration in the developer portal to fully disable the feature.\n\nDefine a service and its associated domain\n\nWhen you want your app and one or more of your websites to interact using predefined services, define an associated domain by performing the following steps. Xcode automatically updates the com.apple.developer.associated-domains array in your target’s entitlements file to include those you define.\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Associated Domains capability.\n\nClick the Add button (+) to insert a service-domain placeholder.\n\nDouble-click the inserted placeholder to edit it.\n\nUpdate the placeholder to contain the service your app supports and its associated domain, which must be in the following format:\n\n<service>:<fully qualified domain>\n\n\nOnly include the top-level domain and, where necessary, the subdomain; don’t include path and query components, or a trailing slash.\n\nTip\n\nFor services other than App Clips, prefix a domain with *. to include all of its subdomains.\n\nThe following table describes the services that associated domains support:\n\nService\n\n\t\n\nDescription\n\n\n\n\nwebcredentials\n\n\t\n\nIf your domain supports shared web credentials, see Managing Shared Credentials for more information.\n\n\n\n\napplinks\n\n\t\n\nIf your domain supports universal links, see Supporting universal links in your app for more information.\n\n\n\n\nactivitycontinuation\n\n\t\n\nIf your domain supports Handoff, see Web Browser-to-Native App Handoff for more information.\n\n\n\n\nappclips\n\n\t\n\nIf your domain supports App Clips, see Associating your App Clip with your website for more information.\n\nProvide an Apple App Site Association file\n\nWhen the user installs your app that contains associated domains, the system fetches the corresponding Apple App Site Association (AASA) file from an Apple-managed content delivery network (CDN) and uses its JSON contents to verify those associated domains. If the CDN doesn’t store a copy of that file, or has an outdated version, it automatically connects to your server and retrieves the latest version.\n\nAfter you define your app’s associated domains in Xcode, you must create this file and serve it using HTTPS from your website’s .well-known directory. For more information, see Add the associated domain file to your website.\n\nEnable alternate mode for unreachable servers\n\nIf you use a private web server while developing your app that’s unreachable from the public internet, enable alternate mode — an option you specify that allows the system to bypass Apple’s CDN and fetch the AASA file directly from your web server.\n\nFollow these steps to enable alternate mode on a specific associated domain:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Associated Domains capability.\n\nDouble-click the associated domain in the Domains list to edit it.\n\nAppend the string ?mode=<alternate mode> to the associated domain. Replace <alternate mode> with one of the modes shown in the list below.\n\nPress Return to save the updated associated domain.\n\nThe following table describes the alternate modes that associated domains support:\n\nMode\n\n\t\n\nDescription\n\n\n\n\ndeveloper\n\n\t\n\nThe domain is accessible from devices in developer mode. You must sign the app with a development profile and users must opt-in on their device by enabling the Associated Domains Development option in Settings.app > Developer.\n\n\n\n\nmanaged\n\n\t\n\nThe domain is accessible from devices using a mobile device management (MDM) profile and that have authorization from the MDM administrator.\n\n\n\n\ndeveloper+managed\n\n\t\n\nThe domain is accessible only from devices that are in both developer and managed modes.\n\nImportant\n\nOnly use alternate mode during development; you must remove the query string from the associated domains before you submit your app to the App Store.\n\nSee Also\nData management\nConfiguring App Groups\nEnable communication and data sharing between multiple installed apps created by the same developer.\nConfiguring iCloud services\nShare user or app data among multiple instances of your app running on different devices."
  },
  {
    "title": "Configuring Siri support | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-siri-support",
    "html": "Overview\n\nTo process user requests that originate from Siri, first add the Siri capability to your app’s target. This informs the system that your app is ready to resolve, confirm, and handle SiriKit intents, typically through its Intents extension; in iOS 14 and later, you can choose to perform each of these steps from within your app.\n\nAfter you configure your app to process SiriKit intents, add code — to your app delegate or your Intents extension — to route incoming intents to your custom handlers. For more information, see Dispatching intents to handlers.\n\nNote\n\nwatchOS doesn’t support all intent types. For example, a watchOS app can’t start a video call or handle intents in the CarPlay domain. Check an intent’s availability information to determine whether you can use it on watchOS.\n\nAdd the Siri capability to your target\n\nFollow the steps in Add a capability to add the capability to your app’s target, making sure you select the Siri capability from Xcode’s Capabilities library. For watchOS apps with separate WatchKit extensions, you must add the capability to the WatchKit Extension target. The capability isn’t available for macOS.\n\nAfter you add the Siri capability, Xcode automatically updates the entitlements file of your target to include the Siri Entitlement. The App Store requires this entitlement for any app that contains an Intents extension that handles non-shortcut Siri requests.\n\nHandle SiriKit intents in an Intents extension\n\nUse an Intents extension to respond to the user’s request from Siri quickly and without incurring the performance cost of loading the entire app into memory. To use an extension, you must first complete a number of additional configuration steps, such as adding one or more Intents extensions to your app’s target and specifying the types of intents those extensions support. For more information, see Add an Intents App Extension to Your Project.\n\nHandle SiriKit intents directly in your app\n\nIn iOS 14 and later, you can choose not to use an Intents extension, and instead respond to the user’s request directly from within your iOS app. To do this, override the application(_:handlerFor:) method in your app delegate and use it to map incoming intents to the objects that are capable of handling them.\n\nIn the same way you configure an Intents extension, you must specify the types of intents that your iOS app supports. For more information, see Specify the Intents Your Extension Supports.\n\nSee Also\nApp execution\nConfiguring background execution modes\nIndicate the background services your app requires to continue executing in the background in iOS, tvOS, visionOS, and watchOS.\nConfiguring custom fonts\nRegister your app as a provider or consumer of systemwide custom fonts.\nConfiguring game controllers\nEnhance gameplay input by enabling the discovery, configuration, and use of physical game controllers.\nConfiguring Maps support\nRegister your iOS routing app to provide point-to-point directions to Maps and other apps."
  },
  {
    "title": "Configuring Wallet support | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-wallet-support",
    "html": "Overview\n\nThe Wallet app on iOS and watchOS allows users to organize their passes — tickets, gift cards, loyalty cards, boarding passes, and the payment cards they use with Apple Pay. By integrating with PassKit (Apple Pay and Wallet), your app can access any related passes and allow the user to manage them.\n\nTo use Wallet in your app, add the capability by configuring your app’s target in Xcode and, optionally, specify which pass types your app supports. Follow the instructions in the Add a capability section of Adding capabilities to your app. When you reach the Capabilities library, choose Wallet. For watchOS apps with separate WatchKit extensions, add the capability to the WatchKit Extension’s target. The capability isn’t available for macOS or tvOS.\n\nAfter you add the Wallet capability, Xcode updates your target’s entitlements file to include the Pass Type IDs Entitlement — an array containing the single wildcard value $(TeamIdentifierPrefix)*. This value allows your app to access passes of every pass type that you define in the developer portal; use the configuration options of the capability to narrow the scope of accessible pass types to only those your app requires.\n\nImportant\n\nThe capability fetches and displays the pass type identifiers you register in the developer portal; Xcode doesn’t provide a way to register them locally. For more information, see Create Wallet identifiers and certificates.\n\nRestrict your app to a subset of pass types\n\nTo minimize potential security risks and help protect the user’s privacy, follow these steps to provide your app with access to only the pass type identifiers it requires to function properly:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target from the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Wallet capability.\n\nSelect the “Enable subset of pass types” option.\n\nXcode enables all pass type identifiers by default; disable individual identifiers by unchecking their checkboxes.\n\nXcode updates the com.apple.developer.pass-type-identifiers array in the app’s entitlements file to include only the enabled pass type identifiers, and if present, removes the wildcard value.\n\nAfter enabling the required pass type identifiers, use the passes() method of PKPassLibrary to retrieve the passes accessible to your app, or pass(withPassTypeIdentifier:serialNumber:) to fetch a specific pass. For more information on creating, distributing, and updating passes, see Wallet Passes.\n\nSee Also\nCommerce\nConfiguring Apple Pay support\nProcess payments in your app using the payment information the user stores on their device.\nConfiguring Sign in with Apple support\nAllow users to create an account and sign in to your app with their Apple ID."
  },
  {
    "title": "Configuring Sign in with Apple support | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-sign-in-with-apple",
    "html": "Overview\n\nSign in with Apple gives your users the option to sign in to your app with their existing Apple ID instead of creating a separate username and password. All Apple devices support Sign in with Apple. For information about using this feature in the browser, see Sign in with Apple JS.\n\nTo use Sign in with Apple in your app, add the capability by configuring your app’s target in Xcode, set up the user interface and necessary authorizations, and register your domain with Apple’s relay service to ensure you can send emails to your users’ personal inboxes.\n\nNote\n\nIf your app targets an OS version that predates the availability of Sign in with Apple, use the JavaScript library to provide the same functionality. For more information, see Incorporating Sign in with Apple into other platforms.\n\nAdd the Sign in with Apple capability to your app\n\nFollow the instructions in the Add a capability section of Adding capabilities to your app. When you reach the Capabilities library, choose Sign in with Apple. For watchOS apps with separate WatchKit extensions, add the capability to the WatchKit Extension’s target.\n\nAfter you add the capability, Xcode updates the target’s entitlements to include the Sign in with Apple Entitlement — an array that contains a single string of Default, the value that represents normal operation. If you configure Xcode to automatically manage app signing, then at this point, Xcode also enables Sign in with Apple for your app’s App ID in the developer portal.\n\nNote\n\nIf you later remove the Sign in with Apple capability in Xcode, you must manually update your App ID’s configuration in the developer portal to disable Sign in with Apple.\n\nUsers must provide their consent before Apple shares any information with your app. If you have a number of related apps — for example, an iOS app and a macOS app — group their App IDs so the user only needs to provide consent on the first device they use to access your app. For more information, see Group Apps for Sign in with Apple.\n\nPrompt the user to sign in with their Apple ID\n\nAfter you add the Sign in with Apple capability to your Xcode project, update your app’s user interface to enable users to sign in with their Apple ID. For a reference implementation of the following steps, see the sample code Implementing User Authentication with Sign in with Apple.\n\nAdd a Sign in with Apple button to your app’s user interface using ASAuthorizationAppleIDButton or WKInterfaceAuthorizationAppleIDButton.\n\nAdd a handler for the button that creates an instance of ASAuthorizationAppleIDRequest. Make sure you set the request’s requestedScopes property. For more information, see ASAuthorization.Scope.\n\nPerform the authorization request with ASAuthorizationController, prompting the user to sign in with their Apple ID and consent to Apple sharing their details with your app.\n\nImplement the ASAuthorizationControllerDelegate protocol to determine the outcome of the authorization request and, if successful, receive the credential — an instance of ASAuthorizationAppleIDCredential that contains details about the user.\n\nIf your app stores account information on a remote server, send the credential’s contents to that server. The remote server verifies the data’s legitimacy with the Apple ID servers before creating or updating a user account. For more information, see Authenticating users with Sign in with Apple.\n\nReceive updates about Apple ID account changes\n\nIf your app uses a remote server to manage user accounts, turn on server-to-server notifications so that the Apple ID servers notify you when users make changes to their Apple ID. The Apple ID servers send notifications when users change their mail forwarding preferences, delete their app account, or permanently delete their Apple ID. Use these notifications to maintain a canonical list of users. For more information, see Enabling Server to Server Notifications.\n\nSend emails to users’ hidden inboxes\n\nIf you include the email scope when you prompt the user for authorization, the system provides an option for that user to hide their real email address and instead use a unique, random forwarding email address that Apple provides. To help prevent spam and ensure that emails to users originate from your registered domains and email addresses, follow these steps:\n\nRegister the domains and subdomains that you use for email communication.\n\nRegister a list of unique email addresses that you use to send email.\n\nAuthenticate your registered domains using the Sender Policy Framework (SPF) and DomainKeys Identified Mail (DKIM) protocol.\n\nYou must complete these steps before you can send emails to your users’ hidden inboxes. For more information, see Configure Private Email Relay Service.\n\nSee Also\nCommerce\nConfiguring Apple Pay support\nProcess payments in your app using the payment information the user stores on their device.\nConfiguring Wallet support\nAccess the user’s Wallet to add, update, and display your app’s passes."
  },
  {
    "title": "Configuring Apple Pay support | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-apple-pay-support",
    "html": "Overview\n\nApple Pay lets the user store payment information on their device and then use it to quickly purchase goods and services in your app. Your app creates a payment request that Apple Pay transfers between your app, the Apple Pay servers, and your payment provider. Apple Pay leverages the device’s Secure Element to help protect the user’s payment information.\n\nTo use Apple Pay in your app, add the capability to configure your app’s target with the necessary entitlements, and create a merchant identifier and payment processing certificate to help secure transaction data. For more detailed information about these steps, see the video Configuring Your Developer Account for Apple Pay.\n\nBefore you create a merchant identifier or select an existing one, follow the instructions in the Add a capability section of Adding capabilities to your app. When you reach the Capabilities library, choose Apple Pay. For watchOS apps with separate WatchKit extensions, add the capability to the WatchKit Extension’s target. The Apple Pay capability isn’t available for tvOS apps.\n\nAfter you add the Apple Pay capability, Xcode updates your target’s entitlements file to include the Merchant IDs Entitlement, which is an array that contains the merchant identifiers you select. If you configure Xcode to automatically manage app signing, then at this point, Xcode also enables Apple Pay for your app’s App ID in the developer portal.\n\nNote\n\nIf you later remove the Apple Pay capability in Xcode, you must manually update your App ID’s configuration in the developer portal to disable Apple Pay.\n\nSelect or create a merchant identifier\n\nA merchant identifier uniquely identifies you to Apple Pay as a merchant that’s able to accept payments. To allow your app to submit payment requests, specify at least one merchant identifier in your project’s configuration. After you add the Apple Pay capability, Xcode retrieves any existing merchant identifiers from your developer account and displays them in the capability’s Merchant IDs list. To fetch an updated list of your account’s merchant identifiers, click the refresh button below the list.\n\nEnable one or more merchant identifiers in the list using their checkboxes. Conversely, uncheck a merchant identifier’s checkbox to disallow your app from using it. Xcode updates the Merchant IDs array — com.apple.developer.in-app-payments — in your target’s entitlements file to reflect any changes you make, and associates the selected merchant identifiers with the app’s App ID in the developer portal.\n\nNote\n\nTo avoid breaking a live version of your app that relies on the identifier association, Xcode doesn’t automatically dissociate a merchant identifier from your App ID when you deselect it in the capability.\n\nTo create a new merchant identifier, perform the following steps:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Apple Pay capability.\n\nClick the Add button (+) below the Merchant IDs list.\n\nEnter a merchant identifier in the dialog that appears. It’s preferrable to prefix a merchant identifier with merchant. and then append a custom string in reverse DNS notation.\n\nClick OK to save the new merchant identifier.\n\nXcode automatically registers the merchant identifier in the developer portal, adds it to your target’s entitlements file, and selects it in the Merchant IDs list, indicating that your app is now able to use the new merchant identifier.\n\nCreate a payment processing certificate\n\nBefore you can use your merchant identifier, you must generate a payment processing certificate — a digital certificate that secures transaction data and proves its origin. The Apple Pay servers use the certificate’s public key to encrypt payment data, and you or your payment service provider use the certificate’s private key to decrypt the data and process the payment. For more information on creating the certificate, see Create a payment processing certificate.\n\nNote\n\nIf you use an e-commerce platform or payment service provider, please contact them for information about using their service with Apple Pay. For a list of supported platforms and providers, see Payment Platforms.\n\nAfter you create your merchant identifier and payment processing certificate, use the PassKit framework to enable the collection of payments from within your app. For more information, see the Apple Pay documentation and the sample code Offering Apple Pay in Your App.\n\nSee Also\nCommerce\nConfiguring Sign in with Apple support\nAllow users to create an account and sign in to your app with their Apple ID.\nConfiguring Wallet support\nAccess the user’s Wallet to add, update, and display your app’s passes."
  },
  {
    "title": "Configuring custom fonts | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-custom-fonts",
    "html": "Overview\n\nIn iOS 13 and later, your iOS app can contribute fonts for systemwide use and leverage fonts that other apps install.\n\nWhen an app attempts the install one or more fonts systemwide, iOS prompts the user for their permission. If the user agrees, the installed fonts become accessible in Settings > General > Fonts. If your app provides installable fonts, include a UI that allows the user to browse those fonts and manage their registration.\n\nYou must store installable fonts in the app bundle or deliver them using On-Demand Resources, because the system prohibits an app from installing arbitrary fonts. Provide fonts in the TTF, OTF, or TTC formats or any of their modern variants, and package large font libraries as asset catalogs.\n\nThe system limits the number of installed fonts, and it derives that limit from the available system resources. If the user deletes your app, the system automatically removes any of the app’s installed fonts.\n\nTo register your app as a provider or consumer of systemwide custom fonts, follow the steps in Add a capability to add the Fonts capability to your app’s target.\n\nNote\n\nThe Fonts capability is only available to use with iOS apps that target iOS 13 and later.\n\nSelect the required privileges\n\nBefore your iOS app can install one or more custom fonts or use fonts that other apps provide, you must enable the necessary privileges by performing the following:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the iOS app’s target from the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Fonts capability.\n\nSelect the required privileges using the corresponding checkboxes.\n\nTip\n\nFonts privileges aren’t exclusive; your iOS app can provide fonts for use in other apps and consume fonts that other apps install systemwide.\n\nXcode adds the com.apple.developer.user-fonts array to your app’s entitlements file, if not already present, and uses the privileges you enable to populate that array with the corresponding values.\n\nAfter enabling the required privileges, update your app to perform one or more of the following:\n\nRegister fonts systemwide using one of these registration methods:\n\nCTFontManagerRegisterFontURLs(_:_:_:_:)\n\nCTFontManagerRegisterFontDescriptors(_:_:_:_:)\n\nCTFontManagerRegisterFontsWithAssetNames(_:_:_:_:_:)\n\nRemove installed fonts using one of these unregister methods:\n\nCTFontManagerUnregisterFontURLs(_:_:_:)\n\nCTFontManagerUnregisterFontDescriptors(_:_:_:)\n\nQuery all installed fonts using CTFontManagerRequestFonts(_:_:)\n\nListen for font change notifications using kCTFontManagerRegisteredFontsChangedNotification\n\nFor more information, see the WWDC session video Font Management and Text Scaling.\n\nSee Also\nApp execution\nConfiguring background execution modes\nIndicate the background services your app requires to continue executing in the background in iOS, tvOS, visionOS, and watchOS.\nConfiguring game controllers\nEnhance gameplay input by enabling the discovery, configuration, and use of physical game controllers.\nConfiguring Maps support\nRegister your iOS routing app to provide point-to-point directions to Maps and other apps.\nConfiguring Siri support\nEnable your app and its Intents extension to resolve, confirm, and handle user-driven Siri requests for your app’s services."
  },
  {
    "title": "Configuring game controllers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-game-controllers",
    "html": "Overview\n\nGame controllers provide physical controls to trigger actions in your game. Apple specifies the look and behavior of the controls to MFi accessory manufacturers, which means you can rely on a consistent set of high-quality controls in all supported game controllers.\n\nA game that supports game controllers enables one or more different game-controller profiles — objects that map physical controls on a device to the inputs your game requires — such as Extended, Micro, and Directional. The game also specifies the preferred order of use for these profiles. After retrieving a profile from the connected game controller, your game periodically requests the device’s current values or installs handlers that the system invokes when those values change.\n\nBefore you can select the profiles your game supports, follow the steps in Add a capability to add the Game Controllers capability to your game’s target.\n\nAfter you add the Game Controllers capability to your game’s target, Xcode appends the GCSupportsControllerUserInteraction key to its Info.plist file with a value of true to indicate to the system that your game supports game controllers.\n\nNote\n\nThe Game Controllers capability is only available to games that target iOS, iPadOS, and tvOS.\n\nSelect the supported game controller profiles\n\nWhen you add support for game controllers to your app, you don’t integrate with specific hardware. Instead, you integrate one or more of the game-controller profiles that the Game Controller framework provides. Each profile maps to a control layout that Apple defines, and that profile describes a set of physical controls that the hardware manufacturer guarantees to be available on the controller.\n\nTo indicate to the system which game-controller profiles your game supports, perform the following steps:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the game’s target from the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Game Controllers capability.\n\nSelect the appropriate game controller profiles by checking their checkboxes.\n\nXcode adds the GCSupportedGameControllers array to your game’s Info.plist file, if it’s not already present, and populates it with names of the selected game-controller profiles. For more information about each profile, see GCExtendedGamepad, GCMicroGamepad, and GCDirectionalGamepad.\n\nHardware controllers can support multiple profiles; if you enable more than one game controller profile, drag the profiles and arrange them in your preferred order. For example, if your game supports both the Extended and Micro profiles, but optimizes gameplay for the Micro profile, place that profile at the top of the list.\n\nFor more information, see the video Tap into virtual and physical game controllers and the sample code Supporting Game Controllers.\n\nSee Also\nApp execution\nConfiguring background execution modes\nIndicate the background services your app requires to continue executing in the background in iOS, tvOS, visionOS, and watchOS.\nConfiguring custom fonts\nRegister your app as a provider or consumer of systemwide custom fonts.\nConfiguring Maps support\nRegister your iOS routing app to provide point-to-point directions to Maps and other apps.\nConfiguring Siri support\nEnable your app and its Intents extension to resolve, confirm, and handle user-driven Siri requests for your app’s services."
  },
  {
    "title": "Configuring Maps support | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-maps-support",
    "html": "Overview\n\nAn iOS app that’s able to display point-to-point directions can register as a routing app and make those directions available to Maps along with all other apps on a user’s device. Registering as a routing app improves the user experience because other apps can access your app’s routing information, and these apps don’t need to provide their own routing directions. Because Maps displays apps in the App Store that provide directions, registering your iOS app as a routing app is a great way to let users know about it.\n\nA routing app provides specific directions in addition to what Maps supports, such as subway routes, hiking trails, and bike paths. Before you can select the routing modes that your app supports, follow the steps in Add a capability to add the Maps capability to your app’s target.\n\nNote\n\nThis capability is only applicable to custom routing apps on iOS. You don’t need to add the Maps capability to a macOS app to be able to use the MapKit framework.\n\nSelect the supported routing modes\n\nBefore the system can distribute requests for directions to your routing app, you must inform it of the routing modes your app supports by following these\nsteps:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target from the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Maps capability.\n\nSelect the relevant routing modes by checking the corresponding checkboxes.\n\nXcode adds the MKDirectionsApplicationSupportedModes array to your app’s Info.plist file (if not already present) and uses the modes you select to populate the array with the necessary values.\n\nAfter you select the necessary routing modes, there are additional configuration steps you must complete before your app can start providing point-to-point directions, such as specifying a directions request document type and declaring your app’s geographic region. For more information, see Configuring Your App to Accept Direction Requests.\n\nSee Also\nApp execution\nConfiguring background execution modes\nIndicate the background services your app requires to continue executing in the background in iOS, tvOS, visionOS, and watchOS.\nConfiguring custom fonts\nRegister your app as a provider or consumer of systemwide custom fonts.\nConfiguring game controllers\nEnhance gameplay input by enabling the discovery, configuration, and use of physical game controllers.\nConfiguring Siri support\nEnable your app and its Intents extension to resolve, confirm, and handle user-driven Siri requests for your app’s services."
  },
  {
    "title": "Allowing apps and websites to link to your content | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content",
    "html": "Overview\n\nYou can connect to content deep inside your app with universal links. Users open your app in a specified context, allowing them to accomplish their goals efficiently.\n\nWhen users tap or click a universal link, the system redirects the link directly to your app without routing through Safari or your website. In addition, because universal links are standard HTTP or HTTPS links, one URL works for both your website and your app. If the user has not installed your app, the system opens the URL in Safari, allowing your website to handle it.\n\nWhen users install your app, the system checks a file stored on your web server to verify that your website allows your app to open URLs on its behalf. Only you can store this file on your server, securing the association of your website and your app.\n\nSupport universal links\n\nTake the following steps to support universal links:\n\nCreate a two-way association between your app and your website and specify the URLs that your app handles, as described in Supporting associated domains.\n\nUpdate your app delegate to respond to the user activity object the system provides when a universal link routes to your app, as described in Supporting universal links in your app.\n\nWith universal links, users open your app when they click links to your website within Safari and WKWebView, and when they click links that result in a call to:\n\nopen(_:options:completionHandler:) in iOS and tvOS\n\nopenSystemURL(_:) in watchOS\n\nopen(_:withApplicationAt:configuration:completionHandler:) in macOS\n\nopenURL in SwiftUI\n\nNote\n\nIf your app uses one of the above methods to open a universal link to your website, the link won’t open in your app.\n\nWhen a user browses your website in Safari and taps a universal link in the same domain, the system opens that link in Safari, respecting the user’s most likely intent to continue within the browser. If the user taps a universal link in a different domain, the system opens the link in your app.\n\nCommunicate with other apps\n\nApps can communicate through universal links. Supporting universal links allows other apps to send small amounts of data directly to your app without using a third-party server. \n\nDefine the parameters that your app handles within the URL query string. The following example code for a photo library app specifies parameters that include the name of an album and the index of a photo to display.\n\nhttps://myphotoapp.example.com/albums?albumname=vacation&index=1\nhttps://myphotoapp.example.com/albums?albumname=wedding&index=17\n\n\nOther apps craft URLs based on your domain, path, and parameters and ask your app to open them by calling:\n\nThe open(_:options:completionHandler:) method of UIApplication in iOS and tvOS\n\nThe openSystemURL(_:) method of WKExtension in watchOS\n\nThe open(_:withApplicationAt:configuration:completionHandler:) method of NSWorkspace in macOS\n\nThe openURL environment value in SwiftUI\n\nThe calling app can ask the system to inform it when your app opens the URL.\n\nIn this example code, an app calls your universal link in iOS and tvOS:\n\nif let appURL = URL(string: \"https://myphotoapp.example.com/albums?albumname=vacation&index=1\") {\n    UIApplication.shared.open(appURL) { success in\n        if success {\n            print(\"The URL was delivered successfully.\")\n        } else {\n            print(\"The URL failed to open.\")\n        }\n    }\n} else {\n    print(\"Invalid URL specified.\")\n}\n\n\nIn this example code, an app calls your universal link in watchOS:\n\nif let appURL = URL(string: \"https://myphotoapp.example.com/albums?albumname=vacation&index=1\") {\n    WKExtension.shared().openSystemURL(appURL)\n} else {\n    print(\"Invalid URL specified.\")\n}\n\n\nIn this example code, an app calls your universal link in macOS:\n\nif let appURL = URL(string: \"https://myphotoapp.example.com/albums?albumname=vacation&index=1\") {\n    let configuration = NSWorkspace.OpenConfiguration()\n    NSWorkspace.shared.open(appURL, configuration: configuration) { (app, error) in\n        guard error == nil else {\n            print(\"The URL failed to open.\")\n            return\n        }\n        print(\"The URL was delivered successfully.\")\n    }\n} else {\n    print(\"Invalid URL specified.\")\n}\n\n\nFor more information on handling links within your app, see Supporting universal links in your app.\n\nTopics\nUniversal links\nSupporting universal links in your app\nPrepare your app to respond to an incoming universal link.\nAssociated domains\nSupporting associated domains\nConnect your app and a website to provide both a native app and a browser experience.\nCustom URLs\nDefining a custom URL scheme for your app\nUse specially formatted URLs to link to content within your app.\nDefault apps\nPreparing your app to be the default web browser\nConfigure your browser app so users can set it as the default on their device instead of Safari."
  },
  {
    "title": "Configuring background execution modes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-background-execution-modes",
    "html": "Overview\n\nTypically, an app is in a suspended state when it’s in the background. However, there are a limited number of background execution modes your app can support that enable it to run when in the background, such as playing audio, receiving location updates, or processing scheduled tasks. For apps that adopt one or more of these modes, the system launches or resumes the app, in the background, and affords it time to process any related events.\n\nUse background execution modes sparingly because overuse can negatively impact device performance and battery life. If an alternative to executing in the background exists, use the alternative instead. For example, apps can use the significant-change location service to receive location events as an alternative to using the Location updates background mode.\n\nBefore you can select the background execution modes your app requires, follow the steps in Add a capability to add the Background Modes capability to your app’s target.\n\nThe background execution modes that appear after you add the capability depend on the target’s platform. For watchOS apps with separate WatchKit extensions, you need to add the capability to the WatchKit Extension target.\n\nNote\n\nThe Background Modes capability isn’t available for macOS apps.\n\nSpecify the background modes your app requires\n\nBefore your app can leverage one or more background execution modes, you need to declare the modes it requires by performing the following:\n\nSelect your project in Xcode’s Project navigator.\n\nSelect the app’s target in the Targets list.\n\nClick the Signing & Capabilities tab in the project editor.\n\nFind the Background Modes capability.\n\nSelect one or more background execution modes using the corresponding checkboxes.\n\nFor watchOS apps, choose the appropriate session type from the pop-up menu. For more information, see Using extended runtime sessions.\n\nXcode adds the UIBackgroundModes array to your app’s Info.plist file, if it isn’t already present, and uses the modes you select to populate the array with the necessary values.\n\nApple’s platforms support these background execution modes:\n\nMode\n\n\t\n\nValue\n\n\t\n\nDescription\n\n\t\n\nPlatforms\n\n\n\n\nAudio, AirPlay, and Picture in Picture\n\n\t\n\naudio\n\n\t\n\nThe app plays audible content in the background. For more information, see Configuring your app for media playback.\n\n\t\n\niOS, iPadOS, tvOS, visionOS\n\n\n\n\nAudio\n\n\t\n\naudio\n\n\t\n\nThe app plays audible content in the background. For more information, see Playing Background Audio.\n\n\t\n\nwatchOS\n\n\n\n\nLocation updates\n\n\t\n\nlocation\n\n\t\n\nThe app provides location-based information and requires the use of the platform’s standard location service. For more information, see Configuring your app to use location services.\n\n\t\n\niOS, iPadOS, watchOS\n\n\n\n\nVoice over IP\n\n\t\n\nvoip\n\n\t\n\nThe app provides Voice over IP services and requires automatic launch after system restart. For more information, see the CallKit framework.\n\n\t\n\niOS, iPadOS, visionOS, watchOS\n\n\n\n\nExternal accessory communication\n\n\t\n\nexternal-accessory\n\n\t\n\nThe app communicates with an accessory that delivers data at regular intervals. For more information, see the External Accessory framework.\n\n\t\n\niOS, iPadOS\n\n\n\n\nUses Bluetooth LE accessories\n\n\t\n\nbluetooth-central\n\n\t\n\nThe app communicates with a Bluetooth accessory while in the background. For more information, see the Core Bluetooth framework.\n\n\t\n\niOS, iPadOS, visionOS\n\n\n\n\nActs as a Bluetooth LE accessory\n\n\t\n\nbluetooth-peripheral\n\n\t\n\nThe app uses peripheral mode to communicate with a Bluetooth accessory. For more information, see the Core Bluetooth framework.\n\n\t\n\niOS, iPadOS\n\n\n\n\nBackground fetch\n\n\t\n\nfetch\n\n\t\n\nThe app requires new content from the network at regular intervals. For more information, see Using background tasks to update your app.\n\n\t\n\niOS, iPadOS, tvOS, visionOS\n\n\n\n\nRemote notifications\n\n\t\n\nremote-notification\n\n\t\n\nThe app uses push notifications as a signal that new content is available to download. For more information, see Pushing background updates to your App.\n\n\t\n\niOS, iPadOS, tvOS, visionOS, watchOS\n\n\n\n\nBackground processing\n\n\t\n\nprocessing\n\n\t\n\nThe app executes scheduled tasks while in the background. For more information, see BGTaskScheduler.\n\n\t\n\niOS, iPadOS, tvOS, visionOS\n\n\n\n\nWorkout processing\n\n\t\n\nworkout-processing\n\n\t\n\nThe app uses a workout session to track a user’s activity on Apple Watch. For more information, see Running workout sessions.\n\n\t\n\nwatchOS\n\n\n\n\nUses Nearby Interaction\n\n\t\n\nnearby-interaction\n\n\t\n\nThe app locates and interacts with nearby devices. For more information, see the Nearby Interaction framework.\n\n\t\n\niOS, iPadOS\n\n\n\n\nPush to Talk\n\n\t\n\npush-to-talk\n\n\t\n\nThe app launches in response to a push notification and plays audible content in the background. For more information, see the Push to Talk framework.\n\n\t\n\niOS, iPadOS\n\nSee Also\nApp execution\nConfiguring custom fonts\nRegister your app as a provider or consumer of systemwide custom fonts.\nConfiguring game controllers\nEnhance gameplay input by enabling the discovery, configuration, and use of physical game controllers.\nConfiguring Maps support\nRegister your iOS routing app to provide point-to-point directions to Maps and other apps.\nConfiguring Siri support\nEnable your app and its Intents extension to resolve, confirm, and handle user-driven Siri requests for your app’s services."
  },
  {
    "title": "Embedding a command-line tool in a sandboxed app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/embedding-a-helper-tool-in-a-sandboxed-app",
    "html": "Overview\n\nWhen building an app for the Mac, you can embed a command-line tool in the app to act as a helper tool. Instances where this may be helpful include, for example:\n\nYou want to run some code in a separate process. In many cases, an XPC service is a better choice for this, but sometimes it’s easier to embed a command-line tool.\n\nYou want to build a command-line tool with an external build system (for example, make) and then run it from your app.\n\nEmbedding a command-line tool in a sandbox app does present some unique challenges. The best approach depends on whether you’re building the tool with Xcode or using a tool built by an external build system.\n\nNote\n\nThese steps assume that you’re building an app for the App Store because that’s the most common destination for sandboxed apps. However, the same basic process works for apps distributed independently using Developer ID signing; you just need to choose a different distribution path in the Xcode organizer.\n\nCreate the app project\n\nTo get started, create a new project from the macOS > App template. Name it AppWithTool, resulting in a bundle ID like com.example.apple-samplecode.AppWithTool.\n\nIn the project editor, set the deployment target to 10.15. Later on, you’ll configure the tool target to inherit this deployment target, which helps to keep everything in sync.\n\nIn the General tab of the app target editor, set the App Category to Utilities. This avoids a warning when you build for distribution.\n\nIn the Signing & Capabilities tab of the app target editor, make sure “Automatically manage signing” is checked, and then select the appropriate team. The Signing Certificate popup should switch to Development, which is exactly what you want for day-to-day development.\n\nAdd the Hardened Runtime capability, which isn’t necessary for App Store apps but is best practice for new code.\n\nChoose Product > Archive, which builds the app into an Xcode archive and reveals that archive in the Xcode organizer. The goal here is to check that everything is working so far.\n\nIn the organizer, delete the new archive, just to reset to the original state.\n\nCreate the helper tool target\n\nWith the app target in the project building correctly, it’s time to create a helper tool target so you can embed its product into the app. To start, create a new target from the macOS > Command Line Tool template. Name this ToolX, where the X stands for built with Xcode.\n\nIn the General tab of the tool target editor, clear the Deployment Target field. This configures the tool target to inherit its deployment target (macOS 10.15) from the project.\n\nIn the Signing & Capabilities tab of the tool target editor, ensure that “Automatically manage signing” is checked, and then select the appropriate team. Again, the Signing Certificate popup switches to Development.\n\nFill in the Bundle Identifier field. The app’s bundle ID is com.example.apple-samplecode.AppWithTool, so set this to com.example.apple-samplecode.AppWithTool.ToolX. This value becomes the helper tool’s code signing identifier. See the discussion of the Other Code Signing Flags build setting, below.\n\nAdd the App Sandbox and Hardened Runtime capabilities. Again, the hardened runtime isn’t required for App Store apps, but it’s best practice for new code.\n\nIn the Build Settings tab, enable the Skip Install (SKIP_INSTALL) build setting. Without this setting, Xcode puts a standalone copy of the tool in your Xcode archive (in addition to the one embedded within your app). That copy of the tool causes problems when you try to distribute that archive.\n\nAlso, disable the Code Signing Inject Base Entitlements (CODE_SIGN_INJECT_BASE_ENTITLEMENTS) build setting. If you leave this setting enabled, then Xcode includes the com.apple.security.get-task-allow entitlement in development builds of your tool. This is problematic because that entitlement is incompatible with the com.apple.security.inherit entitlement.\n\nImportant\n\nThe absence of the com.apple.security.get-task-allow entitlement means that you won’t be able to debug your tool. If you need to debug, create a new command-line tool target, one that’s not sandboxed, specifically for debugging. Be warned, however, that this target may behave differently from the normal tool target because it’s not running in a sandbox.\n\nSet the Other Code Signing Flags (OTHER_CODE_SIGN_FLAGS) build setting to $(inherited) -i $(PRODUCT_BUNDLE_IDENTIFIER), which ensures that the tool’s code signing identifier matches its bundle ID.\n\nSelect ToolX.entitlements in the Project navigator and add com.apple.security.inherit to it, with a Boolean value of true. For more information about this entitlement, see Enabling App Sandbox Inheritance.\n\nSelect the ToolX scheme and chose Product > Build, just to make sure that the tool builds correctly.\n\nNow switch back to the app (AppWithTool) scheme.\n\nEmbed the helper tool\n\nIn the Build Phases tab of the app target editor, add the ToolX target to the Dependencies build phase. This ensures that Xcode builds the tool target before building the app target.\n\nAdd a new Copy Files build phase. Double-click the build phase name and change it to Embed Helper Tools (the exact name doesn’t matter, but it’s best to pick a descriptive one). Set the Destination popup to Executables. This places the helper tool in your app’s Contents/MacOS directory, one of the locations recommended by Placing Content in a Bundle.\n\nAdd the ToolX executable to that build phase, making sure Code Sign On Copy is checked.\n\nFor more information about build phases, see What are build phases?\n\nBuild and validate\n\nWith the project set up, it’s time to test that everything builds correctly. To start, choose Product > Archive, which builds the tool target and then the app target, embedding the result of the former within the latter.\n\nIn the Xcode organizer, select the newly created archive and click Distribute App.\n\nNote\n\nIf the button says Distribute Content rather than Distribute App, go back and check that you enabled the Skip Install build setting on the tool target.\n\nSelect App Store Connect and click Next, then select Export and click Next.\n\nGo through the rest of the export workflow. The end result is a directory with a name like AppWithTool 2021-05-17 14-07-21. Within that directory is an installer package (with the .pkg extension). Unpack that package.\n\nNote\n\nThe easiest way to unpack an installer package is to install it. If you’d rather not install it, unpack it manually using xar and cpio. For more information, read the manual pages for these tools (see Reading UNIX Manual Pages).\n\nRun the following commands to confirm that Xcode constructed everything correctly:\n\n% codesign -d -vvv --entitlements :- AppWithTool.app \n…\nIdentifier=com.example.apple-samplecode.AppWithTool\nFormat=app bundle with Mach-O universal (x86_64 arm64)\nCodeDirectory v=20500 size=822 flags=0x10000(runtime) hashes=14+7 location=embedded\n…\nAuthority=Apple Distribution: …\n…\nTeamIdentifier=SKMME9E2Y8\n…\n<dict>\n    <key>com.apple.security.app-sandbox</key>\n    <true/>\n    <key>com.apple.security.files.user-selected.read-only</key>\n    <true/>\n</dict>\n</plist>\n% codesign -d -vvv --entitlements :- AppWithTool.app/Contents/MacOS/ToolX \n…\nIdentifier=com.example.apple-samplecode.AppWithTool.ToolX\nFormat=Mach-O universal (x86_64 arm64)\nCodeDirectory v=20500 size=796 flags=0x10000(runtime) hashes=13+7 location=embedded\n…\nAuthority=Apple Distribution: …\n…\nTeamIdentifier=SKMME9E2Y8\n…\n<dict>\n    <key>com.apple.security.app-sandbox</key>\n    <true/>\n    <key>com.apple.security.inherit</key>\n    <true/>\n</dict>\n</plist>\n\n\nCheck the following:\n\nThe Identifier field is the code signing identifier.\n\nThe Format field shows that the executable is universal.\n\nThe runtime flag, in the CodeDirectory field, shows that the hardened runtime is enabled.\n\nThe Authority field shows that the code was signed by an Apple Distribution signing identity, which is what you’d expect for an App Store submission.\n\nThe TeamIdentifier field is your Team ID.\n\nThe app’s entitlements include com.apple.security.app-sandbox and whatever other entitlements are appropriate for this app.\n\nThe tool’s entitlements include just com.apple.security.app-sandbox and com.apple.security.inherit.\n\nImportant\n\nAdding other entitlements to the tool can cause problems. If the tool immediately crashes with a code signing error when your app runs the tool, check that the tool is signed with just these two entitlements: com.apple.security.app-sandbox and com.apple.security.inherit.\n\nEmbed an externally built tool\n\nWith the app and Xcode-built helper tool working correctly, it’s time to repeat the process for a tool built using an external build system. The following example creates a dummy helper tool from the command line and then embeds the tool in the AppWithTool app. In a real project, you’d use the command-line tool’s external build system (for example, make) to build the tool that you want to embed.\n\nBuild the tool\n\nCreate a new directory and change into it:\n\n% mkdir ToolC\n% cd ToolC\n\n\nHere C stands for built with Clang.\n\nCreate a source file in the directory that looks like this:\n\n% cat main.c \n#include <stdio.h>\n\n\nint main(int argc, char ** argv) {\n    printf(\"Hello Cruel World!\\n\");\n    return 0;\n}\n\n\nBuild that source file with clang twice, once for each architecture, and then lipo them together:\n\n% clang -o ToolC-x86_64 -mmacosx-version-min=10.15 -arch x86_64 main.c\n% clang -o ToolC-arm64 -mmacosx-version-min=11.0 -arch arm64 main.c\n% lipo ToolC-x86_64 ToolC-arm64 -create -output ToolC \n\n\nThe -mmacosx-version-min option sets the deployment target to match the AppWithTool app. For the Intel architecture, this is macOS 10.15, as discussed above. For the Apple silicon architecture, this is macOS 11.0, the first macOS release to support Apple silicon.\n\nCreate an entitlements file for the tool:\n\n% /usr/libexec/PlistBuddy -c \"Add :com.apple.security.app-sandbox bool true\" \"ToolC.entitlements\"\nFile Doesn't Exist, Will Create: ToolC.entitlements\n% /usr/libexec/PlistBuddy -c \"Add :com.apple.security.inherit bool true\" ToolC.entitlements\n% cat ToolC.entitlements \n…\n<dict>\n    <key>com.apple.security.app-sandbox</key>\n    <true/>\n    <key>com.apple.security.inherit</key>\n    <true/>\n</dict>\n</plist>\n\n\nSign the tool as shown below:\n\n% codesign -s - -i com.example.apple-samplecode.AppWithTool.ToolC -o runtime --entitlements ToolC.entitlements -f ToolC\n\n\nThis breaks down as follows:\n\nThe -s - argument applies an ad hoc signature (in Xcode parlance, this is Sign to Run Locally). Setting up the code signature here is critical. It sets up a pattern that Xcode uses when it re-signs the tool when embedding it into the final app. The signing identity is the only thing that doesn’t matter. Xcode overrides that identity with the product’s signing identity during the embedding process, which is why you can get away with an ad hoc signature.\n\nThe -i com.example.apple-samplecode.AppWithTool.ToolC option sets the code signing identifier.\n\nThe -o runtime option enables the hardened runtime. Again, this isn’t necessary for App Store distribution, but it’s best practice for new code.\n\nThe --entitlements ToolC.entitlements option supplies the signature’s entitlements.\n\nThe -f option overrides any existing signature. This isn’t strictly necessary but it avoids any confusion about the existing ad hoc signature applied by clang to the arm64 architecture. Apple silicon requires that all code be signed, and so clang automatically applies an ad hoc signature when building for Apple silicon.\n\nAdd the ToolC executable to your Xcode project. When you do this:\n\nEnable “Copy items if needed”.\n\nSelect “Create groups” rather than “Create folder reference”.\n\nUncheck all the boxes in the “Add to targets” list.\n\nIn the Build Phases tab of the app target editor, add ToolC to the Embed Helper Tools build phase, making sure that Code Sign On Copy is checked.\n\nBuild and validate again\n\nTo validate your work, follow the process described in Build and Validate, substituting ToolC for ToolX everywhere.\n\nSee Also\nProject configuration\nAdding package dependencies to your app\nIntegrate package dependencies to share code between projects, or leverage code from other developers."
  },
  {
    "title": "Adding package dependencies to your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/adding-package-dependencies-to-your-app",
    "html": "Overview\n\nXcode comes with built-in support for source control accounts and makes it easy to leverage available Swift packages. Use Xcode to manage the versions of package dependencies and make sure your project has the most up-to-date code changes.\n\nNote\n\nA package author can publish their Swift package to either public or private repositories. Xcode supports both private and publicly available packages.\n\nAdd a package dependency\n\nTo add a package dependency to your Xcode project, select File > Add Package Dependency and enter its repository URL. You can also navigate to your target’s General pane, and in the “Frameworks, Libraries, and Embedded Content” section, click the + button, select Add Other, and choose Add Package Dependency.\n\nInstead of adding a repository URL, you can search for a package on GitHub or GitHub Enterprise. Add your GitHub or GitHub Enterprise account in Xcode’s preferences, and a list of package repositories appears as you type. The following screenshot shows a list of repositories for the search term ExamplePackage for a user who added their Git provider in Xcode’s preferences.\n\nIf you’ve added a source control account in Xcode’s preferences and you haven’t yet entered a search term, the list contains package repositories from:\n\nYour Git Repositories\n\nYour teams’ Git repositories\n\nYour starred repositories on GitHub, GitHub Enterprise, GitLab, or your self-managed GitLab instance\n\nImportant\n\nOnly add package dependencies by trustworthy authors. In addition, adding a binary dependency comes with drawbacks over adding a source-based dependency. See Identifying binary dependencies to learn more.\n\nDecide on package requirements\n\nWhen you enter the package dependency’s URL or pick a Swift package from the list of packages, choose one of three package requirements. Package requirements determine the allowed versions of the package dependency in your project, and Xcode updates your package dependency based on the requirement that you choose.\n\nVersion\n\nDecide whether your project accepts updates to a package dependency up to the next major version or up to the next minor version. To be more restrictive, select a specific version range or an exact version. Major versions tend to have more significant changes than minor versions, and may require you to modify your code when they update. The version rule requires Swift packages to conform to semantic versioning. To learn more about the semantic versioning standard, visit Semantic Versioning 2.0.0. Selecting the version requirement is the recommended way to add a package dependency. It allows you to create a balance between restricting changes and obtaining improvements and features.\n\nBranch\n\nSelect the name of the branch for your package dependency to follow. Use branch-based dependencies when you’re developing multiple packages in tandem and don’t want to publish versions of your package dependencies.\n\nCommit\n\nSelect the commit hash for your package dependency to follow. Choosing this option isn’t recommended, and you should only use this option in exceptional cases. While pinning your package dependency to a specific commit ensures that the package dependency doesn’t change and your code remains stable, you don’t receive any updates. If you worry about the stability of a remote package, consider one of the more restrictive options of the version-based requirement.\n\nAfter you choose a package requirement, Xcode resolves and fetches the package dependency. Select the package’s products that you need, and add them to targets in your project.\n\nIn Xcode’s Project navigator, the Swift Package Dependencies section shows the newly added package dependency. Click the disclosure triangle to view the contents of the package as it exists locally on your Mac.\n\nTip\n\nAlthough Xcode updates your package dependencies and resolves package versions automatically, you can trigger both actions from the File > Packages menu.\n\nUse features and assets provided by a Swift package\n\nTo use a Swift package’s functionality in your app, import a package’s product as a Swift module. The following code snippet shows a view controller that imports a Swift package’s MyLibrary module and uses the package’s functionality:\n\nimport UIKit\n\n\n// Import the module that corresponds with the Swift package’s library product MyLibrary.\nimport MyLibrary\n\n\nclass ViewController: UIViewController {\n\n\n    @IBOutlet var aLabel: UILabel!\n    @IBOutlet var aButton: UIButton!\n    @IBOutlet var anImageView: UIImageView!\n    @IBOutlet var aCustomView: CustomView!\n\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n\n        // Use a string that the package exposes as a property in the MyLibrary file.\n        self.aLabel.text = MyLibrary.titleText\n\n\n        // Load an image that the MyLibrary package makes available through a class method.\n        if let imagePath = MyClass.exampleImagePath() {\n            self.anImageView.image = UIImage(contentsOfFile: imagePath)\n        }\n\n\n        // Use the Swift package’s CustomView class.\n        self.aCustomView = CustomView()\n    }\n\n\n    // Show an alert by calling the package’s API.\n    @IBAction func showAlert(_ sender: Any) {\n        MyClass.showAlertUsing(viewController: self)\n    }\n}\n\nEdit a package dependency\n\nYou can’t edit the content of your package dependencies directly. If you want to make changes to a package dependency, you need to add it as a local package to your project. See Editing a package dependency as a local package to learn how you can override a package dependency with a local package and make edits.\n\nCoordinate package versions across your team\n\nWhen collaborating on a project, make sure everyone uses the same version of a package dependency. When you add a package dependency to a project, Xcode creates the Package.resolved file. It lists the specific Git commits to which each package dependency resolves and the checksum of each binary dependency. Commit this file in Git to ensure that everyone is using the same version of a package dependency.\n\nTip\n\nYou can find the Package.resolved file inside your .xcodeproj directory at [appName].xcodeproj/project.workspace/xcshareddata/swiftpm/Package.resolved.\n\nDelete a package dependency\n\nIf you need to remove a package dependency from your Xcode project, navigate to the Swift Packages pane in the settings, then select the Swift package from the list of packages. Click the - button to remove the selected package dependency.\n\nSee Also\nProject configuration\nEmbedding a command-line tool in a sandboxed app\nAdd a command-line tool to a sandboxed app’s Xcode project so the resulting app can run it as a helper tool."
  },
  {
    "title": "Finding and replacing content in a project | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/finding-and-replacing-content-in-a-project",
    "html": "Overview\n\nXcode offers sophisticated search and replace capabilities in the Find navigator, which you access from the navigator area of your project. Use the Find Navigator to search for text and symbols across your entire project. To perform advanced searches, use regular expressions or use the navigator’s controls to narrow the scope of the search operations.\n\nTo display the Find Navigator, click the magnifying glass icon in the navigator area of your project.\n\nFind text strings\n\nTo search for text in your project:\n\nIn the search criteria bar, select Find > Text.\n\nSelect a search criteria: Containing, Matching, Starting with, or Ending with.\n\nEnter text into the search field.\n\nSelect a case-sensitivity option from the pop-up menu.\n\nPress Return.\n\nXcode displays the results of the search. When you select a result, Xcode displays the result in the editor area. To quickly navigate to the next or previous item, choose Find > Find Next in Project or Find > Find Previous in Project.\n\nTip\n\nTo quickly populate the search field, select some text in the editor and choose Find > Find in Project. Xcode copies the selected text to the search field.\n\nFind symbol references and definitions\n\nXcode offers two ways to search for symbols:\n\nUse Find > References to search your code for the specified symbol name.\n\nUse Find > Definitions to search for the source file that contains the definition of the specified symbol.\n\nWhen you execute the search, the search results contain only places where your code refers to the symbol. The results don’t include references to the symbol in code comments or other project files. To refine your results, change the matching behavior and case sensitivity options of your search.\n\nReplace instances of found text\n\nTo search for text and replace it with another string:\n\nIn the search criteria bar, select Replace > Text.\n\nSelect a search criteria: Containing, Matching, Starting with, or Ending with.\n\nEnter text into the search field.\n\nSelect a case-sensitivity option from the pop-up menu.\n\nEnter text in the replacement field.\n\nPress Return.\n\nXcode displays the results of the search, but it doesn’t automatically replace the text. To replace the text for a single result, select it and click the Replace button. To replace the text for all results, click Replace All.\n\nFilter the list of search results\n\nAfter any search, you can narrow the search results further by entering a secondary string into the filter bar. The Find navigator temporarily removes results that don’t also contain the string you type into the filter bar. To restore the original results, clear the text from the filter bar.\n\nLimit the scope of a find or replace operation\n\nWhen you execute a search, Xcode searches all files in your project by default. To search only a subset of files, click Scope and choose from the options that appear.\n\nClick a project or group to restrict searches to the designated part of your Xcode project.\n\nCreate a custom scope to restrict searches to files in specific locations or files with a specific name, path, extension, type, or source-control status.\n\nRefine searches to match predefined pattern strings\n\nPattern tokens help you match strings that contain variable content. For example, you might use a pattern token to represent an email address in a string.\n\nTo add a pattern to your search string, click the magnifying glass in the search field and choose Insert Pattern from the pop-up menu.\n\nSelect the pattern you want from the pop-up menu to add it to your search field. Xcode defines pattern tokens for white space, URLs, hexadecimal digits, and other specific character sets. Include one or more tokens plus literal text to perform complex pattern matching.\n\nFind or replace using a regular expression\n\nRegular expressions let you define your own custom pattern strings to use during matches. The NSRegularExpression class in the Foundation framework defines the syntax that you use for Xcode regular expressions.\n\nTo find or replace text using a regular expression:\n\nIn the search criteria bar, select Find > Regular Expression or Replace > Regular Expression.\n\nSelect a search criteria: Containing, Matching, Starting with, or Ending with.\n\nEnter the regular expression into the Find or Replace search field.\n\nSelect a case-sensitivity option from the pop-up menu.\n\nPress Return.\n\nSee Also\nNavigation\nConfiguring the Xcode project window\nConfigure the appearance of Xcode project windows by showing and hiding editors, inspectors, and navigation content."
  },
  {
    "title": "Managing files and folders in your Xcode project | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/managing-files-and-folders-in-your-xcode-project",
    "html": "Overview\n\nThe Project navigator displays your project’s files and lets you open, add, delete, and rearrange those files. To open the Project navigator, at the top of your project window’s navigator area, click the icon that resembles a file folder.\n\nWhen you select an file in the navigator, the inspector pane displays information about the file, and the editor area displays the contents of the file. The appearance of the editor area changes based on the type of file you select. For example, a source code file displays the source editor, and a property-list file displays the property-list editor.\n\nTo locate files based on keywords or other criteria, use the filter bar at the bottom of the navigator area:\n\nTo search for files, enter keywords in the filter bar’s text field.\n\nTo show only recently modified files, click the Recent Files icon.\n\nTo show only files with a changed source-control status, click the Source Control icon.\n\nAdd new files to a project\n\nXcode provides templates for the common types of files you might want to add to your project, such as Swift files or playgrounds. In the Project navigator, select the folder or group where you want to add a file and perform one of the following actions:\n\nClick the Add button (+) in the filter bar and choose File from the pop-up menu.\n\nChoose New > File.\n\nControl-click and select New File.\n\nIn the new file sheet, select a template for your new file. Xcode organizes templates by type to make them easier to find. You can also use the filter control to search for templates by name. After you select a template, click Next.\n\nSome templates require you to specify additional information for the new file. For example, the Cocoa Touch template asks you to specify information about the class you’re creating, including the parent class name. Xcode uses this information to populate the file with some initial content.\n\nThe final step is to save your file to the file system. When Xcode prompts you for the file’s location, it also asks you to specify group and target information. The group indicates where in your project to place the file, and Xcode selects a default group based on contextual information. Xcode also selects a default target. Make any relevant changes to the target and group values and click Create to create the file.\n\nAdd existing files and folders to a project\n\nXcode offers several ways to add existing files and folders to your project:\n\nDrag the files from the Finder into the Project navigator.\n\nClick the Add button (+) in the Project navigator’s filter bar, and choose Add Files to “projectName”.\n\nChoose File > Add Files to “projectName”.\n\nXcode prompts you to select files and folders and configure how you want to add them to your project. (If you don’t see any configuration options, click the Options button at the bottom of the sheet.) Select at least one target and the options for how to incorporate the files and folders into your project.\n\nWhen you add files and folders to your project, select one of the following options:\n\nCopy items if needed\n\nCopies all files and folders to the project folder before adding them to the Project navigator. Use this option to work on a copy of the files, instead of the original versions.\n\nCreate groups\n\nCreates a group structure in your project that matches the structure of the selected field and folders on disk. Xcode creates a group in the Project navigator for each folder you add, and it adds the contents of the folder to that group.\n\nCreate folder references\n\nDisplays the folders in the Project navigator, but doesn’t copy them to the project. In the Project navigator, each added folder points to a folder in the file system.\n\nWhen adding a local Swift Package’s folder to your project, perform the following additional steps:\n\nPlace the package in a Packages group to make it easier to track. To create a new group in the project navgator, select File > New > Group. Drag the package from the Finder into the group.\n\nAdd the package to the linked libraries build phase in your project settings. In the Project Editor, Select Build Phases and expand Link Binary With Libraries. Click the plus (+) button and select the package from your workspace.\n\nFor more information about managing Swift packages, see Swift packages.\n\nNote\n\nTo use RealityKit content that you create using Reality Composer Pro, you can add its folder to your Xcode project and link against the Swift Package it contains. For more information about Reality Composer Pro, see Designing RealityKit content with Reality Composer Pro.\n\nOrganize project files in the navigator\n\nMost new projects contain some structure to organize the project’s content — for example, to separate source files from generated products. You can create additional groups and folders to organize your content and make it easier to navigate large projects.\n\nA folder is a file-system directory that you reference from your project. Xcode includes the contents of the folder in your project.\n\nA group is a collection of resources in your project. By default, Xcode maps each group to a folder in your project directory, but you can also create groups without an underlying file-system folder. You might use groups without folders if you want to manage files in your project without changing the underlying organization of the files on disk.\n\nIn the Project navigator, create and modify groups using direct interaction or menu commands:\n\nCreate a new group backed by a folder\n\nSelect an item and choose File > New > Group, or Control-click the item and select New Group from the contextual menu.\n\nCreate a new group without a folder\n\nSelect an item and choose File > New > Group without Folder, or Control-click the item and select New Group without Folder from the contextual menu.\n\nCreate a group and move items to it\n\nSelect the items and choose File > New > Group from Selection, or Control-click the selected items and select New Group from Selection.\n\nRename a file or group\n\nDouble-click the file or group, and enter the new name.\n\nChange a group’s associated folder\n\nSelect the group and choose View > Inspectors > Show File Inspector. Drag the new folder from the Finder to the old folder name under Location in the File inspector.\n\nImportant\n\nIf a group is associated with a folder, Xcode performs all rename, delete, move, and copy operations on the folder in the file system. For projects under source control, Xcode uses the source-control system to perform the operations and track the changes. If you move files between groups in the same Git repository, Xcode moves the files in the file system. If the files are in different repositories, Xcode copies the files into the folder in the new repository.\n\nDelete files and folders\n\nTo delete a file or folder from your project, select it and press the Delete key, or select Edit > Delete. Xcode prompts you to choose how to delete any selected items.\n\nMove to Trash\n\nThis option removes files and folders from your project and the file system. Choose this option when you no longer need the information in the files.\n\nRemove Reference\n\nThis option removes files and folders only from your project. Xcode doesn’t remove them from the file system.\n\nSee Also\nFiles and workspaces\nManaging multiple projects and their dependencies\nManage related projects in one place using a workspace, or configure build-time dependencies between different Xcode projects using cross-project references."
  },
  {
    "title": "Analyzing your app’s battery use | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-your-app-s-battery-use",
    "html": "Overview\n\nThe Battery Usage pane in the Xcode Organizer shows a breakdown of the appʼs foreground and background power use, giving you a starting place to optimize power consumption.\n\nThe top graph shows the on-screen use, and the percentage of battery used during a 24-hour period while the app is in the foreground and the device isnʼt connected to power.\n\nThe bottom graph shows the background battery use during the same 24-hour period.\n\nClicking on a bar for a previous version shows a comparison of battery use to the right of the graphs. The zoomed-in section above shows an example of this data. The percentage values for each version are followed by a category breakdown. Larger values are shown in bold for easier comparison.\n\nThe power use categories are:\n\nAudio: Used to play audio in your app\n\nNetworking: Used for networking\n\nProcessing: Used by the CPU and GPU\n\nDisplay: Used to show the application UI\n\nBluetooth: Used for Bluetooth\n\nLocation: Used for location tracking within your app\n\nCamera: Used by the camera within your app\n\nTorch: Used for the flashlight\n\nNFC: Used for NFC within your app\n\nOther: A combination of the power in the above categories thatʼs too small to show in the list and any other power use"
  },
  {
    "title": "Making changes to reduce memory use | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/making-changes-to-reduce-memory-use",
    "html": "Overview\n\nOnce you’ve localized the growth in your app’s memory use to a specific feature or action, you can make changes to reduce memory use. Common causes of excessive memory use and the actions you can take to reduce their impact are described below.\n\nOptimize image assets\n\nLarge images, especially at high color depths, use a lot of memory. Optimize assets bundled with the app for the size at which the app displays them. Transform images loaded from other sources—for example, from network services or the user’s photo library—to an appropriate scale and color depth. Use Image I/O for these transforms to minimize memory impact. WWDC 2018 Session 416, iOS Memory Deep Dive, gives advice on choosing appropriate Image I/O transforms.\n\nReduce the size of Core Data transactions\n\nCore Data stores changes to NSManagedObject instances in memory until their associated NSManagedObjectContext is saved, at which time it writes changes to the parent NSManagedObjectContext or to the persistent store. Until the changes make their way into the persistent store, they’re resident in memory, so the longer your app goes between saves, the bigger Core Data’s working set can grow. Conversely, the more frequently your app saves, the more writes it makes to the device’s solid-state drive, which impacts performance and increases wear on the drive. Design your app’s persistence model to strike a balance between these two resource constraints.\n\nDiscard unused view objects\n\nThe user isn’t looking at your app’s views when they lock the screen or when the app is in the background. There’s no need to keep images, video, SceneKit scenes, and other view-related objects in memory during those times. Release view-related content when your app enters the background, and prepare views again when it re-enters the foreground. For information about preparing your app for background use, see Managing your app’s life cycle.\n\nEliminate memory leaks\n\nA memory leak occurs when allocated memory becomes unreachable and the app can’t deallocate it. Allowing an allocated-memory pointer to go out of scope without freeing the memory can cause a memory leak. A retain cycle in your app’s object graph can also cause a memory leak. When the app removes its reference to any of the objects in a retain cycle, strong references remain within the cycle, and the objects aren’t released.\n\nUse the Leaks profiling template to detect memory leaks. Instruments periodically scans the memory your app is using to report allocated but unreachable regions of memory. The Leaks instrument shows the address and size of the leaked memory, along with a stack trace showing the code responsible for allocating the memory.\n\nRemove references to unused objects\n\nIt’s possible for an app to accumulate memory that it has allocated and has access to but doesn’t use. This unused memory increases the app’s memory use without contributing to its functionality, and without showing up in leak-detection tools like the Leaks instrument.\n\nFor example, a social media app might load a list of messages from a service and store them in a dictionary by message identifier. As the user scrolls through their timeline, the app loads more messages into the dictionary so that it can quickly display more information when the user taps a message. Without a strategy to purge earlier messages from this dictionary, it can grow without bounds as the user scrolls further along the list.\n\nMake sure your app only keeps references to objects it needs to support the features that the user is currently working with. Discard old content, or write it to disk for later retrieval. For example, the social media app can discard messages from its dictionary when the user scrolls away from those messages.\n\nSee Also\nMemory and size\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nReducing your app’s size\nMeasure your app’s size, optimize its assets and settings, and adopt technologies that help streamline installation over a mobile internet connection.\nGathering information about memory use\nIdentify memory-use inefficiencies by measuring and profiling your app.\nPreventing memory-use regressions\nMeasure the memory that your app’s features use, and detect increases by using XCTest performance tests.\nResponding to low-memory warnings\nDetect when your app is using excessive memory, and bring memory use under control."
  },
  {
    "title": "Analyzing the memory usage of your Metal app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-the-memory-usage-of-your-metal-app",
    "html": "Overview\n\nInstruments provides the Game Memory template to help you understand the memory growth in your Metal app. Keeping a small memory footprint allows the system to keep the app alive in the background longer, especially on devices with more constrained memory capacity. For more information, see Profile and optimize your game’s memory.\n\nOpen the Game Memory template\n\nStart the memory analysis from your Xcode project by choosing Product > Profile, or by pressing Command-I. Alternatively, you can launch Instruments and then select the process from the drop-down list.\n\nIn the Template Selection window, select Game Memory.\n\nGet to know the instruments\nAllocations\n\nAnalyzes the memory life cycle of a process’s allocated blocks, and can record reference-counting events.\n\nMetal Resource Events\n\nRecords Metal GPU resource allocations, such as textures and buffers.\n\nVM Tracker\n\nTracks the virtual memory space of a process over time, identifying regions by tag and reporting usage statistics.\n\nVirtual Memory Trace\n\nTracks virtual memory activity per thread.\n\nMetal Application\n\nRecords Metal app events.\n\nGPU\n\nRecords GPU events.\n\nRecord an Instruments capture\n\nBegin collecting the data by clicking the Record button.\n\nWithin your app, perform the actions that reproduce the memory problem, and then click the Record button to stop recording.\n\nAnalyze your app’s memory allocations\n\nThe Game Memory template shows both memory allocations and memory footprint.\n\nMemory allocations occupy space in the virtual memory address space. When your app allocates memory, these new allocations may not immediately take up space on physical memory. It’s not until your app uses these allocations that they consume physical memory.\n\nThe Allocations track provides a detailed view of memory allocations, their sizes, and object reference counts.\n\nNote\n\nThe Allocations track doesn’t include Metal resources with private storage mode — only managed and shared storage modes.\n\nThe Statistics view in the bottom detail area displays the categories of memory allocations. At the top of the Category column, there are three umbrella categories that summarize all allocations:\n\nAll Heap & Anonymous VM\n\nIncludes everything.\n\nAll Heap Allocations\n\nIncludes dynamically allocated buffers that may contain resources.\n\nAll Anonymous VM\n\nIncludes interesting VM regions that may be dirty. You can also find some Metal-related memory here.\n\nBelow them, you can find more detailed categories. Metal resource allocations are in the VM: IOAccelerator category, and drawables are in VM: IOSurface.\n\nTo inspect the individual allocations in a category, click the arrow button next to the category name in the table.\n\nAfter selecting a category, you can sort the table by the Size column to find the largest memory allocation during the selected time range.\n\nYou can also select an allocation in the list to view its description and stack trace in the inspector on the right.\n\nAnalyze Metal resource allocations\n\nThe Metal Resource Events track displays a history of all Metal-specific resource allocations and deallocations, along with their labels (see Naming resources and commands).\n\nThe Resource Events view in the bottom detail area lists the resource allocation and deallocation events. It includes events from created or destroyed resources in the selected time range. Not all resources in the list persisted until the end of the time range.\n\nAnalyze your app’s total virtual memory footprint\n\nThe Allocations track and the Metal Resource Events track both highlight memory allocations. However, allocations don’t always translate to memory footprint. The VM Tracker track shows the noncompressed and compressed/swapped dirty memory that together make up your app’s memory footprint.\n\nMemory operates on the granularity of pages, and those pages can be either clean or dirty.\n\nClean memory\n\nIncludes memory-mapped files and read-only frameworks.\n\nDirty memory\n\nIncludes heap-allocated memory and written symbols in frameworks.\n\nTo conserve the amount of physical memory that your app uses, the system may compress or swap out some dirty pages that your app hasn’t accessed recently.\n\nImportant\n\nThe system charges your app for any compressed/swapped memory based on its orginal size before compression.\n\nThe center timeline area graphs the following metrics:\n\nDirty Size\n\nThe amount of noncompressed dirty memory.\n\nSwapped Size\n\nThe amount of compressed/swapped dirty memory in its original size before compression.\n\nResident Size\n\nThe amount of resident memory.\n\nThe corresponding columns are also available in the Summary view of the bottom detail area. There, you can expand the VM region types. In the mapped file type in the screenshot below, you can see the memory-mapped file of the bistro scene that the Modern Renderer app loaded:\n\nSee Also\nGraphics\nAnalyzing the performance of your Metal app\nEnsure consistent, smooth rendering by profiling your app’s frame time."
  },
  {
    "title": "Configuring a new target in your project | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-a-new-target-in-your-project",
    "html": "Overview\n\nA target specifies a product to build, such as an app, framework, app extension, or unit test. A project can contain multiple targets, usually representing related parts of a single product. For example, a project might contain separate targets for an app, a private framework, an app extension, and a suite of tests.\n\nWhen you create a new project from a template, Xcode adds one or more targets to the project automatically. For example, the multiplatform app template contains separate targets for an iOS app and Mac app.\n\nTo view the targets in a project, select the project in the navigator area. The editor area displays the current project and target information. Select a target to view general information about it, and to view its current build settings and capabilities. Changes you make to a target’s configuration affect that target only. Changes you make to the project affect all targets.\n\nAdd a new target to your project\n\nAdd new targets to create separate products in your project, augment an existing app using app extensions, or factor code into a private framework. You can also add new apps, system extensions, test suites, and other types of targets to your project.\n\nTo add a new target:\n\nChoose File > New > Target.\n\nSelect the platform for the new target.\n\nChoose a starting template.\n\nClick Next.\n\nProvide a name for the target and configure other target-related options, such as the programming language.\n\nClick Finish.\n\nYou can embed some types of targets, directly into the bundle of an existing app. This option simplifies the setup process for frameworks, app extensions, and other products that you plan to ship inside your app. When you embed a target, Xcode configures the necessary project settings to build the target and copy it into your app. Xcode also creates the necessary dependencies to ensure that the targets build in the proper order.\n\nAdd source files and other content to a target\n\nTarget templates contain default files to help you start development. Choose File > New to create new files and embed them directly into an existing target. To assign an existing file to a new target, select the file and update its membership attributes in the Identity inspector.\n\nFor more information about how to add files to a project, see Managing files and folders in your Xcode project.\n\nConfigure a dependency between two targets\n\nDependencies tell Xcode the correct order in which to build a set of targets. Xcode builds targets in parallel when it can, but sometimes it must build targets serially. For example, Xcode must build a custom framework before it builds an app that links against that framework. When you embed a new target inside an app, Xcode creates a dependency between the app and target if the scheme’s Find Implicit Dependencies option is enabled. If that option is disabled, you must configure the dependency yourself.\n\nTo view and add dependencies, select a target and open its build phase settings. The Dependencies build phase contains the targets that Xcode must successfully build before it builds the current target. Xcode can build multiple dependent targets simultaneously if there are no interdependencies between those targets.\n\nWhen there’s a relationship between targets that Xcode can’t easily detect, add dependencies manually. While Xcode can add dependencies automatically when the Find Implicit Dependencies build scheme option is enabled, it can’t detect all dependencies. For example, Xcode can’t detect when a target relies on data files built by a custom script in another target. If you don’t specify a needed dependency, Xcode might report errors or build the targets incorrectly.\n\nNote\n\nIf your target depends on content in a different Xcode project, add a reference to the project before configuring any dependencies. For more information, see Managing multiple projects and their dependencies.\n\nFor more information on optimizing your targets to improve build times, see Improving the speed of incremental builds.\n\nSee Also\nEssentials\nConfiguring a multiplatform app\nShare project settings and code across platforms in a single app target."
  },
  {
    "title": "Responding to low-memory warnings | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/responding-to-low-memory-warnings",
    "html": "Overview\n\niOS sends your app a warning when its memory use approaches the limit of available device memory. The amount of memory use that triggers a memory warning corresponds to the yellow region in Xcode’s memory gauge. Your app can receive a memory warning in any of these ways:\n\nUIKit calls the applicationDidReceiveMemoryWarning(_:) method of your app delegate.\n\nUIKit calls the didReceiveMemoryWarning() method of active UIViewController objects.\n\niOS posts didReceiveMemoryWarningNotification to the default notification center.\n\nDispatch queues receive an event with source type DISPATCH_SOURCE_TYPE_MEMORYPRESSURE.\n\nThe operating system sends low-memory warnings using a best-effort approach, and your app needs to respond to them as quickly as possible. If memory demand on the system increases faster than the warnings relieve memory pressure, the system may not have time to send the low-memory warnings and wait for apps to respond. When this occurs, the system resorts to jettisoning apps to reclaim their memory and recording the reason in a log file, as described in Identifying high-memory use with jetsam event reports.\n\nMake sure your app changes its approach for allocating memory when it receives a memory warning—adopting a conservative policy of looking for opportunities to release objects or reduce their size as it uses them. If your app allocates large amounts of memory at once and crashes before it receives the low-memory warning during the large allocation, modify your code to slowly allocate the necessary memory, so the system has adequate time to free memory from across the system.\n\nIf your app loads data it can easily recreate, consider using NSPurgeableData. When the contents of NSPurgeableData aren’t marked as in-use through beginContentAccess(), the system automatically discards the contents in low-memory situations. This automatic discard process helps your app react to a low-memory warnings more quickly, because the kernel handles discarding the data, rather than your app, which is waiting to receive the low-memory notification before discarding the data.\n\nImportant\n\nDon’t traverse your app’s whole object graph looking for memory to release when your app receives a memory warning, and avoid using NSCache in connection with NSPurgeableData. iOS compresses memory pages that apps haven’t accessed recently. Searching for memory to purge brings these pages out of the compressor, and increases memory demands on the system.\n\nSee Also\nRelated Documentation\nIdentifying high-memory use with jetsam event reports\nDiscover why the operating system terminated your app when available memory was low.\nMemory and size\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nReducing your app’s size\nMeasure your app’s size, optimize its assets and settings, and adopt technologies that help streamline installation over a mobile internet connection.\nGathering information about memory use\nIdentify memory-use inefficiencies by measuring and profiling your app.\nMaking changes to reduce memory use\nDecrease your app’s use of memory by addressing common causes of excessive use.\nPreventing memory-use regressions\nMeasure the memory that your app’s features use, and detect increases by using XCTest performance tests."
  },
  {
    "title": "Analyzing the performance of your Metal app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-the-performance-of-your-metal-app",
    "html": "Overview\n\nA low-performing frame rate can cause an app to seem sluggish or disruptive to its users, so it’s important to remove temporary interruptions, or stutters, to optimize your app’s user experience. To get information about the cause of slowness in your app’s frame rate, you can use the Game Performance template in Instruments, which combines threading and system call information with the Metal system trace instrument. By presenting important app states and rendering activities, the Game Performance template helps you infer the changes that are necessary to achieve consistent, smooth rendering.\n\nOpen the Game Performance template\n\nStart the performance analysis from your Xcode project by choosing Product > Profile, or by pressing Command-I. Alternatively, you can launch Instruments and choose a target app.\n\nIn the Template Selection window, select Game Performance and click Choose.\n\nGet to know the instruments\n\nThe Game Performance template includes the following instruments:\n\nPoints of Interest\n\nIndicates locations in the trace that a developer might want to pay special attention to.\n\nSystem Load\n\nTracks the performance and current load of the system.\n\nThread State Trace\n\nTraces each time the OS scheduler makes a decision that might impact your app’s threads.\n\nSystem Call Trace\n\nRecords system calls and their duration.\n\nVirtual Memory Trace\n\nTracks virtual memory activity per thread.\n\nTime Profiler\n\nProfiles the running threads on all cores at regular intervals for the app.\n\nThermal State\n\nRecords the device thermal state.\n\nMetal Resource Events\n\nRecords Metal GPU resource allocations, such as textures and buffers.\n\nMetal Application\n\nRecords Metal app events.\n\nGPU\n\nRecords GPU events.\n\nDisplay\n\nRecords display and vertical synchronization events.\n\nInclude performance limiter or utilization counters\n\nBy default, Instruments doesn’t collect performance counters data. You can optionally include this for the instruments. Click and hold the Record button and choose Recording Options.\n\nThen, in the Recording Options popover, choose the Performance Limiters option from the Counter Set menu.\n\nWhen you record the Instruments trace, it collects performance limiter and utilization counters data.\n\nRecord an Instruments capture\n\nBegin collecting the data by clicking the Record button.\n\nWithin your app, perform the actions that reproduce a slow frame rate, and then click the Record button to stop recording.\n\nIdentify performance anomalies\n\nTo expedite your review of the capture results, narrow your focus to around the time the frame rate was slow. Sometimes a frame rate anomaly is a result of infrequently skipped frames, and other times it’s due to a consistently poor frame rate. In either case, you identify frame rate anomalies by finding unexpected delay in your app’s display times.\n\nIn the display results, hover the pointer over a frame to check its duration. For example, in the screenshot below, the display instance is 50 milliseconds (ms). Below the display instance, you can inspect how many vertical synchronization (vsync) events the app skipped during that time.\n\nBecause the display instance of 50 ms is significantly longer than the display instances around it, you can consider the delay in frame delivery a stutter. In contrast, the following screenshot shows an app that maintained a consistent frame rate:\n\nA duration of 16.67 ms is one 60 fps frame, and because all other frames consistently achieve this frame duration, there’s no performance anomaly to observe.\n\nNot all displays use a frame interval of ~16 ms. For example, vertical synchronization can happen on ~4 ms intervals. It isn’t a requirement that display instances align with vertical synchronization for a healthy frame rate. An app that uses a 20 ms frame interval is a healthy frame rate as long as it consistently achieves 50 fps. However, a delay of 50 ms is much too long for smooth animations.\n\nCheck GPU utilization\n\nAfter finding a performance anomaly, look for the cause by examining the GPU activities occurring around that time. The GPU Hardware track shows your shader pipeline stages that run on the shader cores. Any long-running stages or inconsistent durations in the track timeline can indicate a utilization issue. For example, the following screenshot shows a case where a display instance spanned multiple frame intervals, meaning that the app unintentionally skipped frames:\n\nTo begin investigating shader core utilization as a potential cause of poor frame rate, do the following:\n\nObserve the performance anomaly. In this case, the display instance spanned multiple frame intervals.\n\nCheck the vertex shader. In this case, the vertex shader is healthy because it completes in a small percentage of the frame interval.\n\nHover the pointer over the fragment shader to see its duration. In this case, it ran for 74.64 ms, which is too long.\n\nBecause the combined duration of the vertex and the fragment shader is more than the duration of a 60 fps frame interval (16.67 ms), the app skipped a frame. The vertex shader ran quickly in this case, which means the app’s frame rate issues are solely due to fragment shader overutilization.\n\nThe following are additional reasons for overutilization of the shader cores:\n\nToo many render passes: Indicated by the renderer depriving the GPU of downtime. Check the number of render passes that occur at the time of the poor frame rate by using the Dependencies viewer. For more information, see Analyzing resource dependencies.\n\nHigh resolution: Inidicated by critically more fragment shader activity per the same number of submitted vertices, as compared to when your viewport is set to the smaller size. To ensure your app’s viewport isn’t related to the slowdown, temporarily reduce the viewport size to see if performance improves.\n\nLarge textures: Indicated by high synchronization time when profiling your fragment shader. The per-line profiling result shows a high percentage of time in wait memory. For more information, see Inspecting shaders.\n\nLarge meshes: Indicated by a high number of vertices that your app submits. Check the affected frames using the Geometry viewer. For more information, see Inspecting the geometry of a draw command.\n\nUnoptimized shader code: Indicated by general shader sluggishness. If you’re able to modify your app’s shaders, profile them to identify hot spots. For example, you can optimize your shaders by downsizing data types, or by minimizing the use of control structures. You don’t necessarily know whether your shaders can benefit from optimization until you try it. For more information, see Inspecting shaders.\n\nCheck CPU utilization\n\nWhile checking your shader core utilization, also look for signs that indicate problems with your app’s CPU utilization. The screenshot below shows a case where frame skipping appears to result from something other than the shader core. Note the gap where the shader core was idle for multiple frames.\n\nWhen the Display track spans multiple frame intervals and there are gaps in the shader core timeline, it indicates that your host app’s code is running long. Inspect your app’s CPU utilization to determine whether it’s responsible for poor frame rate.\n\nTo check your app’s CPU utilization, identify your rendering threads in the thread state tracks. In the case of healthy CPU utilization, your app’s rendering threads generally show a significant amount of blocked time. The following screenshot shows an app’s rendering thread selected, and its blocked time taking around 75% of each ~16 ms frame interval:\n\nBlocked time indicates that your renderer finished submitting its draw commands with some time to spare in the frame interval. Because the amount of blocked time above encompasses about two-thirds of its frame interval, the host app has left enough time for the shader core to start and finish its work within the same frame interval.\n\nBy contrast, if your rendering threads don’t show much blocked time, it’s likely that your app is overutilizing the CPU. To identify whether your app is overutilizing the CPU, and to determine the reason, perform the following steps:\n\nObserve a stutter, as identified by a display duration longer than 16.67 ms.\n\nEnsure that shader code isn’t the cause of the low frame rate. For more information, see Check GPU utilization above.\n\nCheck the thread states for Running that are blue in color.\n\nClick the thread’s track to select it.\n\nChoose Profile from the View Selection menu.\n\nExpand the results list items and look for the highest weight to find the methods that are spending the most time in your host app code.\n\nNote\n\nOption-click the disclosure triangle to automatically disclose your app’s symbols.\n\nThe time a thread spends running is represented by the collection of blue and orange areas in the timeline track. If a frame interval has little blocked time, it indicates CPU overutilization. To resolve the issue, focus your optimization efforts on improving slow-running code. Because the long-running methods are in your host app, you can easily determine whether — and how — you can optimize them to run faster.\n\nCheck CPU thread prioritization\n\nOther processes can preempt your app if you misconfigure thread priority. To consider these kinds of thread-related pipelining issues, check the System Load track.\n\nThe orange spikes in the System Load track indicate that runnable threads outnumbered the CPU cores available to process them. The green areas indicate the opposite — the healthy situation where enough CPU cores were available for processing. To deal with the problematic orange situations, you can use fewer threads and increase the priority of your app’s threads.\n\nTo confirm whether low thread-priority is affecting your app’s frame rate, follow these steps:\n\nObserve long-running display instances.\n\nVisually confirm there are a number of skipped frames. For an app that uses a 60 fps frame interval, you can find that vertical synchronizations don’t align with display.\n\nSelect the System Load track.\n\nSelect your app’s rendering thread in the bottom detail area.\n\nMove the inspection time around the identified performance anomaly in the timeline area, and observe the rendering thread’s state and priority at the inspection time in the bottom detail area.\n\nIn the above screenshot, the Preempted thread state indicates that other Runnable and Running threads starved the rendering thread of processing. Low thread-priority is an example of how misconfigured host app code relates to low frame rate.\n\nA priority of 45 is recommended for rendering threads. To set your thread’s priority, call pthread_attr_setschedparam(_:_:) before creating your thread with pthread_create(_:_:_:_:). For more information on thread priorities, see Tune CPU job scheduling for Apple silicon games. For more information on pthread_create and pthread_attr_setschedparam, see Reading UNIX Manual Pages.\n\nCheck CPU-GPU overlap\n\nIn addition to shader core and CPU utilization, more subtle causes of low frame rate involve CPU-GPU pipelining. In this context, pipelining refers to how well your app coordinates the efforts of the CPU and the GPU while maintaining a consistent frame rate. By minimizing the amount of time the CPU and the GPU wait for each other, you maximize the amount of work each unit does in parallel. That’s called CPU-GPU overlap.\n\nFor example, if you have a rendering algorithm that needs the result from a compute pass before encoding rendering commands, Metal provides indirect command buffers (ICBs) to increase overlap. By generating rendering commands on the GPU using ICBs, you can avoid having the CPU wait for the compute results. For more information, see Encoding Indirect Command Buffers on the GPU.\n\nSee Also\nGraphics\nAnalyzing the memory usage of your Metal app\nKeep your app alive in the background by managing its memory footprint."
  },
  {
    "title": "Reducing your app’s size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reducing-your-app-s-size",
    "html": "Overview\n\nEven when your users are in areas with good mobile network coverage, their download speeds can vary, or their data plan may limit the amount of available high-speed data. To ensure that app downloads don’t take a long time or result in additional costs to users, the App Store limits the size of the apps they can install over a mobile connection. If an app’s size exceeds the limit, users need to connect to a Wi-Fi network to install it. Keep your app well below the size limit to maximize your app’s possible install base and minimize installation time.\n\nIn addition to these issues, devices may have only limited storage available, making it even more important to be mindful about your app’s size. Consider measuring it as part of your development and testing process, and plan to optimize it as you develop it.\n\nBefore you start optimizing your app, you first need to measure its download and installation sizes. However, none of the binaries that you create for debugging or that you upload to the App Store from within Xcode are suitable for measuring your app’s size. For example, you can’t use any of the following binaries:\n\nThe APP file (the app bundle)\n\nThe XCARCHIVE bundle that you create when your archive your app\n\nThe IPA file that you upload to App Store Connect\n\nThose binaries contain resources and files that aren’t part of the bundles that your users download from the App Store; for example, DSYM files for crash reporting.\n\nDuring development, the only way to get accurate download and installation sizes for your app is to create an app size report on your Mac. However, if your app is available through the App Store or the TestFlight app, App Store Connect provides the most accurate size information. It displays the size for each variant of your app and warns you if it exceeds the limit for downloading over a mobile internet connection.\n\nApps distributed for testing with TestFlight contain additional data that an App Store build doesn’t have, so the TestFlight build is larger. This additional data isn’t included in your app when you make it available in the App Store. However, when compared to the binary you uploaded, the final size of your app after it’s approved for the App Store may end up being slightly larger. This size increase can happen when the App Store performs additional processing on your app’s binaries, adding DRM to prevent app piracy and then re-compressing the binaries.\n\nThe following figure shows a common workflow for measuring your app’s size and performing optimizations.\n\nTo learn more about viewing the file sizes of a build in App Store Connect, see View builds and metadata.\n\nThe following two sections describe how you can generate a size report with Xcode, and how you can automate its creation.\n\nCreate the app size report\n\nWhile App Store Connect provides the most accurate measurements of your app’s size, Xcode’s built-in reporting tools can create an app size report for you. It provides close estimates of your app’s download and installation sizes. To create an app size report:\n\nArchive your app in Xcode.\n\nExport your archived app as an Ad Hoc, Development, or Enterprise build.\n\nIn the sheet for setting the development distribution options, choose “All compatible device variants” for app thinning.\n\nSign your app and export it to your Mac.\n\nThis process creates a folder with your app’s artifacts:\n\nA universal IPA file for older devices. This single IPA file contains assets and binaries for all variants of your app.\n\nThinned IPA files for each variant of your app. These files contain assets and binaries for only one variant.\n\nThe output folder for your exported app also contains the app size report: a file named App Thinning Size Report.txt. This report lists the compressed and uncompressed sizes for each of your app’s IPA files. The uncompressed size is equivalent to the size of the installed app on the device, and the compressed size is the download size of your app. The following shows the beginning of the app size report for a sample app:\n\nApp Thinning Size Report for All Variants of ExampleApp\n\n\nVariant: ExampleApp.ipa\nSupported variant descriptors: [device: iPhone11,4, os-version: 12.0], [device: iPhone9,4, os-version: 12.0], [device: iPhone10,3, os-version: 12.0], [device: iPhone11,6, os-version: 12.0], [device: iPhone10,6, os-version: 12.0], [device: iPhone9,2, os-version: 12.0], [device: iPhone10,5, os-version: 12.0], [device: iPhone11,2, os-version: 12.0], and [device: iPhone10,2, os-version: 12.0]\nApp + On Demand Resources size: 6.7 MB compressed, 18.6 MB uncompressed\nApp size: 6.7 MB compressed, 18.6 MB uncompressed\nOn Demand Resources size: Zero KB compressed, Zero KB uncompressed\n\n\n// Other Variants of Your App.\n\n\nWith the app size report you generate, you’re now ready to perform some basic optimizations, such as checking your binaries for unused assets, to reduce the size of your app. For more information, see Doing basic optimization to reduce your app’s size.\n\nAutomate the generation of the app size report\n\nInstead of creating the app size report with Xcode, you may want to automate its generation in build scripts or continuous integration workflows. Run the following command to use xcodebuild to export your app for distribution and create an app thinning size report:\n\nxcodebuild -exportArchive -archivePath iOSApp.xcarchive -exportPath Release/MyApp -exportOptionsPlist OptionsPlist.plist\n\n\nReplace all file names and paths as necessary. To create the app size report, provide xcodebuild with an export options property list. Be sure to include the thinning key, with <thin-for-all-variants> as the value.\n\nImportant\n\nBe sure to escape the angle brackets for the value in your export options property list.\n\nTo learn more about using xcodebuild, see Building from the Command Line with Xcode FAQ.\n\nTopics\nSize optimization\nDoing basic optimization to reduce your app’s size\nAdjust your project’s build settings, and use technologies like asset catalogs early in your app’s development life cycle.\nDoing advanced optimization to further reduce your app’s size\nOptimize your app’s asset files, adopt on-demand resources, and reduce the size of app updates.\nSee Also\nMemory and size\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nGathering information about memory use\nIdentify memory-use inefficiencies by measuring and profiling your app.\nMaking changes to reduce memory use\nDecrease your app’s use of memory by addressing common causes of excessive use.\nPreventing memory-use regressions\nMeasure the memory that your app’s features use, and detect increases by using XCTest performance tests.\nResponding to low-memory warnings\nDetect when your app is using excessive memory, and bring memory use under control."
  },
  {
    "title": "Reducing disk writes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reducing-disk-writes",
    "html": "Overview\n\nAll iOS devices and some macOS devices use a solid-state drive (SSD) for permanent storage. Accessing your data on SSD, or any long-term storage media, is slow compared to RAM. In addition, the system can only write to the same region of SSD a limited number of times before that region wears out.\n\nUse Xcode and Instruments to understand your app’s disk-writing performance, including the total amount of data written, the size of writes, excessive storage write exceptions, and other possible optimizations.\n\nOptimize SSD access\n\nWhen the system writes to a block on the SSD, new read requests for that block are queued until the write operation completes. Writing to an SSD is a slower operation than reading. Interleaving read and write requests can slow your app’s performance.\n\nOptimize your app’s performance by reducing the number of write operations to an SSD. For example, create temporary files in a cache in the RAM whenever possible.\n\nEliminate excessive write operations\n\nThe system throws an exception and generates a report when the disk writes from your app exceed a certain threshold in a 24-hour period. View the aggregated exception logs for a version of your app in the Disk Writes pane in Xcode Organizer or capture them with MetricKit.\n\nEach report in the Report List shows the function call that generated the exception and the percentage of total disk writes it accounted for. Clicking on a report shows a sample stack trace, as well as additional details in the Inspector, including:\n\niOS software version\n\nDevice model\n\nTotal writes\n\nNumber of logs received\n\n14-day reporting trend\n\nPrioritize fixing exceptions by using the total percentage of disk writes, as well as information on the operating system and the impacted device types. Identify the code that’s causing the increase in writes by using the function signature for a specific report in the Report List and the corresponding stack trace. After updating the code and verifying the fix, mark the report as resolved.\n\nGather metrics about your app’s disk usage\n\nView the daily amount of data your app writes to the disk in the Disk Writes metrics pane of the Xcode Organizer window or by using MetricKit.\n\nThe pane displays the logical disk writes in megabytes per day for the shipping versions of your app. Compare versions to find unexpected increases. Filter to find differences between devices and to view the typical amount of data written (50th percentile) or the largest amount (90th percentile). MetricKit reports the same data.\n\nThe screenshot below shows that the largest amount of data written by the latest version of the MealPlanner app is 24.4 MB more per day than an earlier version.\n\nAssess whether the amount of data recorded seems reasonable for your app. If the numbers are greater than what you expect, you may be writing data too frequently. For example, if your app’s files total 100 KB and your app writes 500 MB of data to disk every day, you might want to investigate how many times you’re writing the same data to disk each day.\n\nUse the graph of disk-write frequency by versions to identify trends in disk usage. An app whose writes increase daily might either be legitimately handling more data or inefficiently handling existing data. Spikes might indicate either the user created or downloaded new content for your app, or your app modified the same content even more than usual. Dips might help you identify the smallest subset of data required by your app.\n\nIdentify the code causing significant disk writes\n\nProfile your app in Instruments, using the File Activity template. Instruments tracks the logical and physical use of storage by your app.\n\nThe Filesystem Activity instrument records logical filesystem use in the form of system calls to read or write data, or to map filesystem data into memory. Instruments associates each event with its size, duration, and a backtrace you can use to identify the code that’s using the filesystem. The Disk Usage and Disk I/O Latency instruments report the physical use of the storage medium resulting from the filesystem events by showing the size and latency of reads and writes.\n\nThe Filesystem Suggestions instrument and the Disk Writes Reports pane in the Xcode Organizer also offer suggestions for addressing common filesystem use issues.\n\nNote\n\nThe size of physical reads and writes on the disk doesn’t correlate with the size of logical filesystem activity. The disk controller works with regions called blocks, frequently 4 KB in size. Writes to the disk occur in units of blocks, so saving a file with only a single-byte change writes 4 KB to the disk.\n\nBatch multiple write operations\n\nRepeatedly opening, saving, and then closing the same file can increase the frequency of disk writes. Collecting small changes and performing them as a single write reduces the frequency, though it can also result in an increase in your app’s memory use. Design your app’s persistence model to effectively balance its use of these two resources. See Reducing your app’s memory use.\n\nMinimize writing to serialized files\n\nMany apps use property list, JSON, XML, or other serialized formats for writing user documents. These formats are good for read-only content, such as bundle metadata, or to transfer data over the network. The formats aren’t optimal to store user documents that frequently change. Changing a serialized document requires rewriting the entire file, which increases the latency of the operation and the wear on the device.\n\nWhen possible, use Core Data or SQLite for storing frequently edited documents. If that isn’t possible, use different serialized files for data that changes frequently and data that’s mostly static. This can reduce the amount of disk writes and improve latency.\n\nThe Disk Writes Report pane offers suggestions for optimizing the use of serialized files.\n\nAvoid rapid file creation and deletion\n\nWhen you create or delete a file on iOS, the system updates the directory reference by writing 8 KB of metadata. Rapidly creating or deleting lots of files results in many small writes to the filesystem, degrading performance and increasing wear on the device. Renaming or moving a file on iOS adds up to 16 KB in filesystem metadata writes.\n\nCreating a file atomically adds additional writes because the system must create a temporary file, write the content, unlink an existing destination file, then rename the temporary file to the final destination. Common use cases include the atomic write calls for Foundation objects, such as NSString, NSArray, NSDictionary, and NSData.\n\nUse atomic writes only when needed.\n\nMinimize explicit storage synchronization\n\nWriting data on iOS adds the data to a unified buffer cache that the system then writes to file storage. Forcing iOS to flush pending filesystem changes from the unified buffer can result in unnecessary writes to the disk, degrading performance and increasing wear on the device. When possible, avoid calling fsync(_:), or using the fcntl(_:_:) F_FULLFSYNC operation to force a flush.\n\nSome apps require a write barrier to ensure data persistence before subsequent operations can proceed. Most apps can use the fcntl(_:_:) F_BARRIERFSYNC for this.\n\nOnly use F_FULLFSYNC when your app requires a strong expectation of data persistence. Note that F_FULLFSYNC represents a best-effort guarantee that iOS writes data to the disk, but data can still be lost in the case of sudden power loss.\n\nPrevent regressions in disk-write frequency\n\nMeasure the disk usage of your app by writing an XCTest performance test. Create a test that passes an instance of XCTStorageMetric to the measure(metrics:block:) function. Call your code inside the block argument of measure(metrics:block:), the method that writes data to disk.\n\nThe test measures the number of blocks written to the filesystem to save your data. Set a baseline expectation for the amount of disk use. The test fails if the amount of data written significantly exceeds the baseline.\n\nfunc testDiskUse() {\n  self.measure(metrics: [XCTStorageMetric()]) {\n     // This is a disk-intensive operation.\n  }\n}\n\nUse Core Data or SQLite databases for frequently changing documents\n\nSQLite is highly optimized for efficient access to storage. It uses in-memory caches and batched disk-writes to ensure high performance and minimal wear on storage. The data structures are designed to allow efficient updates when inserting new content or updating existing content.\n\nCore Data takes advantage of SQLite’s efficient disk usage for storing your data. Core Data also uses the SQLite best practices described below.\n\nAvoid unnecessarily closing SQLite connections\n\nOpening and closing SQLite connections are expensive operations that require SQLite to write out all pending changes, along with additional metadata including consistency checks and journaling logs. Take better advantage of SQLite’s efficiency by closing a connection only when there’s a clear need.\n\nUse transactions\n\nUse transactions to perform a consolidated write operation for related changes, such as editing multiple fields in a single document. Each transaction can contain multiple INSERT, UPDATE, and DELETE statements.\n\nTransactions are also atomic. Either all of the changes are saved to the database, or the database is restored to the state prior to the transaction. This prevents the database from being left in an inconsistent state.\n\nUse appropriate indices\n\nDecrease search time and avoid unnecessary writes to the disk by using appropriate indices on your database tables. For example, an email app that uses SQLite may show all inbox messages in chronological order using the following SQL statement:\n\nSELECT * FROM messages WHERE folder LIKE ‘Inbox’ ORDER BY sent_time\n\n\nWithout an index on the sent_time column, SQLite constructs a temporary B-tree in memory, reads the whole table, and performs the sort using the B-tree. If the data in the B-tree is too large for the in-memory cache, SQLite writes it to the disk, further slowing the query. With an index on sent_time, SQLite reads the messages in order and returns matching rows.\n\nUse a partial index for columns representing information that doesn’t require searching each of the rows, such as rows that can contain NULL. A partial index — one with a WHERE clause — provides a performance advantage while taking up less disk space than a full index.\n\nUse EXPLAIN QUERY PLAN to determine if a query can benefit from optimization. The following code shows the explanation of a query on an unindexed sent_time column.\n\n> EXPLAIN QUERY PLAN SELECT * FROM messages WHERE folder\n  LIKE ‘Inbox’ ORDER BY sent_time\n\n\nQUERY PLAN\n|--SEARCH TABLE <>\n|--SEARCH TABLE <>\n--*USE TEMP B-TREE FOR ORDER BY*\n\n\nThe presence of USE TEMP B-TREE FOR ORDER BY in the output indicates that the query requires a temporary B-tree to sort the results.\n\nThe Disk Writes Report pane suggestions identify queries that may benefit from an index.\n\nUse write-ahead logging journaling mode\n\nEnable more efficient reads and writes in SQLite by using write-ahead logging (WAL) journaling mode. This mode enables coalescing multiple writes to the same page, reducing SQLite’s use of write barriers, and supporting multiple database read threads in parallel with a writer.\n\nUse PRAGMA journal_mode to determine your SQLite database’s journaling mode. Use PRAGMA journal_mode=WAL to change to write-ahead logging mode.\n\nThe Disk Writes Report pane suggests using write-ahead logging when a stack trace indicates a different journaling mode.\n\nAvoid using the explicit VACUUM command\n\nUsing the SQLite VACUUM command saves space by rebuilding the database. The operation copies the existing database to a temporary file, then moves information back into the database, which may result in excessive disk writes.\n\nWhen possible, rebuild the database incrementally by setting the auto_vacuum() pragma to 2. Then use the incremental_vacuum() pragma to remove any existing empty pages from the free pages list.\n\nThe Disk Writes Report pane suggests using incremental vacuuming when a stack trace indicates the database is in full auto-vacuum mode.\n\nSee Also\nResponsiveness\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nUnderstanding user interface responsiveness\nMake your app more responsive by examining the event-handling and rendering loop.\nUnderstanding hangs in your app\nDetermine the cause for delays in user interactions by examining the main thread and the main run loop.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing terminations in your app\nMinimize how frequently the system stops your app by addressing common termination reasons."
  },
  {
    "title": "Reducing your app’s launch time | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reducing-your-app-s-launch-time",
    "html": "Overview\n\nA user’s first experience with an app is the wait while it launches. The OS indicates the app is launching with a splash screen on iOS and an icon bouncing in Dock on macOS. The app needs to be ready to help the user with a task as soon as possible. An app that takes too long to launch may frustrate the user, and on iOS, the watchdog will terminate it if it takes too long. Typically, users launch an app many times in a day if it’s part of their regular workflow, and a long launch time causes delays in performing a task.\n\nWhen the user taps an app’s icon on their Home screen, iOS prepares the app for launch before handing control over to the app process. The app then runs code to get ready to draw its UI to the screen. Even after the app’s UI is visible, the app may still be preparing content or replacing an interstitial interface (for example, a loading spinner) with the final controls. Each of these steps contributes to the total perceived launch time of the app, and you can take steps to reduce their duration.\n\nUnderstand app activations\n\nAn activation happens when a user clicks on your icon or otherwise goes back to your app.\n\nOn iOS, an activation can either be a launch or a resume. A launch is when the process needs to start, and a resume is when your app already had a process alive, even if suspended. A resume is generally much faster, and the work to optimize a launch and resume differs.\n\nOn macOS, the system will not terminate your process as part of normal use. An activation may require the system to bring in memory from the compressor, swap, and re-render.\n\nUnderstanding cold and warm launch\n\nYour app activation varies significantly depending on previous actions on the device.\n\nFor example, on iOS, if you swipe back to the home screen and immediately re-enter the app, that is the fastest activation possible. It’s also likely to be a resume. When the system determines that a launch is required, it is commonly referred to as a “warm launch.”\n\nConversely, if a user just played a memory-intensive game, and they then re-enter your app, for example, it may be significantly slower than your average activation. On iOS, your app typically was evicted from memory to allow the foreground application more memory. Frameworks and daemons that your app depends on to launch might also require re-launching and paging in from disk. This scenario, or a launch immediately after boot, is often referred to as a “cold launch.”\n\nThink of warm and cold launches as a spectrum. In real use, your users will experience a range of performance based on the state of the device. This spectrum is why testing in a variety of conditions is essential to predicting your real world performance.\n\nGather metrics about your app’s launch time\n\nVariations in launching mean that understanding how your app is operating in the field can be challenging.\n\nFor iOS apps, use the Launch Time pane in the Xcode Organizer to view the number of milliseconds between the user tapping your icon and when your first screen is drawn, after the static splash screen. Use the filters to check launch times on different devices and for the typical (50th percentile) and longest (90th percentile) times. Compare the launch time of the current release with a previous one by clicking on bar in the graph for the desired release.\n\nMetricKit reports the time to resume the application in addition to the launch time. MXAppLaunchMetric contains a histogram of your launch and resume times for the previous day.\n\nProfile your app’s launch time\n\nOnce you know how long it takes your app to launch, you need to know why it takes that long. Profiling your app’s code is a way to gather the data you need about where your app spends its time. During the profiling process, Instruments gathers information about what methods your app called and how much time it spent executing them. Use this data to identify potential bottlenecks or issues in your code.\n\nProfile your app in Instruments by using the App Launch template. During your launch, Instruments gathers a time profile and thread-state trace. Use the time profile to identify the code your app is running during launch. Use the thread-state trace to find times when threads are active or blocked, and discover the reasons that threads are blocked.\n\nProfile your app’s launch time in different situations to see how these factors affect the experience. Here are some examples of different situations to test:\n\nSwitch the device on, unlock it for the first time, and then launch your app.\n\nForce quit your app, and then launch it. The system will terminate your app process, and the system will perform a warm launch.\n\nIf you open other apps and then launch yours, the system partially evicts your app and its dependencies This mirrors a common user workflow.\n\nUse a very large app — for example, one that works with many graphical resources or live camera input — and then launch your app. The system will likely terminate your app’s process\nterminated, which means the system needs to page in many of the app’s dependencies during your next launch.\n\nUIKit draws views and handles user events on the main thread, so that thread must be available to draw the first frame when the app has finished launching. In the Instruments thread trace, time that the main thread spends running or preempted is time that it cannot draw views or respond to user input events.\n\nFor a different view of app launch, profile the app using the Time Profile template. The App Life Cycle timeline divides activity during app launch into process initialization, UIKit initialization, UIKit initial scene rendering, and initial frame rendering.\n\nReduce dependencies on external frameworks and dynamic libraries\n\nBefore any of your code runs, the system must find and load your app’s executable and any libraries on which it depends.\n\nThe dynamic loader (dyld) loads the app’s executable file, and examines the Mach load commands in the executable to find frameworks and dynamic libraries that the app needs. It then loads each of the frameworks into memory, and resolves dynamic symbols in the executable to point to the appropriate addresses in the dynamic libraries.\n\nEach additional third-party framework that your app loads adds to the launch time. Although dyld caches a lot of this work in a launch closure when the user installs the app, the size of the launch closure and the amount of work done after loading it still depend on the number and sizes of the libraries loaded. You can reduce your app’s launch time by limiting the number of 3rd party frameworks you embed. Frameworks that you import or add to your app’s Linked Frameworks and Libraries setting in the Target editor in Xcode count toward this number. Built-in frameworks, like CoreFoundation, have a much lower impact on launch, because they use shared memory with other processes that use the same framework.\n\nRemove or reduce the static initializers in your code\n\nCertain code in an app must run before iOS runs your app’s main() function, adding to the launch time. This code includes:\n\nC++ static constructors.\n\nObjective-C +load methods defined in classes or categories.\n\nFunctions marked with the clang attribute __attribute__((constructor)).\n\nAny function linked into the __DATA,__mod_init_func section of an app or framework binary.\n\nWhere possible, move the code to a later stage of the app’s life cycle, after the app has finished launching but before the results of the work are needed. In Instruments, the Static Initializer Calls instrument measures the time your app spends running static initializers.\n\nMove expensive tasks out of your app delegate\n\nAudit your initialization code to delay expensive work. The system calls methods of your app delegate during the launch cycle to give you time to perform required tasks. These methods execute synchronously on the main thread, and the launch cycle doesn’t finish until both methods return successfully. As a result, any expensive tasks you perform from the methods delay the completion of that launch cycle.\n\nUIKit initializes an instance of your app delegate class (the class that conforms to the UIApplicationDelegate protocol) and sends it the application(_:willFinishLaunchingWithOptions:) and application(_:didFinishLaunchingWithOptions:) messages. UIKit sends these messages on the main thread, and time spent executing code in these methods increases your app’s launch time. Do only the work necessary to prepare your app’s initial display in these methods; defer other tasks to more appropriate times in the app’s life cycle.\n\nDefer synchronization of the data model with a network service until the app is running, if it makes sense to show stale content to the user while the content is being refreshed. Move the synchronization to an asynchronous background queue. Register a background task to fetch updates from the network service, to reduce both the staleness of data on launch and the amount of work needed to bring it up to date.\n\nInitialize nonview functionality, such as persistent storage and location services, on first use rather than on app launch. Retrieve only the data necessary to display your app’s initial view. Pay attention to whether your app is restoring state, and prepare the data needed to display the view that’s being restored. If no state is being restored, prepare only the default initial view. For example, a photo gallery app might show a collection of image thumbnails by default and let a user pick a photo to get a detailed view. If the app is launching with no restored state, it only needs to show a placeholder for a screenful of thumbnails and fill them in with real image thumbnails once the app has finished launching. It doesn’t need to load the full, detailed images until the user taps one of the thumbnails.\n\nInitialize a restricted subset of the app’s behavior that’s known to be viable on initial launch. For example, a task manager app can let the user create a new task on launch, even if the app hasn’t yet retrieved all of the user’s existing tasks from its persistent storage or network service.\n\nReduce the complexity of your initial views\n\nXcode Organizer and MetricKit both use the time to first frame as the measurement of launch time, including the time required to draw the views that are displayed on that first frame. You can only modify the view hierarchy on the main thread; therefore, a more complicated view hierarchy with more views takes longer to render than a simple hierarchy.\n\nReducing the complexity of your app’s initial view improves the load time, as does replacing custom views that override draw(_:) with standard views. Where you need custom drawing, pay attention to the rectangle passed to draw(_:) and only render parts of the view within that rectangle. Doing so avoids decoding images and computing colors, coordinates, and drawing commands in parts of the view that aren’t rendered to the screen.\n\nTrack additional startup activities\n\nThe launch-time metric measures the time from the user tapping the app icon on their Home screen to the app drawing its first frame to the screen. Drawing the default.png or launch-screen storyboard happens during this time, and its appearance doesn’t end the launch-time counter.\n\nIf your app still has to run code after it has drawn its first frame, but before the user can begin using the app, that time doesn’t contribute to the launch-time metric. Extra startup activities still contribute to the user’s perception of the app’s responsiveness. For example, if your app renders a document after opening, the user will likely wait on the document to render and perceive it as part of your launch time, even though the system will end the launch measurement while you show a loading icon.\n\nTo track additional startup activities, create an OSLog object in your app with the category pointsOfInterest. Use the os_signpost function to record the beginning and end of your app’s preparation tasks, as shown in the following example:\n\nclass ViewController: UIViewController {\n    static let startupActivities:StaticString = \"Startup Activities\"\n    let poiLog = OSLog(subsystem: \"com.example.CocoaPictures\", category: .pointsOfInterest)\n\n\n    override func viewDidAppear() {\n        super.viewDidAppear()\n        os_signpost(.begin, log: self.poiLog, name: ViewController.startupActivities)\n        // do work to prepare the view\n        os_signpost(.end, log: self.poiLog, name: ViewController.startupActivities)\n    }\n}\n\n\nIn Instruments, Points of Interest displays the os_signposts in its timeline. You can use this information to correlate activity in your app with the app’s additional startup tasks.\n\nSee Also\nResponsiveness\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nUnderstanding user interface responsiveness\nMake your app more responsive by examining the event-handling and rendering loop.\nUnderstanding hangs in your app\nDetermine the cause for delays in user interactions by examining the main thread and the main run loop.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode.\nReducing terminations in your app\nMinimize how frequently the system stops your app by addressing common termination reasons.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage."
  },
  {
    "title": "Reducing your app’s memory use | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reducing-your-app-s-memory-use",
    "html": "Overview\n\nThe memory (RAM) on a device is a limited resource that’s shared by apps, operating system processes, and the kernel. iOS has techniques for satisfying the various demands on memory, but these techniques come at the expense of speed and responsiveness. For example, iOS might transfer a memory-intensive app to solid-state storage when the app is running in the background. The app then incurs a delay when coming back to the foreground or attempting to run a background task.\n\nIf the app is using too much memory, iOS sends it a warning. You get notifications of such warnings in the form of a crash report. This report, with an EXC_RESOURCE exception type and MEMORY subtype, indicates that the app has approached its memory limit. It doesn’t mean that iOS has terminated the app, only that it has detected a memory-use problem. The memory limit that triggers the exception depends on the device, and once an app exceeds this limit, iOS terminates it. If the app is terminated when it’s in the foreground, the user sees it disappear. The next time the user opens the app, it launches from the beginning, which takes longer than resuming from the background.\n\nBecause the device shares memory between apps and iOS processes, one app using too much memory can compromise the user experience across the whole device. Limiting the amount of memory an app uses can benefit users even when they’re using other apps.\n\nUnderstand memory-use metrics\n\nThe Xcode Organizer and MetricKit each provide two metrics about memory use in an app. The first metric is peak memory use, which is the highest memory use observed in any of the samples taken. iOS collects this metric by sampling the app’s memory use periodically throughout the day. The second metric is memory use observed on suspension, measured when the app enters the background.\n\niOS measures memory use as the number of memory pages in use multiplied by page size, which is typically 16 KB. Writing a single byte to allocated memory can increase memory use by 16 KB if iOS must allocate a new page to store that byte.\n\nData structures defined in the app’s executable or linked libraries and frameworks contribute to the memory-use metric. Memory that the app allocates at runtime doesn’t initially contribute to this metric. Such memory is “clean,” and iOS doesn’t need to dedicate physical RAM to store it. When the app writes to the allocated memory, it becomes “dirty,” and iOS dedicates RAM to storing its content, as shown in the illustration below. Dirty memory contributes to the memory-use metric.\n\nView data on memory use\n\nView your app’s memory use in the Memory pane of the Xcode Organizer window or by using MetricKit.\n\nThe Memory pane shows information for peak memory in the top graph and memory at suspension on the bottom. Filter the information by device type and by typical memory used (50th percentile) or top memory used (90th percentile), using the two menus in the top right corner, to find possible problem areas. Compare the memory use of the current release with a previous one by clicking on bar in the graph for the desired release.\n\nTopics\nTasks\nGathering information about memory use\nIdentify memory-use inefficiencies by measuring and profiling your app.\nMaking changes to reduce memory use\nDecrease your app’s use of memory by addressing common causes of excessive use.\nPreventing memory-use regressions\nMeasure the memory that your app’s features use, and detect increases by using XCTest performance tests.\nResponding to low-memory warnings\nDetect when your app is using excessive memory, and bring memory use under control.\nSee Also\nRelated Documentation\nIdentifying high-memory use with jetsam event reports\nDiscover why the operating system terminated your app when available memory was low.\nMemory and size\nReducing your app’s size\nMeasure your app’s size, optimize its assets and settings, and adopt technologies that help streamline installation over a mobile internet connection.\nGathering information about memory use\nIdentify memory-use inefficiencies by measuring and profiling your app.\nMaking changes to reduce memory use\nDecrease your app’s use of memory by addressing common causes of excessive use.\nPreventing memory-use regressions\nMeasure the memory that your app’s features use, and detect increases by using XCTest performance tests.\nResponding to low-memory warnings\nDetect when your app is using excessive memory, and bring memory use under control."
  },
  {
    "title": "Reducing terminations in your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/reduce-terminations-in-your-app",
    "html": "Overview\n\nTerminations are part of the app lifecycle, when the system stops your process. You can significantly reduce terminations by fixing bugs and lowering your app’s resource consumption; however, terminations are expected and you cannot fully eliminate them. The system uses terminations to prioritize resources needed to keep the foreground user experience fluid.\n\nWhen the system terminates your app, your app must re-launch the next time a user activates it. A re-launch is much slower than re-activating your app.\n\nView Termination data using the Xcode Organizer or collect data in your app using MetricKit’s MXAppExitMetric.\n\nFor more information about debugging your terminations, see the following WWDC session video: developer.apple.com/videos/play/wwdc2020/10078.\n\nUnderstand termination reasons\n\nThe system stops your app when it encounters any of the following issues.\n\nAborts (Abnormal Exits). An abort happens when your process calls abort(). This commonly occurs when your app encounters uncaught exceptions or failed assert() calls, often through a framework that your app uses. An abort makes use of the SIGABRT signal. Aborts are crashes.\n\nMemory Limit. On iOS, the system attempts to provide foreground apps as much memory as possible. If your app attempts to use more memory than the system can provide, the system terminates it.\n\nBad Access. A Bad Access termination happens when your app attempts to access invalid memory; for example, by deferencing null pointers or by attempting to index out of bounds on an array. Bad Access terminations are crashes.\n\nIllegal Instruction. An Illegal Instruction termination happens when your app attempts to execute an instruction that the system cannot interpret. Illegal Instruction terminations are crashes.\n\nApp Watchdog. An App Timeout happens when your app takes too long to launch. The system gives a lenient amount of time to launch, and a timeout is generally indicative of your app getting stuck on launch. Many users will quit your app before this limit is hit, and those quits will not be considered an App Timeout. macOS apps do not have a launch time limit.\n\nMemory Pressure. As part of the normal app lifecycle, iOS & watchOS terminate apps when the system requires more memory than is currently available. The system most often terminates apps in the background when a foreground app needs more memory. Reduce the frequency of memory pressure terminations for your app by lowering your memory at suspension. You can see memory at suspension in the Xcode Organizer. Because you cannot remove all memory pressure terminations, ensure that your app has proper state restoration to provide a fluid user experience.\n\nTo resolve terminations that are crashes, view the stack trace for the crash in the Crashes Organizer in Xcode. For more information about diagnosing and resolving a crash, see Diagnosing Issues Using Crash Reports and Device Logs .\n\nBackground termination reasons\n\nSome termination reasons only apply while your app is in the background:\n\nTask Timeout. The system allows your app to continue executing in the background, after the user has placed the app in the background, through the use of the beginBackgroundTask API. If your app does not finish its work in the allotted time, the system will terminate it with the Task Timeout reason.\n\nFile Lock. A File Lock termination happens when your app continues to hold a lock on a shared file held in your AppGroup when the user put your app in the background. The system performs this termination to avoid blocking on a lock that your app may never release.\n\nSee Also\nResponsiveness\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nUnderstanding user interface responsiveness\nMake your app more responsive by examining the event-handling and rendering loop.\nUnderstanding hangs in your app\nDetermine the cause for delays in user interactions by examining the main thread and the main run loop.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage."
  },
  {
    "title": "Diagnosing performance issues early | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/diagnosing-performance-issues-early",
    "html": "Overview\n\nIdentifying potential performance issues during development saves testing time later. Resolving performance issues, such as priority inversions and non-UI work on the main thread, makes your app responsive. Priority inversions occur when a low-priority thread blocks a higher-priority thread, which can lead to an unresponsive app. Similarly, non-UI work, such as synchronous networking or I/O on the main thread, can block the main thread for hundreds of milliseconds, which prevents people from interacting with your app.\n\nThe Thread Performance Checker tool detects priority inversions and non-UI work on the main thread. It doesn’t require any recompilation. Use the Thread Performance Checker tool to detect, diagnose, and resolve performance issues.\n\nUnderstand the detected issues\n\nThe Thread Performance Checker tool surfaces issues in the Issue navigator and the source editor. Read the diagnostic message carefully.\n\nTo understand the issue in depth, expand the backtrace of the issue in the Issue navigator.\n\nThe issues surfaced point to code in your project that can cause hangs. Hangs occur when your app is unresponsive for hundreds of milliseconds. To learn more about hangs, see Improving app responsiveness and the WWDC session video Understand and eliminate hangs from your app.\n\nDiagnose and resolve priority inversions\n\nIf you use concurrency primitives, such as dispatch_semaphore_wait and dispatch_group_wait, in your code or invoke APIs that use them, your app is susceptible to priority inversions if there is a mismatch in the quality-of-service (QoS) class of the dispatch queues your app uses. When you use these primitives, the system can’t automatically propagate priority from the higher-priority thread to the lower-priority thread. You can take these precautions to avoid priority inversions in your code:\n\nDon’t use dispatch_semaphore_wait and dispatch_group_wait to emulate synchronous behavior when calling an asynchronous internal method or API. Remove the code if the underlying functionality is unnecessary.\n\nEnsure that the QoS of the waiting thread is the same as or lower than the QoS of the signaling thread when a synchronous variant isn’t available. Explicitly classify the QoS of the work when you create a Dispatch Queue or an OperationQueue.\n\nThe code in initiateBackgroundWork below explicitly creates a dispatch queue with background QoS. doBackgroundWorkAsync signals the completion of the background work it does asynchronously at background QoS. After the background work completes, it updates the UI label on the main thread at userInteractive QoS.\n\nfunc initiateBackgroundWork() {\n    let dispatchSemaphore = DispatchSemaphore(value: 0)\n    let backgroundQueue = DispatchQueue(label: \"background_queue\", \n                                        qos: .background)\n    \n    backgroundQueue.async {\n        // Perform work on a separate thread at background QoS and \n        // signal when the work completes.\n       doBackgroundWorkAsync {\n           dispatchSemaphore.signal()\n       }\n       \n       _ = dispatchSemaphore.wait(timeout: DispatchTime.distantFuture)\n       \n       DispatchQueue.main.async { [weak self] in\n           self?.label.text = \"Background work completed\"\n       }\n    })\n}\n\n\nTo learn more about priority inversions and QoS, see Modernizing Grand Central Dispatch Usage and Energy Efficiency Guide for iOS Apps.\n\nDiagnose and eliminate non-UI work on the main thread\n\nLong-running synchronous I/O and networking on the main thread can make your app unresponsive. For example, to perform real-time capture, you instantiate an AVCaptureSession object and add appropriate inputs and outputs. Invoking the startRunning() method of an AVCaptureSession object on the main thread of your app can lead to hangs. You can take these precautions to avoid non-UI work on the main thread:\n\nDon’t synchronously read from or write to files and I/O devices on the main thread. Instead, do the work on a separate serial dispatch queue, and notify the completion of I/O by enqueuing a block onto the main queue.\n\nUse the asynchronous variant of an API that performs I/O to do that work off the main thread.\n\nDon’t perform synchronous networking on the main thread of your app. Instead, use an asynchronous networking API, such as URLSession.\n\nDisable the Thread Performance Checker tool\n\nThe Thread Performance Checker tool is enabled by default for schemes that build an app in your project. To disable it, choose Product > Scheme > Edit Scheme to display the scheme editor. Select the Run schemes, navigate to the Diagnostics section, and unselect the Thread Performance Checker tool checkbox.\n\nIn addition to the Thread Performance Checker tool, always test your code using a comprehensive set of performance tests. For more information about testing your code, see Testing your apps in Xcode.\n\nImportant\n\nThe Thread Performance Checker tool is currently supported only on macOS and iOS.\n\nResolution of certain performance issues may require significant code refactoring or redesign of the underlying logic. To suppress the warning for issues you intend to address at a later time, set the PERFC_SUPPRESSION_FILE environment variable to provide a list of classes and methods in a suppression file. The Thread Performance Checker tool only shows issues that don’t involve those classes and methods. Use the following format for your suppression file:\n\nclass:UIActivityViewController\nclass:NSThread\nmethod:-[UIViewController view]\nmethod:readv\n\nSee Also\nRelated Documentation\nAddressing watchdog terminations\nIdentify the signature of an unresponsive app terminated by the watchdog, and address the issue.\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nResponsiveness\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nUnderstanding user interface responsiveness\nMake your app more responsive by examining the event-handling and rendering loop.\nUnderstanding hangs in your app\nDetermine the cause for delays in user interactions by examining the main thread and the main run loop.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing terminations in your app\nMinimize how frequently the system stops your app by addressing common termination reasons.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage."
  },
  {
    "title": "Understanding hangs in your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/understanding-hangs-in-your-app",
    "html": "Overview\n\nA discrete user interaction occurs when a person performs a single well-contained interaction and the screen then updates. An example is when someone presses a key on the keyboard and the corresponding letter then appears onscreen. Although the software running on the device needs time to process the incoming user input event and compute the corresponding screen update, it’s usually so quick that a human can’t perceive it and the screen update seems instantaneous.\n\nWhen the delay in handling a discrete user interaction becomes noticeable, that period of unresponsiveness is known as a hang. Other common terms for this behavior are freeze because the app stops updating, and spin based on the spinning wait cursor that appears in macOS when an app is unresponsive.\n\nAlthough discrete interactions are less sensitive to delays than continuous interactions, it doesn’t take long for a person to perceive a gap between an action and its reaction as a pause, which breaks their immersive experience. A delay of less than 100 ms in a discrete user interaction is rarely noticeable, but even a few hundred milliseconds can make people feel that an app is unresponsive.\n\nA hang is almost always the result of long-running work on the main thread. This article explains what causes a hang, why the main thread and the main run loop are essential to understanding hangs, and how various tools can detect hangs on Apple devices.\n\nNote\n\nThis article assumes a basic understanding of the event-handling and rendering loop, as well as a basic understanding of hangs and hitches, and how they differ. If you’re unfamiliar with hangs and hitches, see Understanding user interface responsiveness for more information about them, as well as the event-handling and rendering loop.\n\nUnderstand work on the main thread\n\nProcessing incoming events and updating the UI accordingly is the responsibility of an app’s main thread. As part of handling an event, the main thread performs the following work:\n\nDelivers the event to the right place and calls the right handler.\n\nMakes any state changes, fetches data, updates the UI, and so on.\n\nPerforms a Core Animation (CA) commit, which submits all the changes of the view hierarchy to the render server. The UI framework usually performs the CA commit automatically when your code finishes handling the event.\n\nYour code is involved in each of these stages, but most of it typically deals with the second stage.\n\nConsider the Send button in a messaging app using SwiftUI. Your implementation might look like the following:\n\nimport SwiftUI \n\n\nstruct MessengerView: View {\n    @State var messageText: String\n\n\n    var body: someView {\n        // [...] other UI\n        Button(\"Send\", action: {\n            messageSender.send(message: messageText)\n        })\n        // [...] other UI\n    }\n}\n\n\nWhen someone taps the Send button, they touch the screen where the button appears. The operating system registers this as a touch-down event. Similar events exist for other input methods, like mouse-down on macOS.\n\nAs soon as the finger comes in contact with the screen, the touch-down event is sent. Your app’s main thread then determines which view is responsible for handling the event. It compares the event’s location on the screen to the frames of all the views in the view hierarchy to find the one that’s frontmost at that location. Because the user touched the location of your Send button, the view representing that button receives the touch-down event.\n\nWhen they lift their finger from the screen, the touchscreen registers the finger leaving the screen, and the OS creates a touch-up event and delivers it to your app. The touch-up event goes to the same view that received the corresponding touch-down event, even if the finger has moved to a different position by then. In response to the touch-up event, if the location of the finger is still inside its bounds when the touch-up event occurs, a Button calls its action closure.\n\nAt this point, the first stage, event dispatching, or event delivery, is complete. The event reaches its destination and the UI framework calls the appropriate event-handling method, which is usually your code, on the selected view. Your design also contributes to how quickly the system delivers events, as you set up the view hierarchy, decide where to place the button, and add any other UI elements, which might include custom views. All of this can have an impact on the speed of event delivery. However, most of the time, this step is fast and not something you need to worry about.\n\nDuring the second stage, SwiftUI calls your send(message:) method as part of calling the Button’s action closure, where your app likely starts some asynchronous work to serialize the message string into a data packet, send it to a backend server, and so on. Your app also needs to add the new message to the list of messages in the current conversation, so it can store it, even if sending the message fails. Additionally, your app needs to update the UI to show the user the result of their action. For instance, you might want to display a message bubble onscreen and clear the text field to prepare it for the next message. For more information on responding asynchronously to UI events, see Improving app responsiveness.\n\nIn the third stage, the UI framework takes over again and commits the changes to the UI so the render server can start rendering the new frame. Your code usually isn’t directly involved in the CA commit, but your code does influence how many changes the UI framework needs to commit and how expensive the commit is.\n\nHandling this event isn’t the only thing your app needs the main thread for. Maybe you set a timer to check whether the user is still typing and then update a typing indicator, or your app’s request to the backend server to check for new messages finishes and returns a new message that the app needs to display onscreen.\n\nIn each of these situations, your app needs to make updates to the user interface, but doing so isn’t thread-safe, meaning the system can’t modify the UI from multiple threads at the same time. Instead, it needs to serialize and execute the updates to the UI one after the other. For this reason, there’s only one thread that can make UI updates: the main thread. In Swift, using the MainActor ensures that your code executes on the main thread. It also helps the compiler prevent any code outside the main thread from making changes to the user interface.\n\nBecause there’s only one thread that can make changes to the UI, you don’t want to block it waiting for someone to press the Send button. So, the system needs need a way to schedule work to execute on the main thread, and then check for that work and execute it whenever it comes in — whether it’s handling an event, processing the result of a network request, or reacting to a timer firing. This scheduling and sequential processing of various work items is the responsibility of the main thread’s RunLoop.\n\nUnderstand the main run loop\n\nRun loops provide a mechanism for threads to wait on input sources and fire input handlers when any of those sources has data or events to process. Any thread can have a run loop. The main thread starts a run loop, the main run loop, as soon as an app finishes launching. This is the run loop that processes all incoming user interaction events.\n\nA very simplified implementation of a run loop might resemble the following:\n\nclass RunLoop {\n    var stopped = false\n    \n    func run() {\n        repeat {\n            if let work = workSet.fetchNextWorkItem() {\n                processWork(work)\n            } else {\n                sleepUntilNewWorkArrives()\n            }\n        } while(!stopped)\n    }\n}\n\n\nAfter calling run, the run loop keeps running in an infinite loop, checking for new work to process. If there’s work to do, the run loop processes it by calling an appropriate handler. If there isn’t any work, it goes to sleep, which means the main thread also sleeps, so it isn’t running. If a new work item comes in, the operating system wakes up the main thread, and its run loop processes the incoming work before going back to sleep.\n\nAny work that the system needs to execute on the main thread, like updating the UI, becomes a work item that it submits to the run loop, and the run loop then processes it as soon as possible. Work items may include:\n\nIncoming user events\n\nA callback of a timer scheduled on the run loop (when a timer fires, it submits its callback to run on the run loop.)\n\nWork on the main DispatchQueue, the main OperationQueue, or the main actor\n\nAlthough the run loop performs work items that the system submits to it on the main thread, it isn’t the same as the main dispatch queue. The main dispatch queue, the main NSOperationQueue, the main actor, and the main run loop are all ways to submit work to run on the main thread, but for the main thread specifically, the run loop is the foundation of everything.\n\nThe main dispatch queue, the main NSOperationQueue, and the main actor are clients of the run loop, and the run loop executes work you submit to any of them, but it can also execute work from other sources. As such, a long-running item that you submit to the main dispatch queue becomes a long-running item on the main run loop, and prevents other work from executing. And a long-running item on the main run loop prevents it from executing any work of other run-loop clients, whether it’s the main dispatch queue, a timer, or some other work.\n\nIdeally, the run loop only wakes up briefly to process an incoming event, goes to sleep again, and spends most of the time asleep waiting for new work.\n\nIf the run loop is already processing work, it can’t handle a new incoming event until processing of the previous work item is complete. So, it’s important to finish any work on the main thread as quickly as possible so the run loop can go back to sleep and wait for the next incoming event.\n\nIn the case of an incoming user input event, the run loop simply processes the event by calling the corresponding UI framework, such as UIKit or AppKit, which handles the event, likely calling some of your code in the process. To handle an event promptly, the run loop needs to be asleep or just finishing a work item when the event comes in.\n\nNo matter why your code runs on the main run loop, whether its due to handling an event or any of the other ways described above: If code running on the main runloop takes too long to complete, it prevents the run loop from processing other work, including incoming events, and may cause a hang.\n\nUnderstand hangs\n\nAlthough the relevant delay for the user is the time between interacting with the physical device and the physical screen updating, most of the stages in the event-handling and rendering loop take a short amount of time and are fairly consistent in timing.\n\nIt usually takes just a few milliseconds for the hardware device to recognize user input, send it to the OS, and have the OS forward it to the correct process. Although the output side of rendering the new frame and updating pixels on the display can add a delay of 16 ms to 50 ms, it’s rare that these steps take longer when everything else in your app works well.\n\nBecause the other stages have fairly consistent timing, it’s almost always main thread work that takes too long when the system doesn’t meet this threshold. This can be due to the event handling itself taking too long, or due to the main thread being busy with other work and not being available to handle the event. Observing the main runloop’s behavior is a good way to tell whether the main thread is too busy.\n\nA healthy run loop spends most of its time asleep and waiting for events, as in the following example:\n\nIn the screenshot above, the run loop is waiting for events (the gray areas) most of the time, and the periods where it’s busy (the light blue areas) are very short.\n\nFor this reason, the hang reporting feature on Apple platforms focuses on the main run loop being unresponsive for an extended period of time as a proxy for hangs that the user experiences. More specifically, hang reporting looks at the duration between two waiting for events periods of the run loop, also known as the busy portion. During a busy period, the run loop can’t process other incoming events, so if it gets too long, the system reports it as a potential hang.\n\nMost of Apple’s developer tools start reporting issues when the period of unresponsiveness for the main run loop exceeds 250 ms. Some of them, like the Hangs instrument in the Instruments app, allow you to choose lower thresholds for reporting an unresponsive main run loop.\n\nHang reporting only measures the time on the main run loop. The time necessary for event delivery, before handing the event to the main run loop, and the time to render the new screen after the main thread finishes updating the UI can add 10 ms to 50 ms to the overall delay that the user experiences, even under normal operation.\n\nSee Also\nResponsiveness\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nUnderstanding user interface responsiveness\nMake your app more responsive by examining the event-handling and rendering loop.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing terminations in your app\nMinimize how frequently the system stops your app by addressing common termination reasons.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage."
  },
  {
    "title": "Understanding user interface responsiveness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/understanding-user-interface-responsiveness",
    "html": "Overview\n\nHuman perception is adept at identifying motion and linking cause to effect through sequential actions. This is important for graphical user interfaces because they rely on making the user believe a certain interaction with a device causes a specific effect, and that the objects onscreen behave sufficiently realistically. For example, a button needs to highlight when a person taps or clicks it, and when someone drags an object across the screen, it needs to follow the mouse or finger.\n\nThere are two ways this illusion can break down:\n\nThe time between user input and the screen update is too long, so the app’s UI doesn’t seem like it’s responding instantaneously anymore. A noticeable delay between user input and the corresponding screen update is called a hang. For more information, see Understanding hangs in your app.\n\nThe motion onscreen isn’t fluid like it would be in the real world. An example is when the screen seems to get stuck and then jumps ahead during scrolling or during an animation. This is called a hitch.\n\nThis article covers different types of user interactions and how the event-handling and rendering loop processes events to handle them. This foundational knowledge helps you understand what causes hangs and hitches, how the two are similar, and what differentiates them.\n\nUnderstand different types of interactions\n\nA discrete user interaction occurs when the user performs a single well-contained interaction and the screen then updates in response. An example is when somebody presses a key on the keyboard and the corresponding letter then appears onscreen. Another example is pressing a button on a touchscreen. However, in that case, there are two discrete interactions. First, the finger presses down on the button and, in response, the button changes color or otherwise indicates it’s in a pressed state. Then, the finger lifts and, in response, the button changes back to its previous visual state to show it’s no longer pressed.\n\nA continuous user interaction occurs when the user performs a longer series of movements or gestures, and the screen updates continuously throughout the interaction. Examples of this include scrolling through a list, dragging an icon, and using a two-finger pinch gesture to zoom in or out on a map.\n\nIn general, humans are much more sensitive to delays in continuous interactions than delays in discrete interactions. A small latency that isn’t noticeable for a discrete user interaction may become visible during a continuous user interaction, such as when a dragged icon doesn’t quite keep up with the user’s finger.\n\nHumans are even more sensitive to nonfluid motion. In the example of dragging an icon, a delay of 50 milliseconds (ms) between the finger changing direction and the icon changing direction may be noticeable when looking for it. However, it isn’t obvious when the delay stays constant and the icon moves smoothly.\n\nIf the latency between a change in user interaction and the corresponding screen update is smaller, but inconsistent, the icon seems to sometimes get stuck for a moment and then jumps ahead. This kind of jarring movement is far more noticeable than a slightly longer delay. For this reason, Apple devices often optimize for smooth motion while accepting a slightly longer interaction latency, if necessary. There are times when both an extremely low interaction latency and fluid motion onscreen are crucial to making an interaction feel real. One example of this is drawing onscreen with Apple Pencil.\n\nUnderstand the event-handling and rendering pipeline\n\nFor a single user-input event, there are several steps in the event’s journey through the system.\n\nAs the diagram above illustrates, a user interaction propagates through the system as follows:\n\nUser clicks\n\nThe user interacts with an input device by performing a click, tap, or press.\n\nHardware\n\nThe hardware, such as a mouse, touchscreen, or keyboard, recognizes the input, and forwards it to the operating system (OS).\n\nOS event delivery\n\nThe operating system determines which process is responsible for handling the user input event, which is usually the currently active app or the app that owns the window where the event occurs.\n\nMain thread work\n\nThe system puts the event in an app-specific queue, and it’s the responsibility of the main thread of the app to pick up the events and process them. The thread is called the main thread due to this responsibility, and because it’s also the only thread in your app that can modify the view hierarchy, which makes up your app’s UI. If a UI update is necessary, the app updates the view hierarchy, still on the main thread. The app also updates the layer tree (containment, position) and provides content for the individual layers to display. However, compositing the layers into a single bitmap image to display onscreen doesn’t happen inside the app.\n\nRender server\n\nThe render server is a separate process that handles all rendering of the various processes that need to draw to the screen. It composites the layer trees from the apps and the system processes into a final image.\n\nUpdate display\n\nWhen the final image representing the new frame is ready, the display driver uses it to update the display. The display driver checks at regular intervals to determine whether the screen needs updating. The time when a display update can start is known as the vertical sync, or vsync, and the time between two potential display updates is the vsync interval, or the display refresh interval.\n\nDifferentiate hangs and hitches\n\nAs mentioned above, a hang is a noticeable delay in a discrete user interaction, and it’s almost always the result of long-running work on the main thread. Long-running work on the main thread can also cause hitches, but for hitches, the threshold is lower. Discrete interaction delays only start becoming noticeable as hangs when the main thread is unresponsive for about 50 ms to 100 ms or longer. However, a delay as small as the length of a single refresh interval — generally between 8 ms and 16 ms, depending on the refresh rate of the display — can cause a hitch. Delays in the render server can also cause a hitch, but usually aren’t long enough to cause a hang.\n\nFor a hang, only the delay between a user interaction and the corresponding screen update is relevant. For more information about hangs, see Understanding hangs in your app. To avoid a hitch, which describes a failure in fluid motion, it’s only relevant to be able to update the screen with each screen refresh. The delay between user input and screen update isn’t relevant for a hitch.\n\nBecause of the much lower time thresholds for hitches, as well as the fact that an unresponsive main thread can also cause hitches, when the system detects a potential hang, the same system state might also cause a hitch.\n\nUnderstand when the system reports hitches and hangs\n\nBecause the system detects hitches by measuring the time between the start of a screen update event and the UI updating, it can only detect hitches when user interaction is happening or another trigger for screen updates exists. When no such trigger exists, the display doesn’t need to update, so the frame can’t be late.\n\nAlthough a hang is also only noticeable by the user when they interact with their device, the system can detect the conditions leading to a hang by examining the behavior of the main run loop. It measures extended periods of unresponsiveness of the main run loop, regardless of whether the user happens to be interacting with the app at the time. In that sense, the system reports potential hangs, conditions that would cause a hang if the user were to interact with the device during that time. For hitches, the system only reports actual delays in screen updates. It can’t detect device states that would potentially lead to a hitch.\n\nFix hangs first\n\nPrioritize investigating and addressing hangs first because they’re easier to understand and usually easier to fix.\nAnd by fixing the hangs, you’re likely to fix major sources of hitches as well.\n\nWhen analyzing the hangs, do the following:\n\nSeparate UI update work from non-UI tasks, such as loading updated data, and ensure the non-UI work runs on a background queue.\n\nLook for hangs where the main thread is doing too much work.\nInvestigate whether you can do less work, like reloading only the data for the currently visible objects instead of every object in the list even if it isn’t onscreen.\n\nAfter fixing any hangs, you can look at the hitches in your app, which requires understanding the work of the render server on the main thread, in addition to the work your app is doing there.\n\nTo learn about the various tools to detect hangs and hitches, and best practices to avoid them, see Improving app responsiveness.\n\nSee Also\nResponsiveness\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nUnderstanding hangs in your app\nDetermine the cause for delays in user interactions by examining the main thread and the main run loop.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing terminations in your app\nMinimize how frequently the system stops your app by addressing common termination reasons.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage."
  },
  {
    "title": "Improving your app’s performance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/improving-your-app-s-performance",
    "html": "Overview\n\nPeople using your app expect it to perform well. An app that takes a long time to launch, or responds slowly to input, may appear as if it isn’t working or is sluggish. An app that makes a lot of large network requests may increase the user’s data charges and drain the device battery. Any of these behaviors can frustrate users and lead them to uninstall the app.\n\nPlan and implement performance improvements by approaching the problem scientifically:\n\nGather information about the problems your users are experiencing.\n\nMeasure your app’s behavior to find the causes of the problems.\n\nPlan one change to improve the situation.\n\nImplement the change.\n\nObserve whether the app’s performance improves.\n\nThese activities form a cycle of continuous improvement, as the following illustration shows:\n\nMinimizing resource use benefits your users and improves their perceptions of your app. Here are some specific benefits:\n\nDecreasing app launch time improves the user experience, and reduces the chances of the iOS watchdog timer terminating the app.\n\nDecreasing overall memory use reduces the likelihood of iOS freeing your app’s memory in the background, and improves responsiveness when a user switches back to your app.\n\nReducing disk writes speeds up your app’s overall performance, makes it more responsive, and reduces wear on users’ device storage.\n\nDecreasing hang rate and hang duration improves your users’ perception of your app’s performance and responsiveness.\n\nReducing battery consumption and the use of power-hungry device features makes your app more reliable, and helps ensure that the rest of the user’s device is available when needed.\n\nEven when your measurements and observations show no pressing performance problems, it’s a good idea to run through the performance-improvement cycle and do preventive work to keep your app’s performance from regressing.\n\nGather data about your app’s current performance\n\nTo thoroughly understand your app’s performance, combine information from multiple sources:\n\nUse the Xcode Organizer to view metrics for launch time, user-interface responsiveness, writes to storage, memory use, and energy use, as well as diagnostic reports for disk writes, crashes, and energy. The Organizer lets you break down measurements by device model, app version, and user percentile. For more information, see Analyzing the performance of your shipping app.\n\nUse MetricKit to gather metrics and record them in your own tools. These metrics are in the form of histograms that record the frequency of observed values over a day. MetricKit goes beyond the metrics in the Metrics organizer to include average pixel luminance, cellular network conditions, and durations associated with custom OSSignpost events in your app.\n\nGet feedback from TestFlight testers about their experiences with beta versions of your app. Fill out the Test Information page for your beta version, and request that testers provide feedback about the performance of your app. Include an email address so that testers can report their findings.\n\nInvestigate feedback from your users about their experiences with released versions of your app. Invite users to send their feedback through email or a dedicated interface within your app. Ask them about their experiences using the app — both what works well and any problems they encounter.\n\nDetermine the most important aspect to improve\n\nUse the information from your observations and your understanding of your app’s purpose and expected use patterns to spot the greatest opportunities for improvement. Some performance issues are independent of the type of app under investigation. An app that takes a long time to launch, or is unresponsive to users’ attempts to manipulate the interface, results in users feeling they have no control over the app.\n\nThe largest value for a metric you see in the Metrics organizer or in MetricKit may not indicate the most important issue to address if that value represents expected app usage. For example, energy use associated with background-audio playing is probably not a problem for a podcast player, which users expect to play in the background. However, it would be surprising to see that metric dominate if your app is a game that has no background component to its gameplay.\n\nSeeing that value dominate the metric reports can indicate that efficiency savings are possible, but the most impactful changes may be in the use of auxiliary services that don’t impact the app’s main features. The podcast player might infrequently need to use coarse-grained location services to recommend local-interest podcasts to the listener, but the high-energy consumption associated with the frequent tracking of the user’s precise location may be a sign that a change is necessary.\n\nProfile your app\n\nUse Instruments to profile your app with a profiling template that’s relevant to the metric you’re considering:\n\nUnresponsiveness and hangs: Use the Time Profiler template.\n\nMemory issues: Use the Allocations and Leaks templates.\n\nPower-consumption issues: Use the Energy Log template.\n\nI/O issues: Use the File Activity template.\n\nNetwork-related issues: Use the Network template.\n\nYou get higher-fidelity measurements by profiling on a device instead of the simulator. If the information you gather shows that your app performs poorly on a particular class or model of device, profile on that device.\n\nFind the code that’s causing the performance problem, and create a plan for improving it. Keep in mind that your change may not be localized to a particular line or even function, and you may need to make significant architectural changes to your app. For example, to mitigate a hang that results from synchronously downloading network resources, introduce background operations to handle the networking (see Downloading files in the background), and perform a UI update on the main thread when the downloads are complete.\n\nMake the next change\n\nImplement the change you plan as a result of your investigation. Create an after profile in Instruments that you can compare with the before profile to ensure your change results in an improvement. Consider writing a performance test in XCTest to protect against future regressions in performance, and to serve as a record that the problem existed and you fixed it.\n\nCompare the changed behavior with your original data\n\nAfter you change your app to address the most important performance issue you observe, confirm that the change has the desired effect and that the level of improvement is sufficient. Use the graphs of performance metrics for each version of your app in Xcode’s Metrics organizer to see whether the change results in an improvement or a regression.\n\nFinally, decide whether the metric you’re working on is still the most important to address, or whether the data points to another metric for the next iteration of the performance improvement cycle.\n\nAdditional resources\n\nThe following articles, Xcode Help topics, and WWDC session videos contain more information about using Xcode and Instruments for measuring and improving app performance:\n\nPerformance tools and techniques\n\nDiagnose Performance Issues With the Xcode Organizer\n\nEliminate Animation Hitches With XCTest\n\nInstruments Help\n\nLogging\n\nPerformance on iOS and watchOS\n\nPractical Approaches to Great App Performance\n\nProfile your app’s performance\n\nVisual Debugging with Xcode\n\nWhat’s New in MetricKit\n\nWriting and running performance tests\n\nEnergy consumption\n\nAchieving All-day Battery Life\n\nDebugging Energy Issues\n\nEnergy Efficiency and the User Experience\n\nEnergy Efficiency Guide for iOS Apps\n\nEnergy Efficiency Guide for Mac Apps\n\nIdentify Trends With the Power and Performance API\n\nMonitor a running app using debug gauges\n\nMonitor your app’s energy usage\n\nProfile your app’s energy use\n\nWhat’s New in Energy Debugging\n\nWriting Energy Efficient Apps\n\nXcode Energy Organizer\n\nTopics\nMemory\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nApp launch time\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nDisk writes\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage.\nSee Also\nRelated Documentation\nCreating Custom Modelers for Intelligent Instruments\nCreate Custom Modelers with the CLIPS language and learn how the embedded rules engine works.\nEssentials\nAnalyzing the performance of your shipping app\nView power and performance metrics for apps you distribute through the App Store."
  },
  {
    "title": "Analyzing the performance of your shipping app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/analyzing-the-performance-of-your-shipping-app",
    "html": "Overview\n\nUse the Xcode Organizer to view anonymized performance data from your app’s users, including launch times, memory usage, UI responsiveness, and impact on the battery. Use the data to tune the next version of your app and catch regressions that make it into a specific version of your app.\n\nIn Xcode, choose Window > Organizer to open the Organizer window, and then select the desired metric or report. In some cases, the pane shows “Insufficient usage data available” because there may not be enough anonymized data reported from participating user devices. When this happens, try checking back in a few days.\n\nRead data for a metric\n\nThe Xcode Organizer shows a title, description, and graph for each type of metric. In the graph, each bar represents a version of your app. Use the pop-up menus to filter the metric data for different devices and the median or high value. If your app has an App Clip available, use the pop-up menu to filter by app type and switch between viewing metrics for the main app and the App Clip.\n\nMetrics that show limited usage in the detail section include an associated margin of error because the existing data is limited. Use this margin of error to determine the upper and lower bounds of the displayed value. The margin of error decreases as data increases. The release date information in this section provides the date when the selected app version is ready for sale.\n\nCompare performance with a previous app release\n\nTo explore changes between versions for a metric, such as those for Hang Rate in the image below, click the vertical bar for your selected version.\n\nThe data for both the selected and latest versions appear to the right of the graph with the higher of the two values in bold. Change information for those versions appears in the details section below the latest version data.\n\nRead data for smart insights\n\nThe Xcode Organizer presents a list of smart insights whenever the system detects new performance regressions for the latest version of your app. Each item in the insights list contains information that provides a brief summary.\n\nTo the right of the list is the detail pane that shows a chart corresponding to the selected smart insight. Note that the insight for Scroll Hitch Rate for the typical percentile of samples from “iPad (All)” devices is selected. When a selected insight corresponds to more than one percentile, or to different sets of devices, the detail pane presents a scrollable list of additional charts.\n\nTo the right of the chart is the insight data showing the metric value for the latest version, as well as the average metric values for the previous four versions. Use this information to see how your latest app version is performing with respect to the average of the previous versions.\n\nSelect the Notifications button in the upper-right corner to opt in to power and performance regression notifications. Xcode sends you a notification for the latest version of each of your shipped apps when it detects a high-impact regression. A regression is considered high impact if performance data is available and indicates the latest version of your app regresses 100 percent or more compared to the average of the previous four app versions available in the App Store. Xcode notifies you once per 24-hour period when Xcode is running. To keep notifications to a minimum, Xcode sends you no more than one notification for the same app version.\n\nFor more details about how to use the data in the Organizer panes to improve the performance of the next version of your app, see the topics below.\n\nTopics\nBattery usage\nAnalyzing your app’s battery use\nIncrease the available use time for your app on a single battery charge by reducing your appʼs power consumption.\nResponsiveness\nAnalyzing responsiveness issues in your shipping app\nIdentify responsiveness issues your users encounter, and use the hang and hitch data in Xcode Organizer to determine which issues are most important to fix.\nSee Also\nRelated Documentation\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nEssentials\nImproving your app’s performance\nModel, measure, and boost the performance of your app by using a continuous-improvement cycle."
  },
  {
    "title": "Building your app to include debugging information | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/building-your-app-to-include-debugging-information",
    "html": "Overview\n\nWhen Xcode compiles your source code into machine code, it generates a list of symbols in your app — class names, global variables, and method and function names. These symbols correspond to the file and line numbers where they’re defined; this association creates a debug symbol, so you can use the debugger in Xcode, or refer to line numbers reported by a crash report. Debug builds of an app place the debug symbols inside the compiled binary file by default, while release builds of an app place the debug symbols in a companion debug symbol (dSYM) file to reduce the size of the distributed app.\n\nEach binary file in an app — the main app executable, frameworks, and app extensions — has its own dSYM file. The compiled binary and its companion dSYM file are tied together by a build UUID that’s recorded by both the built binary and dSYM file. If you build two binaries from the same source code but with different Xcode versions or build settings, the build UUIDs for the two binaries won’t match. A binary and a dSYM file are only compatible with each other when they have identical build UUIDs. Keep the dSYM files for the specific builds you distribute, and use them when diagnosing issues from crash reports.\n\nBuild your app with symbol information\n\nBefore building your app for distribution, verify that the Debug Information Format build setting is set to DWARF with dSYM File. This generates the necessary dSYM files, so you can diagnose crashes after releasing your app. For instructions on configuring the build settings for your project, see Configuring the build settings of a target.\n\nThese dSYM files are the most common type of symbol file you need when debugging an app after releasing it.\n\nPublish your app with symbol information\n\nWhen archiving your app for distribution, Xcode gathers all binaries and dSYM files for your app and stores them inside the Xcode archive.\n\nIf you distribute your app through the App Store or conduct a beta test using TestFlight, you have the option to include the symbol files when uploading your app to App Store Connect. You need to upload symbols with your build so the App Store can add the symbol names for your app to the crash reports, before delivering them to the Crashes organizer in Xcode. If you don’t include symbols with the upload to the App Store, you still receive the crash reports through the Crashes organizer, but without the symbol names. Xcode adds symbol names to these crash reports if the correct dSYM files are available on the Mac. See Diagnosing issues using crash reports and device logs for how to work with crash reports using dSYM files.\n\nImportant\n\nYou must retain the Xcode archive for each build of your app you distribute. Without this archive, you might not be able to diagnose an issue from crash reports.\n\nFor more information on archiving your app for distribution, see Distributing your app for beta testing and releases.\n\nSee Also\nReports\nDiagnosing issues using crash reports and device logs\nUse crash reports and device logs to debug app issues."
  },
  {
    "title": "Setting breakpoints to pause your running app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/setting-breakpoints-to-pause-your-running-app",
    "html": "Overview\n\nWhen you identify a place in your source code where you want to investigate a bug, set a breakpoint to pause the debugger so you can inspect your variables and step through your code to isolate the bug.\n\nTo locate crashes or other bugs where it is difficult to know where to set a breakpoint, use symbolic or issue breakpoints to pause on specific problem conditions and quickly identify where a bug occurs.\n\nFor bugs that occur after several iterations or only under certain circumstances, specify conditions on your breakpoint. If you want to log information at specific points in your app or receive notifications when a line of code executes, use breakpoint actions.\n\nSpecify where to pause your app\n\nNavigate to a line in your code where you want execution to pause, then click the gutter or line number in the source editor to set a breakpoint. Xcode displays a breakpoint icon to indicate the location.\n\nDrag a breakpoint up or down to move it to another location; drag it away from the gutter to remove it. Click the breakpoint icon in the debug area toolbar to activate or deactivate all breakpoints.\n\nManage breakpoints across your app\n\nWhen you have many breakpoints set across several source code files, click the Breakpoint Navigator button in the navigator area of the main window to open the Breakpoint navigator to view and manage all breakpoints.\n\nClick a breakpoint label in the Breakpoint navigator to quickly navigate to the breakpoint in the source editor. Pressing the Delete key after selecting a breakpoint label deletes the breakpoint from your code. Click a breakpoint icon in the Breakpoint navigator to enable or disable it.\n\nTo easily find a frequently used breakpoint in the navigator, Control-click the breakpoint label, choose Edit Breakpoint, and enter a name for it. Then use the filter at the bottom of the Breakpoint navigator.\n\nYou can also use the filter to find breakpoints by symbols in the line of code for the breakpoint. The filter tools provide options for showing only modified breakpoints and showing only enabled breakpoints.\n\nSpecify conditions for pausing your app\n\nFor bugs that occur after a certain number of iterations, or under limited conditions that require repetitive actions, it’s cumbersome to pause at the breakpoint and press the Continue button repeatedly until the bug occurs. There are two approaches to handle this type of situation more efficiently in the debugger.\n\nFor a bug that occurs after a certain number of iterations, set the debugger to ignore the breakpoint for some iterations. Control-click the breakpoint, choose Edit Breakpoint, and specify the number of times to ignore the breakpoint before stopping.\n\nFor a bug that occurs under limited conditions, set the debugger to pause on a breakpoint when an expression is true. Control-click the breakpoint, choose Edit Breakpoint, and enter a condition using variables available in the local scope.\n\nThe debugger evaluates the expression each time it reaches the breakpoint in execution, and pauses only if the expression is true.\n\nPause on a symbol outside your code\n\nTo debug some issues, you need to pause on a symbol that your source code doesn’t define. For example, when you encounter an Auto Layout issue, the error message recommends setting a breakpoint on UIViewAlertForUnsatisfiableConstraints. To do that, use a symbolic breakpoint.\n\nIn the Breakpoint navigator, click the Add button (+) in the lower-left corner, and choose Symbolic Breakpoint. Enter the object and symbol in the Symbol field, using the format of the example text.\n\nThe debugger pauses when the app or your code calls the symbol you specify. The example symbol UIViewAlertForUnsatisfiableConstraints typically pauses in the application’s main method and not on a line in your code. When this happens, use the console to view an Auto Layout trace with po [[UIWindow keyWindow] _autolayoutTrace].\n\nTip\n\nSome symbols receive calls very frequently and pausing on each can be unmanageable. Add a condition to the breakpoint to reduce the frequency of calls, or disable the symbolic breakpoint until you reach a breakpoint in your code where you want to start diagnosing the issue, and then enable the symbolic breakpoint.\n\nPause on an uncaught Swift error or Objective-C exception\n\nWhen your app encounters an unhandled Swift Error or Objective-C exception, it crashes. Frequently, the stack trace doesn’t point directly to where the problem occurs. Set a breakpoint to pause on an uncaught Swift Error or Objective-C exception so you can locate the problem.\n\nWhen an unhandled Swift error causes a crash, the debugger shows a fatal error on the line with the try! and not where the error originally occurs.\n\nIf the thrown error has a helpful error message, that may be enough information to resolve the problem. If not, add a Swift error breakpoint to pause on the line that throws the error. In the Breakpoint navigator, click the Add button (+) in the lower-left corner, and choose Swift Error Breakpoint. The app then pauses on the thrown error instead of the try!.\n\nWhen an uncaught Objective-C error causes a crash, the debugger shows the crash in the AppDelegate or main method.\n\nAdd an Objective-C exception breakpoint to pause on the line where the crash occurs instead of main. In the Breakpoint navigator, click the Add button (+) in the lower-left corner, and choose Exception Breakpoint.\n\nFor more information, see Identifying the cause of common crashes.\n\nPause automatically when the system detects a runtime issue\n\nXcode has tools called sanitizers to detect several different types of runtime issues: updating the user interface outside the main thread, updating variables from different threads unsafely, accessing addresses unsafely, and executing code that results in undefined behavior. Configure your scheme to enable sanitizers to detect these issues with static analysis at build time. When you disable the sanitizers and your app encounters one of these issues, your app crashes and Xcode may not clearly identify where the issue occurs.\n\nTo pause your app and investigate, click the Add button (+) in the lower-left corner of the Breakpoint navigator, choose Runtime Issue Breakpoint, and select the type of runtime issue for the breakpoint.\n\nEnable the sanitizer for the issue and run your app. The sanitizer identifies lines of code where it expects runtime issues to occur. When the app pauses at your runtime breakpoint, investigate why the issue occurs. For more information, see Diagnosing memory, thread, and crash issues early.\n\nLog variable values, run scripts, or play sounds at a breakpoint\n\nInstead of writing code to log variable values and details about your app’s execution, use breakpoint actions to log messages and to perform debugger commands that print variable values to the console.\n\nBreakpoint actions can also play sounds when the debugger reaches a breakpoint, which is useful for knowing when code executes without pausing. Breakpoint actions can execute AppleScripts or shell scripts to perform helpful debugging tasks like taking a screenshot or saving some app data for analysis.\n\nTo perform an action with a breakpoint, Control-click the breakpoint, either in the source editor or in the Breakpoint navigator, choose Edit Breakpoint, click Add Action, choose an action and provide any additional information necessary. For example, provide a message for the Log Message action, or a command and parameters for the Debugger Command action.\n\nTo perform more than one action at a breakpoint, click the Add button (+) to the right of an existing action to add another action. To continue executing your app without pausing after performing your action, select the “Automatically continue after evaluating actions” option.\n\nSee Also\nBreakpoints and variables\nStepping through code and inspecting variables to isolate bugs\nFind the cause of your bugs by watching variables change as you step through your source code in the debugger."
  },
  {
    "title": "Stepping through code and inspecting variables to isolate bugs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/stepping-through-code-and-inspecting-variables-to-isolate-bugs",
    "html": "Overview\n\nIf the root cause of a bug isn’t immediately obvious when inspecting your source code, watching your variables change as you step through the code helps you isolate where the bug is occurring so you can investigate the possible cause for it.\n\nThe Xcode debugger provides several methods to step through your code and inspect variables. You can precisely control execution of your code from a breakpoint, stepping into and out of called functions as necessary to determine where your bug occurs. You can monitor variables while stepping through code, or pause execution to inspect them more closely.\n\nStart your investigation at a breakpoint when your app is in a known good state before the bug occurs, at a point where you think the bug may be about to happen.\n\nStep through code in the debugger\n\nWhen you run your app, the debugger pauses at the first breakpoint it encounters, and, by default, updates the display to show the Debug navigator, the source editor, the debug bar, the variable viewer, and the console.\n\nCustomize what Xcode displays when running your app in the debugger by choosing Xcode > Preferences > Behaviors > Running.\n\nUse the buttons in the debug bar to control the execution of your app.\n\nContinue normal execution from the paused position until the app stops at the next breakpoint with the Continue button.\n\nPause the app without setting a breakpoint using the Pause button. The Continue button changes to the Pause button when the app is running.\n\nExecute the next instruction in the same function with the Step Over button.\n\nExecute the next instruction using the Step Into button. If the next instruction is inside another method or function, the debugger jumps to that function and continues executing it each time you click the Step Into button.\n\nClick the Step Out button to skip the rest of the function and return to the next instruction in the calling function or method after using Step Into.\n\nAs you step through your app, inspect variables relevant to your bug and watch for unexpected values.\n\nSee variable values in code and the variable viewer\n\nWhen your app pauses at a breakpoint, hover over a variable in your source code to view its current value. If the variable is an image or other type that isn’t expressible as text, click the Quick Look button at the upper-right to see a preview of the variable. Click the Print Description button to print a description of the object in the console.\n\nThe variable viewer lists the variables available in the current execution context. Select the scope of variables to view from the selector at the bottom left of the viewer: automatic, local, or all variables, registers, globals, and statics. Use the filter field to find variables matching a pattern.\n\nEach variable shows a brief summary of the variable’s type, value, and pointer location, if applicable. The variable viewer generates the summary it shows with the lldb command frame variable. If the summary for a variable isn’t available or only shows a memory pointer, see the Evaluate expressions in the console section below for more ways to inspect the variable.\n\nClick the disclosure triangles to explore instance variables for classes and structures, or internals for other data types. Select a variable and click the Quick Look button to see a preview of the variable, click the Print Description button to print a description of the object in the console.\n\nSee the call stack and navigate related code\n\nWhen the debugger pauses at a breakpoint, it shows the current active threads and the current call stack in the Debug navigator, and highlights the breakpoint. The call stack represents the relationships of function or method calls that result in the current breakpoint.\n\nSelect a line in the call stack if you suspect that your bug is in a calling function. The calling function might change an instance variable incorrectly, or may be passing an incorrect value in a parameter. The debugger shows the source code for that point and the related variables in the variable viewer, if the source code is available in the project. Otherwise, the debugger shows the assembly code for the selected line. Inspect the variables at this point for unexpected values.\n\nSelect a thread to expand or collapse the view of the call stack for that thread. Select a line in the call stack for the thread to see the source and variables.\n\nEvaluate expressions in the console\n\nTo see more information than the summary of a variable shows in the variables viewer, or to change the value of a variable in the middle of a debugging session, use the console to interact with the debugger directly.\n\nPrint the value of a variable in the current stack frame using frame variable, or the shortened alias v.\n\n(lldb) v self.fruitList.title\n(String) self.fruitList.title = \"Healthy Fruit”\n(lldb) v self.listData[0]\n(String) [0] = “Banana\"\n\n\nThe frame variable command returns only what is currently in memory and doesn’t evaluate expressions, so it returns an error if you attempt to print something more. For example, it won’t print a function or method call, an @Published variable, or a calculated variable.\n\n(lldb) v fruitList.fruit(at: indexPath)\nerror: no variable named 'fruitList' found in this frame\nerror: no variable named 'indexPath)' found in this frame\n(lldb) v self.fruitList.calculatedFruitCount\nerror: \"calculatedFruitCount\" is not a member of \"(Debugger_Demo.FruitList) self.fruitList”\n\n\nEvaluate an expression and print the result in the console with the expression command, or the aliases expr or p.\n\n(lldb) p self.fruitList.calculatedFruitCount\n(Int) $R18 = 9\n(lldb) p fruitList.fruit(at: indexPath)\n(Debugger_Demo.FruitItem) $R20 = 0x00006000013dcc90 (fruitName = \"Strawberry\", fruitDescription = \"Small red berry with seeds on the outside.”)\n(lldb) expr fruit.fruitName\n(String) $R14 = \"Strawberry\"\n(lldb) p fruit.fruitName == \"Peach\"\n(Bool) $R16 = false\n\n\nThe p command compiles code to evaluate the expression, so it handles function calls and calculated variables. Use the references that p provides as parts of other expressions.\n\n(lldb) p fruit.fruitName\n(String) $R2 = \"Banana\"\n(lldb) p fruit.fruitName\n(String) $R6 = \"Strawberry\"\n(lldb) p $R2 + \", \" + $R6\n(String) $R8 = \"Banana, Strawberry\"\n\n\nFor some classes, using p may display only a memory pointer location, or may show a fully expanded view of all the attributes of the class, which can be a lot of unnecessary information. In those cases, use po, an alias for expression —object-description. This version also compiles code to evaluate the expression, but it prints an object description for the result, which you can customize for your objects.\n\n(lldb) po cell\n<Debugger_Demo.ListTableViewCell: 0x7fca3450e520; baseClass = UITableViewCell; frame = (0 28; 414 43.5); clipsToBounds = YES; layer = <CALayer: 0x600001d3ed40>>\n(lldb) po fruitList\nYummy Fruit: 9 items starting with Banana\n\n\nTip\n\nCustomize what the debugger shows for your objects by adding a debug description. In Swift, implement the CustomDebugStringProtocol for your object. For Objective-C objects that extend NSObject, override debugDescription.\n\nChange the value of a variable in memory while you are debugging with either p or po.\n\n(lldb) po fruitList.title = \"Tasty Fruit\"\n0 elements\n\n\n(lldb) po fruitList\nTasty Fruit: 9 items starting with Banana\n\n\nWhen you print an item that you declare using a protocol, p and po print an error because they don’t perform iterative dynamic type resolution. Use v to print variables when p or po print an error.\n\n(lldb) po fruitItem.fruitName\nerror: <EXPR>:3:11: error: value of type 'FruitDisplayProtocol' has no member 'fruitName'\nfruitItem.fruitName\n~~~~~~~~~ ^~~~~~~~~\n\n\n(lldb) v fruitItem.fruitName\n(String) fruitItem.fruitName = \"Apple\"\n\nSee Also\nBreakpoints and variables\nSetting breakpoints to pause your running app\nSpecify where your app pauses when running the debugger to investigate bugs."
  },
  {
    "title": "Metal debugger | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/metal-debugger",
    "html": "Overview\n\nThe Metal debugger consists of a suite of tools for debugging and profiling your Metal app.\n\nUnlike pausing at breakpoints during runtime, you can capture your Metal workload for multiple frames and then jump back and forth in time to explore the captured work. The Metal debugger enables you to explore the dependencies between passes, and offers insights for improving the performance of your app. You can also debug your shaders in draw commands and compute dispatches to fix sources of artifacts (see Investigating visual artifacts).\n\nIn addition, the Metal debugger displays your Metal workload on a profiling timeline and offers detailed statistics like performance counters and per-line shader profiling data. These tools can help you identify and eliminate performance bottlenecks in your app (see Optimizing GPU performance).\n\nFor additional information about the Metal debugger, see the following video sessions:\n\nMetal Shader Debugging and Profiling\n\nGain insights into your Metal app with Xcode 12\n\nOptimize Metal apps and games with GPU counters\n\nDiscover Metal debugging, profiling, and asset creation tools\n\nProfile and optimize your game’s memory\n\nTopics\nEssentials\nCapturing a Metal workload in Xcode\nAnalyze your app’s performance by configuring your project to leverage the Metal debugger.\nCapturing a Metal workload programmatically\nAnalyze your app’s performance by invoking Metal’s frame capture.\nReplaying a GPU trace file\nDebug and profile your app’s performance using a GPU trace file in the Metal debugger.\nInvestigating visual artifacts\nDiscover, diagnose, and fix visual artifacts in your app with the Metal debugger.\nOptimizing GPU performance\nFind and address performance bottlenecks using the Metal debugger.\nMetal workload analysis\nAnalyzing your Metal workload\nInvestigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.\nAnalyzing resource dependencies\nAvoid unnecessary work in your Metal app by understanding the relationships between resources.\nAnalyzing memory usage\nManage your Metal app’s memory usage by inspecting its resources.\nAnalyzing Apple GPU performance using a visual timeline\nLocate performance issues using the Performance timeline.\nAnalyzing Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands.\nAnalyzing non-Apple GPU performance using counter statistics\nOptimize performance by examining counters for individual passes and commands.\nMetal resource inspection\nInspecting acceleration structures\nReveal ray intersection bottlenecks by examining your acceleration structures.\nInspecting buffers\nConfirm your buffer formats by examining buffer content.\nInspecting pipeline states\nDetermine how your render and compute passes behave by examining their properties.\nInspecting sampler states\nVerify your sampler state configurations by examining their properties.\nInspecting shaders\nImprove your app’s shader performance by examining and editing your shaders.\nInspecting textures\nDiscover issues in your textures by examining their content.\nMetal command analysis\nInspecting the bound resources for a command\nDiscover issues by examining the bound resources at any point in an encoder.\nInspecting the geometry of a draw command\nFind problems in your app’s vertex, object, or mesh function by examining the current geometry.\nInspecting the attachments of a draw command\nDiscover attachment issues by inspecting individual pixels and samples.\nDebugging the shaders within a draw command or compute dispatch\nIdentify and fix problematic shaders in your app using the shader debugger.\nAnalyzing draw command and compute dispatch performance with GPU counters\nIdentify issues within your frame capture by examining performance counters.\nAnalyzing draw command and compute dispatch performance with pipeline statistics\nIdentify issues within your frame capture by examining pipeline statistics.\nSee Also\nGraphics\nMetal developer workflows\nLocate and fix issues related to your app’s use of the Metal API and GPU functions."
  },
  {
    "title": "Writing documentation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/writing-documentation",
    "html": "Overview\n\nThe DocC documentation compiler converts Markdown-based text into rich documentation for Swift and Objective-C frameworks, packages, and apps to display in Xcode’s documentation window or host on a website.\n\nDocC syntax — called documentation markup — is a custom variant of Markdown that adds functionality for developer documentation-specific features, like cross-symbol linking, term-definition lists, code listings, and asides. You add documentation markup to your source code, use Xcode’s Build Documentation feature to compile it with DocC, and produce reference documentation for your APIs. You can also use documentation markup, along with a set of directives that instruct how DocC generates your content, to offer step-by-step tutorials that teach developers to use your APIs through interactive coding exercises.\n\nFor a deeper understanding of DocC and guidance on its usage, please consult the DocC documentation available at DocC Swift.org.\n\nTopics\nEssentials\nDocumenting apps, frameworks, and packages\nCreate developer documentation from in-source comments, add articles with code snippets, and add tutorials for a guided learning experience.\nDocumentation content\nWriting symbol documentation in your source files\nAdd reference documentation to your symbols that explains how to use them.\nAdding supplemental content to a documentation catalog\nInclude articles and extension files to extend your source documentation comments or provide supporting conceptual content.\nSlothCreator: Building DocC Documentation in Xcode\nBuild DocC documentation for a Swift package that contains a DocC Catalog.\nStructure and formatting\nAdding structure to your documentation pages\nMake symbols easier to find by arranging them into groups and collections.\nDistribution\nDistributing documentation to external developers\nShare your documentation directly with Xcode users or host it on a web server."
  },
  {
    "title": "Metal developer workflows | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/metal-developer-workflows",
    "html": "Overview\n\nMetal comes with a comprehensive suite of advanced developer tools to help you debug and optimize your Metal apps.\n\nRuntime diagnostics\n\nYou can enable API Validation when running your app to check for incorrect Metal API usage. For more information, see Validating your app’s Metal API usage.\n\nEnable Shader Validation when running your app to check for issues like out-of-bounds memory access, missing useResource calls, and stack overflows. For more information, see Validating your app’s Metal shader usage.\n\nThe Metal Performance HUD offers a visual overlay to catch performance issues while your app is running. For more information, see Monitoring your Metal app’s graphics performance.\n\nRuntime performance analysis\n\nThe Metal system trace tool in Instruments provides a visual timeline of the parallel work on the CPU and the GPU, and the memory usage of your Metal app.\n\nYou can begin profiling with the Game Performance template (see Analyzing the performance of your Metal app) or the Game Memory template (see Analyzing the memory usage of your Metal app).\n\nAdvanced Metal debugging and profiling\n\nThe Metal debugger in Xcode provides advanced tools for debugging and profiling your Metal app.\n\nYou can get summaries of your Metal workload with the Dependencies viewer and the Memory viewer, inspect individual resources, and selectively debug your shaders. For more information on debugging, see Investigating visual artifacts.\n\nIn addition, you can optimize your Metal app by drilling down performance bottlenecks with the Performance timeline and the per-line shader profiling results. For more information on profiling, see Optimizing GPU performance.\n\nLearn more about Metal debugger.\n\nTopics\nProject preparation for debugging\nMake your Metal app easier to debug by taking a few extra steps as you develop your code.\nBuilding your project with embedded shader sources\nPrepare to debug your project’s shaders by including source code in the build.\nNaming resources and commands\nEnhance the debugging of your Metal app using labels and grouping.\nCreating and using custom capture scopes\nCapture specific GPU commands by using custom capture scopes.\nRuntime diagnostics\nLearn how to use runtime tools to discover potential issues in your Metal app.\nInspecting live resources at runtime\nValidate your resources by viewing the contents of your textures and buffers while debugging your Metal app.\nValidating your app’s Metal API usage\nCatch runtime issues in your Metal app using API Validation.\nValidating your app’s Metal shader usage\nCatch common shader runtime issues using Shader Validation while your app is running.\nMonitoring your Metal app’s graphics performance\nCatch performance issues using the Metal Performance HUD while your app is running.\nCounters\nGet references for the set of performance metrics available across Metal tools.\nFinding your Metal app’s GPU occupancy\nUnderstand the GPU usage for executing shaders by using occupancy.\nReducing shader bottlenecks\nIdentify and minimize congestion points in a GPU’s subsystems by checking its limiter and utilization counters.\nMeasuring the GPU’s use of memory bandwidth\nCheck whether your Metal app correctly reads and writes to memory by measuring the GPU’s memory bandwidth.\nSee Also\nGraphics\nMetal debugger\nDebug and profile your Metal workload with a GPU trace."
  },
  {
    "title": "Detecting when your app contacts domains that may be profiling users | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/detecting-when-your-app-contacts-domains-that-may-be-profiling-users",
    "html": "Overview\n\nThe operating system maintains a list of DNS domains that may be following people across multiple apps and websites to combine their activity into a profile. Use Instruments to discover whether your app contacts these domains — because of code you wrote or code that’s included in a third-party SDK your app links to — so that you can assess whether the domains are used for tracking as defined under the App Tracking Transparency framework. For more information, see User Privacy and Data Use.\n\nAnalyze your app’s networking behavior\n\nXcode and Instruments provide the tools you need to analyze your app’s network connections. In particular, you use Instruments to record HTTP traffic to and from your app, and the later analyze that for any unexpected activity. Follow these steps:\n\nOpen your app project in Xcode.\n\nChoose Product > Profile. Xcode builds your app for profiling, and opens it in Instruments.\n\nIn Instruments, choose the Network template.\n\nClick Record.\n\nInstruments presents an alert, warning you that recording HTTP traffic may expose sensitive and personal information. If you accept this risk, click Record Anyway. Instruments launches your app, and begins profiling.\n\nExercise the features of your app.\n\nWhen you’re done, switch back to Instruments and click Stop.\n\nReview your app’s connections to domains that may be profiling users\n\nWhen your app makes an HTTP request to a domain on the operating system list of DNS domains that may be following people across multiple apps and websites to combine their activity into a profile, the Points of Interest instrument records the activity. A fault pin in the Points on Interest track in the timeline shows when your app made a request to the domain.\n\nIn Instruments, select the Points of Interest track. The Detail area shows a list of the occasions when your app made HTTP requests to these domains. Select the entry in the Start column for a point of interest to move the tracking head to that time. Instruments focuses on the time your app made the HTTP request, so you can explore other tracks to learn more about your app’s behavior when it made the request. For more information on using Instruments to analyze HTTP traffic, see Analyzing HTTP traffic with Instruments.\n\nDeclare tracking domains in your app’s privacy manifest\n\nIf you determine that the domains your app connects to are using data sent from your app to track people, declare them in your privacy manifest and ask for permission to track under the App Tracking Transparency framework. For more information, see User Privacy and Data Use. The operating system blocks network requests to declared tracking domains when the user has not granted tracking permission.\n\nIf you are not expecting your app to track, consider removing the code or contacting the third-party SDK developer whose code is contacting the domain. If the third-party SDK has a privacy manifest, the manifest may also provide you with details about whether the third-party SDK is engaged in tracking. For more information, see Describing data use in privacy manifests.\n\nSee Also\nDebugging strategies\nDiagnosing issues in the appearance of a running app\nInspect your running app to investigate issues in the appearance and placement of the content it displays.\nDiagnosing memory, thread, and crash issues early\nIdentify runtime crashes and undefined behaviors in your app during testing using Xcode’s sanitizer tools."
  },
  {
    "title": "Choosing localization regions and scripts | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/choosing-localization-regions-and-scripts",
    "html": "Overview\n\nWhen you localize your app, you add localizations by choosing a language, and then, optionally, a region and script from Xcode’s menus. Apple recommends that you choose the most specific localization, not just the language. For example, if you only support English and it is American English, choose English (United States) (en-US) instead of English (en).\n\nIn Xcode menus, you choose a human-readable name for a localization, but in the project and exported files, a language identifier understood by localizers specifies the language, region, and script. The Xcode Localization Catalog (a folder with a .xcloc file extension) uses the language identifier as the suffix, as in en.xcloc and de.xcloc for the English and German catalog names, respectively.\n\nFor information about how the Bundle object finds the best match between the localizations your app supports and the user’s language and region settings, see Bundle.\n\nUnderstand the language identifier\n\nA language identifier is a compound syntax that represents a combination of a language, regional variant, and script. It contains a language code, and, optionally, a region code, and a script code.\n\nFor a language used in many regions, use just the language code that represents the language ([language code]). For example, to specify Serbian, use the sr language code. Use the two-letter ISO 639-1 standard (preferred) or, if no code is available for a particular language, use the ISO 639-2 standard instead.\n\nTo distinguish between different languages and regional variants, use a language code with a region code separated by hyphens ([language code]-[region code]). A region code represents a country or region. Use the ISO 3166-1 standard, a two-letter, capitalized code, such as, US, GB, AU, and FR. For example, to specify the Swiss variant of the German language, use de-CH. If it’s not possible to create a language identifier using the ISO 3166-1 standard, use the United Nations M.49 standard, which is a numeric code.\n\nTo specify a script, combine a language code with a script code in the ISO 3166-1 standard, separated by a hyphen ([language code]-[script code]), as in az-Cyrl for Azerbaijani in the Cyrillic script. To represent Chinese spoken in Taiwan and written in traditional Chinese script, use zh-Hant-TW.\n\nThis table shows some common language identifiers with their language, region, and script codes:\n\nSyntax\n\n\t\n\nDescription\n\n\t\n\nExamples\n\n\n\n\n[language code]\n\n\t\n\nSpecifies a language only\n\n\t\n\nen for English\n\n\n\n\n\t\n\n\t\n\nfr for French\n\n\n\n\n\t\n\n\t\n\nde for German\n\n\n\n\n[language code]-[region code]\n\n\t\n\nSpecifies a regional variant of a language\n\n\t\n\nen-AU for English in Australia\n\n\n\n\n\t\n\n\t\n\nen-GB for English in United Kingdom\n\n\n\n\n\t\n\n\t\n\nfr-FR for French in France\n\n\n\n\n\t\n\n\t\n\nfr-CA for French in Canada\n\n\n\n\n\t\n\n\t\n\nde-AT for German in Austria\n\n\n\n\n\t\n\n\t\n\nde-CH for German in Switzerland\n\n\n\n\n[language code]-[script code]\n\n\t\n\nSpecifies a script of a language\n\n\t\n\naz-Cyrl for Azerbaijani in the Cyrillic script\n\n\n\n\n\t\n\n\t\n\nsr-Latn for Serbian in the Latin script\n\n\n\n\n\t\n\n\t\n\nuz-Cyrl for Uzbek in the Cyrillic script\n\n\n\n\n\t\n\n\t\n\nzh-Hans for Chinese in the simplified script\n\n\n\n\n\t\n\n\t\n\nzh-Hant for Chinese in the traditional script\n\nSee Also\nLanguages and regions\nAdding support for languages and regions\nSelect the resources that you want to localize for each language and region you support."
  },
  {
    "title": "Editing XLIFF and string catalog files | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/editing-xliff-and-string-catalog-files",
    "html": "Overview\n\nAfter you export localizations, you can give the Xcode Localization Catalog to localizers for translation, or edit the XLIFF files located in the Localized Contents folder yourself.\n\nAdd translations to XLIFF files\n\nTo find the user-facing strings that need translation, including the app name, search for the <trans-unit> element in the XLIFF file. To insert a translation of a string, add a <target> element to the <trans-unit> element containing the localized text as in:\n\n<trans-unit id=\"Hello, world!\" xml:space=\"preserve\">\n        <source>Hello, world!</source>\n        <target>Hallo, Welt!</target>\n        <note>A friendly greeting.</note>\n</trans-unit>\n\nGroup related strings using tables\n\nIf you specify a table name when you internationalize your code — in other words, if you use the Text init(_:tableName:bundle:comment:) method or the NSLocalizedString(_:tableName:bundle:value:comment:) function with the tableName parameter — Xcode groups the strings into separate <file> elements with [table name].strings as the filename. If you don’t specify a table name, Xcode uses the default Localizable.strings as the filename.\n\nWhen you import the localizations, Xcode adds a version of the strings file for each localization to your project. In the following SwiftUI code listing, the first Text string appears in the default Localized.strings file while the Button label that specifies a table name appears in the Buttons.strings file:\n\nVStack {\n    Text(\"Hello, world!\", comment:\"A friendly greeting.\")\n        .font(.largeTitle)\n        .padding()\n    Button(action: pushMe){\n        Text(\"Push Me\", tableName:\"Buttons\", comment:\"Push Me button label.\")\n    }\n    .font(.title)\n}\n\nEdit string catalogs in Xcode\n\nAfter you import localizations, you can edit the string catalog file in your project and the next time you export localizations, Xcode includes your changes in the XLIFF files.\n\nFor more information about editing string catalogs in Xcode, see Localizing and varying text with a string catalog.\n\nSee Also\nTranslation and adaptation\nCreating screenshots of your app for localizers\nShare screenshots of your app with localizers to provide context for translation.\nExporting localizations\nProvide the localizable files from your project to localizers.\nImporting localizations\nImport the files that you translate or adapt for a language and region into your project.\nLocking views in storyboard and XIB files\nPrevent changes to your Interface Builder files while localizing human-facing strings."
  },
  {
    "title": "Localizing assets in a catalog | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/localizing-assets-in-a-catalog",
    "html": "Overview\n\nYou use asset catalogs to organize and manage different types of assets, such as images, sprites, textures, stickers, and data. Most types of assets can have multiple variations to support different device characteristics, including variations for the language and region settings.\n\nYou can localize certain types of asset catalogs and add localized versions of those assets directly to the catalog in Xcode.\n\nThe localizable asset types include:\n\nColor sets\n\nImage sets\n\nSymbol sets\n\nWatch complications\n\nApple TV image stacks\n\nSprite atlases\n\nAdd asset catalogs to localizations\n\nIn the Project navigator, select the asset catalog, then select the asset you want to localize in the outline view of the editor area. Under Localization in the Attributes inspector, click Localize. Select the localizations you want to add the asset to. Xcode displays corresponding placeholder spaces in the editor area.\n\nEither drop the localized assets in the spaces for localizations, or export the localizations and let the localizers add the assets later.\n\nSee Also\nResources and assets\nAdding resources to localizations\nInclude more resources in the localizations you add to your project."
  },
  {
    "title": "Locking views in storyboard and XIB files | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/locking-views-in-storyboard-and-xib-files",
    "html": "Overview\n\nBefore you export localizations, optionally lock the views in your storyboard and XIB files so you don’t inadvertently change localizable properties while you’re waiting for translations. Use this feature if you want to continue developing your app and avoid conflicts when importing localizations later. You can choose a locking level that controls the set of editable properties for each view.\n\nLock views\n\nYou can set the locking level for a single view or for the entire user interface file. By default, views inherit their lock attribute from their parent view, and top-level views inherit their lock attribute from the user interface file. If you set a view’s lock attribute, it sets the lock attribute for all its descendant views.\n\nTo lock a single view, select the user interface file (files with a .storyboard or .xib filename extension) in the Project navigator, then select the view in Interface Builder. In the Identity inspector, choose a locking level from the Lock pop-up menu under Document:\n\nInherited - ([locking level])\n\nUse the parent view’s locking level.\n\nNothing\n\nDon’t lock any properties (make all properties editable).\n\nAll Properties\n\nLock all properties.\n\nLocalizable Properties\n\nLock localizable properties, such as user-facing text and size.\n\nNon-localizable Properties\n\nLock non-localizable properties (make user-facing text and size properties editable).\n\nFor example, choose Localizable Properties while waiting for translations from localizers. If you import localizations and don’t want to make other changes inadvertently, choose Non-localizable Properties.\n\nTo lock all views, select the user interface file in the Project navigator, then choose a locking level from the Editor > Localization Locking menu.\n\nUnlock views\n\nTo unlock all views after you import localizations, select the user interface file in the Project navigator, then choose Editor > Localization Locking > Reset Locking Controls. To prevent any edits in a user interface file that would impact localized strings files, choose Editor > Localization Locking > Reset Locking Controls and then choose Editor > Localization Locking > Localizable Properties.\n\nSee Also\nTranslation and adaptation\nCreating screenshots of your app for localizers\nShare screenshots of your app with localizers to provide context for translation.\nExporting localizations\nProvide the localizable files from your project to localizers.\nEditing XLIFF and string catalog files\nTranslate or adapt the localizable files for a language and region that you export from your project.\nImporting localizations\nImport the files that you translate or adapt for a language and region into your project."
  },
  {
    "title": "Diagnosing issues in the appearance of a running app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/diagnosing-issues-in-the-appearance-of-your-running-app",
    "html": "Overview\n\nAt times your app’s content may appear to be missing, out of place, or have an appearance that is incorrect. To identify and diagnose the cause of these issues, attach the debugger, reproduce the error, and then narrow down its root cause by inspecting changes in your interface, the code that is executing, and the state of variables. If you configure a scheme’s run action for debugging by using the Debug executable checkbox in Info settings, the app will attach to the debugger automatically when the app uses the scheme. To attach the debugger to a process that is already running, choose Debug → Attach to Process, and select your app’s process from the list.\n\nTemporarily override system settings to control your app’s appearance and reveal problems that only occur when these settings are in effect, understand layout issues by visualize your views in stacked layers, and debug content in immersive space by adding visual overlays.\n\nAdjust system configurations to identify their impact on your views\n\nSome visual issues only arise when you configure the system using specific environmental settings. Xcode provides environmental overrides when targeting iOS, macOS, and tvOS apps to help you debug these issue. Use these environmental overrides to change the interface style, dynamic text size, and to induce the effects of other accessibility options, so you can understand the effect of these changes on the layout and visual appearance of your views.\n\nTo enable one or more of these overrides, click the Enable Overrides button on Xcode’s debugging toolbar, toggle the switch next to the override category, and configure the controls under the category heading.\n\nAppearance\n\nView your app’s content with a light or dark appearance. Select between light and dark appearances using the radio button.\n\nDynamic Type\n\nView your app’s content using different dynamic type sizes. Select the size using the slider. For more information on dynamic types, see DynamicTypeSize.\n\nAccessibility\n\nView the effects various accessibility features have on your app’s content. Click the checkboxes to enable or disable the accessibility features.\n\nResolve issues in the layout of your UIKit and SwiftUI views\n\nUse the View debugger, available when targeting iOS, macOS, tvOS, and watchOS apps, to diagnose the reasons an item in your user interface is in the wrong position or is the wrong size. Set a breakpoint in your app after it presents the view, for example, in a viewDidAppear: method, then click the View Debugger button in the debug bar when the debugger pauses on your breakpoint. Alternatively, just click the View Debugger button after your app presents the view.\n\nThe debugger displays a 3D rendering of the current view on the canvas in the center, with a representation of the view hierarchy in the Debug navigator. Drag the view in any direction to see a 3D representation of the current view stack, and use the controls at the bottom of the canvas to adjust the views and the spacing between them.\n\nClick to select a view in either the visual rendering or the view hierarchy in the Debug navigator, then inspect details in the Object inspector or Size inspector. Resolve your layout issue according to the type of layout:\n\nFrame-based layouts\n\nThe view debugger shows the frames you specify in the Size inspector. If the size isn’t what you expect, step through your code to diagnose issues with your frame calculations. Then fix and retest.\n\nViews using Auto Layout\n\nThe Size inspector shows constraints. Click a constraint to highlight it in the view debugger. Analyze the constraints that affect the misplaced or mis-sized view to diagnose the issue. Adjust your constraints, either in your code or in Interface Builder, and retest.\n\nViews built with SwiftUI\n\nThe Size inspector shows how SwiftUI resolves the size and placement of your view. With that information, analyze and adjust your SwiftUI code and retest.\n\nUnderstand the relationships between objects in a immersive space\n\nFor visionOS apps with content in an immersive space, it’s often helpful to see a visual representation of coordinate axes, bounding boxes, and other information that is normally invisible. Xcode’s debugging tools include options to display this information in Simulator or on a device. Use them to ensure that your entities are located where you expect, and interacting with each other and the surroundings the way you anticipate. For example, if an entity isn’t responding to events, enable Collision Shapes to confirm the presence of one, required for event handling, and indicate its boundary.\n\nTo annotate your content with an overlay, click the Enable Visualizations button on Xcode’s debugging toolbar and select one or more of the options:\n\nAxes\n\nRed, green and blue arrows indicating the x, y, and z axes of each object in the space. Use this to understand the orientation of each object.\n\nBounds\n\nGreen lines that indicate the bounding edge of each entity.\n\nOrigin\n\nA dot marking the the origin of each object.\n\nAnchoring\n\nRed, green and blue arrows indicating the x, y, and z axes of each anchor point and a yellow line betwen entities and their anchors. Use this to understand the placement of entities in relation to other real-world objects in the space.\n\nCollision Shapes\n\nA white outline around the collision shape of an entity. Use this to understand issues in event detection.\n\nOcclusion Mesh\n\nA multi-colored wireframe around real objects in the space. Use this to identify areas where virtual objects are correctly or incorrectly being hidden behind real objects.\n\nSurfaces\n\nWhite border lines and diagonals marking each surface. Use this to understand the borders of surfaces that the system detects.\n\nSee Also\nDebugging strategies\nDiagnosing memory, thread, and crash issues early\nIdentify runtime crashes and undefined behaviors in your app during testing using Xcode’s sanitizer tools.\nDetecting when your app contacts domains that may be profiling users\nUse Instruments to assess whether your app or its third-party SDKs connect to domains that may profile users."
  },
  {
    "title": "Diagnosing and resolving bugs in your running app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/diagnosing-and-resolving-bugs-in-your-running-app",
    "html": "Overview\n\nUnit testing determines whether your code delivers results that meet your expectations, but it doesn’t explain the cause when it doesn’t. To diagnose an error, attach the debugger, reproduce the error, and then narrow down its root cause by inspecting your variables at key points in your code while the app is running with breakpoints. If you configure a scheme’s run action for debugging by using the Debug executable checkbox in Info settings, the app will attach to the debugger automatically when the app uses the scheme. To attach the debugger to a process that is already running, choose Debug → Attach to Process, and select your app’s process from the list. Follow this same process to diagnose and resolve errors in your code, crashes, memory leaks, and layout problems.\n\nPause the app to inspect variables and isolate bugs\n\nTo fix a bug, you first need to understand what is causing it. To narrow down the cause of a bug, develop a set of steps to reliably reproduce it:\n\nDetermine where the bug happens in your source code.\n\nPause your app with a breakpoint in your source code before the point at which you believe the bug occurs.\n\nLook at your variables and confirm they have the values you expect. If they don’t, begin again with step 1.\n\nStep through your code and watch your variables change. Note where your variables have unexpected values.\n\nAnalyze your code to determine a fix.\n\nAfter determining a potential fix for the bug, confirm the diagnosis by changing your code and retesting to reproduce it. If the change addresses the problem, you’ve resolved the bug. If your change doesn’t resolve it, reconsider where the bug might be occurring, and repeat the steps to isolate and fix it.\n\nFor more information on setting breakpoints and inspecting variables, see Setting breakpoints to pause your running app and Stepping through code and inspecting variables to isolate bugs.\n\nLocate crashes, exceptions, and runtime issues\n\nWhen your app experiences a crash, exception, or runtime issue, it can be challenging to pinpoint the code causing the problem because the stack trace for the crash doesn’t always point to the line of code that causes the crash. Use the rubric below to identify the problem characteristics and then set the correct type of breakpoint:\n\nA crash that stops at main or highlights AppDelegate is frequently an Objective-C exception.\n\nA crash that is the result of a runtime issue also stops at main or highlights AppDelegate, and may have a message similar to: “Thread 8: EXC_BAD_INSTRUCTION (code=…)”.\n\nA crash that stops at an uncaught or unhandled Swift error displays a fatal error message and indicates a Swift error.\n\nAdd a breakpoint to your code in a location based on problem characteristics, then when your app stops at the breakpoint, check the state of the code execution. For more information on setting breakpoints and identifying crashes, see Setting breakpoints to pause your running app and Identifying the cause of common crashes.\n\nNote\n\nYour Swift code can receive an Objective-C exception when it uses code from a module that uses Objective-C.\n\nInspect variables and execution sequence without pausing\n\nWhen you develop code, it’s helpful to log actions and variable values so you understand how your code runs and what values your variables have at different points in your app. This is especially true when you develop concurrent code, or code that executes simultaneously across multiple queues or threads, because bugs can be intermittent and difficult to reproduce. Often, you reproduce a bug in normal execution, but not when stepping through the debugger, because the timing is different between normal execution and debugging. The debugger provides tools to inspect variables without pausing and disturbing the timing of your concurrent code.\n\nDevelopers commonly add print or NSLog statements to see variable values. While this technique works, it adds extra code that isn’t useful after you finish development, and leaves your app with a noisy console that makes diagnosing subsequent bugs more difficult. Instead, use breakpoint actions to know when events in your app take place, and inspect variable values without pausing.\n\nTo determine whether your code executes with minimal effect to timing, use a breakpoint action to play a sound and continue executing. If the debugger reaches the breakpoint when you run the app, it plays the sound and confirms execution.\n\nTo log a variable value to the console without pausing, add a breakpoint with a Debugger Command action using po to print out the evaluation of an object, or v to print the value of a variable to the console. Select the Automatically continue after evaluating actions option for the breakpoint to prevent pausing.\n\nTo log custom text to the console and add context to variable values, add a breakpoint with a Log Message action. Specify your custom text, and include expressions, the breakpoint name, or the breakpoint hit count to provide more information.\n\nNote\n\nBecause po compiles code dynamically to evaluate expressions, it takes more time to evaluate your variable and log it to the console. To reduce timing issues, use v to log variable values instead.\n\nUse other breakpoint actions to execute an AppleScript or a shell script, or to capture a GPU frame.\n\nFor more information on inspecting variables, see Setting breakpoints to pause your running app and Stepping through code and inspecting variables to isolate bugs.\n\nIdentify potential overuse of CPU and memory\n\nAn easily overlooked and common problem in development and testing is the overuse of CPU and memory. Xcode’s debugger provides gauges in the Debug navigator to help investigate potential problems. Monitor the gauges while you’re testing your app to uncover unusual usage. Click a gauge for a more detailed view.\n\nThe CPU gauge shows the amount of CPU the app requires to process instructions over time. When your app is drawing the user interface, processing data it retrieves from the network, or performing calculations, it‘s normal to see CPU usage increase to fairly high numbers for a short period of time. When those tasks are complete and your app is idle and waiting for the user to perform an action, CPU usage should be zero or very low. Do additional analysis if CPU usage is:\n\nPersistent at a level above zero when the app appears to be idle.\n\nOver 100% for more than very short periods of time.\n\nVery high and you see hitches in your user interface.\n\nFor more information on improving performance, see Improving your app’s performance.\n\nThe Memory gauge shows how much memory your app uses over time. It starts at a fairly small number, less than 10 MB, when you first launch your app, and then increases as people navigate through your user interface. It may also increase if you fetch, process, and store data from the network, or perform complex calculations. It then decreases when processing is complete. Watch the gauge as you navigate through your app, and note when memory usage goes up and down. Memory usage increases when you present modal views or add a view to a navigation controller, and decreases when you dismiss or navigate away from those views. If your usage continues to increase and doesn’t ever decrease, investigate whether you have a memory leak or abandoned memory. For more information on reducing memory use and resolving memory leaks, see the section below Visualize and diagnose increasing memory usage and Reducing your app’s memory use.\n\nDetect high disk access and network use\n\nBe aware of issues resulting from frequent access to resources on disk and over the network. You can monitor these resources using the gauges in Xcode’s debugger as well. The Disk I/O gauge shows how much data your app reads and writes from disk over time. The gauge shows if you:\n\nStore data that the user generates in your app.\n\nStore data in user preferences.\n\nFetch data from the network and store it.\n\nRead data from your app bundle or the app’s directories.\n\nStoring and reading data frequently from disk uses more power than doing so from memory, and it adds wear and tear to the user’s device. To know whether disk usage is unusual, you need to understand the size of data you’re storing and reading, and compare that to what you observe in the gauge. For example, if you download and store a 5 MB graphic file for display in a view that you use frequently and it writes over 50 MB of data, investigate whether the remote image changes frequently, or whether you need to configure networking to prevent redownloading the same image. If you’re reading more data from disk than you expect, investigate whether a memory-caching solution might help, or whether you’re initiating a data read from the wrong point in your app or view life cycle, and reading it too often. For more information on reducing disk writes, see Reducing disk writes.\n\nThe Network I/O gauge shows how much data your app reads from and writes to the network over time. If your app only uses local resources, your app may not read or write any data from the network. Communicating data over the network uses energy and reduces the device’s battery life, so minimize data transfer wherever possible. To understand your app’s network usage, watch the Network I/O gauge when your app is sending or receiving data from the network. For example, if you implement a cache system for downloaded images and your network usage increases when accessing them, confirm that your cache settings are correct in the app and on the server. If you’re uploading user-generated content and frequent upload failures during poor networking conditions lead to high network usage, implement a system to recover and restart failed uploads at the point of failure, rather than reuploading the entire file.\n\nVisualize and diagnose increasing memory usage\n\nDiagnose the cause of memory leaks and abandoned memory with the memory graph. The observable symptom of a memory leak is memory usage that continues to increase over time, even when conditions in the app indicate that memory usage is decreasing. A memory leak can occur in a retain cycle, which is when objects maintain strong references to each other, but the app no longer references them. These objects remain in memory and the app can’t remove them. Abandoned memory occurs when you create objects and your code still references them, but your app no longer needs them or uses them.\n\nTo see the memory graph in the debugger, pause your app at a breakpoint and click the Debug Memory Graph button in the debug bar. Alternatively, click the Debug Memory Graph button when the app is running to pause the app and show the memory graph.\n\nThe memory graph view replaces the stack trace in the Debug navigator with a list of types, organized by library, each with a list of instances called nodes. Select a node to view its memory graph.\n\nA node’s memory graph shows all the memory references to that node, and highlights strong references. Control-click any node in the graph to perform more actions, such as accessing Quick Look or printing the description to the console. Choose Focus on Node to show the graph for the selected node. Click a reference to see its details, including the name of the variable, the type of reference, and the source and destination objects in memory.\n\nTo resolve a memory leak for a retain cycle:\n\nObserve the Memory gauge while you navigate the app.\n\nNote when memory usage increases when your app instantiates an object, but doesn’t decrease when you expect the system to deallocate the object.\n\nExamine the memory graph to see if there are an unexpected number of instances of the object or inappropriate strong references to it.\n\nIf there is a strong reference to the object, Control-click the node with the strong reference and choose Focus on Node to view its graph. If the node also has a strong reference from the object, this is a retain cycle.\n\nResolve the retain cycle by changing one side of the relationship to use a weak declaration for the reference to the other object, or remove the reference altogether by removing any dependencies on the other object. Retest to confirm that the change fixes the issue.\n\nTo resolve abandoned memory issues, identify the time in your app’s life cycle that it no longer needs the abandoned object and remove any references to it.\n\nInspect and resolve appearance and layout issues\n\nSome issues in the appearance or layout of your app only appear when you configure the system with a particular interface style, dynamic text size or when your app uses particular accessibility features. Use environmental overrides when targeting iOS, macOS, and tvOS apps to test your interface in these environments. To understand issues that involve the position or size of your view, you might need to inspect them within the context of views in other layers. Use the view debugger when targeting iOS, macOS, tvOS, and watchOS apps, which displays a 3D representation of the view hierarchy in layers, to help diagnose these issue. Entities within a visionOS app and their surroundings sometimes interact with each other in ways you don’t expect. Enable visualizations to represent coordinate axes, bounding boxes, and other information that is normally invisible, to help understand these interactions.\n\nFor information on using these features to debug the appearance of your app, see Diagnosing issues in the appearance of a running app."
  },
  {
    "title": "Identifying and addressing framework module issues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/identifying-and-addressing-framework-module-issues",
    "html": "Overview\n\nWhen you create a framework containing Objective-C, Objective-C++, C, or C++ code that you distribute to customers, clients, or other developers, it’s often challenging and time-consuming to find problems in your framework that don’t appear at build time.\n\nIn Xcode version 14.3 or later, enable the module verifier in your Xcode project’s build settings so that you can identify and address problems with your framework module before you distribute it.\n\nSome examples of these problems include:\n\nMissing header references in your umbrella header\n\nUsing quoted includes instead of angle-bracketed includes\n\nUsing @import syntax in your public and private headers\n\nIncorrect target conditionals\n\nImports inside of extern \"C\" language linkage specification\n\nNon-modular headers in your umbrella header\n\nReferences to private headers from public headers\n\nWhen you enable the module verifier, it finds module problems in your code and displays errors for them in Xcode’s Issue navigator, just like compiler errors or warnings.\n\nEnable the module verifier build setting\n\nIn your Xcode project, select your framework’s target, then select the Build Settings tab. Scroll down to the Apple Clang Module Verifier section. For new projects created in Xcode 14.3 or later, the Enable Module Verifier setting defaults to Yes. For projects you created in earlier versions of Xcode, change the setting to Yes.\n\nThen, check the values for Supported Languages and Supported Language Dialects, and update them to match your project’s requirements. View Quick Help for each setting to find valid values.\n\nFor more information about configuring build settings, see Configuring the build settings of a target.\n\nBuild your project and identify issues\n\nIn Xcode, build your project, then show the Issue navigator to see issues in your project. Module verifier issues show up as errors in the Issue navigator.\n\nReview the issues, then click on an issue to highlight it in your source code.\n\nAddress common issues\n\nIdentify each issue you find by matching it with an example error message in the following table. Then, use the error resolution examples to help you address the issue in your code.\n\nError message\n\n\t\n\nError resolution\n\n\n\n\numbrella header for module ‘ExampleModule’ does not include header ‘MyObject.h’\n\n\t\n\nAdd missing headers to your umbrella header. Include the missing header like so: #import <ExampleModule/MyObject.h>.\n\n\n\n\ndouble-quoted include “MyObject.h” in framework header, expected angle-bracketed instead\n\n\t\n\nReplace quoted includes with angle-bracketed includes. Change #import \"MyObject.h\" to #import <ExampleModule/MyObject.h>.\n\n\n\n\nuse of ‘@import’ in framework header is discouraged, including this header requires -fmodules\n\n\t\n\nAvoid the use of semantic import syntax in your public and private headers. Change @import Foundation; to #import <Foundation/Foundation.h>.\n\n\n\n\n‘TARGET_OS_IPHONE’ is not defined, evaluates to 0\n\n\t\n\nFix target conditionals. Add an include statement to your header that uses the target conditional: #include <TargetConditionals.h>. If that doesn’t fix the issue, check that the target conditional you use is defined in TargetConditionals.h.\n\n\n\n\nimport of C++ module ‘ExampleFramework.ExampleSource’ appears within extern “C” language linkage specification, or extern “C” language linkage specification begins here\n\n\t\n\nAvoid including imports inside of extern \"C\" language linkage specification. Move the include statement outside of the extern \"C\" scope. Don’t use the [extern_c] attribute in the module map.\n\n\n\n\ninclude of non-modular header inside framework module ‘ExampleModule’\n\n\t\n\nRemove the include statement from your header. The header you are trying to include is not modular so you can’t include it in your framework module. If possible, make that code modular so that you can include it in your framework module.\n\n\n\n\npublic framework header includes private framework header ‘ExampleModule/MyObject_Private.h’\n\n\t\n\nAvoid including references to private headers from public headers. Either make the private header public, or remove the private header include from the public header.\n\nSee Also\nBuild settings\nConfiguring the build settings of a target\nSpecify the options you use to compile, link, and produce a product from a target, and identify settings inherited from your project or the system.\nAdding a build configuration file to your project\nSpecify your project’s build settings in plain-text files, and supply different settings for debug and release builds.\nBuild settings reference\nA detailed list of individual Xcode build settings that control or change the way a target is built."
  },
  {
    "title": "Creating a multiplatform binary framework bundle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-a-multi-platform-binary-framework-bundle",
    "html": "Overview\n\nAn XCFramework bundle, or artifact, is a binary package created by Xcode that includes the frameworks and libraries necessary to build for multiple platforms (iOS, macOS, tvOS, and watchOS), including Simulator builds. The frameworks can be static or dynamic and also include headers.\n\nInclude an XCFramework bundle inside a Swift package to distribute code in binary form for use in other projects. For more information, see Distributing binary frameworks as Swift packages.\n\nRelated sessions from WWDC19\n\nSession 417: Binary Frameworks in Swift\n\nSet up the project\n\nTo set up your project for creating an XCFramework, ensure your Xcode project has a scheme that builds only the framework target and its dependencies.\n\nConfigure these build settings on your target:\n\nSet the Build Libraries for Distribution build setting to Yes. For Swift, this enables support for library evolution and generation of a module interface file.\n\nSet the Skip Install build setting to No. If enabled, the built products aren‘t included in the archives.\n\nLeave the Architectures build setting unset. The predefined value configures the target to build a universal binary for all the possible architectures the target platform uses.\n\nFor more information, see Customizing the build schemes for a project and Configuring the build settings of a target.\n\nCreate archives for frameworks or libraries\n\nCreate an archive of your framework or library for each platform you wish to support by running xcodebuild in Terminal using the archive build action.\n\nThe following command archives a framework for the iOS platform:\n\nxcodebuild archive \n    -project MyFramework.xcodeproj\n    -scheme MyFramework\n    -destination \"generic/platform=iOS\"\n    -archivePath \"archives/MyFramework\"\n\n\nThe system determines the architectures and SDK according to build settings when running the command with the -destination flag, like the example above. Avoid common errors by using this flag rather than -arch and -sdk.\n\nTo build an archive for a different platform, adjust the value for -destination. Replacing this value with \"generic/platform=iOS Simulator\" creates an archive for Simulator.\n\nAn XCFramework can contain versions of your framework built for macOS with and without Mac Catalyst. To generate an archive for the Mac Catalyst variant, use \"generic/platform=macOS,variant=Mac Catalyst\", adding the the variant type to the -destination value.\n\nTo see an extensive list of all the command options, execute xcodebuild with the -help flag.\n\nNote\n\nClients of your XCFramework need it to support all the possible architectures the platform uses. As platforms move forward to adopt new architectures, such as the adoption of Apple silicon by macOS and iOS Simulator, keep the binaries your XCFramework includes up to date by rebuilding the frameworks and libraries to include new architectures. To determine the architectures of a binary, see Determine the architectures a binary supports.\n\nGenerate the XCFramework bundle\n\nTo package the built content of a given framework or library for multiple platforms and variants into a single XCFramework bundle, execute xcodebuild with the -create-xcframework option.\n\nThe following command creates an XCFramework with variants for iOS, iOS Simulator, macOS, and Mac Catalyst:\n\nxcodebuild -create-xcframework\n    -archive archives/MyFramework-iOS.xcarchive -framework MyFramework.framework\n    -archive archives/MyFramework-iOS_Simulator.xcarchive -framework MyFramework.framework\n    -archive archives/MyFramework-macOS.xcarchive -framework MyFramework.framework\n    -archive archives/MyFramework-Mac_Catalyst.xcarchive -framework MyFramework.framework\n    -output xcframeworks/MyFramework.xcframework\n\n\nTo include a static library file (.a file), replace -framework with -library in the command above.\n\nIf the content you wish to include exists outside of an archive, provide paths for the instances of -framework or -library and include paths to headers using the additional -headers flag.\n\nxcodebuild -create-xcframework\n    -library products/iOS/usr/local/lib/libMyLibrary.a -headers products/iOS/usr/local/include\n    -library products/iOS_Simulator/usr/local/lib/libMyLibrary.a -headers products/iOS/usr/local/include\n    -library products/macOS/usr/local/lib/libMyLibrary.a -headers products/macOS/usr/local/include\n    -library products/Mac\\ Catalyst/usr/local/lib/libMyLibrary.a -headers products/Mac\\ Catalyst/usr/local/include\n    -output xcframeworks/MyLibrary.xcframework\n\n\nTo see all the options the XCFramework utility supports, execute:\n\nxcodebuild -create-xcframework -help\n\nSign the XCFramework bundle\n\nSigning your XCFramework using your code signing identity informs developers who use your framework that it came from you and that it hasn’t been tampered with since you added the signature. To sign your framework, run the following command:\n\n% codesign --timestamp -s <identity> xcframeworks/MyLibrary.xcframework\n\n\nTo sign a framework for distribution as a member of the Apple Developer Program, your code signing identity should be an Apple Distribution or Apple Development identity. To sign a framework for distribution as a member of an Enterprise Program, use an iOS Distribution or iOS App Development identity. You don’t need to supply the full name of your code signing identity after the -s option. Use a string that uniquely identifies the code signing identity in the keychain you use to sign the XCFramework. For more information on the codesign tool, see the UNIX manual page for codesign.\n\nImportant\n\nIf you revoke a certificate for a code signing identity that you use to sign frameworks for distribution, sign the framework with a different code signing identity that isn’t revoked and share that version with developers who use your framework. The Xcode build system fails with an error when it encounters a framework with a code signature that contains a revoked certificate.\n\nAvoid issues when using alternate build systems\n\nWhen using an alternative build system, common for open source projects, follow a similar process to compile the source code into static library files, using one binary per platform, or destination. Use the files to create the XCFramework.\n\nFor each library and each platform, build a binary static libary file (.a file) that includes slices for all the possible architectures the platform uses.\n\nSpecify the path to each of the binaries you create in a call to xcodebuild -create-xcframework to generate the XCFramework.\n\nAvoid wrapping a static library in a .framework bundle and omitting the .a extension. Use the -library flag to create an XCFramework with a static library; see the example above under Generate the XCFramework bundle.\n\nAvoid using tools such as lipo to combine architecture slices built for iOS and iOS Simulator into a single binary. The static library files for iOS and iOS Simulator must remain seperate. For an XCFramework that supports iOS and iOS Simulator, you produce at least two binary static library files. The binary iOS devices use is built for ARM64. The universal binary for Simulator includes slices for x86_64 and ARM64 for Apple silicon.\n\nAvoid using dynamic library files (.dylib files) for dynamic linking. An XCFramework can include dynamic library files, but only macOS supports these libraries for dynamic linking. Dynamic linking on iOS, watchOS, and tvOS requires the XCFramework to contain .framework bundles.\n\nIf you have further questions on how to compile the library to meet these goals, work with support for the library vendor.\n\nDetermine the architectures a binary supports\n\nProjects that link to your XCFramework require that it contains universal binaries covering the architectures each platform builds for.\n\nTo determine the architectures an existing binary includes, execute file from Terminal and provide the path to the binary.\n\nfile <PathToFramework>/<FrameworkName>.framework/<FrameworkName>\n\nfile <PathToLibrary>/libMyLibrary.a\n\nSee Also\nFrameworks\nIdentifying and addressing framework module issues\nDetect and fix common problems found in framework modules with the module verifier."
  },
  {
    "title": "Embedding nonstandard code structures in a bundle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/embedding-nonstandard-code-structures-in-a-bundle",
    "html": "Overview\n\nAll apps — and many non-app software products on the Mac, like plug-ins — are packaged in a bundle structure. When creating a bundle, place content in the correct location. Placing content in a nonstandard location can cause code signing and distribution problems. For more on this, see Placing Content in a Bundle.\n\nIn some cases you need to work with nonstandard code structures, that is, code whose structure doesn’t match the standard bundle structure for your platform. For example, you might be building a Mac app and want to embed an open source language runtime in it. If the on-disk layout of this runtime doesn’t follow the rules in Placing Content in a Bundle, you run the risk of code signing and distribution problems.\n\nThe best way to resolve this conundrum is to rebuild the code to match your target platform’s bundle structure. However, this isn’t always feasible:\n\nIt requires extensive knowledge of the code’s build system. If you’re not already familiar with that, you may spend a lot of time gaining that knowledge.\n\nIt only works if the product is open source.\n\nFortunately there’s another way. This document walks you through an example of how to embed a nonstandard code structure into your bundle without having to rebuild all the code. This example is for the Mac but the basic techniques work on all Apple platforms.\n\nImportant\n\nThis is just an example. It’s likely that the code you’re using will have a structure that’s different from this example. Adapt the techniques shown here to your specific situation.\n\nSeparate read-only and read/write content\n\nA bundle is a read-only structure. All Apple platforms except the Mac enforce this requirement at runtime. On iOS, for example, any attempt to modify your app’s bundle at runtime will fail with an error. The Mac may or may not enforce this requirement at runtime, depending on the context, but modifying your app’s bundle isn’t supported because it breaks the seal on the app’s code signature.\n\nCode structures with their origins on other platforms are not always compatible with this requirement. For example, the Python runtime writes bytecode files in the same directory in as the original Python source file. If, say, you have a file called WaffleVarnish.py, the runtime may write a file called WaffleVarnish.pyc (or WaffleVarnish.pyo) into that directory. This causes two problems:\n\nIf the platform blocks this write, you miss out on the performance benefits of these bytecode files.\n\nIf the platform does not block this write, the write breaks the seal on your app’s code signature.\n\nIf the code you’re using works this way, find a way to separate its read-only content, which you can safely place in your bundle, and its read/write content, which you can’t. The details are specific to the code in question, but this often involves setting a command-line argument or an environment variable that points to a writable location, for example, in the Library directory.\n\nInvestigate dynamic library linkage\n\nImagine you’re building a Mac app to varnish waffles and want to use the fabulous open source libWaffleVarnish code. Its build system outputs a directory structure like this:\n\nlibWaffleVarnish/\n  bin/\n    wafflevarnish\n  etc/\n    wafflevarnish.config\n  lib/\n    libVarnish.dylib\n    libWaffle.dylib\n\n\nThe wafflevarnish tool depends on both dynamic libraries. The libVarnish.dylib library depends on libWaffle.dylib. The wafflevarnish tool also reads the wafflevarnish.config configuration file.\n\nThe good news here is that libWaffleVarnish is structured in a way that makes it easy to relocate. The wafflevarnish tool sets up the rpath context via an executable relative path that leads to the lib directory:\n\n% otool -l libWaffleVarnish/bin/wafflevarnish | grep -B 1 -A 2 LC_RPATH \nLoad command 15\n          cmd LC_RPATH\n      cmdsize 40\n         path @executable_path/../lib …\n\n\nAnd both wafflevarnish and libVarnish.dylib reference their dynamic library dependencies with rpath-relative references:\n\n% otool -L \"libWaffleVarnish/bin/wafflevarnish\"\n…\n    @rpath/libVarnish.dylib …\n    @rpath/libWaffle.dylib …\n    …\n% otool -L \"libWaffleVarnish/lib/libVarnish.dylib\"\n…\n    @rpath/libVarnish.dylib …\n    @rpath/libWaffle.dylib …\n    …\n% otool -L \"libWaffleVarnish/lib/libWaffle.dylib\"\n…\n    @rpath/libWaffle.dylib …\n    …\n\n\nFor more information on the rpath mechanism, see the dyld man page. If you’re unfamiliar with reading man pages, see Reading UNIX Manual Pages.\n\nWith this setup it’s easy to place this tool and its libraries in your bundle with a minimum amount of disruption. If the code you’re using is built this way, skip forward to Place Content in the Correct Location Within the Bundle.\n\nAdopt rpath-relative references\n\nNot all code with a nonstandard structure is as accommodating as libWaffleVarnish. For example, the build system for libRubPat expresses its dependencies using absolute paths:\n\n% otool -L \"libRubPat/bin/rubpat\"\n…\n    /usr/local/libRubPat/lib/libPat.dylib …\n    /usr/local/libRubPat/lib/libRub.dylib …\n    …\n% otool -L \"libRubPat/lib/libPat.dylib\"\n…\n    /usr/local/libRubPat/lib/libPat.dylib …\n    /usr/local/libRubPat/lib/libRub.dylib …\n    …\n% otool -L \"libRubPat/lib/libRub.dylib\"\n…\n    /usr/local/libRubPat/lib/libRub.dylib …\n    …\n\n\nThis tool and its associated dynamic libraries will only work when they’re installed in /usr/local/libRubPat, so you can’t embed this code as-is in your bundle.\n\nNote\n\nlibWaffleVarnish, which is based entirely on rpath-relative paths, and libRubPat, which is based entirely on absolute paths, aren’t the only possibilities. Many nonstandard code structures use a mishmash of absolute paths, relative paths, executable-relative paths (@executable_path), loader-relative paths (@loader_path), and rpath-relative paths (@rpath). Sorting this out can be a challenge.\n\nThe best way to fix this problem is to update the code’s build system to use rpath-relative references. However, this isn’t possible for libRubPat because that library is not open source. To embed libRubPat in your bundle, use install_name_tool to change the paths embedded in its code items. First remove all the code signatures:\n\n% codesign --remove-signature \"libRubPat/lib/libRub.dylib\"\n% codesign --remove-signature \"libRubPat/lib/libPat.dylib\"\n% codesign --remove-signature \"libRubPat/bin/rubpat\"\n\n\nChanging code using install_name_tool breaks the seal on its code signature, a fact that install_name_tool warns you about. You will be re-signing this code as part of your distribution process, so you might as well work with unsigned code and avoid a bunch of warnings.\n\nNow change the dynamic library identifier for each library to be rpath-relative:\n\n% install_name_tool -id \"@rpath/libRub.dylib\" \"libRubPat/lib/libRub.dylib\"\n% install_name_tool -id \"@rpath/libPat.dylib\" \"libRubPat/lib/libPat.dylib\"\n\n\nThis controls how the library identifies itself to the rest of the system.\n\nNext, change each dynamic library dependency to match:\n\n% install_name_tool -change \"/usr/local/libRubPat/lib/libRub.dylib\" \"@rpath/libWaffle.dylib\" \"libRubPat/lib/libPat.dylib\"\n% install_name_tool -change \"/usr/local/libRubPat/lib/libRub.dylib\" \"@rpath/libWaffle.dylib\" \"libRubPat/bin/rubpat\"\n% install_name_tool -change \"/usr/local/libRubPat/lib/libPat.dylib\" \"@rpath/libVarnish.dylib\" \"libRubPat/bin/rubpat\"\n\n\nFinally, add an executable-relative rpath to the tool:\n\n% install_name_tool -add_rpath \"@executable_path/../lib\" \"libRubPat/bin/rubpat\"\n\n\nTo confirm that you’ve fixed all the dependencies, run otool just like you did for libWaffleVarnish:\n\n% otool -l libRubPat/bin/rubpat | grep -B 1 -A 2 LC_RPATH \nLoad command 17\n          cmd LC_RPATH\n      cmdsize 40\n         path @executable_path/../lib (offset 12)\n\n\n% otool -L \"libRubPat/bin/rubpat\"\n…\n    @rpath/libPat.dylib …\n    @rpath/libRub.dylib …\n    …\n% otool -L \"libRubPat/lib/libPat.dylib\"\n…\n    @rpath/libPat.dylib …\n    @rpath/libRub.dylib …\n    …\n% otool -L \"libRubPat/lib/libRub.dylib\"\n…\n    @rpath/libRub.dylib …\n    …\n\n\nThe final result is a code structure where all the dynamic library dependencies are rpath-relative, and the rpath entry for the tool itself is executable-relative. This structure works regardless of where it’s located on disk, making it feasible to embed it in your bundle.\n\nPlace content in the correct location within the bundle\n\nOnce you’ve confirmed that the code uses rpath-relative paths, it’s time to embed it in your bundle. Imagine you’re building an app called MacWaffleVarnish. The rules in Placing Content in a Bundle require this structure:\n\nMacWaffleVarnish.app/\n  Contents/\n    Info.plist\n    MacOS/\n      MacWaffleVarnish\n      wafflevarnish\n    Frameworks/\n      libVarnish.dylib\n      libWaffle.dylib\n    Resources/\n      … other resources …\n      libWaffleVarnish/\n        etc/\n          wafflevarnish.config\n\n\nThe dynamic libraries are in Contents/Frameworks, the tool in Contents/MacOS, and the configuration file in Contents/Resources.\n\nTo make this work, use install_name_tool to adjust the rpath entry in the wafflevarnish tool to point to the Frameworks directory rather than the lib directory:\n\n% install_name_tool -rpath \"@executable_path/../lib\" \"@executable_path/../Frameworks\" \"wafflevarnish\"\n\n\nAnd that’s all you need to do. The use of rpath-relative references in libWaffleVarnish makes it easy to change its code structure to match platform conventions.\n\nUse symlinks for gnarly edge cases\n\nThere’s one final gotcha here. If you run the wafflevarnish tool you’ll see this error:\n\n% MacWaffleVarnish.app/Contents/MacOS/wafflevarnish\nMacWaffleVarnish.app/Contents/MacOS/../etc/wafflevarnish.config: No such file or directory\n…\n\n\nIt’s trying to access wafflevarnish.config via a path that’s relative to the executable, but you’ve moved things around such that the configuration file is no longer available at that relative path. In many cases a tool will have a way to set the path to its configuration using a command-line argument or an environment variable. If not, fix the problem using a symlink:\n\nMacWaffleVarnish.app/\n  Contents/\n    …\n    MacOS/\n      …\n      wafflevarnish\n    …\n    Resources/\n      …\n      libWaffleVarnish/\n        bin/\n          wafflevarnish -> ../../MacOS/wafflevarnish\n        etc/\n          wafflevarnish.config\n\n\nNow, if you run the wafflevarnish tool via the symlink, it finds the configuration file and all is well:\n\n% MacWaffleVarnish.app/Contents/Resources/libWaffleVarnish/bin/wafflevarnish\nconfiguration:\n  finish: gloss\n…\n\n\nSymlinking is a powerful technique for handling gnarly edge cases. For example, if the code dynamically loads a plug-in via a relative path that leads to a location that cannot hold code, create a symlink at that location that points to where the code is actually placed.\n\nYou can also use symlinks to reduce the number of dynamic library dependencies you have to rewrite using install_name_tool. Imagine you’re working with a huge code structure with a lot of inter-library dependencies. Rather than rewrite all of those dependencies, you could embed the code structure en masse, then move each code item to its appropriate location within your bundle while leaving behind a symlink.\n\nIn most cases, however, it’s easier and better to rewrite everything to use rpath-relative references."
  },
  {
    "title": "Build system | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/build-system",
    "html": "Overview\n\nThe Xcode build system manages the tools that transform your code and resource files into a finished app. When you tell Xcode to build your project, the build system analyzes your files and uses your project settings to assemble the set of tasks to perform. Use your project settings to modify the build process and add tasks that you need to complete your builds.\n\nTopics\nEssentials\nConfiguring a new target in your project\nConfigure your project to build a new product, and add the code and resources the product requires.\nConfiguring a multiplatform app\nShare project settings and code across platforms in a single app target.\nBuild settings\nConfiguring the build settings of a target\nSpecify the options you use to compile, link, and produce a product from a target, and identify settings inherited from your project or the system.\nAdding a build configuration file to your project\nSpecify your project’s build settings in plain-text files, and supply different settings for debug and release builds.\nBuild settings reference\nA detailed list of individual Xcode build settings that control or change the way a target is built.\nIdentifying and addressing framework module issues\nDetect and fix common problems found in framework modules with the module verifier.\nBuild customization\nCustomizing the build schemes for a project\nSpecify which targets to build, and customize the settings Xcode uses to build, run, test, and profile those targets.\nCustomizing the build phases of a target\nSpecify the tasks to perform during a build, including the source files to compile, the scripts to run, and the resources to include in the final product.\nCreating build rules for custom file types\nTell Xcode how to build your project’s custom file types, and provide dependency information to optimize the build process for each file.\nRunning custom scripts during a build\nExecute custom shell scripts during the build process, and run tools or other commands that your project requires.\nRunning code on a specific platform or OS version\nAdd conditional compilation markers around code that requires a particular family of devices or minimum operating system version to run.\nPerformance\nConfiguring your project to use mergeable libraries\nUse mergeable dynamic libraries to get app launch times similar to static linking in release builds, without losing dynamically linked build times in debug builds.\nImproving the speed of incremental builds\nTell the Xcode build system about your project’s target-related dependencies, and reduce the compiler workload during each build cycle.\nImproving build efficiency with good coding practices\nShorten compile times by reducing the number of symbols your code exports and by giving the compiler the explicit information it needs.\nSecurity and privacy\nVerifying the origin of your XCFrameworks\nDiscover who signed a framework, and take action when that changes.\nSee Also\nXcode IDE\nProjects and workspaces\nManage the code and resources you use to build apps, libraries, and other software for Apple platforms.\nSource control management\nBack up your files, collaborate with others, and tag your releases with source control support in Xcode.\nCapabilities\nEnable services that Apple provides, such as In-App Purchase, Push Notifications, Apple Pay, iCloud, and many others."
  },
  {
    "title": "Configuring Group Activities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/configuring-group-activities",
    "html": "Overview\n\nUse Group Activities to bring your app’s users together to enjoy new and exciting shared experiences that are built atop SharePlay and the FaceTime infrastructure. For example, a karaoke app might offer karaoke parties where several participants take part simultaneously from their own devices.\n\nRepresent shareable activities by creating objects that conform to the GroupActivity protocol and, after a shared activity begins, use GroupSession to synchronize that activity across participants’ devices.\n\nAdd the Group Activities capability to your target\n\nFollow the steps in Add a capability to add the capability to your app’s target, making sure you select the Group Activities capability from Xcode’s Capabilities library. This capability is available on all platforms except watchOS, and you must add it to an app target — Group Activities aren’t available in widgets, extensions, or App Clips.\n\nAfter you add the Group Activities capability, Xcode updates your target’s entitlements file to include the com.apple.developer.group-session entitlement. If Xcode automatically manages the signing of your app, it also enables Group Activities for your app’s App ID.\n\nNote\n\nIf you remove the Group Activities capability in Xcode, you must manually update your App ID’s configuration in the developer portal to disable Group Activities.\n\nWhen you add the Group Activities capability, there are additional steps you must complete before your app’s users can start experiencing shared activities; for more information on these steps, see Defining your app’s SharePlay activities and Joining and managing a shared activity.\n\nSee Also\nNetwork\nConfiguring network extensions\nCustomize the various capabilities of your app’s networking stack, such as proxying DNS queries or creating packet tunnels.\nConfiguring media device discovery\nAdd a third-party media device or protocol as a streaming option in the same system menu as AirPlay."
  },
  {
    "title": "Application binary interfaces | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/application-binary-interfaces",
    "html": "Overview\n\nThe CPUs found in Apple products define rules for how to call functions, manage the stack, and perform other operations. If your code includes assembly instructions, you must adhere to these rules to operate correctly with compiler-generated code. If you don’t adhere to them, your code might crash or behave unexpectedly.\n\nTopics\n64-bit interfaces\nWriting ARM64 code for Apple platforms\nCreate 64-bit ARM assembly language instructions that adhere to the application binary interface (ABI) that Apple platforms support.\niOS interfaces\nWriting ARMv7 code for iOS\nCreate ARMv7 assembly language instructions that adhere to the application binary interface (ABI) that iOS supports.\nWriting ARMv6 code for iOS\nCreate ARMv6 assembly language instructions that adhere to the application binary interface (ABI) that iOS supports."
  },
  {
    "title": "Previewing your app’s interface in Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/previewing-your-apps-interface-in-xcode",
    "html": "Overview\n\nWith Xcode previews, you can make changes to your app’s views in code, and see the result of those changes quickly in the preview canvas. Add previews to your SwiftUI, UIKit, and AppKit views using the preview macro. Then configure how you want your previews to display using Xcode’s preview canvas, or programmatically in code.\n\nAdd a preview to your view using the preview macro\n\nWhen you create a view in Xcode, you can display it in the preview canvas. The preview canvas shows how your view appears on different devices in a variety of configurations.\n\nThe Swift preview macro is a snippet of code that makes and configures your view. You use one of the preview macros — such as Preview(_:body:) — to tell Xcode what to display. To manually show or hide the preview canvas, select Editor > Canvas from the Xcode menu.\n\nSwiftUI\nUIKit\nAppKit\n// A SwiftUI preview.\n#Preview {\n    // The view to preview.\n}\n\n\nTo add a preview macro to your view:\n\nOpen the source file of the view you want to display.\n\nAdd the #Preview macro to the view.\n\nCreate and return an instance of the view configuration you want to display in the body of the trailing closure of the macro.\n\nSwiftUI\nUIKit\nAppKit\nstruct ContentView: View {\n    var body: some View {\n        // ...\n    }\n}\n\n\n// A SwiftUI preview.\n#Preview {\n    ContentView()\n}\n\nInteract with your view in live mode\n\nWhen you select the live or interactive preview option, your view appears and interacts just like it would on a device or simulator. Use this mode of preview to test control logic, animations, and text entry as well as responses to asynchronous code. When you select this mode, a single device preview appears in the canvas. This is the default mode for new previews you display.\n\nPlay\nTry out new designs quickly with select mode\n\nIn select mode, the preview displays a snapshot of your view so you can interact with your view’s UI elements in the canvas. Selecting a control in the preview highlights the corresponding line of code in the source editor. Double-clicking certain text views, such as Label, moves focus to the source editor so you can make changes quickly.\n\nControl how your previews display with device settings\n\nUse Device settings to control how a preview displays for a specific device. For example, to see how your view looks in Dark Mode, in a landscape right orientation, with extra large text:\n\nSelect the Device settings option at the bottom of the preview canvas.\n\nClick the Color Scheme toggle to on, and select the Dark Appearance option under Color Scheme.\n\nClick the Orientation toggle to on, and select the Landscape Right option under the Orientation header.\n\nClick the Dynamic Type toggle to on, and drag the Dynamic Type slider to the X Large text setting.\n\nTest different view configurations\n\nUse variant mode to see how your view appears in different variations for a given configuration. For example, to test how well your view supports accessibility, select Variant mode from the bottom of the preview canvas, and select the Dynamic Type Variants option. Xcode displays your view with different sizes of text.\n\nPreview canvas supports the following variations:\n\nColor Scheme Variants\n\nDisplays a light and dark preview of your view.\n\nOrientation Variants\n\nDisplays your view in all the different portrait and landscape orientations.\n\nDynamic Type Variants\n\nDisplays your view in all the accessibility text sizes for your app.\n\nExperiment\n\nBecause variant mode shows all the values for a given device setting, you can override what variant mode displays by making further changes in Device settings. For example, to see how your view appears in different sizes of text in Dark Mode, select the Dynamic Type Variants option from Variant mode, and then enable the Dark Mode color scheme in Device settings.\n\nPreview on a specific device\n\nTo see how your view displays on a specific device, select the Preview destination picker option, and then select the device you want your preview to display. When you do, Xcode displays a preview of your view on that device.\n\nCapture specific previews in code\n\nIn addition to the preview options Xcode provides, you can also customize and configure previews you want to reuse programmatically in code.\n\nFor example, you can add a name to more easily track what each preview displays. When you pass the name of your preview as a string into the preview macro, the name appears in the title of the preview in the preview canvas.\n\n// A preview with an assigned name.\n#Preview(\"2x2 Grid Portrait\") {\n   Content()\n}\n\n\nYou can also control how your preview displays by passing one or more configuration traits as a variadic argument list into the preview macro. For example, to display your view in the landscape left orientation, pass the landscapeLeft type property into the init(_:traits:body:) preview initializer to tell Xcode which orientation to display.\n\nSwiftUI\nUIKit\nAppKit\n// A SwiftUI preview with name and orientation.\n#Preview(\"2x2 grid\", traits: .landscapeLeft) {\n    CollageView(layout: .twoByTwoGrid)\n}\n\nPass views only the data they need\n\nWhen creating views, pass in only the data the view needs to display. Avoid passing in objects that fetch data; objects make setting up a view’s preview more complicated and less performant.\n\nInstead, create views with the minimal amount of data they need, favoring simpler, immutable data types. Creating views this way makes testing and previewing your views easier and helps them perform better.\n\nThe following example shows how simple data types, like String and enum, can be used to preview a view in various ways using the preview macro.\n\nSwiftUI\nUIKit\nAppKit\nstruct CollaboratorCell: View {\n    // Construct your view with only the data it needs.\n    let name: String\n    let image: Image?\n    let connectionStatus: ConnectionStatus\n    \n    enum ConnectionStatus {\n        case online\n        case offline\n    }\n\n\n    // ...\n}\n\n\n#Preview(\"Supported cell combinations\", traits: .sizeThatFitsLayout) {\n    let image = Image(systemName: \"person.circle\")\n    return VStack {\n        // Then test each scenario in your preview macro.\n        CollaboratorCell(name: \"Tom Clark\", image: nil, connectionStatus: .offline)\n        CollaboratorCell(name: \"Tom Clark\", image: image, connectionStatus: .offline)\n        CollaboratorCell(name: \"Tom Clark\", image: nil, connectionStatus: .online)\n        CollaboratorCell(name: \"Tom Clark\", image: image, connectionStatus: .online)\n        CollaboratorCell(name: \"Tom Long Middle Clark\", image: nil, connectionStatus: .offline)\n        CollaboratorCell(name: \"Tom Long Middle Clark\", image: image, connectionStatus: .online)\n    }\n}\n\n\nSee Also\nEssentials\nCreating an Xcode project for an app\nStart developing your app by creating an Xcode project from a template.\nCreating your app’s interface with SwiftUI\nDevelop apps in SwiftUI with an interactive preview that keeps the code and layout in sync.\nBuilding and running an app\nCompile your source files and assemble an app bundle to run on a device or simulator."
  },
  {
    "title": "Xcode Cloud | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/xcode-cloud",
    "html": "Overview\n\nXcode Cloud lets you adopt continuous integration and delivery (CI/CD), a standard software development practice that helps you develop and maintain your code and deliver apps to testers and users. Xcode Cloud is a CI/CD system that combines the tools you use to create apps and frameworks for Apple platforms: Xcode, TestFlight, and App Store Connect.\n\nWith Xcode Cloud, you can automatically and frequently:\n\nBuild your project.\n\nRun tests and perform verifications.\n\nDistribute builds to testers and gather their feedback with TestFlight while protecting user privacy.\n\nAfter successfully verifying a new version of your app with Xcode Cloud and TestFlight, you can quickly release it on the App Store.\n\nFor more information about continuous integration and delivery, see About continuous integration and delivery with Xcode Cloud. To learn more about configuring your project or workspace to use Xcode Cloud, see Configuring your first Xcode Cloud workflow.\n\nNote\n\nFor additional information about Xcode Cloud that includes videos from WWDC21 and WWDC22, see The Xcode Cloud toolkit.\n\nTopics\nEssentials\nAbout continuous integration and delivery with Xcode Cloud\nLearn how continuous integration and delivery with Xcode Cloud helps you create high-quality apps and frameworks.\nRequirements for using Xcode Cloud\nReview account, project, and source control requirements before configuring your project or workspace to use Xcode Cloud.\nSetup and maintenance\nConfiguring your first Xcode Cloud workflow\nConfigure your project or workspace to use Xcode Cloud and adopt continuous integration and delivery.\nMaking dependencies available to Xcode Cloud\nReview dependencies and make them available to Xcode Cloud before you configure your project to use Xcode Cloud.\nConfiguring Xcode Cloud for your team\nStart using continuous integration and delivery with Xcode Cloud as a team.\nBuilding Swift packages and Swift Playgrounds app projects with Xcode Cloud\nAdd your Swift package or Swift Playgrounds app project to an Xcode project to build it in Xcode Cloud.\nSetting the next build number for Xcode Cloud builds\nStart numbering builds from a custom build number for your existing Mac app to avoid version collisions.\nIncluding notes for testers with a beta release of your app\nAdd text files to your Xcode project to provide notes to beta testers about what to test.\nRemoving your project from Xcode Cloud\nRemove your project from Xcode Cloud to delete app and workflow data, disconnect your Git repository, and remove the Slack integration.\nUsage data\nReviewing Xcode Cloud usage data\nAccess Xcode Cloud usage information to understand how you and your team use Xcode Cloud.\nWorkflows\nDeveloping a workflow strategy for Xcode Cloud\nReview how you can best create custom Xcode Cloud workflows to refine your continuous integration and delivery practice.\nXcode Cloud workflow reference\nConfigure metadata, start conditions, actions, post-actions, and more to create custom Xcode Cloud workflows.\nCreating a workflow that builds your app for distribution\nConfigure a workflow to build and sign your app for distribution to testers with TestFlight, in the App Store, or as a notarized app.\nSource code management\nSource code management setup\nAllow Xcode Cloud to access your Git repository.\nConfiguring requirements for merging a pull request\nProtect stable branches by requiring a successful Xcode Cloud build or action before it’s possible to merge a pull request.\nCustom build scripts\nWriting custom build scripts\nExtend your Xcode Cloud workflows with custom build scripts that perform custom tasks or install additional tools.\nEnvironment variable reference\nReview predefined environment variables you use in custom build scripts.\nTroubleshooting\nResolving common configuration and build issues\nReview common configuration and build issues and learn how you can resolve them.\nResolve GitHub Enterprise connection issues\nVerify that Xcode Cloud can access your GitHub Enterprise repository and fix configuration issues.\nReporting feedback for Xcode Cloud\nProvide feedback on issues you encounter when building with Xcode Cloud.\nNotifications\nConfiguring webhooks in Xcode Cloud\nConfigure webhooks that connect Xcode Cloud to other services and tools.\nConnecting Xcode Cloud to Slack\nConnect Xcode Cloud to Slack to keep your team informed about the latest Xcode Cloud builds.\nREST API\nXcode Cloud Workflows and Builds\nAutomate reading Xcode Cloud data, managing workflows, and starting builds.\nSee Also\nDistribution and continuous integration\nDistribution\nPrepare you app and share it with your team, beta testers, and customers."
  },
  {
    "title": "Distribution | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/distribution",
    "html": "Topics\nEssentials\nPreparing your app for distribution\nConfigure the information property list and add icons before you distribute your app.\nDistribution and release\nDistributing your app for beta testing and releases\nRelease your app to beta testers and users.\nDistributing your app to registered devices\nRegister devices in your developer account and deploy your app to them for testing.\nCode signing\nUsing the latest code signature format\nUpdate legacy app code signatures so your app runs on current OS releases.\nNotarizing macOS software before distribution\nGive users even more confidence in your macOS software by submitting it to Apple for notarization.\nSigning a daemon with a restricted entitlement\nWrap a daemon in an app-like structure to use an entitlement thatʼs authorized by a provisioning profile.\nSynchronizing your code signing identities with Apple Developer Portal\nEnsure you and other team members can sign your organization’s code and installer packages in Xcode.\nTN3125: Inside Code Signing: Provisioning Profiles\nLearn how provisioning profiles enable third-party code to run on Apple platforms.\nTesting\nTesting a release build\nRun your app in simulated user environments to discover and identify deployment errors.\nTesting a beta OS\nManage unintended differences in your app by testing beta operating-system (OS) releases.\nFeedback\nViewing and responding to feedback from beta testers\nFollow up on feedback from beta testers using the Feedback organizer.\nSee Also\nDistribution and continuous integration\nXcode Cloud\nAutomatically build, test, and distribute your apps with Xcode Cloud to verify changes and create high-quality apps."
  },
  {
    "title": "Test coverage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/test-coverage",
    "html": "Topics\nEssentials\nTesting your apps in Xcode\nDetect logic failures, UI problems, and performance regressions with XCTest.\nTest development\nDefining Test Cases and Test Methods\nAdd test cases and test methods to a test target to confirm that your code performs as expected.\nAdding unit tests to your existing project\nRemove coupling between components to increase test coverage and reliability.\nImproving code assessment by organizing tests into test plans\nControl the information you receive from your tests at different stages in the software engineering process by creating and configuring test plans.\nExecution and results\nRunning tests and interpreting results\nRun tests to determine whether your project’s code behaves as you expect.\nPerformance tests\nWriting and running performance tests\nRepeatably gather metrics on the performance of your code.\nLocation\nSimulating location in tests\nImprove test reliability and coverage when working with location-based code.\nStoreKit\nSetting up StoreKit Testing in Xcode\nPrepare your test environment to test in-app purchases with data you configure locally.\nTesting in-app purchases with StoreKit transaction manager in Xcode\nUse the transaction manager within Xcode to test in-app purchases without requiring a connection to App Store servers.\nSee Also\nTuning and debugging\nDevices and Simulator\nConfigure and manage devices connected to your Mac or devices in Simulator and use them to run your app.\nDebugging\nIdentify and address issues in your app using the Xcode debugger, Xcode Organizer, Metal debugger, and Instruments.\nPerformance and metrics\nMeasure, investigate, and address the use of system resources and issues impacting performance using Instruments and Xcode Organizer."
  },
  {
    "title": "Devices and Simulator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/devices-and-simulator",
    "html": "Overview\n\nAs you build your app, run it on real or simulated devices to test new features and evaluate your progress.\n\nRun your app on a real device to confirm that you can interact with it as you intend, and that your app’s performance on a real device meets your expectations. To run your app on a real device, first enable developer mode on your iOS, visionOS, or watchOS device, then connect your device to your Mac and run your app from Xcode.\n\nRun your app on Simulator to quickly evaluate new features and bug fixes, and to see how your user interface works on devices that you don’t have access to. Use Simulator’s features to streamline your testing, but be aware that there are some scenarios that require testing on hardware instead of Simulator.\n\nTopics\nEssentials\nEnabling Developer Mode on a device\nGrant or deny permission for locally installed apps to run on iOS, iPadOS, visionOS, and watchOS devices.\nRunning your app in Simulator or on a device\nLaunch your app in a simulated iOS, tvOS, watchOS, or visionOS device, or on a device connected to a Mac.\nSimulator management\nInstalling and managing Simulator runtimes\nKeep the Simulator platforms and versions you need to run and test your apps up to date in Xcode.\nInstalling your app in many Simulator platforms and versions\nSet up your app in multiple Simulator platforms and versions without the build-and-run cycle.\nSimulator interactions\nInteracting with your app in the iOS and iPadOS simulator\nUse your Mac to control interactions with your iOS and iPadOS apps in Simulator.\nInteracting with your app in the tvOS simulator\nUse your Mac to control interactions with your tvOS apps in Simulator.\nInteracting with your app in the watchOS simulator\nUse your Mac to control interactions with your watchOS apps in Simulator.\nInteracting with your app in the visionOS simulator\nUse your Mac to navigate spaces and control interactions with your visionOS apps in Simulator.\nConfiguring Simulator for your working environment\nAdjust Simulator settings for window or screen size, light or dark appearance, and audio settings, and restart or reset a simulated device.\nSimulating an external display or CarPlay\nTest how your app handles an external display or CarPlay from Simulator.\nCapturing screenshots and videos from Simulator\nRecord and share test results, or prepare for App Store distribution with screenshots and videos of your app from Simulator.\nSimulator testing considerations\nTesting in Simulator versus testing on hardware devices\nReview the differences between Simulator and hardware devices to determine which you should choose to test a scenario.\nSharing data with Simulator\nEnter text directly in Simulator, or share location data, images, web addresses, files, or data from the clipboard with Simulator.\nTesting complex hardware device scenarios in Simulator\nTest hardware device-specific scenarios, such as Face ID or Touch ID authentication, fall detection, getting a memory warning, or location changes.\nIdentifying graphics and animations issues in Simulator\nReveal performance and display issues in your views with color overlays, and slow down animations to debug and improve them.\nSimulator troubleshooting\nTroubleshooting Simulator launch or animation issues\nDiagnose and resolve issues launching a simulator, or with slow scrolling or animations in Simulator.\nSee Also\nTuning and debugging\nDebugging\nIdentify and address issues in your app using the Xcode debugger, Xcode Organizer, Metal debugger, and Instruments.\nPerformance and metrics\nMeasure, investigate, and address the use of system resources and issues impacting performance using Instruments and Xcode Organizer.\nTest coverage\nDevelop and run tests to detect logic failures, UI problems, and performance regressions."
  },
  {
    "title": "Localization | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/localization",
    "html": "Overview\n\nLocalization is the process of translating and adapting your app into multiple languages and regions. Localize your app to provide access for users who speak a variety of languages, and who download from different App Store territories.\n\nFirst, internationalize your code with APIs that automatically format and translate strings correctly for the language and region. Then add support for content that includes plural nouns and verbs by following language plural rules to increase the accuracy of your translations.\n\nTranslate and adapt your app\n\nIn Xcode, localization refers specifically to the set of resources for a specific language and region that you support.\n\nYou add a localization to your project and select the resources you want to include for that language and region. Export the localization and send the files to localizers, who translate the user-facing text and adapt resources for particular cultures and regions. Finally, you import the localized files and test the app in that language and region directly in Xcode.\n\nWhen you release a localized version of your app, you can also localize the App Store information in App Store Connect for the specific territories where you offer your app.\n\nFor other localization tips, tools, and resources, see Expanding Your App to New Markets.\n\nImportant\n\nIn Xcode 15 and later, string catalogs are the recommended way to localize strings. In earlier versions of Xcode, use strings and stringsdict files. For more information about string catalogs, see Localizing and varying text with a string catalog.\n\nTopics\nEssentials\nSupporting multiple languages in your app\nInternationalize your app’s strings, images, and other resource types to prepare for the translation process.\nLocalizing and varying text with a string catalog\nUse a string catalog to translate text, handle plurals, and vary the text your app displays on specific devices.\nStrings and text\nPreparing your interface for localization\nFind text in your app that needs translation and verify that your interface adapts to translated text.\nPreparing your app’s text for translation\nMake your app’s text translatable by leveraging the localization APIs in the Foundation framework.\nPreparing dates, currencies, and numbers for translation\nEnsure that dates, currencies, and numbers display correctly across multiple languages and locales by using formatters.\nLayouts and views\nPreparing views for localization\nSpecify hints and add strings to localize your SwiftUI views.\nAutosizing Views for Localization in iOS\nAdd auto layout constraints to your app to achieve localizable views.\nLocalization-Friendly Layouts in macOS\nThis project demonstrates localization-friendly auto layout constraints. It uses NSGridView as a container view to achieve localized layouts.\nLanguages and regions\nAdding support for languages and regions\nSelect the resources that you want to localize for each language and region you support.\nChoosing localization regions and scripts\nAdd a language-only localization or localizations specific to regional variants and scripts.\nResources and assets\nAdding resources to localizations\nInclude more resources in the localizations you add to your project.\nLocalizing assets in a catalog\nUse asset catalogs to localize colors, images, symbols, watch complications, and more.\nTranslation and adaptation\nCreating screenshots of your app for localizers\nShare screenshots of your app with localizers to provide context for translation.\nExporting localizations\nProvide the localizable files from your project to localizers.\nEditing XLIFF and string catalog files\nTranslate or adapt the localizable files for a language and region that you export from your project.\nImporting localizations\nImport the files that you translate or adapt for a language and region into your project.\nLocking views in storyboard and XIB files\nPrevent changes to your Interface Builder files while localizing human-facing strings.\nTesting\nPreviewing localizations\nTest localizations in the SwiftUI preview or the Interface Builder preview.\nTesting localizations when running your app\nRun your app in each language and region you support to thoroughly test your app.\nLegacy localization techniques\nLocalizing strings that contain plurals\nUse a strings dictionary file to ensure correct localization of strings that contain language plurals.\nCreating width and device variants of strings\nChange a localized string for different interface widths and devices.\nSee Also\nInterface\nAsset management\nAdd images, strings, data files, and other resources to your projects, and manage how you load them at runtime."
  },
  {
    "title": "Asset management | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/asset-management",
    "html": "Overview\n\nApps rely on many types of assets to create a rich, dynamic, and visually engaging user experience. Xcode provides tools and settings to help you add, organize, and optimize the different asset types your app uses.\n\nXcode simplifies managing most types of assets with asset catalogs. Use asset catalogs to organize and manage resources such as images, colors, app icons, textures, stickers, and data.\n\nXcode also provides interactive editors for certain types of assets, like particle effects, that let you experiment, make changes, and see the results immediately.\n\nTopics\nAsset catalogs\nManaging assets with asset catalogs\nAdd, organize, and edit sets of assets in your Xcode project using asset catalogs.\nApp icons and launch screen\nConfiguring your app icon\nAdd app icon variations to represent your app in places such as Settings, search results, and the App Store.\nConfiguring Your App to Use Alternate App Icons\nAdd alternate app icons to your app, and let people choose which icon to display.\nSpecifying your app’s launch screen\nMake your iOS app launch experience faster and more responsive by customizing a launch screen.\nImages\nAdding images to your Xcode project\nImport images into your project, manage their appearances and variations, and load them at runtime.\nCreating custom symbol images for your app\nCreate, organize, and annotate symbol images using SF Symbols.\nColors\nSpecifying your app’s color scheme\nSet a global accent color for your app by using asset catalogs.\nSupporting Dark Mode in Your Interface\nUpdate colors, images, and behaviors so that your app adapts automatically when Dark Mode is active.\nAR assets\nDetecting Images in an AR Experience\nReact to known 2D images in the user’s environment, and use their positions to place AR content.\nScanning and detecting 3D objects\nRecord spatial features of real-world objects, then use the results to find those objects in the user’s environment and trigger AR content.\nCreating 3D Content with Reality Composer\nAssemble assets into a dynamic 3D composition that you can add to a scene in your app, or share with AR Quick Look.\nMachine learning assets\nCreate ML\nCreate machine learning models for use in your app.\nParticle effects\nCreating a SpriteKit particle emitter in Xcode\nAdd particle effects to your app by creating repeatable particles.\nSee Also\nInterface\nLocalization\nExpand the market for your app by supporting multiple languages and regions."
  },
  {
    "title": "Swift packages | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/swift-packages",
    "html": "Overview\n\nSwift packages are reusable components of Swift, Objective-C, Objective-C++, C, or C++ code that developers can use in their projects. They bundle source files, binaries, and resources in a way that’s easy to use in your app’s project.\n\nXcode supports creating and publishing Swift packages, as well as adding, removing, and managing package dependencies. Its support for Swift packages is built on top of the open source Swift Package Manager project.\n\nTo learn more about the API you use in your package manifest, see Package. To learn more about the Swift Package Manager, see Swift.org and the open source Swift Package Manager repository.\n\nTopics\nPackage dependencies\nAdding package dependencies to your app\nIntegrate package dependencies to share code between projects, or leverage code from other developers.\nIdentifying binary dependencies\nFind out if a package dependency references a binary and verify the binary’s authenticity.\nEditing a package dependency as a local package\nOverride a package dependency and edit its content by adding it as a local package.\nPackage creation\nCreating a standalone Swift package with Xcode\nBundle executable or shareable code into a standalone Swift package.\nBundling resources with a Swift package\nAdd resource files to your Swift package and access them in your code.\nLocalizing package resources\nEnsure that your Swift package provides localized resources for many locales.\nDistributing binary frameworks as Swift packages\nMake binaries available to other developers by creating Swift packages that include one or more XCFrameworks.\nDeveloping a Swift package in tandem with an app\nAdd your published Swift package as a local package to your app’s project and develop the package and the app in tandem.\nOrganizing your code with local packages\nSimplify maintenance, promote modularity, and encourage reuse by organizing your app’s code into local Swift packages.\nPackageDescription\nCreate reusable code, organize it in a lightweight way, and share it across your projects and with other developers.\nPackage distribution\nPublishing a Swift package with Xcode\nPublish your Swift package privately, or share it globally with other developers.\nContinuous integration\nBuilding Swift packages or apps that use them in continuous integration workflows\nBuild Swift packages with an existing continuous integration setup and prepare apps that consume package dependencies within an existing CI pipeline.\nSee Also\nCode\nSource Editor\nEdit your source files, locate issues, and make necessary changes using the Source Editor.\nBundles and frameworks\nOrganize code and resources in bundles and frameworks."
  },
  {
    "title": "Bundles and frameworks | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/bundles-and-frameworks",
    "html": "Topics\nBundles\nPlacing Content in a Bundle\nPlace bundle content in the correct location based on its type.\nEmbedding nonstandard code structures in a bundle\nUse code that’s structured in a nonstandard way while avoiding code signing and distribution problems.\nFrameworks\nCreating a multiplatform binary framework bundle\nCombine variants of a binary framework or library into an XCFramework bundle that supports multiple platforms.\nIdentifying and addressing framework module issues\nDetect and fix common problems found in framework modules with the module verifier.\nSee Also\nCode\nSource Editor\nEdit your source files, locate issues, and make necessary changes using the Source Editor.\nSwift packages\nCreate reusable code, organize it in a lightweight way, and share it across Xcode projects and with other developers."
  },
  {
    "title": "Source Editor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/source-editor",
    "html": "Topics\nSource file creation, organization, and editing\nEditing source files in Xcode\nEdit source files in Xcode and add Quick Help comments to improve your project’s maintainability.\nIssue detection\nFixing issues in your code as you type\nMinimize typing-related errors using code completion, and let Xcode fix common mistakes for you.\nCode search and refactoring\nFinding and refactoring code\nSearch your code for text, patterns, and symbols that you can refactor quickly and easily.\nSee Also\nCode\nBundles and frameworks\nOrganize code and resources in bundles and frameworks.\nSwift packages\nCreate reusable code, organize it in a lightweight way, and share it across Xcode projects and with other developers."
  },
  {
    "title": "Source control management | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/source-control-management",
    "html": "Overview\n\nSource control is the practice of tracking and managing changes to your code. Manage your Xcode project with source control to keep a rich history of the changes you make, and collaborate on code faster and more effectively.\n\nXcode simplifies source control management with its built-in support for Git. You create a Git source control repository that represents your project, and track the changes you make to your project through commits. When your code is\nready, your collaborators can review your changes, suggest alternative approaches, and accept your changes by approving and merging your new code into the main codebase.\n\nTopics\nEssentials\nConfiguring your Xcode project to use source control\nSync code changes between team members and development computers by setting up your Xcode project to use Git source control.\nTracking code changes in a source control repository\nCreate a history of incremental code changes to your Xcode project’s source control repository with Git commits.\nGit\nOrganizing your code changes with source control\nStreamline your collaboration workflow by managing your Xcode project’s features and releases with Git branches and tags.\nCombining code changes in a source control repository\nIntegrate code changes from multiple sources and resolve conflicts between different versions of code using source control tools in Xcode.\nConfiguring source control preferences in Xcode\nCustomize the default Xcode settings for connecting to Git repositories, applying code changes, and more options for configuring source control.\nSee Also\nXcode IDE\nProjects and workspaces\nManage the code and resources you use to build apps, libraries, and other software for Apple platforms.\nCapabilities\nEnable services that Apple provides, such as In-App Purchase, Push Notifications, Apple Pay, iCloud, and many others.\nBuild system\nCompile your code into a binary format, and customize your project settings to build your code."
  },
  {
    "title": "Capabilities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/capabilities",
    "html": "Overview\n\nCapabilities simplify the configuration process for many of Apple’s services, some of which require you to configure specific entitlements or change your app’s provisioning profile. When you add a capability to an app or other target in your project, Xcode automatically configures that target to use the corresponding service. For example, Xcode might add a required entitlement to a new entitlements file and configure the project to use those entitlements. When Xcode needs you to provide additional information, it presents a simplified UI for you to specify that information.\n\nNote\n\nYou add most capabilities directly from Xcode, but some app services — such as Game Center and In-App Purchase — require additional setup in App Store Connect and your developer account. For more information, see the documentation below for the specific capability.\n\nTopics\nEssentials\nAdding capabilities to your app\nConfigure your target to include and customize capabilities that provide access to Apple’s app services.\nApp execution\nConfiguring background execution modes\nIndicate the background services your app requires to continue executing in the background in iOS, tvOS, visionOS, and watchOS.\nConfiguring custom fonts\nRegister your app as a provider or consumer of systemwide custom fonts.\nConfiguring game controllers\nEnhance gameplay input by enabling the discovery, configuration, and use of physical game controllers.\nConfiguring Maps support\nRegister your iOS routing app to provide point-to-point directions to Maps and other apps.\nConfiguring Siri support\nEnable your app and its Intents extension to resolve, confirm, and handle user-driven Siri requests for your app’s services.\nCommerce\nConfiguring Apple Pay support\nProcess payments in your app using the payment information the user stores on their device.\nConfiguring Sign in with Apple support\nAllow users to create an account and sign in to your app with their Apple ID.\nConfiguring Wallet support\nAccess the user’s Wallet to add, update, and display your app’s passes.\nData management\nConfiguring an associated domain\nCreate a two-way association between your app and your website to enable universal links, Handoff, App Clips, and shared web credentials.\nConfiguring App Groups\nEnable communication and data sharing between multiple installed apps created by the same developer.\nConfiguring iCloud services\nShare user or app data among multiple instances of your app running on different devices.\nNetwork\nConfiguring network extensions\nCustomize the various capabilities of your app’s networking stack, such as proxying DNS queries or creating packet tunnels.\nRegistering your app with APNs\nCommunicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.\nConfiguring Group Activities\nLeverage FaceTime infrastructure to create coordinated experiences users can share.\nConfiguring media device discovery\nAdd a third-party media device or protocol as a streaming option in the same system menu as AirPlay.\nSecurity\nConfiguring the hardened runtime\nProtect the runtime integrity of your macOS app by restricting access to sensitive resources and preventing common exploits.\nConfiguring the macOS App Sandbox\nProtect system resources and user data from compromised apps by restricting access to the file system, network connections, and more.\nConfiguring keychain sharing\nShare keychain items between multiple apps belonging to the same developer.\nUser data\nConfiguring HealthKit access\nRead and write health and activity data in the Health app.\nConfiguring HomeKit access\nDiscover compatible accessories and communicate with configured accessories and services to perform actions.\nSee Also\nXcode IDE\nProjects and workspaces\nManage the code and resources you use to build apps, libraries, and other software for Apple platforms.\nSource control management\nBack up your files, collaborate with others, and tag your releases with source control support in Xcode.\nBuild system\nCompile your code into a binary format, and customize your project settings to build your code."
  },
  {
    "title": "Projects and workspaces | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/projects-and-workspaces",
    "html": "Topics\nFiles and workspaces\nManaging files and folders in your Xcode project\nAdd new or existing files to your project, and use groups to organize the files and folders in the Project navigator.\nManaging multiple projects and their dependencies\nManage related projects in one place using a workspace, or configure build-time dependencies between different Xcode projects using cross-project references.\nNavigation\nConfiguring the Xcode project window\nConfigure the appearance of Xcode project windows by showing and hiding editors, inspectors, and navigation content.\nFinding and replacing content in a project\nSearch some or all of your project for text strings or symbol names, and perform advanced searches using regular expressions.\nProject configuration\nManaging Your App’s Information Property List\nCreate and customize an information property list file for your app using Xcode.\nAdding package dependencies to your app\nIntegrate package dependencies to share code between projects, or leverage code from other developers.\nCreating a Mac version of your iPad app\nBring your iPad app to macOS with Mac Catalyst.\nSetting up a watchOS project\nCreate a new watchOS project or add a watch target to an existing iOS project.\nEmbedding a command-line tool in a sandboxed app\nAdd a command-line tool to a sandboxed app’s Xcode project so the resulting app can run it as a helper tool.\nAssociated domains and universal links\nAllowing apps and websites to link to your content\nUse universal links to link directly to content within your app and share data securely.\nSee Also\nXcode IDE\nSource control management\nBack up your files, collaborate with others, and tag your releases with source control support in Xcode.\nCapabilities\nEnable services that Apple provides, such as In-App Purchase, Push Notifications, Apple Pay, iCloud, and many others.\nBuild system\nCompile your code into a binary format, and customize your project settings to build your code."
  },
  {
    "title": "Building and running an app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/building-and-running-an-app",
    "html": "Overview\n\nDuring development, you build and run an app many times to test new features and eliminate bugs. Each time you build, Xcode analyzes your app’s source files to determine which ones it must recompile. Xcode also identifies any other tasks that it must perform, such as running custom scripts. Depending on the state of your project, Xcode performs either a complete rebuild of everything, or an incremental build of only the changed items.\n\nWhen you run an app after a successful build, Xcode launches the app on the selected device. Mac apps run on the same device as your Xcode installation. iOS, iPadOS, visionOS, watchOS, and tvOS apps run either on a connected device or in a simulated environment on your Mac.\n\nConfigure a target for your app\n\nXcode determines how to build apps and other products from your project’s target information. A target contains the tasks required to create an executable, and the settings to use to build it. For example, an app target might contain the list of files to compile, the resources to copy into the app’s bundle, and other steps needed to configure the app.\n\nWhen you create a new project, the template you choose includes a default target, which Xcode configures using the information you provide. You can add new targets to your project at any time to create additional products. For information about how to configure new targets, see Configuring a new target in your project.\n\nSelect a scheme for your target\n\nA build scheme is a collection of settings that specify which targets to build, the build configuration to use, and the executable environment for the running product. Xcode creates schemes for most targets automatically, and you can create additional schemes to customize the build and execution options. For example, you might create a new scheme to pass additional launch arguments to your app.\n\nTo build an app, or any other target, select a scheme that contains the target. Xcode displays the selected scheme in the toolbar of your project window. To change the selected scheme, click the scheme name and choose a new one from the pop-up menu.\n\nFor information about how to configure your project’s schemes, see Customizing the build schemes for a project.\n\nTell Xcode where to run your app\n\nWhen you select a scheme to build, you also select a destination where you run the built products. Each scheme contains a list of real or simulated devices that represent the available destinations. To select a destination, click the destination name, which is next to the scheme name in the toolbar. Select an appropriate device from the pop-up menu.\n\nChoose a destination that gives you the capabilities you need. For Mac products, select My Mac. For other platforms, if the app doesn’t require actual hardware, you can choose a simulator to test features quickly on your Mac. If your app requires actual hardware, or you’re ready to see how your app behaves in real conditions, select a real device.\n\nImportant\n\nBefore you ship any code, test and gather metrics on real devices. Simulators offer quick turnaround times during development, but they don’t simulate the actual performance of target devices.\n\nBuild, run, and debug your app\n\nTo build and run your code, choose Product > Run, or click the Run button in your project’s toolbar.\n\nXcode analyzes your scheme’s targets and builds them in the proper sequence. After a successful build, Xcode launches the associated app. If you enabled the Debug executable option in your scheme, Xcode attaches the debugger to the app immediately after launch. To build a scheme without running the app, select Product > Build instead.\n\nIf Xcode encounters an error during a build, Xcode reports the error in the Issue navigator and stops. If you enable the “Continue building after errors” setting in the General tab of Xcode preferences, Xcode continues to build and report errors for the rest of your project’s files. To stop an in-progress build, select Product > Stop, or click the Stop button in your project’s toolbar.\n\nA scheme’s build configuration determines how Xcode launches the product. For a scheme that builds an app, Xcode launches the app itself. For other products, you specify the app to launch using the scheme editor. You can also use the scheme editor to specify launch arguments, runtime data, and debugging parameters.\n\nSee Also\nEssentials\nCreating an Xcode project for an app\nStart developing your app by creating an Xcode project from a template.\nCreating your app’s interface with SwiftUI\nDevelop apps in SwiftUI with an interactive preview that keeps the code and layout in sync.\nPreviewing your app’s interface in Xcode\nIterate designs quickly and preview your apps’ displays across different Apple devices."
  },
  {
    "title": "Creating an Xcode project for an app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-an-xcode-project-for-an-app",
    "html": "Overview\n\nTo create an Xcode project for your app, choose a template for the platform on which your app will run, and select the type of app you wish to develop, such as a single view, game, or document-based for iOS. Xcode templates include essential project configuration and files that help you start developing your app quickly.\n\nPrepare configuration information\n\nBefore you create a project, collect the information that Xcode needs to identify your app and you as a developer:\n\nProduct name. The name of your app as it will appear in the App Store and appear on a device when installed. The product name must be at least 2 characters and no more than 255 bytes, and should be similar to the app name that you enter later in App Store Connect.\n\nOrganization identifier. A reverse DNS string that uniquely identifies your organization. If you don’t have a company identifier, use com.example. followed by your organization name, and replace it before you distribute your app.\n\nOrganization name. The name that appears in boilerplate text throughout your project folder. For example, the source and header file copyright strings contain the organization name. The organization name in your project isn’t the same as the organization name that appears in the App Store.\n\nImportant\n\nThe organization identifier is part of the bundle ID (CFBundleIdentifier) by default. Xcode uses the bundle ID to register an App ID when you first run your app on a device. The number of App IDs are limited if you are not a member of the Apple Developer Program, and you can’t change the App ID after you upload a build to App Store Connect, so choose the organization identifier carefully.\n\nCreate a project\n\nLaunch Xcode, then click “Create a new Xcode project” in the Welcome to Xcode window or choose File > New > Project. In the sheet that appears, select the target operating system or platform and a template under Application. In the following sheets, fill out the forms and choose options to configure your project.\n\nYou must provide a product name and organization identifier because they are used to create the bundle identifier that identifies your app throughout the system. Also enter an organization name. If you don’t belong to an organization, enter your name.\n\nTo develop for all platforms and see an interactive preview of your layout, choose SwiftUI as the user interface before you click Next on this sheet.\n\nManage files in the main window\n\nWhen you create a project or open an existing project, the main window appears, showing the necessary files and resources for developing your app.\n\nYou can access different parts of your project from the navigator area in the main window. Use the project navigator to select files you want to edit in the editor area. For example, when you select a Swift file in the project navigator, the file opens in the source editor, where you can modify the code and set breakpoints.\n\nDetails about the selected file also appear in the inspector area on the right. In the inspector area, you can select the Attributes inspector to edit properties of a file or user interface element. If you want to hide the inspector to make more room for the editor, click the “Hide or show the Inspectors” button in the upper-right corner of the toolbar.\n\nYou use the toolbar to build and run your app on a simulated or real device. For iOS apps, choose the app target and a simulator or device from the run destination menu in the toolbar, then click the Run button.\n\nFor macOS apps, just click the Run button. When your app launches, the debug area opens, where you can control the execution of your app and inspect variables. When the app stops at the breakpoint, use the controls in the debug area to step through the code or continue execution. When you are done running the app, click the Stop button in the toolbar.\n\nIf you use SwiftUI, you can see an interactive preview of the user interface while you create your app. Xcode keeps the changes you make in the source file, the canvas on the right, and the inspector in sync. You can use the controls in the preview to run the app with the debugger, too. For details, see Creating your app’s interface with SwiftUI.\n\nTo change properties you entered when creating your project, select the project name in the project navigator that appears at the top, then the project editor opens in the editor area. Most of the properties you entered appear on the General pane of the project editor.\n\nSee Also\nEssentials\nCreating your app’s interface with SwiftUI\nDevelop apps in SwiftUI with an interactive preview that keeps the code and layout in sync.\nPreviewing your app’s interface in Xcode\nIterate designs quickly and preview your apps’ displays across different Apple devices.\nBuilding and running an app\nCompile your source files and assemble an app bundle to run on a device or simulator."
  },
  {
    "title": "Creating your app’s interface with SwiftUI | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/creating-your-app-s-interface-with-swiftui",
    "html": "Overview\n\nIf you choose the SwiftUI framework to develop your app, you can see an interactive preview as you lay out your user interface. Xcode keeps the changes you make to the source code, the user interface layout, and the inspector in sync. For example, when you edit attributes in the inspector, Xcode adds the corresponding code to the source file.\n\nDisplay the SwiftUI preview\n\nTo show the preview, select a file that uses SwiftUI in the project navigator, and choose Editor > Canvas. Then click the Resume button in the upper-right corner of the canvas to start the preview. Xcode builds and runs the code, displaying the results directly in the canvas.\n\nUse the controls at the bottom of the preview to run the app on a simulated device in the canvas, with or without a debug session, or run the app on a connected device.\n\nAdd views and modifiers\n\nTo add views and modifiers to your app, click the Library button (+) in the toolbar to open the library, then drag user interface elements from the library to either the canvas or source code. Regardless of where you drop the elements, Xcode keeps the source code and the layout in sync.\n\nEdit user interface elements\n\nEdit element attributes using either the Action menu or the inspector, or by entering code in the source editor. Command-click the element in the canvas or the structure in the code, choose Show SwiftUI Inspector from the Action menu, then change the attributes in the next pane. Alternatively, choose View > Inspectors > Show Attributes Inspector, and change the attributes in the Attributes inspector that appears on the right.\n\nEmbed user interface elements\n\nAdditionally, you can modify the user interface by embedding elements in other structures. Command-click an element in the source code or in the canvas, then choose an “Embed in [Generic Structure]” action from the pop-up menu. For example, choose “Embed in HStack” to embed an element that arranges a view’s children in a horizontal line.\n\nTo learn more about SwiftUI, go to Introducing SwiftUI.\n\nSee Also\nEssentials\nCreating an Xcode project for an app\nStart developing your app by creating an Xcode project from a template.\nPreviewing your app’s interface in Xcode\nIterate designs quickly and preview your apps’ displays across different Apple devices.\nBuilding and running an app\nCompile your source files and assemble an app bundle to run on a device or simulator."
  },
  {
    "title": "Performance and metrics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/performance-and-metrics",
    "html": "Topics\nEssentials\nImproving your app’s performance\nModel, measure, and boost the performance of your app by using a continuous-improvement cycle.\nAnalyzing the performance of your shipping app\nView power and performance metrics for apps you distribute through the App Store.\nCreating a performance plan for your visionOS app\nIdentify your app’s performance and power goals and create a plan to measure and assess them.\nResponsiveness\nImproving app responsiveness\nCreate a user experience that feels responsive by removing hangs and hitches from your app.\nUnderstanding user interface responsiveness\nMake your app more responsive by examining the event-handling and rendering loop.\nUnderstanding hangs in your app\nDetermine the cause for delays in user interactions by examining the main thread and the main run loop.\nDiagnosing performance issues early\nDiagnose potential performance issues in your app during testing with the Thread Performance Checker tool in Xcode.\nReducing your app’s launch time\nCreate a more responsive experience with your app by minimizing time spent in startup.\nReducing terminations in your app\nMinimize how frequently the system stops your app by addressing common termination reasons.\nReducing disk writes\nImprove your app’s responsiveness by optimizing how it writes data to permanent storage.\nMemory and size\nReducing your app’s memory use\nImprove your app’s performance by analyzing memory-use metrics and making changes to maximize memory efficiency.\nReducing your app’s size\nMeasure your app’s size, optimize its assets and settings, and adopt technologies that help streamline installation over a mobile internet connection.\nGathering information about memory use\nIdentify memory-use inefficiencies by measuring and profiling your app.\nMaking changes to reduce memory use\nDecrease your app’s use of memory by addressing common causes of excessive use.\nPreventing memory-use regressions\nMeasure the memory that your app’s features use, and detect increases by using XCTest performance tests.\nResponding to low-memory warnings\nDetect when your app is using excessive memory, and bring memory use under control.\nGraphics\nAnalyzing the performance of your Metal app\nEnsure consistent, smooth rendering by profiling your app’s frame time.\nAnalyzing the memory usage of your Metal app\nKeep your app alive in the background by managing its memory footprint.\nPower\nAnalyzing your app’s battery use\nIncrease the available use time for your app on a single battery charge by reducing your appʼs power consumption.\nNetwork\nAnalyzing HTTP traffic with Instruments\nMeasure HTTP-based network performance and usage of your apps.\nCustom instruments\nCreating Custom Modelers for Intelligent Instruments\nCreate Custom Modelers with the CLIPS language and learn how the embedded rules engine works.\nSee Also\nTuning and debugging\nDevices and Simulator\nConfigure and manage devices connected to your Mac or devices in Simulator and use them to run your app.\nDebugging\nIdentify and address issues in your app using the Xcode debugger, Xcode Organizer, Metal debugger, and Instruments.\nTest coverage\nDevelop and run tests to detect logic failures, UI problems, and performance regressions."
  },
  {
    "title": "Debugging | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/xcode/debugging",
    "html": "Topics\nEssentials\nDiagnosing and resolving bugs in your running app\nInspect your app to isolate bugs, locate crashes, identify excess system-resource usage, visualize memory bugs, and investigate problems in its appearance.\nDebugging strategies\nDiagnosing issues in the appearance of a running app\nInspect your running app to investigate issues in the appearance and placement of the content it displays.\nDiagnosing memory, thread, and crash issues early\nIdentify runtime crashes and undefined behaviors in your app during testing using Xcode’s sanitizer tools.\nAnalyzing HTTP traffic with Instruments\nMeasure HTTP-based network performance and usage of your apps.\nDetecting when your app contacts domains that may be profiling users\nUse Instruments to assess whether your app or its third-party SDKs connect to domains that may profile users.\nGraphics\nMetal developer workflows\nLocate and fix issues related to your app’s use of the Metal API and GPU functions.\nMetal debugger\nDebug and profile your Metal workload with a GPU trace.\nBreakpoints and variables\nSetting breakpoints to pause your running app\nSpecify where your app pauses when running the debugger to investigate bugs.\nStepping through code and inspecting variables to isolate bugs\nFind the cause of your bugs by watching variables change as you step through your source code in the debugger.\nReports\nBuilding your app to include debugging information\nConfigure Xcode to produce the symbol information for debugging and crash reports.\nDiagnosing issues using crash reports and device logs\nUse crash reports and device logs to debug app issues.\nEntitlements\nDiagnosing Issues with Entitlements\nVerify your app’s entitlements at every stage of development to track down errors during distribution.\nSee Also\nTuning and debugging\nDevices and Simulator\nConfigure and manage devices connected to your Mac or devices in Simulator and use them to run your app.\nPerformance and metrics\nMeasure, investigate, and address the use of system resources and issues impacting performance using Instruments and Xcode Organizer.\nTest coverage\nDevelop and run tests to detect logic failures, UI problems, and performance regressions."
  },
  {
    "title": "Xcode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Xcode",
    "html": "Overview\n\nXcode is a suite of tools developers use to build apps for Apple platforms. Use Xcode to manage your entire development workflow — from creating your app to testing, optimizing, and submitting it to the App Store.\n\nXcode includes a world-class code editor, built in SwiftUI preview tools that show the UI of your app as you modify code, and a powerful debugger with conditional breakpoints.\n\nXcode also includes several development tools to help you rapidly prototype and test your app. Use Simulator for rapid prototyping and testing your app in a simulated environment when a real device isn’t available. Use Instruments to profile and analyze your app, improve performance, and investigate system resource usage. Construct 3D content with Reality Composer, train custom machine learning models with Create ML, and identify areas of your app that aren’t accessible with Accessiblity Inspector.\n\nNote\n\nDownload the latest version of Xcode from the Mac App Store. Download beta versions of Xcode from the Apple Developer website.\n\nTopics\nEssentials\nCreating an Xcode project for an app\nStart developing your app by creating an Xcode project from a template.\nCreating your app’s interface with SwiftUI\nDevelop apps in SwiftUI with an interactive preview that keeps the code and layout in sync.\nPreviewing your app’s interface in Xcode\nIterate designs quickly and preview your apps’ displays across different Apple devices.\nBuilding and running an app\nCompile your source files and assemble an app bundle to run on a device or simulator.\nXcode updates\nLearn about important changes to Xcode.\nXcode IDE\nProjects and workspaces\nManage the code and resources you use to build apps, libraries, and other software for Apple platforms.\nSource control management\nBack up your files, collaborate with others, and tag your releases with source control support in Xcode.\nCapabilities\nEnable services that Apple provides, such as In-App Purchase, Push Notifications, Apple Pay, iCloud, and many others.\nBuild system\nCompile your code into a binary format, and customize your project settings to build your code.\nCode\nSource Editor\nEdit your source files, locate issues, and make necessary changes using the Source Editor.\nBundles and frameworks\nOrganize code and resources in bundles and frameworks.\nSwift packages\nCreate reusable code, organize it in a lightweight way, and share it across Xcode projects and with other developers.\nInterface\nAsset management\nAdd images, strings, data files, and other resources to your projects, and manage how you load them at runtime.\nLocalization\nExpand the market for your app by supporting multiple languages and regions.\nAccessibility Inspector\nReveal how your app represents itself to people using accessibility features.\nDocumentation\nWriting documentation\nProduce rich and engaging developer documentation for your apps, frameworks, and packages.\nTuning and debugging\nDevices and Simulator\nConfigure and manage devices connected to your Mac or devices in Simulator and use them to run your app.\nDebugging\nIdentify and address issues in your app using the Xcode debugger, Xcode Organizer, Metal debugger, and Instruments.\nPerformance and metrics\nMeasure, investigate, and address the use of system resources and issues impacting performance using Instruments and Xcode Organizer.\nTest coverage\nDevelop and run tests to detect logic failures, UI problems, and performance regressions.\nDistribution and continuous integration\nDistribution\nPrepare you app and share it with your team, beta testers, and customers.\nXcode Cloud\nAutomatically build, test, and distribute your apps with Xcode Cloud to verify changes and create high-quality apps.\nHardware considerations\nApple Silicon\nGet the resources you need to create software for Macs with Apple silicon.\nApplication binary interfaces\nWrite assembly instructions that adhere to the application binary interfaces of Apple platforms."
  }
]