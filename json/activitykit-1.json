[
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/compactmap(_:)-9ft2b",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/flatmap(_:)-65g9v",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/flatmap(_:)-2drkd",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/flatmap(_:)-76w7z",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/compactmap(_:)-4qjwp",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/map(_:)-1532l",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/compactmap(_:)-676r0",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/compactmap(_:)-7ufl4",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/flatmap(_:)-2vgc2",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/map(_:)-9lpm0",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/map(_:)-63nss",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/flatmap(_:)-352or",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/map(_:)-73943",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/map(_:)-3uc6m",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/flatmap(_:)-69tf6",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/flatmap(_:)-7f4lc",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/compactmap(_:)-6mtmy",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/compactmap(_:)-4a4iy",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "ActivityAuthorizationInfo.ActivityEnablementUpdates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> Bool?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> ActivityAuthorizationInfo.ActivityEnablementUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/map(_:)-28ekb",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/makeasynciterator()",
    "html": "See Also\nCreating an iterator\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "ActivityAuthorizationInfo.ActivityEnablementUpdates.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> ActivityAuthorizationInfo.ActivityEnablementUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series."
  },
  {
    "title": "AsyncSequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "ActivityAuthorizationInfo.FrequentPushEnablementUpdates.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> ActivityAuthorizationInfo.FrequentPushEnablementUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/makeasynciterator()",
    "html": "See Also\nCreating an iterator\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "ActivityAuthorizationInfo.FrequentPushEnablementUpdates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> Bool?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> ActivityAuthorizationInfo.FrequentPushEnablementUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "AsyncSequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/map(_:)-1jebs",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/flatmap(_:)-94oio",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/map(_:)-1o7yj",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/map(_:)-9weri",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/compactmap(_:)-3evj7",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/compactmap(_:)-5yil8",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/compactmap(_:)-9hd9f",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/map(_:)-2zlx",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/flatmap(_:)-3yr22",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/map(_:)-5dpe2",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "AsyncSequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Activity.ActivityUpdates.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ActivityUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/flatmap(_:)-8g7mq",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/map(_:)-1rmpg",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/compactmap(_:)-2mrai",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/compactmap(_:)-8g6ul",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/flatmap(_:)-9h2ls",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/compactmap(_:)-3h804",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/flatmap(_:)-3borw",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/map(_:)-71j1s",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/map(_:)-2h564",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/alertsound/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "default | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/alertsound/default",
    "html": "See Also\nConfiguring the alert sound\nstatic func named(String) -> AlertConfiguration.AlertSound\nA function you use to configure a custom sound for a Live Activity update alert."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/alertsound/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "Activity.ContentUpdates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> Activity<Attributes>.ContentUpdates.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol"
  },
  {
    "title": "named(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/alertsound/named(_:)",
    "html": "Parameters\nname\n\nThe name of the sound file to use for the alert. Choose a file that’s in your app’s main bundle or the Library/Sounds folder of your app’s data container.\n\nSee Also\nConfiguring the alert sound\nstatic var `default`: AlertConfiguration.AlertSound\nA value that represents the system’s default alert sound."
  },
  {
    "title": "LocalizedError Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/localizederror-implementations",
    "html": "Topics\nInstance Properties\nvar errorDescription: String?\nA localized message describing what error occurred.\nvar helpAnchor: String?\nA localized message providing “help” text if the user requests help."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitycontent/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "body | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/body",
    "html": "Discussion\n\nApple Watch displays this string briefly as part of the alert that appears when you update a Live Activity and choose to alert people about the update. Choose text that’s easy to read at a glance. For example, a pizza delivery app could use “Your order will arrive in 25 minutes.”\n\nSee Also\nConfiguring Live Activity alerts\ninit(title: LocalizedStringResource, body: LocalizedStringResource, sound: AlertConfiguration.AlertSound)\nInitializes a new alert configuration for a Live Activity update.\nvar title: LocalizedStringResource\nA short title that describes the purpose of the Live Activity update on Apple Watch.\nvar sound: AlertConfiguration.AlertSound\nThe sound the system plays when the Live Activity alert appears on a person’s device.\nstruct AlertSound\nAn object that describes the sound to play for a Live Activity update alert."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/compactmap(_:)-3e6k6",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/compactmap(_:)-41orc",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/flatmap(_:)-4bufz",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/flatmap(_:)-2f0fb",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "title | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/title",
    "html": "Discussion\n\nApple Watch displays this string briefly as part of the alert that appears when you update a Live Activity and choose to alert people about the update. Choose text that’s easy to read at a glance. For example, a pizza delivery app could use “On the way.”\n\nSee Also\nConfiguring Live Activity alerts\ninit(title: LocalizedStringResource, body: LocalizedStringResource, sound: AlertConfiguration.AlertSound)\nInitializes a new alert configuration for a Live Activity update.\nvar body: LocalizedStringResource\nThe main text that appears on the alert for a Live Activity update on Apple Watch.\nvar sound: AlertConfiguration.AlertSound\nThe sound the system plays when the Live Activity alert appears on a person’s device.\nstruct AlertSound\nAn object that describes the sound to play for a Live Activity update alert."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "ActivityAuthorizationInfo.ActivityEnablementUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.struct",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> ActivityAuthorizationInfo.ActivityEnablementUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nObserving Live Activity permission changes\nvar areActivitiesEnabled: Bool\nA Boolean value that indicates whether your app can start a Live Activity.\nlet activityEnablementUpdates: ActivityAuthorizationInfo.ActivityEnablementUpdates\nAn asynchronous sequence you use to observe whether your app can start a Live Activity.\ninit()\nCreates an object you use to observe user authorizations for starting Live Activities and updating them with ActivityKit push notifications."
  },
  {
    "title": "ActivityAuthorizationInfo.FrequentPushEnablementUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.struct",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> ActivityAuthorizationInfo.FrequentPushEnablementUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nObserving availability of frequent ActivityKit push notifications\nvar frequentPushesEnabled: Bool\nA Boolean value that indicates whether a person permitted you to update Live Activities with frequent ActivityKit push notifications.\nlet frequentPushEnablementUpdates: ActivityAuthorizationInfo.FrequentPushEnablementUpdates\nAn asynchronous sequence you use to observe whether a person permitted you to update Live Activities with frequent ActivityKit push notifications."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityuidismissalpolicy/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityuidismissalpolicy/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/init()",
    "html": "See Also\nObserving Live Activity permission changes\nvar areActivitiesEnabled: Bool\nA Boolean value that indicates whether your app can start a Live Activity.\nlet activityEnablementUpdates: ActivityAuthorizationInfo.ActivityEnablementUpdates\nAn asynchronous sequence you use to observe whether your app can start a Live Activity.\nstruct ActivityEnablementUpdates\nA structure that offers functionality to observe whether your app can start a Live Activity."
  },
  {
    "title": "ActivityAuthorizationError.persistenceFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/persistencefailure",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "ActivityAuthorizationError.reconnectNotPermitted | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/reconnectnotpermitted",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "activityEnablementUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/activityenablementupdates-swift.property",
    "html": "See Also\nObserving Live Activity permission changes\nvar areActivitiesEnabled: Bool\nA Boolean value that indicates whether your app can start a Live Activity.\nstruct ActivityEnablementUpdates\nA structure that offers functionality to observe whether your app can start a Live Activity.\ninit()\nCreates an object you use to observe user authorizations for starting Live Activities and updating them with ActivityKit push notifications."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future.\n\nSee Also\nHashing\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.\n\nSee Also\nEncoding and decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "previewContext(_:isStale:viewKind:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityattributes/previewcontext(_:isstale:viewkind:)",
    "html": "Parameters\ncontentState\n\nThe dynamic content of the Live Activity.\n\nisStale\n\nA Boolean that indicates whether the content of a Live Activity is out of date.\n\nviewKind\n\nA value that determines which Live Activity presentation to render for this preview."
  },
  {
    "title": "ContentState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityattributes/contentstate",
    "html": "Required\n\nDiscussion\n\nThe dynamic data of a Live Activity that’s encoded by ContentState can’t exceed 4KB."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "AsyncSequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "AsyncSequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Activity.ActivityStateUpdates.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ActivityStateUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/makeasynciterator()",
    "html": "See Also\nCreating an iterator\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "Activity.ContentStateUpdates.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ContentStateUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series."
  },
  {
    "title": "Activity.ActivityStateUpdates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> Activity<Attributes>.ActivityStateUpdates.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ActivityStateUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "AsyncSequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Properties\nvar characters: AsyncCharacterSequence<Self>\nA non-blocking sequence of Characters created by decoding the elements of self as UTF8.\nAvailable when Element is UInt8.\nvar lines: AsyncLineSequence<Self>\nA non-blocking sequence of newline-separated Strings created by decoding the elements of self as UTF8.\nAvailable when Element is UInt8.\nvar unicodeScalars: AsyncUnicodeScalarSequence<Self>\nA non-blocking sequence of UnicodeScalars created by decoding the elements of self as UTF8.\nAvailable when Element is UInt8.\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max() async rethrows -> Self.Element?\nReturns the maximum element in an asynchronous sequence of comparable elements.\nAvailable when Element conforms to Comparable.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min() async rethrows -> Self.Element?\nReturns the minimum element in an asynchronous sequence of comparable elements.\nAvailable when Element conforms to Comparable.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/makeasynciterator()",
    "html": "See Also\nCreating an iterator\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "AsyncSequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Activity.ContentStateUpdates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> Activity<Attributes>.ContentStateUpdates.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ContentStateUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "AlertConfiguration.AlertSound | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/alertsound",
    "html": "Topics\nConfiguring the alert sound\nstatic func named(String) -> AlertConfiguration.AlertSound\nA function you use to configure a custom sound for a Live Activity update alert.\nstatic var `default`: AlertConfiguration.AlertSound\nA value that represents the system’s default alert sound.\nOperators\nstatic func == (AlertConfiguration.AlertSound, AlertConfiguration.AlertSound) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSee Also\nConfiguring Live Activity alerts\ninit(title: LocalizedStringResource, body: LocalizedStringResource, sound: AlertConfiguration.AlertSound)\nInitializes a new alert configuration for a Live Activity update.\nvar title: LocalizedStringResource\nA short title that describes the purpose of the Live Activity update on Apple Watch.\nvar body: LocalizedStringResource\nThe main text that appears on the alert for a Live Activity update on Apple Watch.\nvar sound: AlertConfiguration.AlertSound\nThe sound the system plays when the Live Activity alert appears on a person’s device."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "sound | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/sound",
    "html": "See Also\nConfiguring Live Activity alerts\ninit(title: LocalizedStringResource, body: LocalizedStringResource, sound: AlertConfiguration.AlertSound)\nInitializes a new alert configuration for a Live Activity update.\nvar title: LocalizedStringResource\nA short title that describes the purpose of the Live Activity update on Apple Watch.\nvar body: LocalizedStringResource\nThe main text that appears on the alert for a Live Activity update on Apple Watch.\nstruct AlertSound\nAn object that describes the sound to play for a Live Activity update alert."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/pushtype/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "Error Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/error-implementations",
    "html": "Topics\nInstance Properties\nvar localizedDescription: String\nRetrieve the localized description for this error."
  },
  {
    "title": "init(title:body:sound:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration/init(title:body:sound:)",
    "html": "Parameters\ntitle\n\nThe short title that describes the purpose of the Live Activity update.\n\nbody\n\nThe main text of the alert for a Live Activity update.\n\nsound\n\nThe sound that the system plays when the alert appears on a person’s device.\n\nSee Also\nConfiguring Live Activity alerts\nvar title: LocalizedStringResource\nA short title that describes the purpose of the Live Activity update on Apple Watch.\nvar body: LocalizedStringResource\nThe main text that appears on the alert for a Live Activity update on Apple Watch.\nvar sound: AlertConfiguration.AlertSound\nThe sound the system plays when the Live Activity alert appears on a person’s device.\nstruct AlertSound\nAn object that describes the sound to play for a Live Activity update alert."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "CustomNSError Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/customnserror-implementations",
    "html": "Topics\nInstance Properties\nvar errorUserInfo: [String : Any]\nThe default user-info dictionary.\nType Properties\nstatic var errorDomain: String\nDefault domain of the error."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/pushtype/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "errorCode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/errorcode",
    "html": "See Also\nProtocol confirmation\nstatic var errorDomain: String\nThe domain for errors that can happen when starting a Live Activity."
  },
  {
    "title": "ActivityAuthorizationError.visibility | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/visibility",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities."
  },
  {
    "title": "errorDomain | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/errordomain-8mhmu",
    "html": "See Also\nProtocol confirmation\nvar errorCode: Int\nAn integer value that represents the error code."
  },
  {
    "title": "ActivityAuthorizationError.unsupported | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/unsupported",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "ActivityAuthorizationError.unentitled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/unentitled",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "ActivityAuthorizationError.unsupportedTarget | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/unsupportedtarget",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "ActivityAuthorizationError.targetMaximumExceeded | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/targetmaximumexceeded",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "ActivityAuthorizationError.missingProcessIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/missingprocessidentifier",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "ActivityAuthorizationError.globalMaximumExceeded | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/globalmaximumexceeded",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "ActivityAuthorizationError.malformedActivityIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/malformedactivityidentifier",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "state | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitycontent/state",
    "html": "Discussion\n\nThis value is the same as activityState.\n\nSee Also\nDescribing a Live Activity\ninit(state: State, staleDate: Date?, relevanceScore: Double)\nCreates the object that describes the state and configuration of a Live Activity.\nlet staleDate: Date?\nThe date when the system considers the Live Activity to be out of date.\nlet relevanceScore: Double\nA score you assign that determines the order in which your Live Activities appear when you start several Live Activities for your app."
  },
  {
    "title": "ActivityAuthorizationError.attributesTooLarge | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/attributestoolarge",
    "html": "See Also\nError codes\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "init(state:staleDate:relevanceScore:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitycontent/init(state:staledate:relevancescore:)",
    "html": "See Also\nDescribing a Live Activity\nlet state: State\nThe current state of a Live Activity in its life cycle.\nlet staleDate: Date?\nThe date when the system considers the Live Activity to be out of date.\nlet relevanceScore: Double\nA score you assign that determines the order in which your Live Activities appear when you start several Live Activities for your app."
  },
  {
    "title": "CustomStringConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitycontent/customstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar description: String\nA textual representation of this instance.\nAvailable when State conforms to Decodable, Encodable, and Hashable."
  },
  {
    "title": "immediate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityuidismissalpolicy/immediate",
    "html": "Discussion\n\nWith the immediate dismissal policy, the system immediately removes the ended Live Activity and the ActivityState changes to ActivityState.dismissed.\n\nSee Also\nDismissing a Live Activity\nstatic let `default`: ActivityUIDismissalPolicy\nThe system’s default dismissal policy for the Live Activity.\nstatic func after(Date) -> ActivityUIDismissalPolicy\nThe system removes the Live Activity that ended at the specified time within a four-hour window."
  },
  {
    "title": "relevanceScore | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitycontent/relevancescore",
    "html": "Discussion\n\nIf you start more than one Live Activity in your app, the Live Activity with the highest relevance score appears in the Dynamic Island. If Live Activities have the same relevance score, the system displays the Live Activity that started first. Additionally, the relevanceScore determines the order of your Live Activities on the Lock Screen.\n\nSee Also\nDescribing a Live Activity\ninit(state: State, staleDate: Date?, relevanceScore: Double)\nCreates the object that describes the state and configuration of a Live Activity.\nlet state: State\nThe current state of a Live Activity in its life cycle.\nlet staleDate: Date?\nThe date when the system considers the Live Activity to be out of date."
  },
  {
    "title": "staleDate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitycontent/staledate",
    "html": "Discussion\n\nWhen time reaches the configured stale date, the system considers the Live Activity out of date, and the ActivityState of the Live Activity changes to ActivityState.stale.\n\nSee Also\nDescribing a Live Activity\ninit(state: State, staleDate: Date?, relevanceScore: Double)\nCreates the object that describes the state and configuration of a Live Activity.\nlet state: State\nThe current state of a Live Activity in its life cycle.\nlet relevanceScore: Double\nA score you assign that determines the order in which your Live Activities appear when you start several Live Activities for your app."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format.\n\nSee Also\nEncoding and decoding\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "ActivityState.ended | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/ended",
    "html": "See Also\nLive Activity states\ncase active\nThe Live Activity is active, visible, and can receive content updates.\ncase dismissed\nThe Live Activity ended and is no longer visible because a person or the system removed it.\ncase stale\nThe Live Activity content is out of date and needs an update."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you.\n\nSee Also\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/makeasynciterator()",
    "html": "See Also\nCreating an iterator\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/makeasynciterator()",
    "html": "See Also\nCreating an iterator\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "Activity.PushTokenUpdates.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.PushTokenUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series."
  },
  {
    "title": "Activity.PushTokenUpdates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> Activity<Attributes>.PushTokenUpdates.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.PushTokenUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "Activity.ActivityUpdates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> Activity<Attributes>.ActivityUpdates.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ActivityUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "failureReason | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/failurereason",
    "html": "See Also\nGetting error information\nvar recoverySuggestion: String?\nA localized message that describes how to recover from the error."
  },
  {
    "title": "update(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/update(_:)",
    "html": "Parameters\ncontent\n\nThe updated dynamic content for the Live Activity. The size of its state property can’t exceed 4KB in size.\n\nDiscussion\n\nUse this function to update the Live Activity while your app is in the foreground or while it’s in the background — for example, by using Background Tasks.\n\nNote\n\nThe system ignores attempts to update a Live Activity that ended.\n\nSee Also\nUpdating a Live Activity\nfunc update(ActivityContent<Activity<Attributes>.ContentState>, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update.\nstruct AlertConfiguration\nA structure you use to configure an alert that appears when you update your Live Activity.\nfunc update(using: Activity<Attributes>.ContentState) async\nUpdates the dynamic content of the Live Activity.\nfunc update(using: Activity<Attributes>.ContentState, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "ActivityAuthorizationError.denied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/denied",
    "html": "See Also\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background."
  },
  {
    "title": "contentState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstate-swift.property",
    "html": "See Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity."
  },
  {
    "title": "recoverySuggestion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror/recoverysuggestion",
    "html": "See Also\nGetting error information\nvar failureReason: String?\nA string that describes the error that occurred."
  },
  {
    "title": "after(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityuidismissalpolicy/after(_:)",
    "html": "Parameters\ndate\n\nA date within a four-hour window from the moment the Live Activity ends.\n\nDiscussion\n\nProvide a date to tell the system when it should remove a Live Activity that ended. While you can provide any date, the system removes a Live Activity that ended after the specified date or after four hours from the moment the Live Activity ended — whichever comes first. When the system removes the Live Activity, the ActivityState changes to ActivityState.dismissed.\n\nSee Also\nDismissing a Live Activity\nstatic let `default`: ActivityUIDismissalPolicy\nThe system’s default dismissal policy for the Live Activity.\nstatic let immediate: ActivityUIDismissalPolicy\nThe system immediately removes the Live Activity that ended."
  },
  {
    "title": "ActivityState.dismissed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/dismissed",
    "html": "See Also\nLive Activity states\ncase active\nThe Live Activity is active, visible, and can receive content updates.\ncase stale\nThe Live Activity content is out of date and needs an update.\ncase ended\nThe Live Activity is visible, but a person, app, or system ended it, and it won’t update its content anymore."
  },
  {
    "title": "ActivityState.active | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/active",
    "html": "See Also\nLive Activity states\ncase dismissed\nThe Live Activity ended and is no longer visible because a person or the system removed it.\ncase stale\nThe Live Activity content is out of date and needs an update.\ncase ended\nThe Live Activity is visible, but a person, app, or system ended it, and it won’t update its content anymore."
  },
  {
    "title": "default | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityuidismissalpolicy/default",
    "html": "Discussion\n\nWith the default dismissal policy, the system keeps a Live Activity that ended on the Lock Screen for up to four hours after it ends or a person removes it. The ActivityState doesn’t change to ActivityState.dismissed until a person or the system removes the Live Activity user interface.\n\nSee Also\nDismissing a Live Activity\nstatic let immediate: ActivityUIDismissalPolicy\nThe system immediately removes the Live Activity that ended.\nstatic func after(Date) -> ActivityUIDismissalPolicy\nThe system removes the Live Activity that ended at the specified time within a four-hour window."
  },
  {
    "title": "areActivitiesEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/areactivitiesenabled",
    "html": "See Also\nObserving Live Activity permission changes\nlet activityEnablementUpdates: ActivityAuthorizationInfo.ActivityEnablementUpdates\nAn asynchronous sequence you use to observe whether your app can start a Live Activity.\nstruct ActivityEnablementUpdates\nA structure that offers functionality to observe whether your app can start a Live Activity.\ninit()\nCreates an object you use to observe user authorizations for starting Live Activities and updating them with ActivityKit push notifications."
  },
  {
    "title": "frequentPushEnablementUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushenablementupdates-swift.property",
    "html": "See Also\nObserving availability of frequent ActivityKit push notifications\nvar frequentPushesEnabled: Bool\nA Boolean value that indicates whether a person permitted you to update Live Activities with frequent ActivityKit push notifications.\nstruct FrequentPushEnablementUpdates\nA structure that can observe whether you can update Live Activities with frequent ActivityKit push notifications."
  },
  {
    "title": "frequentPushesEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationinfo/frequentpushesenabled",
    "html": "See Also\nObserving availability of frequent ActivityKit push notifications\nlet frequentPushEnablementUpdates: ActivityAuthorizationInfo.FrequentPushEnablementUpdates\nAn asynchronous sequence you use to observe whether a person permitted you to update Live Activities with frequent ActivityKit push notifications.\nstruct FrequentPushEnablementUpdates\nA structure that can observe whether you can update Live Activities with frequent ActivityKit push notifications."
  },
  {
    "title": "ActivityAttributes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityattributes",
    "html": "Overview\n\nThe ActivityAttributes protocol describes the content that appears in your Live Activity. Its inner type ContentState represents the dynamic content of the Live Activity.\n\nThe following example shows an implementation of the ActivityAttributes protocol for a pizza delivery app. The app’s Live Activity shows the number of ordered pizzas and the total amount on the bill as static data and the name of the driver and an estimated delivery time as dynamic data that changes over time. Note how the implementation defines the type alias PizzaDeliveryStatus to make the code more descriptive and easier to read.\n\nimport Foundation\nimport ActivityKit\n\n\nstruct PizzaDeliveryAttributes: ActivityAttributes {\n    public typealias PizzaDeliveryStatus = ContentState\n\n\n    public struct ContentState: Codable, Hashable {\n        var driverName: String\n        var deliveryTimer: ClosedRange<Date>\n    }\n\n\n    var numberOfPizzas: Int\n    var totalAmount: String\n    var orderNumber: String\n}\n\nTopics\nDynamic content\nassociatedtype ContentState : Decodable, Encodable, Hashable\nThe associated type that describes the dynamic content of a Live Activity.\n\nRequired\n\nInstance Methods\nfunc previewContext(Self.ContentState, isStale: Bool, viewKind: ActivityPreviewViewKind) -> some View\nGenerates a preview for a Live Activity.\nRelationships\nInherits From\nDecodable\nEncodable\nSee Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "activities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activities",
    "html": "See Also\nAccessing Live Activities\nstatic var activityUpdates: Activity<Attributes>.ActivityUpdates\nAn asynchronous sequence you use to observe changes to ongoing Live Activities and to asynchronously access a Live Activity when you start it.\nstruct ActivityUpdates\nA structure that offers functionality to observe changes to a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "Activity.ActivityUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.struct",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ActivityUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nAccessing Live Activities\nstatic var activities: [Activity<Attributes>]\nAn array of your app’s current Live Activities.\nstatic var activityUpdates: Activity<Attributes>.ActivityUpdates\nAn asynchronous sequence you use to observe changes to ongoing Live Activities and to asynchronously access a Live Activity when you start it."
  },
  {
    "title": "activityUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activityupdates-swift.type.property",
    "html": "See Also\nAccessing Live Activities\nstatic var activities: [Activity<Attributes>]\nAn array of your app’s current Live Activities.\nstruct ActivityUpdates\nA structure that offers functionality to observe changes to a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "Activity.PushTokenUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.struct",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.PushTokenUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nUsing ActivityKit push notifications\nvar pushToken: Data?\nThe token you use to send ActivityKit push notifications to a Live Activity.\nvar pushTokenUpdates: Activity<Attributes>.PushTokenUpdates\nAn asynchronous sequence you use to observe changes to the push token of a Live Activity.\nstatic var pushToStartToken: Data?\nstatic var pushToStartTokenUpdates: Activity<Attributes>.PushTokenUpdates"
  },
  {
    "title": "pushToStartToken | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtostarttoken",
    "html": "See Also\nUsing ActivityKit push notifications\nvar pushToken: Data?\nThe token you use to send ActivityKit push notifications to a Live Activity.\nvar pushTokenUpdates: Activity<Attributes>.PushTokenUpdates\nAn asynchronous sequence you use to observe changes to the push token of a Live Activity.\nstruct PushTokenUpdates\nA structure that offers functionality to observe changes to the push token of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nstatic var pushToStartTokenUpdates: Activity<Attributes>.PushTokenUpdates"
  },
  {
    "title": "Activity.ActivityStateUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.struct",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ActivityStateUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nObserving the Live Activity life cycle\nvar activityState: ActivityState\nThe current state of a Live Activity in its life cycle.\nenum ActivityState\nThe enum that describes the state of a Live Activity in its life cycle.\nvar activityStateUpdates: Activity<Attributes>.ActivityStateUpdates\nAn asynchronous sequence you use to observe activity state changes."
  },
  {
    "title": "ActivityState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate",
    "html": "Topics\nLive Activity states\ncase active\nThe Live Activity is active, visible, and can receive content updates.\ncase dismissed\nThe Live Activity ended and is no longer visible because a person or the system removed it.\ncase stale\nThe Live Activity content is out of date and needs an update.\ncase ended\nThe Live Activity is visible, but a person, app, or system ended it, and it won’t update its content anymore.\nEncoding and decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nOperators\nstatic func == (ActivityState, ActivityState) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nDecodable\nEncodable\nEquatable\nHashable\nSendable\nSee Also\nObserving the Live Activity life cycle\nvar activityState: ActivityState\nThe current state of a Live Activity in its life cycle.\nvar activityStateUpdates: Activity<Attributes>.ActivityStateUpdates\nAn asynchronous sequence you use to observe activity state changes.\nstruct ActivityStateUpdates\nA structure that offers functionality to observe state changes of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "contentStateUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.property",
    "html": "See Also\nObserving Live Activity content changes\nvar contentUpdates: Activity<Attributes>.ContentUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity.\nstruct ContentUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nstruct ContentStateUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "Activity.ContentStateUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstateupdates-swift.struct",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> Activity<Attributes>.ContentStateUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nObserving Live Activity content changes\nvar contentUpdates: Activity<Attributes>.ContentUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity.\nstruct ContentUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nvar contentStateUpdates: Activity<Attributes>.ContentStateUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity."
  },
  {
    "title": "Activity.ContentUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.struct",
    "html": "Topics\nStructures\nstruct Iterator\nAn iterator for accessing individual data entries from the series.\nInstance Methods\nfunc makeAsyncIterator() -> Activity<Attributes>.ContentUpdates.Iterator\nCreates the asynchronous iterator that produces results from this asynchronous sequence.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nObserving Live Activity content changes\nvar contentUpdates: Activity<Attributes>.ContentUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity.\nvar contentStateUpdates: Activity<Attributes>.ContentStateUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity.\nstruct ContentStateUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "contentUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentupdates-swift.property",
    "html": "See Also\nObserving Live Activity content changes\nstruct ContentUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nvar contentStateUpdates: Activity<Attributes>.ContentStateUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity.\nstruct ContentStateUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "end(using:dismissalPolicy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/end(using:dismissalpolicy:)",
    "html": "Parameters\ncontentState\n\nThe latest and final dynamic content for the Live Activity that ended. The size of the encoded content can’t exceed 4KB in size.\n\ndismissalPolicy\n\nDescribes how and when the system should dismiss a Live Activity and and remove it from the Lock Screen.\n\nDiscussion\n\nEnd an active Live Activity while your app is in the foreground or while it’s in the background — for example, by using Background Tasks.\n\nInclude updated data in the contentState parameter to ensure the Live Activity shows the latest and final content update after it ends. This is important because the Live Activity remains visible until the system or the person removes it.\n\nSee Also\nEnding a Live Activity\nfunc end(ActivityContent<Activity<Attributes>.ContentState>?, dismissalPolicy: ActivityUIDismissalPolicy) async\nEnds an active Live Activity.\nstruct ActivityUIDismissalPolicy\nThe structure that describes when the system should remove a Live Activity that ended."
  },
  {
    "title": "end(_:dismissalPolicy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/end(_:dismissalpolicy:)",
    "html": "Parameters\ncontent\n\nThe latest and final dynamic content for the Live Activity that ended. The size of the encoded content can’t exceed 4KB in size.\n\ndismissalPolicy\n\nDescribes how and when the system should dismiss a Live Activity and and remove it from the Lock Screen.\n\nDiscussion\n\nEnd an active Live Activity while your app is in the foreground or while it’s in the background — for example, by using Background Tasks. When you end a Live Activity, include a final content update using the content parameter to ensure the Live Activity shows the latest and final content update after it ends. This is important because the Live Activity may remain visible until the system or the person removes it.\n\nSee Also\nEnding a Live Activity\nstruct ActivityUIDismissalPolicy\nThe structure that describes when the system should remove a Live Activity that ended.\nfunc end(using: Activity<Attributes>.ContentState?, dismissalPolicy: ActivityUIDismissalPolicy) async\nEnds an active Live Activity."
  },
  {
    "title": "update(using:alertConfiguration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/update(using:alertconfiguration:)",
    "html": "Parameters\ncontentState\n\nThe updated dynamic content for the Live Activity. The size of the encoded content can’t exceed 4KB in size.\n\nalertConfiguration\n\nThe alert configuration you use to configure how the system notifies a person about the updated content of the Live Activity.\n\nDiscussion\n\nThe system ignores updates to a Live Activity that’s in the ActivityState.ended state.\n\nSee Also\nUpdating a Live Activity\nfunc update(ActivityContent<Activity<Attributes>.ContentState>) async\nUpdates the dynamic content of the Live Activity.\nfunc update(ActivityContent<Activity<Attributes>.ContentState>, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update.\nstruct AlertConfiguration\nA structure you use to configure an alert that appears when you update your Live Activity.\nfunc update(using: Activity<Attributes>.ContentState) async\nUpdates the dynamic content of the Live Activity."
  },
  {
    "title": "update(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/update(using:)",
    "html": "Parameters\ncontentState\n\nThe updated dynamic content for the Live Activity. The size of the encoded content can’t exceed 4KB in size.\n\nDiscussion\n\nUse this function to update the Live Activity while your app is in the foreground or while it’s in the background — for example, by using Background Tasks.\n\nNote\n\nThe system ignores attempts to update a Live Activity that ended.\n\nSee Also\nUpdating a Live Activity\nfunc update(ActivityContent<Activity<Attributes>.ContentState>) async\nUpdates the dynamic content of the Live Activity.\nfunc update(ActivityContent<Activity<Attributes>.ContentState>, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update.\nstruct AlertConfiguration\nA structure you use to configure an alert that appears when you update your Live Activity.\nfunc update(using: Activity<Attributes>.ContentState, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update."
  },
  {
    "title": "update(_:alertConfiguration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/update(_:alertconfiguration:)",
    "html": "Parameters\ncontent\n\nThe updated dynamic content for the Live Activity. The size of its state property can’t exceed 4KB in size.\n\nalertConfiguration\n\nThe alert configuration you use to configure how the system notifies a person about the updated content of the Live Activity.\n\nDiscussion\n\nThe system ignores updates to a Live Activity that’s in the ActivityState.ended state.\n\nSee Also\nUpdating a Live Activity\nfunc update(ActivityContent<Activity<Attributes>.ContentState>) async\nUpdates the dynamic content of the Live Activity.\nstruct AlertConfiguration\nA structure you use to configure an alert that appears when you update your Live Activity.\nfunc update(using: Activity<Attributes>.ContentState) async\nUpdates the dynamic content of the Live Activity.\nfunc update(using: Activity<Attributes>.ContentState, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update."
  },
  {
    "title": "AlertConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/alertconfiguration",
    "html": "Topics\nConfiguring Live Activity alerts\ninit(title: LocalizedStringResource, body: LocalizedStringResource, sound: AlertConfiguration.AlertSound)\nInitializes a new alert configuration for a Live Activity update.\nvar title: LocalizedStringResource\nA short title that describes the purpose of the Live Activity update on Apple Watch.\nvar body: LocalizedStringResource\nThe main text that appears on the alert for a Live Activity update on Apple Watch.\nvar sound: AlertConfiguration.AlertSound\nThe sound the system plays when the Live Activity alert appears on a person’s device.\nstruct AlertSound\nAn object that describes the sound to play for a Live Activity update alert.\nOperators\nstatic func == (AlertConfiguration, AlertConfiguration) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSee Also\nUpdating a Live Activity\nfunc update(ActivityContent<Activity<Attributes>.ContentState>) async\nUpdates the dynamic content of the Live Activity.\nfunc update(ActivityContent<Activity<Attributes>.ContentState>, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update.\nfunc update(using: Activity<Attributes>.ContentState) async\nUpdates the dynamic content of the Live Activity.\nfunc update(using: Activity<Attributes>.ContentState, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update."
  },
  {
    "title": "PushType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/pushtype",
    "html": "Overview\n\nPass the token constant to the request(attributes:contentState:pushType:) function to the start a Live Activity that receives content updates with ActivityKit push notifications.\n\nTo learn more about using ActivityKit push notifications to update your Live Activity, see doc:updating-live-activities-with-activitykit-push-notifications.\n\nTopics\nSupporting ActivityKit push notifications\nstatic var token: PushType\nA constant you use to configure a Live Activity that updates its dynamic content by receiving ActivityKit push notifications.\nOperators\nstatic func == (PushType, PushType) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSee Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "activityStateUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystateupdates-swift.property",
    "html": "See Also\nObserving the Live Activity life cycle\nvar activityState: ActivityState\nThe current state of a Live Activity in its life cycle.\nenum ActivityState\nThe enum that describes the state of a Live Activity in its life cycle.\nstruct ActivityStateUpdates\nA structure that offers functionality to observe state changes of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "ActivityAuthorizationError | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activityauthorizationerror",
    "html": "Topics\nError codes\ncase attributesTooLarge\nThe provided Live Activity attributes exceeded the maximum size of 4KB.\ncase denied\nA person deactivated Live Activities in Settings.\ncase globalMaximumExceeded\nThe device reached the maximum number of ongoing Live Activities.\ncase malformedActivityIdentifier\nThe provided activity identifier is malformed.\ncase missingProcessIdentifier\nThe process that tried to start the Live Activity is missing a process identifier.\ncase persistenceFailure\nThe system couldn’t persist the Live Activity.\ncase reconnectNotPermitted\nThe process that tried to recreate the Live Activity is not the process that originally created the Live Activity.\ncase targetMaximumExceeded\nThe app has already started the maximum number of concurrent Live Activities.\ncase unentitled\nThe app doesn’t have the required entitlement to start a Live Activity.\ncase unsupported\nThe device doesn’t support Live Activities.\ncase unsupportedTarget\nThe app doesn’t have the required entitlement to start a Live Activities.\ncase visibility\nThe app tried to start the Live Activity while it was in the background.\nGetting error information\nvar failureReason: String?\nA string that describes the error that occurred.\nvar recoverySuggestion: String?\nA localized message that describes how to recover from the error.\nProtocol confirmation\nvar errorCode: Int\nAn integer value that represents the error code.\nstatic var errorDomain: String\nThe domain for errors that can happen when starting a Live Activity.\nOperators\nstatic func == (ActivityAuthorizationError, ActivityAuthorizationError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nCustomNSError Implementations\nEquatable Implementations\nError Implementations\nLocalizedError Implementations\nRelationships\nConforms To\nCustomNSError\nEquatable\nError\nHashable\nLocalizedError\nSendable\nSee Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "ActivityContent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitycontent",
    "html": "Topics\nDescribing a Live Activity\ninit(state: State, staleDate: Date?, relevanceScore: Double)\nCreates the object that describes the state and configuration of a Live Activity.\nlet state: State\nThe current state of a Live Activity in its life cycle.\nlet staleDate: Date?\nThe date when the system considers the Live Activity to be out of date.\nlet relevanceScore: Double\nA score you assign that determines the order in which your Live Activities appear when you start several Live Activities for your app.\nDefault Implementations\nCustomStringConvertible Implementations\nRelationships\nConforms To\nCustomStringConvertible\nSendable\nSee Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "content | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/content",
    "html": "See Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "attributes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/attributes",
    "html": "See Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "ActivityState.stale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activitystate/stale",
    "html": "Discussion\n\nThe content of a Live Activity may become out of date before you can update it. For example, a person may be in an area without a network connection, causing the Live Activity to not receive updates. To tell people that they are looking at outdated Live Activity content, you can configure a staleDate for your Live Activity. At the specified date, the activityState changes to stale and you can update the Live Activity to indicate that its content is out of date.\n\nSee Also\nLive Activity states\ncase active\nThe Live Activity is active, visible, and can receive content updates.\ncase dismissed\nThe Live Activity ended and is no longer visible because a person or the system removed it.\ncase ended\nThe Live Activity is visible, but a person, app, or system ended it, and it won’t update its content anymore."
  },
  {
    "title": "activityState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/activitystate",
    "html": "See Also\nObserving the Live Activity life cycle\nenum ActivityState\nThe enum that describes the state of a Live Activity in its life cycle.\nvar activityStateUpdates: Activity<Attributes>.ActivityStateUpdates\nAn asynchronous sequence you use to observe activity state changes.\nstruct ActivityStateUpdates\nA structure that offers functionality to observe state changes of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes."
  },
  {
    "title": "Activity.ContentState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/contentstate-swift.typealias",
    "html": "See Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "pushToStartTokenUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtostarttokenupdates",
    "html": "See Also\nUsing ActivityKit push notifications\nvar pushToken: Data?\nThe token you use to send ActivityKit push notifications to a Live Activity.\nvar pushTokenUpdates: Activity<Attributes>.PushTokenUpdates\nAn asynchronous sequence you use to observe changes to the push token of a Live Activity.\nstruct PushTokenUpdates\nA structure that offers functionality to observe changes to the push token of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nstatic var pushToStartToken: Data?"
  },
  {
    "title": "pushTokenUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtokenupdates-swift.property",
    "html": "See Also\nUsing ActivityKit push notifications\nvar pushToken: Data?\nThe token you use to send ActivityKit push notifications to a Live Activity.\nstruct PushTokenUpdates\nA structure that offers functionality to observe changes to the push token of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nstatic var pushToStartToken: Data?\nstatic var pushToStartTokenUpdates: Activity<Attributes>.PushTokenUpdates"
  },
  {
    "title": "pushToken | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/pushtoken",
    "html": "Discussion\n\nThe push token for a Live Activity may change over time. Use the pushTokenUpdates asynchronous sequence to receive the updated push token. When you receive an updated push token, make sure to send it to your server and invalidate the outdated token.\n\nSee Also\nUsing ActivityKit push notifications\nvar pushTokenUpdates: Activity<Attributes>.PushTokenUpdates\nAn asynchronous sequence you use to observe changes to the push token of a Live Activity.\nstruct PushTokenUpdates\nA structure that offers functionality to observe changes to the push token of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nstatic var pushToStartToken: Data?\nstatic var pushToStartTokenUpdates: Activity<Attributes>.PushTokenUpdates"
  },
  {
    "title": "request(attributes:content:pushType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/request(attributes:content:pushtype:)",
    "html": "Parameters\nattributes\n\nA set of attributes that describe the Live Activity and its static content.\n\ncontent\n\nA structure that describes the dynamic content of the Live Activity that changes over time.\n\npushType\n\nA value that indicates whether the Live Activity receives updates to its dynamic content with ActivityKit push notifications. Pass nil to start a Live Activity that only receives updates from the app with the update(_:) function. To start a Live Activity that receives updates to its dynamic content with ActivityKit push notifications in addition to the update(_:) function, pass token to this parameter.\n\nReturn Value\n\nThe object that represents the Live Activity you started.\n\nDiscussion\n\nUse this function to request and start a Live Activity from your app while it’s in the foreground. Note that you can’t do this while your app is in the background.\n\nIf your Live Activity displays image assets, the system requires them to use a resolution that’s smaller or equal to the size of the Live Activity presentation for a device. If you use an image asset that’s larger than the size of the Live Activity presentation, the system may fail to start the Live Activity. For information about the sizes of Live Activity presentations, see Human Interface Guidelines > Live Activities.\n\nFor additional information on starting a Live Activity, see Displaying live data with Live Activities.\n\nThrows\n\nActivityAuthorizationError if the app can’t start a new Live Activity. For example, ActivityAuthorizationError.denied indicates that the person deactivated Live Activities for the app.\n\nSee Also\nStarting a Live Activity\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "request(attributes:contentState:pushType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity/request(attributes:contentstate:pushtype:)",
    "html": "Parameters\nattributes\n\nA set of attributes that describe the Live Activity and its static content.\n\ncontentState\n\nA structure that describes the dynamic content of the Live Activity that changes over time.\n\npushType\n\nA value that indicates whether the Live Activity receives updates to its dynamic content with ActivityKit push notifications. Pass nil to start a Live Activity that only receives updates from the app with the update(_:) function. To start a Live Activity that receives updates to its dynamic content with ActivityKit push notifications in addition to the update(_:) function, pass token to this parameter.\n\nReturn Value\n\nThe object that represents the started Live Activity.\n\nDiscussion\n\nUse this function to request and start a Live Activity from your app while it’s in the foreground. Note that you can’t do this while your app is in the background.\n\nIf your Live Activity displays image assets, the system requires them to use a resolution that’s smaller or equal to the size of the Live Activity presentation for a device. If you use an image asset that’s larger than the size of the Live Activity presentation, the system may fail to start the Live Activity. For information about the sizes of Live Activity presentations, see Human Interface Guidelines > Live Activities.\n\nFor additional information on starting a Live Activity, see Displaying live data with Live Activities.\n\nThrows\n\nActivityAuthorizationError if the app can’t start a new Live Activity. For example, ActivityAuthorizationError.denied indicates that a person deactivated Live Activities for the app.\n\nSee Also\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity."
  },
  {
    "title": "Displaying live data with Live Activities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities",
    "html": "Overview\n\nLive Activities display your app’s most current data on the iPhone or iPad Lock Screen and in the Dynamic Island, allowing people to see live information at a glance and perform quick actions that are related to the displayed information.\n\nTo offer Live Activities, add code to your existing widget extension or create a new widget extension if your app doesn’t already include one. Live Activities use WidgetKit functionality and SwiftUI for their user interface. ActivityKit’s role is to handle the life cycle of each Live Activity: You use its API to request, update, and end a Live Activity and to receive ActivityKit push notifications.\n\nFor design guidance, see Human Interface Guidelines > Live Activities.\n\nRelated sessions from WWDC23\n\nSession 10184: Meet ActivityKit and Session 10194: Design dynamic Live Activities\n\nReview Live Activity presentations\n\nLive Activities come in different presentations for the Lock Screen and the Dynamic Island. The Lock Screen presentation appears on all devices. On an unlocked device that doesn’t support the Dynamic Island, the Lock Screen presentation also appears as a banner for Live Activity updates that include an alert configuration. For example, if a person uses Mail on a device that doesn’t support the Dynamic Island while the Live Activity receives an update with an alert configuration, the system displays the Lock Screen presentation as a banner at the top of the screen to let them know about the updated Live Activity.\n\nDevices that support the Dynamic Island display Live Activities in the Dynamic Island using several presentations. When there’s only one ongoing Live Activity, the system uses the compact presentation. It’s composed of two elements: one that displays on the leading side of the TrueDepth camera, and one that displays on the trailing side. Although the leading and trailing presentations are separate views, they form a cohesive view in the Dynamic Island, representing a single piece of information from your app. People can tap a compact Live Activity to open the app and get more details about the event or task.\n\nWhen multiple Live Activities from several apps are active, the system uses the circular minimal presentation to display two of them in the Dynamic Island. The system chooses a Live Activity from one app to appear attached to the Dynamic Island while it presents a Live Activity from another app detached from the Dynamic Island. As with a compact Live Activity, people can tap a minimal Live Activity to open the app and get more details about the event or task.\n\nWhen people touch and hold a Live Activity in a compact or minimal presentation, the system displays the content in an expanded presentation.\n\nThe minimal presentation also appears at the top of the iPhone Lock Screen when the device is in StandBy — in landscape orientation, charging, and with the display positioned at an angle to face the room. If a person taps the minimal presentation in StandBy, the Live Activity expands to fill the whole display using the Lock Screen presentation.\n\nTo add support for Live Activities in your app, you must support all presentations.\n\nUnderstand constraints\n\nA Live Activity can be active for up to eight hours unless its app or a person ends it before this limit. After the eight-hour limit, the system automatically ends the Live Activity, and immediately removes it from the Dynamic Island. However, the Live Activity remains on the Lock Screen until a person removes it or for up to four additional hours before the system removes it — whichever comes first. As a result, a Live Activity remains on the Lock Screen for a maximum of 12 hours.\n\nFor more information about ending a Live Activity, see the “End the Live Activity” section below.\n\nThe system requires image assets for a Live Activity to use a resolution that’s smaller or equal to the size of the presentation for a device. If you use an image asset that’s larger than the size of the Live Activity presentation, the system might fail to start the Live Activity. For example, an image you use for the minimal presentation of your Live Activity shouldn’t exceed 45x36.67 points. For size guidance of Live Activity presentations, see Human Interface Guidelines > Live Activities.\n\nEach Live Activity runs in its own sandbox, and — unlike a widget — it can’t access the network or receive location updates. To update the dynamic data of an active Live Activity, use ActivityKit in your app or allow your Live Activities to receive ActivityKit push notifications as described in Starting and updating Live Activities with ActivityKit push notifications.\n\nNote\n\nThe updated dynamic data for both ActivityKit updates and ActivityKit push notifications can’t exceed 4 KB in size.\n\nAdd support for Live Activities to your app\n\nThe code that describes the user interface of your Live Activity is part of your app’s widget extension. If you already offer widgets in your app, add code for the Live Activity to your existing widget extension and reuse code between your widgets and Live Activities. However, although Live Activities leverage WidgetKit’s functionality, they aren’t widgets. In contrast to the timeline mechanism you use to update your widgets’ user interface, you start and update a Live Activity from your app with ActivityKit or with ActivityKit push notifications.\n\nNote\n\nYou can create a widget extension to adopt Live Activities without offering widgets. However, consider offering both widgets and Live Activities to allow people to add glanceable information and a personal touch to their device.\n\nTo support Live Activities:\n\nCreate a widget extension if you haven’t added one to your app and make sure to select “Include Live Activity” when you add a widget extension target to your Xcode project. For more information on creating a widget extension, see WidgetKit and Creating a widget extension.\n\nIf your project includes an Info.plist file, add the Supports Live Activities entry to it, and set its Boolean value to YES. Alternatively, open the Info.plist file as source code, add the NSSupportsLiveActivities key, then set the type to Boolean and its value to YES. If your project doesn’t have an Info.plist file, add the Supports Live Activities entry to the list of custom iOS target properties for your iOS app target and set its value to YES.\n\nAdd code that defines an ActivityAttributes structure to describe the static and dynamic data of your Live Activity.\n\nUse the ActivityAttributes you defined to create the ActivityConfiguration.\n\nAdd code to configure, start, update, and end your Live Activities.\n\nMake your Live Activity interactive with Button or Toggle as described in Adding interactivity to widgets and Live Activities.\n\nAdd animations to bring attention to content updates as described in Animating data updates in widgets and Live Activities.\n\nDefine a set of static and dynamic data\n\nAfter you add a widget extension target that includes Live Activities to your Xcode project, describe the data that your Live Activity displays by implementing ActivityAttributes. The ActivityAttributes inform the system about static data that appears in the Live Activity. You also use ActivityAttributes to declare the required custom Activity.ContentState type that describes the dynamic data of your Live Activity. In the example below from the Apple Developer Documentation sample code project, AdventureAttributes describes the hero information as static data using let hero: EmojiRanger. Note how the code defines the Activity.ContentState to encapsulate dynamic data: the current health level of the hero and a string that describes what happens to the hero.\n\nimport ActivityKit\n\n\nstruct AdventureAttributes: ActivityAttributes {\n    struct ContentState: Codable & Hashable {\n        let currentHealthLevel: Double\n        let eventDescription: String\n    }\n    \n    let hero: EmojiRanger\n}\n\n\nTip\n\nTo make your code more descriptive and easy to read, you can define a type alias for the ContentState; for example: public typealias HeroStatus = ContentState.\n\nAdd Live Activities to the widget extension\n\nLive Activities leverage WidgetKit. After you add code to describe the data that appears in the Live Activity with the ActivityAttributes structure, add code to return an ActivityConfiguration in your widget implementation.\n\nThe following example uses the AdventureAttributes structure from the previous example:\n\nimport WidgetKit\nimport SwiftUI\n\n\nstruct AdventureActivityConfiguration: Widget {\n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: AdventureAttributes.self) { context in\n            // Create the presentation that appears on the Lock Screen and as a\n            // banner on the Home Screen of devices that don't support the\n            // Dynamic Island.\n            // ...\n        } dynamicIsland: { context in\n            // Create the presentations that appear in the Dynamic Island.\n            // ...\n        }\n    }\n}\n\n\nTip\n\nIf you select “Include Live Activities” when you add a new widget extension target to your project, Xcode automatically creates a widget bundle for you that includes a widget and a Live Activity.\n\nIf your app already offers widgets, add the Live Activity to your WidgetBundle. If you don’t have a WidgetBundle — for example, if you only offer one widget — create a widget bundle as described in Creating a widget extension and then add the Live Activity to it.\n\nCreate the Lock Screen presentation\n\nTo create the user interface of the Live Activity, you use SwiftUI in the widget extension you created earlier. Similar to widgets, you don’t provide the size of the user interface for your Live Activity but let the system determine the appropriate dimensions.\n\nStart with the presentation that appears on the Lock Screen. The following code displays the information that the AdventureAttributes struct describes using the custom AdventureLiveActivityView:\n\nstruct AdventureActivityConfiguration: Widget {\n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: AdventureAttributes.self) { context in\n            // Create the presentation that appears on the Lock Screen and as a\n            // banner on the Home Screen of devices that don't support the\n            // Dynamic Island.\n            AdventureLiveActivityView(\n                hero: context.attributes.hero,\n                isStale: context.isStale,\n                contentState: context.state\n            )\n            .activityBackgroundTint(Color.liveActivityBackground.opacity(0.25))\n        } dynamicIsland: { context in\n            // Create the presentations that appear in the Dynamic Island.\n            // ...\n        }\n    }\n}\n\n\nNote\n\nThe system may truncate a Live Activity if its height exceeds 160 points.\n\nOn a device that doesn’t support the Dynamic Island, the system displays the Lock Screen presentation as a banner for a Live Activity update if:\n\nThe device is unlocked and its app isn’t in use\n\nYou pass an AlertConfiguration to the update(_:alertConfiguration:) function\n\nOn iPhone in StandBy, the Lock Screen presentation appears scaled to fill the screen of the device. Make sure your assets offer a high-enough resolution for StandBy. Additionally, consider updating the Lock Screen presentation to make use of the additional space. To detect Standby, use the isActivityFullscreen environment variable.\n\nCreate the compact and minimal presentations\n\nLive Activities appear in the Dynamic Island of devices that support it. When you start one or more Live Activities and no other app starts a Live Activity, the compact leading and trailing presentations appear together to form a cohesive presentation in the Dynamic Island for one Live Activity.\n\nWhen more than one app starts a Live Activity, the system chooses which Live Activities are visible and displays two Live Activities using the minimal presentation for each: One minimal presentation appears attached to the Dynamic Island, while the other appears detached. Additionally, the detached minimal presentation appears on the Lock Screen on iPhone in StandBy. If your app starts more than one Live Activity at the same time, you can tell the system which one it should display by setting a relevance score. For more information, see the “Configure the Live Activity” section below.\n\nThe following example shows how the Emoji Rangers: Supporting Live Activities, interactivity, and animations app provides the required compact and minimal presentations. For the leading presentation, it reuses the custom SwiftUI view Avatar. For the trailing presentation, it uses a ProgressView.\n\nimport SwiftUI\nimport WidgetKit\n\n\nstruct AdventureActivityConfiguration: Widget {\n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: AdventureAttributes.self) { context in\n            // Create the presentation that appears on the Lock Screen and as a\n            // banner on the Home Screen of devices that don't support the\n            // Dynamic Island.\n            // ...\n        } dynamicIsland: { context in\n            // Create the presentations that appear in the Dynamic Island.\n            DynamicIsland {\n                // Create the expanded presentation.\n                // ...\n            } compactLeading: {\n                // Create the compact leading presentation.\n                Avatar(hero: context.attributes.hero, includeBackground: true)\n                    .accessibilityLabel(\"The avatar of \\(context.attributes.hero.name).\")\n            } compactTrailing: {\n                // Create the compact trailing presentation.\n                ProgressView(value: context.state.currentHealthLevel, total: 1) {\n                    let healthLevel = Int(context.state.currentHealthLevel * 100)\n                    Text(\"\\(healthLevel)\")\n                        .accessibilityLabel(\"Health level at \\(healthLevel) percent.\")\n                }\n                .progressViewStyle(.circular)\n                .tint(context.state.currentHealthLevel <= 0.2 ? Color.red : Color.green)\n            } minimal: {\n                // Create the minimal presentation.\n                // ...\n            }           \n        }\n    }\n}\n\nCreate the expanded presentation\n\nIn addition to the compact and minimal presentations, you must support the expanded presentation. It appears when a person touches and holds a compact or minimal presentation, and it also appears briefly for Live Activity updates.\n\nUse the DynamicIslandExpandedRegionPosition to specify detailed instructions where you want SwiftUI to position your content. The following example shows how the the Emoji Rangers: Supporting Live Activities, interactivity, and animations app creates its expanded presentation using a DynamicIslandExpandedContentBuilder:\n\nstruct AdventureActivityConfiguration: Widget {\n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: AdventureAttributes.self) { context in\n            // Create the presentation that appears on the Lock Screen and as a\n            // banner on the Home Screen of devices that don't support the\n            // Dynamic Island.\n            // ...\n        } dynamicIsland: { context in\n            // Create the presentations that appear in the Dynamic Island.\n            DynamicIsland {\n                // Create the expanded presentation.\n                expandedContent(\n                    hero: context.attributes.hero,\n                    contentState: context.state,\n                    isStale: context.isStale\n                )\n            } compactLeading: {\n                // Create the compact leading presentation.\n                // ...\n            } compactTrailing: {\n                // Create the compact trailing presentation.\n                // ...\n            } minimal: {\n                // Create the minimal presentation.\n                // ...\n            }\n        }\n    }\n    \n    @DynamicIslandExpandedContentBuilder\n    private func expandedContent(hero: EmojiRanger,\n                                 contentState: AdventureAttributes.ContentState,\n                                 isStale: Bool) -> DynamicIslandExpandedContent<some View> {\n        DynamicIslandExpandedRegion(.leading) {\n            LiveActivityAvatarView(hero: hero)\n        }\n        \n        DynamicIslandExpandedRegion(.trailing) {\n            StatsView(\n                hero: hero,\n                isStale: isStale\n            )\n        }\n        \n        DynamicIslandExpandedRegion(.bottom) {\n            HealthBar(currentHealthLevel: contentState.currentHealthLevel)\n            \n            EventDescriptionView(\n                hero: hero,\n                contentState: contentState\n            )\n        }\n    }\n}\n\n\nTo render views that appear in the expanded Live Activity, the system divides the expanded presentation into different areas. Note how the example returns a DynamicIsland that specifies several DynamicIslandExpandedRegion objects. Pass the following DynamicIslandExpandedRegionPosition values to lay out your content at a specified position in the expanded presentation:\n\ncenter places content below the TrueDepth camera.\n\nleading places content along the leading edge of the expanded Live Activity next to the TrueDepth camera and wraps additional content below it.\n\ntrailing places content along the trailing edge of the expanded Live Activity next to the TrueDepth camera and wraps additional content below it.\n\nbottom places content below the leading, trailing, and center content.\n\nTo render content that appears in the expanded Live Activity, the system first determines the width of the center content while taking into account the minimal width of the leading and trailing content. The system then places and sizes the leading and trailing content based on its vertical position. By default, leading and trailing positions receive an equal amount of horizontal space.\n\nYou can tell the system to prioritize one of the DynamicIslandExpandedRegion views by passing a priority to the init(_:priority:content:) initializer. The system renders the view with the highest priority with the full width of the Dynamic Island. The following illustration shows leading and trailing positions in an expanded presentation with higher priority to render them below the TrueDepth camera.\n\nNote\n\nIf content is too wide to appear in a leading position next to the TrueDepth camera, use the belowIfTooWide modifier to render leading content below the TrueDepth camera.\n\nSet custom content margins\n\nLimiting the content you display is key to offering glanceable, easy-to-read Live Activities. Aim to use the system’s default content margins for your Live Activities and only show content that’s relevant to the person viewing it. However, you may want to change the system’s default content margin to display more content or provide a custom user interface that matches your app. To set custom content margins, use contentMargins(_:_:for:). The following example results in a margin of eight points for the trailing edge of an expanded Live Activity.\n\nstruct AdventureActivityConfiguration: Widget {\n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: AdventureAttributes.self) { context in\n            // Create the presentation that appears on the Lock Screen and as a\n            // banner on the Home Screen of devices that don't support the\n            // Dynamic Island.\n            // ...\n        } dynamicIsland: { context in\n            // Create the presentations that appear in the Dynamic Island.\n            DynamicIsland {\n                // Create the expanded presentation.\n                // ...\n            } compactLeading: {\n                // Create the compact leading presentation.\n                // ...\n            } compactTrailing: {\n                // Create the compact trailing presentation.\n                // ...\n            } minimal: {\n                // Create the minimal presentation.\n                // ...\n            }\n            .contentMargins(.trailing, 8, for: .expanded)\n        }\n    }\n}\n\n\nIf you repeatedly use the contentMargins(_:_:for:) modifier, the system uses the innermost specified values for a mode.\n\nNote\n\nAvoid placing content too close to the edges of the Dynamic Island.\n\nUse custom colors\n\nLive Activities in the Dynamic Island use a black background color with white text. Use the keylineTint(_:) modifier to apply a subtle tint color to the border of the Dynamic Island when the device is in Dark Mode and change text color as needed.\n\nNote\n\nYou can’t change the background color of Live Activities in the Dynamic Island.\n\nBy default, the Lock Screen presentation — including the banner that appears on devices that don’t support the Dynamic island — uses a solid white background color in Light Mode and a solid black background color in Dark Mode. To set a custom background color for the Lock Screen presentation, use the activityBackgroundTint(_:) modifier. Be sure to choose a color that works well in both Dark or Light Mode or use different background colors that best fit each appearance. To set the translucency of the custom background color, use the opacity(_:) view modifier or specify an opaque background color.\n\nIf you choose a custom background color for the Lock Screen presentation, use the activitySystemActionForegroundColor(_:) view modifier to customize the text color of the auxiliary button that allows people to end the Live Activity on the Lock Screen.\n\nNote\n\nOn devices that include an Always-On display, the system dims the screen to preserve battery life and renders Live Activities on the Lock Screen as if in Dark Mode. Use SwiftUI’s isLuminanceReduced environment value to detect reduced luminance on devices with an Always-On display and use colors and images that look great with reduced luminance.\n\nCreate a deep link into your app\n\nPeople tap a Live Activity to launch your app. To improve the user experience, you can use widgetURL(_:) to create a deep link into your app from the Lock Screen, compact leading, compact trailing, and minimal presentations. When the compact leading and trailing presentations are visible, make sure both link to the same screen in your app.\n\nThe expanded presentation offers additional options to create deep links into your app for more utility using SwiftUI’s Link.\n\nIf you don’t explicitly provide a deep link into your app with widgetURL(_:) or Link, the system launches your app and passes a NSUserActivity object to the scene(_:willContinueUserActivityWithType:) and scene(_:continue:) callbacks. Implement both callbacks and check whether the NSUserActivity object’s activityType is NSUserActivityTypeLiveActivity, and add code to open a screen in your app that fits the context of the active Live Activity.\n\nFor additional information about deep linking into your app, see Linking to specific app scenes from your widget or Live Activity.\n\nAdd Buttons or Toggles\n\nLike widgets, starting with iOS 17 and iPadOS 17, Live Activities can contain SwiftUI buttons and toggles to provide quick actions. For example, a food-ordering app might show a button in its Live Activity that people tap to check in at a restaurant when they pick up a takeout order.\n\nTo add a toggle or button to a Live Activity, adopt the App Intents framework and use the initializers for Button and Toggle that take an app intent. For more information about using toggles and buttons in widget extensions, including for Live Activities, see WidgetKit.\n\nProvide accessibility labels\n\nDesigning with accessibility in mind is a foundational principle when creating an app. It also applies to Live Activities. To allow people to customize how they interact with your Live Activity and to make sure VoiceOver for your Live Activity works correctly, add accessibility labels for the SwiftUI views you create for each Live Activity presentation. For more information, see Adding accessible descriptions to widgets and Live Activities.\n\nMake sure Live Activities are available\n\nLive Activities are available on iPhone and iPad. If your app is available on additional platforms and offers a widget extension, make sure Live Activities are available at runtime. Additionally, people can choose to deactivate Live Activities for an app in the Settings app.\n\nTo see if Live Activities are available and if a person allowed your app to use Live Activities:\n\nUse areActivitiesEnabled to synchronously determine whether to show a user interface in your app for starting a Live Activity.\n\nReceive asynchronous user authorization updates by observing any user authorization changes with the activityEnablementUpdates stream and respond to them accordingly.\n\nNote\n\nAn app can start several Live Activities, and a device can run Live Activities from several apps — the exact number may depend on a variety of factors. In addition to making sure Live Activities are available, always handle any errors gracefully when starting, updating, or ending a Live Activity. For example, starting a Live Activity may fail because a person’s device may have reached its limit of active Live Activities.\n\nConfigure the Live Activity\n\nBefore you can start a Live Activity in your app, configure it with an ActivityContent structure. The activity content encapsulates the ActivityAttributes and additional configuration information:\n\nThe staleDate tells the system when the Live Activity content becomes outdated.\n\nThe relevanceScore determines which of your Live Activities appears in the Dynamic Island and the order of your Live Activities on the Lock Screen.\n\nWhile setting the staleDate is optional, it’s helpful when you want to ensure your Live Activity doesn’t display outdated content. At the specified date, the activityState changes to ActivityState.stale and isStale changes to true. Access isStale to monitor the activity state and respond to outdated Live Activities that haven’t received updates. For example, while a person has network connectivity, a sports app could update the Live Activity with the latest game information and advance the stale date. If a person enters an area without network connectivity, the app can’t update the Live Activity with new information and an advanced stale date. Eventually, the Live Activity becomes stale and displays text to indicate that the displayed information is outdated. On the next app launch or when it performs background tasks, the app can also respond to the ActivityState.stale state.\n\nIf your app starts more than one Live Activity, provide a relevance score to determine the order of your Live Activities on the Lock Screen and which of your Live Activities appears in the Dynamic Island:\n\nIf you don’t provide a relevance score or if Live Activities have the same relevance score, the system shows the first Live Activity you started in the Dynamic Island.\n\nIf you use different relevance scores, the system shows the Live Activity with the highest relevance score in the Dynamic Island.\n\nThe system expects relative values for the relevance score. Assign a higher value for an important Live Activity content update — for example, a score of 100 — and use lower values for less important Live Activity content updates — for example, 50.\n\nNote\n\nKeep track of the relevance scores you assign for each ongoing Live Activity so you can change the order of them as needed with each Live Activity update.\n\nStart the Live Activity\n\nYou start a Live Activity in your app’s code while the app is in the foreground with the request(attributes:content:pushType:) function. Pass the ActivityAttributes and ActivityContent objects you created to it and, if you implement ActivityKit push notifications, the pushType parameter.\n\nThe following example from the Emoji Rangers: Supporting Live Activities, interactivity, and animations app creates the initial attributes and content state for the Emoji Rangers Live Activity.\n\nif ActivityAuthorizationInfo().areActivitiesEnabled {\n    do {\n        let adventure = AdventureAttributes(hero: hero)\n        let initialState = AdventureAttributes.ContentState(\n            currentHealthLevel: hero.healthLevel,\n            eventDescription: \"Adventure has begun!\"\n        )\n        \n        let activity = try Activity.request(\n            attributes: adventure,\n            content: .init(state: initialState, staleDate: nil),\n            pushType: .token\n        )\n        \n        self.setup(withActivity: activity)\n    } catch {\n        errorMessage = \"\"\"\n\t\t\t\t    Couldn't start activity\n\t\t\t\t    ------------------------\n\t\t\t\t    \\(String(describing: error))\n\t\t\t\t    \"\"\"\n        \n        self.errorMessage = errorMessage\n    }\n}\n\n\nYour app can only start Live Activities while it’s in the foreground. However, you can update or end a Live Activity from your app while it runs in the background — for example, by using Background Tasks.\n\nAdditionally, you can enable Live Activity updates with ActivityKit push notifications. Pass .token as a value the pushType parameter as shown in the example above, and implement your remote notification server. Starting with iOS 17.2 and iPadOS 17.2, you can also start Live Activities with ActivityKit push notifications. For more information on using ActivityKit push notifications, see Starting and updating Live Activities with ActivityKit push notifications.\n\nUpdate the Live Activity\n\nWhen you start a Live Activity from your app, update the data that appears in the Live Activity using the update(_:) function of the Activity object you received when you started the Live Activity. To retrieve your app’s active Live Activities, use activities.\n\nFor important updates, use the update(_:alertConfiguration:) function to display an alert on iPhone, iPad, and a paired Apple Watch that tells a person about new Live Activity content. For example, the following example from the Emoji Rangers: Supporting Live Activities, interactivity, and animations app updates its Live Activity an alert configuration to inform to display an alert that lets people know that the hero has been knocked down:\n\nguard let activity = currentActivity else {\n    return\n}\n\n\nvar alertConfig: AlertConfiguration? = nil\nlet contentState: AdventureAttributes.ContentState\nif alert {\n    let heroName = activity.attributes.hero.name\n    \n    alertConfig = AlertConfiguration(\n        title: \"\\(heroName) has been knocked down!\",\n        body: \"Open the app and use a potion to heal \\(heroName).\",\n        sound: .default\n    )\n    \n    contentState = AdventureAttributes.ContentState(\n        currentHealthLevel: 0,\n        eventDescription: \"\\(heroName) has been knocked down!\"\n    )\n} else {\n    contentState = AdventureAttributes.ContentState(\n        currentHealthLevel: Double.random(in: 0...1),\n        eventDescription: self.getEventDescription(hero: activity.attributes.hero)\n    )\n}\n\n\nawait activity.update(\n    ActivityContent<AdventureAttributes.ContentState>(\n        state: contentState,\n        staleDate: Date.now + 15,\n        relevanceScore: alert ? 100 : 50\n    ),\n    alertConfiguration: alertConfig\n)\n\n\nNote\n\nThe size of the updated data can’t exceed 4KB in size.\n\nOn Apple Watch, the system uses the title and body attributes for the alert. On iPhone and iPad, the system doesn’t show a regular alert but instead shows the expanded Live Activity in the Dynamic Island or the Lock Screen presentation as a banner on devices without the Dynamic Island.\n\nAnimate content updates\n\nWhen you define the user interface of your Live Activity, the system ignores any animation modifiers — for example, withAnimation(_:_:) and animation(_:value:) — and uses the system’s animation timing instead. However, the system performs some animation when the dynamic content of the Live Activity changes. Text views animate content changes with blurred content transitions, and the system animates content transitions for images and SF Symbols. If you add or remove views from the user interface based on content or state changes, views fade in and out. Use the following view transitions to configure these built-in transitions: opacity, move(edge:), slide, push(from:), or combinations of them. Additionally, request animations for timer text with numericText(countsDown:).\n\nStarting with iOS 17 and iPadOS 17, you can animate data changes in your Live Activity with functions that give you more control over animation timing. For example, you can use timingCurve(_:duration:) to create an animation with a custom timing curve. For more information on SwiftUI animations, see Animation.\n\nNote\n\nOn devices that include an Always-On display, the system doesn’t perform animations to preserve battery life in Always On. Make sure to use SwiftUI’s isLuminanceReduced environment value to detect reduced luminance before animating content changes.\n\nEnd the Live Activity\n\nAlways end a Live Activity after the associated task or live event ends. A Live Activity that ended remains on the Lock Screen until the person removes it or the system removes it automatically. The automatic removal depends on the dismissal policy you provide to the end(_:dismissalPolicy:) function. Always include an updated Activity.ContentState to ensure the Live Activity shows the latest and final content update after it ends. This is important because the Live Activity can remain visible on the Lock Screen for some time after it ends.\n\nThe following example shows how the Emoji Rangers: Supporting Live Activities, interactivity, and animations app ends its Live Activity and sets a custom dismissal policy based on a setting in the app:\n\nfunc endActivity(dismissTimeInterval: Double?) async {\n    guard let activity = currentActivity else {\n        return\n    }\n    \n    let hero = activity.attributes.hero\n    \n    let finalContent = AdventureAttributes.ContentState(\n        currentHealthLevel: 1.0,\n        eventDescription: \"Adventure over! \\(hero.name) is taking a nap.\"\n    )\n    \n    let dismissalPolicy: ActivityUIDismissalPolicy\n    if let dismissTimeInterval = dismissTimeInterval {\n        if dismissTimeInterval <= 0 {\n            dismissalPolicy = .immediate\n        } else {\n            dismissalPolicy = .after(.now + dismissTimeInterval)\n        }\n    } else {\n        dismissalPolicy = .default\n    }\n    \n    await activity.end(ActivityContent(state: finalContent, staleDate: nil), dismissalPolicy: dismissalPolicy)\n}\n\n\nWith the default dismissal policy, the Live Activity appears on the Lock Screen for some time after it ends to allow a person to glance at their phone to see the latest information. A person can choose to remove the Live Activity at any time, or the system removes it automatically four hours after it ended.\n\nTo immediately remove the Live Activity that ended from the Lock Screen, use immediate. Alternatively, use after(_:) to specify a date within a four-hour window. While you can provide any date, the system removes the ended Live Activity after the given date or after four hours from the moment the Live Activity ended — whichever comes first.\n\nA person can remove your Live Activity from their Lock Screen at any time. This ends the Live Activity, but it doesn’t end or cancel the person’s action that started it. For example, a person may remove the Live Activity for their pizza delivery from the Lock Screen, but this doesn’t cancel the pizza order.\n\nNote\n\nWhen a person or the system removes a Live Activity, its ActivityState changes to ActivityState.dismissed.\n\nUpdate or end your Live Activity with a push notification\n\nIn addition to updating and ending a Live Activity from your app with ActivityKit, update or end a Live Activity with an ActivityKit push notification that you send from your server to the Apple Push Notification service (APNs). Starting with iOS 17.2 and iPadOS 17.2, ActivityKit push notifications can also start Live Activities. To learn more about using ActivityKit push notifications, see Starting and updating Live Activities with ActivityKit push notifications.\n\nKeep track of updates\n\nWhen you start a Live Activity, ActivityKit returns an Activity object. In addition to the id that uniquely identifies each activity, the Activity offers sequences to observe content, activity state, and push token updates. Use the corresponding sequence to receive updates in your app, keep your app and Live Activities in sync, and respond to changed data:\n\nTo observe changes to ongoing Live Activities and to asynchronously access a Live Activity when you start it, use activityUpdates.\n\nTo observe the state of an ongoing Live Activity — for example, to determine whether it’s active or has ended — use activityStateUpdates.\n\nTo observe changes to the dynamic content of a Live Activity, use contentUpdates.\n\nTo observe changes to the push token of a Live Activity, use pushTokenUpdates.\n\nThe following example shows how the Emoji Rangers: Supporting Live Activities, interactivity, and animations app tracks updates its content for ongoing Live Activities and updates its adventure view accordingly:\n\n// Observe updates for ongoing Live Activities.\nTask {\n    for await content in activity.contentUpdates {\n        self.updateAdventureView(content: content)\n    }\n}\n\nObserve active Live Activities\n\nYour app can start more than one Live Activity. For example, a sports app may allow a person to start a Live Activity for each live sports game they’re interested in. If your app starts multiple Live Activities, keep track of ongoing Live Activities for your app using the activities property to make sure your app is aware of all ongoing Live Activities that ActivityKit tracks. Another use case for fetching all activities is to maintain Live Activities that are in progress and make sure you don’t keep any activities running for longer than needed. For example, the system may stop your app, or your app may crash while a Live Activity is active. When the app launches the next time, check if any activities are still active, update your app’s stored Live Activity data, and end any Live Activity that’s no longer relevant.\n\nStart and stop Live Activities from App Intents\n\nThe App Intents framework enables you to extend your app’s custom functionality to support system-level services like Siri and the Shortcuts app, as well as the functionality to start a Live Activity. For example, a sports app could expose functionality to start a Live Activity for a person’s favorite sports team with the Shortcuts app or Siri.\n\nStarting a Live Activity from an app intent is almost the same as adopting App Intents to expose other functionality in your app:\n\nAdopt the App Intents framework as described in Providing your app’s capabilities to system services.\n\nWhen you implement your app intent that starts the Live Activity, make sure it inherits from LiveActivityStartingIntent.\n\nIn your LiveActivityStartingIntent implementation, add code to start the Live Activity.\n\nSee Also\nLive Activity implementation\nStarting and updating Live Activities with ActivityKit push notifications\nUse ActivityKit to receive push tokens and to remotely start, update, and end your Live Activity with ActivityKit notifications.\nAdding accessible descriptions to widgets and Live Activities\nDescribe the interface elements of your widgets and Live Activities to help people understand what they represent.\nclass Activity\nThe object you use to start, update, and end a Live Activity."
  },
  {
    "title": "Activity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/activity",
    "html": "Overview\n\nThe Activity object offers functionality to start, update, and end a Live Activity from within your app. You can update or end a Live Activity while your app is in the background, but you can only start a Live Activity while the app is in the foreground.\n\nAdditionally, Activity offers functionality to observe changes to:\n\nThe Live Activity\n\nThe Live Activity’s state in its life cycle\n\nA person’s permission to start Live Activities\n\nThe Live Activity’s push token if you configure it to receive updates through ActivityKit push notifications.\n\nTo observe these changes, use the asynchronous sequences the activity object offers; for example, use the activityStateUpdates sequence to observe changes to the state of a Live Activity.\n\nTopics\nStarting a Live Activity\nstatic func request(attributes: Attributes, content: ActivityContent<Activity<Attributes>.ContentState>, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nlet attributes: Attributes\nA set of attributes that describe a Live Activity and its content.\nprotocol ActivityAttributes\nThe protocol you implement to describe the content of a Live Activity.\nvar content: ActivityContent<Activity<Attributes>.ContentState>\nThe dynamic content of a Live Activity.\nstruct ActivityContent\nA structure that describes the state and configuration of a Live Activity.\ntypealias ContentState\nThe type alias for the structure that describes the dynamic content of a Live Activity.\nstruct PushType\nThe structure that offers constants you use to configure a Live Activity to receive updates through ActivityKit push notifications.\nenum ActivityAuthorizationError\nAn error that indicates why the request to start a Live Activity failed.\nstatic func request(attributes: Attributes, contentState: Activity<Attributes>.ContentState, pushType: PushType?) throws -> Activity<Attributes>\nRequests and starts a Live Activity.\nvar contentState: Activity<Attributes>.ContentState\nThe dynamic content of a Live Activity.\nUpdating a Live Activity\nfunc update(ActivityContent<Activity<Attributes>.ContentState>) async\nUpdates the dynamic content of the Live Activity.\nfunc update(ActivityContent<Activity<Attributes>.ContentState>, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update.\nstruct AlertConfiguration\nA structure you use to configure an alert that appears when you update your Live Activity.\nfunc update(using: Activity<Attributes>.ContentState) async\nUpdates the dynamic content of the Live Activity.\nfunc update(using: Activity<Attributes>.ContentState, alertConfiguration: AlertConfiguration?) async\nUpdates the dynamic content of a Live Activity and alerts a person about the Live Activity update.\nEnding a Live Activity\nfunc end(ActivityContent<Activity<Attributes>.ContentState>?, dismissalPolicy: ActivityUIDismissalPolicy) async\nEnds an active Live Activity.\nstruct ActivityUIDismissalPolicy\nThe structure that describes when the system should remove a Live Activity that ended.\nfunc end(using: Activity<Attributes>.ContentState?, dismissalPolicy: ActivityUIDismissalPolicy) async\nEnds an active Live Activity.\nObserving Live Activity content changes\nvar contentUpdates: Activity<Attributes>.ContentUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity.\nstruct ContentUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nvar contentStateUpdates: Activity<Attributes>.ContentStateUpdates\nAn asynchronous sequence you use to observe changes to the dynamic content of a Live Activity.\nstruct ContentStateUpdates\nA structure that offers functionality to observe changes to the dynamic content of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nObserving the Live Activity life cycle\nvar activityState: ActivityState\nThe current state of a Live Activity in its life cycle.\nenum ActivityState\nThe enum that describes the state of a Live Activity in its life cycle.\nvar activityStateUpdates: Activity<Attributes>.ActivityStateUpdates\nAn asynchronous sequence you use to observe activity state changes.\nstruct ActivityStateUpdates\nA structure that offers functionality to observe state changes of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nUsing ActivityKit push notifications\nvar pushToken: Data?\nThe token you use to send ActivityKit push notifications to a Live Activity.\nvar pushTokenUpdates: Activity<Attributes>.PushTokenUpdates\nAn asynchronous sequence you use to observe changes to the push token of a Live Activity.\nstruct PushTokenUpdates\nA structure that offers functionality to observe changes to the push token of a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nstatic var pushToStartToken: Data?\nstatic var pushToStartTokenUpdates: Activity<Attributes>.PushTokenUpdates\nChecking user authorization\nclass ActivityAuthorizationInfo\nAn object with information about whether a person allowed your app to start Live Activities and permitted content updates with frequent ActivityKit push notifications.\nAccessing Live Activities\nstatic var activities: [Activity<Attributes>]\nAn array of your app’s current Live Activities.\nstatic var activityUpdates: Activity<Attributes>.ActivityUpdates\nAn asynchronous sequence you use to observe changes to ongoing Live Activities and to asynchronously access a Live Activity when you start it.\nstruct ActivityUpdates\nA structure that offers functionality to observe changes to a Live Activity.\nAvailable when Attributes conforms to ActivityAttributes.\nIdentifying a Live Activity\nlet id: String\nA unique identifier for a Live Activity.\nType Aliases\ntypealias ID\nA type representing the stable identity of the entity associated with an instance.\nRelationships\nConforms To\nIdentifiable\nSee Also\nLive Activity implementation\nDisplaying live data with Live Activities\nDisplay your app’s data in the Dynamic Island and on the Lock Screen and offer quick interactions.\nStarting and updating Live Activities with ActivityKit push notifications\nUse ActivityKit to receive push tokens and to remotely start, update, and end your Live Activity with ActivityKit notifications.\nAdding accessible descriptions to widgets and Live Activities\nDescribe the interface elements of your widgets and Live Activities to help people understand what they represent."
  },
  {
    "title": "Starting and updating Live Activities with ActivityKit push notifications | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/starting-and-updating-live-activities-with-activitykit-push-notifications",
    "html": "Overview\n\nActivityKit offers functionality to start, update, and end Live Activities from your app. Additionally, it offers functionality to receive push tokens. You can use push tokens to update and end Live Activities with ActivityKit push notifications that you send from your server to Apple Push Notification service (APNs). Starting with iOS 17.2 and iPadOS 17.2, you can also start Live Activities with ActivityKit push notifications.\n\nRelated session from WWDC23\n\nSession 10185: Update Live Activities with push notifications\n\nTo start and update your Live Activities with ActivityKit push notifications:\n\nUse ActivityKit functionality to obtain push tokens.\n\nSet up a remote notification server or make changes to your existing server to support ActivityKit push notifications. If you’re new to using push notifications, plan to spend time implementing your remote notification server. For more information, see Registering your app with APNs.\n\nSend the push tokens you receive from ActivityKit to your server and use them establish a token-based connection to APNs, as described in Establishing a token-based connection to APNs.\n\nHandle updates to the push tokens and update or invalidate them on your server as needed.\n\nSend ActivityKit push notifications from your server with APNs using the push tokens, HTTP header fields, and JSON payloads described in this article to start, update, and end Live Activities.\n\nTest ActivityKit push notifications locally and verify that your Live Activity behaves as expected.\n\nDecide the frequency for your ActivityKit push notifications. For more information, see the “Determine the update frequency” section below.\n\nAdd the Push Notifications capability\n\nIn your Xcode project, start by adding the Push Notifications capability to your app in Xcode as described in Registering your app with APNs. Note that you can’t use the UserNotifications framework to register your Live Activity for push notifications. Instead, you use ActivityKit to obtain a push token as described below.\n\nCreate a push notification server\n\nAdditionally, set up a remote notification server or make changes to your existing server and send JSON payloads to APNs as described below. If you’re new to using push notifications, plan to spend time implementing the remote notification server. For more information, see Registering your app with APNs. In your remote notification server, you use the push tokens you receive from ActivityKit to authenticate your server with APNs as described in Establishing a token-based connection to APNs.\n\nStart a Live Activity in your app that supports push updates\n\nOn devices that run iOS or iPadOS 17.1 and earlier, you can’t start Live Activities with ActivityKit push notifications. However, you can update and end them with ActivityKit push notifications. In your app, start a Live Activity with the request(attributes:content:pushType:) function and pass token to its pushType parameter. As a result, you receive a push token that’s unique to your Live Activity when you successfully start the Live Activity.\n\nThe following code snippet from the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project starts a Live Activity and requests a push token:\n\nfunc startActivity(hero: EmojiRanger) throws {\n    let adventure = AdventureAttributes(hero: hero)\n    let initialState = AdventureAttributes.ContentState(\n        currentHealthLevel: hero.healthLevel,\n        eventDescription: \"Adventure has begun!\"\n    )\n    \n    let activity = try Activity.request(\n        attributes: adventure,\n        content: .init(state: initialState, staleDate: nil),\n        pushType: .token\n    )\n  \n    // ...\n}\n\n\n\n\nEvery time you start a new Live Activity, you need to send the push token to your server. However, the pushToken isn’t available immediately after calling request(attributes:content:pushType:), because push token creation happens asynchronously and may take some time. Take this into account before accessing the pushToken synchronously. Instead, observe push token updates using the pushTokenUpdates asynchronous sequence. This makes sure you receive the first push token, and any updates to it.\n\nFor example, the following code snippet from the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project uses an asynchronous Task to receive push token updates. In the asynchronous for loop, it logs the updated token to the console for debugging and local testing, and sends it to the server:\n\nTask {\n    for await pushToken in activity.pushTokenUpdates {\n        let pushTokenString = pushToken.reduce(\"\") {\n\t          $0 + String(format: \"%02x\", $1)\n        }\n\n\n        Logger().log(\"New push token: \\(pushTokenString)\")\n                \n        try await self.sendPushToken(hero: hero, pushTokenString: pushTokenString)\n    }\n}\n\n\nThe push token for a Live Activity may change throughout its duration. When your app receives a new token, it receives foreground runtime to process the updated token. Keep track of the push token for each Live Activity. Additionally, invalidate the previous, now outdated token on your server when you receive an updated token to successfully send subsequent updates.\n\nStart new Live Activities with ActivityKit push notifications\n\nStarting with iOS 17.2 and iPadOS 17.2, you can start new Live Activities with ActivityKit push notifications. This option is especially useful for tracking events with Live Activities that occur more than once. For example, if someone starts a Live Activity to track a match of their favorite sports team, the sports app could offer to automatically start a Live Activity for each match of the team. In the future, the person wouldn’t have to remember to start the Live Activity from the app. Instead, a Live Activity for tracking the game could automatically start from an ActivityKit push notification you sent with your remote notification server and APNs.\n\nTo start Live Activities from ActivityKit push notifications, configure your app to support push notifications. Then obtain the token to for starting a Live Activity:\n\nUse the pushToStartTokenUpdates asynchronous sequence to retrieve a push-to-start token that allows you to start new Live Activities. You don’t have to start a Live Activity from your app to receive the push-to-start token.\n\nSend the push-to-start token to your server and use the pushToStartTokenUpdates sequence to receive token updates. Similar to the update token, update it on your server when needed and invalidate the old token.\n\nOn your push notification server, use the push-to-start token to send JSON payloads to APNs that start a new Live Activity.\n\nWhen the system receives the ActivityKit push notification on a device, it starts a new Live Activity, wakes up your app, and grants it background run time to allow you to download assets that the Live Activity needs.\n\nWhile the system starts the new Live Activity and wakes up your app, you receive the push token you use for updates. To update and end the Live Activity, use this update push token as if you obtained it by starting a Live Activity from within your app.\n\nConstruct the ActivityKit remote push notification payload\n\nTo successfully start, update, or end a Live Activity with an ActivityKit push notification, send an HTTP request to APNs that conforms to the following requirements:\n\nSet the value for the apns-push-type header field to liveactivity.\n\nSet the apns-topic header field using the following format: <your bundleID>.push-type.liveactivity.\n\nSet the value for the apns-priority header field to 5 or 10. For more information, see “Determine the update frequency” below.\n\nFor more information about request headers, see Sending notification requests to APNs.\n\nIn your request’s aps dictionary:\n\nSet the timestamp to the current time in seconds since 1970 to allow the system to always display the most recent ActivityKit push update.\n\nTo start a Live Activity, see “Construct the payload that starts a Live Activity” below.\n\nTo update a Live Activity, set the value for the event key to update.\n\nTo end a Live Activity, set the value for the event key to end. If you end a Live Activity, include the final content state to make sure the Live Activity displays the latest data after it ends.\n\nSet the fields for the content-state key to match your custom Activity.ContentState type. This ensures that the system can decode the JSON payload and update or end the Live Activity. Additionally, don’t use any custom JSON encoding strategies to encode your data, because the system always decodes JSON payloads for Live Activity updates using its default encoding strategies. Custom encoding strategies will result in update failures.\n\nTo mark a Live Activity as outdated with an update, optionally set the stale-date. For more information, see the “Mark a Live Activity as outdated by setting a stale date” section below.\n\nTo set a custom dismissal date that tells the system to remove an ended Live Activity from the Lock Screen, see the “End the Live Activity with a custom dismissal date” section below.\n\nTo alert a person about a critical Live Activity update, optionally provide an alert to light up their device and display the expanded presentation on devices that support the Dynamic Island or a banner on devices that don’t support it.\n\nThe following payload updates the Live Activity of the Emoji Rangers: Supporting Live Activities, interactivity, and animations example with the latest information. The content of content-state must match the properties of the custom Activity.ContentState type you declare in your ActivityAttributes implementation. In the example, content-state matches the properties of the custom AdventureAttributes.ContentState type of the sample code project. Additionally, the example payload includes an alert with a custom sound to let a person know that the hero has been knocked down and requires a healing potion.\n\n{\n    \"aps\": {\n        \"timestamp\": 1685952000,\n        \"event\": \"update\",\n        \"content-state\": {\n            \"currentHealthLevel\": 0.0,\n            \"eventDescription\": \"Power Panda has been knocked down!\"\n        },\n        \"alert\": {\n            \"title\": {\n                \"loc-key\": \"%@ is knocked down!\",\n                \"loc-args\": [\"Power Panda\"]\n            },\n            \"body\": {\n                \"loc-key\": \"Use a potion to heal %@!\",\n                \"loc-args\": [\"Power Panda\"]\n            },\n            \"sound\": \"HeroDown.mp4\"\n        }\n    }\n}\n\n\nIn your alert implementation, consider localizing both strings. For more information on displaying alerts for a remote notification, including localized alert messages and a reference of available keys, see Generating a remote notification.\n\nRemember that a person’s device may not receive a push notification — for example, if a person is in an area without a network connection. Similarly, the system ignores an ActivityKit push notification if it arrives after the Live Activity ended. Both cases can cause a Live Activity to display outdated information. To help reduce the chance of showing outdated information, update your Live Activity from your app in addition to push notifications.\n\nNote\n\nWhen you send ActivityKit push notifications to a device, the system wakes the widget extension to render the UI of your Live Activity.\n\nConstruct the payload that starts a Live Activity\n\nThe JSON payload for starting a Live Activity with an ActivityKit push notification is similar to the payload you use for updates. However, it comes with the following requirements:\n\nSet the value of the event field to start.\n\nInclude an alert in the JSON payload.\n\nInclude the attributes-type and attributes keys.\n\nBy including an alert in your JSON payload, you make sure a person gets alerted about the started Live Activity and avoid unexpectedly surprising them. The following sample payload starts a Live Activity:\n\n{\n    \"aps\": {\n        \"timestamp\": 1234,\n        \"event\": \"start\",\n        \"content-state\": {\n            \"currentHealthLevel\": 100,\n            \"eventDescription\": \"Adventure has begun!\"\n        },\n        \"attributes-type\": \"AdventureAttributes\",\n        \"attributes\": {\n            \"currentHealthLevel\": 100,\n            \"eventDescription\": \"Adventure has begun!\"\n        },\n         \"alert\": {\n            \"title\": {\n                \"loc-key\": \"%@ is on an adventure!\",\n                \"loc-args\": [\"Power Panda\"]\n            },\n            \"body\": {\n                \"loc-key\": \"%@ found a sword!\",\n                \"loc-args\": [\"Power Panda\"]\n            },\n            \"sound\": \"chime.aiff\"\n        }\n    }\n}\n\nTest Live Activity updates locally\n\nDuring development, verify your JSON payloads and Live Activity updates locally. Using command-line tools and Simulator or a test device, you can send a JSON payload from the command line to APNs and receive Live Activity updates to verify that your payload updates the Live Activity and the Live Activity behaves as expected.\n\nTo locally test Live Activity updates during development:\n\nSet up your command line as described in the “Send a Push Notification Using a Token” section of Sending push notifications using command-line tools.\n\nAdd code that logs the push token to the console when you start a new Live Activity in your app.\n\nRun your app in Simulator or on a test device and start a Live Activity.\n\nCopy the logged push token from the console and set it as the $ACTIVITY_PUSH_TOKEN environment variable in Terminal.\n\nUse a curl command to send a Live Activity update using APNs. Set the value of the apns-priority header field to 10 to deliver the update quickly with high priority.\n\nThe following example shows a curl command that the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project could use to test a Live Activity update.\n\ncurl \\\n --header \"apns-topic: com.example.apple-samplecode.Emoji-Rangers.push-type.liveactivity\" \\\n --header \"apns-push-type: liveactivity\" \\\n --header \"apns-priority: 10\" \\\n --header \"authorization: bearer $AUTHENTICATION_TOKEN\" \\\n --data '{\n     \"aps\": {\n         \"timestamp\": '$(date +%s)',\n         \"event\": \"update\",\n         \"content-state\": {\n             \"currentHealthLevel\": 0.941,\n             \"eventDescription\": \"Power Panda found a sword!\"\n         }\n     }\n }' \\\n --http2 https://api.sandbox.push.apple.com/3/device/$ACTIVITY_PUSH_TOKEN\n\n\nNote\n\nTo test ActivityKit push notifications in Simulator, use a Mac with the Apple T2 Security Chip or a Mac with Apple silicon that runs macOS 13 or later.\n\nIf you encounter failures while sending an ActivityKit push notification:\n\nEnsure the curl command was successful. An error might indicate an incorrect field for the request or errors setting up the command-line environment.\n\nUse the Console app to view device logs and look for errors that could help you understand the issue. Processes in Console that may contain relevant information are liveactivitiesd, apsd, and chronod.\n\nDetermine the update frequency\n\nThe system allows for a certain budget of ActivityKit push notifications per hour. As with other push notifications you send with APNs, you can set the HTTP header field apns-priority for your requests to specify the priority of an ActivityKit push notification:\n\nIf you don’t specify the apns-priority value, APNs delivers the ActivityKit push notification immediately with the default priority of 10 and counts it toward the notification budget that the system imposes.\n\nIf you exceed the budget, the system may throttle your ActivityKit push notifications.\n\nTo avoid throttling, you can send a low-priority ActivityKit push notification that doesn’t count toward the budget by setting the HTTP header field apns-priority to 5. Consider this lower priority first before using the priority of 10. In many cases, choosing a mix of priority 5 and 10 for updates prevents your Live Activity updates from being throttled. For example, the Live Activity of the Emoji Rangers: Supporting Live Activities, interactivity, and animations sample code project could use priority 5 for updates that don’t require a person’s immediate attention, like when the hero heals by a few points. When the hero requires a healing potion, the example would use a priority of 10 to immediately update the Live Activity and let the user know about the important change.\n\nHowever, your app may need to update its Live Activity more frequently, causing you to hit the budget limit for ActivityKit push notifications. For example, if your app allows people to track a sports event like a basketball match that requires many updates per minute, you may not be able to update your Live Activity often enough.\n\nTo allow for use cases like this, you can enable your Live Activities to receive frequent ActivityKit push notifications:\n\nIf your project includes an Info.plist file, add the NSSupportsLiveActivitiesFrequentUpdates entry to it, and set its Boolean value to YES.\n\nAlternatively, open the Info.plist file as source code, add the key NSSupportsLiveActivitiesFrequentUpdates, then set the type to Boolean and its value to YES. If your project doesn’t have an Info.plist file, add NSSupportsLiveActivitiesFrequentUpdates to the list of custom iOS target properties for your iOS app target and set its value to YES.\n\nPeople can deactivate frequent ActivityKit push notifications for your app in the Settings app. In your code, use frequentPushesEnabled to detect whether a person deactivated frequent push notifications and display information in your app that asks them to activate frequent ActivityKit push notifications again. Additionally, send the value of this setting to your server and adjust the update frequency accordingly.\n\nSimilarly to other asynchronous sequences ActivityKit provides to receive configuration updates, you can also subscribe to changes to the frequent Live Activity push notification setting setting with the frequentPushEnablementUpdates stream.\n\nFor more information on available HTTPs headers and sending requests to APNs, see Sending notification requests to APNs.\n\nEnd the Live Activity with a custom dismissal date\n\nWhen you end a Live Activity, by default the Live Activity appears on the Lock Screen for up to four hours after it ends to allow people to glance at their phone to see the latest information. To change the time until the system removes a Live Activity from the Lock Screen after it ends, include the \"dismissal-date\" entry in the \"aps\" dictionary of your JSON payload. If you don’t include the \"dismissal-date\", your Live Activity uses the system’s default dismissal behavior. To dismiss the Live Activity from the Lock Screen immediately after it ends, provide a date for \"dismissal-date\" that’s in the past — for example, \"dismissal-date\": 1663177260. Alternatively, provide a date within a four-hour window to set a custom dismissal date.\n\nMark a Live Activity as outdated by setting a stale date\n\nIn some scenarios — for example, if a person enters an area without network connectivity — you might not be able update the Live Activity with new information, causing it to display outdated data. To provide the best possible user experience and let the person know that the Live Activity displays outdated information, add a timestamp in the optional stale-date field to provide the time when the system will consider the Live Activity to be stale. With each update, you can advance this stale-date. When you can’t update the Live Activity for some time until it becomes stale, the activityState changes to ActivityState.stale at the specified date. Use the activityStateUpdates stream in your app to monitor the activity state and respond to outdated Live Activities that haven’t received updates. For example, while a person has network connectivity, a sports app could update the Live Activity with the latest game information and advance the stale date. When it becomes stale, it displays text to indicate that the displayed information is outdated.\n\nDisplay the most important Live Activity in the Dynamic Island\n\nIf your app starts more than one Live Activity, provide a relevance-score in your JSON payload to determine the order of your Live Activities on the Lock Screen and which of your Live Activities appears in the Dynamic Island:\n\nIf you don’t provide a relevance score or if Live Activities have the same relevance score, the system shows the first Live Activity you started in the Dynamic Island.\n\nIf you use different relevance scores, the system shows the Live Activity with the highest relevance score in the Dynamic Island.\n\nThe system expects relative values for the relevance score. Assign a higher value for an important Live Activity content update — for example, a score of 100 — and use lower values for less important Live Activity content updates — for example, 50.\n\nNote\n\nKeep track of the relevance scores you assign for each ongoing Live Activity so you can change the order of them as needed with each Live Activity update.\n\nThe following example payload provides a relevance score of 100 to make sure the Live Activity that receives the update appears in the Dynamic Island and at top of the list on the Lock Screen:\n\n{\n    \"aps\": {\n        \"timestamp\": 1685952000,\n        \"event\": \"update\",\n        \"relevance-score\": 100,\n        \"content-state\": {\n            \"currentHealthLevel\": 0.941,\n            \"eventDescription\": \"Power Panda found a sword!\"\n        }\n    }\n}\n\nSee Also\nLive Activity implementation\nDisplaying live data with Live Activities\nDisplay your app’s data in the Dynamic Island and on the Lock Screen and offer quick interactions.\nAdding accessible descriptions to widgets and Live Activities\nDescribe the interface elements of your widgets and Live Activities to help people understand what they represent.\nclass Activity\nThe object you use to start, update, and end a Live Activity."
  },
  {
    "title": "Adding accessible descriptions to widgets and Live Activities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit/adding-accessible-descriptions-to-widgets-and-live-activities",
    "html": "Overview\n\nDesigning with accessibility in mind is a foundational principle when creating an app. It also applies to widgets and Live Activities. To allow people to customize how they interact with your widget or Live Activity, to verify VoiceOver works correctly for them, and to help people understand what each interface element represents, add accessibility labels to the SwiftUI views you create for each widget and Live Activity presentation.\n\nProvide accessibility labels\n\nAdd accessibility labels for each SwiftUI view you use as needed and make sure your accessibility labels fit the widget or Live Activity content. To review API that allows you to add accessible descriptions to SwiftUI views, see Accessible descriptions.\n\nThe example below shows how the Emoji Rangers: Supporting Live Activities, interactivity, and animations app uses the accessibilityLabel(_:) modifier to add an accessibility labels for minimal, compact leading, and compact trailing presentations.\n\nimport SwiftUI\nimport WidgetKit\n\n\nstruct AdventureActivityConfiguration: Widget {\n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: AdventureAttributes.self) { context in\n            // Create the presentation that appears on the Lock Screen and as a\n            // banner on the Home Screen of devices that don't support the\n            // Dynamic Island.\n            // ...\n        } dynamicIsland: { context in\n            // Create the presentations that appear in the Dynamic Island.\n            DynamicIsland {\n                // Create the expanded presentation.\n                // ...\n            } compactLeading: {\n                // Create the compact leading presentation.\n                Avatar(hero: context.attributes.hero, includeBackground: true)\n                    .accessibilityLabel(\"The avatar of \\(context.attributes.hero.name).\")\n            } compactTrailing: {\n                // Create the compact trailing presentation.\n                ProgressView(value: context.state.currentHealthLevel, total: 1) {\n                    let healthLevel = Int(context.state.currentHealthLevel * 100)\n                    Text(\"\\(healthLevel)\")\n                        .accessibilityLabel(\"Health level at \\(healthLevel) percent.\")\n                }\n                .progressViewStyle(.circular)\n                .tint(context.state.currentHealthLevel <= 0.2 ? Color.red : Color.green)\n            } minimal: {\n                 // Create the minimal presentation.\n                ProgressView(value: context.state.currentHealthLevel, total: 1) {\n                    Avatar(hero: context.attributes.hero, includeBackground: false)\n                        .accessibilityLabel(\"The avatar of \\(context.attributes.hero.name).\")\n                }\n                .progressViewStyle(.circular)\n                .tint(context.state.currentHealthLevel <= 0.2 ? Color.red : Color.green)\n            }\n        }\n    }\n}\n\n\nIf you provide a content description for an image you update while a Live Activity is active and the image conveys status information or similar, make sure to also update the accessibility label to match the updated status. For example, if an image indicates a delivery status, make sure the accessibility label changes as the delivery status that the image indicates changes. Similarly, update accessibility labels when a widget updates displayed images or SwiftUI views. For guidance on providing content descriptions, see Human Interface Guidelines > Accessibility > VoiceOver > Content descriptions.\n\nSee Also\nLive Activity implementation\nDisplaying live data with Live Activities\nDisplay your app’s data in the Dynamic Island and on the Lock Screen and offer quick interactions.\nStarting and updating Live Activities with ActivityKit push notifications\nUse ActivityKit to receive push tokens and to remotely start, update, and end your Live Activity with ActivityKit notifications.\nclass Activity\nThe object you use to start, update, and end a Live Activity."
  },
  {
    "title": "ActivityKit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/activitykit",
    "html": "Overview\n\nWith the ActivityKit framework, you can start a Live Activity to share live updates from your app in the Dynamic Island and on the Lock Screen. Especially for apps that push the limit of notifications to provide updated information, Live Activities can offer a richer, interactive and highly glanceable way for people to keep track of an event or activity over a couple of hours. For example, a sports app might start a Live Activity that makes live information available at a glance for the duration of a game.\n\nA Live Activity appears in highly visible contexts:\n\nOn the Lock Screen of iPhone and iPad, it appears at the top of the list alongside notifications.\n\nOn devices that support it, the Live Activity appears in the Dynamic Island.\n\nOn iPhone in StandBy, it appears using a minimal presentation at the top of the screen or scaled to fill the display.\n\nOn the Home Screen and when other apps are in use, updates appear as a banner at the top of the screen of devices that don’t support the Dynamic Island if the update includes an alert configuration.\n\nRelated sessions from WWDC23\n\nSession 10184: Meet ActivityKit, Session 10185: Update Live Activities with push notifications, and Session 10194: Design dynamic Live Activities\n\nIn addition to viewing real-time information, people tap a Live Activity to launch your app and interact with its buttons or toggles to perform essential functionality without launching your app. In the Dynamic Island, people touch and hold the compact and minimal presentations to show an expanded presentation with more content that feels like a peek into your app.\n\nIn your app, use ActivityKit to configure, start, update, and end the Live Activity, and create the user interface of your Live Activities with a widget extension, SwiftUI, and WidgetKit. As a result of using SwiftUI and WidgetKit, you can share code between widgets and Live Activities or develop them in tandem.\n\nHowever, Live Activities use a different mechanism to receive updates compared to widgets. Instead of using a timeline mechanism, Live Activities receive updated data from your app with ActivityKit and remotely with ActivityKit push notifications. Starting with iOS 17.2 and iPadOS 17.2, you can also start Live Activities with ActivityKit push notifications.\n\nNote\n\nvisionOS doesn’t load WidgetKit extensions found in compatible iPad and iPhone apps. As a result, it doesn’t support Live Activities.\n\nTopics\nEssentials\nDeveloping a WidgetKit strategy\nExplore features, tasks, related frameworks, and constraints as you make a plan to implement widgets, watch complications, and Live Activities.\nLive Activity implementation\nDisplaying live data with Live Activities\nDisplay your app’s data in the Dynamic Island and on the Lock Screen and offer quick interactions.\nStarting and updating Live Activities with ActivityKit push notifications\nUse ActivityKit to receive push tokens and to remotely start, update, and end your Live Activity with ActivityKit notifications.\nAdding accessible descriptions to widgets and Live Activities\nDescribe the interface elements of your widgets and Live Activities to help people understand what they represent.\nclass Activity\nThe object you use to start, update, and end a Live Activity.\nEmoji Rangers: Supporting Live Activities, interactivity, and animations\nOffer Live Activities, animate data updates, and add interactivity to widgets.\nproperty list key NSSupportsLiveActivities\nA Boolean value that indicates whether an app supports Live Activities.\nproperty list key NSSupportsLiveActivitiesFrequentUpdates\nA Boolean value that indicates whether an app can update its Live Activities frequently.\nWidget extensions\nWidgetKit\nExtend the reach of your app by creating widgets, watch complications, and Live Activities.\nCreating a widget extension\nDisplay your app’s content in a convenient, informative widget on various devices.\nAnimating data updates in widgets and Live Activities\nUse SwiftUI animations to indicate data updates in your widgets and Live Activities.\nUser interface\nCreating views for widgets, Live Activities, and watch complications\nImplement glanceable views with WidgetKit and SwiftUI.\nLinking to specific app scenes from your widget or Live Activity\nAdd deep links to your widgets and Live Activities that enable people to open a specific scene in your app."
  }
]
