[
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/uiapplicationdelegateadaptor/init(_:)-2zc7c",
        "html": "Parameters\ndelegateType\n\nThe type of application delegate that you define in your app, which conforms to the UIApplicationDelegate and Observable protocols.\n\nDiscussion\n\nCall this initializer indirectly by creating a property with the UIApplicationDelegateAdaptor property wrapper from inside your App declaration:\n\n@main\nstruct MyApp: App {\n    @UIApplicationDelegateAdaptor private var appDelegate: MyAppDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI initializes the delegate and manages its lifetime, calling it as needed to handle application delegate callbacks.\n\nSwiftUI invokes this method when your app delegate conforms to the Observable protocol. In this case, SwiftUI automatically places the delegate in the Environment. You can access such a delegate from any scene or view in your app using the Environment property wrapper:\n\n@Environment(MyAppDelegate.self) private var appDelegate\n\n\nIf your delegate isn\u2019t observable, SwiftUI invokes the init(_:) initializer rather than this one, and doesn\u2019t put the delegate instance in the environment.\n\nSee Also\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates a UIKit app delegate adaptor.\ninit(DelegateType.Type)\nCreates a UIKit app delegate adaptor using a delegate that\u2019s an observable object.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to UIApplicationDelegate."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/uiapplicationdelegateadaptor/init(_:)-59sfu",
        "html": "Parameters\ndelegateType\n\nThe type of application delegate that you define in your app, which conforms to the UIApplicationDelegate protocol.\n\nDiscussion\n\nCall this initializer indirectly by creating a property with the UIApplicationDelegateAdaptor property wrapper from inside your App declaration:\n\n@main\nstruct MyApp: App {\n    @UIApplicationDelegateAdaptor private var appDelegate: MyAppDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI initializes the delegate and manages its lifetime, calling upon it to handle application delegate callbacks.\n\nIf you want SwiftUI to put the instantiated delegate in the Environment, make sure the delegate class also conforms to the ObservableObject protocol. That causes SwiftUI to invoke the init(_:) initializer rather than this one.\n\nSee Also\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates a UIKit app delegate adaptor using a delegate that\u2019s an observable object.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to UIApplicationDelegate.\ninit(DelegateType.Type)\nCreates a UIKit app delegate adaptor using an observable delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to Observable, and DelegateType conforms to UIApplicationDelegate."
    },
    {
        "title": "selectionDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/selectiondisabled(_:)",
        "html": "Parameters\nisDisabled\n\nA Boolean value that determines whether users can select this view.\n\nDiscussion\n\nUse this modifier to control the selectability of views in selectable containers like List or Table. In the example, below, the user can\u2019t select the first item in the list.\n\n@Binding var selection: Item.ID?\n@Binding var items: [Item]\n\n\nvar body: some View {\n    List(selection: $selection) {\n        ForEach(items) { item in\n            ItemView(item: item)\n                .selectionDisabled(item.id == items.first?.id)\n        }\n    }\n}\n\n\nYou can also use this modifier to specify the selectability of views within a Picker. The following example represents a flavor picker that disables selection on flavors that are unavailable.\n\nPicker(\"Flavor\", selection: $selectedFlavor) {\n    ForEach(Flavor.allCases) { flavor in\n        Text(flavor.rawValue.capitalized)\n            .selectionDisabled(isSoldOut(flavor))\n    }\n}\n\nSee Also\nConfiguring interaction\nfunc swipeActions<T>(edge: HorizontalEdge, allowsFullSwipe: Bool, content: () -> T) -> some View\nAdds custom swipe actions to a row in a list."
    },
    {
        "title": "SearchSuggestionsPlacement.Set",
        "url": "https://developer.apple.com/documentation/swiftui/searchsuggestionsplacement/set",
        "html": "Topics\nGetting placement sets\nstatic var content: SearchSuggestionsPlacement.Set\nA set containing placements with the apps main content, excluding the menu placement.\nstatic var menu: SearchSuggestionsPlacement.Set\nA set containing the menu display mode.\nCreating a set\ninit(rawValue: Int)\nCreates a set of search suggestions from an integer.\nvar rawValue: Int\nThe raw value that records the search suggestion display modes.\nSupporting types\ntypealias Element\nA type for the elements of the set.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra"
    },
    {
        "title": "refresh",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/refresh",
        "html": "Discussion\n\nWhen this environment value contains an instance of the RefreshAction structure, certain built-in views in the corresponding Environment begin offering a refresh capability. They apply the instance\u2019s handler to any refresh operation that the user initiates. By default, the environment value is nil, but you can use the refreshable(action:) modifier to create and store a new refresh action that uses the handler that you specify:\n\nList(mailbox.conversations) { conversation in\n    ConversationCell(conversation)\n}\n.refreshable {\n    await mailbox.fetch()\n}\n\n\nOn iOS and iPadOS, the List in the example above offers a pull to refresh gesture because it detects the refresh action. When the user drags the list down and releases, the list calls the action\u2019s handler. Because SwiftUI declares the handler as asynchronous, it can safely make long-running asynchronous calls, like fetching network data.\n\nRefreshing custom views\n\nYou can also offer refresh capability in your custom views. Read the refresh environment value to get the RefreshAction instance for a given Environment. If you find a non-nil value, change your view\u2019s appearance or behavior to offer the refresh to the user, and call the instance to conduct the refresh. You can call the refresh instance directly because it defines a callAsFunction() method that Swift calls when you call the instance:\n\nstruct RefreshableView: View {\n    @Environment(\\.refresh) private var refresh\n\n\n    var body: some View {\n        Button(\"Refresh\") {\n            Task {\n                await refresh?()\n            }\n        }\n        .disabled(refresh == nil)\n    }\n}\n\n\nBe sure to call the handler asynchronously by preceding it with await. Because the call is asynchronous, you can use its lifetime to indicate progress to the user. For example, you can reveal an indeterminate ProgressView before calling the handler, and hide it when the handler completes.\n\nIf your code isn\u2019t already in an asynchronous context, create a Task for the method to run in. If you do this, consider adding a way for the user to cancel the task. For more information, see Concurrency in The Swift Programming Language.\n\nSee Also\nRefreshing a list\u2019s content\nfunc refreshable(action: () async -> Void) -> some View\nMarks this view as refreshable.\nstruct RefreshAction\nAn action that initiates a refresh operation."
    },
    {
        "title": "wrappedValue",
        "url": "https://developer.apple.com/documentation/swiftui/uiapplicationdelegateadaptor/wrappedvalue",
        "html": "See Also\nGetting the delegate adaptor\nvar projectedValue: ObservedObject<DelegateType>.Wrapper\nA projection of the observed object that provides bindings to its properties.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to UIApplicationDelegate."
    },
    {
        "title": "readableContentTypes",
        "url": "https://developer.apple.com/documentation/swiftui/filedocument/readablecontenttypes",
        "html": "Required\n\nDiscussion\n\nDefine this list to indicate the content types that your document can read. By default, SwiftUI assumes that your document can also write the same set of content types. If you need to indicate a different set of types for writing files, define the writableContentTypes property in addition to this property.\n\nSee Also\nReading a document\ninit(configuration: Self.ReadConfiguration) throws\nCreates a document and initializes it with the contents of a file.\n\nRequired\n\ntypealias ReadConfiguration\nThe configuration for reading document contents."
    },
    {
        "title": "listRowInsets(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/listrowinsets(_:)",
        "html": "Parameters\ninsets\n\nThe EdgeInsets to apply to the edges of the view.\n\nReturn Value\n\nA view that uses the given edge insets when used as a list cell.\n\nDiscussion\n\nUse listRowInsets(_:) to change the default padding of the content of list items.\n\nIn the example below, the Flavor enumeration provides content for list items. The SwiftUI ForEach structure computes views for each element of the Flavor enumeration and extracts the raw value of each of its elements using the resulting text to create each list row item. The listRowInsets(_:) modifier then changes the edge insets of each row of the list according to the EdgeInsets provided:\n\nstruct ContentView: View {\n    enum Flavor: String, CaseIterable, Identifiable {\n        var id: String { self.rawValue }\n        case vanilla, chocolate, strawberry\n    }\n\n\n    var body: some View {\n        List {\n            ForEach(Flavor.allCases) {\n                Text($0.rawValue)\n                    .listRowInsets(.init(top: 0,\n                                         leading: 25,\n                                         bottom: 0,\n                                         trailing: 0))\n            }\n        }\n    }\n}\n\n\nSee Also\nConfiguring rows\nfunc listRowHoverEffect(HoverEffect?) -> some View\nRequests that the containing list row use the provided hover effect.\nBeta\nfunc listRowHoverEffectDisabled(Bool) -> some View\nRequests that the containing list row have its hover effect disabled.\nBeta\nfunc listItemTint(Color?) -> some View\nSets a fixed tint color associated with specific content in a list.\nfunc listItemTint(ListItemTint?) -> some View\nSets the tint effect for content in a list.\nstruct ListItemTint\nThe configuration of a tint effect applied to content within a List.\nvar defaultMinListRowHeight: CGFloat\nThe default minimum height of a row in a list."
    },
    {
        "title": "automatic",
        "url": "https://developer.apple.com/documentation/swiftui/windowtoolbarstyle/automatic",
        "html": "See Also\nGetting built-in window toolbar styles\nstatic var expanded: ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nAvailable when Self is ExpandedWindowToolbarStyle.\nstatic var unified: UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic func unified(showsTitle: Bool) -> UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic var unifiedCompact: UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle.\nstatic func unifiedCompact(showsTitle: Bool) -> UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle."
    },
    {
        "title": "style",
        "url": "https://developer.apple.com/documentation/swiftui/strokebordershapeview/style",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape."
    },
    {
        "title": "init(topLeading:bottomLeading:bottomTrailing:topTrailing:)",
        "url": "https://developer.apple.com/documentation/swiftui/rectanglecornerradii/init(topleading:bottomleading:bottomtrailing:toptrailing:)",
        "html": "Parameters\ntopLeading\n\nthe radius of the top-leading corner.\n\nbottomLeading\n\nthe radius of the bottom-leading corner.\n\nbottomTrailing\n\nthe radius of the bottom-trailing corner.\n\ntopTrailing\n\nthe radius of the top-trailing corner."
    },
    {
        "title": "topLeading",
        "url": "https://developer.apple.com/documentation/swiftui/rectanglecornerradii/topleading",
        "html": "See Also\nGetting values for specific corners\nvar topTrailing: CGFloat\nThe radius of the top-trailing corner.\nvar bottomLeading: CGFloat\nThe radius of the bottom-leading corner.\nvar bottomTrailing: CGFloat\nThe radius of the bottom-trailing corner."
    },
    {
        "title": "bottomTrailing",
        "url": "https://developer.apple.com/documentation/swiftui/rectanglecornerradii/bottomtrailing",
        "html": "See Also\nGetting values for specific corners\nvar topLeading: CGFloat\nThe radius of the top-leading corner.\nvar topTrailing: CGFloat\nThe radius of the top-trailing corner.\nvar bottomLeading: CGFloat\nThe radius of the bottom-leading corner."
    },
    {
        "title": "init(_:for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:for:content:)-58ovx",
        "html": "Parameters\ntitle\n\nThe string to use for the title of the group.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nCreating a data-driven window group\ninit<D, C>(for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string.\nAvailable when Content conforms to View.\ninit<D, C>(Text, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:for:content:)-67oml",
        "html": "Parameters\ntitle\n\nThe Text view to use for the group\u2019s title.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the given view as a template to form the content of each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nImportant\n\nThe system ignores any text styling that you apply to the Text view title, like bold or italics. However, you can use the formatting controls that the view offers, like for localization, dates, and numerical representations.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nCreating a data-driven window group\ninit<D, C>(for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string.\nAvailable when Content conforms to View."
    },
    {
        "title": "callAsFunction(id:)",
        "url": "https://developer.apple.com/documentation/swiftui/openwindowaction/callasfunction(id:)",
        "html": "Parameters\nid\n\nThe identifier of the scene to present.\n\nDiscussion\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the openWindow action with an identifier:\n\nopenWindow(id: \"message\")\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language.\n\nSee Also\nCalling the action\nfunc callAsFunction<D>(id: String, value: D)\nOpens a window defined by the window group that presents the specified value type and that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(value: D)\nOpens a window defined by a window group that presents the type of the specified value."
    },
    {
        "title": "FullImmersionStyle",
        "url": "https://developer.apple.com/documentation/swiftui/fullimmersionstyle",
        "html": "Overview\n\nYour space\u2019s content fully obscures the passthrough video except for the user\u2019s hands, if configured accordingly.\n\nUse full to construct this style.\n\nTopics\nCreating the immersion style\ninit()\nRelationships\nConforms To\nImmersionStyle\nSee Also\nSupporting types\nstruct AutomaticImmersionStyle\nThe default style of immersive spaces.\nBeta\nstruct MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nBeta\nstruct ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nBeta"
    },
    {
        "title": "ReferenceFileDocument.ReadConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument/readconfiguration",
        "html": "Discussion\n\nThis type is an alias for FileDocumentReadConfiguration, which contains a content type and a file wrapper that you use to access the contents of a document file. You get a value of this type as an input to the init(configuration:) initializer. Use it to load a document from a file.\n\nSee Also\nReading a document\ninit(configuration: Self.ReadConfiguration) throws\nCreates a document and initializes it with the contents of a file.\n\nRequired\n\nstatic var readableContentTypes: [UTType]\nThe file and data types that the document reads from.\n\nRequired"
    },
    {
        "title": "init(viewing:contentType:viewer:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(viewing:contenttype:viewer:)-75r8",
        "html": "Parameters\nmodelTypes\n\nThe model types defining the schema used for each document.\n\ncontentType\n\nThe content type of document your app can view. It should conform to UTType.package.\n\nviewer\n\nThe viewing UI for the provided document.\n\nDiscussion\n @main\n struct Todo: App {\n     var body: some Scene {\n         DocumentGroup(viewing: [TodoItem.self, CalendarEvent.self], contentType: .tasks) {\n             ContentView()\n         }\n     }\n }\n\n\n struct ContentView: View {\n     @Query var items: [TodoItem]\n     @Query var events: [CalendarEvent]\n\n\n     var body: some View {\n         Form {\n             Section(\"Todo\") {\n                 ForEach(items) { item in\n                     Image(systemName: item.isDone ? \"checkmark.square\" : \"square\")\n                 }\n             }\n             Section(\"Events\") {\n                 ForEach(events) { event in\n                     LabeledContent(event.title, value: event.date.formatted())\n                  }\n              }\n         }\n         .formStyle(.grouped)\n         .padding()\n     }\n }\n\n\n @Model\n final class TodoItem {\n     var created: Date\n     var text: String\n     var isDone = false\n }\n\n\n @Model\n final class CalendarEvent {\n     var title: String\n     var date: Date\n}\n\n\n\n\n extension UTType {\n     static var tasks = UTType(exportedAs: \"com.myApp.tasks\")\n }\n\n\nImportant\n\nIf your app declares custom uniform type identifiers, include corresponding entries in the app\u2019s Info.plist. For more information, see Defining file and data types for your app. Also, remember to specify the supported Document types in the Info.plist as well.\n\nSee Also\nViewing a document backed by a persistent store\ninit(viewing: PersistentModel.Type, contentType: UTType, viewer: () -> Content)\nInstantiates a document group for viewing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(viewing: UTType, migrationPlan: SchemaMigrationPlan.Type, viewer: () -> Content)\nInstantiates a document group for viewing documents described by the last Schema in the migration plan.\nAvailable when Document is ModelDocument and Content conforms to View."
    },
    {
        "title": "init(editing:contentType:editor:prepareDocument:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(editing:contenttype:editor:preparedocument:)-7uvjw",
        "html": "Parameters\nmodelType\n\nThe model type defining the schema used for each document.\n\ncontentType\n\nThe content type of the document. It should conform to UTType.package.\n\neditor\n\nThe editing UI for the provided document.\n\nprepareDocument\n\nThe optional closure that accepts ModelContext associated with the new document. Use this closure to set the document\u2019s initial contents before it is displayed: insert preconfigured models in the provided ModelContext.\n\nDiscussion\n @main\n struct Todo: App {\n     var body: some Scene {\n         DocumentGroup(editing: TodoItem.self, contentType: .todoItem) {\n             ContentView()\n         }\n     }\n }\n\n\n struct ContentView: View {\n     @Query var items: [TodoItem]\n\n\n         var body: some View {\n             List {\n                 ForEach(items) { item in\n                     @Bindable var item = item\n                     Toggle(item.text, isOn: $item.isDone)\n                 }\n              }\n         }\n }\n\n\n @Model\n final class TodoItem {\n     var created: Date\n     var text: String\n     var isDone = false\n }\n\n\n extension UTType {\n     static var todoItem = UTType(exportedAs: \"com.myApp.todoItem\")\n }\n\n\nImportant\n\nIf your app declares custom uniform type identifiers, include corresponding entries in the app\u2019s Info.plist. For more information, see Defining file and data types for your app. Also, remember to specify the supported Document types in the Info.plist as well.\n\nSee Also\nEditing a document backed by a persistent store\ninit(editing: [PersistentModel.Type], contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store several model types.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(editing: UTType, migrationPlan: SchemaMigrationPlan.Type, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents described by the last Schema in the migration plan.\nAvailable when Document is ModelDocument and Content conforms to View."
    },
    {
        "title": "init(editing:contentType:editor:prepareDocument:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(editing:contenttype:editor:preparedocument:)-4gw67",
        "html": "Parameters\nmodelTypes\n\nThe array of model types defining the schema used for each document.\n\ncontentType\n\nThe content type of the document. It should conform to UTType.package.\n\neditor\n\nThe editing UI for the provided document.\n\nprepareDocument\n\nThe optional closure that accepts ModelContext associated with the new document. Use this closure to set the document\u2019s initial contents before it is displayed: insert preconfigured models in the provided ModelContext.\n\nDiscussion\n @main\n struct Todo: App {\n     var body: some Scene {\n         DocumentGroup(editing: [TodoItem.self, CalendarEvent.self], contentType: .tasks) {\n             ContentView()\n         }\n     }\n }\n\n\n struct ContentView: View {\n     @Query var items: [TodoItem]\n     @Query var events: [CalendarEvent]\n\n\n     var body: some View {\n         Form {\n             Section(\"Todo\") {\n                 ForEach(items) { item in\n                     @Bindable var item = item\n                     Toggle(item.text, isOn: $item.isDone)\n                 }\n             }\n             Section(\"Events\") {\n                 ForEach(events) { event in\n                     LabeledContent(event.title, value: event.date.formatted())\n                  }\n              }\n         }\n         .formStyle(.grouped)\n         .padding()\n     }\n }\n\n\n @Model\n final class TodoItem {\n     var created: Date\n     var text: String\n     var isDone = false\n }\n\n\n @Model\n final class CalendarEvent {\n     var title: String\n     var date: Date\n}\n\n\n\n\n extension UTType {\n     static var tasks = UTType(exportedAs: \"com.myApp.tasks\")\n }\n\n\nImportant\n\nIf your app declares custom uniform type identifiers, include corresponding entries in the app\u2019s Info.plist. For more information, see Defining file and data types for your app. Also, remember to specify the supported Document types in the Info.plist as well.\n\nSee Also\nEditing a document backed by a persistent store\ninit(editing: PersistentModel.Type, contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(editing: UTType, migrationPlan: SchemaMigrationPlan.Type, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents described by the last Schema in the migration plan.\nAvailable when Document is ModelDocument and Content conforms to View."
    },
    {
        "title": "init(editing:migrationPlan:editor:prepareDocument:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(editing:migrationplan:editor:preparedocument:)",
        "html": "Parameters\nediting\n\nThe content type of the document. It should conform to UTType.package.\n\nmigrationPlan\n\nThe description of steps required to migrate older document versions so that they can be opened and edited. The last VersionedSchema in the plan is considered to be the current application schema.\n\neditor\n\nThe editing UI for the provided document.\n\nSee Also\nEditing a document backed by a persistent store\ninit(editing: [PersistentModel.Type], contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store several model types.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(editing: PersistentModel.Type, contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View."
    },
    {
        "title": "init(configuration:)",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument/init(configuration:)",
        "html": "Required\n\nParameters\nconfiguration\n\nInformation about the file that you read document data from.\n\nDiscussion\n\nSwiftUI calls this initializer when someone opens a file type that matches one of those that your document type supports. Use the file property of the configuration input to get document\u2019s data. Deserialize the data, and store it in your document\u2019s data structure:\n\ninit(configuration: ReadConfiguration) throws {\n    guard let data = configuration.file.regularFileContents\n    else { /* Throw an error. */ }\n    model = try JSONDecoder().decode(Model.self, from: data)\n}\n\n\nThe above example assumes that you define Model to contain the document\u2019s data, that Model conforms to the Codable protocol, and that you store a model property of that type inside your document.\n\nNote\n\nSwiftUI calls this method on a background thread. Don\u2019t make user interface changes from that thread.\n\nSee Also\nReading a document\nstatic var readableContentTypes: [UTType]\nThe file and data types that the document reads from.\n\nRequired\n\ntypealias ReadConfiguration\nThe configuration for reading document contents."
    },
    {
        "title": "init(viewing:viewer:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(viewing:viewer:)-1rgjv",
        "html": "Parameters\ndocumentType\n\nThe type of document being viewed.\n\nviewer\n\nThe viewing UI for the provided document.\n\nDiscussion\n\nThe current document for a given editor instance is also provided as an environment object for its subhierarchy.\n\nSee Also: CFBundleTypeRole with a value of \u201cViewer\u201d\n\nSee Also\nCreating a reference file document group\ninit(newDocument: () -> Document, editor: (ReferenceFileDocumentConfiguration<Document>) -> Content)\nCreates a document group that is able to create and edit reference file documents.\nAvailable when Document conforms to ReferenceFileDocument and Content conforms to View."
    },
    {
        "title": "init(newDocument:editor:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(newdocument:editor:)-1mltk",
        "html": "Parameters\nnewDocument\n\nThe initial document used when the user creates a new document. The argument should create a new instance, such that a new document is created on each invocation of the closure.\n\neditor\n\nThe editing UI for the provided document.\n\nDiscussion\n\nThe current document for a given editor instance is also provided as an environment object for its subhierarchy.\n\nUndo support is not automatically provided for this construction of a DocumentGroup, and any updates to the document by the editor view hierarchy are expected to register undo operations when appropriate.\n\nSee Also\nCreating a reference file document group\ninit(viewing: Document.Type, viewer: (ReferenceFileDocumentConfiguration<Document>) -> Content)\nCreates a document group that is able to view reference file documents.\nAvailable when Document conforms to ReferenceFileDocument and Content conforms to View."
    },
    {
        "title": "init(viewing:viewer:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(viewing:viewer:)-6dq9n",
        "html": "Parameters\ndocumentType\n\nThe type of document your app can view.\n\nviewer\n\nThe viewing UI for the provided document.\n\nDiscussion\n\nUse this method to create a document group that can view files of a specific type. The example below creates a new document viewer for MyImageFormatDocument and displays them with MyImageFormatViewer:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(viewing: MyImageFormatDocument.self) { file in\n            MyImageFormatViewer(image: file.document)\n        }\n    }\n}\n\n\nYou tell the system about the app\u2019s role with respect to the document type by setting the CFBundleTypeRole Info.plist key with a value of Viewer.\n\nSee Also\nCreating a document group\ninit(newDocument: () -> Document, editor: (FileDocumentConfiguration<Document>) -> Content)\nCreates a document group for creating and editing file documents.\nAvailable when Document conforms to FileDocument and Content conforms to View."
    },
    {
        "title": "automatic",
        "url": "https://developer.apple.com/documentation/swiftui/windowresizability/automatic",
        "html": "Discussion\n\nWhen you use automatic resizability, SwiftUI applies a resizing strategy that\u2019s appropriate for the scene type:\n\nWindows from WindowGroup, Window, and DocumentGroup scene declarations use the contentMinSize strategy.\n\nA window from a Settings scene declaration uses the contentSize strategy.\n\nAutomatic resizability is the default if you don\u2019t specify another value using the windowResizability(_:) scene modifier.\n\nSee Also\nGetting the resizability\nstatic var contentMinSize: WindowResizability\nA window resizability that\u2019s partially derived from the window\u2019s content.\nstatic var contentSize: WindowResizability\nA window resizability that\u2019s derived from the window\u2019s content."
    },
    {
        "title": "FileDocument.ReadConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/filedocument/readconfiguration",
        "html": "Discussion\n\nThis type is an alias for FileDocumentReadConfiguration, which contains a content type and a file wrapper that you use to access the contents of a document file. You get a value of this type as an input to the init(configuration:) initializer. Use it to load a document from a file.\n\nSee Also\nReading a document\ninit(configuration: Self.ReadConfiguration) throws\nCreates a document and initializes it with the contents of a file.\n\nRequired\n\nstatic var readableContentTypes: [UTType]\nThe file and data types that the document reads from.\n\nRequired"
    },
    {
        "title": "document",
        "url": "https://developer.apple.com/documentation/swiftui/filedocumentconfiguration/document",
        "html": "Discussion\n\nSetting a new value marks the document as having changes for later saving and registers an undo action to restore the model to its previous value.\n\nIf isEditable is false, setting a new value has no effect because the document is in viewing mode.\n\nSee Also\nGetting and setting the document\nvar $document: Binding<Document>"
    },
    {
        "title": "ListSectionSpacing",
        "url": "https://developer.apple.com/documentation/swiftui/listsectionspacing",
        "html": "Topics\nGetting section spacing\nstatic let `default`: ListSectionSpacing\nThe default spacing between sections\nstatic let compact: ListSectionSpacing\nCompact spacing between sections\nstatic func custom(CGFloat) -> ListSectionSpacing\nCreates a custom spacing value.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring spacing\nfunc listRowSpacing(CGFloat?) -> some View\nSets the vertical spacing between two adjacent rows in a List.\nfunc listSectionSpacing(CGFloat) -> some View\nSets the spacing to a custom value between adjacent sections in a List.\nfunc listSectionSpacing(ListSectionSpacing) -> some View\nSets the spacing between adjacent sections in a List."
    },
    {
        "title": "UnifiedWindowToolbarStyle",
        "url": "https://developer.apple.com/documentation/swiftui/unifiedwindowtoolbarstyle",
        "html": "Overview\n\nYou can also use unified or unified(showsTitle:) to construct this style.\n\nTopics\nCreating the window toolbar style\ninit()\nCreates a unified window toolbar style.\ninit(showsTitle: Bool)\nCreates a unified window toolbar style.\nRelationships\nConforms To\nWindowToolbarStyle\nSee Also\nSupporting types\nstruct DefaultWindowToolbarStyle\nThe default window toolbar style.\nstruct ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nstruct UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing."
    },
    {
        "title": "scrollTargetBehavior(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrolltargetbehavior(_:)",
        "html": "Discussion\n\nA scrollable view calculates where scroll gestures should end using its deceleration rate and the state of its scroll gesture by default. A scroll behavior allows for customizing this logic. You can provide your own ScrollTargetBehavior or use one of the built in behaviors provided by SwiftUI.\n\nPaging Behavior\n\nSwiftUI offers a PagingScrollTargetBehavior behavior which uses the geometry of the scroll view to decide where to allow scrolls to end.\n\nIn the following example, every view in the lazy stack is flexible in both directions and the scroll view will settle to container aligned boundaries.\n\nScrollView {\n    LazyVStack(spacing: 0.0) {\n        ForEach(items) { item in\n            FullScreenItem(item)\n        }\n    }\n}\n.scrollTargetBehavior(.paging)\n\nView Aligned Behavior\n\nSwiftUI offers a ViewAlignedScrollTargetBehavior scroll behavior that will always settle on the geometry of individual views.\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 10.0) {\n        ForEach(items) { item in\n            ItemView(item)\n        }\n    }\n    .scrollTargetLayout()\n}\n.scrollTargetBehavior(.viewAligned)\n.safeAreaPadding(.horizontal, 20.0)\n\n\nYou configure which views should be used for settling using the scrollTargetLayout(isEnabled:) modifier. Apply this modifier to a layout container like LazyVStack or HStack and each individual view in that layout will be considered for alignment.\n\nSee Also\nDefining scroll targets\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nstruct ScrollTarget\nA type defining the target in which a scroll view should try and scroll to.\nprotocol ScrollTargetBehavior\nA type that defines the scroll behavior of a scrollable view.\nstruct ScrollTargetBehaviorContext\nThe context in which a scroll target behavior updates its scroll target.\nstruct PagingScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to container-based geometry.\nstruct ViewAlignedScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to view-based geometry."
    },
    {
        "title": "defaultScrollAnchor(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/defaultscrollanchor(_:)",
        "html": "Discussion\n\nUse this modifier to specify an anchor to control both which part of the scroll view\u2019s content should be visible initially and how the scroll view handles content size changes.\n\nProvide a value of `UnitPoint/center`` to have the scroll view start in the center of its content when a scroll view is scrollable in both axes.\n\nScrollView([.horizontal, .vertical]) {\n    // initially centered content\n}\n.defaultScrollAnchor(.center)\n\n\nProvide a value of UnitPoint/bottom to have the scroll view start at the bottom of its content when scrollable in the vertical axis.\n\n@Binding var items: [Item]\n@Binding var scrolledID: Item.ID?\n\n\nScrollView {\n    LazyVStack {\n        ForEach(items) { item in\n            ItemView(item)\n        }\n    }\n}\n.defaultScrollAnchor(.bottom)\n\n\nThe user may scroll away from the initial defined scroll position. When the content size of the scroll view changes, it may consult the anchor to know how to reposition the content.\n\nSee Also\nManaging scroll position\nfunc scrollPosition(id: Binding<(some Hashable)?>, anchor: UnitPoint?) -> some View\nAssociates a binding to be updated when a scroll view within this view scrolls."
    },
    {
        "title": "scrollContentBackground(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrollcontentbackground(_:)",
        "html": "Parameters\nvisibility\n\nthe visibility to use for the background.\n\nDiscussion\n\nThe following example hides the standard system background of the List.\n\nList {\n    Text(\"One\")\n    Text(\"Two\")\n    Text(\"Three\")\n}\n.scrollContentBackground(.hidden)\n\nSee Also\nManaging content visibility\nfunc scrollClipDisabled(Bool) -> some View\nSets whether a scroll view clips its content to its bounds."
    },
    {
        "title": "isScrollEnabled",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/isscrollenabled",
        "html": "Discussion\n\nThe default value is true. Use the scrollDisabled(_:) modifier to configure this property.\n\nSee Also\nDisabling scrolling\nfunc scrollDisabled(Bool) -> some View\nDisables or enables scrolling in scrollable views."
    },
    {
        "title": "scrollClipDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrollclipdisabled(_:)",
        "html": "Parameters\ndisabled\n\nA Boolean value that specifies whether to disable scroll view clipping.\n\nReturn Value\n\nA view that disables or enables scroll view clipping.\n\nDiscussion\n\nBy default, a scroll view clips its content to its bounds, but you can disable that behavior by using this modifier. For example, if the views inside the scroll view have shadows that extend beyond the bounds of the scroll view, you can use this modifier to avoid clipping the shadows:\n\nstruct ContentView: View {\n    var disabled: Bool\n    let colors: [Color] = [.red, .green, .blue, .mint, .teal]\n\n\n    var body: some View {\n        ScrollView(.horizontal) {\n            HStack(spacing: 20) {\n                ForEach(colors, id: \\.self) { color in\n                    Rectangle()\n                        .frame(width: 100, height: 100)\n                        .foregroundStyle(color)\n                        .shadow(color: .primary, radius: 20)\n                }\n            }\n        }\n        .scrollClipDisabled(disabled)\n    }\n}\n\n\nThe scroll view in the above example clips when the content view\u2019s disabled input is false, as it does if you omit the modifier, but not when the input is true:\n\nTrue\nFalse\n\nWhile you might want to avoid clipping parts of views that exceed the bounds of the scroll view, like the shadows in the above example, you typically still want the scroll view to clip at some point. Create custom clipping by using the clipShape(_:style:) modifier to add a different clip shape. The following code disables the default clipping and then adds rectangular clipping that exceeds the bounds of the scroll view by the default padding amount:\n\nScrollView(.horizontal) {\n    // ...\n}\n.scrollClipDisabled()\n.padding()\n.clipShape(Rectangle())\n\nSee Also\nManaging content visibility\nfunc scrollContentBackground(Visibility) -> some View\nSpecifies the visibility of the background for scrollable views within this view."
    },
    {
        "title": "scrollBounceBehavior(_:axes:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrollbouncebehavior(_:axes:)",
        "html": "Parameters\nbehavior\n\nThe bounce behavior to apply to any scrollable views within the configured view. Use one of the ScrollBounceBehavior values.\n\naxes\n\nThe set of axes to apply behavior to. The default is Axis.vertical.\n\nReturn Value\n\nA view that\u2019s configured with the specified scroll bounce behavior.\n\nDiscussion\n\nUse this modifier to indicate whether scrollable views bounce when people scroll to the end of the view\u2019s content, taking into account the relative sizes of the view and its content. For example, the following ScrollView only enables bounce behavior if its content is large enough to require scrolling:\n\nScrollView {\n    Text(\"Small\")\n    Text(\"Content\")\n}\n.scrollBounceBehavior(.basedOnSize)\n\n\nThe modifier passes the scroll bounce mode through the Environment, which means that the mode affects any scrollable views in the modified view hierarchy. Provide an axis to the modifier to constrain the kinds of scrollable views that the mode affects. For example, all the scroll views in the following example can access the mode value, but only the two nested scroll views are affected, because only they use horizontal scrolling:\n\nScrollView { // Defaults to vertical scrolling.\n    ScrollView(.horizontal) {\n        ShelfContent()\n    }\n    ScrollView(.horizontal) {\n        ShelfContent()\n    }\n}\n.scrollBounceBehavior(.basedOnSize, axes: .horizontal)\n\n\nYou can use this modifier to configure any kind of scrollable view, including ScrollView, List, Table, and TextEditor:\n\nList {\n    Text(\"Hello\")\n    Text(\"World\")\n}\n.scrollBounceBehavior(.basedOnSize)\n\nSee Also\nConfiguring scroll bounce behavior\nvar horizontalScrollBounceBehavior: ScrollBounceBehavior\nThe scroll bounce mode for the horizontal axis of scrollable views.\nvar verticalScrollBounceBehavior: ScrollBounceBehavior\nThe scroll bounce mode for the vertical axis of scrollable views.\nstruct ScrollBounceBehavior\nThe ways that a scrollable view can bounce when it reaches the end of its content."
    },
    {
        "title": "modelContext",
        "url": "https://developer.apple.com/documentation/SwiftUI/EnvironmentValues/modelContext",
        "html": "See Also\nGlobal objects\nvar calendar: Calendar\nThe current calendar that views should use when handling dates.\nvar documentConfiguration: DocumentConfiguration?\nThe configuration of a document in a DocumentGroup.\nvar locale: Locale\nThe current locale that views should use.\nvar managedObjectContext: NSManagedObjectContext\nvar timeZone: TimeZone\nThe current time zone that views should use when handling dates.\nvar undoManager: UndoManager?\nThe undo manager used to register a view\u2019s undo operations."
    },
    {
        "title": "unifiedCompact(showsTitle:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowtoolbarstyle/unifiedcompact(showstitle:)",
        "html": "Parameters\nshowsTitle\n\nWhether the title should be displayed.\n\nSee Also\nGetting built-in window toolbar styles\nstatic var automatic: DefaultWindowToolbarStyle\nThe automatic window toolbar style.\nAvailable when Self is DefaultWindowToolbarStyle.\nstatic var expanded: ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nAvailable when Self is ExpandedWindowToolbarStyle.\nstatic var unified: UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic func unified(showsTitle: Bool) -> UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic var unifiedCompact: UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle."
    },
    {
        "title": "modelContainer(_:)",
        "url": "https://developer.apple.com/documentation/SwiftUI/View/modelContainer(_:)",
        "html": "Parameters\ncontainer\n\nThe model container to use for this view.\n\nDiscussion\n\nIn this example, ContentView sets a model container to use for RecipesList:\n\nstruct ContentView: View {\n    @State private var container = ModelContainer(...)\n\n\n    var body: some Scene {\n        RecipesList()\n            .modelContainer(container)\n    }\n}\n\n\nThe environment\u2019s modelContext property will be assigned a new context associated with this container. All implicit model context operations in this view, such as Query properties, will use the environment\u2019s context.\n\nSee Also\nConfiguring a model\nfunc modelContext(ModelContext) -> some View\nSets the model context in this view\u2019s environment.\nfunc modelContainer(for: PersistentModel.Type, inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some View\nSets the model container in this view for storing the provided model type, creating a new container if necessary, and also sets a model context for that container in this view\u2019s environment.\nfunc modelContainer(for: [PersistentModel.Type], inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some View\nSets the model container in this view for storing the provided model types, creating a new container if necessary, and also sets a model context for that container in this view\u2019s environment."
    },
    {
        "title": "ScrollTarget",
        "url": "https://developer.apple.com/documentation/swiftui/scrolltarget",
        "html": "Topics\nGetting the scroll target\nvar anchor: UnitPoint?\nThe anchor to which the rect should be aligned within the visible region of the scrollable view.\nvar rect: CGRect\nThe rect that a scrollable view should try and have contained.\nSee Also\nDefining scroll targets\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> some View\nSets the scroll behavior of views scrollable in the provided axes.\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nprotocol ScrollTargetBehavior\nA type that defines the scroll behavior of a scrollable view.\nstruct ScrollTargetBehaviorContext\nThe context in which a scroll target behavior updates its scroll target.\nstruct PagingScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to container-based geometry.\nstruct ViewAlignedScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to view-based geometry."
    },
    {
        "title": "ScrollTargetBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/scrolltargetbehavior",
        "html": "Overview\n\nA scrollable view calculates where scroll gestures should end using its deceleration rate and the state of its scroll gesture by default. A scroll behavior allows for customizing this logic.\n\nYou define a scroll behavior using the updateTarget(_:context:) method.\n\nUsing this method, you can control where someone can scroll in a scrollable view. For example, you can create a custom scroll behavior that aligns to every 10 points by doing the following:\n\nstruct BasicScrollTargetBehavior: ScrollTargetBehavior {\n    func updateTarget(_ target: inout Target, context: TargetContext) {\n        // Align to every 1/10 the size of the scroll view.\n        target.rect.x.round(\n            toMultipleOf: round(context.containerSize.width / 10.0))\n    }\n}\n\nPaging Behavior\n\nSwiftUI offers built in scroll behaviors. One such behavior is the PagingScrollTargetBehavior which uses the geometry of the scroll view to decide where to allow scrolls to end.\n\nIn the following example, every view in the lazy stack is flexible in both directions and the scroll view will settle to container aligned boundaries.\n\nScrollView {\n    LazyVStack(spacing: 0.0) {\n        ForEach(items) { item in\n            FullScreenItem(item)\n        }\n    }\n}\n.scrollTargetBehavior(.paging)\n\nView Aligned Behavior\n\nSwiftUI also offers a ViewAlignedScrollTargetBehavior scroll behavior that will always settle on the geometry of individual views.\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 10.0) {\n        ForEach(items) { item in\n            ItemView(item)\n        }\n    }\n    .scrollTargetLayout()\n}\n.scrollTargetBehavior(.viewAligned)\n.safeAreaPadding(.horizontal, 20.0)\n\n\nYou configure which views should be used for settling using the scrollTargetLayout(isEnabled:) modifier. Apply this modifier to a layout container like LazyVStack or HStack and each individual view in that layout will be considered for alignment.\n\nUse types conforming to this protocol with the scrollTargetBehavior(_:) modifier.\n\nTopics\nGetting the scroll target behavior\nstatic var paging: PagingScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to container-based geometry.\nAvailable when Self is PagingScrollTargetBehavior.\nstatic var viewAligned: ViewAlignedScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to view-based geometry.\nAvailable when Self is ViewAlignedScrollTargetBehavior.\nstatic func viewAligned(limitBehavior: ViewAlignedScrollTargetBehavior.LimitBehavior) -> Self\nThe scroll behavior that aligns scroll targets to view-based geometry.\nAvailable when Self is ViewAlignedScrollTargetBehavior.\nUpdating the proposed target\nfunc updateTarget(inout ScrollTarget, context: Self.TargetContext)\nUpdates the proposed target that a scrollable view should scroll to.\n\nRequired\n\ntypealias TargetContext\nThe context in which a scroll behavior updates the scroll target.\nRelationships\nConforming Types\nPagingScrollTargetBehavior\nViewAlignedScrollTargetBehavior\nSee Also\nDefining scroll targets\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> some View\nSets the scroll behavior of views scrollable in the provided axes.\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nstruct ScrollTarget\nA type defining the target in which a scroll view should try and scroll to.\nstruct ScrollTargetBehaviorContext\nThe context in which a scroll target behavior updates its scroll target.\nstruct PagingScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to container-based geometry.\nstruct ViewAlignedScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to view-based geometry."
    },
    {
        "title": "ViewAlignedScrollTargetBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/viewalignedscrolltargetbehavior",
        "html": "Overview\n\nYou use this behavior when a scroll view should always align its scroll targets to a rectangle that\u2019s aligned to the geometry of a view. In the following example, the scroll view always picks an item view to settle on.\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 10.0) {\n        ForEach(items) { item in\n          ItemView(item)\n        }\n    }\n    .scrollTargetLayout()\n}\n.scrollTargetBehavior(.viewAligned)\n.padding(.horizontal, 20.0)\n\n\nYou configure which views should be used for settling using the scrollTargetLayout(isEnabled:) modifier. Apply this modifier to a layout container like LazyVStack or HStack and each individual view in that layout will be considered for alignment.\n\nYou can customize whether the view aligned behavior limits the number of views that can be scrolled at a time by using the ViewAlignedScrollTargetBehavior.LimitBehavior type. Provide a value of always to always have the behavior only allow a few views to be scrolled at a time.\n\nBy default, the view aligned behavior will limit the number of views it scrolls when in a compact horizontal size class when scrollable in the horizontal axis, when in a compact vertical size class when scrollable in the vertical axis, and otherwise does not impose any limit on the number of views that can be scrolled.\n\nTopics\nCreating the target behavior\ninit(limitBehavior: ViewAlignedScrollTargetBehavior.LimitBehavior)\nCreates a view aligned scroll behavior.\nstruct LimitBehavior\nA type that defines the amount of views that can be scrolled at a time.\nRelationships\nConforms To\nScrollTargetBehavior\nSee Also\nDefining scroll targets\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> some View\nSets the scroll behavior of views scrollable in the provided axes.\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nstruct ScrollTarget\nA type defining the target in which a scroll view should try and scroll to.\nprotocol ScrollTargetBehavior\nA type that defines the scroll behavior of a scrollable view.\nstruct ScrollTargetBehaviorContext\nThe context in which a scroll target behavior updates its scroll target.\nstruct PagingScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to container-based geometry."
    },
    {
        "title": "unifiedCompact",
        "url": "https://developer.apple.com/documentation/swiftui/windowtoolbarstyle/unifiedcompact",
        "html": "See Also\nGetting built-in window toolbar styles\nstatic var automatic: DefaultWindowToolbarStyle\nThe automatic window toolbar style.\nAvailable when Self is DefaultWindowToolbarStyle.\nstatic var expanded: ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nAvailable when Self is ExpandedWindowToolbarStyle.\nstatic var unified: UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nstatic func unified(showsTitle: Bool) -> UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic func unifiedCompact(showsTitle: Bool) -> UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle."
    },
    {
        "title": "callAsFunction()",
        "url": "https://developer.apple.com/documentation/swiftui/dismissaction/callasfunction()",
        "html": "Discussion\n\nDon\u2019t call this method directly. SwiftUI calls it for you when you call the DismissAction structure that you get from the Environment:\n\nprivate struct SheetContents: View {\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Button(\"Done\") {\n            dismiss() // Implicitly calls dismiss.callAsFunction()\n        }\n    }\n}\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language."
    },
    {
        "title": "ScrollTargetBehaviorContext",
        "url": "https://developer.apple.com/documentation/swiftui/scrolltargetbehaviorcontext",
        "html": "Topics\nGetting the scroll target behavior context\nvar axes: Axis.Set\nThe axes in which the scrollable view is scrollable.\nvar containerSize: CGSize\nThe size of the container of the scrollable view.\nvar contentSize: CGSize\nThe size of the content of the scrollable view.\nvar originalTarget: ScrollTarget\nThe original target when the scroll gesture began.\nvar velocity: CGVector\nThe current velocity of the scrollable view\u2019s scroll gesture.\nAccessing the context\nsubscript<T>(dynamicMember _: KeyPath<EnvironmentValues, T>) -> T\nSee Also\nDefining scroll targets\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> some View\nSets the scroll behavior of views scrollable in the provided axes.\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nstruct ScrollTarget\nA type defining the target in which a scroll view should try and scroll to.\nprotocol ScrollTargetBehavior\nA type that defines the scroll behavior of a scrollable view.\nstruct PagingScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to container-based geometry.\nstruct ViewAlignedScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to view-based geometry."
    },
    {
        "title": "DefaultWindowToolbarStyle",
        "url": "https://developer.apple.com/documentation/swiftui/defaultwindowtoolbarstyle",
        "html": "Overview\n\nYou can also use automatic to construct this style.\n\nTopics\nCreating the window toolbar style\ninit()\nCreates a default window toolbar style.\nRelationships\nConforms To\nWindowToolbarStyle\nSee Also\nSupporting types\nstruct ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nstruct UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nstruct UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing."
    },
    {
        "title": "scrollTransition(topLeading:bottomTrailing:axis:transition:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrolltransition(topleading:bottomtrailing:axis:transition:)",
        "html": "Parameters\ntransition\n\nthe transition to apply.\n\ntopLeading\n\nThe configuration that drives the transition when the view is about to appear at the top edge of a vertical scroll view, or the leading edge of a horizont scroll view.\n\nbottomTrailing\n\nThe configuration that drives the transition when the view is about to appear at the bottom edge of a vertical scroll view, or the trailing edge of a horizont scroll view.\n\naxis\n\nThe axis of the containing scroll view over which the transition will be applied. The default value of nil uses the axis of the innermost containing scroll view, or .vertical if the innermost scroll view is scrollable along both axes.\n\ntransition\n\nA closure that applies visual effects as a function of the provided phase.\n\nSee Also\nAnimating scroll transitions\nfunc scrollTransition(ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nenum ScrollTransitionPhase\nThe phases that a view transitions between when it scrolls among other views.\nstruct ScrollTransitionConfiguration\nThe configuration of a scroll transition that controls how a transition is applied as a view is scrolled through the visible region of a containing scroll view or other container."
    },
    {
        "title": "scrollTransition(_:axis:transition:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrolltransition(_:axis:transition:)",
        "html": "Parameters\nconfiguration\n\nThe configuration controlling how the transition will be applied. The configuration will be applied both while the view is coming into view and while it is disappearing (the transition is symmetrical).\n\naxis\n\nThe axis of the containing scroll view over which the transition will be applied. The default value of nil uses the axis of the innermost containing scroll view, or .vertical if the innermost scroll view is scrollable along both axes.\n\ncoordinateSpace\n\nThe coordinate space of the container that visibility is evaluated within. Defaults to .scrollView.\n\ntransition\n\nA closure that applies visual effects as a function of the provided phase.\n\nSee Also\nAnimating scroll transitions\nfunc scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nenum ScrollTransitionPhase\nThe phases that a view transitions between when it scrolls among other views.\nstruct ScrollTransitionConfiguration\nThe configuration of a scroll transition that controls how a transition is applied as a view is scrolled through the visible region of a containing scroll view or other container."
    },
    {
        "title": "PagingScrollTargetBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/pagingscrolltargetbehavior",
        "html": "Overview\n\nIn the following example, every view in the lazy stack is flexible in both directions and the scroll view settles to container-aligned boundaries.\n\nScrollView {\n    LazyVStack(spacing: 0.0) {\n        ForEach(items) { item in\n            FullScreenItem(item)\n        }\n    }\n}\n.scrollTargetBehavior(.paging)\n\nTopics\nCreating the target behavior\ninit()\nCreates a paging scroll behavior.\nRelationships\nConforms To\nChartScrollTargetBehavior\nScrollTargetBehavior\nSee Also\nDefining scroll targets\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> some View\nSets the scroll behavior of views scrollable in the provided axes.\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nstruct ScrollTarget\nA type defining the target in which a scroll view should try and scroll to.\nprotocol ScrollTargetBehavior\nA type that defines the scroll behavior of a scrollable view.\nstruct ScrollTargetBehaviorContext\nThe context in which a scroll target behavior updates its scroll target.\nstruct ViewAlignedScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to view-based geometry."
    },
    {
        "title": "ScrollTransitionPhase",
        "url": "https://developer.apple.com/documentation/swiftui/scrolltransitionphase",
        "html": "Overview\n\nWhen a view with a scroll transition modifier applied is approaching the visible region of the containing scroll view or other container, the effect will first be applied with the topLeading or bottomTrailing phase (depending on which edge the view is approaching), then will be moved to the identity phase as the view moves into the visible area. The timing and behavior that determines when a view is visible within the container is controlled by the configuration that is provided to the scrollTransition modifier.\n\nIn the identity phase, scroll transitions should generally not make any visual change to the view they are applied to, since the transition\u2019s view modifications in the identity phase will be applied to the view as long as it is visible. In the topLeading and bottomTrailing phases, transitions should apply a change that will be animated to create the transition.\n\nTopics\nGetting the phase\ncase identity\nThe scroll transition is being applied to a view that is in the visible area.\ncase topLeading\nThe scroll transition is being applied to a view that is about to move into the visible area at the top edge of a vertical scroll view, or the leading edge of a horizont scroll view.\ncase bottomTrailing\nThe scroll transition is being applied to a view that is about to move into the visible area at the bottom edge of a vertical scroll view, or the trailing edge of a horizontal scroll view.\nAccessing the phase state\nvar isIdentity: Bool\nvar value: Double\nA phase-derived value that can be used to scale or otherwise modify effects.\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nAnimating scroll transitions\nfunc scrollTransition(ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nfunc scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nstruct ScrollTransitionConfiguration\nThe configuration of a scroll transition that controls how a transition is applied as a view is scrolled through the visible region of a containing scroll view or other container."
    },
    {
        "title": "scrollIndicators(_:axes:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrollindicators(_:axes:)",
        "html": "Parameters\nvisibility\n\nThe visibility to apply to scrollable views.\n\naxes\n\nThe axes of scrollable views that the visibility applies to.\n\nReturn Value\n\nA view with the specified scroll indicator visibility.\n\nDiscussion\n\nUse this modifier to hide or show scroll indicators on scrollable content in views like a ScrollView, List, or TextEditor. This modifier applies the prefered visibility to any scrollable content within a view hierarchy.\n\nScrollView {\n    VStack(alignment: .leading) {\n        ForEach(0..<100) {\n            Text(\"Row \\($0)\")\n        }\n    }\n}\n.scrollIndicators(.hidden)\n\n\nUse the hidden value to indicate that you prefer that views never show scroll indicators along a given axis. Use visible when you prefer that views show scroll indicators. Depending on platform conventions, visible scroll indicators might only appear while scrolling. Pass automatic to allow views to decide whether or not to show their indicators.\n\nSee Also\nShowing scroll indicators\nfunc scrollIndicatorsFlash(onAppear: Bool) -> some View\nFlashes the scroll indicators of a scrollable view when it appears.\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> some View\nFlashes the scroll indicators of scrollable views when a value changes.\nvar horizontalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visibility to apply to scroll indicators of any horizontally scrollable content.\nvar verticalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visiblity to apply to scroll indicators of any vertically scrollable content.\nstruct ScrollIndicatorVisibility\nThe visibility of scroll indicators of a UI element."
    },
    {
        "title": "snapshot(contentType:)",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument/snapshot(contenttype:)",
        "html": "Required\n\nParameters\ncontentType\n\nThe content type that you create the document snapshot for.\n\nReturn Value\n\nA snapshot of the document content that the system provides to the fileWrapper(snapshot:configuration:) method for serialization.\n\nDiscussion\n\nTo store a document \u2014 for example, in response to a Save command \u2014 SwiftUI begins by calling this method. Return a copy of the document\u2019s content from your implementation of the method. For example, you might define an initializer for your document\u2019s model object that copies the contents of the document\u2019s instance, and return that:\n\nfunc snapshot(contentType: UTType) throws -> Snapshot {\n    Model(from: model) // Creates a copy.\n}\n\n\nSwiftUI prevents document edits during the snapshot operation to ensure that the model state remains coherent. After the call completes, SwiftUI reenables edits, and then calls the fileWrapper(snapshot:configuration:) method, where you serialize the snapshot and store it to a file.\n\nNote\n\nSwiftUI calls this method on a background thread. Don\u2019t make user interface changes from that thread.\n\nSee Also\nGetting a snapshot\nassociatedtype Snapshot\nA type that represents the document\u2019s stored content.\n\nRequired"
    },
    {
        "title": "scrollIndicatorsFlash(onAppear:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrollindicatorsflash(onappear:)",
        "html": "Parameters\nonAppear\n\nA Boolean value that indicates whether the scroll indicators flash when the scroll view appears.\n\nReturn Value\n\nA view that flashes any visible scroll indicators when it first appears.\n\nDiscussion\n\nUse this modifier to control whether the scroll indicators of a scroll view briefly flash when the view first appears. For example, you can make the indicators flash by setting the onAppear parameter to true:\n\nScrollView {\n    // ...\n}\n.scrollIndicatorsFlash(onAppear: true)\n\n\nOnly scroll indicators that you configure to be visible flash. To flash scroll indicators when a value changes, use scrollIndicatorsFlash(trigger:) instead.\n\nSee Also\nShowing scroll indicators\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> some View\nFlashes the scroll indicators of scrollable views when a value changes.\nfunc scrollIndicators(ScrollIndicatorVisibility, axes: Axis.Set) -> some View\nSets the visibility of scroll indicators within this view.\nvar horizontalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visibility to apply to scroll indicators of any horizontally scrollable content.\nvar verticalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visiblity to apply to scroll indicators of any vertically scrollable content.\nstruct ScrollIndicatorVisibility\nThe visibility of scroll indicators of a UI element."
    },
    {
        "title": "ScrollIndicatorVisibility",
        "url": "https://developer.apple.com/documentation/swiftui/scrollindicatorvisibility",
        "html": "Overview\n\nPass a value of this type to the scrollIndicators(_:axes:) method to specify the preferred scroll indicator visibility of a view hierarchy.\n\nTopics\nGetting visibilties\nstatic var automatic: ScrollIndicatorVisibility\nScroll indicator visibility depends on the policies of the component accepting the visibility configuration.\nstatic var hidden: ScrollIndicatorVisibility\nHide the scroll indicators.\nstatic var never: ScrollIndicatorVisibility\nScroll indicators should never be visible.\nstatic var visible: ScrollIndicatorVisibility\nShow the scroll indicators.\nRelationships\nConforms To\nEquatable\nSee Also\nShowing scroll indicators\nfunc scrollIndicatorsFlash(onAppear: Bool) -> some View\nFlashes the scroll indicators of a scrollable view when it appears.\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> some View\nFlashes the scroll indicators of scrollable views when a value changes.\nfunc scrollIndicators(ScrollIndicatorVisibility, axes: Axis.Set) -> some View\nSets the visibility of scroll indicators within this view.\nvar horizontalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visibility to apply to scroll indicators of any horizontally scrollable content.\nvar verticalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visiblity to apply to scroll indicators of any vertically scrollable content."
    },
    {
        "title": "verticalScrollIndicatorVisibility",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/verticalscrollindicatorvisibility",
        "html": "See Also\nShowing scroll indicators\nfunc scrollIndicatorsFlash(onAppear: Bool) -> some View\nFlashes the scroll indicators of a scrollable view when it appears.\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> some View\nFlashes the scroll indicators of scrollable views when a value changes.\nfunc scrollIndicators(ScrollIndicatorVisibility, axes: Axis.Set) -> some View\nSets the visibility of scroll indicators within this view.\nvar horizontalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visibility to apply to scroll indicators of any horizontally scrollable content.\nstruct ScrollIndicatorVisibility\nThe visibility of scroll indicators of a UI element."
    },
    {
        "title": "horizontalScrollIndicatorVisibility",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/horizontalscrollindicatorvisibility",
        "html": "See Also\nShowing scroll indicators\nfunc scrollIndicatorsFlash(onAppear: Bool) -> some View\nFlashes the scroll indicators of a scrollable view when it appears.\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> some View\nFlashes the scroll indicators of scrollable views when a value changes.\nfunc scrollIndicators(ScrollIndicatorVisibility, axes: Axis.Set) -> some View\nSets the visibility of scroll indicators within this view.\nvar verticalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visiblity to apply to scroll indicators of any vertically scrollable content.\nstruct ScrollIndicatorVisibility\nThe visibility of scroll indicators of a UI element."
    },
    {
        "title": "unified(showsTitle:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowtoolbarstyle/unified(showstitle:)",
        "html": "Parameters\nshowsTitle\n\nWhether the title should be displayed.\n\nSee Also\nGetting built-in window toolbar styles\nstatic var automatic: DefaultWindowToolbarStyle\nThe automatic window toolbar style.\nAvailable when Self is DefaultWindowToolbarStyle.\nstatic var expanded: ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nAvailable when Self is ExpandedWindowToolbarStyle.\nstatic var unified: UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic var unifiedCompact: UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle.\nstatic func unifiedCompact(showsTitle: Bool) -> UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle."
    },
    {
        "title": "init(_:id:for:content:defaultValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:for:content:defaultvalue:)-2ua0r",
        "html": "Parameters\ntitle\n\nThe Text view to use for the group\u2019s title.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\ndefaultValue\n\nA closure that returns a default value to present. SwiftUI calls this closure when it has no data to provide, like when someone opens a new window from the File > New Window menu item.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nImportant\n\nThe system ignores any text styling that you apply to the Text view title, like bold or italics. However, you can use the formatting controls that the view offers, like for localization, dates, and numerical representations.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nIdentifying a window group that has default data\ninit<D, C>(id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with an identifier and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a localized title string, an identifier, and a default value.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a title string, an identifier, and a default value.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:id:for:content:defaultValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:for:content:defaultvalue:)-5geiq",
        "html": "Parameters\ntitle\n\nThe string to use for the title of the group.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\ndefaultValue\n\nA closure that returns a default value to present. SwiftUI calls this closure when it has no data to provide, like when someone opens a new window from the File > New Window menu item.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nIdentifying a window group that has default data\ninit<D, C>(id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with an identifier and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a localized title string, an identifier, and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(Text, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a text view title, an identifier, and a default value.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:id:for:content:defaultValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:for:content:defaultvalue:)-95crv",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the group\u2019s title.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\ndefaultValue\n\nA closure that returns a default value to present. SwiftUI calls this closure when it has no data to provide, like when someone opens a new window from the File > New Window menu item.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nIdentifying a window group that has default data\ninit<D, C>(id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with an identifier and a default value.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a title string, an identifier, and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(Text, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a text view title, an identifier, and a default value.\nAvailable when Content conforms to View."
    },
    {
        "title": "unified",
        "url": "https://developer.apple.com/documentation/swiftui/windowtoolbarstyle/unified",
        "html": "See Also\nGetting built-in window toolbar styles\nstatic var automatic: DefaultWindowToolbarStyle\nThe automatic window toolbar style.\nAvailable when Self is DefaultWindowToolbarStyle.\nstatic var expanded: ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nAvailable when Self is ExpandedWindowToolbarStyle.\nstatic func unified(showsTitle: Bool) -> UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic var unifiedCompact: UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle.\nstatic func unifiedCompact(showsTitle: Bool) -> UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle."
    },
    {
        "title": "expanded",
        "url": "https://developer.apple.com/documentation/swiftui/windowtoolbarstyle/expanded",
        "html": "See Also\nGetting built-in window toolbar styles\nstatic var automatic: DefaultWindowToolbarStyle\nThe automatic window toolbar style.\nAvailable when Self is DefaultWindowToolbarStyle.\nstatic var unified: UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nstatic func unified(showsTitle: Bool) -> UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic var unifiedCompact: UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle.\nstatic func unifiedCompact(showsTitle: Bool) -> UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle."
    },
    {
        "title": "fileWrapper(configuration:)",
        "url": "https://developer.apple.com/documentation/swiftui/filedocument/filewrapper(configuration:)",
        "html": "Required\n\nParameters\nconfiguration\n\nInformation about a file that already exists for the document, if any.\n\nReturn Value\n\nThe destination to serialize the document contents to. The value can be a newly created FileWrapper or an update of the one provided in the configuration input.\n\nDiscussion\n\nTo store a document \u2014 for example, in response to a Save command \u2014 SwiftUI calls this method. Use it to serialize the document\u2019s data and create or modify a file wrapper with the serialized data:\n\nfunc fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {\n    let data = try JSONEncoder().encode(model)\n    return FileWrapper(regularFileWithContents: data)\n}\n\n\nNote\n\nSwiftUI calls this method on a background thread. Don\u2019t make user interface changes from that thread.\n\nSee Also\nWriting a document\nstatic var writableContentTypes: [UTType]\nThe file types that the document supports saving or exporting to.\n\nRequired Default implementation provided.\n\ntypealias WriteConfiguration\nThe configuration for writing document contents."
    },
    {
        "title": "interactive",
        "url": "https://developer.apple.com/documentation/swiftui/dismissbehavior/interactive",
        "html": "Discussion\n\nUse this behavior when you want to dismiss a window in a manner that is similar to the standard system affordances for window dismissal - for example, when a user clicks the close button.\n\nThis is the default behavior on macOS and iOS.\n\nOn macOS, dismissing a window using this behavior will not dismiss a window which is currently showing a modal presentation, such as a sheet or alert. Additionally, a document window that is dismissed with this behavior will show the save dialog if there are unsaved changes to the document.\n\nOn iOS, dismissing a window using this behavior will dismiss it regardless of any modal presentations being shown.\n\nSee Also\nGetting behaviors\nstatic let destructive: DismissBehavior\nThe destructive dismiss behavior."
    },
    {
        "title": "init(configuration:)",
        "url": "https://developer.apple.com/documentation/swiftui/filedocument/init(configuration:)",
        "html": "Required\n\nParameters\nconfiguration\n\nInformation about the file that you read document data from.\n\nDiscussion\n\nSwiftUI calls this initializer when someone opens a file type that matches one of those that your document type supports. Use the file property of the configuration input to get document\u2019s data. Deserialize the data, and store it in your document\u2019s data structure:\n\ninit(configuration: ReadConfiguration) throws {\n    guard let data = configuration.file.regularFileContents\n    else { /* Throw an error. */ }\n    model = try JSONDecoder().decode(Model.self, from: data)\n}\n\n\nThe above example assumes that you define Model to contain the document\u2019s data, that Model conforms to the Codable protocol, and that you store a model property of that type inside your document.\n\nNote\n\nSwiftUI calls this method on a background thread. Don\u2019t make user interface changes from that thread.\n\nSee Also\nReading a document\nstatic var readableContentTypes: [UTType]\nThe file and data types that the document reads from.\n\nRequired\n\ntypealias ReadConfiguration\nThe configuration for reading document contents."
    },
    {
        "title": "destructive",
        "url": "https://developer.apple.com/documentation/swiftui/dismissbehavior/destructive",
        "html": "Discussion\n\nUse this behavior when you want to dismiss a window regardless of any conditions that would normally prevent the dismissal. Dismissing windows in this matter may result in loss of state.\n\nOn macOS, this behavior will cause windows to dismiss even when they are currently showing a modal presentation, such as a sheet or alert. Additionally, a document window will not show the save dialog when there are unsaved changes and the window is dismissed with this behavior.\n\nOn iOS, this behavior behaves the same as interactive.\n\nSee Also\nGetting behaviors\nstatic let interactive: DismissBehavior\nThe interactive dismiss behavior."
    },
    {
        "title": "callAsFunction(value:)",
        "url": "https://developer.apple.com/documentation/swiftui/dismisswindowaction/callasfunction(value:)",
        "html": "Parameters\nvalue\n\nThe value which is currently presented.\n\nDiscussion\n\nIf multiple windows match the provided value, then they all will be dismissed. For dismissing a specific window in a specific group, use dismissWindow(id:value:).\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the dismissWindow action with an identifier and a value:\n\ndismissWindow(value: message.id)\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language.\n\nSee Also\nCalling the action\nfunc callAsFunction()\nDismisses the current window.\nfunc callAsFunction(id: String)\nDismisses the window that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(id: String, value: D)\nDismisses the window defined by the window group that is presenting the specified value type and that\u2019s associated with the specified identifier."
    },
    {
        "title": "callAsFunction(id:value:)",
        "url": "https://developer.apple.com/documentation/swiftui/openwindowaction/callasfunction(id:value:)",
        "html": "Parameters\nid\n\nThe identifier of the scene to present.\n\nvalue\n\nThe value to present.\n\nDiscussion\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the openWindow action with an identifier and a value:\n\nopenWindow(id: \"message\", value: message.id)\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language.\n\nSee Also\nCalling the action\nfunc callAsFunction(id: String)\nOpens a window that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(value: D)\nOpens a window defined by a window group that presents the type of the specified value."
    },
    {
        "title": "callAsFunction()",
        "url": "https://developer.apple.com/documentation/swiftui/dismisswindowaction/callasfunction()",
        "html": "Discussion\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the dismissWindow action:\n\ndismissWindow()\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language.\n\nSee Also\nCalling the action\nfunc callAsFunction(id: String)\nDismisses the window that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(id: String, value: D)\nDismisses the window defined by the window group that is presenting the specified value type and that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(value: D)\nDismisses the window defined by the window group that is presenting the specified value type."
    },
    {
        "title": "callAsFunction(id:)",
        "url": "https://developer.apple.com/documentation/swiftui/openimmersivespaceaction/callasfunction(id:)",
        "html": "Parameters\nid\n\nThe identifier of the immersive space to present.\n\nDiscussion\n\nThe call returns either once the space is presented, or once an error occurred.\n\nIf an immersive space is already presented, calling this action has no effect. Dismiss any currently presented immersive space prior to presenting another one.\n\nIf the immersive space presents data, the system provides the default value or nil to the the space\u2019s root view.\n\nSee Also\nCalling the action\nfunc callAsFunction<D>(id: String, value: D) async -> OpenImmersiveSpaceAction.Result\nPresents the immersive space that your app defines for the specified identifier and that handles the type of the presented value.\nBeta\nfunc callAsFunction<D>(value: D) async -> OpenImmersiveSpaceAction.Result\nPresents the immersive space that handles the type of the presented value.\nBeta"
    },
    {
        "title": "init(_:id:for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:for:content:)-90zw1",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the group\u2019s title.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nIdentifying a data-driven window group\ninit<D, C>(id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with an identifier.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string and an identifier.\nAvailable when Content conforms to View.\ninit<D, C>(Text, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title and an identifier.\nAvailable when Content conforms to View."
    },
    {
        "title": "automatic",
        "url": "https://developer.apple.com/documentation/swiftui/immersionstyle/automatic",
        "html": "See Also\nGetting built-in styles\nstatic var full: FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video, except for the user\u2019s hands, if configured accordingly.\nAvailable when Self is FullImmersionStyle.\nBeta\nstatic var mixed: MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nAvailable when Self is MixedImmersionStyle.\nBeta\nstatic var progressive: ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nAvailable when Self is ProgressiveImmersionStyle.\nBeta"
    },
    {
        "title": "AutomaticImmersionStyle",
        "url": "https://developer.apple.com/documentation/swiftui/automaticimmersionstyle",
        "html": "Overview\n\nBy default, SwiftUI uses the mixed style as the automatic style.\n\nUse automatic to construct this style.\n\nTopics\nCreating the immersion style\ninit()\nRelationships\nConforms To\nImmersionStyle\nSee Also\nSupporting types\nstruct FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video.\nBeta\nstruct MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nBeta\nstruct ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nBeta"
    },
    {
        "title": "TitleBarWindowStyle",
        "url": "https://developer.apple.com/documentation/swiftui/titlebarwindowstyle",
        "html": "Overview\n\nYou can also use titleBar to construct this style.\n\nTopics\nCreating the window style\ninit()\nCreates a title bar window style.\nRelationships\nConforms To\nWindowStyle\nSee Also\nSupporting types\nstruct DefaultWindowStyle\nThe default window style.\nstruct HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nstruct PlainWindowStyle\nThe plain window style.\nBeta\nstruct VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nBeta"
    },
    {
        "title": "callAsFunction(value:)",
        "url": "https://developer.apple.com/documentation/swiftui/openwindowaction/callasfunction(value:)",
        "html": "Parameters\nvalue\n\nThe value to present.\n\nDiscussion\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the openWindow action with a value:\n\nopenWindow(value: message.id)\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language.\n\nSee Also\nCalling the action\nfunc callAsFunction(id: String)\nOpens a window that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(id: String, value: D)\nOpens a window defined by the window group that presents the specified value type and that\u2019s associated with the specified identifier."
    },
    {
        "title": "init(_:for:content:defaultValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:for:content:defaultvalue:)-3xqbx",
        "html": "Parameters\ntitle\n\nThe Text view to use for the group\u2019s title.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\ndefaultValue\n\nA closure that returns a default value to present. SwiftUI calls this closure when it has no data to provide, like when someone opens a new window from the File > New Window menu item.\n\nDiscussion\n\nThe window group uses the given view as a template to form the content of each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nImportant\n\nThe system ignores any text styling that you apply to the Text view title, like bold or italics. However, you can use the formatting controls that the view offers, like for localization, dates, and numerical representations.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nProviding default data to a window group\ninit<D, C>(for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a default value.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a localized title string and a default value.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a title string and a default value.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:id:for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:for:content:)-1bmnd",
        "html": "Parameters\ntitle\n\nThe Text view to use for the group\u2019s title.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nImportant\n\nThe system ignores any text styling that you apply to the Text view title, like bold or italics. However, you can use the formatting controls that the view offers, like for localization, dates, and numerical representations.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nIdentifying a data-driven window group\ninit<D, C>(id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with an identifier.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string and an identifier.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string and an identifier.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:for:content:defaultValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:for:content:defaultvalue:)-2lg54",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the group\u2019s title.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\ndefaultValue\n\nA closure that returns a default value to present. SwiftUI calls this closure when it has no data to provide, like when someone opens a new window from the File > New Window menu item.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nProviding default data to a window group\ninit<D, C>(for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a default value.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a title string and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(Text, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a text view title and a default value.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:id:for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:for:content:)-3hbmw",
        "html": "Parameters\ntitle\n\nThe string to use for the title of the group.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nIdentifying a data-driven window group\ninit<D, C>(id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with an identifier.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string and an identifier.\nAvailable when Content conforms to View.\ninit<D, C>(Text, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title and an identifier.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(id:for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(id:for:content:)",
        "html": "Parameters\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nIdentifying a data-driven window group\ninit<D, C>(LocalizedStringKey, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string and an identifier.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string and an identifier.\nAvailable when Content conforms to View.\ninit<D, C>(Text, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title and an identifier.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:for:content:)-9vyco",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the group\u2019s title.\n\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group.\n\nThe system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nCreating a data-driven window group\ninit<D, C>(for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string.\nAvailable when Content conforms to View.\ninit<D, C>(Text, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(for:content:defaultValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(for:content:defaultvalue:)",
        "html": "Parameters\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\ndefaultValue\n\nA closure that returns a default value to present. SwiftUI calls this closure when it has no data to provide, like when someone opens a new window from the File > New Window menu item.\n\nDiscussion\n\nThe window group using the given view as a template to form the content of each window in the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nProviding default data to a window group\ninit<D, C>(LocalizedStringKey, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a localized title string and a default value.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a title string and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(Text, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a text view title and a default value.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(for:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(for:content:)",
        "html": "Parameters\ntype\n\nThe type of presented data this window group accepts.\n\ncontent\n\nA closure that creates the content for each instance of the group. The closure receives a binding to the value that you pass into the openWindow action when you open the window. SwiftUI automatically persists and restores the value of this binding as part of the state restoration process.\n\nDiscussion\n\nThe window group uses the given view as a template to form the content of each window in the group.\n\nSwiftUI creates a window from the group when you present a value of the specified type using the openWindow action.\n\nSee Also\nCreating a data-driven window group\ninit<D, C>(LocalizedStringKey, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string.\nAvailable when Content conforms to View.\ninit<D, C>(Text, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title.\nAvailable when Content conforms to View."
    },
    {
        "title": "init(_:id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:content:)-2kb4v",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the title of the group.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group. The system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSee Also\nIdentifying a window group\ninit(id: String, content: () -> Content)\nCreates a window group with an identifier.\ninit(Text, id: String, content: () -> Content)\nCreates a window group with a text view title and an identifier.\ninit<S>(S, id: String, content: () -> Content)\nCreates a window group with a title string and an identifier."
    },
    {
        "title": "init(_:id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:content:)-5ulvw",
        "html": "Parameters\ntitle\n\nThe string to use for the title of the group.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group. The system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSee Also\nIdentifying a window group\ninit(id: String, content: () -> Content)\nCreates a window group with an identifier.\ninit(Text, id: String, content: () -> Content)\nCreates a window group with a text view title and an identifier.\ninit(LocalizedStringKey, id: String, content: () -> Content)\nCreates a window group with a localized title string and an identifier."
    },
    {
        "title": "shape",
        "url": "https://developer.apple.com/documentation/swiftui/transformedshape/shape",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar transform: CGAffineTransform"
    },
    {
        "title": "background",
        "url": "https://developer.apple.com/documentation/swiftui/strokebordershapeview/background",
        "html": "See Also\nGetting shape view properties\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape.\nvar style: Style\nThe style that strokes the border of this view\u2019s shape."
    },
    {
        "title": "transform",
        "url": "https://developer.apple.com/documentation/swiftui/transformedshape/transform",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar shape: Content"
    },
    {
        "title": "shape",
        "url": "https://developer.apple.com/documentation/swiftui/rotatedshape/shape",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar anchor: UnitPoint\nvar angle: Angle"
    },
    {
        "title": "isAntialiased",
        "url": "https://developer.apple.com/documentation/swiftui/strokebordershapeview/isantialiased",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape.\nvar style: Style\nThe style that strokes the border of this view\u2019s shape."
    },
    {
        "title": "angle",
        "url": "https://developer.apple.com/documentation/swiftui/rotatedshape/angle",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar anchor: UnitPoint\nvar shape: Content"
    },
    {
        "title": "strokeStyle",
        "url": "https://developer.apple.com/documentation/swiftui/strokebordershapeview/strokestyle",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar style: Style\nThe style that strokes the border of this view\u2019s shape."
    },
    {
        "title": "init(_:id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:id:content:)-6bb4r",
        "html": "Parameters\ntitle\n\nThe Text view to use for the group\u2019s title.\n\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group. The system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nImportant\n\nThe system ignores any text styling that you apply to the Text view title, like bold or italics. However, you can use the formatting controls that the view offers, like for localization, dates, and numerical representations.\n\nSee Also\nIdentifying a window group\ninit(id: String, content: () -> Content)\nCreates a window group with an identifier.\ninit(LocalizedStringKey, id: String, content: () -> Content)\nCreates a window group with a localized title string and an identifier.\ninit<S>(S, id: String, content: () -> Content)\nCreates a window group with a title string and an identifier."
    },
    {
        "title": "anchor",
        "url": "https://developer.apple.com/documentation/swiftui/rotatedshape/anchor",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar angle: Angle\nvar shape: Content"
    },
    {
        "title": "bottomLeading",
        "url": "https://developer.apple.com/documentation/swiftui/rectanglecornerradii/bottomleading",
        "html": "See Also\nGetting values for specific corners\nvar topLeading: CGFloat\nThe radius of the top-leading corner.\nvar topTrailing: CGFloat\nThe radius of the top-trailing corner.\nvar bottomTrailing: CGFloat\nThe radius of the bottom-trailing corner."
    },
    {
        "title": "topTrailing",
        "url": "https://developer.apple.com/documentation/swiftui/rectanglecornerradii/toptrailing",
        "html": "See Also\nGetting values for specific corners\nvar topLeading: CGFloat\nThe radius of the top-leading corner.\nvar bottomLeading: CGFloat\nThe radius of the bottom-leading corner.\nvar bottomTrailing: CGFloat\nThe radius of the bottom-trailing corner."
    },
    {
        "title": "writableContentTypes",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument/writablecontenttypes-6x6w9",
        "html": "Required Default implementation provided.\n\nDiscussion\n\nBy default, SwiftUI assumes that your document reads and writes the same set of content types. Only define this property if you need to indicate a different set of types for writing files. Otherwise, the default implementation of this property returns the list that you specify in your implementation of readableContentTypes.\n\nDefault Implementations\nReferenceFileDocument Implementations\nstatic var writableContentTypes: [UTType]\nThe file types that the document supports saving or exporting to.\nSee Also\nWriting a document\nfunc fileWrapper(snapshot: Self.Snapshot, configuration: Self.WriteConfiguration) throws -> FileWrapper\nSerializes a document snapshot to a file wrapper.\n\nRequired\n\ntypealias WriteConfiguration\nThe configuration for writing document contents."
    },
    {
        "title": "ReferenceFileDocument.WriteConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument/writeconfiguration",
        "html": "Discussion\n\nThis type is an alias for FileDocumentWriteConfiguration, which contains a content type and a file wrapper that you use to access the contents of a document file, if one already exists. You get a value of this type as an input to the fileWrapper(snapshot:configuration:) method.\n\nSee Also\nWriting a document\nfunc fileWrapper(snapshot: Self.Snapshot, configuration: Self.WriteConfiguration) throws -> FileWrapper\nSerializes a document snapshot to a file wrapper.\n\nRequired\n\nstatic var writableContentTypes: [UTType]\nThe file types that the document supports saving or exporting to.\n\nRequired Default implementation provided."
    },
    {
        "title": "init(_:image:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:isinserted:content:)-1wlb8",
        "html": "Parameters\ntitle\n\nThe string to use for the accessibility label of the item.\n\nimage\n\nThe name of an image in the app\u2019s bundle to use as the label.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\n\nSee Also\nCreating a menu bar extra with a named image\ninit(LocalizedStringKey, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "fileWrapper(snapshot:configuration:)",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument/filewrapper(snapshot:configuration:)",
        "html": "Required\n\nParameters\nsnapshot\n\nThe document snapshot to save.\n\nconfiguration\n\nInformation about a file that already exists for the document, if any.\n\nReturn Value\n\nThe destination to serialize the document contents to. The value can be a newly created FileWrapper or an update of the one provided in the configuration input.\n\nDiscussion\n\nTo store a document \u2014 for example, in response to a Save command \u2014 SwiftUI begins by calling the snapshot(contentType:) method to get a copy of the document data in its current state. Then SwiftUI passes that snapshot to this method, where you serialize it and create or modify a file wrapper with the serialized data:\n\nfunc fileWrapper(snapshot: Snapshot, configuration: WriteConfiguration) throws -> FileWrapper {\n    let data = try JSONEncoder().encode(snapshot)\n    return FileWrapper(regularFileWithContents: data)\n}\n\n\nSwiftUI disables document edits during the snapshot to ensure that the document\u2019s data remains coherent, but reenables edits during the serialization operation.\n\nNote\n\nSwiftUI calls this method on a background thread. Don\u2019t make user interface changes from that thread.\n\nSee Also\nWriting a document\nstatic var writableContentTypes: [UTType]\nThe file types that the document supports saving or exporting to.\n\nRequired Default implementation provided.\n\ntypealias WriteConfiguration\nThe configuration for writing document contents."
    },
    {
        "title": "readableContentTypes",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument/readablecontenttypes",
        "html": "Required\n\nDiscussion\n\nDefine this list to indicate the content types that your document can read. By default, SwiftUI assumes that your document can also write the same set of content types. If you need to indicate a different set of types for writing files, define the writableContentTypes property in addition to this property.\n\nSee Also\nReading a document\ninit(configuration: Self.ReadConfiguration) throws\nCreates a document and initializes it with the contents of a file.\n\nRequired\n\ntypealias ReadConfiguration\nThe configuration for reading document contents."
    },
    {
        "title": "init(_:systemImage:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:systemimage:content:)-3weny",
        "html": "Parameters\ntitle\n\nThe string to use for the accessibility label of the item.\n\nsystemImage\n\nThe name of a system image to use as the label.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item defines the primary scene of an App.\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra with a system image\ninit(LocalizedStringKey, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "WindowMenuBarExtraStyle",
        "url": "https://developer.apple.com/documentation/swiftui/windowmenubarextrastyle",
        "html": "Overview\n\nUse window to construct this style.\n\nTopics\nCreating the menu bar extra style\ninit()\nCreates a window menu bar extra style.\nRelationships\nConforms To\nMenuBarExtraStyle\nSee Also\nSupporting types\nstruct AutomaticMenuBarExtraStyle\nThe default menu bar extra style. You can also use automatic to construct this style.\nstruct PullDownMenuBarExtraStyle\nA menu bar extra style that renders its contents as a menu that pulls down from the icon in the menu bar."
    },
    {
        "title": "init(viewing:migrationPlan:viewer:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(viewing:migrationplan:viewer:)",
        "html": "Parameters\nviewing\n\nThe content type of the document. It should conform to UTType.package.\n\nmigrationPlan\n\nThe description of steps required to migrate older document versions so that they can be opened. The last VersionedSchema in the plan is considered to be the current application schema.\n\nviewer\n\nThe viewing UI for the provided document.\n\nSee Also\nViewing a document backed by a persistent store\ninit(viewing: [PersistentModel.Type], contentType: UTType, viewer: () -> Content)\nInstantiates a document group for viewing documents that store several model types.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(viewing: PersistentModel.Type, contentType: UTType, viewer: () -> Content)\nInstantiates a document group for viewing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View."
    },
    {
        "title": "contentSize",
        "url": "https://developer.apple.com/documentation/swiftui/windowresizability/contentsize",
        "html": "Discussion\n\nWindows that use this resizability have:\n\nA minimum size that matches the minimum size of the window\u2019s content.\n\nA maximum size that matches the maximum size of the window\u2019s content.\n\nSee Also\nGetting the resizability\nstatic var automatic: WindowResizability\nThe automatic window resizability.\nstatic var contentMinSize: WindowResizability\nA window resizability that\u2019s partially derived from the window\u2019s content."
    },
    {
        "title": "contentMinSize",
        "url": "https://developer.apple.com/documentation/swiftui/windowresizability/contentminsize",
        "html": "Discussion\n\nWindows that use this resizability have:\n\nA minimum size that matches the minimum size of the window\u2019s content.\n\nNo maximum size.\n\nSee Also\nGetting the resizability\nstatic var automatic: WindowResizability\nThe automatic window resizability.\nstatic var contentSize: WindowResizability\nA window resizability that\u2019s derived from the window\u2019s content."
    },
    {
        "title": "callAsFunction(at:)",
        "url": "https://developer.apple.com/documentation/swiftui/opendocumentaction/callasfunction(at:)",
        "html": "Parameters\nurl\n\nA file URL that points at an existing document.\n\nDiscussion\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the openDocument action:\n\ndo {\n    try await openDocument(at: url)\n} catch {\n    // Handle error\n}\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language."
    },
    {
        "title": "fileURL",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocumentconfiguration/fileurl",
        "html": "See Also\nGetting document properties\nvar isEditable: Bool\nA Boolean that indicates whether you can edit the document."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/wkextensiondelegateadaptor/init(_:)-2556",
        "html": "Parameters\ndelegateType\n\nThe type of extension delegate that you define in your app, which conforms to the WKExtensionDelegate protocol.\n\nDiscussion\n\nCall this initializer indirectly by creating a property with the WKExtensionDelegateAdaptor property wrapper from inside your App declaration:\n\n@main\nstruct MyApp: App {\n    @WKExtensionDelegateAdaptor private var extensionDelegate: MyExtensionDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI initializes the delegate and manages its lifetime, calling upon it to handle extension delegate callbacks.\n\nIf you want SwiftUI to put the instantiated delegate in the Environment, make sure the delegate class also conforms to the ObservableObject protocol. That causes SwiftUI to invoke the init(_:) initializer rather than this one.\n\nSee Also\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor using a delegate that\u2019s an observable object.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to WKExtensionDelegate.\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor using an observable delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to Observable, and DelegateType conforms to WKExtensionDelegate."
    },
    {
        "title": "init(content:label:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(content:label:)",
        "html": "Parameters\ncontent\n\nA View to display when the user selects the item.\n\nlabel\n\nA View to use as the label in the system menu bar.\n\nDiscussion\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The extra defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit(LocalizedStringKey, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit(isInserted: Binding<Bool>, content: () -> Content, label: () -> Label)\nCreates a menu bar extra. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false."
    },
    {
        "title": "document",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocumentconfiguration/document",
        "html": "Discussion\n\nChanges to the document dirty the document state, indicating that it needs to be saved. SwiftUI doesn\u2019t automatically register undo actions. You have to manage undo operations yourself, as demonstrated in Building a Document-Based App with SwiftUI.\n\nSee Also\nGetting and setting the document\nvar $document: ObservedObject<Document>.Wrapper"
    },
    {
        "title": "UnifiedCompactWindowToolbarStyle",
        "url": "https://developer.apple.com/documentation/swiftui/unifiedcompactwindowtoolbarstyle",
        "html": "Overview\n\nYou can also use unifiedCompact or unifiedCompact(showsTitle:) to construct this style.\n\nTopics\nCreating the window toolbar style\ninit()\nCreates a unified compact window toolbar style.\ninit(showsTitle: Bool)\nCreates a unified compact window toolbar style.\nRelationships\nConforms To\nWindowToolbarStyle\nSee Also\nSupporting types\nstruct DefaultWindowToolbarStyle\nThe default window toolbar style.\nstruct ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nstruct UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline."
    },
    {
        "title": "init(_:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:content:)-4tqs4",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the label of the item.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra\ninit<S>(S, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a menu bar extra that will be displayed in the system menu bar, and defines the primary scene of an App.\ninit(LocalizedStringKey, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit(isInserted: Binding<Bool>, content: () -> Content, label: () -> Label)\nCreates a menu bar extra. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false."
    },
    {
        "title": "init(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/settings/init(content:)",
        "html": "Parameters\ncontent\n\nA view that represents the content of the scene.\n\nDiscussion\n\nUse Settings(content:) to add a preferences scene when you declare your app using the App protocol.\n\nThe example below shows the view content for the settings scene added to the SwiftUI app delegate:\n\n@main\nstruct MacSwiftUISnippets: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        #if os(macOS)\n        Settings(content: {\n            SettingsView()\n        }\n        #endif\n    }\n}\n\n\nWhen you use an App declaration for multiple platforms, compile the settings scene only in macOS, as shown in the example above."
    },
    {
        "title": "ScenePhase.inactive",
        "url": "https://developer.apple.com/documentation/swiftui/scenephase/inactive",
        "html": "Discussion\n\nA scene in this phase doesn\u2019t receive events and should pause timers and free any unnecessary resources. The scene might be completely hidden in the user interface or otherwise unavailable to the user. In macOS, scenes only pass through this phase temporarily on their way to the ScenePhase.background phase.\n\nAn app or custom scene in this phase contains no scene instances in the ScenePhase.active phase.\n\nSee Also\nGetting scene phases\ncase active\nThe scene is in the foreground and interactive.\ncase background\nThe scene isn\u2019t currently visible in the UI."
    },
    {
        "title": "FileDocument.WriteConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/filedocument/writeconfiguration",
        "html": "Discussion\n\nThis type is an alias for FileDocumentWriteConfiguration, which contains a content type and a file wrapper that you use to access the contents of a document file, if one already exists. You get a value of this type as an input to the fileWrapper(configuration:) method.\n\nSee Also\nWriting a document\nfunc fileWrapper(configuration: Self.WriteConfiguration) throws -> FileWrapper\nSerializes a document snapshot to a file wrapper.\n\nRequired\n\nstatic var writableContentTypes: [UTType]\nThe file types that the document supports saving or exporting to.\n\nRequired Default implementation provided."
    },
    {
        "title": "DocumentGroup",
        "url": "https://developer.apple.com/documentation/SwiftUI/DocumentGroup",
        "html": "Overview\n\nUse a DocumentGroup scene to tell SwiftUI what kinds of documents your app can open when you declare your app using the App protocol.\n\nInitialize a document group scene by passing in the document model and a view capable of displaying the document type. The document types you supply to DocumentGroup must conform to FileDocument or ReferenceFileDocument. SwiftUI uses the model to add document support to your app. In macOS this includes document-based menu support, including the ability to open multiple documents. On iOS this includes a document browser that can navigate to the documents stored on the file system and multiwindow support:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextFile()) { configuration in\n            ContentView(document: configuration.$document)\n        }\n    }\n}\n\n\nAny time the configuration changes, SwiftUI updates the contents with that new configuration, similar to other parameterized builders.\n\nViewing documents\n\nIf your app only needs to display but not modify a specific document type, you can use the file viewer document group scene. You supply the file type of the document, and a view that displays the document type that you provide:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(viewing: MyImageFormatDocument.self) {\n            MyImageFormatViewer(image: $0.document)\n        }\n    }\n}\n\nSupporting multiple document types\n\nYour app can support multiple document types by adding additional document group scenes:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextFile()) { group in\n            ContentView(document: group.$document)\n        }\n        DocumentGroup(viewing: MyImageFormatDocument.self) { group in\n            MyImageFormatViewer(image: group.document)\n        }\n    }\n}\n\nAccessing the document\u2019s URL\n\nIf your app needs to know the document\u2019s URL, you can read it from the editor closure\u2019s configuration parameter, along with the binding to the document. When you create a new document, the configuration\u2019s fileURL property is nil. Every time it changes, it is passed over to the DocumentGroup builder in the updated configuration. This ensures that the view you define in the closure always knows the URL of the document it hosts.\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextFile()) { configuration in\n            ContentView(\n                document: configuration.$document,\n                fileURL: configuration.fileURL\n            )\n        }\n    }\n}\n\n\nThe URL can be used, for example, to present the file path of the file name in the user interface. Don\u2019t access the document\u2019s contents or metadata using the URL because that can conflict with the management of the file that SwiftUI performs. Instead, use the methods that FileDocument and ReferenceFileDocument provide to perform read and write operations.\n\nTopics\nCreating a document group\ninit(newDocument: () -> Document, editor: (FileDocumentConfiguration<Document>) -> Content)\nCreates a document group for creating and editing file documents.\nAvailable when Document conforms to FileDocument and Content conforms to View.\ninit(viewing: Document.Type, viewer: (FileDocumentConfiguration<Document>) -> Content)\nCreates a document group capable of viewing file documents.\nAvailable when Document conforms to FileDocument and Content conforms to View.\nCreating a reference file document group\ninit(newDocument: () -> Document, editor: (ReferenceFileDocumentConfiguration<Document>) -> Content)\nCreates a document group that is able to create and edit reference file documents.\nAvailable when Document conforms to ReferenceFileDocument and Content conforms to View.\ninit(viewing: Document.Type, viewer: (ReferenceFileDocumentConfiguration<Document>) -> Content)\nCreates a document group that is able to view reference file documents.\nAvailable when Document conforms to ReferenceFileDocument and Content conforms to View.\nEditing a document backed by a persistent store\ninit(editing: [PersistentModel.Type], contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store several model types.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(editing: PersistentModel.Type, contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(editing: UTType, migrationPlan: SchemaMigrationPlan.Type, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents described by the last Schema in the migration plan.\nAvailable when Document is ModelDocument and Content conforms to View.\nViewing a document backed by a persistent store\ninit(viewing: [PersistentModel.Type], contentType: UTType, viewer: () -> Content)\nInstantiates a document group for viewing documents that store several model types.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(viewing: PersistentModel.Type, contentType: UTType, viewer: () -> Content)\nInstantiates a document group for viewing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(viewing: UTType, migrationPlan: SchemaMigrationPlan.Type, viewer: () -> Content)\nInstantiates a document group for viewing documents described by the last Schema in the migration plan.\nAvailable when Document is ModelDocument and Content conforms to View.\nRelationships\nConforms To\nScene\nSee Also\nCreating a document\nBuilding a document-based app using SwiftData\nCode along with the WWDC presenter to transform an app with SwiftData."
    },
    {
        "title": "$document",
        "url": "https://developer.apple.com/documentation/swiftui/filedocumentconfiguration/$document",
        "html": "See Also\nGetting and setting the document\nvar document: Document\nThe current document model."
    },
    {
        "title": "Bindable",
        "url": "https://developer.apple.com/documentation/SwiftUI/Bindable",
        "html": "Overview\n\nUse this property wrapper to create bindings to mutable properties of a data model object that conforms to the Observable protocol. For example, the following code wraps the book input with @Bindable. Then it uses a TextField to change the title property of a book, and a Toggle to change the isAvailable property, using the $ syntax to pass a binding for each property to those controls.\n\n@Observable\nclass Book: Identifiable {\n    var title = \"Sample Book Title\"\n    var isAvailable = true\n}\n\n\nstruct BookEditView: View {\n    @Bindable var book: Book\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Form {\n            TextField(\"Title\", text: $book.title)\n\n\n            Toggle(\"Book is available\", isOn: $book.isAvailable)\n\n\n            Button(\"Close\") {\n                dismiss()\n            }\n        }\n    }\n}\n\n\nYou can use the Bindable property wrapper on properties and variables to an Observable object. This includes global variables, properties that exists outside of SwiftUI types, or even local variables. For example, you can create a @Bindable variable within a view\u2019s body:\n\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n\n    var body: some View {\n        List(books) { book in\n            @Bindable var book = book\n            TextField(\"Title\", text: $book.title)\n        }\n    }\n}\n\n\nThe @Bindable variable book provides a binding that connects TextField to the title property of a book so that a person can make changes directly to the model data.\n\nUse this same approach when you need a binding to a property of an observable object stored in a view\u2019s environment. For example, the following code uses the Environment property wrapper to retrieve an instance of the observable type Book. Then the code creates a @Bindable variable book and passes a binding for the title property to a TextField using the $ syntax.\n\nstruct TitleEditView: View {\n    @Environment(Book.self) private var book\n\n\n    var body: some View {\n        @Bindable var book = book\n        TextField(\"Title\", text: $book.title)\n    }\n}\n\nTopics\nCreating a bindable value\ninit(Value)\nCreates a bindable object from an observable object.\nAvailable when Value conforms to Observable.\ninit(wrappedValue: Value)\nCreates a bindable object from an observable object.\nAvailable when Value conforms to Observable.\ninit(projectedValue: Bindable<Value>)\nCreates a bindable from the value of another bindable.\nAvailable when Value conforms to Observable.\nGetting the value\nvar wrappedValue: Value\nThe wrapped object.\nvar projectedValue: Bindable<Value>\nThe bindable wrapper for the object that creates bindings to its properties using dynamic member lookup.\nsubscript<Subject>(dynamicMember _: ReferenceWritableKeyPath<Value, Subject>) -> Binding<Subject>\nReturns a binding to the value of a given key path.\nRelationships\nConforms To\nIdentifiable\nSendable\nSee Also\nCreating and sharing view state\nManaging user interface state\nEncapsulate view-specific data within your app\u2019s view hierarchy to make your views reusable.\nstruct State\nA property wrapper type that can read and write a value managed by SwiftUI.\nstruct Binding\nA property wrapper type that can read and write a value owned by a source of truth."
    },
    {
        "title": "init(newDocument:editor:)",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup/init(newdocument:editor:)-4toe2",
        "html": "Parameters\nnewDocument\n\nThe initial document to use when a user creates a new document.\n\neditor\n\nThe editing UI for the provided document.\n\nDiscussion\n\nUse a DocumentGroup scene to tell SwiftUI what kinds of documents your app can open when you declare your app using the App protocol. You initialize a document group scene by passing in the document model and a view capable of displaying the document\u2019s contents. The document types you supply to DocumentGroup must conform to FileDocument or ReferenceFileDocument. SwiftUI uses the model to add document support to your app. In macOS this includes document-based menu support including the ability to open multiple documents. On iOS this includes a document browser that can navigate to the documents stored on the file system and multiwindow support:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextFile()) { file in\n            ContentView(document: file.$document)\n        }\n    }\n}\n\n\nThe document types you supply to DocumentGroup must conform to FileDocument or ReferenceFileDocument. Your app can support multiple document types by adding additional DocumentGroup scenes.\n\nSee Also\nCreating a document group\ninit(viewing: Document.Type, viewer: (FileDocumentConfiguration<Document>) -> Content)\nCreates a document group capable of viewing file documents.\nAvailable when Document conforms to FileDocument and Content conforms to View."
    },
    {
        "title": "callAsFunction(id:)",
        "url": "https://developer.apple.com/documentation/swiftui/dismisswindowaction/callasfunction(id:)",
        "html": "Parameters\nid\n\nThe identifier of the scene to dismiss.\n\nDiscussion\n\nWhen the specified identifier represents a WindowGroup, all of the open windows in that group will be dismissed. For dismissing a single window associated to a WindowGroup scene, use dismissWindow(value:) or dismissWindow(id:value:).\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the dismissWindow action with an identifier:\n\ndismissWindow(id: \"message\")\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language.\n\nSee Also\nCalling the action\nfunc callAsFunction()\nDismisses the current window.\nfunc callAsFunction<D>(id: String, value: D)\nDismisses the window defined by the window group that is presenting the specified value type and that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(value: D)\nDismisses the window defined by the window group that is presenting the specified value type."
    },
    {
        "title": "callAsFunction(id:value:)",
        "url": "https://developer.apple.com/documentation/swiftui/dismisswindowaction/callasfunction(id:value:)",
        "html": "Parameters\nid\n\nThe identifier of the scene to dismiss.\n\nvalue\n\nThe value which is currently presented.\n\nDiscussion\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the dismissWindow action with an identifier and a value:\n\ndismissWindow(id: \"message\", value: message.id)\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language.\n\nSee Also\nCalling the action\nfunc callAsFunction()\nDismisses the current window.\nfunc callAsFunction(id: String)\nDismisses the window that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(value: D)\nDismisses the window defined by the window group that is presenting the specified value type."
    },
    {
        "title": "ProgressiveImmersionStyle",
        "url": "https://developer.apple.com/documentation/swiftui/progressiveimmersionstyle",
        "html": "Overview\n\nThe system initially uses a radial portal effect. People can then interactively dial in and out to switch between the portal style and a style that matches the FullImmersionStyle. In the case of the latter passthrough is obscured except for people\u2019s hands if configured accordingly.\n\nUse progressive to create this style.\n\nTopics\nCreating the immersion style\ninit()\nRelationships\nConforms To\nImmersionStyle\nSee Also\nSupporting types\nstruct AutomaticImmersionStyle\nThe default style of immersive spaces.\nBeta\nstruct FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video.\nBeta\nstruct MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nBeta"
    },
    {
        "title": "HiddenTitleBarWindowStyle",
        "url": "https://developer.apple.com/documentation/swiftui/hiddentitlebarwindowstyle",
        "html": "Overview\n\nYou can also use hiddenTitleBar to construct this style.\n\nTopics\nCreating the window style\ninit()\nCreates a hidden title bar window style.\nRelationships\nConforms To\nWindowStyle\nSee Also\nSupporting types\nstruct DefaultWindowStyle\nThe default window style.\nstruct PlainWindowStyle\nThe plain window style.\nBeta\nstruct TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nstruct VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nBeta"
    },
    {
        "title": "PlainWindowStyle",
        "url": "https://developer.apple.com/documentation/swiftui/plainwindowstyle",
        "html": "Overview\n\nYou can also use plain to construct this style.\n\nTopics\nCreating the window style\ninit()\nRelationships\nConforms To\nWindowStyle\nSee Also\nSupporting types\nstruct DefaultWindowStyle\nThe default window style.\nstruct HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nstruct TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nstruct VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nBeta"
    },
    {
        "title": "MixedImmersionStyle",
        "url": "https://developer.apple.com/documentation/swiftui/mixedimmersionstyle",
        "html": "Overview\n\nUse mixed to specify this style.\n\nTopics\nCreating the immersion style\ninit()\nRelationships\nConforms To\nImmersionStyle\nSee Also\nSupporting types\nstruct AutomaticImmersionStyle\nThe default style of immersive spaces.\nBeta\nstruct FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video.\nBeta\nstruct ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nBeta"
    },
    {
        "title": "OpenImmersiveSpaceAction.Result",
        "url": "https://developer.apple.com/documentation/swiftui/openimmersivespaceaction/result",
        "html": "Topics\nGetting the result\ncase opened\nOpening the immersive space succeeded.\ncase userCancelled\nOpening the immersive space failed since the user cancelled the request.\ncase error\nOpening the immersive space failed since the system cannot fulfill the request.\nRelationships\nConforms To\nEquatable\nHashable\nSendable"
    },
    {
        "title": "init(_:id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/window/init(_:id:content:)-2jw3u",
        "html": "Parameters\ntitle\n\nThe Text view to use for the window\u2019s title in system menus and in the window\u2019s title bar. Provide a title that describes the purpose of the window.\n\nid\n\nA unique string identifier that you can use to open the window.\n\ncontent\n\nThe view content to display in the window.\n\nDiscussion\n\nThe window displays the view that you specify.\n\nImportant\n\nThe system ignores any text styling that you apply to the Text view title, like bold or italics. However, you can use the formatting controls that the view offers, like for localization, dates, and numerical representations.\n\nSee Also\nCreating a window\ninit(LocalizedStringKey, id: String, content: () -> Content)\nCreates a window with a localized title and an identifier.\ninit<S>(S, id: String, content: () -> Content)\nCreates a window with a title string and an identifier."
    },
    {
        "title": "callAsFunction(id:value:)",
        "url": "https://developer.apple.com/documentation/swiftui/openimmersivespaceaction/callasfunction(id:value:)",
        "html": "Parameters\nid\n\nThe identifier of the immersive space to present.\n\nvalue\n\nThe value to present.\n\nDiscussion\n\nThe call returns either once the space is presented, or once an error occurred.\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the openImmersiveSpace action:\n\nawait openImmersiveSpace(id: \"solarSystem\", value: solarSystem.ID)\n\n\nIf an immersive space is already presented, calling this action has no effect. Dismiss any currently presented immersive space prior to presenting another one. Otherwise, the system creates a new immersive space and passes its root view a binding to the specified value.\n\nFor best performance, use lightweight data for the presentation value. For structured model values that conform to Identifiable, the value\u2019s identifier makes a good presentation value.\n\nSee Also\nCalling the action\nfunc callAsFunction(id: String) async -> OpenImmersiveSpaceAction.Result\nPresents an immersive space for the scene with the specified identifier.\nBeta\nfunc callAsFunction<D>(value: D) async -> OpenImmersiveSpaceAction.Result\nPresents the immersive space that handles the type of the presented value.\nBeta"
    },
    {
        "title": "volumetric",
        "url": "https://developer.apple.com/documentation/swiftui/windowstyle/volumetric",
        "html": "Discussion\n\nUse a volumetric window \u2014 or a volume \u2014 to display 3D content within a bounded region. For example, Hello World uses a volume to present a Globe model that people can pick up and move around the Shared Space using the window bar:\n\nWindowGroup(id: Module.globe.name) {\n    Globe()\n        .environment(model)\n}\n.windowStyle(.volumetric)\n.defaultSize(width: 0.6, height: 0.6, depth: 0.6, in: .meters)\n\n\nA volume enables someone to view content from all angles, unlike other windows which fade out as people move around the window. Also unlike other windows, a volume uses fixed scale, which means that objects in the volume appear smaller when the volume is farther away, like real objects would. For a comparison of fixed and dynamic scale, see Spatial layout.\n\nYou can specify a size for the volume using one of the default size scene modifiers, like defaultSize(width:height:depth:in:). Because volumes use fixed scale, it\u2019s typically convenient to specify a size in physical units \u2014 like meters, as the above code demonstrates. People can\u2019t change the size of the volume after it appears.\n\nFor design guidance, see Windows. If you want to place 3D objects arbitrarily throughout the Shared Space or in a Full Space, use an ImmersiveSpace instead.\n\nSee Also\nGetting built-in window styles\nstatic var automatic: DefaultWindowStyle\nThe default window style.\nAvailable when Self is DefaultWindowStyle.\nstatic var hiddenTitleBar: HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nAvailable when Self is HiddenTitleBarWindowStyle.\nstatic var plain: PlainWindowStyle\nThe plain window style.\nAvailable when Self is PlainWindowStyle.\nBeta\nstatic var titleBar: TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nAvailable when Self is TitleBarWindowStyle."
    },
    {
        "title": "init(_:id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/window/init(_:id:content:)-7fkt9",
        "html": "Parameters\ntitle\n\nA string to use for the window\u2019s title in system menus and in the window\u2019s title bar. Provide a title that describes the purpose of the window.\n\nid\n\nA unique string identifier that you can use to open the window.\n\ncontent\n\nThe view content to display in the window.\n\nDiscussion\n\nThe window displays the view that you specify.\n\nSee Also\nCreating a window\ninit(LocalizedStringKey, id: String, content: () -> Content)\nCreates a window with a localized title and an identifier.\ninit(Text, id: String, content: () -> Content)\nCreates a window with a title and an identifier."
    },
    {
        "title": "callAsFunction(value:)",
        "url": "https://developer.apple.com/documentation/swiftui/openimmersivespaceaction/callasfunction(value:)",
        "html": "Parameters\nvalue\n\nThe value to present.\n\nDiscussion\n\nThe call returns either once the immersive space is presented, or once an error occurred.\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the openImmersiveSpace action:\n\nawait openImmersiveSpace(value: solarSystem.ID)\n\n\nIf an immersive space is already presented, calling this action has no effect. Dismiss any currently presented immersive space prior to presenting another one. Otherwise, the system creates a new immersive space and passes its root view a binding to the specified value.\n\nFor best performance, use lightweight data for the presentation value. For structured model values that conform to Identifiable, the value\u2019s identifier makes a good presentation value.\n\nSee Also\nCalling the action\nfunc callAsFunction(id: String) async -> OpenImmersiveSpaceAction.Result\nPresents an immersive space for the scene with the specified identifier.\nBeta\nfunc callAsFunction<D>(id: String, value: D) async -> OpenImmersiveSpaceAction.Result\nPresents the immersive space that your app defines for the specified identifier and that handles the type of the presented value.\nBeta"
    },
    {
        "title": "DefaultWindowStyle",
        "url": "https://developer.apple.com/documentation/swiftui/defaultwindowstyle",
        "html": "Overview\n\nYou can also use automatic to construct this style.\n\nTopics\nCreating the window style\ninit()\nRelationships\nConforms To\nWindowStyle\nSee Also\nSupporting types\nstruct HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nstruct PlainWindowStyle\nThe plain window style.\nBeta\nstruct TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nstruct VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nBeta"
    },
    {
        "title": "init(_:id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/window/init(_:id:content:)-2m884",
        "html": "Parameters\ntitleKey\n\nA localized string key to use for the window\u2019s title in system menus and in the window\u2019s title bar. Provide a title that describes the purpose of the window.\n\nid\n\nA unique string identifier that you can use to open the window.\n\ncontent\n\nThe view content to display in the window.\n\nDiscussion\n\nThe window displays the view that you specify.\n\nSee Also\nCreating a window\ninit<S>(S, id: String, content: () -> Content)\nCreates a window with a title string and an identifier.\ninit(Text, id: String, content: () -> Content)\nCreates a window with a title and an identifier."
    },
    {
        "title": "plain",
        "url": "https://developer.apple.com/documentation/swiftui/windowstyle/plain",
        "html": "Discussion\n\nUnlike automatic, a plain window does not receive a glass background in visionOS. Use this style if you want more control over how glass is used in your window.\n\nSee Also\nGetting built-in window styles\nstatic var automatic: DefaultWindowStyle\nThe default window style.\nAvailable when Self is DefaultWindowStyle.\nstatic var hiddenTitleBar: HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nAvailable when Self is HiddenTitleBarWindowStyle.\nstatic var titleBar: TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nAvailable when Self is TitleBarWindowStyle.\nstatic var volumetric: VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nAvailable when Self is VolumetricWindowStyle.\nBeta"
    },
    {
        "title": "automatic",
        "url": "https://developer.apple.com/documentation/swiftui/windowstyle/automatic",
        "html": "See Also\nGetting built-in window styles\nstatic var hiddenTitleBar: HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nAvailable when Self is HiddenTitleBarWindowStyle.\nstatic var plain: PlainWindowStyle\nThe plain window style.\nAvailable when Self is PlainWindowStyle.\nBeta\nstatic var titleBar: TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nAvailable when Self is TitleBarWindowStyle.\nstatic var volumetric: VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nAvailable when Self is VolumetricWindowStyle.\nBeta"
    },
    {
        "title": "titleBar",
        "url": "https://developer.apple.com/documentation/swiftui/windowstyle/titlebar",
        "html": "See Also\nGetting built-in window styles\nstatic var automatic: DefaultWindowStyle\nThe default window style.\nAvailable when Self is DefaultWindowStyle.\nstatic var hiddenTitleBar: HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nAvailable when Self is HiddenTitleBarWindowStyle.\nstatic var plain: PlainWindowStyle\nThe plain window style.\nAvailable when Self is PlainWindowStyle.\nBeta\nstatic var volumetric: VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nAvailable when Self is VolumetricWindowStyle.\nBeta"
    },
    {
        "title": "hiddenTitleBar",
        "url": "https://developer.apple.com/documentation/swiftui/windowstyle/hiddentitlebar",
        "html": "See Also\nGetting built-in window styles\nstatic var automatic: DefaultWindowStyle\nThe default window style.\nAvailable when Self is DefaultWindowStyle.\nstatic var plain: PlainWindowStyle\nThe plain window style.\nAvailable when Self is PlainWindowStyle.\nBeta\nstatic var titleBar: TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nAvailable when Self is TitleBarWindowStyle.\nstatic var volumetric: VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nAvailable when Self is VolumetricWindowStyle.\nBeta"
    },
    {
        "title": "AccessibilitySystemRotor",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitysystemrotor",
        "html": "Topics\nIterating through text\nstatic var textFields: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all text fields.\nstatic var boldText: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all the ranges of bolded text.\nstatic var italicText: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all the ranges of italicized text.\nstatic var underlineText: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all the ranges of underlined text.\nstatic var misspelledWords: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all the ranges of mis-spelled words.\nIterating through headings\nstatic var headings: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all headings.\nstatic func headings(level: AccessibilityHeadingLevel) -> AccessibilitySystemRotor\nSystem Rotors allowing users to iterate through all headings, of various heading levels.\nIterating through links\nstatic var links: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all links.\nstatic func links(visited: Bool) -> AccessibilitySystemRotor\nSystem Rotors allowing users to iterate through links or visited links.\nIterating through other elements\nstatic var images: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all images.\nstatic var landmarks: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all landmarks.\nstatic var lists: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all lists.\nstatic var tables: AccessibilitySystemRotor\nSystem Rotor allowing users to iterate through all tables.\nRelationships\nConforms To\nSendable\nSee Also\nReplacing system rotors\nfunc accessibilityRotor<Content>(AccessibilitySystemRotor, entries: () -> Content) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel, ID>(AccessibilitySystemRotor, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel>(AccessibilitySystemRotor, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor(AccessibilitySystemRotor, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element."
    },
    {
        "title": "KeyPress",
        "url": "https://developer.apple.com/documentation/swiftui/keypress",
        "html": "Topics\nGetting the keypress\nlet key: KeyEquivalent\nThe key equivalent value for the pressed key.\nlet characters: String\nThe characters generated by the pressed key as if no modifier key applies.\nlet modifiers: EventModifiers\nThe set of modifier keys the user held in addition to the pressed key.\nGetting the phase of the keypress\nlet phase: KeyPress.Phases\nThe phase of the key-press event (.down, .repeat, or .up).\nstruct Phases\nOptions for matching different phases of a key-press event.\nGetting the result\nenum Result\nA result value returned from a key-press action that indicates whether the action consumed the event.\nRelationships\nConforms To\nCustomDebugStringConvertible\nSendable\nSee Also\nResponding to keyboard input\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses any key on a hardware keyboard while the view has focus.\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus."
    },
    {
        "title": "TouchBar",
        "url": "https://developer.apple.com/documentation/swiftui/touchbar",
        "html": "Topics\nCreating a Touch Bar view\ninit(content: () -> Content)\nCreates a non-customizable Touch Bar view container.\ninit(id: String, content: () -> Content)\nCreates a customizable Touch Bar view container with a globally unique identifier.\nSee Also\nManaging Touch Bar input\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nenum TouchBarItemPresence\nOptions that affect user customization of the Touch Bar."
    },
    {
        "title": "accessibilityRotor(_:textRanges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:textranges:)-1ot43",
        "html": "Parameters\nsystemRotor\n\nThe system-provided Rotor that will be overridden by this custom Rotor.\n\ntextRanges\n\nAn array of ranges that will be used to generate the entries of the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nIn the following example, a Message application adds a Rotor allowing the user to navigate through all the ranges of text containing headings.\n\nextension Message {\n    // Ranges of special areas in the `content` text. Calculated when\n    // `content` is set and then cached so that we don't have to\n    // re-compute them.\n    var headingRanges: [Range<String.Index>]\n}\n\n\nstruct MessageContentView: View {\n    TextEditor(.constant(message.content))\n        .accessibilityRotor(\n            .heading,\n            textRanges: message.headingRanges\n        )\n}\n\nSee Also\nReplacing system rotors\nfunc accessibilityRotor<Content>(AccessibilitySystemRotor, entries: () -> Content) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel, ID>(AccessibilitySystemRotor, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel>(AccessibilitySystemRotor, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nstruct AccessibilitySystemRotor\nDesignates a Rotor that replaces one of the automatic, system-provided Rotors with a developer-provided Rotor."
    },
    {
        "title": "preferredAmbientBrightness(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/preferredambientbrightness(_:)",
        "html": "Discussion\n\nThe system will use this value to tailor the ambient lightning appropriately.\n\nNote that the system might not able to honor a specified preference."
    },
    {
        "title": "modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/modelcontainer(for:inmemory:isautosaveenabled:isundoenabled:onsetup:)-82y49",
        "html": "Parameters\nmodelType\n\nThe model type defining the schema used to create the model container.\n\ninMemory\n\nWhether the container should store data only in memory.\n\nisAutosaveEnabled\n\ntrue if autosave is enabled.\n\nisUndoEnabled\n\nuse undoManager in the scene\u2019s environment to manage undo operations for the model container.\n\nonSetup\n\nA callback that will be invoked when the creation of the container has has succeeded or failed.\n\nDiscussion\n\nIn this example, RecipesApp sets a shared model container to use for all of its windows, configured to store instances of Recipe:\n\n@Model class Recipe { ... }\n\n\n@main\nstruct RecipesApp: App {\n    var body: some Scene {\n        WindowGroup {\n            RecipesList()\n        }\n        .modelContainer(for: Recipe.self)\n    }\n}\n\n\nThe environment\u2019s modelContext property will be assigned a new context associated with this container. All implicit model context operations in this scene, such as Query properties, will use the environment\u2019s context.\n\nBy default, the container stores its model data persistently on disk. To only store data in memory for the lifetime of the app\u2019s process, pass true to the inMemory: parameter.\n\nThe container will only be created once. New values that are passed to the modelType and inMemory parameters after the view is first created will be ignored.\n\nSee Also\nConfiguring a data model\nfunc modelContext(ModelContext) -> some Scene\nSets the model context in this scene\u2019s environment.\nfunc modelContainer(ModelContainer) -> some Scene\nSets the model container and associated model context in this scene\u2019s environment.\nfunc modelContainer(for: [PersistentModel.Type], inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model types, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment."
    },
    {
        "title": "onChange(of:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/onchange(of:perform:)",
        "html": "Deprecated\n\nUse onChange(of:initial:_:) or onChange(of:initial:_:) instead. The trailing closure in each case takes either zero or two input parameters, compared to this method which takes one.\n\nBe aware that the replacements have slightly different behvavior. This modifier\u2019s closure captures values that represent the state before the change. The new modifiers capture values that correspond to the new state. The new behavior makes it easier to perform updates that rely on values other than the one that caused the modifier\u2019s closure to run.\n\nParameters\nvalue\n\nThe value to check when determining whether to run the closure. The value must conform to the Equatable protocol.\n\naction\n\nA closure to run when the value changes. The closure provides a single newValue parameter that indicates the changed value.\n\nReturn Value\n\nA scene that triggers an action in response to a change.\n\nDiscussion\n\nUse this modifier to trigger a side effect when a value changes, like the value associated with an Environment value or a Binding. For example, you can clear a cache when you notice that a scene moves to the background:\n\nstruct MyScene: Scene {\n    @Environment(\\.scenePhase) private var scenePhase\n    @StateObject private var cache = DataCache()\n\n\n    var body: some Scene {\n        WindowGroup {\n            MyRootView()\n        }\n        .onChange(of: scenePhase) { newScenePhase in\n            if newScenePhase == .background {\n                cache.empty()\n            }\n        }\n    }\n}\n\n\nThe system may call the action closure on the main actor, so avoid long-running tasks in the closure. If you need to perform such tasks, detach an asynchronous background task:\n\n.onChange(of: scenePhase) { newScenePhase in\n    if newScenePhase == .background {\n        Task.detached(priority: .background) {\n            // ...\n        }\n    }\n}\n\n\nThe system passes the new value into the closure. If you need the old value, capture it in the closure."
    },
    {
        "title": "AccessibilityRotorContentBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityrotorcontentbuilder",
        "html": "Topics\nBuilding navigation content\nstatic func buildBlock<Content>(Content) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1>(C0, C1) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some AccessibilityRotorContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some AccessibilityRotorContent\nstatic func buildIf<Content>(Content?) -> some AccessibilityRotorContent\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nSee Also\nCreating rotors\nfunc accessibilityRotor<Content>(LocalizedStringKey, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<Content>(Text, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<L, Content>(L, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nprotocol AccessibilityRotorContent\nContent within an accessibility rotor.\nstruct AccessibilityRotorEntry\nA struct representing an entry in an Accessibility Rotor."
    },
    {
        "title": "accessibilityRotor(_:entries:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:)-7wp5a",
        "html": "Parameters\nlabel\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nContent used to generate Rotor entries. This can include AccessibilityRotorEntry structs, as well as constructs such as if and ForEach.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Identifiable` `Message`s.\n\n\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\") {\n    // Not all the MessageViews are generated at once, the model\n    // knows about all the messages.\n    ForEach(messages) { message in\n        // If the Message is from a VIP, make a Rotor entry for it.\n        if message.isVIP {\n            AccessibilityRotorEntry(message.subject, id: message.id)\n        }\n    }\n}\n\nSee Also\nCreating rotors\nfunc accessibilityRotor<Content>(LocalizedStringKey, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<Content>(Text, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nprotocol AccessibilityRotorContent\nContent within an accessibility rotor.\nstruct AccessibilityRotorContentBuilder\nResult builder you use to generate rotor entry content.\nstruct AccessibilityRotorEntry\nA struct representing an entry in an Accessibility Rotor."
    },
    {
        "title": "buildBlock(_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "accessibilityRotor(_:entries:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:)-nvy7",
        "html": "Parameters\nlabelKey\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nContent used to generate Rotor entries. This can include AccessibilityRotorEntry structs, as well as constructs such as if and ForEach.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Identifiable` `Message`s.\n\n\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\") {\n    // Not all the MessageViews are generated at once, the model\n    // knows about all the messages.\n    ForEach(messages) { message in\n        // If the Message is from a VIP, make a Rotor entry for it.\n        if message.isVIP {\n            AccessibilityRotorEntry(message.subject, id: message.id)\n        }\n    }\n}\n\nSee Also\nCreating rotors\nfunc accessibilityRotor<Content>(Text, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<L, Content>(L, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nprotocol AccessibilityRotorContent\nContent within an accessibility rotor.\nstruct AccessibilityRotorContentBuilder\nResult builder you use to generate rotor entry content.\nstruct AccessibilityRotorEntry\nA struct representing an entry in an Accessibility Rotor."
    },
    {
        "title": "Graphics and rendering modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-graphics-and-rendering",
        "html": "Overview\n\nUse these view modifiers to apply many of the rendering effects typically associated with a graphics context, like adding masks and creating composites. You can apply these effects to graphical views, like Shapes, as well as any other SwiftUI view.\n\nWhen you do need the flexibility of immediate mode drawing in a graphics context, use a Canvas view instead. This can be particularly helpful when you want to draw an extremely large number of dynamic shapes \u2014 for example, to create particle effects.\n\nFor more information about using these effects in your app, see Drawing and graphics.\n\nTopics\nMasks and clipping\nfunc mask<Mask>(alignment: Alignment, () -> Mask) -> some View\nMasks this view using the alpha channel of the given view.\nfunc clipped(antialiased: Bool) -> some View\nClips this view to its bounding rectangular frame.\nfunc clipShape<S>(S, style: FillStyle) -> some View\nSets a clipping shape for this view.\nfunc containerShape<T>(T) -> some View\nSets the container shape to use for any container relative shape within this view.\nScale\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc imageScale(Image.Scale) -> some View\nScales images within the view according to one of the relative sizes available including small, medium, and large images sizes.\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nRotation and transformation\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nGraphical effects\nfunc blur(radius: CGFloat, opaque: Bool) -> some View\nApplies a Gaussian blur to this view.\nfunc opacity(Double) -> some View\nSets the transparency of this view.\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view.\nfunc shadow(color: Color, radius: CGFloat, x: CGFloat, y: CGFloat) -> some View\nAdds a shadow to this view.\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a geometry proxy.\nfunc visualEffect3D((EmptyVisualEffect, GeometryProxy3D) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a 3D geometry proxy.\nBeta\nShaders\nfunc colorEffect(Shader, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter effect on the color of each pixel.\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a geometric distortion effect on the location of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter on the raster layer created from self.\nComposites\nfunc blendMode(BlendMode) -> some View\nSets the blend mode for compositing this view with overlapping views.\nfunc compositingGroup() -> some View\nWraps this view in a compositing group.\nfunc drawingGroup(opaque: Bool, colorMode: ColorRenderingMode) -> some View\nComposites this view\u2019s contents into an offscreen image before final display.\nAnimations\nfunc animation(Animation?) -> some View\nApplies the given animation to this view when this view changes.\nAvailable when Self conforms to Equatable.\nfunc animation<V>(Animation?, value: V) -> some View\nApplies the given animation to this view when the specified value changes.\nfunc animation<V>(Animation?, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given animation to all animatable values within the body closure.\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change continuously.\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change based on a trigger.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nfunc matchedGeometryEffect<ID>(id: ID, in: Namespace.ID, properties: MatchedGeometryProperties, anchor: UnitPoint, isSource: Bool) -> some View\nDefines a group of views with synchronized geometry using an identifier and namespace that you provide.\nfunc geometryGroup() -> some View\nIsolates the geometry (e.g. position and size) of the view from its parent view.\nSee Also\nDrawing views\nStyle modifiers\nApply built-in styles to different types of views.\nLayout modifiers\nTell a view how to arrange itself within a view hierarchy by adjusting its size, position, alignment, padding, and so on."
    },
    {
        "title": "modelContainer(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/modelcontainer(_:)",
        "html": "Parameters\ncontainer\n\nThe model container to use for this scene.\n\nDiscussion\n\nIn this example, RecipesApp sets a shared model container to use for all of its windows:\n\n@main\nstruct RecipesApp: App {\n    @State private var container = ModelContainer(...)\n\n\n    var body: some Scene {\n        WindowGroup {\n            RecipesList()\n        }\n        .modelContainer(container)\n    }\n}\n\n\nThe environment\u2019s modelContext property will be assigned a new context associated with this container. All implicit model context operations in this scene, such as Query properties, will use the environment\u2019s context.\n\nSee Also\nConfiguring a data model\nfunc modelContext(ModelContext) -> some Scene\nSets the model context in this scene\u2019s environment.\nfunc modelContainer(for: [PersistentModel.Type], inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model types, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment.\nfunc modelContainer(for: PersistentModel.Type, inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model type, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment."
    },
    {
        "title": "AccessibilityRotorContent",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityrotorcontent",
        "html": "Overview\n\nGenerally generated from control flow constructs like ForEach and if, and AccessibilityRotorEntry.\n\nTopics\nSupporting types\nvar body: Self.Body\nThe internal content of this AccessibilityRotorContent.\n\nRequired\n\nassociatedtype Body : AccessibilityRotorContent\nThe type for the internal content of this AccessibilityRotorContent.\n\nRequired\n\nRelationships\nConforming Types\nAccessibilityRotorEntry\nConforms when ID conforms to Hashable.\nForEach\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to AccessibilityRotorContent.\nGroup\nConforms when Content conforms to AccessibilityRotorContent.\nSee Also\nCreating rotors\nfunc accessibilityRotor<Content>(LocalizedStringKey, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<Content>(Text, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<L, Content>(L, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nstruct AccessibilityRotorContentBuilder\nResult builder you use to generate rotor entry content.\nstruct AccessibilityRotorEntry\nA struct representing an entry in an Accessibility Rotor.\nAvailable when ID conforms to Hashable."
    },
    {
        "title": "projectedValue",
        "url": "https://developer.apple.com/documentation/swiftui/wkextensiondelegateadaptor/projectedvalue",
        "html": "Discussion\n\nUse the projected value to get a binding to a value that the delegate publishes. Access the projected value by prefixing the name of the delegate instance with a dollar sign ($). For example, you might publish a Boolean value in your extension delegate:\n\nclass MyExtensionDelegate: NSObject, WKExtensionDelegate, ObservableObject {\n    @Published var isEnabled = false\n\n\n    // ...\n}\n\n\nIf you declare the delegate in your App using the WKExtensionDelegateAdaptor property wrapper, you can get the delegate that SwiftUI instantiates from the environment and access a binding to its published values from any view in your extension:\n\nstruct MyView: View {\n    @EnvironmentObject private var extensionDelegate: MyExtensionDelegate\n\n\n    var body: some View {\n        Toggle(\"Enabled\", isOn: $extensionDelegate.isEnabled)\n    }\n}\n\nSee Also\nGetting the delegate adaptor\nvar wrappedValue: DelegateType\nThe underlying delegate."
    },
    {
        "title": "modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/modelcontainer(for:inmemory:isautosaveenabled:isundoenabled:onsetup:)-2ake3",
        "html": "Parameters\nmodelTypes\n\nThe model types defining the schema used to create the model container.\n\ninMemory\n\nWhether the container should store data only in memory.\n\nisAutosaveEnabled\n\ntrue if autosave is enabled.\n\nisUndoEnabled\n\nuse undoManager in the scene\u2019s environment to manage undo operations for the model container.\n\nonSetup\n\nA callback that will be invoked when the creation of the container has has succeeded or failed.\n\nDiscussion\n\nIn this example, RecipesApp sets a shared model container to use for all of its windows, configured to store instances of Recipe and Ingredient:\n\n@Model class Recipe { ... }\n@Model class Ingredient { ... }\n\n\n@main\nstruct RecipesApp: App {\n    var body: some Scene {\n        WindowGroup {\n            RecipesList()\n        }\n        .modelContainer(for: [Recipe.self, Ingredient.self])\n    }\n}\n\n\nThe environment\u2019s modelContext property will be assigned a new context associated with this container. All implicit model context operations in this scene, such as Query properties, will use the environment\u2019s context.\n\nBy default, the container stores its model data persistently on disk. To only store data in memory for the lifetime of the app\u2019s process, pass true to the inMemory: parameter.\n\nThe container will only be created once. New values that are passed to the modelTypes and inMemory parameters after the view is first created will be ignored.\n\nSee Also\nConfiguring a data model\nfunc modelContext(ModelContext) -> some Scene\nSets the model context in this scene\u2019s environment.\nfunc modelContainer(ModelContainer) -> some Scene\nSets the model container and associated model context in this scene\u2019s environment.\nfunc modelContainer(for: PersistentModel.Type, inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model type, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment."
    },
    {
        "title": "keyboardShortcut(_:modifiers:localization:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/keyboardshortcut(_:modifiers:localization:)",
        "html": "Parameters\nkey\n\nThe key equivalent the user presses to present the scene.\n\nmodifiers\n\nThe modifier keys required to perform the shortcut.\n\nlocalization\n\nThe localization style to apply to the shortcut.\n\nReturn Value\n\nA scene that can be presented with a keyboard shortcut.\n\nDiscussion\n\nA scene\u2019s keyboard shortcut is bound to the command it adds for creating new windows (in the case of WindowGroup and DocumentGroup) or bringing a singleton window forward (in the case of Window and, on macOS, Settings). Pressing the keyboard shortcut is equivalent to selecting the menu command.\n\nIn cases where a command already has a keyboard shortcut, the scene\u2019s keyboard shortcut is used instead. For example, WindowGroup normally creates a File > New Window menu command whose keyboard shortcut is \u2318N. The following code changes it to \u2325\u2318N:\n\nWindowGroup {\n    ContentView()\n}\n.keyboardShortcut(\"n\", modifiers: [.option, .command])\n\nLocalization\n\nProvide a localization value to specify how this shortcut should be localized.\n\nGiven that key is always defined in relation to the US-English keyboard layout, it might be hard to reach on different international layouts. For example the shortcut \u2318[ works well for the US layout but is hard to reach for German users, where [ is available by pressing \u23255, making users type \u2325\u23185. The automatic keyboard shortcut remapping re-assigns the shortcut to an appropriate replacement, \u2318\u00d6 in this case.\n\nProviding the option custom disables the automatic localization for this shortcut to tell the system that internationalization is taken care of in a different way.\n\nSee Also\nSetting commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nfunc keyboardShortcut(KeyboardShortcut?) -> some Scene\nDefines a keyboard shortcut for opening new scene windows."
    },
    {
        "title": "accessibilityRotor(_:entries:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:)-3bf9k",
        "html": "Parameters\nlabel\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nContent used to generate Rotor entries. This can include AccessibilityRotorEntry structs, as well as constructs such as if and ForEach.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Identifiable` `Message`s.\n\n\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\") {\n    // Not all the MessageViews are generated at once, the model knows\n    // about all the messages.\n    ForEach(messages) { message in\n        // If the Message is from a VIP, make a Rotor entry for it.\n        if message.isVIP {\n            AccessibilityRotorEntry(message.subject, id: message.id)\n        }\n    }\n}\n\nSee Also\nCreating rotors\nfunc accessibilityRotor<Content>(LocalizedStringKey, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<L, Content>(L, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nprotocol AccessibilityRotorContent\nContent within an accessibility rotor.\nstruct AccessibilityRotorContentBuilder\nResult builder you use to generate rotor entry content.\nstruct AccessibilityRotorEntry\nA struct representing an entry in an Accessibility Rotor."
    },
    {
        "title": "keyboardShortcut(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/keyboardshortcut(_:)",
        "html": "Parameters\nshortcut\n\nThe keyboard shortcut for presenting the scene, or nil.\n\nReturn Value\n\nA scene that can be presented with a keyboard shortcut.\n\nDiscussion\n\nA scene\u2019s keyboard shortcut is bound to the command it adds for creating new windows (in the case of WindowGroup and DocumentGroup) or bringing a singleton window forward (in the case of Window and, on macOS, Settings). Pressing the keyboard shortcut is equivalent to selecting the menu command.\n\nIn cases where a command already has a keyboard shortcut, the scene\u2019s keyboard shortcut is used instead. For example, WindowGroup normally creates a File > New Window menu command whose keyboard shortcut is \u2318N. The following code changes it to something based on dynamic state:\n\n@main\nstruct Notes: App {\n    @State private var newWindowShortcut: KeyboardShortcut? = ...\n\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView($newWindowShortcut)\n        }\n        .keyboardShortcut(newWindowShortcut)\n    }\n}\n\n\nIf shortcut is nil, the scene\u2019s presentation command will not be associated with a keyboard shortcut, even if SwiftUI normally assigns one automatically.\n\nSee Also\nSetting commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some Scene\nDefines a keyboard shortcut for opening new scene windows."
    },
    {
        "title": "wrappedValue",
        "url": "https://developer.apple.com/documentation/swiftui/wkextensiondelegateadaptor/wrappedvalue",
        "html": "See Also\nGetting the delegate adaptor\nvar projectedValue: ObservedObject<DelegateType>.Wrapper\nA projection of the observed object that provides bindings to its properties.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to WKExtensionDelegate."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/wkextensiondelegateadaptor/init(_:)-3tcpl",
        "html": "Parameters\ndelegateType\n\nThe type of extension delegate that you define in your app, which conforms to the WKExtensionDelegate and Observable protocols.\n\nDiscussion\n\nCall this initializer indirectly by creating a property with the WKExtensionDelegateAdaptor property wrapper from inside your App declaration:\n\n@main\nstruct MyApp: App {\n    @WKExtensionDelegateAdaptor private var extensionDelegate: MyExtensionDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI initializes the delegate and manages its lifetime, calling it as needed to handle extension delegate callbacks.\n\nSwiftUI invokes this method when your app delegate conforms to the Observable protocol. In this case, SwiftUI automatically places the delegate in the Environment. You can access such a delegate from any scene or view in your app using the Environment property wrapper:\n\n@Environment(MyAppDelegate.self) private var appDelegate\n\n\nIf your delegate isn\u2019t observable, SwiftUI invokes the init(_:) initializer rather than this one, and doesn\u2019t put the delegate instance in the environment.\n\nSee Also\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor.\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor using a delegate that\u2019s an observable object.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to WKExtensionDelegate."
    },
    {
        "title": "window",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextrastyle/window",
        "html": "Discussion\n\nThe styling and layout of controls is similar to that when contained in a normal window, compared to the menu-like layout that the menu style provides.\n\nSee Also\nGetting menu bar extra styles\nstatic var automatic: AutomaticMenuBarExtraStyle\nThe default menu bar extra style.\nAvailable when Self is AutomaticMenuBarExtraStyle.\nstatic var menu: PullDownMenuBarExtraStyle\nA menu bar extra style that renders its contents as a menu that pulls down from the icon in the menu bar.\nAvailable when Self is PullDownMenuBarExtraStyle."
    },
    {
        "title": "digitalCrownRotation(_:onChange:onIdle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/digitalcrownrotation(_:onchange:onidle:)",
        "html": "Parameters\nbinding\n\nA binding to a value that updates as the user rotates the Digital Crown. The implicit range is (-infinity, +infinity).\n\nonChange\n\nA block that is called as the Digital Crown is rotated.\n\nonIdle\n\nA block that is called when the Digital Crown has settled to an idle state.\n\nDiscussion\n\nUse this method to receive values on a binding you provide as the user turns the Digital Crown on Apple Watch. The example below receives changes to the binding value, starting at 0.0 and incrementing or decrementing depending on the direction that the user turns the Digital Crown:\n\nstruct DigitalCrown: View {\n    @State private var crownValue = 0.0\n\n\n    var body: some View {\n        Text(\"Received Value:\\(crownValue, specifier: \"%.1f\")\")\n            .focusable()\n            .digitalCrownRotation($crownValue)\n    }\n}\n\n\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "handlesExternalEvents(matching:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/handlesexternalevents(matching:)",
        "html": "Parameters\nmatching\n\nA Set of Strings that are checked to see if they are contained in the targetContentIdenfifier. The empty Set and empty Strings never match. The String value \u201c*\u201d always matches.\n\nDiscussion\n\nThis modifier is only supported for WindowGroup Scene types.\n\nFor DocumentGroups, the received External Event must have a URL for the DocumentGroup to be considered. (Either via openURL, or the webPageURL property of an NSUserActivity). The UTI for the URL is implicitly matched against the DocumentGroup\u2019s supported types.\n\nIf the modifier evaluates to true, an instance of the Scene will be used.\n\nIf the modifier evaluates to false, on macOS the Scene will not be used even if no other Scenes are available. This case is considered an error. On iOS, the first Scene specified in the body property for the App will be used.\n\nIf no modifier is set, the Scene will be used if all other WindowGroups with a modifier evaluate to false.\n\nOn platforms that only allow a single Window/Scene, this method is ignored.\n\nSee Also\nWatching for changes\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> some Scene\nAdds an action to perform when the given value changes.\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> some Scene\nAdds an action to perform when the given value changes."
    },
    {
        "title": "ScenePhase.active",
        "url": "https://developer.apple.com/documentation/swiftui/scenephase/active",
        "html": "Discussion\n\nAn active scene isn\u2019t necessarily front-most. For example, a macOS window might be active even if it doesn\u2019t currently have focus. Nevertheless, all scenes should operate normally in this phase.\n\nAn app or custom scene in this phase contains at least one active scene instance.\n\nSee Also\nGetting scene phases\ncase inactive\nThe scene is in the foreground but should pause its work.\ncase background\nThe scene isn\u2019t currently visible in the UI."
    },
    {
        "title": "init(placement:content:label:)",
        "url": "https://developer.apple.com/documentation/swiftui/toolbaritemgroup/init(placement:content:label:)",
        "html": "Parameters\nplacement\n\nWhich section of the toolbar the item should be placed in.\n\ncontent\n\nThe content of the item.\n\nlabel\n\nThe label describing the content of the item.\n\nDiscussion\n\nA toolbar item group provided a label wraps its content within a ControlGroup which allows the content to collapse down into a menu that presents its content based on available space.\n\nSee Also\nCreating a toolbar item group\ninit(placement: ToolbarItemPlacement, content: () -> Content)\nCreates a toolbar item group with a specified placement and content."
    },
    {
        "title": "AutomaticMenuBarExtraStyle",
        "url": "https://developer.apple.com/documentation/swiftui/automaticmenubarextrastyle",
        "html": "Topics\nCreating the menu bar extra style\ninit()\nCreates an automatic menu bar extra style.\nRelationships\nConforms To\nMenuBarExtraStyle\nSee Also\nSupporting types\nstruct PullDownMenuBarExtraStyle\nA menu bar extra style that renders its contents as a menu that pulls down from the icon in the menu bar.\nstruct WindowMenuBarExtraStyle\nA menu bar extra style that renders its contents in a popover-like window."
    },
    {
        "title": "digitalCrownAccessory(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/digitalcrownaccessory(content:)",
        "html": "Parameters\ncontent\n\nThe view to be used as a Digital Crown Accessory.\n\nDiscussion\n\nUse this method to place a custom View next to the Digital Crown on Apple Watch. Use digitalCrownAccessory(_:) to specify the visibility of your custom view.\n\nstruct ZoomingMapView: View {\n    // Width of the map displayed on screen in miles\n    @State private var zoomLevel: Int = 1.0\n\n\n    var body: some View {\n        CustomMap(width: .miles(zoomLevel))\n            .focusable()\n            .digitalCrownRotation(value: $zoomLevel)\n            .digitalCrownAccessory {\n                Text(\"\\(zoomLevel, specifier: \"%.2f\")MI\")\n                .background {\n                    RoundedRectangle(cornerRadius: 5)\n                        .fill(Color.gray)\n                }\n            }\n    }\n}\n\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "automatic",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextrastyle/automatic",
        "html": "See Also\nGetting menu bar extra styles\nstatic var menu: PullDownMenuBarExtraStyle\nA menu bar extra style that renders its contents as a menu that pulls down from the icon in the menu bar.\nAvailable when Self is PullDownMenuBarExtraStyle.\nstatic var window: WindowMenuBarExtraStyle\nA menu bar extra style that renders its contents in a popover-like window.\nAvailable when Self is WindowMenuBarExtraStyle."
    },
    {
        "title": "MenuStyleConfiguration.Content",
        "url": "https://developer.apple.com/documentation/swiftui/menustyleconfiguration/content",
        "html": "Relationships\nConforms To\nView\nSee Also\nSetting the label and content\nstruct Label\nA type-erased label of a menu."
    },
    {
        "title": "buildBlock(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "init(controller:category:)",
        "url": "https://developer.apple.com/documentation/swiftui/wknotificationscene/init(controller:category:)",
        "html": "Parameters\ncontroller\n\nThe type of WKUserNotificationHostingController to display upon receipt of the specified notification category.\n\ncategory\n\nThe category of notifications to listen for.\n\nDiscussion\n\nUse a watch notification instance to add support for one or more Apple Watch notification scenes that appear on receipt of the local or remote notification categories you specify. The example below, adds two notification scenes to the app declaration:\n\n@main\nstruct PopQuizApp : App {\n    var body: some Scene {\n        MainScene {\n            RootView()\n        }\n\n\n        WKNotificationScene(\n            controller: QuizTimeController.self,\n            category: \"com.example.quiztime\"\n        )\n\n\n        WKNotificationScene(\n            controller: QuizResultsController.self,\n            category: \"com.example.results\"\n        )\n    }\n}\n\n\nEach WKNotificationScene declaration references a WKUserNotificationHostingController and a category string that you provide. The hosting controller displays your notification\u2019s content view upon receipt of a local or a PushKit notification. The category string you specify corresponds to the category name in the notification\u2019s dictionary and describes a specific notification that contains the content displayed by the notification view."
    },
    {
        "title": "init(placement:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/toolbaritemgroup/init(placement:content:)",
        "html": "Discussion\n\nplacement: Which section of the toolbar all of its vended ToolbarItems should be placed in.\n\ncontent: The content of the group. Each view specified in the ViewBuilder will be given its own ToolbarItem in the toolbar.\n\nSee Also\nCreating a toolbar item group\ninit<C, L>(placement: ToolbarItemPlacement, content: () -> C, label: () -> L)\nCreates a toolbar item group with the specified placement, content, and a label describing that content.\nAvailable when Content conforms to View."
    },
    {
        "title": "ScrollView",
        "url": "https://developer.apple.com/documentation/swiftui/scrollview",
        "html": "Overview\n\nThe scroll view displays its content within the scrollable content region. As the user performs platform-appropriate scroll gestures, the scroll view adjusts what portion of the underlying content is visible. ScrollView can scroll horizontally, vertically, or both, but does not provide zooming functionality.\n\nIn the following example, a ScrollView allows the user to scroll through a VStack containing 100 Text views. The image after the listing shows the scroll view\u2019s temporarily visible scrollbar at the right; you can disable it with the showsIndicators parameter of the ScrollView initializer.\n\nvar body: some View {\n    ScrollView {\n        VStack(alignment: .leading) {\n            ForEach(0..<100) {\n                Text(\"Row \\($0)\")\n            }\n        }\n    }\n}\n\n\nControlling Scroll Position\n\nYou can influence where a scroll view is initially scrolled by using the defaultScrollAnchor(_:) view modifier.\n\nProvide a value of `UnitPoint/center`` to have the scroll view start in the center of its content when a scroll view is scrollable in both axes.\n\nScrollView([.horizontal, .vertical]) {\n    // initially centered content\n}\n.defaultScrollAnchor(.center)\n\n\nOr provide an alignment of `UnitPoint/bottom`` to have the scroll view start at the bottom of its content when a scroll view is scrollable in its vertical axes.\n\nScrollView {\n    // initially bottom aligned content\n}\n.defaultScrollAnchor(.bottom)\n\n\nAfter the scroll view initially renders, the user may scroll the content of the scroll view.\n\nTo perform programmatic scrolling, wrap one or more scroll views with a ScrollViewReader.\n\nTopics\nCreating a scroll view\ninit(Axis.Set, showsIndicators: Bool, content: () -> Content)\nCreates a new instance that\u2019s scrollable in the direction of the given axis and can show indicators while scrolling.\ninit(Axis.Set, content: () -> Content)\nCreates a new instance that\u2019s scrollable in the direction of the given axis and can show indicators while scrolling.\nAvailable when Content conforms to View.\nConfiguring a scroll view\nvar content: Content\nThe scroll view\u2019s content.\nvar axes: Axis.Set\nThe scrollable axes of the scroll view.\nvar showsIndicators: Bool\nA value that indicates whether the scroll view displays the scrollable component of the content offset, in a way that\u2019s suitable for the platform.\nSupporting types\nvar body: some View\nThe content and behavior of the scroll view.\nRelationships\nConforms To\nView\nSee Also\nCreating a scroll view\nstruct ScrollViewReader\nA view that provides programmatic scrolling, by working with a proxy to scroll to known child views.\nstruct ScrollViewProxy\nA proxy value that supports programmatic scrolling of the scrollable views within a view hierarchy."
    },
    {
        "title": "digitalCrownAccessory(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/digitalcrownaccessory(_:)",
        "html": "Parameters\nvisibility\n\nThe visibility of the digital crown accessory.\n\nDiscussion\n\nUse this method to customize the visibility of a Digital Crown accessory View created with the View/digitalCrownAccessory(_ content:) modifier. You may want to keep an accessory visible even when the Digital Crown Indicator is not visible to indicate what scrolling the crown will do.\n\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/wkextensiondelegateadaptor/init(_:)-2btqx",
        "html": "Parameters\ndelegateType\n\nThe type of extension delegate that you define in your app, which conforms to the WKExtensionDelegate and ObservableObject protocols.\n\nDiscussion\n\nCall this initializer indirectly by creating a property with the WKExtensionDelegateAdaptor property wrapper from inside your App declaration:\n\n@main\nstruct MyApp: App {\n    @WKExtensionDelegateAdaptor private var extensionDelegate: MyExtensionDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI initializes the delegate and manages its lifetime, calling it as needed to handle extension delegate callbacks.\n\nSwiftUI invokes this method when your extension delegate conforms to the ObservableObject protocol. In this case, SwiftUI automatically places the delegate in the Environment. You can access such a delegate from any scene or view in your app using the EnvironmentObject property wrapper:\n\n@EnvironmentObject private var appDelegate: MyAppDelegate\n\n\nIf your delegate isn\u2019t an observable object, SwiftUI invokes the init(_:) initializer rather than this one, and doesn\u2019t put the delegate instance in the environment.\n\nSee Also\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor.\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor using an observable delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to Observable, and DelegateType conforms to WKExtensionDelegate."
    },
    {
        "title": "contentShape(_:_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contentshape(_:_:eofill:)",
        "html": "Parameters\nkind\n\nThe kinds to apply to this content shape.\n\nshape\n\nThe shape to use.\n\neoFill\n\nA Boolean that indicates whether the shape is interpreted with the even-odd winding number rule.\n\nReturn Value\n\nA view that uses the given shape for the specified kind.\n\nDiscussion\n\nThe content shape has a variety of uses. You can control the kind of the content shape by specifying one in kind. For example, the following example only sets the focus ring shape of the view, without affecting its shape for hit-testing:\n\nMyFocusableView()\n    .contentShape(.focusEffect, Circle())\n\nSee Also\nControlling hit testing\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nfunc contentShape<S>(S, eoFill: Bool) -> some View\nDefines the content shape for hit testing.\nstruct ContentShapeKinds\nA kind for the content shape of a view."
    },
    {
        "title": "init(_:image:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:isinserted:content:)-2vnz2",
        "html": "Parameters\ntitle\n\nThe string to use for the accessibility label of the item.\n\nimage\n\nThe image resource to use as the label.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\n\nSee Also\nCreating a menu bar extra with an image resource\ninit(LocalizedStringKey, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "MoveCommandDirection",
        "url": "https://developer.apple.com/documentation/swiftui/movecommanddirection",
        "html": "Topics\nGetting move command directions\ncase up\ncase down\ncase left\ncase right\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nResponding to commands\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector."
    },
    {
        "title": "init(_:image:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:isinserted:content:)-1bubh",
        "html": "Parameters\ntitleKey\n\nThe localized string key to use for the accessibility label of the item.\n\nimage\n\nThe image resource to use as the label.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\n\nSee Also\nCreating a menu bar extra with an image resource\ninit(LocalizedStringKey, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "init(_:systemImage:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:systemimage:isinserted:content:)-rwmi",
        "html": "Parameters\ntitle\n\nThe string to use for the accessibility label of the item.\n\nsystemImage\n\nThe name of a system image to use as the label.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\n\nSee Also\nCreating a menu bar extra with a system image\ninit(LocalizedStringKey, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "init(_:image:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:content:)-40xc3",
        "html": "Parameters\ntitle\n\nThe string to use for the accessibility label of the item.\n\nimage\n\nThe image resource to use as the label.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item defines the primary scene of an App.\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra with an image resource\ninit(LocalizedStringKey, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "init(_:image:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:content:)-42l33",
        "html": "Parameters\ntitleKey\n\nThe localized string key to use for the accessibility label of the item.\n\nimage\n\nThe image resource to use as the label.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item defines the primary scene of an App.\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra with an image resource\ninit(LocalizedStringKey, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "init(_:systemImage:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:systemimage:isinserted:content:)-1qg20",
        "html": "Parameters\ntitleKey\n\nThe localized string key to use for the accessibility label of the item.\n\nsystemImage\n\nThe name of a system image to use as the label.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\n\nSee Also\nCreating a menu bar extra with a system image\ninit(LocalizedStringKey, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "onPlayPauseCommand(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onplaypausecommand(perform:)",
        "html": "See Also\nResponding to commands\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector.\nenum MoveCommandDirection\nSpecifies the direction of an arrow key movement."
    },
    {
        "title": "onChange(of:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onchange(of:perform:)",
        "html": "Deprecated\n\nUse onChange(of:initial:_:) or onChange(of:initial:_:) instead. The trailing closure in each case takes either zero or two input parameters, compared to this method which takes one.\n\nBe aware that the replacements have slightly different behvavior. This modifier\u2019s closure captures values that represent the state before the change. The new modifiers capture values that correspond to the new state. The new behavior makes it easier to perform updates that rely on values other than the one that caused the modifier\u2019s closure to run.\n\nDiscussion\n\nUse this modifier to trigger a side effect when a value changes, like the value associated with an Environment value or a Binding. For example, you can clear a cache when you notice that a scene moves to the background:\n\nstruct MyScene: Scene {\n    @Environment(\\.scenePhase) private var scenePhase\n    @StateObject private var cache = DataCache()\n\n\n    var body: some Scene {\n        WindowGroup {\n            MyRootView()\n        }\n        .onChange(of: scenePhase) { newScenePhase in\n            if newScenePhase == .background {\n                cache.empty()\n            }\n        }\n    }\n}\n\n\nThe system may call the action closure on the main actor, so avoid long-running tasks in the closure. If you need to perform such tasks, detach an asynchronous background task:\n\n.onChange(of: scenePhase) { newScenePhase in\n    if newScenePhase == .background {\n        Task.detached(priority: .background) {\n            // ...\n        }\n    }\n}\n\n\nThe system passes the new value into the closure. If you need the old value, capture it in the closure.\n\nSee Also\nInput and events modifiers\nfunc onTapGesture(count: Int, coordinateSpace: CoordinateSpace, perform: (CGPoint) -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture, and provides the action with the location of the interaction.\nDeprecated\nfunc onLongPressGesture(minimumDuration: Double, maximumDistance: CGFloat, pressing: ((Bool) -> Void)?, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nDeprecated\nfunc onLongPressGesture(minimumDuration: Double, pressing: ((Bool) -> Void)?, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nDeprecated\nfunc onPasteCommand(of: [String], perform: ([NSItemProvider]) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command.\nDeprecated\nfunc onPasteCommand<Payload>(of: [String], validator: ([NSItemProvider]) -> Payload?, perform: (Payload) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command with items that you validate.\nDeprecated\nfunc onDrop(of: [String], delegate: DropDelegate) -> some View\nDefines the destination for a drag and drop operation with the same size and position as this view, with behavior controlled by the given delegate.\nDeprecated\nfunc onDrop(of: [String], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination for a drag and drop operation, using the same size and position as this view, handling dropped content with the given closure.\nDeprecated\nfunc onDrop(of: [String], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination for a drag and drop operation with the same size and position as this view, handling dropped content and the drop location with the given closure.\nDeprecated\nfunc focusable(Bool, onFocusChange: (Bool) -> Void) -> some View\nSpecifies if the view is focusable and, if so, adds an action to perform when the view comes into focus.\nDeprecated\nfunc onContinuousHover(coordinateSpace: CoordinateSpace, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nDeprecated"
    },
    {
        "title": "init(_:image:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:isinserted:content:)-1qwnu",
        "html": "Parameters\ntitleKey\n\nThe localized string key to use for the accessibility label of the item.\n\nimage\n\nThe name of an image in the app\u2019s bundle to use as the label.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\n\nSee Also\nCreating a menu bar extra with a named image\ninit(LocalizedStringKey, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "onCommand(_:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/oncommand(_:perform:)",
        "html": "Parameters\nselector\n\nThe selector to register for action.\n\naction\n\nThe action to perform. If action is nil, command keeps its association with this view but doesn\u2019t trigger.\n\nReturn Value\n\nA view that triggers action when the command occurs.\n\nDiscussion\n\nThis view or one of the views it contains must be in focus in order for the action to trigger. Other actions for the same command on views closer to the view in focus take priority, potentially overriding this action.\n\nSee Also\nResponding to commands\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nenum MoveCommandDirection\nSpecifies the direction of an arrow key movement."
    },
    {
        "title": "init(_:systemImage:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:systemimage:content:)-1vdub",
        "html": "Parameters\ntitleKey\n\nThe localized string key to use for the accessibility label of the item.\n\nsystemImage\n\nThe name of a system image to use as the label.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item defines the primary scene of an App.\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra with a system image\ninit(LocalizedStringKey, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "init(_:image:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:content:)-1n53m",
        "html": "Parameters\ntitleKey\n\nThe localized string key to use for the accessibility label of the item.\n\nimage\n\nThe name of an image in the app\u2019s bundle to use as the label.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item defines the primary scene of an App.\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra with a named image\ninit(LocalizedStringKey, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "init(_:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:content:)-8wn1q",
        "html": "Parameters\ntitle\n\nThe string to use for the label of the item. as a Menu.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The extra defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a menu bar extra that will be displayed in the system menu bar, and defines the primary scene of an App.\ninit(LocalizedStringKey, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit(isInserted: Binding<Bool>, content: () -> Content, label: () -> Label)\nCreates a menu bar extra. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false."
    },
    {
        "title": "init(_:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:content:)-82t24",
        "html": "Parameters\ntitle\n\nThe string to use for the title of the group.\n\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group. The system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSee Also\nCreating a window group\ninit(content: () -> Content)\nCreates a window group.\ninit(Text, content: () -> Content)\nCreates a window group with a text view title.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a window group with a localized title string."
    },
    {
        "title": "init(_:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:isinserted:content:)-8zpg3",
        "html": "Parameters\ntitle\n\nThe string to use for the label of the item.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nSee Also\nCreating a menu bar extra\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The extra defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a menu bar extra that will be displayed in the system menu bar, and defines the primary scene of an App.\ninit(LocalizedStringKey, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit(isInserted: Binding<Bool>, content: () -> Content, label: () -> Label)\nCreates a menu bar extra. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false."
    },
    {
        "title": "init(_:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:content:)-ulz4",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the group\u2019s title.\n\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the specified content as a template to create each window in the group. The system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nSee Also\nCreating a window group\ninit(content: () -> Content)\nCreates a window group.\ninit(Text, content: () -> Content)\nCreates a window group with a text view title.\ninit<S>(S, content: () -> Content)\nCreates a window group with a title string."
    },
    {
        "title": "init(_:image:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:image:content:)-2qdmd",
        "html": "Parameters\ntitle\n\nThe string to use for the accessibility label of the item.\n\nimage\n\nThe name of an image in the app\u2019s bundle to use as the label.\n\ncontent\n\nA View to display when the user selects the item.\n\nDiscussion\n\nThe item defines the primary scene of an App.\n\nWhen this item is removed from the system menu bar by the user, the application will be automatically quit. As such, it should not be used in conjunction with other scene types in your App.\n\nSee Also\nCreating a menu bar extra with a named image\ninit(LocalizedStringKey, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View."
    },
    {
        "title": "init(id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(id:content:)",
        "html": "Parameters\nid\n\nA string that uniquely identifies the window group. Identifiers must be unique among the window groups in your app.\n\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the given view as a template to form the content of each window in the group.\n\nSee Also\nIdentifying a window group\ninit(Text, id: String, content: () -> Content)\nCreates a window group with a text view title and an identifier.\ninit(LocalizedStringKey, id: String, content: () -> Content)\nCreates a window group with a localized title string and an identifier.\ninit<S>(S, id: String, content: () -> Content)\nCreates a window group with a title string and an identifier."
    },
    {
        "title": "init(isInserted:content:label:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(isinserted:content:label:)",
        "html": "Parameters\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nlabel\n\nA View to use as the label in the system menu bar.\n\nSee Also\nCreating a menu bar extra\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The extra defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a menu bar extra that will be displayed in the system menu bar, and defines the primary scene of an App.\ninit(LocalizedStringKey, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View."
    },
    {
        "title": "init(_:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(_:content:)-6ptoo",
        "html": "Parameters\ntitle\n\nThe Text view to use for the group\u2019s title.\n\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the given view as a template to form the content of each window in the group. The system uses the title to distinguish the window group in the user interface, such as in the name of commands associated with the group.\n\nImportant\n\nThe system ignores any text styling that you apply to the Text view title, like bold or italics. However, you can use the formatting controls that the view offers, like for localization, dates, and numerical representations.\n\nSee Also\nCreating a window group\ninit(content: () -> Content)\nCreates a window group.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a window group with a localized title string.\ninit<S>(S, content: () -> Content)\nCreates a window group with a title string."
    },
    {
        "title": "init(_:isInserted:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra/init(_:isinserted:content:)-6t4ml",
        "html": "Parameters\ntitleKey\n\nThe title key to use for the label of the item.\n\nisInserted\n\nWhether the item is inserted in the menu bar. The item may or may not be visible, depending on the number of items present.\n\ncontent\n\nA View to display when the user selects the item.\n\nSee Also\nCreating a menu bar extra\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The extra defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a menu bar extra that will be displayed in the system menu bar, and defines the primary scene of an App.\ninit<S>(S, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit(isInserted: Binding<Bool>, content: () -> Content, label: () -> Label)\nCreates a menu bar extra. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false."
    },
    {
        "title": "init(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup/init(content:)",
        "html": "Parameters\ncontent\n\nA closure that creates the content for each instance of the group.\n\nDiscussion\n\nThe window group uses the given view as a template to form the content of each window in the group.\n\nSee Also\nCreating a window group\ninit(Text, content: () -> Content)\nCreates a window group with a text view title.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a window group with a localized title string.\ninit<S>(S, content: () -> Content)\nCreates a window group with a title string."
    },
    {
        "title": "submitLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/submitlabel(_:)",
        "html": "Parameters\nsubmitLabel\n\nOne of the cases specified in SubmitLabel.\n\nDiscussion\nForm {\n    TextField(\"Username\", $viewModel.username)\n        .submitLabel(.continue)\n    SecureField(\"Password\", $viewModel.password)\n        .submitLabel(.done)\n}\n\nSee Also\nLabeling a submission event\nstruct SubmitLabel\nA semantic label describing the label of submission within a view hierarchy."
    },
    {
        "title": "ScenePhase.background",
        "url": "https://developer.apple.com/documentation/swiftui/scenephase/background",
        "html": "Discussion\n\nDo as little as possible in a scene that\u2019s in the background phase. The background phase can precede termination, so do any cleanup work immediately upon entering this state. For example, close any open files and network connections. However, a scene can also return to the ScenePhase.active phase from the background.\n\nExpect an app that enters the background phase to terminate.\n\nSee Also\nGetting scene phases\ncase active\nThe scene is in the foreground and interactive.\ncase inactive\nThe scene is in the foreground but should pause its work."
    },
    {
        "title": "ProgressViewStyleConfiguration.CurrentValueLabel",
        "url": "https://developer.apple.com/documentation/swiftui/progressviewstyleconfiguration/currentvaluelabel-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the current value label\nvar currentValueLabel: ProgressViewStyleConfiguration.CurrentValueLabel?\nA view that describes the current value of a progress view."
    },
    {
        "title": "AccessibilityRotorEntry",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityrotorentry",
        "html": "Overview\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nAn entry in a Rotor may contain a label to identify the entry to the user, and identifier used to determine which Accessibility element the Rotor entry should navigate to, as well as an optional range used for entries that navigate to a specific position in the text of their associated Accessibility element. An entry can also specify a handler to be called before the entry is navigated to, to do any manual work needed to bring the Accessibility element on-screen.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Identifiable` `Message`s.\n\n\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\") {\n    // Not all the `MessageView`s are generated at once, but the model\n    // knows about all the messages.\n    ForEach(messages) { message in\n        // If the Message is from a VIP, make a Rotor entry for it.\n        if message.isVIP {\n            AccessibilityRotorEntry(message.subject, id: message.id)\n        }\n    }\n}\n\n\nAn entry may also be created using an optional namespace, for situations where there are multiple Accessibility elements within a ForEach iteration or where a ScrollView is not present. In this case, the prepare closure may be needed in order to scroll the element into position using ScrollViewReader. The same namespace should be passed to calls to accessibilityRotorEntry(id:in:) to tag the Accessibility elements associated with this entry.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs. The Rotor entries are associated with the content text of the message, which is one of the two views within the ForEach that generate Accessibility elements. That view is tagged with accessibilityRotorEntry(id:in:) so that it can be found by the AccessibilityRotorEntry, and ScrollViewReader is used with the prepare closure to scroll it into position.\n\nstruct MessageListView: View {\n    @Namespace var namespace\n\n\n    var body: some View {\n        ScrollViewReader { scroller in\n             ScrollView {\n                LazyVStack {\n                    ForEach(allMessages) { message in\n                        VStack {\n                            Text(message.subject)\n                            // Tag this `Text` as an element associated\n                            // with a Rotor entry.\n                            Text(message.content)\n                                .accessibilityRotorEntry(\n                                    \"\\(message.id)_content\",\n                                    in: namespace\n                                )\n                        }\n                    }\n                }\n            }\n            .accessibilityElement(children: .contain)\n            .accessibilityRotor(\"VIP Messages\") {\n                ForEach(vipMessages) { vipMessage in\n                    // The Rotor entry points to a specific ID we\n                    // defined within a given `ForEach` iteration,\n                    // not to the entire `ForEach` iteration.\n                    AccessibilityRotorEntry(vipMessage.subject,\n                        id: \"\\(vipMessage.id)_content\", in: namespace)\n                    {\n                        // But the ID we give to `ScrollViewReader`\n                        // matches the one used in the `ForEach`, which\n                        // is the identifier for the whole iteration\n                        // and what `ScrollViewReader` requires.\n                        scroller.scrollTo(vipMessage.id)\n                    }\n                }\n            }\n        }\n    }\n}\n\nTopics\nCreating a rotor entry\ninit(LocalizedStringKey, textRange: Range<String.Index>, prepare: (() -> Void))\nCreate a Rotor entry with a specific label and range. This Rotor entry will be associated with the Accessibility element that owns the Rotor.\ninit<L>(L, textRange: Range<String.Index>, prepare: (() -> Void))\nCreate a Rotor entry with a specific label and range. This Rotor entry will be associated with the Accessibility element that owns the Rotor.\ninit(Text?, textRange: Range<String.Index>, prepare: (() -> Void))\nCreate a Rotor entry with a specific label and range. This Rotor entry will be associated with the Accessibility element that owns the Rotor.\nCreating a rotor entry with an identifier\ninit(LocalizedStringKey, id: ID, textRange: Range<String.Index>?, prepare: (() -> Void))\nCreate a Rotor entry with a specific label and identifier, with an optional range.\ninit<L>(L, id: ID, textRange: Range<String.Index>?, prepare: (() -> Void))\nCreate a Rotor entry with a specific label and identifier, with an optional range.\ninit(Text, id: ID, textRange: Range<String.Index>?, prepare: (() -> Void))\nCreate a Rotor entry with a specific label and identifier, with an optional range.\nCreating an identified rotor entry in a namespace\ninit(LocalizedStringKey, id: ID, in: Namespace.ID, textRange: Range<String.Index>?, prepare: (() -> Void))\nCreate a Rotor entry with a specific label, identifier and namespace, and with an optional range.\ninit<L>(L, ID, in: Namespace.ID, textRange: Range<String.Index>?, prepare: (() -> Void))\nCreate a Rotor entry with a specific label, identifier and namespace, and with an optional range.\ninit(Text, id: ID, in: Namespace.ID, textRange: Range<String.Index>?, prepare: (() -> Void))\nCreate a Rotor entry with a specific label, identifier and namespace, and with an optional range.\nRelationships\nConforms To\nAccessibilityRotorContent\nConforms when ID conforms to Hashable.\nSee Also\nCreating rotors\nfunc accessibilityRotor<Content>(LocalizedStringKey, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<Content>(Text, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<L, Content>(L, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nprotocol AccessibilityRotorContent\nContent within an accessibility rotor.\nAvailable when ID conforms to Hashable.\nstruct AccessibilityRotorContentBuilder\nResult builder you use to generate rotor entry content."
    },
    {
        "title": "keyboardShortcut(_:modifiers:localization:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/keyboardshortcut(_:modifiers:localization:)",
        "html": "Discussion\n\nPressing the control\u2019s shortcut while the control is anywhere in the frontmost window or scene, or anywhere in the macOS main menu, is equivalent to direct interaction with the control to perform its primary action.\n\nThe target of a keyboard shortcut is resolved in a leading-to-trailing, depth-first traversal of one or more view hierarchies. On macOS, the system looks in the key window first, then the main window, and then the command groups; on other platforms, the system looks in the active scene, and then the command groups.\n\nIf multiple controls are associated with the same shortcut, the first one found is used.\n\nLocalization\n\nProvide a localization value to specify how this shortcut should be localized. Given that key is always defined in relation to the US-English keyboard layout, it might be hard to reach on different international layouts. For example the shortcut \u2318[ works well for the US layout but is hard to reach for German users, where [ is available by pressing \u23255, making users type \u2325\u23185. The automatic keyboard shortcut remapping re-assigns the shortcut to an appropriate replacement, \u2318\u00d6 in this case.\n\nCertain shortcuts carry information about directionality. For instance, \u2318[ can reveal a previous view. Following the layout direction of the UI, this shortcut will be automatically mirrored to \u2318]. However, this does not apply to items such as \u201cAlign Left \u2318{\u201d, which will be \u201cleft\u201d independently of the layout direction. When the shortcut shouldn\u2019t follow the directionality of the UI, but rather be the same in both right-to-left and left-to-right directions, using withoutMirroring will prevent the system from flipping it.\n\nvar body: some Commands {\n    CommandMenu(\"Card\") {\n        Button(\"Align Left\") { ... }\n            .keyboardShortcut(\"{\",\n                 modifiers: .option,\n                 localization: .withoutMirroring)\n        Button(\"Align Right\") { ... }\n            .keyboardShortcut(\"}\",\n                 modifiers: .option,\n                 localization: .withoutMirroring)\n    }\n}\n\n\nLastly, providing the option custom disables the automatic localization for this shortcut to tell the system that internationalization is taken care of in a different way.\n\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture."
    },
    {
        "title": "accessibilityRotor(_:entries:entryID:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entryid:entrylabel:)-4qsb1",
        "html": "Parameters\nlabelKey\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nAn array of values that will be used to generate the entries of the Rotor.\n\nentryID\n\nKey path on the entry type that can be used to generate an identifier for the Entry. The identifiers must match up with identifiers in ForEach or explicit id calls within the ScrollView.\n\nentryLabel\n\nKey path on the entry type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Message`s that have a `subject` and a\n// `uuid`. `vipMesages` is a filtered version of that list\n// containing only messages from VIPs.\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\", entries: vipMessages,\n    entryID: \\.uuid, entryLabel: \\.subject)\n\nSee Also\nCreating rotors from a collection\nfunc accessibilityRotor<EntryModel, ID>(Text, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel, ID>(L, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries."
    },
    {
        "title": "touchBarItemPrincipal(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/touchbaritemprincipal(_:)",
        "html": "Parameters\nprincipal\n\nA Boolean value that indicates whether to display this view prominently in the Touch Bar compared to other views.\n\nReturn Value\n\nA Touch Bar view with one element centered in the Touch Bar row.\n\nDiscussion\n\nUse touchBarItemPrincipal(_:) to designate a view as a significant view in the Touch Bar. Currently, that view will be placed in the center of the row.\n\nThe example below sets the last button as the principal button for the Touch Bar view.\n\nlet touchBarItems = TouchBar(id: \"myBarItems\") {\n    Button(\"\u2663\ufe0f\", action: {})\n    Button(\"\u2665\ufe0f\", action: {})\n    Button(\"\u2660\ufe0f\", action: {})\n    Button(\"\u2666\ufe0f\", action: {})\n       .touchBarItemPrincipal(true)\n}\n\n\nTextField(\"TouchBar Demo\", text: $placeholder)\n    .frame(maxWidth: .infinity, maxHeight: .infinity)\n    .focusable()\n    .touchBar(touchBarItems)\n\n\nNote\n\nMultiple visible bars may each specify a principal view, but the system only honors one of them.\n\nSee Also\nManaging Touch Bar input\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nstruct TouchBar\nA container for a view that you can show in the Touch Bar.\nenum TouchBarItemPresence\nOptions that affect user customization of the Touch Bar."
    },
    {
        "title": "accessibilityRotor(_:entries:entryID:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entryid:entrylabel:)-7r302",
        "html": "Parameters\nsystemRotor\n\nThe system-provided Rotor that will be overridden by this custom Rotor.\n\nentries\n\nAn array of values that will be used to generate the entries of the Rotor.\n\nentryID\n\nKey path on the entry type that can be used to generate an identifier for the Entry. The identifiers must match up with identifiers in ForEach or explicit id calls within the ScrollView.\n\nentryLabel\n\nKey path on the entry type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to the headings in its vertical stack of messages.\n\n// `messageListItems` is a list of `MessageListItem`s\n// that are either a `Message` or a heading, containing a `subject`\n// and a `uuid`.\n// `headingMessageListItems` is a filtered list of\n// `messageListItems` containing just the headings.\nScrollView {\n    LazyVStack {\n        ForEach(messageListItems) { messageListItem in\n            switch messageListItem {\n                case .heading(let subject):\n                    Text(subject)\n                case .message(let message):\n                    MessageView(message)\n            }\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\n    .heading, entries: headingMessageListItems,\n    entryID: \\.uuid, label: \\.subject\n)\n\nSee Also\nReplacing system rotors\nfunc accessibilityRotor<Content>(AccessibilitySystemRotor, entries: () -> Content) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel>(AccessibilitySystemRotor, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor(AccessibilitySystemRotor, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nstruct AccessibilitySystemRotor\nDesignates a Rotor that replaces one of the automatic, system-provided Rotors with a developer-provided Rotor."
    },
    {
        "title": "accessibilityRotor(_:entries:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:)-1g128",
        "html": "Parameters\nsystemRotor\n\nThe system-provided Rotor that will be overridden by this custom Rotor.\n\nentries\n\nContent used to generate Rotor entries. This can include AccessibilityRotorEntry structs, as well as constructs such as if and ForEach.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements. Replacing system Rotors this way is useful when the System Rotor does not automatically pick up elements that aren\u2019t on-screen, such as elements far down in a LazyVStack or List.\n\nIn the following example, a Message application adds a Rotor allowing the user to navigate through all the ranges of text containing headings.\n\nextension Message {\n    // Ranges of special areas in the `content` text. Calculated\n    // when `content` is set and then cached so that we don't have\n    // to re-compute them.\n    var contentHeadingRanges: [Range<String.Index>]\n}\n\n\nstruct MessageContentView: View {\n    TextEditor(.constant(message.content))\n        .accessibilityRotor(.heading) {\n            ForEach(range in message.contentHeadingRanges) {\n                AccessibilityRotorEntry(textRange: range)\n            }\n        }\n}\n\nSee Also\nReplacing system rotors\nfunc accessibilityRotor<EntryModel, ID>(AccessibilitySystemRotor, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel>(AccessibilitySystemRotor, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor(AccessibilitySystemRotor, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nstruct AccessibilitySystemRotor\nDesignates a Rotor that replaces one of the automatic, system-provided Rotors with a developer-provided Rotor."
    },
    {
        "title": "accessibilityRotor(_:textRanges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:textranges:)-53aet",
        "html": "Parameters\nlabel\n\nLocalized label identifying this Rotor to the user.\n\ntextRanges\n\nAn array of ranges that will be used to generate the entries of the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nIn the following example, a Message application adds a Rotor allowing the user to navigate through all the ranges of text containing email addresses.\n\nextension Message {\n    // Ranges of special areas in the `content` text. Calculated\n    // when `content` is set and then cached so that we don't have\n    // to re-compute them.\n    var emailAddressRanges: [Range<String.Index>]\n}\n\n\nstruct MessageContentView: View {\n    TextEditor(.constant(message.content))\n        .accessibilityRotor(\"Email Addresses\",\n            textRanges: message.emailAddressRanges)\n}\n\nSee Also\nCreating rotors for text ranges\nfunc accessibilityRotor(LocalizedStringKey, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nfunc accessibilityRotor(Text, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element."
    },
    {
        "title": "accessibilityRotor(_:entries:entryID:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entryid:entrylabel:)-36wol",
        "html": "Parameters\nrotorLabel\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nAn array of values that will be used to generate the entries of the Rotor.\n\nentryID\n\nKey path on the entry type that can be used to generate an identifier for the Entry. The identifiers must match up with identifiers in ForEach or explicit id calls within the ScrollView.\n\nentryLabel\n\nKey path on the entry type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Message`s that have a `subject` and a\n// `uuid`. `vipMessages` is a filtered version of that list\n// containing only messages from VIPs.\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\", entries: vipMessages,\n    id: \\.uuid, label: \\.subject)\n\nSee Also\nCreating rotors from a collection\nfunc accessibilityRotor<EntryModel, ID>(LocalizedStringKey, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel, ID>(L, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries."
    },
    {
        "title": "digitalCrownRotation(detent:from:through:by:sensitivity:isContinuous:isHapticFeedbackEnabled:onChange:onIdle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/digitalcrownrotation(detent:from:through:by:sensitivity:iscontinuous:ishapticfeedbackenabled:onchange:onidle:)-9ad6y",
        "html": "Parameters\nbinding\n\nA binding to a value that updates when the user rotates the Digital Crown.\n\nminValue\n\nLower end of the range reported.\n\nmaxValue\n\nUpper end of the range reported.\n\nstride\n\nThe value settles on multiples of stride.\n\nsensitivity\n\nHow much the user needs to rotate the Digital Crown to move between two integer numbers.\n\nisContinuous\n\nControls if the value reported stops at minValue and maxValue, or if it should wrap around. Default is false.\n\nisHapticFeedbackEnabled\n\nControls the generation of haptic feedback when turning the Digital Crown. Default is true.\n\nonChange\n\nA block that is called as the Digital Crown is rotated.\n\nonIdle\n\nA block that is called when the Digital Crown has settled to an idle state.\n\nDiscussion\n\nUse this method to receive values on a binding you provides as the user turns the Digital Crown on Apple Watch. The example below receives changes to the binding value, starting at the minValue of 0 up to the maxValue of 100 in steps of 1 incrementing or decrementing depending on the direction that the user turns the Digital Crown, rolling over if the user exceeds the specified boundary values. The binding will always be updated to a value that is a multiple of the stride that is provided:\n\nstruct DigitalCrown: View {\n    @State private var crownValue = 0.0\n    @State private var selected = 0\n    @State private var minValue = 0\n    @State private var maxValue = 100\n    @State private var stepAmount = 1\n    @State private var velocity = 0.0\n    @State private var isIdle = true\n\n\n    var body: some View {\n        Text(\"Received Value:\\(crownValue, specifier: \"%.2f\")\")\n            .focusable()\n            .digitalCrownRotation(detent: $selected,\n                                  from: minValue,\n                                  through: maxValue,\n                                  by: stepAmount,\n                                  sensitivity: .low,\n                                  isContinuous: true\n            ) { crownEvent in\n                isIdle = false\n                crownValue = crownEvent.offset\n                velocity = crownEvent.velocity\n            } onIdle: {\n                isIdle = true\n            }\n    }\n}\n\n\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "accessibilityRotor(_:entries:entryID:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entryid:entrylabel:)-6qqy6",
        "html": "Parameters\nrotorLabel\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nAn array of values that will be used to generate the entries of the Rotor.\n\nentryID\n\nKey path on the entry type that can be used to generate an identifier for the Entry. The identifiers must match up with identifiers in ForEach or explicit id calls within the ScrollView.\n\nentryLabel\n\nKey path on the entry type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs. // messages is a list of Messages that have a subject and a // uuid. vipMessages is a filtered version of that list // containing only messages from VIPs. ScrollView { LazyVStack { ForEach(messages) { message in MessageView(message) } } } .accessibilityElement(children: .contain) .accessibilityRotor(\u201cVIPs\u201d, entries: vipMessages, id: .uuid, label: .subject)\n\nSee Also\nCreating rotors from a collection\nfunc accessibilityRotor<EntryModel, ID>(LocalizedStringKey, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<EntryModel, ID>(Text, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries."
    },
    {
        "title": "touchBarItemPresence(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/touchbaritempresence(_:)",
        "html": "Parameters\npresence\n\nOne of the allowed TouchBarItemPresence descriptions.\n\nReturn Value\n\nA trait that describes the behavior for this Touch Bar view.\n\nDiscussion\n\nUse touchBarItemPresence(_:) to define the visibility requirements of a particular Touch Bar view during customization by the user.\n\nTouch Bar views may be:\n\n.required: not allowed to be removed by the user.\n\n.default: shown by default prior to user customization, but removable.\n\n.optional: not visible by default, but can be added through the customization palette.\n\nEach TouchBarItemPresence must be initialized with a string that is a globally unique identifier for this item.\n\nIn the example below, all of the Touch Bar items are visible in the Touch Bar by default, except for the \u201cClubs\u201d item. It\u2019s set to .optional but is configurable by the user:\n\nTextField(\"TouchBar Demo\", text: $placeholder)\n    .frame(maxWidth: .infinity, maxHeight: .infinity)\n    .focusable()\n    .touchBar {\n        Button(\"\u2665\ufe0f\", action: selectHearts)\n            .touchBarItemPresence(.required(\"heartsKey\"))\n        Button(\"\u2663\ufe0f\", action: selectClubs)\n            .touchBarItemPresence(.optional(\"clubsKey\"))\n        Button(\"\u2660\ufe0f\", action: selectSpades)\n            .touchBarItemPresence(.required(\"spadesKey\"))\n        Button(\"\u2666\ufe0f\", action: selectDiamonds)\n            .touchBarItemPresence(.required(\"diamondsKey\"))\n}\n\n\nSee Also\nManaging Touch Bar input\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nstruct TouchBar\nA container for a view that you can show in the Touch Bar.\nenum TouchBarItemPresence\nOptions that affect user customization of the Touch Bar."
    },
    {
        "title": "accessibilityRotor(_:textRanges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:textranges:)-4njdd",
        "html": "Parameters\nlabel\n\nLocalized label identifying this Rotor to the user.\n\ntextRanges\n\nAn array of ranges that will be used to generate the entries of the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nIn the following example, a Message application adds a Rotor allowing the user to navigate through all the ranges of text containing email addresses.\n\nextension Message {\n    // Ranges of special areas in the `content` text. Calculated\n    // when `content` is set and then cached so that we don't have\n    // to re-compute them.\n    var emailAddressRanges: [Range<String.Index>]\n}\n\n\nstruct MessageContentView: View {\n    TextEditor(.constant(message.content))\n        .accessibilityRotor(\"Email Addresses\",\n            textRanges: message.emailAddressRanges)\n}\n\nSee Also\nCreating rotors for text ranges\nfunc accessibilityRotor(LocalizedStringKey, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nfunc accessibilityRotor<L>(L, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element."
    },
    {
        "title": "offset",
        "url": "https://developer.apple.com/documentation/swiftui/offsetshape/offset",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar shape: Content"
    },
    {
        "title": "accessibilityLinkedGroup(id:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitylinkedgroup(id:in:)",
        "html": "Parameters\nid\n\nA hashable identifier used to separate sets of linked elements within the same namespace. Elements with matching namespace and id will be linked together.\n\nnamespace\n\nThe namespace to use to organize linked accessibility elements. All elements marked with accessibilityLink in this namespace and with the specified id will be linked together.\n\nDiscussion\n\nThis can be useful to allow quickly jumping between content in a list and the same content shown in a detail view, for example. All elements marked with accessibilityLinkedGroup with the same namespace and identifier will be linked together.\n\nSee Also\nConfiguring rotors\nfunc accessibilityRotorEntry<ID>(id: ID, in: Namespace.ID) -> some View\nDefines an explicit identifier tying an Accessibility element for this view to an entry in an Accessibility Rotor.\nfunc accessibilitySortPriority(Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the sort priority order for this view\u2019s accessibility element, relative to other elements at the same level."
    },
    {
        "title": "DigitalCrownRotationalSensitivity",
        "url": "https://developer.apple.com/documentation/swiftui/digitalcrownrotationalsensitivity",
        "html": "Overview\n\nYou may need to experiment to find the level of sensitivity that works for your use case.\n\nTopics\nGetting sensitivity options\ncase low\nLow sensitivity.\ncase medium\nMedium sensitivity.\ncase high\nHigh sensitivity.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown."
    },
    {
        "title": "digitalCrownRotation(detent:from:through:by:sensitivity:isContinuous:isHapticFeedbackEnabled:onChange:onIdle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/digitalcrownrotation(detent:from:through:by:sensitivity:iscontinuous:ishapticfeedbackenabled:onchange:onidle:)-17066",
        "html": "Parameters\ndetent\n\nA binding to a value that updates when the user rotates the Digital Crown.\n\nminValue\n\nLower end of the range reported.\n\nmaxValue\n\nUpper end of the range reported.\n\nstride\n\nThe value settles on multiples of stride.\n\nsensitivity\n\nHow much the user needs to rotate the Digital Crown to move between two detents.\n\nisContinuous\n\nControls if the value reported stops at minValue and maxValue, or if it should wrap around. Default is false.\n\nisHapticFeedbackEnabled\n\nControls the generation of haptic feedback when turning the Digital Crown. Default is true.\n\nonChange\n\nA block that is called as the Digital Crown is rotated.\n\nonIdle\n\nA block that is called when the Digital Crown has settled to an idle state.\n\nDiscussion\n\nUse this method to receive values on a binding you provide as the user turns the Digital Crown on Apple Watch. The example below receives changes to the binding value, starting at the minValue of 0.0 up to the maxValue of 10.0 in steps of 0.1 incrementing or decrementing depending on the direction that the user turns the Digital Crown, rolling over if the user exceeds the specified boundary values. The binding will always be updated to a value that is a multiple of the stride that is provided:\n\nstruct DigitalCrown: View {\n    @State private var crownValue = 0.0\n    @State private var selected = 0.0\n    @State private var minValue = 0.0\n    @State private var maxValue = 10.0\n    @State private var stepAmount = 0.1\n    @State private var velocity = 0.0\n    @State private var isIdle = true\n\n\n    var body: some View {\n        Text(\"Received Value:\\(crownValue, specifier: \"%.2f\")\")\n            .focusable()\n            .digitalCrownRotation(detent: $selected,\n                                  from: minValue,\n                                  through: maxValue,\n                                  by: stepAmount,\n                                  sensitivity: .low,\n                                  isContinuous: true\n            ) { crownEvent in\n                isIdle = false\n                crownValue = crownEvent.offset\n                velocity = crownEvent.velocity\n            } onIdle: {\n                isIdle = true\n            }\n    }\n}\n\n\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "touchBarCustomizationLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/touchbarcustomizationlabel(_:)",
        "html": "Parameters\nlabel\n\nA Text view containing the customization label.\n\nReturn Value\n\nA Touch Bar element with a set customization label.\n\nDiscussion\n\nThis string is visible during user customization.\n\nTextField(\"TouchBar Demo\", text: $placeholder)\n    .frame(maxWidth: .infinity, maxHeight: .infinity)\n    .focusable()\n    .touchBar {\n        Button(\"\u2665\ufe0f\", action: selectHearts)\n            .touchBarCustomizationLabel(Text(\"Hearts\"))\n        Button(\"\u2663\ufe0f\", action: selectClubs)\n            .touchBarCustomizationLabel(Text(\"Clubs\"))\n        Button(\"\u2660\ufe0f\", action: selectSpades)\n            .touchBarCustomizationLabel(Text(\"Spades\"))\n        Button(\"\u2666\ufe0f\", action: selectDiamonds)\n            .touchBarCustomizationLabel(Text(\"Diamonds\"))\n    }\n\n\nSee Also\nManaging Touch Bar input\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nstruct TouchBar\nA container for a view that you can show in the Touch Bar.\nenum TouchBarItemPresence\nOptions that affect user customization of the Touch Bar."
    },
    {
        "title": "accessibilitySortPriority(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitysortpriority(_:)",
        "html": "Discussion\n\nHigher numbers are sorted first. The default sort priority is zero.\n\nSee Also\nConfiguring rotors\nfunc accessibilityRotorEntry<ID>(id: ID, in: Namespace.ID) -> some View\nDefines an explicit identifier tying an Accessibility element for this view to an entry in an Accessibility Rotor.\nfunc accessibilityLinkedGroup<ID>(id: ID, in: Namespace.ID) -> some View\nLinks multiple accessibility elements so that the user can quickly navigate from one element to another, even when the elements are not near each other in the accessibility hierarchy."
    },
    {
        "title": "MenuStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/menustyleconfiguration/label",
        "html": "Relationships\nConforms To\nView\nSee Also\nSetting the label and content\nstruct Content\nA type-erased content of a menu."
    },
    {
        "title": "accessibilityRotorEntry(id:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotorentry(id:in:)",
        "html": "Parameters\nid\n\nAn arbitrary hashable identifier. Pass this same value when initializing an AccessibilityRotorEntry.\n\nnamespace\n\nA namespace created with @Namespace(). Pass this same namespace when initializing an AccessibilityRotorEntry.\n\nDiscussion\n\nUse this when creating an AccessibilityRotorEntry without a namespace does not allow SwiftUI to automatically find and reveal the element, or when the Rotor entry should be associated with a sub-element of a complex view generated in a ForEach, for example.\n\nSee Also\nConfiguring rotors\nfunc accessibilityLinkedGroup<ID>(id: ID, in: Namespace.ID) -> some View\nLinks multiple accessibility elements so that the user can quickly navigate from one element to another, even when the elements are not near each other in the accessibility hierarchy.\nfunc accessibilitySortPriority(Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the sort priority order for this view\u2019s accessibility element, relative to other elements at the same level."
    },
    {
        "title": "touchBar(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/touchbar(content:)",
        "html": "Parameters\ncontent\n\nA collection of views to be displayed by the Touch Bar.\n\nReturn Value\n\nA view that contains the Touch Bar content.\n\nDiscussion\n\nUse touchBar(_:) when you need to dynamically construct items to show in the Touch Bar. The content is displayed by the Touch Bar when appropriate, depending on focus.\n\nIn the example below, four buttons are added to a Touch Bar content struct and then added to the Touch Bar:\n\nlet touchBarItems = TouchBar(id: \"myBarItems\") {\n    Button(\"\u2663\ufe0f\", action: {})\n    Button(\"\u2665\ufe0f\", action: {})\n    Button(\"\u2660\ufe0f\", action: {})\n    Button(\"\u2666\ufe0f\", action: {})\n}\n\n\nTextField(\"TouchBar Demo\", text: $placeholder)\n    .frame(maxWidth: .infinity, maxHeight: .infinity)\n    .focusable()\n    .touchBar(touchBarItems)\n\n\nSee Also\nManaging Touch Bar input\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nstruct TouchBar\nA container for a view that you can show in the Touch Bar.\nenum TouchBarItemPresence\nOptions that affect user customization of the Touch Bar."
    },
    {
        "title": "accessibilityRotor(_:textRanges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:textranges:)-fbkg",
        "html": "Parameters\nlabelKey\n\nLocalized label identifying this Rotor to the user.\n\ntextRanges\n\nAn array of ranges that will be used to generate the entries of the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nIn the following example, a Message application adds a Rotor allowing the user to navigate through all the ranges of text containing email addresses.\n\nextension Message {\n    // Ranges of special areas in the `content` text. Calculated\n    // when `content` is set and then cached so that we don't have\n    // to re-compute them.\n    var emailAddressRanges: [Range<String.Index>]\n}\n\n\nstruct MessageContentView: View {\n    TextEditor(.constant(message.content))\n        .accessibilityRotor(\"Email Addresses\",\n            textRanges: message.emailAddressRanges)\n}\n\nSee Also\nCreating rotors for text ranges\nfunc accessibilityRotor(Text, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nfunc accessibilityRotor<L>(L, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element."
    },
    {
        "title": "touchBar(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/touchbar(_:)",
        "html": "Parameters\ntouchBar\n\nA collection of views that the Touch Bar displays.\n\nReturn Value\n\nA view that contains the Touch Bar content.\n\nDiscussion\n\nUse touchBar(_:) to provide a static set of views that are displayed by the Touch Bar when appropriate, depending on whether the view has focus.\n\nThe example below provides Touch Bar content in-line, that creates the content the Touch Bar displays:\n\nfunc selectHearts() {/* ... */ }\nfunc selectClubs() { /* ... */ }\nfunc selectSpades() { /* ... */ }\nfunc selectDiamonds() { /* ... */ }\n\n\nTextField(\"TouchBar Demo\", text: $placeholder)\n    .frame(maxWidth: .infinity, maxHeight: .infinity)\n    .focusable()\n    .touchBar {\n        Button(\"\u2665\ufe0f - Hearts\", action: selectHearts)\n        Button(\"\u2663\ufe0f - Clubs\", action: selectClubs)\n        Button(\"\u2660\ufe0f - Spades\", action: selectSpades)\n        Button(\"\u2666\ufe0f - Diamonds\", action: selectDiamonds)\n    }\n\n\nSee Also\nManaging Touch Bar input\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nstruct TouchBar\nA container for a view that you can show in the Touch Bar.\nenum TouchBarItemPresence\nOptions that affect user customization of the Touch Bar."
    },
    {
        "title": "GaugeStyleConfiguration.MarkedValueLabel",
        "url": "https://developer.apple.com/documentation/swiftui/gaugestyleconfiguration/markedvaluelabel",
        "html": "Relationships\nConforms To\nView\nSee Also\nSetting the value\nvar value: Double\nThe current value of the gauge.\nvar currentValueLabel: GaugeStyleConfiguration.CurrentValueLabel?\nA view that describes the current value.\nstruct CurrentValueLabel\nA type-erased value label of a gauge that contains the current value."
    },
    {
        "title": "PullDownMenuBarExtraStyle",
        "url": "https://developer.apple.com/documentation/swiftui/pulldownmenubarextrastyle",
        "html": "Overview\n\nUse menu to construct this style.\n\nTopics\nCreating the menu bar extra style\ninit()\nCreates a pull down menu bar extra style.\nRelationships\nConforms To\nMenuBarExtraStyle\nSee Also\nSupporting types\nstruct AutomaticMenuBarExtraStyle\nThe default menu bar extra style. You can also use automatic to construct this style.\nstruct WindowMenuBarExtraStyle\nA menu bar extra style that renders its contents in a popover-like window."
    },
    {
        "title": "GaugeStyleConfiguration.MinimumValueLabel",
        "url": "https://developer.apple.com/documentation/swiftui/gaugestyleconfiguration/minimumvaluelabel-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nReporting the range\nvar minimumValueLabel: GaugeStyleConfiguration.MinimumValueLabel?\nA view that describes the minimum of the range for the current value.\nvar maximumValueLabel: GaugeStyleConfiguration.MaximumValueLabel?\nA view that describes the maximum of the range for the current value.\nstruct MaximumValueLabel\nA type-erased value label of a gauge describing the maximum value."
    },
    {
        "title": "modelContext(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/modelcontext(_:)",
        "html": "Parameters\nmodelContext\n\nThe model context to set in this scene\u2019s environment.\n\nDiscussion\n\nIn this example, RecipesApp sets a shared model context to use for all of its windows:\n\n@Model class Recipe { ... }\n\n\n@main\nstruct RecipesApp: App {\n    var body: some Scene {\n        WindowGroup {\n            RecipesList()\n        }\n        .modelContext(myContext)\n    }\n}\n\n\nThe environment\u2019s modelContext property will be assigned a myContext. All implicit model context operations in this scene, such as Query properties, will use the environment\u2019s context.\n\nSee Also\nConfiguring a data model\nfunc modelContainer(ModelContainer) -> some Scene\nSets the model container and associated model context in this scene\u2019s environment.\nfunc modelContainer(for: [PersistentModel.Type], inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model types, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment.\nfunc modelContainer(for: PersistentModel.Type, inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model type, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment."
    },
    {
        "title": "menu",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextrastyle/menu",
        "html": "See Also\nGetting menu bar extra styles\nstatic var automatic: AutomaticMenuBarExtraStyle\nThe default menu bar extra style.\nAvailable when Self is AutomaticMenuBarExtraStyle.\nstatic var window: WindowMenuBarExtraStyle\nA menu bar extra style that renders its contents in a popover-like window.\nAvailable when Self is WindowMenuBarExtraStyle."
    },
    {
        "title": "buildBlock(_:_:_:_:_:_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:_:_:_:_:_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "buildBlock(_:_:_:_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:_:_:_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "buildBlock(_:_:_:_:_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:_:_:_:_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "buildExpression(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildexpression(_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "onChange(of:initial:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/onchange(of:initial:_:)-7b6vh",
        "html": "Parameters\nvalue\n\nThe value to check when determining whether to run the closure. The value must conform to the Equatable protocol.\n\ninitial\n\nWhether the action should be run when this scene initially appears.\n\naction\n\nA closure to run when the value changes.\n\nReturn Value\n\nA scene that triggers an action in response to a change.\n\nDiscussion\n\nUse this modifier to trigger a side effect when a value changes, like the value associated with an Environment key or a Binding. For example, you can clear a cache when you notice that a scene moves to the background:\n\nstruct MyScene: Scene {\n    @Environment(\\.locale) private var locale\n    @StateObject private var cache = LocalizationDataCache()\n\n\n    var body: some Scene {\n        WindowGroup {\n            MyRootView(cache: cache)\n        }\n        .onChange(of: locale) {\n            cache.empty()\n        }\n    }\n}\n\n\nThe system may call the action closure on the main actor, so avoid long-running tasks in the closure. If you need to perform such tasks, detach an asynchronous background task:\n\n.onChange(of: locale) {\n    Task.detached(priority: .background) {\n        // ...\n    }\n}\n\n\nWhen the value changes, the new version of the closure will be called, so any captured values will have their values from the time that the observed value has its new value.\n\nSee Also\nWatching for changes\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> some Scene\nAdds an action to perform when the given value changes.\nfunc handlesExternalEvents(matching: Set<String>) -> some Scene\nSpecifies a modifier to indicate if this Scene can be used when creating a new Scene for the received External Event."
    },
    {
        "title": "buildBlock(_:_:_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:_:_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "buildLimitedAvailability(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildlimitedavailability(_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "buildBlock(_:_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "buildOptional(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildoptional(_:)",
        "html": "Discussion\n\nConditional statements in a SceneBuilder can contain an if statement but not an else statement, and the condition can only perform a compiler check for availability, like in the following code:\n\nvar body: some Scene {\n    if #available(iOS 16, *) {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n\nSee Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check."
    },
    {
        "title": "buildBlock(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "fileURL",
        "url": "https://developer.apple.com/documentation/swiftui/documentconfiguration/fileurl",
        "html": "Discussion\n\nIf the document has never been saved, returns nil.\n\nSee Also\nGetting configuration values\nvar isEditable: Bool\nA Boolean value that indicates whether you can edit the document."
    },
    {
        "title": "onChange(of:initial:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/onchange(of:initial:_:)-7r9vn",
        "html": "Parameters\nvalue\n\nThe value to check when determining whether to run the closure. The value must conform to the Equatable protocol.\n\ninitial\n\nWhether the action should be run when this scene initially appears.\n\naction\n\nA closure to run when the value changes.\n\noldValue\n\nThe old value that failed the comparison check (or the initial value when requested).\n\nnewValue\n\nThe new value that failed the comparison check.\n\nReturn Value\n\nA scene that triggers an action in response to a change.\n\nDiscussion\n\nUse this modifier to trigger a side effect when a value changes, like the value associated with an Environment key or a Binding. For example, you can clear a cache when you notice that a scene moves to the background:\n\nstruct MyScene: Scene {\n    @Environment(\\.scenePhase) private var scenePhase\n    @StateObject private var cache = DataCache()\n\n\n    var body: some Scene {\n        WindowGroup {\n            MyRootView(cache: cache)\n        }\n        .onChange(of: scenePhase) { oldScenePhase, newScenePhase in\n            if newScenePhase == .background {\n                cache.empty()\n            }\n        }\n    }\n}\n\n\nThe system may call the action closure on the main actor, so avoid long-running tasks in the closure. If you need to perform such tasks, detach an asynchronous background task:\n\n.onChange(of: scenePhase) { oldScenePhase, newScenePhase in\n    if newScenePhase == .background {\n        Task.detached(priority: .background) {\n            // ...\n        }\n    }\n}\n\n\nWhen the value changes, the new version of the closure will be called, so any captured values will have their values from the time that the observed value has its new value. The system passes the old and new observed values into the closure.\n\nSee Also\nWatching for changes\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> some Scene\nAdds an action to perform when the given value changes.\nfunc handlesExternalEvents(matching: Set<String>) -> some Scene\nSpecifies a modifier to indicate if this Scene can be used when creating a new Scene for the received External Event."
    },
    {
        "title": "buildBlock(_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "buildBlock(_:_:_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder/buildblock(_:_:_:_:_:)",
        "html": "See Also\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true."
    },
    {
        "title": "body",
        "url": "https://developer.apple.com/documentation/swiftui/scene/body-swift.property",
        "html": "Required\n\nDiscussion\n\nFor any scene that you create, provide a computed body property that defines the scene as a composition of other scenes. You can assemble a scene from built-in scenes that SwiftUI provides, as well as other scenes that you\u2019ve defined.\n\nSwift infers the scene\u2019s Body associated type based on the contents of the body property.\n\nSee Also\nCreating a scene\nassociatedtype Body : Scene\nThe type of scene that represents the body of this scene.\n\nRequired"
    },
    {
        "title": "Body",
        "url": "https://developer.apple.com/documentation/swiftui/scene/body-swift.associatedtype",
        "html": "Required\n\nDiscussion\n\nWhen you create a custom scene, Swift infers this type from your implementation of the required body property.\n\nSee Also\nCreating a scene\nvar body: Self.Body\nThe content and behavior of the scene.\n\nRequired"
    },
    {
        "title": "defaultAppStorage(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultappstorage(_:)",
        "html": "Parameters\nstore\n\nThe user defaults to use as the default store for AppStorage.\n\nDiscussion\n\nIf unspecified, the default store for a view hierarchy is UserDefaults.standard, but can be set a to a custom one. For example, sharing defaults between an app and an extension can override the default store to one created with UserDefaults.init(suiteName:_)."
    },
    {
        "title": "isEditable",
        "url": "https://developer.apple.com/documentation/swiftui/documentconfiguration/iseditable",
        "html": "Discussion\n\nOn macOS, the document could be non-editable if the user lacks write permissions, the parent directory or volume is read-only, or the document couldn\u2019t be autosaved.\n\nOn iOS, the document is not editable if there was an error reading or saving it, there\u2019s an unresolved conflict, the document is being uploaded or downloaded, or otherwise, it is currently busy and unsafe for user edits.\n\nSee Also\nGetting configuration values\nvar fileURL: URL?\nA URL of an open document."
    },
    {
        "title": "contentShape(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contentshape(_:eofill:)",
        "html": "Parameters\nshape\n\nThe hit testing shape for the view.\n\neoFill\n\nA Boolean that indicates whether the shape is interpreted with the even-odd winding number rule.\n\nReturn Value\n\nA view that uses the given shape for hit testing.\n\nSee Also\nControlling hit testing\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nfunc contentShape<S>(ContentShapeKinds, S, eoFill: Bool) -> some View\nSets the content shape for this view.\nstruct ContentShapeKinds\nA kind for the content shape of a view."
    },
    {
        "title": "onExitCommand(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onexitcommand(perform:)",
        "html": "Discussion\n\nThe user generates an exit command by pressing the Menu button on tvOS, or the escape key on macOS.\n\nSee Also\nResponding to commands\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector.\nenum MoveCommandDirection\nSpecifies the direction of an arrow key movement."
    },
    {
        "title": "pageCommand(value:in:step:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/pagecommand(value:in:step:)",
        "html": "Parameters\nvalue\n\nA Binding to the value to modify when the user pages up or down.\n\nbounds\n\nA closed range that specifies the upper and lower bounds of value.\n\nstep\n\nThe amount by which to increment or decrement value. Defaults to 1.\n\nDiscussion\n\nUse this command to step through sections of a data model associated with a view by providing a binding to a value, a range, and step. If taking another step would cause the value to exceed the bounds, then the value remains unchanged.\n\nOn tvOS, the user triggers \u2018pageUp\u2019 and \u2018pageDown\u2019 commands by pressing a dedicated button on a connected remote. For example, you can let a user page through a TV programming guide using the channel buttons:\n\nstruct GuideView: View {\n    @State private var pageOffset: Int = 0\n\n\n    var body: some View {\n        GuideContent(at: pageOffset)\n            .pageCommand(\n                value: $pageOffset,\n                in: 0...9,\n                step: 1)\n    }\n}\n\nSee Also\nResponding to commands\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector.\nenum MoveCommandDirection\nSpecifies the direction of an arrow key movement."
    },
    {
        "title": "onDeleteCommand(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ondeletecommand(perform:)",
        "html": "See Also\nResponding to commands\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector.\nenum MoveCommandDirection\nSpecifies the direction of an arrow key movement."
    },
    {
        "title": "onKeyPress(_:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onkeypress(_:action:)",
        "html": "Parameters\nkey\n\nThe key to match against incoming hardware keyboard events.\n\naction\n\nThe action to perform. Return .handled to consume the event and prevent further dispatch, or .ignored to allow dispatch to continue.\n\nReturn Value\n\nA modified view that binds hardware keyboard input when focused.\n\nDiscussion\n\nSwiftUI performs the action for key-down and key-repeat events.\n\nSee Also\nResponding to keyboard input\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses any key on a hardware keyboard while the view has focus.\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nstruct KeyPress"
    },
    {
        "title": "onKeyPress(phases:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onkeypress(phases:action:)",
        "html": "Parameters\nphases\n\nThe key-press phases to match (.down, .repeat, and .up). The default value is [.down, .repeat].\n\naction\n\nThe action to perform. The action receives a value describing the matched key event. Return .handled to consume the event and prevent further dispatch, or .ignored to allow dispatch to continue.\n\nReturn Value\n\nA modified view that binds hardware keyboard input when focused.\n\nSee Also\nResponding to keyboard input\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nstruct KeyPress"
    },
    {
        "title": "onKeyPress(keys:phases:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onkeypress(keys:phases:action:)",
        "html": "Parameters\nkeys\n\nA set of keys to match against incoming hardware keyboard events.\n\nphases\n\nThe key-press phases to match (.down, .repeat, and .up). The default value is [.down, .repeat].\n\naction\n\nThe action to perform. The action receives a value describing the matched key event. Return .handled to consume the event and prevent further dispatch, or .ignored to allow dispatch to continue.\n\nReturn Value\n\nA modified view that binds keyboard input when focused.\n\nSee Also\nResponding to keyboard input\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses any key on a hardware keyboard while the view has focus.\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nstruct KeyPress"
    },
    {
        "title": "keyboardShortcut(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/keyboardshortcut(_:)-8liec",
        "html": "Discussion\n\nPressing the control\u2019s shortcut while the control is anywhere in the frontmost window or scene, or anywhere in the macOS main menu, is equivalent to direct interaction with the control to perform its primary action.\n\nThe target of a keyboard shortcut is resolved in a leading-to-trailing traversal of one or more view hierarchies. On macOS, the system looks in the key window first, then the main window, and then the command groups; on other platforms, the system looks in the active scene, and then the command groups.\n\nIf multiple controls are associated with the same shortcut, the first one found is used.\n\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture."
    },
    {
        "title": "keyboardShortcut(_:modifiers:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/keyboardshortcut(_:modifiers:)",
        "html": "Discussion\n\nPressing the control\u2019s shortcut while the control is anywhere in the frontmost window or scene, or anywhere in the macOS main menu, is equivalent to direct interaction with the control to perform its primary action.\n\nThe target of a keyboard shortcut is resolved in a leading-to-trailing, depth-first traversal of one or more view hierarchies. On macOS, the system looks in the key window first, then the main window, and then the command groups; on other platforms, the system looks in the active scene, and then the command groups.\n\nIf multiple controls are associated with the same shortcut, the first one found is used.\n\nThe default localization configuration is set to automatic.\n\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture."
    },
    {
        "title": "KeyEquivalent",
        "url": "https://developer.apple.com/documentation/swiftui/keyequivalent",
        "html": "Overview\n\nKey equivalents are used to establish keyboard shortcuts to app functionality. Any key can be used as a key equivalent as long as pressing it produces a single character value. Key equivalents are typically initialized using a single-character string literal, with constants for unprintable or hard-to-type values.\n\nThe modifier keys necessary to type a key equivalent are factored in to the resulting keyboard shortcut. That is, a key equivalent whose raw value is the capitalized string \u201cA\u201d corresponds with the keyboard shortcut Command-Shift-A. The exact mapping may depend on the keyboard layout\u2014for example, a key equivalent with the character value \u201c}\u201d produces a shortcut equivalent to Command-Shift-] on ANSI keyboards, but would produce a different shortcut for keyboard layouts where punctuation characters are in different locations.\n\nTopics\nGetting arrow keys\nstatic let upArrow: KeyEquivalent\nUp Arrow (U+F700)\nstatic let downArrow: KeyEquivalent\nDown Arrow (U+F701)\nstatic let leftArrow: KeyEquivalent\nLeft Arrow (U+F702)\nstatic let rightArrow: KeyEquivalent\nRight Arrow (U+F703)\nGetting other special keys\nstatic let clear: KeyEquivalent\nClear (U+F739)\nstatic let delete: KeyEquivalent\nDelete (U+0008)\nstatic let deleteForward: KeyEquivalent\nDelete Forward (U+F728)\nstatic let end: KeyEquivalent\nEnd (U+F72B)\nstatic let escape: KeyEquivalent\nEscape (U+001B)\nstatic let home: KeyEquivalent\nHome (U+F729)\nstatic let pageDown: KeyEquivalent\nPage Down (U+F72D)\nstatic let pageUp: KeyEquivalent\nPage Up (U+F72C)\nstatic let `return`: KeyEquivalent\nReturn (U+000D)\nstatic let space: KeyEquivalent\nSpace (U+0020)\nstatic let tab: KeyEquivalent\nTab (U+0009)\nCreating a key equivalent\ninit(Character)\nCreates a new key equivalent from the given character value.\nvar character: Character\nThe character value that the key equivalent represents.\nRelationships\nConforms To\nEquatable\nExpressibleByExtendedGraphemeClusterLiteral\nExpressibleByUnicodeScalarLiteral\nHashable\nSendable\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture."
    },
    {
        "title": "KeyboardShortcut",
        "url": "https://developer.apple.com/documentation/swiftui/keyboardshortcut",
        "html": "Topics\nGetting standard shortcuts\nstatic let cancelAction: KeyboardShortcut\nThe standard keyboard shortcut for cancelling the in-progress action or dismissing a prompt, consisting of the Escape (\u238b) key and no modifiers.\nstatic let defaultAction: KeyboardShortcut\nThe standard keyboard shortcut for the default button, consisting of the Return (\u21a9) key and no modifiers.\nCreating a shortcut\ninit(KeyEquivalent, modifiers: EventModifiers)\nCreates a new keyboard shortcut with the given key equivalent and set of modifier keys.\nvar key: KeyEquivalent\nThe key equivalent that the user presses in conjunction with any specified modifier keys to activate the shortcut.\nvar modifiers: EventModifiers\nThe modifier keys that the user presses in conjunction with a key equivalent to activate the shortcut.\nCreating a localized shortcut\ninit(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization)\nCreates a new keyboard shortcut with the given key equivalent and set of modifier keys.\nvar localization: KeyboardShortcut.Localization\nThe localization strategy to apply to this shortcut.\nstruct Localization\nOptions for how a keyboard shortcut participates in automatic localization.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture."
    },
    {
        "title": "onContinuousHover(coordinateSpace:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/oncontinuoushover(coordinatespace:perform:)-4ehfq",
        "html": "Parameters\ncoordinateSpace\n\nThe coordinate space for the location values. The default value is CoordinateSpace.local.\n\naction\n\nThe action to perform whenever the pointer enters, moves within, or exits the view\u2019s bounds. The closure takes a phase input that has the value HoverPhase.active(_:) and contains the pointer\u2019s coordinates if the pointer is within the view\u2019s bounds. The closure receives the HoverPhase.ended phase when the pointer leaves the view\u2019s bounds.\n\nReturn Value\n\nA view that calls action when the pointer enters, moves within, or exits the view\u2019s bounds.\n\nDiscussion\n\nUse this modifier to define a region for detecting pointer movement with a view. The following example updates a small rectangle\u2019s position and style by modifying hoverLocation and isHovering as the pointer moves within the larger, red rectangle:\n\n@State private var hoverLocation: CGPoint = .zero\n@State private var isHovering = false\n\n\nvar body: some View {\n    Color.red\n        .frame(width: 400, height: 400)\n        .onContinuousHover { phase in\n            switch phase {\n            case .active(let location):\n                hoverLocation = location\n                isHovering = true\n            case .ended:\n                isHovering = false\n            }\n        }\n        .overlay {\n            Rectangle()\n                .frame(width: 50, height: 50)\n                .foregroundStyle(isHovering ? .green : .blue)\n                .offset(x: hoverLocation.x, y: hoverLocation.y)\n        }\n}\n\nSee Also\nResponding to hover events\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed.\nenum HoverPhase\nThe current hovering state and value of the pointer."
    },
    {
        "title": "EventModifiers",
        "url": "https://developer.apple.com/documentation/swiftui/eventmodifiers",
        "html": "Topics\nGetting modifier keys\nstatic let all: EventModifiers\nAll possible modifier keys.\nstatic let capsLock: EventModifiers\nThe Caps Lock key.\nstatic let command: EventModifiers\nThe Command key.\nstatic let control: EventModifiers\nThe Control key.\nstatic let numericPad: EventModifiers\nAny key on the numeric keypad.\nstatic let option: EventModifiers\nThe Option key.\nstatic let shift: EventModifiers\nThe Shift key.\nCreating a set of options\ninit(rawValue: Int)\nCreates a new set from a raw value.\nlet rawValue: Int\nThe raw value.\nDeprecated modifiers\nstatic let function: EventModifiers\nThe Function key.\nDeprecated\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut."
    },
    {
        "title": "onHover(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onhover(perform:)",
        "html": "Parameters\naction\n\nThe action to perform whenever the pointer enters or exits this view\u2019s frame. If the pointer is in the view\u2019s frame, the action closure passes true as a parameter; otherwise, false.\n\nReturn Value\n\nA view that triggers action when the pointer enters or exits this view\u2019s frame.\n\nDiscussion\n\nCalling this method defines a region for detecting pointer movement with the size and position of this view.\n\nSee Also\nResponding to hover events\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed.\nenum HoverPhase\nThe current hovering state and value of the pointer."
    },
    {
        "title": "hoverEffectDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/hovereffectdisabled(_:)",
        "html": "Parameters\ndisabled\n\nA Boolean value that determines whether this view can display hover effects.\n\nReturn Value\n\nA view that controls whether hover effects can be displayed in this view.\n\nDiscussion\n\nThe higher views in a view hierarchy can override the value you set on this view. In the following example, the button does not display a hover effect because the outer hoverEffectDisabled(_:) modifier overrides the inner one:\n\nHStack {\n    Button(\"Press\") {}\n        .hoverEffectDisabled(false)\n}\n.hoverEffectDisabled(true)\n\nSee Also\nResponding to hover events\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed.\nenum HoverPhase\nThe current hovering state and value of the pointer."
    },
    {
        "title": "SearchUnavailableContent.Label",
        "url": "https://developer.apple.com/documentation/swiftui/searchunavailablecontent/label",
        "html": "Overview\n\nYou don\u2019t create this type directly. SwiftUI creates it when you build a searchContentUnavailableView.\n\nRelationships\nConforms To\nView\nSee Also\nGetting content types\nstruct Actions\nA view that represents the actions of a static ContentUnavailableView.search view.\nstruct Description\nA view that represents the description of a static ContentUnavailableView.search view."
    },
    {
        "title": "accessibilityRotor(_:entries:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entrylabel:)-9hhbs",
        "html": "Parameters\nrotorLabel\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nAn array of identifiable values that will be used to generate the entries of the Rotor. The identifiers of the Identifiable values must match up with identifiers in a ForEach or explicit id calls within the ScrollView. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nentryLabel\n\nKey path on the Identifiable type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Identifiable` `Message`s that have a\n// `subject`.\n// `vipMessages` is a filtered version of that list containing only\n// messages from VIPs.\n\n\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\", entries: vipMessages, label: \\.subject)\n\nSee Also\nCreating rotors with a label\nfunc accessibilityRotor<EntryModel>(LocalizedStringKey, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel>(L, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries."
    },
    {
        "title": "accessibilityRotor(_:entries:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entrylabel:)-5kis3",
        "html": "Parameters\nrotorLabelKey\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nAn array of identifiable values that will be used to generate the entries of the Rotor. The identifiers of the Identifiable values must match up with identifiers in a ForEach or explicit id calls within the ScrollView. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nentryLabel\n\nKey path on the Identifiable type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Identifiable` `Message`s that have a\n// `subject`.\n// `vipMessages` is a filtered version of that list containing only\n// messages from VIPs.\n\n\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\", entries: vipMessages,\n    entryLabel: \\.subject)\n\nSee Also\nCreating rotors with a label\nfunc accessibilityRotor<EntryModel>(Text, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel>(L, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries."
    },
    {
        "title": "accessibilityRotor(_:entries:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entrylabel:)-25lt5",
        "html": "Parameters\nrotorLabel\n\nLocalized label identifying this Rotor to the user.\n\nentries\n\nAn array of identifiable values that will be used to generate the entries of the Rotor. The identifiers of the Identifiable values must match up with identifiers in a ForEach or explicit id calls within the ScrollView. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nentry\n\nKey path on the Identifiable type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to specifically the messages originating from VIPs.\n\n// `messages` is a list of `Identifiable` `Message`s that have a\n// `subject`.\n// `vipMesages` is a filtered version of that list containing only\n// messages from VIPs.\n\n\nScrollView {\n    LazyVStack {\n        ForEach(messages) { message in\n            MessageView(message)\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\"VIPs\", entries: vipMessages, label: \\.subject)\n\nSee Also\nCreating rotors with a label\nfunc accessibilityRotor<EntryModel>(LocalizedStringKey, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<EntryModel>(Text, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries."
    },
    {
        "title": "accessibilityRotor(_:entries:entryLabel:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entrylabel:)-2jbai",
        "html": "Parameters\nsystemRotor\n\nThe system-provided Rotor that will be overridden by this custom Rotor.\n\nentries\n\nAn array of identifiable values that will be used to generate the entries of the Rotor. The identifiers of the Identifiable values must match up with identifiers in a ForEach or explicit id calls within the ScrollView. When the user navigates to entries from this Rotor, SwiftUI will automatically scroll them into place as needed.\n\nentryLabel\n\nKey path on the Identifiable type that can be used to get a user-visible label for every Rotor entry. This is used on macOS when the user opens the list of entries for the Rotor.\n\nDiscussion\n\nAn Accessibility Rotor is a shortcut for Accessibility users to quickly navigate to specific elements of the user interface, and optionally specific ranges of text within those elements.\n\nUsing this modifier requires that the Rotor be attached to a ScrollView, or an Accessibility Element directly within a ScrollView, such as a ForEach.\n\nIn the following example, a Message application creates a Rotor allowing users to navigate to the headings in its vertical stack of messages.\n\n// `messageListItems` is a list of `Identifiable` `MessageListItem`s\n// that are either a `Message` or a heading, containing a `subject`.\n// `headingMessageListItems` is a filtered list of\n// `messageListItems` containing just the headings.\nScrollView {\n    LazyVStack {\n        ForEach(messageListItems) { messageListItem in\n            switch messageListItem {\n                case .heading(let subject):\n                    Text(subject)\n                case .message(let message):\n                    MessageView(message)\n            }\n        }\n    }\n}\n.accessibilityElement(children: .contain)\n.accessibilityRotor(\n    .heading, entries: headingMessageListItems, label: \\.subject)\n\nSee Also\nReplacing system rotors\nfunc accessibilityRotor<Content>(AccessibilitySystemRotor, entries: () -> Content) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel, ID>(AccessibilitySystemRotor, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor(AccessibilitySystemRotor, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nstruct AccessibilitySystemRotor\nDesignates a Rotor that replaces one of the automatic, system-provided Rotors with a developer-provided Rotor."
    },
    {
        "title": "Chart view modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-chart-view",
        "html": "Overview\n\nUse these modifiers to configure a Chart view that you add to your SwiftUI app.\n\nTopics\nStyles\nfunc chartBackground<V>(alignment: Alignment, content: (ChartProxy) -> V) -> some View\nAdds a background to a view that contains a chart.\nfunc chartForegroundStyleScale<DataValue, S>(KeyValuePairs<DataValue, S>) -> some View\nConfigures the foreground style scale for charts.\nfunc chartForegroundStyleScale<Domain, Range>(domain: Domain, range: Range, type: ScaleType?) -> some View\nConfigures the foreground style scale for charts.\nfunc chartForegroundStyleScale<Domain>(domain: Domain, type: ScaleType?) -> some View\nConfigures the foreground style scale for charts.\nfunc chartForegroundStyleScale<Domain, S>(domain: Domain, mapping: (Domain.Element) -> S) -> some View\nConfigures the foreground style scale for charts.\nfunc chartForegroundStyleScale<DataValue, S>(mapping: (DataValue) -> S) -> some View\nConfigures the foreground style scale for charts.\nfunc chartForegroundStyleScale<Range>(range: Range, type: ScaleType?) -> some View\nConfigures the foreground style scale for charts.\nfunc chartForegroundStyleScale(type: ScaleType?) -> some View\nConfigures the foreground style scale for charts.\nfunc chartPlotStyle<Content>(content: (ChartPlotContent) -> Content) -> some View\nConfigures the plot area of charts.\nLegends\nfunc chartLegend(Visibility) -> some View\nConfigures the legend for charts.\nfunc chartLegend(position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?) -> some View\nConfigures the legend for charts.\nfunc chartLegend<Content>(position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?, content: () -> Content) -> some View\nConfigures the legend for charts.\nOverlays\nfunc chartOverlay<V>(alignment: Alignment, content: (ChartProxy) -> V) -> some View\nAdds an overlay to a view that contains a chart.\nAxes\nfunc chartXAxis(Visibility) -> some View\nSets the visibility of the x axis.\nfunc chartXAxis<Content>(content: () -> Content) -> some View\nConfigures the x-axis for charts in the view.\nfunc chartXAxisStyle<Content>(content: (ChartAxisContent) -> Content) -> some View\nConfigures the x axis content of charts.\nfunc chartYAxis(Visibility) -> some View\nSets the visibility of the y axis.\nfunc chartYAxis<Content>(content: () -> Content) -> some View\nConfigures the y-axis for charts in the view.\nfunc chartYAxisStyle<Content>(content: (ChartAxisContent) -> Content) -> some View\nConfigures the y axis content of charts.\nAxis Labels\nfunc chartXAxisLabel<S>(S, position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?) -> some View\nAdds x axis label for charts in the view.\nfunc chartXAxisLabel(LocalizedStringKey, position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?) -> some View\nAdds x axis label for charts in the view.\nfunc chartXAxisLabel<C>(position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?, content: () -> C) -> some View\nAdds x axis label for charts in the view.\nfunc chartYAxisLabel<S>(S, position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?) -> some View\nAdds y axis label for charts in the view.\nfunc chartYAxisLabel(LocalizedStringKey, position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?) -> some View\nAdds y axis label for charts in the view.\nfunc chartYAxisLabel<C>(position: AnnotationPosition, alignment: Alignment?, spacing: CGFloat?, content: () -> C) -> some View\nAdds y axis label for charts in the view.\nAxis scales\nfunc chartXScale<Domain, Range>(domain: Domain, range: Range, type: ScaleType?) -> some View\nConfigures the x scale for charts.\nfunc chartXScale<Domain>(domain: Domain, type: ScaleType?) -> some View\nConfigures the x scale for charts.\nfunc chartXScale<Range>(range: Range, type: ScaleType?) -> some View\nConfigures the x scale for charts.\nfunc chartXScale(type: ScaleType?) -> some View\nConfigures the x scale for charts.\nfunc chartYScale<Domain, Range>(domain: Domain, range: Range, type: ScaleType?) -> some View\nConfigures the y scale for charts.\nfunc chartYScale<Domain>(domain: Domain, type: ScaleType?) -> some View\nConfigures the y scale for charts.\nfunc chartYScale<Range>(range: Range, type: ScaleType?) -> some View\nConfigures the y scale for charts.\nfunc chartYScale(type: ScaleType?) -> some View\nConfigures the y scale for charts.\nSymbol scales\nfunc chartSymbolScale<DataValue, S>(KeyValuePairs<DataValue, S>) -> some View\nConfigures the symbol scale for charts.\nfunc chartSymbolScale<DataValue>(KeyValuePairs<DataValue, ChartSymbolShape>) -> some View\nConfigures the symbol scale for charts.\nfunc chartSymbolScale<Domain>(domain: Domain) -> some View\nConfigures the symbol style scale for charts.\nfunc chartSymbolScale<Domain, Range>(domain: Domain, range: Range) -> some View\nConfigures the symbol style scale for charts.\nfunc chartSymbolScale<Domain>(domain: Domain, range: [ChartSymbolShape]) -> some View\nConfigures the symbol style scale for charts.\nfunc chartSymbolScale<Domain, S>(domain: Domain, mapping: (Domain.Element) -> S) -> some View\nConfigures the symbol scale for charts.\nfunc chartSymbolScale<DataValue, S>(mapping: (DataValue) -> S) -> some View\nConfigures the symbol scale for charts.\nfunc chartSymbolScale(range: [ChartSymbolShape]) -> some View\nConfigures the symbol style scale for charts.\nfunc chartSymbolScale<Range>(range: Range) -> some View\nConfigures the symbol style scale for charts.\nSymbol size scales\nfunc chartSymbolSizeScale<DataValue>(KeyValuePairs<DataValue, CGFloat>) -> some View\nConfigures the symbol size scale for charts.\nfunc chartSymbolSizeScale<Domain, Range>(domain: Domain, range: Range, type: ScaleType?) -> some View\nConfigures the symbol size scale for charts.\nfunc chartSymbolSizeScale<Domain>(domain: Domain, type: ScaleType?) -> some View\nConfigures the symbol size scale for charts.\nfunc chartSymbolSizeScale<Domain>(domain: Domain, mapping: (Domain.Element) -> CGFloat) -> some View\nConfigures the symbol size scale for charts.\nfunc chartSymbolSizeScale<DataValue>(mapping: (DataValue) -> CGFloat) -> some View\nConfigures the symbol size scale for charts.\nfunc chartSymbolSizeScale<Range>(range: Range, type: ScaleType?) -> some View\nConfigures the symbol size scale for charts.\nfunc chartSymbolSizeScale(type: ScaleType?) -> some View\nConfigures the symbol size scale for charts.\nLine style scales\nfunc chartLineStyleScale<DataValue>(KeyValuePairs<DataValue, StrokeStyle>) -> some View\nConfigures the line style scale for charts.\nfunc chartLineStyleScale<Domain>(domain: Domain) -> some View\nConfigures the line style scale for charts.\nfunc chartLineStyleScale<Domain, Range>(domain: Domain, range: Range) -> some View\nConfigures the line style scale for charts.\nfunc chartLineStyleScale<Range>(range: Range) -> some View\nConfigures the line style scale for charts.\nfunc chartLineStyleScale<Domain>(domain: Domain, mapping: (Domain.Element) -> StrokeStyle) -> some View\nConfigures the line style scale for charts.\nfunc chartLineStyleScale<DataValue>(mapping: (DataValue) -> StrokeStyle) -> some View\nConfigures the line style scale for charts.\nScrolling\nfunc chartScrollPosition(initialX: some Plottable) -> some View\nSets the initial scroll position along the x-axis. Once the user scrolls the scroll view, the value provided to this modifier will have no effect.\nfunc chartScrollPosition(initialY: some Plottable) -> some View\nSets the initial scroll position along the y-axis. Once the user scrolls the scroll view, the value provided to this modifier will have no effect.\nfunc chartScrollPosition(x: Binding<some Plottable>) -> some View\nAssociates a binding to be updated when the chart scrolls along the x-axis.\nfunc chartScrollPosition(y: Binding<some Plottable>) -> some View\nAssociates a binding to be updated when the chart scrolls along the y-axis.\nfunc chartScrollTargetBehavior(some ChartScrollTargetBehavior) -> some View\nSets the scroll behavior of the scrollable chart.\nfunc chartScrollableAxes(Axis.Set) -> some View\nConfigures the scrollable behavior of charts in this view.\nSelection\nfunc chartXSelection<P>(range: Binding<ClosedRange<P>?>) -> some View\nfunc chartXSelection<P>(value: Binding<P?>) -> some View\nfunc chartYSelection<P>(range: Binding<ClosedRange<P>?>) -> some View\nfunc chartYSelection<P>(value: Binding<P?>) -> some View\nfunc chartAngleSelection<P>(value: Binding<P?>) -> some View\nVisible domain\nfunc chartXVisibleDomain<P>(length: P) -> some View\nSets the length of the visible domain in the X dimension.\nfunc chartYVisibleDomain<P>(length: P) -> some View\nSets the length of the visible domain in the Y dimension.\nInteraction\nfunc chartGesture((ChartProxy) -> some Gesture) -> some View\nSee Also\nConfiguring view elements\nAccessibility modifiers\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAppearance modifiers\nConfigure a view\u2019s foreground and background styles, controls, and visibility.\nText and symbol modifiers\nManage the rendering, selection, and entry of text in your view.\nAuxiliary view modifiers\nAdd and configure supporting views, like toolbars and context menus."
    },
    {
        "title": "digitalCrownRotation(_:from:through:by:sensitivity:isContinuous:isHapticFeedbackEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/digitalcrownrotation(_:from:through:by:sensitivity:iscontinuous:ishapticfeedbackenabled:)",
        "html": "Parameters\nbinding\n\nA binding to a value that updates when the user rotates the Digital Crown.\n\nminValue\n\nLower end of the range reported.\n\nmaxValue\n\nUpper end of the range reported.\n\nstride\n\nThe value settles on multiples of stride.\n\nsensitivity\n\nHow much the user needs to rotate the Digital Crown to move between two integer numbers.\n\nisContinuous\n\nControls if the value reported stops at minValue and maxValue, or if it should wrap around. Default is false.\n\nisHapticFeedbackEnabled\n\nControls the generation of haptic feedback when turning the Digital Crown. Default is true.\n\nDiscussion\n\nUse this method to receive values on a binding you provides as the user turns the Digital Crown on Apple Watch. The example below receives changes to the binding value, starting at the minValue of 0.0 up to the maxValue of 10.0 in steps of 0.1 incrementing or decrementing depending on the direction that the user turns the Digital Crown, rolling over if the user exceeds the specified boundary values:\n\nstruct DigitalCrown: View {\n    @State private var crownValue = 0.0\n    @State private var minValue = 0.0\n    @State private var maxValue = 10.0\n    @State private var stepAmount = 0.1\n\n\n    var body: some View {\n        Text(\"Received Value:\\(crownValue, specifier: \"%.2f\")\")\n            .focusable()\n            .digitalCrownRotation($crownValue,\n                                  from: minValue,\n                                  through: maxValue,\n                                  by: stepAmount,\n                                  sensitivity: .low,\n                                  isContinuous: true)\n    }\n}\n\n\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "DigitalCrownEvent",
        "url": "https://developer.apple.com/documentation/swiftui/digitalcrownevent",
        "html": "Overview\n\nUse the digitalCrownRotation(_:) modifier to receive these events.\n\nTopics\nGetting events\nvar offset: Double\nThe offset of the digital crown when this event was sent.\nvar velocity: Double\nThe velocity at which the offset was changing when this event was sent.\nRelationships\nConforms To\nSendable\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "TouchBarItemPresence",
        "url": "https://developer.apple.com/documentation/swiftui/touchbaritempresence",
        "html": "Topics\nGetting presence options\ncase `default`(String)\nThe Touch Bar view is visible by default, but can be removed during customization.\ncase optional(String)\nThe Touch Bar view isn\u2019t visible by default, but appears in the customization palette.\ncase required(String)\nThe Touch Bar view is visible by default and cannot be removed during customization.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Touch Bar input\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nstruct TouchBar\nA container for a view that you can show in the Touch Bar."
    },
    {
        "title": "ForEach",
        "url": "https://developer.apple.com/documentation/swiftui/foreach",
        "html": "Overview\n\nUse ForEach to provide views based on a RandomAccessCollection of some data type. Either the collection\u2019s elements must conform to Identifiable or you need to provide an id parameter to the ForEach initializer.\n\nThe following example creates a NamedFont type that conforms to Identifiable, and an array of this type called namedFonts. A ForEach instance iterates over the array, producing new Text instances that display examples of each SwiftUI Font style provided in the array.\n\nprivate struct NamedFont: Identifiable {\n    let name: String\n    let font: Font\n    var id: String { name }\n}\n\n\nprivate let namedFonts: [NamedFont] = [\n    NamedFont(name: \"Large Title\", font: .largeTitle),\n    NamedFont(name: \"Title\", font: .title),\n    NamedFont(name: \"Headline\", font: .headline),\n    NamedFont(name: \"Body\", font: .body),\n    NamedFont(name: \"Caption\", font: .caption)\n]\n\n\nvar body: some View {\n    ForEach(namedFonts) { namedFont in\n        Text(namedFont.name)\n            .font(namedFont.font)\n    }\n}\n\n\nTopics\nCreating a collection from a range\ninit(Range<Int>, content: (Int) -> Content)\nCreates an instance that computes views on demand over a given constant range.\nAvailable when Data is Range<Int>, ID is Int, and Content conforms to View.\nCreating a collection from data\ninit(Data, content: (Data.Element) -> Content)\nCreates an instance that uniquely identifies and creates views across updates based on the identity of the underlying data.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Content conforms to View, and Data.Element conforms to Identifiable.\ninit<C>(Binding<C>, content: (Binding<C.Element>) -> Content)\nCreates an instance that uniquely identifies and creates views across updates based on the identity of the underlying data.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\ninit(Data, id: KeyPath<Data.Element, ID>, content: (Data.Element) -> Content)\nCreates an instance that uniquely identifies and creates views across updates based on the provided key path to the underlying data\u2019s identifier.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\ninit<C>(Binding<C>, id: KeyPath<C.Element, ID>, content: (Binding<C.Element>) -> Content)\nCreates an instance that uniquely identifies and creates views across updates based on the identity of the underlying data.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\ninit(Data)\nCreates an instance that uniquely identifies and creates table rows across updates based on the identity of the underlying data.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\nGenerating rotor content\ninit(Data, content: (Data.Element) -> Content)\nCreates an instance that generates Rotor content by combining, in order, individual Rotor content for each element in the data given to this ForEach.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Content conforms to AccessibilityRotorContent, and Data.Element conforms to Identifiable.\ninit(Data, id: KeyPath<Data.Element, ID>, content: (Data.Element) -> Content)\nCreates an instance that generates Rotor content by combining, in order, individual Rotor content for each element in the data given to this ForEach.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to AccessibilityRotorContent.\nCreating a collection of table rows\ninit<V>(Range<Int>, content: (Int) -> Content)\nCreates an instance that computes table rows on demand over a given constant range.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\ninit<V>(Data, content: (Data.Element) -> Content)\nCreates an instance that uniquely identifies and creates table rows across updates based on the identity of the underlying data.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\ninit<V>(Data, id: KeyPath<Data.Element, ID>, content: (Data.Element) -> Content)\nCreates an instance that uniquely identifies and creates table rows across updates based on the provided key path to the underlying data\u2019s identifier.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\nCreating chart content\ninit(Data, content: (Data.Element) -> Content)\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Content conforms to ChartContent, and Data.Element conforms to Identifiable.\ninit(Data, id: KeyPath<Data.Element, ID>, content: (Data.Element) -> Content)\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to ChartContent.\nCreating editable content\ninit<C, R>(Binding<C>, editActions: EditActions<C>, content: (Binding<C.Element>) -> R)\nCreates an instance that uniquely identifies and creates views across updates based on the identity of the underlying data.\nAvailable when Data conforms to RandomAccessCollection and ID conforms to Hashable.\ninit<C, R>(Binding<C>, id: KeyPath<C.Element, ID>, editActions: EditActions<C>, content: (Binding<C.Element>) -> R)\nCreates an instance that uniquely identifies and creates views across updates based on the identity of the underlying data.\nAvailable when Data conforms to RandomAccessCollection and ID conforms to Hashable.\nCreating attachment content\ninit(Data, content: (Data.Element) -> Content)\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Content conforms to AttachmentContent, and Data.Element conforms to Identifiable.\nBeta\ninit(Data, id: KeyPath<Data.Element, ID>, content: (Data.Element) -> Content)\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to AttachmentContent.\nBeta\nAccessing content\nvar content: (Data.Element) -> Content\nA function to create content on demand using the underlying data.\nvar data: Data\nThe collection of underlying identified data that SwiftUI uses to create views dynamically.\nType Aliases\ntypealias Body\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\nDefault Implementations\nAttachmentContent Implementations\nRelationships\nConforms To\nAccessibilityRotorContent\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to AccessibilityRotorContent.\nAttachmentContent\nChartContent\nDynamicTableRowContent\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\nDynamicViewContent\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\nTableRowContent\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\nView\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\nSee Also\nIterating over list content\nprotocol DynamicViewContent\nA type of view that generates views from an underlying collection of data.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View."
    },
    {
        "title": "HoverEffect",
        "url": "https://developer.apple.com/documentation/swiftui/hovereffect",
        "html": "Topics\nGetting hover effects\nstatic let automatic: HoverEffect\nAn effect that attempts to determine the effect automatically. This is the default effect.\nstatic let highlight: HoverEffect\nAn effect that morphs the pointer into a platter behind the view and shows a light source indicating position.\nstatic let lift: HoverEffect\nAn effect that slides the pointer under the view and disappears as the view scales up and gains a shadow.\nSee Also\nChanging view appearance for hover events\nfunc hoverEffect(HoverEffect) -> some View\nApplies a hover effect to this view."
    },
    {
        "title": "digitalCrownRotation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/digitalcrownrotation(_:)",
        "html": "Parameters\nbinding\n\nA binding to a value that updates as the user rotates the Digital Crown. The implicit range is (-infinity, +infinity).\n\nDiscussion\n\nUse this method to receive values on a binding you provide as the user turns the Digital Crown on Apple Watch. The example below receives changes to the binding value, starting at 0.0 and incrementing or decrementing depending on the direction that the user turns the Digital Crown:\n\nstruct DigitalCrown: View {\n    @State private var crownValue = 0.0\n\n\n    var body: some View {\n        Text(\"Received Value:\\(crownValue, specifier: \"%.1f\")\")\n            .focusable()\n            .digitalCrownRotation($crownValue)\n    }\n}\n\n\nSee Also\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers."
    },
    {
        "title": "HoverPhase",
        "url": "https://developer.apple.com/documentation/swiftui/hoverphase",
        "html": "Overview\n\nWhen you use the onContinuousHover(coordinateSpace:perform:) modifier, you can handle the hovering state using the action closure. SwiftUI calls the closure with a phase value to indicate the current hovering state. The following example updates hoverLocation and isHovering based on the phase provided to the closure:\n\n@State private var hoverLocation: CGPoint = .zero\n@State private var isHovering = false\n\n\nvar body: some View {\n    VStack {\n        Color.red\n            .frame(width: 400, height: 400)\n            .onContinuousHover { phase in\n                switch phase {\n                case .active(let location):\n                    hoverLocation = location\n                    isHovering = true\n                case .ended:\n                    isHovering = false\n                }\n            }\n            .overlay {\n                Rectangle()\n                    .frame(width: 50, height: 50)\n                    .foregroundColor(isHovering ? .green : .blue)\n                    .offset(x: hoverLocation.x, y: hoverLocation.y)\n            }\n    }\n}\n\nTopics\nGetting hover phases\ncase active(CGPoint)\nThe pointer\u2019s location moved to the specified point within the view.\ncase ended\nThe pointer exited the view.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nResponding to hover events\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed."
    },
    {
        "title": "GaugeStyleConfiguration.CurrentValueLabel",
        "url": "https://developer.apple.com/documentation/swiftui/gaugestyleconfiguration/currentvaluelabel-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nSetting the value\nvar value: Double\nThe current value of the gauge.\nvar currentValueLabel: GaugeStyleConfiguration.CurrentValueLabel?\nA view that describes the current value.\nstruct MarkedValueLabel\nA type-erased label describing a specific value of a gauge."
    },
    {
        "title": "onMoveCommand(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onmovecommand(perform:)",
        "html": "See Also\nResponding to commands\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector.\nenum MoveCommandDirection\nSpecifies the direction of an arrow key movement."
    },
    {
        "title": "isHoverEffectEnabled",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/ishovereffectenabled",
        "html": "Discussion\n\nThe default value is true.\n\nSee Also\nResponding to hover events\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nenum HoverPhase\nThe current hovering state and value of the pointer."
    },
    {
        "title": "onSubmit(of:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onsubmit(of:_:)",
        "html": "Parameters\ntriggers\n\nThe triggers that should invoke the provided action.\n\naction\n\nThe action to perform on submission of a value.\n\nDiscussion\n\nDifferent views may have different triggers for the provided action. A TextField, or SecureField will trigger this action when the user hits the hardware or software return key. This modifier may also bind this action to a default action keyboard shortcut. You may set this action on an individual view or an entire view hierarchy.\n\nTextField(\"Username\", text: $username)\n    .onSubmit {\n        guard viewModel.validate() else { return }\n        viewModel.login()\n    }\n\n\nYou can use the submitScope(_:) modifier to stop a submit trigger from a control from propagating higher up in the view hierarchy to higher View.onSubmit(of:_:) modifiers.\n\nForm {\n    TextField(\"Username\", text: $viewModel.userName)\n    SecureField(\"Password\", text: $viewModel.password)\n\n\n    TextField(\"Tags\", text: $viewModel.tags)\n        .submitScope()\n}\n.onSubmit {\n    guard viewModel.validate() else { return }\n    viewModel.login()\n}\n\n\nYou can use different submit triggers to filter the types of triggers that should invoke the provided submission action. For example, you may provide a value of search to only hear submission triggers that originate from search fields vended by searchable modifiers.\n\n@StateObject private var viewModel = ViewModel()\n\n\nNavigationView {\n    SidebarView()\n    DetailView()\n}\n.searchable(\n    text: $viewModel.searchText,\n    placement: .sidebar\n) {\n    SuggestionsView()\n}\n.onSubmit(of: .search) {\n    viewModel.submitCurrentSearchQuery()\n}\n\nSee Also\nResponding to submission events\nfunc submitScope(Bool) -> some View\nPrevents submission triggers originating from this view to invoke a submission action configured by a submission modifier higher up in the view hierarchy.\nstruct SubmitTriggers\nA type that defines various triggers that result in the firing of a submission action."
    },
    {
        "title": "hoverEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/hovereffect(_:)",
        "html": "Parameters\neffect\n\nThe effect to apply to this view.\n\nisEnabled\n\nWhether the effect is enabled or not.\n\nReturn Value\n\nA new view that applies a hover effect to self.\n\nDiscussion\n\nBy default, automatic is used. You can control the behavior of the automatic effect with the defaultHoverEffect(_:) modifier.\n\nSee Also\nChanging view appearance for hover events\nstruct HoverEffect\nAn effect applied when the pointer hovers over a view."
    },
    {
        "title": "SubmitTriggers",
        "url": "https://developer.apple.com/documentation/swiftui/submittriggers",
        "html": "Overview\n\nThese triggers may be provided to the onSubmit(of:_:) modifier to alter which types of user behaviors trigger a provided submission action.\n\nTopics\nGetting submit triggers\nstatic let search: SubmitTriggers\nDefines triggers originating from search fields constructed from searchable modifiers.\nstatic let text: SubmitTriggers\nDefines triggers originating from text input controls like TextField and SecureField.\nCreating a set of options\ninit(rawValue: SubmitTriggers.RawValue)\nCreates a set of submit triggers.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nResponding to submission events\nfunc onSubmit(of: SubmitTriggers, (() -> Void)) -> some View\nAdds an action to perform when the user submits a value to this view.\nfunc submitScope(Bool) -> some View\nPrevents submission triggers originating from this view to invoke a submission action configured by a submission modifier higher up in the view hierarchy."
    },
    {
        "title": "submitScope(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/submitscope(_:)",
        "html": "Parameters\nisBlocking\n\nA Boolean that indicates whether this scope is actively blocking submission triggers from reaching higher submission actions.\n\nDiscussion\n\nUse this modifier when you want to avoid specific views from initiating a submission action configured by the onSubmit(of:_:) modifier. In the example below, the tag field doesn\u2019t trigger the submission of the form:\n\nForm {\n    TextField(\"Username\", text: $viewModel.userName)\n    SecureField(\"Password\", text: $viewModel.password)\n\n\n    TextField(\"Tags\", text: $viewModel.tags)\n        .submitScope()\n}\n.onSubmit {\n    guard viewModel.validate() else { return }\n    viewModel.login()\n}\n\nSee Also\nResponding to submission events\nfunc onSubmit(of: SubmitTriggers, (() -> Void)) -> some View\nAdds an action to perform when the user submits a value to this view.\nstruct SubmitTriggers\nA type that defines various triggers that result in the firing of a submission action."
    },
    {
        "title": "ToggleStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/togglestyleconfiguration/label-swift.struct",
        "html": "Overview\n\nSwiftUI provides a value of this type \u2014 which is a View type \u2014 as the label to your custom toggle style implementation. Use the label to help define the appearance of the toggle.\n\nRelationships\nConforms To\nView\nSee Also\nGetting the label view\nlet label: ToggleStyleConfiguration.Label\nA view that describes the effect of switching the toggle between states."
    },
    {
        "title": "RadialGradient",
        "url": "https://developer.apple.com/documentation/swiftui/radialgradient",
        "html": "Overview\n\nThe gradient applies the color function as the distance from a center point, scaled to fit within the defined start and end radii. The gradient maps the unit space center point into the bounding rectangle of each shape filled with the gradient.\n\nWhen using a radial gradient as a shape style, you can also use radialGradient(_:center:startRadius:endRadius:).\n\nTopics\nCreating a radial gradient\ninit(gradient: Gradient, center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat)\nCreates a radial gradient from a base gradient.\ninit(colors: [Color], center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat)\nCreates a radial gradient from a collection of colors.\ninit(stops: [Gradient.Stop], center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat)\nCreates a radial gradient from a collection of color stops.\nRelationships\nConforms To\nSendable\nShapeStyle\nView\nSee Also\nSupporting types\nstruct AngularGradient\nAn angular gradient.\nstruct EllipticalGradient\nA radial gradient that draws an ellipse.\nstruct LinearGradient\nA linear gradient.\nstruct Material\nA background material type.\nstruct ImagePaint\nA shape style that fills a shape by repeating a region of an image.\nstruct HierarchicalShapeStyle\nA shape style that maps to one of the numbered content styles.\nstruct HierarchicalShapeStyleModifier\nStyles that you can apply to hierarchical shapes.\nstruct ForegroundStyle\nThe foreground style in the current context.\nstruct BackgroundStyle\nThe background style in the current context.\nstruct SelectionShapeStyle\nA style used to visually indicate selection following platform conventional colors and behaviors.\nstruct SeparatorShapeStyle\nA style appropriate for foreground separator or border lines.\nstruct TintShapeStyle\nA style that reflects the current tint color.\nstruct FillShapeStyle\nA shape style that displays one of the overlay fills.\nstruct LinkShapeStyle\nA style appropriate for links.\nstruct PlaceholderTextShapeStyle\nA style appropriate for placeholder text.\nstruct WindowBackgroundShapeStyle\nA style appropriate for elements that should match the background of their containing window."
    },
    {
        "title": "SearchUnavailableContent.Actions",
        "url": "https://developer.apple.com/documentation/swiftui/searchunavailablecontent/actions",
        "html": "Overview\n\nYou don\u2019t create this type directly. SwiftUI creates it when you build a searchContentUnavailableView.\n\nRelationships\nConforms To\nView\nSee Also\nGetting content types\nstruct Description\nA view that represents the description of a static ContentUnavailableView.search view.\nstruct Label\nA view that represents the label of a static placeholder search view."
    },
    {
        "title": "OutlineGroup",
        "url": "https://developer.apple.com/documentation/swiftui/outlinegroup",
        "html": "Overview\n\nUse an outline group when you need a view that can represent a hierarchy of data by using disclosure views. This allows the user to navigate the tree structure by using the disclosure views to expand and collapse branches.\n\nIn the following example, a tree structure of FileItem data offers a simplified view of a file system. Passing the root of this tree and the key path of its children allows you to quickly create a visual representation of the file system.\n\nstruct FileItem: Hashable, Identifiable, CustomStringConvertible {\n    var id: Self { self }\n    var name: String\n    var children: [FileItem]? = nil\n    var description: String {\n        switch children {\n        case nil:\n            return \"\ud83d\udcc4 \\(name)\"\n        case .some(let children):\n            return children.isEmpty ? \"\ud83d\udcc2 \\(name)\" : \"\ud83d\udcc1 \\(name)\"\n        }\n    }\n}\n\n\nlet data =\n  FileItem(name: \"users\", children:\n    [FileItem(name: \"user1234\", children:\n      [FileItem(name: \"Photos\", children:\n        [FileItem(name: \"photo001.jpg\"),\n         FileItem(name: \"photo002.jpg\")]),\n       FileItem(name: \"Movies\", children:\n         [FileItem(name: \"movie001.mp4\")]),\n          FileItem(name: \"Documents\", children: [])\n      ]),\n     FileItem(name: \"newuser\", children:\n       [FileItem(name: \"Documents\", children: [])\n       ])\n    ])\n\n\nOutlineGroup(data, children: \\.children) { item in\n    Text(\"\\(item.description)\")\n}\n\nType parameters\n\nFive generic type constraints define a specific OutlineGroup instance:\n\nData: The type of a collection containing the children of an element in the tree-shaped data.\n\nID: The type of the identifier for an element.\n\nParent: The type of the visual representation of an element whose children property is non-nil\n\nLeaf: The type of the visual representation of an element whose children property is nil.\n\nSubgroup: A type of a view that groups a parent view and a view representing its children, typically with some mechanism for showing and hiding the children\n\nTopics\nCreating an outline group\ninit<DataElement>(DataElement, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a root data element and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to View, Parent is Leaf, Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>, and Data.Element conforms to Identifiable.\ninit<DataElement>(Data, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a collection of root data elements and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to View, Parent is Leaf, Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>, and Data.Element conforms to Identifiable.\ninit<DataElement>(DataElement, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a root data element, the key path to its identifier, and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, Parent conforms to View, Parent is Leaf, and Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>.\ninit<DataElement>(Data, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a collection of root data elements, the key path to a data element\u2019s identifier, and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, Parent conforms to View, Parent is Leaf, and Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>.\nCreating an outline group from a binding\ninit<C, E>(Binding<E>, children: WritableKeyPath<E, C?>, content: (Binding<E>) -> Leaf)\nCreates an outline group from a binding to a root data element and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to View, Parent is Leaf, Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>, and Data.Element conforms to Identifiable.\ninit<C, E>(Binding<C>, children: WritableKeyPath<E, C?>, content: (Binding<E>) -> Leaf)\nCreates an outline group from a binding to a collection of root data elements and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to View, Parent is Leaf, Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>, and Data.Element conforms to Identifiable.\ninit<C, E>(Binding<E>, id: KeyPath<E, ID>, children: WritableKeyPath<E, C?>, content: (Binding<E>) -> Leaf)\nCreates an outline group from a binding to a root data element, the key path to its identifier, and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, Parent conforms to View, Parent is Leaf, and Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>.\ninit<C, E>(Binding<C>, id: KeyPath<E, ID>, children: WritableKeyPath<E, C?>, content: (Binding<E>) -> Leaf)\nCreates an outline group from a binding to a collection of root data elements, the key path to a data element\u2019s identifier, and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, Parent conforms to View, Parent is Leaf, and Subgroup is DisclosureGroup<Parent, OutlineSubgroupChildren>.\nCreating an outline group in a table\ninit<DataElement>(DataElement, children: KeyPath<DataElement, Data?>)\nCreates an outline group from a root data element and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\ninit<DataElement>(Data, children: KeyPath<DataElement, Data?>)\nCreates an outline group from a collection of root data elements and a key path to element\u2019s children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\ninit<DataElement>(Data, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a collection of root data elements and a key path to element\u2019s children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\ninit<DataElement>(DataElement, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a root data element and a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\ninit<DataElement>(DataElement, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a root data element, a key path to the its identifier, as well as a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\ninit<DataElement>(DataElement, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a root data element, a key path to the its identifier, as well as a key path to its children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\nSupporting types\nstruct OutlineSubgroupChildren\nA type-erased view representing the children in an outline subgroup.\nInitializers\ninit<DataElement>(Data, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, content: (DataElement) -> Leaf)\nCreates an outline group from a collection of root data elements, a key path to the element\u2019s identifier, as well as a key path to element\u2019s children.\nAvailable when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\nRelationships\nConforms To\nTableRowContent\nConforms when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\nView\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, Parent conforms to View, Leaf conforms to View, and Subgroup conforms to View.\nSee Also\nDisclosing information progressively\nstruct DisclosureGroup\nA view that shows or hides another content view, based on the state of a disclosure control.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view."
    },
    {
        "title": "ScrollViewReader",
        "url": "https://developer.apple.com/documentation/swiftui/scrollviewreader",
        "html": "Overview\n\nThe scroll view reader\u2019s content view builder receives a ScrollViewProxy instance; you use the proxy\u2019s scrollTo(_:anchor:) to perform scrolling.\n\nThe following example creates a ScrollView containing 100 views that together display a color gradient. It also contains two buttons, one each at the top and bottom. The top button tells the ScrollViewProxy to scroll to the bottom button, and vice versa.\n\n@Namespace var topID\n@Namespace var bottomID\n\n\nvar body: some View {\n    ScrollViewReader { proxy in\n        ScrollView {\n            Button(\"Scroll to Bottom\") {\n                withAnimation {\n                    proxy.scrollTo(bottomID)\n                }\n            }\n            .id(topID)\n\n\n            VStack(spacing: 0) {\n                ForEach(0..<100) { i in\n                    color(fraction: Double(i) / 100)\n                        .frame(height: 32)\n                }\n            }\n\n\n            Button(\"Top\") {\n                withAnimation {\n                    proxy.scrollTo(topID)\n                }\n            }\n            .id(bottomID)\n        }\n    }\n}\n\n\nfunc color(fraction: Double) -> Color {\n    Color(red: fraction, green: 1 - fraction, blue: 0.5)\n}\n\n\nImportant\n\nYou may not use the ScrollViewProxy during execution of the content view builder; doing so results in a runtime error. Instead, only actions created within content can call the proxy, such as gesture handlers or a view\u2019s onChange(of:perform:) method.\n\nTopics\nCreating a scroll view reader\ninit(content: (ScrollViewProxy) -> Content)\nCreates an instance that can perform programmatic scrolling of its child scroll views.\nConfiguring a scroll view reader\nvar content: (ScrollViewProxy) -> Content\nThe view builder that creates the reader\u2019s content.\nRelationships\nConforms To\nView\nSee Also\nCreating a scroll view\nstruct ScrollView\nA scrollable view.\nstruct ScrollViewProxy\nA proxy value that supports programmatic scrolling of the scrollable views within a view hierarchy."
    },
    {
        "title": "rect",
        "url": "https://developer.apple.com/documentation/swiftui/shape/rect",
        "html": "See Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "LabeledContentStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/labeledcontentstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the label\nlet label: LabeledContentStyleConfiguration.Label\nThe label of the labeled content instance."
    },
    {
        "title": "ProgressViewStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/progressviewstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the label\nvar label: ProgressViewStyleConfiguration.Label?\nA view that describes the task represented by the progress view."
    },
    {
        "title": "LabeledContentStyleConfiguration.Content",
        "url": "https://developer.apple.com/documentation/swiftui/labeledcontentstyleconfiguration/content-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the content\nlet content: LabeledContentStyleConfiguration.Content\nThe content of the labeled content instance."
    },
    {
        "title": "ContentShapeKinds",
        "url": "https://developer.apple.com/documentation/swiftui/contentshapekinds",
        "html": "Overview\n\nThe kind is used by the system to influence various effects, hit-testing, and more.\n\nTopics\nGetting shape kinds\nstatic let interaction: ContentShapeKinds\nThe kind for hit-testing and accessibility.\nstatic let dragPreview: ContentShapeKinds\nThe kind for drag and drop previews.\nstatic let contextMenuPreview: ContentShapeKinds\nThe kind for context menu previews.\nstatic let focusEffect: ContentShapeKinds\nThe kind for the focus effect.\nstatic let hoverEffect: ContentShapeKinds\nThe kind for hover effects.\nstatic let accessibility: ContentShapeKinds\nThe kind for accessibility visuals and sorting.\nCreating a set of options\ninit(rawValue: Int)\nCreates a content shape kind.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nControlling hit testing\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nfunc contentShape<S>(S, eoFill: Bool) -> some View\nDefines the content shape for hit testing.\nfunc contentShape<S>(ContentShapeKinds, S, eoFill: Bool) -> some View\nSets the content shape for this view."
    },
    {
        "title": "LinearGradient",
        "url": "https://developer.apple.com/documentation/swiftui/lineargradient",
        "html": "Overview\n\nThe gradient applies the color function along an axis, as defined by its start and end points. The gradient maps the unit space points into the bounding rectangle of each shape filled with the gradient.\n\nWhen using a linear gradient as a shape style, you can also use linearGradient(_:startPoint:endPoint:).\n\nTopics\nCreating a linear gradient\ninit(gradient: Gradient, startPoint: UnitPoint, endPoint: UnitPoint)\nCreates a linear gradient from a base gradient.\ninit(colors: [Color], startPoint: UnitPoint, endPoint: UnitPoint)\nCreates a linear gradient from a collection of colors.\ninit(stops: [Gradient.Stop], startPoint: UnitPoint, endPoint: UnitPoint)\nCreates a linear gradient from a collection of color stops.\nRelationships\nConforms To\nSendable\nShapeStyle\nView\nSee Also\nSupporting types\nstruct AngularGradient\nAn angular gradient.\nstruct EllipticalGradient\nA radial gradient that draws an ellipse.\nstruct RadialGradient\nA radial gradient.\nstruct Material\nA background material type.\nstruct ImagePaint\nA shape style that fills a shape by repeating a region of an image.\nstruct HierarchicalShapeStyle\nA shape style that maps to one of the numbered content styles.\nstruct HierarchicalShapeStyleModifier\nStyles that you can apply to hierarchical shapes.\nstruct ForegroundStyle\nThe foreground style in the current context.\nstruct BackgroundStyle\nThe background style in the current context.\nstruct SelectionShapeStyle\nA style used to visually indicate selection following platform conventional colors and behaviors.\nstruct SeparatorShapeStyle\nA style appropriate for foreground separator or border lines.\nstruct TintShapeStyle\nA style that reflects the current tint color.\nstruct FillShapeStyle\nA shape style that displays one of the overlay fills.\nstruct LinkShapeStyle\nA style appropriate for links.\nstruct PlaceholderTextShapeStyle\nA style appropriate for placeholder text.\nstruct WindowBackgroundShapeStyle\nA style appropriate for elements that should match the background of their containing window."
    },
    {
        "title": "LabelStyleConfiguration.Title",
        "url": "https://developer.apple.com/documentation/swiftui/labelstyleconfiguration/title-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nSetting the title\nvar title: LabelStyleConfiguration.Title\nA description of the labeled item."
    },
    {
        "title": "GroupBoxStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/groupboxstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the label\nlet label: GroupBoxStyleConfiguration.Label\nA view that provides the title of the group box."
    },
    {
        "title": "GroupBoxStyleConfiguration.Content",
        "url": "https://developer.apple.com/documentation/swiftui/groupboxstyleconfiguration/content-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the content\nlet content: GroupBoxStyleConfiguration.Content\nA view that represents the content of the group box."
    },
    {
        "title": "stroke(_:lineWidth:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/stroke(_:linewidth:)",
        "html": "Parameters\ncontent\n\nThe color or gradient with which to stroke this shape.\n\nlineWidth\n\nThe width of the stroke that outlines this shape.\n\nReturn Value\n\nA stroked shape.\n\nDiscussion\n\nThe following example draws a circle with a purple stroke:\n\nCircle().stroke(Color.purple, lineWidth: 5)\n\nSee Also\nSetting the stroke characteristics\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(lineWidth: CGFloat) -> some Shape\nReturns a new shape that is a stroked copy of self with line-width defined by lineWidth and all other properties of StrokeStyle having their default values.\nfunc stroke<S>(S, style: StrokeStyle) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(style: StrokeStyle) -> some Shape\nReturns a new shape that is a stroked copy of self, using the contents of style to define the stroke characteristics."
    },
    {
        "title": "LabelStyleConfiguration.Icon",
        "url": "https://developer.apple.com/documentation/swiftui/labelstyleconfiguration/icon-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nSetting the icon\nvar icon: LabelStyleConfiguration.Icon\nA symbolic representation of the labeled item."
    },
    {
        "title": "PrimitiveButtonStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/primitivebuttonstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring a button\u2019s label\nlet label: PrimitiveButtonStyleConfiguration.Label\nA view that describes the effect of calling the button\u2019s action."
    },
    {
        "title": "onKeyPress(characters:phases:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onkeypress(characters:phases:action:)",
        "html": "Parameters\ncharacters\n\nThe set of characters to match against incoming hardware keyboard events.\n\nphases\n\nThe key-press phases to match (.down, .repeat, and .up). The default value is [.down, .repeat].\n\naction\n\nThe action to perform. The action receives a value describing the matched key event. Return .handled to consume the event and prevent further dispatch, or .ignored to allow dispatch to continue.\n\nReturn Value\n\nA modified view that binds hardware keyboard input when focused.\n\nSee Also\nResponding to keyboard input\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses any key on a hardware keyboard while the view has focus.\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nstruct KeyPress"
    },
    {
        "title": "keyboardShortcut(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/keyboardshortcut(_:)-3vjx6",
        "html": "Discussion\n\nPressing the control\u2019s shortcut while the control is anywhere in the frontmost window or scene, or anywhere in the macOS main menu, is equivalent to direct interaction with the control to perform its primary action.\n\nThe target of a keyboard shortcut is resolved in a leading-to-trailing traversal of one or more view hierarchies. On macOS, the system looks in the key window first, then the main window, and then the command groups; on other platforms, the system looks in the active scene, and then the command groups.\n\nIf multiple controls are associated with the same shortcut, the first one found is used. If the provided shortcut is nil, the modifier will have no effect.\n\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture."
    },
    {
        "title": "GaugeStyleConfiguration.MaximumValueLabel",
        "url": "https://developer.apple.com/documentation/swiftui/gaugestyleconfiguration/maximumvaluelabel-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nReporting the range\nvar minimumValueLabel: GaugeStyleConfiguration.MinimumValueLabel?\nA view that describes the minimum of the range for the current value.\nstruct MinimumValueLabel\nA type-erased value label of a gauge describing the minimum value.\nvar maximumValueLabel: GaugeStyleConfiguration.MaximumValueLabel?\nA view that describes the maximum of the range for the current value."
    },
    {
        "title": "onKeyPress(_:phases:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onkeypress(_:phases:action:)",
        "html": "Parameters\nkey\n\nThe key to match against incoming hardware keyboard events.\n\nphases\n\nThe key-press phases to match (.down, .up, and .repeat).\n\naction\n\nThe action to perform. The action receives a value describing the matched key event. Return .handled to consume the event and prevent further dispatch, or .ignored to allow dispatch to continue.\n\nReturn Value\n\nA modified view that binds hardware keyboard input when focused.\n\nDiscussion\n\nSwiftUI performs the action for the specified event phases.\n\nSee Also\nResponding to keyboard input\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses any key on a hardware keyboard while the view has focus.\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nstruct KeyPress"
    },
    {
        "title": "keyboardShortcut",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/keyboardshortcut",
        "html": "Discussion\n\nThis is particularly useful in button styles when a button\u2019s appearance depends on the shortcut associated with it. On macOS, for example, when a button is bound to the Return key, it is typically drawn with a special emphasis. This happens automatically when using the built-in button styles, and can be implemented manually in custom styles using this environment key:\n\nprivate struct MyButtonStyle: ButtonStyle {\n    @Environment(\\.keyboardShortcut)\n    private var shortcut: KeyboardShortcut?\n\n\n    func makeBody(configuration: Configuration) -> some View {\n        let labelFont = Font.body\n            .weight(shortcut == .defaultAction ? .bold : .regular)\n        configuration.label\n            .font(labelFont)\n    }\n}\n\n\nIf no keyboard shortcut has been applied to the view or its ancestor, then the environment value will be nil.\n\nSee Also\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture."
    },
    {
        "title": "LabeledToolbarItemGroupContent",
        "url": "https://developer.apple.com/documentation/swiftui/labeledtoolbaritemgroupcontent",
        "html": "Overview\n\nYou don\u2019t create this type directly. SwiftUI creates it when you build a ToolbarItemGroup.\n\nRelationships\nConforms To\nView"
    },
    {
        "title": "Presentation modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-presentation",
        "html": "Overview\n\nUse presentation modifiers to show different kinds of modal presentations, like alerts, popovers, sheets, and confirmation dialogs.\n\nBecause SwiftUI is a declarative framework, you don\u2019t call a method at the moment you want to present the modal. Rather, you define how the presentation looks and the condition under which SwiftUI should present it. SwiftUI detects when the condition changes and makes the presentation for you. Because you provide a Binding to the condition that initiates the presentation, SwiftUI can reset the underlying value when the user dismisses the presentation.\n\nFor more information about how to use these modifiers, see Modal presentations.\n\nTopics\nAlerts\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present.\nAlerts with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present.\nConfirmation dialogs\nfunc confirmationDialog<S, A>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a string variable as a title.\nfunc confirmationDialog<A>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a text view for the title.\nfunc confirmationDialog<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a localized string key for the title.\nfunc confirmationDialog<S, A, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a string variable for the title.\nConfirmation dialogs with a message\nfunc confirmationDialog<S, A, M>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a string variable for the title.\nfunc confirmationDialog<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, M>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A, M, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a text view for the message.\nfunc confirmationDialog<S, A, M, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a string variable for the title.\nfunc confirmationDialog<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a localized string key for the title.\nDialog configuration\nfunc dialogIcon(Image?) -> some View\nConfigures the icon used by dialogs within this view.\nfunc dialogSeverity(DialogSeverity) -> some View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a default suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nSheets\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nPopovers\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content.\nSheet and popover configuration\nfunc interactiveDismissDisabled(Bool) -> some View\nConditionally prevents interactive dismissal of presentations like popovers, sheets, and inspectors.\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nfunc presentationBackground<S>(S) -> some View\nSets the presentation background of the enclosing sheet using a shape style.\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> some View\nSets the presentation background of the enclosing sheet to a custom view.\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> some View\nControls whether people can interact with the view behind a presentation.\nfunc presentationCompactAdaptation(horizontal: PresentationAdaptation, vertical: PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to horizontally and vertically compact size classes.\nfunc presentationCompactAdaptation(PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to compact size classes.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nfunc presentationCornerRadius(CGFloat?) -> some View\nRequests that the presentation have a specific corner radius.\nFile exporter\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nFile importer\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import multiple files.\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import an existing file.\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to import multiple files.\nFile mover\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move a collection of existing files to a new location.\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move a collection of existing files to a new location.\nFile dialog configuration\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nInspectors\nfunc inspector<V>(isPresented: Binding<Bool>, content: () -> V) -> some View\nInserts an inspector at the applied position in the view hierarchy.\nfunc inspectorColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the inspector containing this view when presented as a trailing column.\nfunc inspectorColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the inspector in a trailing-column presentation.\nQuick look previews\nfunc quickLookPreview(Binding<URL?>) -> some View\nPresents a Quick Look preview of the contents of a single URL.\nfunc quickLookPreview<Items>(Binding<Items.Element?>, in: Items) -> some View\nPresents a Quick Look preview of the URLs you provide.\nFamily Sharing\nfunc familyActivityPicker(isPresented: Binding<Bool>, selection: Binding<FamilyActivitySelection>) -> some View\nPresents an activity picker view as a sheet.\nfunc familyActivityPicker(headerText: String?, footerText: String?, isPresented: Binding<Bool>, selection: Binding<FamilyActivitySelection>) -> some View\nPresents an activity picker view as a sheet.\nLive Activities\nfunc activitySystemActionForegroundColor(Color?) -> some View\nThe text color for the auxiliary action button that the system shows next to a Live Activity on the Lock Screen.\nfunc activityBackgroundTint(Color?) -> some View\nSets the tint color for the background of a Live Activity that appears on the Lock Screen.\nApple Music\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nStoreKit\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nPhotoKit\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker.\nSee Also\nProviding interactivity\nInput and event modifiers\nSupply actions for a view to perform in response to user input and system events.\nSearch modifiers\nEnable people to search for content in your app.\nState modifiers\nAccess storage and provide child views with configuration data."
    },
    {
        "title": "Input and event modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-input-and-events",
        "html": "Overview\n\nUse input and event modifiers to configure and provide handlers for a wide variety of user inputs or system events. For example, you can detect and control focus, respond to life cycle events like view appearance and disappearance, manage keyboard shortcuts, and much more.\n\nTopics\nInteractivity\nfunc disabled(Bool) -> some View\nAdds a condition that controls whether users can interact with this view.\nfunc handlesExternalEvents(preferring: Set<String>, allowing: Set<String>) -> some View\nSpecifies a modifier indicating the Scene this View is in can handle matching incoming External Events.\nfunc interactionActivityTrackingTag(String) -> some View\nSets a tag that you use for tracking interactivity.\nList controls\nfunc swipeActions<T>(edge: HorizontalEdge, allowsFullSwipe: Bool, content: () -> T) -> some View\nAdds custom swipe actions to a row in a list.\nfunc refreshable(action: () async -> Void) -> some View\nMarks this view as refreshable.\nfunc selectionDisabled(Bool) -> some View\nAdds a condition that controls whether users can select this view.\nScroll controls\nfunc scrollPosition(id: Binding<(some Hashable)?>, anchor: UnitPoint?) -> some View\nAssociates a binding to be updated when a scroll view within this view scrolls.\nfunc defaultScrollAnchor(UnitPoint?) -> some View\nAssociates an anchor to control which part of the scroll view\u2019s content should be rendered by default.\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> some View\nSets the scroll behavior of views scrollable in the provided axes.\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nfunc scrollTransition(ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nfunc scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nTaps and gestures\nFor more information, see Gestures.\nfunc onTapGesture(count: Int, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture.\nfunc onTapGesture(count: Int, coordinateSpace: some CoordinateSpaceProtocol, perform: (CGPoint) -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture, and provides the action with the location of the interaction.\nfunc onLongPressGesture(minimumDuration: Double, maximumDistance: CGFloat, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongPressGesture(minimumDuration: Double, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongTouchGesture(minimumDuration: Double, perform: () -> Void, onTouchingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a remote long touch gesture. A long touch gesture is when the finger is on the remote touch surface without actually pressing.\nfunc gesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a lower precedence than gestures defined by the view.\nfunc highPriorityGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a higher precedence than gestures defined by the view.\nfunc simultaneousGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view to process simultaneously with gestures defined by the view.\nfunc defersSystemGestures(on: Edge.Set) -> some View\nSets the screen edge from which you want your gesture to take precedence over the system gesture.\nKeyboard input\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses any key on a hardware keyboard while the view has focus.\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nKeyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nHover\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffect(HoverEffect) -> some View\nApplies a hover effect to this view.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nfunc listRowHoverEffect(HoverEffect?) -> some View\nRequests that the containing list row use the provided hover effect.\nBeta\nfunc listRowHoverEffectDisabled(Bool) -> some View\nRequests that the containing list row have its hover effect disabled.\nBeta\nFocus\nFor more information, see Focus.\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nfunc focusedValue<T>(T?) -> some View\nSets the focused value for the given object type.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused view hierarchy.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the active scene.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused scene.\nfunc focusedObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose state depends on the focused view hierarchy.\nfunc focusedObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the focused view hierarchy.\nfunc focusedSceneObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nfunc focusedSceneObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nfunc prefersDefaultFocus(Bool, in: Namespace.ID) -> some View\nIndicates that the view should receive focus by default for a given namespace.\nfunc focusScope(Namespace.ID) -> some View\nCreates a focus scope that SwiftUI uses to limit default focus preferences.\nfunc focusSection() -> some View\nIndicates that the view\u2019s frame and cohort of focusable descendants should be used to guide focus movement.\nfunc focusable(Bool) -> some View\nSpecifies if the view is focusable.\nfunc focusable(Bool, interactions: FocusInteractions) -> some View\nSpecifies if the view is focusable, and if so, what focus-driven interactions it supports.\nfunc focusEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display focus effects, such as a default focus ring or hover effect.\nfunc defaultFocus<V>(FocusState<V>.Binding, V, priority: DefaultFocusEvaluationPriority) -> some View\nDefines a region of the window in which default focus is evaluated by assigning a value to a given focus state binding.\nCopy and paste\nFor more information, see Clipboard.\nfunc copyable<T>(() -> [T]) -> some View\nSpecifies a list of items to copy in response to the system\u2019s Copy command.\nfunc cuttable<T>(for: T.Type, action: () -> [T]) -> some View\nSpecifies an action that moves items to the Clipboard in response to the system\u2019s Cut command.\nfunc pasteDestination<T>(for: T.Type, action: ([T]) -> Void, validator: ([T]) -> [T]) -> some View\nSpecifies an action that adds validated items to a view in response to the system\u2019s Paste command.\nfunc onCopyCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Copy command.\nfunc onCutCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Cut command.\nfunc onPasteCommand(of: [UTType], perform: ([NSItemProvider]) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command.\nfunc onPasteCommand<Payload>(of: [UTType], validator: ([NSItemProvider]) -> Payload?, perform: (Payload) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command with items that you validate.\nDrag and drop\nFor more information, see Drag and drop.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nfunc dropDestination<T>(for: T.Type, action: ([T], CGPoint) -> Bool, isTargeted: (Bool) -> Void) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc draggable<T>(() -> T) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc draggable<V, T>(() -> T, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc springLoadingBehavior(SpringLoadingBehavior) -> some View\nSets the spring loading behavior this view.\nSubmission\nfunc onSubmit(of: SubmitTriggers, (() -> Void)) -> some View\nAdds an action to perform when the user submits a value to this view.\nfunc submitScope(Bool) -> some View\nPrevents submission triggers originating from this view to invoke a submission action configured by a submission modifier higher up in the view hierarchy.\nfunc submitLabel(SubmitLabel) -> some View\nSets the submit label for this view.\nMovement\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc moveDisabled(Bool) -> some View\nAdds a condition for whether the view\u2019s view hierarchy is movable.\nDeletion\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc deleteDisabled(Bool) -> some View\nAdds a condition for whether the view\u2019s view hierarchy is deletable.\nCommands\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector.\nDigital crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nUser activities\nfunc userActivity<P>(String, element: P?, (P, NSUserActivity) -> ()) -> some View\nAdvertises a user activity type.\nfunc userActivity(String, isActive: Bool, (NSUserActivity) -> ()) -> some View\nAdvertises a user activity type.\nfunc onContinueUserActivity(String, perform: (NSUserActivity) -> ()) -> some View\nRegisters a handler to invoke when the view receives the specified activity type for the scene or window the view is in.\nView life cycle\nfunc onAppear(perform: (() -> Void)?) -> some View\nAdds an action to perform before this view appears.\nfunc onDisappear(perform: (() -> Void)?) -> some View\nAdds an action to perform after this view disappears.\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes.\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes.\nfunc task(priority: TaskPriority, () async -> Void) -> some View\nAdds an asynchronous task to perform before this view appears.\nfunc task<T>(id: T, priority: TaskPriority, () async -> Void) -> some View\nAdds a task to perform before this view appears or when a specified value changes.\nFile renaming\nfunc renameAction(() -> Void) -> some View\nSets a closure to run for the rename action.\nfunc renameAction(FocusState<Bool>.Binding) -> some View\nSets the rename action in the environment to update focus state.\nURLs\nfunc onOpenURL(perform: (URL) -> ()) -> some View\nRegisters a handler to invoke when the view receives a url for the scene or window the view is in.\nfunc widgetURL(URL?) -> some View\nSets the URL to open in the containing app when the user clicks the widget.\nPublisher events\nfunc onReceive<P>(P, perform: (P.Output) -> Void) -> some View\nAdds an action to perform when this view detects data emitted by the given publisher.\nHit testing\nfunc allowsHitTesting(Bool) -> some View\nConfigures whether this view participates in hit test operations.\nContent shape\nfunc contentShape<S>(S, eoFill: Bool) -> some View\nDefines the content shape for hit testing.\nfunc contentShape<S>(ContentShapeKinds, S, eoFill: Bool) -> some View\nSets the content shape for this view.\nImport and export\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider]) -> some View\nExports a read-only item provider for consumption by shortcuts, quick actions, and services.\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider], onEdit: ([NSItemProvider]) -> Bool) -> some View\nExports a read-write item provider for consumption by shortcuts, quick actions, and services.\nfunc importsItemProviders([UTType], onImport: ([NSItemProvider]) -> Bool) -> some View\nEnables importing item providers from services, such as Continuity Camera on macOS.\nfunc exportableToServices<T>(() -> [T]) -> some View\nExports items for consumption by shortcuts, quick actions, and services.\nfunc exportableToServices<T>(() -> [T], onEdit: ([T]) -> Bool) -> some View\nExports read-write items for consumption by shortcuts, quick actions, and services.\nfunc importableFromServices<T>(for: T.Type, action: ([T]) -> Bool) -> some View\nEnables importing items from services, such as Continuity Camera on macOS.\nApp intents\nfunc shortcutsLinkStyle(ShortcutsLinkStyle) -> some View\nSets the given style for ShortcutsLinks within the view hierarchy\nfunc siriTipViewStyle(SiriTipViewStyle) -> some View\nSets the given style for SiriTipView within the view hierarchy\nSee Also\nProviding interactivity\nSearch modifiers\nEnable people to search for content in your app.\nPresentation modifiers\nDefine additional views for the view to present under specified conditions.\nState modifiers\nAccess storage and provide child views with configuration data."
    },
    {
        "title": "hoverEffect(_:isEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/hovereffect(_:isenabled:)",
        "html": "Parameters\neffect\n\nThe effect to apply to this view.\n\nisEnabled\n\nWhether the effect is enabled or not.\n\nReturn Value\n\nA new view that applies a hover effect to self.\n\nDiscussion\n\nBy default, automatic is used. You can control the behavior of the automatic effect with the defaultHoverEffect(_:) modifier.\n\nSee Also\nResponding to hover events\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed.\nenum HoverPhase\nThe current hovering state and value of the pointer."
    },
    {
        "title": "defaultHoverEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/defaulthovereffect(_:)",
        "html": "Parameters\neffect\n\nThe default hover effect to use for views within this view.\n\nReturn Value\n\nA view that uses this effect as the default hover effect.\n\nDiscussion\n\nUse this modifier to set a specific hover effect for all views with the hoverEffect(_:) modifier applied within a view. The default effect is typically used when no HoverEffect was provided or if automatic is specified.\n\nFor example, this view uses highlight for both the red and green Color views:\n\nHStack {\n    Color.red.hoverEffect()\n    Color.green.hoverEffect()\n}\n.defaultHoverEffect(.highlight)\n\n\nThis also works for customizing the default hover effect in views like Buttons when using a SwiftUI-defined style like ButtonStyle/bordered, which can provide a hover effect by default. For example, this view replaces the hover effect for a Button with highlight:\n\nButton(\"Next\") {}\n    // perform action\n}\n.buttonStyle(.bordered)\n.defaultHoverEffect(.highlight)\n\n\nUse a nil effect to indicate that the default hover effect should not be modified.\n\nSee Also\nResponding to hover events\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed.\nenum HoverPhase\nThe current hovering state and value of the pointer."
    },
    {
        "title": "stroke(_:style:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/stroke(_:style:antialiased:)",
        "html": "Parameters\ncontent\n\nThe color or gradient with which to stroke this shape.\n\nstyle\n\nThe stroke characteristics \u2014 such as the line\u2019s width and whether the stroke is dashed \u2014 that determine how to render this shape.\n\nReturn Value\n\nA stroked shape.\n\nDiscussion\n\nThe following example adds a dashed purple stroke to a Capsule:\n\nCapsule()\n.stroke(\n    Color.purple,\n    style: StrokeStyle(\n        lineWidth: 5,\n        lineCap: .round,\n        lineJoin: .miter,\n        miterLimit: 0,\n        dash: [5, 10],\n        dashPhase: 0\n    )\n)\n\nSee Also\nSetting the stroke characteristics\nfunc stroke<S>(S, lineWidth: CGFloat) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(lineWidth: CGFloat) -> some Shape\nReturns a new shape that is a stroked copy of self with line-width defined by lineWidth and all other properties of StrokeStyle having their default values.\nfunc stroke<S>(S, style: StrokeStyle) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke(style: StrokeStyle) -> some Shape\nReturns a new shape that is a stroked copy of self, using the contents of style to define the stroke characteristics."
    },
    {
        "title": "stroke(lineWidth:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/stroke(linewidth:)",
        "html": "See Also\nSetting the stroke characteristics\nfunc stroke<S>(S, lineWidth: CGFloat) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(style: StrokeStyle) -> some Shape\nReturns a new shape that is a stroked copy of self, using the contents of style to define the stroke characteristics."
    },
    {
        "title": "EllipticalGradient",
        "url": "https://developer.apple.com/documentation/swiftui/ellipticalgradient",
        "html": "Overview\n\nThe gradient maps its coordinate space to the unit space square in which its center and radii are defined, then stretches that square to fill its bounding rect, possibly also stretching the circular gradient to have elliptical contours.\n\nFor example, an elliptical gradient centered on the view, filling its bounds:\n\nEllipticalGradient(gradient: .init(colors: [.red, .yellow]))\n\n\nWhen using an elliptical gradient as a shape style, you can also use ellipticalGradient(_:center:startRadiusFraction:endRadiusFraction:).\n\nTopics\nCreating an elliptical gradient\ninit(gradient: Gradient, center: UnitPoint, startRadiusFraction: CGFloat, endRadiusFraction: CGFloat)\nCreates an elliptical gradient.\ninit(colors: [Color], center: UnitPoint, startRadiusFraction: CGFloat, endRadiusFraction: CGFloat)\nCreates an elliptical gradient from a collection of colors.\ninit(stops: [Gradient.Stop], center: UnitPoint, startRadiusFraction: CGFloat, endRadiusFraction: CGFloat)\nCreates an elliptical gradient from a collection of color stops.\nRelationships\nConforms To\nSendable\nShapeStyle\nView\nSee Also\nSupporting types\nstruct AngularGradient\nAn angular gradient.\nstruct LinearGradient\nA linear gradient.\nstruct RadialGradient\nA radial gradient.\nstruct Material\nA background material type.\nstruct ImagePaint\nA shape style that fills a shape by repeating a region of an image.\nstruct HierarchicalShapeStyle\nA shape style that maps to one of the numbered content styles.\nstruct HierarchicalShapeStyleModifier\nStyles that you can apply to hierarchical shapes.\nstruct ForegroundStyle\nThe foreground style in the current context.\nstruct BackgroundStyle\nThe background style in the current context.\nstruct SelectionShapeStyle\nA style used to visually indicate selection following platform conventional colors and behaviors.\nstruct SeparatorShapeStyle\nA style appropriate for foreground separator or border lines.\nstruct TintShapeStyle\nA style that reflects the current tint color.\nstruct FillShapeStyle\nA shape style that displays one of the overlay fills.\nstruct LinkShapeStyle\nA style appropriate for links.\nstruct PlaceholderTextShapeStyle\nA style appropriate for placeholder text.\nstruct WindowBackgroundShapeStyle\nA style appropriate for elements that should match the background of their containing window."
    },
    {
        "title": "Deprecated modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-deprecated",
        "html": "Overview\n\nAvoid using deprecated modifiers in your app. Select a modifier to see the replacement that you should use instead.\n\nTopics\nAccessibility modifiers\nfunc accessibility(label: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nDeprecated\nfunc accessibility(value: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nDeprecated\nfunc accessibility(hidden: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSpecifies whether to hide this view from system accessibility features.\nDeprecated\nfunc accessibility(identifier: String) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nUses the specified string to identify the view.\nDeprecated\nfunc accessibility(selectionIdentifier: AnyHashable) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets a selection identifier for this view\u2019s accessibility element.\nDeprecated\nfunc accessibility(hint: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nDeprecated\nfunc accessibility(activationPoint: UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSpecifies the unit point where activations occur in the view.\nDeprecated\nfunc accessibility(activationPoint: CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSpecifies the point where activations occur in the view.\nDeprecated\nfunc accessibility(inputLabels: [Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nDeprecated\nfunc accessibility(addTraits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds the given traits to the view.\nDeprecated\nfunc accessibility(removeTraits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nRemoves the given traits from this view.\nDeprecated\nfunc accessibility(sortPriority: Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the sort priority order for this view\u2019s accessibility element, relative to other elements at the same level.\nDeprecated\nAppearance modifiers\nfunc colorScheme(ColorScheme) -> some View\nSets this view\u2019s color scheme.\nDeprecated\nfunc listRowPlatterColor(Color?) -> some View\nSets the color that the system applies to the row background when this view is placed in a list.\nDeprecated\nfunc background<Background>(Background, alignment: Alignment) -> some View\nLayers the given view behind this view.\nDeprecated\nfunc overlay<Overlay>(Overlay, alignment: Alignment) -> some View\nLayers a secondary view in front of this view.\nDeprecated\nfunc foregroundColor(Color?) -> some View\nSets the color of the foreground elements displayed by this view.\nDeprecated\nText modifiers\nfunc autocapitalization(UITextAutocapitalizationType) -> some View\nSets whether to apply auto-capitalization to this view.\nDeprecated\nfunc disableAutocorrection(Bool?) -> some View\nSets whether to disable autocorrection for this view.\nDeprecated\nAuxiliary view modifiers\nfunc navigationBarTitle(Text) -> some View\nSets the title in the navigation bar for this view.\nDeprecated\nfunc navigationBarTitle(Text, displayMode: NavigationBarItem.TitleDisplayMode) -> some View\nSets the title and display mode in the navigation bar for this view.\nDeprecated\nfunc navigationBarTitle(LocalizedStringKey) -> some View\nSets the title of this view\u2019s navigation bar with a localized string.\nDeprecated\nfunc navigationBarTitle<S>(S) -> some View\nSets the title of this view\u2019s navigation bar with a string.\nDeprecated\nfunc navigationBarTitle(LocalizedStringKey, displayMode: NavigationBarItem.TitleDisplayMode) -> some View\nSets the title and display mode in the navigation bar for this view.\nDeprecated\nfunc navigationBarTitle<S>(S, displayMode: NavigationBarItem.TitleDisplayMode) -> some View\nSets the title and display mode in the navigation bar for this view.\nDeprecated\nfunc navigationBarItems<L>(leading: L) -> some View\nSets the navigation bar items for this view.\nDeprecated\nfunc navigationBarItems<L, T>(leading: L, trailing: T) -> some View\nSets the navigation bar items for this view.\nDeprecated\nfunc navigationBarItems<T>(trailing: T) -> some View\nConfigures the navigation bar items for this view.\nDeprecated\nfunc navigationBarHidden(Bool) -> some View\nHides the navigation bar for this view.\nDeprecated\nfunc statusBar(hidden: Bool) -> some View\nSets the visibility of the status bar.\nDeprecated\nfunc contextMenu<MenuItems>(ContextMenu<MenuItems>?) -> some View\nAdds a context menu to the view.\nDeprecated\nStyle modifiers\nfunc menuButtonStyle<S>(S) -> some View\nSets the style for menu buttons within this view.\nDeprecated\nfunc navigationViewStyle<S>(S) -> some View\nSets the style for navigation views within this view.\nDeprecated\nLayout modifiers\nfunc frame() -> some View\nPositions this view within an invisible frame.\nDeprecated\nfunc edgesIgnoringSafeArea(Edge.Set) -> some View\nChanges the view\u2019s proposed area to extend outside the screen\u2019s safe areas.\nDeprecated\nfunc coordinateSpace<T>(name: T) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nDeprecated\nGraphics and rendering modifiers\nfunc accentColor(Color?) -> some View\nSets the accent color for this view and the views it contains.\nDeprecated\nfunc mask<Mask>(Mask) -> some View\nMasks this view using the alpha channel of the given view.\nDeprecated\nfunc animation(Animation?) -> some View\nApplies the given animation to all animatable values within this view.\nDeprecated\nfunc cornerRadius(CGFloat, antialiased: Bool) -> some View\nClips this view to its bounding frame, with the specified corner radius.\nDeprecated\nInput and events modifiers\nfunc onChange<V>(of: V, perform: (V) -> Void) -> some View\nAdds an action to perform when the given value changes.\nDeprecated\nfunc onTapGesture(count: Int, coordinateSpace: CoordinateSpace, perform: (CGPoint) -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture, and provides the action with the location of the interaction.\nDeprecated\nfunc onLongPressGesture(minimumDuration: Double, maximumDistance: CGFloat, pressing: ((Bool) -> Void)?, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nDeprecated\nfunc onLongPressGesture(minimumDuration: Double, pressing: ((Bool) -> Void)?, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nDeprecated\nfunc onPasteCommand(of: [String], perform: ([NSItemProvider]) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command.\nDeprecated\nfunc onPasteCommand<Payload>(of: [String], validator: ([NSItemProvider]) -> Payload?, perform: (Payload) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command with items that you validate.\nDeprecated\nfunc onDrop(of: [String], delegate: DropDelegate) -> some View\nDefines the destination for a drag and drop operation with the same size and position as this view, with behavior controlled by the given delegate.\nDeprecated\nfunc onDrop(of: [String], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination for a drag and drop operation, using the same size and position as this view, handling dropped content with the given closure.\nDeprecated\nfunc onDrop(of: [String], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination for a drag and drop operation with the same size and position as this view, handling dropped content and the drop location with the given closure.\nDeprecated\nfunc focusable(Bool, onFocusChange: (Bool) -> Void) -> some View\nSpecifies if the view is focusable and, if so, adds an action to perform when the view comes into focus.\nDeprecated\nfunc onContinuousHover(coordinateSpace: CoordinateSpace, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nDeprecated\nView presentation modifiers\nfunc actionSheet(isPresented: Binding<Bool>, content: () -> ActionSheet) -> some View\nPresents an action sheet when a given condition is true.\nDeprecated\nfunc actionSheet<T>(item: Binding<T?>, content: (T) -> ActionSheet) -> some View\nPresents an action sheet using the given item as a data source for the sheet\u2019s content.\nDeprecated\nfunc alert(isPresented: Binding<Bool>, content: () -> Alert) -> some View\nPresents an alert to the user.\nDeprecated\nfunc alert<Item>(item: Binding<Item?>, content: (Item) -> Alert) -> some View\nPresents an alert to the user.\nDeprecated\nSearch modifiers\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?, suggestions: () -> S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, suggestions: () -> S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<V, S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S, suggestions: () -> V) -> some View\nMarks this view as searchable, which configures the display of a search field."
    },
    {
        "title": "DisclosureGroupStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/disclosuregroupstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the label\nlet label: DisclosureGroupStyleConfiguration.Label\nThe label for the disclosure group."
    },
    {
        "title": "Search modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-search",
        "html": "Overview\n\nUse search view modifiers to add search capability to your app. For more information, see Search.\n\nTopics\nDisplaying a search interface\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> some View\nConfigures the search toolbar presentation behavior for any searchable modifiers within this view.\nSearching with tokens\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nSearching with editable tokens\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nMaking search suggestions\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nLimiting search scope\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> some View\nConfigures the search scopes for this view.\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> some View\nConfigures the search scopes for this view with the specified activation strategy.\nSearching through dictation\nfunc searchDictationBehavior(TextInputDictationBehavior) -> some View\nSee Also\nProviding interactivity\nInput and event modifiers\nSupply actions for a view to perform in response to user input and system events.\nPresentation modifiers\nDefine additional views for the view to present under specified conditions.\nState modifiers\nAccess storage and provide child views with configuration data."
    },
    {
        "title": "Layout modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-layout",
        "html": "Overview\n\nUse layout modifiers to fine tune the placement of views in a view hierarchy. You can adjust or constrain the size, position, and alignment of a view. You can also add padding around a view, and indicate how the view interacts with system-defined safe areas.\n\nTo get started arranging views, see Layout fundamentals. To make adjustments to a basic layout, see Layout adjustments.\n\nTopics\nSize\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child.\nPosition\nfunc position(CGPoint) -> some View\nPositions the center of this view at the specified point in its parent\u2019s coordinate space.\nfunc position(x: CGFloat, y: CGFloat) -> some View\nPositions the center of this view at the specified coordinates in its parent\u2019s coordinate space.\nfunc offset(CGSize) -> some View\nOffset this view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(x: CGFloat, y: CGFloat) -> some View\nOffset this view by the specified horizontal and vertical distances.\nfunc offset(z: CGFloat) -> some View\nBrings a view forward in Z by the provided distance in points.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nAlignment\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nPadding and spacing\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc listRowInsets(EdgeInsets?) -> some View\nApplies an inset to the rows in a list.\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc listRowSpacing(CGFloat?) -> some View\nSets the vertical spacing between two adjacent rows in a List.\nfunc listSectionSpacing(CGFloat) -> some View\nSets the spacing to a custom value between adjacent sections in a List.\nfunc listSectionSpacing(ListSectionSpacing) -> some View\nSets the spacing between adjacent sections in a List.\nGrid configuration\nfunc gridCellColumns(Int) -> some View\nTells a view that acts as a cell in a grid to span the specified number of columns.\nfunc gridCellAnchor(UnitPoint) -> some View\nSpecifies a custom alignment anchor for a view that acts as a grid cell.\nfunc gridCellUnsizedAxes(Axis.Set) -> some View\nAsks grid layouts not to offer the view extra size in the specified axes.\nfunc gridColumnAlignment(HorizontalAlignment) -> some View\nOverrides the default horizontal alignment of the grid column that the view appears in.\nSafe area and margins\nfunc ignoresSafeArea(SafeAreaRegions, edges: Edge.Set) -> some View\nExpands the view out of its safe area.\nfunc safeAreaInset<V>(edge: HorizontalEdge, alignment: VerticalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content beside the modified view.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(EdgeInsets) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(CGFloat) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> some View\nAdds the provided insets into the safe area of this view.\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nLayer order\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nLayout direction\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> some View\nSets the behavior of this view for different layout directions.\nCustom layout characteristics\nfunc layoutValue<K>(key: K.Type, value: K.Value) -> some View\nAssociates a value with a custom layout property.\nSee Also\nDrawing views\nStyle modifiers\nApply built-in styles to different types of views.\nGraphics and rendering modifiers\nAffect the way the system draws a view, for example by scaling or masking a view, or by applying graphical effects."
    },
    {
        "title": "EditableCollectionContent",
        "url": "https://developer.apple.com/documentation/swiftui/editablecollectioncontent",
        "html": "Overview\n\nYou don\u2019t use this type directly. Instead SwiftUI creates this type on your behalf.\n\nRelationships\nConforms To\nView\nConforms when Content conforms to View.\nSee Also\nEditing a list\nfunc moveDisabled(Bool) -> some View\nAdds a condition for whether the view\u2019s view hierarchy is movable.\nfunc deleteDisabled(Bool) -> some View\nAdds a condition for whether the view\u2019s view hierarchy is deletable.\nvar editMode: Binding<EditMode>?\nAn indication of whether the user can edit the contents of a view associated with this environment.\nenum EditMode\nA mode that indicates whether the user can edit a view\u2019s content.\nstruct EditActions\nA set of edit actions on a collection of data that a view can offer to a user.\nstruct IndexedIdentifierCollection\nA collection wrapper that iterates over the indices and identifiers of a collection together."
    },
    {
        "title": "FormStyleConfiguration.Content",
        "url": "https://developer.apple.com/documentation/swiftui/formstyleconfiguration/content-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nGetting configuration content\nlet content: FormStyleConfiguration.Content\nA view that is the content of the form."
    },
    {
        "title": "State modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-state",
        "html": "Overview\n\nSwiftUI provides tools for managing data in your app. For example, you can store values and objects in an environment that\u2019s shared among the views in a view hierarchy. Any view that shares the environment \u2014 typically all the descendant views of the view that stores the item \u2014 can then access the stored item.\n\nFor more information about the types that SwiftUI provides to help manage data in your app, see Model data.\n\nTopics\nIdentity\nfunc tag<V>(V) -> some View\nSets the unique tag value of this view.\nfunc id<ID>(ID) -> some View\nBinds a view\u2019s identity to the given proxy value.\nfunc equatable() -> EquatableView<Self>\nPrevents the view from updating its child view when its new value is the same as its old value.\nAvailable when Self conforms to Equatable.\nEnvironment values\nfunc environment<T>(T?) -> some View\nPlaces an observable object in the view\u2019s environment.\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some View\nSets the environment value of the specified key path to the given value.\nfunc environmentObject<T>(T) -> some View\nSupplies an observable object to a view\u2019s hierarchy.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some View\nTransforms the environment value of the specified key path with the given function.\nPreferences\nfunc preference<K>(key: K.Type, value: K.Value) -> some View\nSets a value for the given preference.\nfunc transformPreference<K>(K.Type, (inout K.Value) -> Void) -> some View\nApplies a transformation to a preference value.\nfunc anchorPreference<A, K>(key: K.Type, value: Anchor<A>.Source, transform: (Anchor<A>) -> K.Value) -> some View\nSets a value for the specified preference key, the value is a function of a geometry value tied to the current coordinate space, allowing readers of the value to convert the geometry to their local coordinates.\nfunc transformAnchorPreference<A, K>(key: K.Type, value: Anchor<A>.Source, transform: (inout K.Value, Anchor<A>) -> Void) -> some View\nSets a value for the specified preference key, the value is a function of the key\u2019s current value and a geometry value tied to the current coordinate space, allowing readers of the value to convert the geometry to their local coordinates.\nfunc onPreferenceChange<K>(K.Type, perform: (K.Value) -> Void) -> some View\nAdds an action to perform when the specified preference key\u2019s value changes.\nfunc backgroundPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc backgroundPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc overlayPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view.\nfunc overlayPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view.\nDefault storage\nfunc defaultAppStorage(UserDefaults) -> some View\nThe default store used by AppStorage contained within the view.\nConfiguring a model\nfunc modelContext(ModelContext) -> some View\nSets the model context in this view\u2019s environment.\nfunc modelContainer(ModelContainer) -> some View\nSets the model container and associated model context in this view\u2019s environment.\nfunc modelContainer(for: PersistentModel.Type, inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some View\nSets the model container in this view for storing the provided model type, creating a new container if necessary, and also sets a model context for that container in this view\u2019s environment.\nfunc modelContainer(for: [PersistentModel.Type], inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some View\nSets the model container in this view for storing the provided model types, creating a new container if necessary, and also sets a model context for that container in this view\u2019s environment.\nSee Also\nProviding interactivity\nInput and event modifiers\nSupply actions for a view to perform in response to user input and system events.\nSearch modifiers\nEnable people to search for content in your app.\nPresentation modifiers\nDefine additional views for the view to present under specified conditions."
    },
    {
        "title": "Appearance modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-appearance",
        "html": "Overview\n\nUse these modifiers to configure the appearance of a view, including the use of color and tint, and the application of overlays and background elements. Control the visibility of a view and specific elements within a view. Manage the shape and size of various controls.\n\nFor information about configuring views, see View configuration.\n\nTopics\nColors and patterns\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc allowedDynamicRange(Image.DynamicRange?) -> some View\nReturns a new view configured with the specified allowed dynamic range.\nTint\nfunc tint<S>(S?) -> some View\nSets the tint within this view.\nfunc tint(Color?) -> some View\nSets the tint color within this view.\nfunc listRowSeparatorTint(Color?, edges: VerticalEdge.Set) -> some View\nSets the tint color associated with a row.\nfunc listSectionSeparatorTint(Color?, edges: VerticalEdge.Set) -> some View\nSets the tint color associated with a section.\nfunc listItemTint(Color?) -> some View\nSets a fixed tint color associated with specific content in a list.\nfunc listItemTint(ListItemTint?) -> some View\nSets the tint effect for content in a list.\nLight and dark appearance\nfunc preferredColorScheme(ColorScheme?) -> some View\nSets the preferred color scheme for this presentation.\nfunc preferredSurroundingsEffect(SurroundingsEffect?) -> some View\nSets the preferred video passthrough effect of the user\u2019s surroundings.\nBeta\nForeground elements\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nBackground elements\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc alternatingRowBackgrounds(AlternatingRowBackgroundBehavior) -> some View\nOverrides whether lists and tables in this view have alternating row backgrounds.\nfunc listRowBackground<V>(V?) -> some View\nPlaces a custom background view behind a list row item.\nfunc scrollContentBackground(Visibility) -> some View\nSpecifies the visibility of the background for scrollable views within this view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nfunc glassBackgroundEffect(displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material that\u2019s shaped as a container-relative rounded rectangle.\nBeta\nfunc glassBackgroundEffect<S>(in: S, displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material using a shape that you specify.\nBeta\nControl configuration\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nfunc controlSize(ControlSize) -> some View\nSets the size for controls within this view.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nfunc headerProminence(Prominence) -> some View\nSets the header prominence for this view.\nfunc scrollDisabled(Bool) -> some View\nDisables or enables scrolling in scrollable views.\nfunc scrollBounceBehavior(ScrollBounceBehavior, axes: Axis.Set) -> some View\nConfigures the bounce behavior of scrollable views along the specified axis.\nfunc scrollIndicatorsFlash(onAppear: Bool) -> some View\nFlashes the scroll indicators of a scrollable view when it appears.\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> some View\nFlashes the scroll indicators of scrollable views when a value changes.\nfunc menuOrder(MenuOrder) -> some View\nSets the preferred order of items for menus presented from this view.\nfunc menuActionDismissBehavior(MenuActionDismissBehavior) -> some View\nTells a menu whether to dismiss after performing an action.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item.\nfunc typeSelectEquivalent(Text?) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nfunc typeSelectEquivalent(LocalizedStringKey) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nfunc typeSelectEquivalent<S>(S) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nSymbol effects\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffectsRemoved(Bool) -> some View\nReturns a new view with its inherited symbol image effects either removed or left unchanged.\nPrivacy and redaction\nfunc privacySensitive(Bool) -> some View\nMarks the view as containing sensitive, private user data.\nfunc redacted(reason: RedactionReasons) -> some View\nAdds a reason to apply a redaction to this view hierarchy.\nfunc unredacted() -> some View\nRemoves any reason to apply a redaction to this view hierarchy.\nfunc invalidatableContent(Bool) -> some View\nMark the receiver as their content might be invalidated.\nVisibility\nfunc hidden() -> some View\nHides this view unconditionally.\nfunc labelsHidden() -> some View\nHides the labels of any controls contained within this view.\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view.\nfunc listRowSeparator(Visibility, edges: VerticalEdge.Set) -> some View\nSets the display mode for the separator associated with this specific row.\nfunc listSectionSeparator(Visibility, edges: VerticalEdge.Set) -> some View\nSets whether to hide the separator associated with a list section.\nfunc persistentSystemOverlays(Visibility) -> some View\nSets the preferred visibility of the non-transient system views overlaying the app.\nfunc scrollIndicators(ScrollIndicatorVisibility, axes: Axis.Set) -> some View\nSets the visibility of scroll indicators within this view.\nfunc scrollClipDisabled(Bool) -> some View\nSets whether a scroll view clips its content to its bounds.\nfunc tableColumnHeaders(Visibility) -> some View\nControls the visibility of a Table\u2019s column header views.\nfunc upperLimbVisibility(Visibility) -> some View\nSets the preferred visibility of the user\u2019s upper limbs, while an ImmersiveSpace scene is presented.\nBeta\nSensory feedback\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> some View\nPlays the specified feedback when the provided trigger value changes.\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> some View\nPlays feedback when returned from the feedback closure after the provided trigger value changes.\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> some View\nPlays the specified feedback when the provided trigger value changes and the condition closure returns true.\nWidget configuration\nfunc widgetAccentable(Bool) -> some View\nAdds the view and all of its subviews to the accented group.\nfunc widgetCurvesContent(Bool) -> some View\nDisplays the widget\u2019s content along a curve if the context allows it.\nfunc widgetLabel<S>(S) -> some View\nReturns a text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view.\nfunc widgetLabel(LocalizedStringKey) -> some View\nReturns a localized text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view.\nfunc widgetLabel<Label>(label: () -> Label) -> some View\nCreates a label for displaying additional content outside an accessory family widget\u2019s main SwiftUI view.\nfunc dynamicIsland(verticalPlacement: DynamicIslandExpandedRegionVerticalPlacement) -> some View\nSpecifies the vertical placement for a view of an expanded Live Activity that appears in the Dynamic Island.\nSee Also\nConfiguring view elements\nAccessibility modifiers\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nText and symbol modifiers\nManage the rendering, selection, and entry of text in your view.\nAuxiliary view modifiers\nAdd and configure supporting views, like toolbars and context menus.\nChart view modifiers\nConfigure charts that you declare with Swift Charts."
    },
    {
        "title": "Text and symbol modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-text-and-symbols",
        "html": "Overview\n\nSwiftUI provides built-in views that display text to the user, like Text and Label, or that collect text from the user, like TextField and TextEditor. Use text and symbol modifiers to control how SwiftUI displays and manages that text. For example, you can set a font, specify text layout parameters, and indicate what kind of input to expect.\n\nTo learn more about the kinds of views that you use to display text and the ways in which you can configure those views, see Text input and output.\n\nTopics\nFonts\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nDynamic type\nfunc dynamicTypeSize(DynamicTypeSize) -> some View\nSets the Dynamic Type size within the view to the given value.\nfunc dynamicTypeSize<T>(T) -> some View\nLimits the Dynamic Type size within the view to the given range.\nText style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nfunc textScale(Text.Scale, isEnabled: Bool) -> some View\nApplies a text scale to text in the view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nText layout\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nMultiline text\nfunc lineLimit(Int?) -> some View\nSets the maximum number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeFrom<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeThrough<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(ClosedRange<Int>) -> some View\nSets to a closed range the number of lines that text can occupy in this view.\nfunc lineLimit(Int, reservesSpace: Bool) -> some View\nSets a limit for the number of lines text can occupy in this view.\nfunc lineSpacing(CGFloat) -> some View\nSets the amount of space between lines of text in this view.\nfunc multilineTextAlignment(TextAlignment) -> some View\nSets the alignment of a text view that contains multiple lines of text.\nText selection\nfunc textSelection<S>(S) -> some View\nControls whether people can select text within this view.\nText entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nFind and replace\nfunc findNavigator(isPresented: Binding<Bool>) -> some View\nProgrammatically presents the find and replace interface for text editor views.\nfunc findDisabled(Bool) -> some View\nPrevents find and replace operations in a text editor.\nfunc replaceDisabled(Bool) -> some View\nPrevents replace operations in a text editor.\nSymbol appearance\nfunc symbolRenderingMode(SymbolRenderingMode?) -> some View\nSets the rendering mode for symbol images within this view.\nfunc symbolVariant(SymbolVariants) -> some View\nMakes symbols within the view show a particular variant.\nSee Also\nConfiguring view elements\nAccessibility modifiers\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAppearance modifiers\nConfigure a view\u2019s foreground and background styles, controls, and visibility.\nAuxiliary view modifiers\nAdd and configure supporting views, like toolbars and context menus.\nChart view modifiers\nConfigure charts that you declare with Swift Charts."
    },
    {
        "title": "Style modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-style-modifiers",
        "html": "Overview\n\nSwiftUI defines built-in styles for certain kinds of views, and chooses the appropriate style for a particular presentation context. For example, a Label might appear as an icon, a string title, or both, depending on factors like the platform, whether the view appears in a toolbar, and so on.\n\nYou can override the automatic style by using one of the style modifiers. These modifiers typically propagate through container views, so you can wrap an entire view hierarchy in a style modifier to affect all the views of the given type within the hierarchy. Some view types enable you to create custom styles, which you also apply using style modifiers.\n\nFor more information about styling views, see View styles.\n\nTopics\nControls\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nfunc menuStyle<S>(S) -> some View\nSets the style for menus within this view.\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy.\nIndicators\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nText\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nfunc textEditorStyle(some TextEditorStyle) -> some View\nSets the style for text editors within this view.\nCollections\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view.\nPresentation\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc tabViewStyle<S>(S) -> some View\nSets the style for the tab view within the current environment.\nfunc presentedWindowStyle<S>(S) -> some View\nSets the style for windows created by interacting with this view.\nfunc presentedWindowToolbarStyle<S>(S) -> some View\nSets the style for the toolbar in windows created by interacting with this view.\nGroups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nSee Also\nDrawing views\nLayout modifiers\nTell a view how to arrange itself within a view hierarchy by adjusting its size, position, alignment, padding, and so on.\nGraphics and rendering modifiers\nAffect the way the system draws a view, for example by scaling or masking a view, or by applying graphical effects."
    },
    {
        "title": "SubmitLabel",
        "url": "https://developer.apple.com/documentation/swiftui/submitlabel",
        "html": "Overview\n\nA submit label is a description of a submission action provided to a view hierarchy using the onSubmit(of:_:) modifier.\n\nTopics\nGetting submission labels\nstatic var `continue`: SubmitLabel\nDefines a submit label with text of \u201cContinue\u201d.\nstatic var done: SubmitLabel\nDefines a submit label with text of \u201cDone\u201d.\nstatic var go: SubmitLabel\nDefines a submit label with text of \u201cGo\u201d.\nstatic var join: SubmitLabel\nDefines a submit label with text of \u201cJoin\u201d.\nstatic var next: SubmitLabel\nDefines a submit label with text of \u201cNext\u201d.\nstatic var `return`: SubmitLabel\nDefines a submit label with text of \u201cReturn\u201d.\nstatic var route: SubmitLabel\nDefines a submit label with text of \u201cRoute\u201d.\nstatic var search: SubmitLabel\nDefines a submit label with text of \u201cSearch\u201d.\nstatic var send: SubmitLabel\nDefines a submit label with text of \u201cSend\u201d.\nRelationships\nConforms To\nSendable\nSee Also\nLabeling a submission event\nfunc submitLabel(SubmitLabel) -> some View\nSets the submit label for this view."
    },
    {
        "title": "Section",
        "url": "https://developer.apple.com/documentation/swiftui/section",
        "html": "Overview\n\nUse Section instances in views like List, Picker, and Form to organize content into separate sections. Each section has custom content that you provide on a per-instance basis. You can also provide headers and footers for each section.\n\nCollapsible sections\n\nCreate sections that expand and collapse by using an initializer that accepts an isExpanded binding. A collapsible section in a List that uses the sidebar style shows a disclosure indicator next to the section\u2019s header. Tapping on the disclosure indicator toggles the appearance of the section\u2019s content.\n\nNote\n\nNot all contexts provide a default control to trigger collapse or expansion.\n\nTopics\nCreating a section\ninit<V>(content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent conforms to TableRowContent, Content conforms to TableRowContent, and Footer conforms to TableRowContent.\ninit(content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent is EmptyView, Content conforms to View, and Footer is EmptyView.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent is Text, Content conforms to View, and Footer is EmptyView.\ninit<S>(S, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent is Text, Content conforms to View, and Footer is EmptyView.\ninit<V, S>(S, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent conforms to TableRowContent, Content conforms to TableRowContent, and Footer conforms to TableRowContent.\ninit<V>(LocalizedStringKey, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent conforms to TableRowContent, Content conforms to TableRowContent, and Footer conforms to TableRowContent.\nAdding headers and footers\ninit(content: () -> Content, header: () -> Parent)\nCreates a section with a header and the provided section content.\nAvailable when Parent conforms to View, Content conforms to View, and Footer is EmptyView.\ninit<V, H>(content: () -> Content, header: () -> H)\nCreates a section with a header and the provided section content.\nAvailable when Parent conforms to TableRowContent, Content conforms to TableRowContent, and Footer conforms to TableRowContent.\ninit(content: () -> Content, footer: () -> Footer)\nCreates a section with a footer and the provided section content.\nAvailable when Parent is EmptyView, Content conforms to View, and Footer conforms to View.\ninit(content: () -> Content, header: () -> Parent, footer: () -> Footer)\nCreates a section with a header, footer, and the provided section content.\nAvailable when Parent conforms to View, Content conforms to View, and Footer conforms to View.\nControlling collapsibility\ninit<V, S>(S, isExpanded: Binding<Bool>, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent conforms to TableRowContent and Content conforms to TableRowContent.\ninit<S>(S, isExpanded: Binding<Bool>, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent is Text, Content conforms to View, and Footer is EmptyView.\ninit<V>(LocalizedStringKey, isExpanded: Binding<Bool>, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent conforms to TableRowContent and Content conforms to TableRowContent.\ninit(LocalizedStringKey, isExpanded: Binding<Bool>, content: () -> Content)\nCreates a section with the provided section content.\nAvailable when Parent is Text, Content conforms to View, and Footer is EmptyView.\ninit(isExpanded: Binding<Bool>, content: () -> Content, header: () -> Parent)\nCreates a section with a header, the provided section content, and a binding representing the section\u2019s expansion state.\nAvailable when Parent conforms to View, Content conforms to View, and Footer is EmptyView.\ninit<V, H>(isExpanded: Binding<Bool>, content: () -> Content, header: () -> H)\nCreates a section with a header and the provided section content.\nAvailable when Parent conforms to TableRowContent and Content conforms to TableRowContent.\nDeprecated symbols\ninit(header: Parent, content: () -> Content)\nCreates a section with a header and the provided section content.\nAvailable when Parent conforms to View, Content conforms to View, and Footer is EmptyView.\nDeprecated\ninit(footer: Footer, content: () -> Content)\nCreates a section with a footer and the provided section content.\nAvailable when Parent is EmptyView, Content conforms to View, and Footer conforms to View.\nDeprecated\ninit(header: Parent, footer: Footer, content: () -> Content)\nCreates a section with a header, footer, and the provided section content.\nAvailable when Parent conforms to View, Content conforms to View, and Footer conforms to View.\nDeprecated\nfunc collapsible(Bool) -> some View\nSets whether a section can be collapsed by the user.\nAvailable when Parent conforms to View, Content conforms to View, and Footer conforms to View.\nDeprecated\nRelationships\nConforms To\nTableRowContent\nConforms when Parent conforms to TableRowContent, Content conforms to TableRowContent, and Footer conforms to TableRowContent.\nView\nConforms when Parent conforms to View, Content conforms to View, and Footer conforms to View.\nSee Also\nCreating a list\nDisplaying data in lists\nVisualize collections of data with platform-appropriate appearance.\nstruct List\nA container that presents rows of data arranged in a single column, optionally providing the ability to select one or more members.\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view."
    },
    {
        "title": "fill(style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/fill(style:)",
        "html": "Parameters\nstyle\n\nThe style options that determine how the fill renders.\n\nReturn Value\n\nA shape filled with the foreground color.\n\nSee Also\nFilling a shape\nfunc fill<S>(S, style: FillStyle) -> _ShapeView<Self, S>\nFills this shape with a color or gradient.\nfunc fill<S>(S, style: FillStyle) -> some View\nFills this shape with a color or gradient."
    },
    {
        "title": "Path.Element",
        "url": "https://developer.apple.com/documentation/swiftui/path/element",
        "html": "Topics\nGetting path elements\ncase closeSubpath\nA line from the start point of the current subpath (if any) to the current point, which terminates the subpath.\ncase curve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nA cubic B\u00e9zier curve from the previous current point to the given end-point, using the two control points to define the curve.\ncase line(to: CGPoint)\nA line from the previous current point to the given point, which becomes the new current point.\ncase move(to: CGPoint)\nA path element that terminates the current subpath (without closing it) and defines a new current point.\ncase quadCurve(to: CGPoint, control: CGPoint)\nA quadratic B\u00e9zier curve from the previous current point to the given end-point, using the single control point to define the curve.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nOperating over path elements\nfunc forEach((Path.Element) -> Void)\nCalls body with each element in the path."
    },
    {
        "title": "lineSubtraction(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/linesubtraction(_:eofill:)",
        "html": "Parameters\nother\n\nThe shape to subtract.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the shapes (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new shape.\n\nDiscussion\n\nThe line of the resulting shape is the line of this shape that does not overlap the filled region of other.\n\nIntersected subpaths that are clipped create open subpaths. Closed subpaths that do not intersect other remain closed.\n\nSee Also\nPerforming operations on a shape\nfunc intersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions common to both shapes.\nfunc lineIntersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that overlaps the filled regions of the given shape.\nfunc subtracting<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions from this shape that are not in the given shape.\nfunc symmetricDifference<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions either from this shape or the given shape, but not in both.\nfunc union<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions in either this shape or the given shape."
    },
    {
        "title": "role",
        "url": "https://developer.apple.com/documentation/swiftui/shape/role-x85s",
        "html": "Required Default implementation provided.\n\nDiscussion\n\nSwiftUI looks at a shape\u2019s role when deciding how to apply a ShapeStyle at render time. The Shape protocol provides a default implementation with a value of ShapeRole.fill. If you create a composite shape, you can provide an override of this property to return another value, if appropriate.\n\nDefault Implementations\nShape Implementations\nstatic var role: ShapeRole\nAn indication of how to style a shape."
    },
    {
        "title": "layoutDirectionBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/shape/layoutdirectionbehavior-361s6",
        "html": "Required Default implementation provided.\n\nDiscussion\n\nIf the layoutDirectionBehavior for a Shape is one that mirrors, the shape\u2019s path will be mirrored horizontally when in the specified layout direction. When mirrored, the individual points of the path will be transformed.\n\nDefaults to .mirrors when deploying on iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0 and later, and to .fixed if not. To mirror a path when deploying to earlier releases, either use View.flipsForRightToLeftLayoutDirection for a filled or stroked shape or conditionally mirror the points in the path of the shape.\n\nDefault Implementations\nShape Implementations\nvar layoutDirectionBehavior: LayoutDirectionBehavior\nReturns the behavior this shape should use for different layout directions."
    },
    {
        "title": "PresentedWindowContent",
        "url": "https://developer.apple.com/documentation/swiftui/presentedwindowcontent",
        "html": "Overview\n\nYou don\u2019t create this type directly. WindowGroup creates values for you.\n\nRelationships\nConforms To\nView"
    },
    {
        "title": "OutlineSubgroupChildren",
        "url": "https://developer.apple.com/documentation/swiftui/outlinesubgroupchildren",
        "html": "Overview\n\nOutlineGroup uses this type as a generic constraint for the Content of the DisclosureGroup instances it creates.\n\nRelationships\nConforms To\nView"
    },
    {
        "title": "LabeledControlGroupContent",
        "url": "https://developer.apple.com/documentation/swiftui/labeledcontrolgroupcontent",
        "html": "Overview\n\nYou don\u2019t create this type directly. SwiftUI creates it when you build a ControlGroup.\n\nRelationships\nConforms To\nView"
    },
    {
        "title": "shape",
        "url": "https://developer.apple.com/documentation/swiftui/offsetshape/shape",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar offset: CGSize"
    },
    {
        "title": "isAntialiased",
        "url": "https://developer.apple.com/documentation/swiftui/strokeshapeview/isantialiased",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape.\nvar style: Style\nThe style that strokes this view\u2019s shape."
    },
    {
        "title": "fillStyle",
        "url": "https://developer.apple.com/documentation/swiftui/fillshapeview/fillstyle",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar style: Style\nThe style that fills this view\u2019s shape."
    },
    {
        "title": "dashPhase",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle/dashphase",
        "html": "See Also\nSetting stroke style properties\nvar lineWidth: CGFloat\nThe width of the stroked path.\nvar lineCap: CGLineCap\nThe endpoint style of a line.\nvar lineJoin: CGLineJoin\nThe join type of a line.\nvar miterLimit: CGFloat\nA threshold used to determine whether to use a bevel instead of a miter at a join.\nvar dash: [CGFloat]\nThe lengths of painted and unpainted segments used to make a dashed line."
    },
    {
        "title": "capsule(style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/capsule(style:)",
        "html": "Discussion\n\nA capsule shape is equivalent to a rounded rectangle where the corner radius is chosen as half the length of the rectangle\u2019s smallest edge.\n\nSee Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "anchor",
        "url": "https://developer.apple.com/documentation/swiftui/scaledshape/anchor",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar scale: CGSize\nvar shape: Content"
    },
    {
        "title": "containerRelative",
        "url": "https://developer.apple.com/documentation/swiftui/shape/containerrelative",
        "html": "See Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "capsule",
        "url": "https://developer.apple.com/documentation/swiftui/shape/capsule",
        "html": "Discussion\n\nA capsule shape is equivalent to a rounded rectangle where the corner radius is chosen as half the length of the rectangle\u2019s smallest edge.\n\nSee Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "scale",
        "url": "https://developer.apple.com/documentation/swiftui/scaledshape/scale",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar anchor: UnitPoint\nvar shape: Content"
    },
    {
        "title": "buttonBorder",
        "url": "https://developer.apple.com/documentation/swiftui/shape/buttonborder",
        "html": "Discussion\n\nYou can override the resolved shape in a given view hierarchy by using the buttonBorderShape(_:) modifier. If no button border shape is specified, it is resolved automatically for the given context and platform.\n\nSee Also\nGetting standard shapes\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "rect(cornerRadius:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/rect(cornerradius:style:)",
        "html": "See Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "background",
        "url": "https://developer.apple.com/documentation/swiftui/fillshapeview/background",
        "html": "See Also\nGetting shape view properties\nvar fillStyle: FillStyle\nThe fill style used when filling this view\u2019s shape.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar style: Style\nThe style that fills this view\u2019s shape."
    },
    {
        "title": "circle",
        "url": "https://developer.apple.com/documentation/swiftui/shape/circle",
        "html": "Discussion\n\nThe circle\u2019s radius equals half the length of the frame rectangle\u2019s smallest edge.\n\nSee Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "rect(cornerRadii:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/rect(cornerradii:style:)",
        "html": "See Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "rect(topLeadingRadius:bottomLeadingRadius:bottomTrailingRadius:topTrailingRadius:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/rect(topleadingradius:bottomleadingradius:bottomtrailingradius:toptrailingradius:style:)",
        "html": "See Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle."
    },
    {
        "title": "trim(from:to:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/trim(from:to:)",
        "html": "Parameters\nstartFraction\n\nThe fraction of the way through drawing this shape where drawing starts.\n\nendFraction\n\nThe fraction of the way through drawing this shape where drawing ends.\n\nReturn Value\n\nA shape built by capturing a portion of this shape\u2019s path.\n\nDiscussion\n\nTo create a Shape instance, you define the shape\u2019s path using lines and curves. Use the trim(from:to:) method to draw a portion of a shape by ignoring portions of the beginning and ending of the shape\u2019s path.\n\nFor example, if you\u2019re drawing a figure eight or infinity symbol (\u221e) starting from its center, setting the startFraction and endFraction to different values determines the parts of the overall shape.\n\nThe following example shows a simplified infinity symbol that draws only three quarters of the full shape. That is, of the two lobes of the symbol, one lobe is complete and the other is half complete.\n\nPath { path in\n    path.addLines([\n        .init(x: 2, y: 1),\n        .init(x: 1, y: 0),\n        .init(x: 0, y: 1),\n        .init(x: 1, y: 2),\n        .init(x: 3, y: 0),\n        .init(x: 4, y: 1),\n        .init(x: 3, y: 2),\n        .init(x: 2, y: 1)\n    ])\n}\n.trim(from: 0.25, to: 1.0)\n.scale(50, anchor: .topLeading)\n.stroke(Color.black, lineWidth: 3)\n\n\nChanging the parameters of trim(from:to:) to .trim(from: 0, to: 1) draws the full infinity symbol, while .trim(from: 0, to: 0.5) draws only the left lobe of the symbol.\n\nSee Also\nTransforming a shape\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "sizeThatFits(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/sizethatfits(_:)-9r323",
        "html": "Required Default implementation provided.\n\nParameters\nproposal\n\nA size proposal for the container.\n\nReturn Value\n\nA size that indicates how much space the shape needs.\n\nDiscussion\n\nImplement this method to tell the container of the shape how much space the shape needs to render itself, given a size proposal.\n\nSee sizeThatFits(proposal:subviews:cache:) for more details about how the layout system chooses the size of views.\n\nDefault Implementations\nShape Implementations\nfunc sizeThatFits(ProposedViewSize) -> CGSize\nReturns the original proposal, with nil components replaced by a small positive value.\nSee Also\nDefining a shape\u2019s size and path\nfunc path(in: CGRect) -> Path\nDescribes this shape as a path within a rectangular frame of reference.\n\nRequired"
    },
    {
        "title": "transform(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/transform(_:)",
        "html": "Parameters\ntransform\n\nThe affine transformation matrix to apply to this shape.\n\nReturn Value\n\nA transformed shape, based on its matrix values.\n\nDiscussion\n\nAffine transforms present a mathematical approach to applying combinations of rotation, scaling, translation, and skew to shapes.\n\nSee Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "path(in:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/path(in:)",
        "html": "Required\n\nParameters\nrect\n\nThe frame of reference for describing this shape.\n\nReturn Value\n\nA path that describes this shape.\n\nSee Also\nDefining a shape\u2019s size and path\nfunc sizeThatFits(ProposedViewSize) -> CGSize\nReturns the size of the view that will render the shape, given a proposed size.\n\nRequired Default implementation provided."
    },
    {
        "title": "subscriptionStoreControlIcon(icon:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolicon(icon:)",
        "html": "Discussion\n\nYou can adjust this view to provide different appearances for each subscription option.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "storeButton(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/storebutton(_:for:)",
        "html": "Parameters\nvisibility\n\nThe preferred visibility of the buttons.\n\nbuttonKinds\n\nThe kinds of buttons to update visibility of.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "size(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/size(_:)",
        "html": "See Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "scale(x:y:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/scale(x:y:anchor:)",
        "html": "Parameters\nx\n\nThe multiplication factor used to resize this shape along its x-axis.\n\ny\n\nThe multiplication factor used to resize this shape along its y-axis.\n\nReturn Value\n\nA scaled form of this shape.\n\nDiscussion\n\nBoth the x and y multiplication factors halve their respective dimension\u2019s size when set to 0.5, maintain their existing size when set to 1, double their size when set to 2, and so forth.\n\nSee Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "rotation(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/rotation(_:anchor:)",
        "html": "Parameters\nangle\n\nThe angle of rotation to apply. Positive angles rotate clockwise; negative angles rotate counterclockwise.\n\nanchor\n\nThe point to rotate the shape around.\n\nReturn Value\n\nA rotated shape.\n\nDiscussion\n\nThe following example rotates a square by 45 degrees to the right to create a diamond shape:\n\nRoundedRectangle(cornerRadius: 10)\n.rotation(Angle(degrees: 45))\n.aspectRatio(1.0, contentMode: .fit)\n\nSee Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "offset(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/offset(_:)-9nmd5",
        "html": "Parameters\noffset\n\nThe amount, in points, by which you offset the shape. Negative numbers are to the left and up; positive numbers are to the right and down.\n\nReturn Value\n\nA shape offset by the specified amount.\n\nDiscussion\n\nThe following example renders two circles. It places one circle at its default position. The second circle is outlined with a stroke, positioned on top of the first circle and offset by 100 points to the left and 50 points below.\n\nCircle()\n.overlay(\n    Circle()\n    .offset(CGPoint(x: -100, y: 50))\n    .stroke()\n)\n\nSee Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "scale(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/scale(_:anchor:)",
        "html": "Parameters\nscale\n\nThe multiplication factor used to resize this shape. A value of 0 scales the shape to have no size, 0.5 scales to half size in both dimensions, 2 scales to twice the regular size, and so on.\n\nReturn Value\n\nA scaled form of this shape.\n\nSee Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "stroke(_:lineWidth:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/stroke(_:linewidth:antialiased:)",
        "html": "Parameters\ncontent\n\nThe color or gradient with which to stroke this shape.\n\nlineWidth\n\nThe width of the stroke that outlines this shape.\n\nReturn Value\n\nA stroked shape.\n\nDiscussion\n\nThe following example draws a circle with a purple stroke:\n\nCircle().stroke(Color.purple, lineWidth: 5)\n\nSee Also\nSetting the stroke characteristics\nfunc stroke<S>(S, lineWidth: CGFloat) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke(lineWidth: CGFloat) -> some Shape\nReturns a new shape that is a stroked copy of self with line-width defined by lineWidth and all other properties of StrokeStyle having their default values.\nfunc stroke<S>(S, style: StrokeStyle) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(style: StrokeStyle) -> some Shape\nReturns a new shape that is a stroked copy of self, using the contents of style to define the stroke characteristics."
    },
    {
        "title": "offset(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/offset(_:)-8jkk1",
        "html": "Parameters\noffset\n\nThe amount, in points, by which you offset the shape. Negative numbers are to the left and up; positive numbers are to the right and down.\n\nReturn Value\n\nA shape offset by the specified amount.\n\nDiscussion\n\nThe following example renders two circles. It places one circle at its default position. The second circle is outlined with a stroke, positioned on top of the first circle and offset by 100 points to the left and 50 points below.\n\nCircle()\n.overlay(\n    Circle()\n    .offset(CGSize(width: -100, height: 50))\n    .stroke()\n)\n\nSee Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "offset(x:y:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/offset(x:y:)",
        "html": "Parameters\nx\n\nThe horizontal amount, in points, by which you offset the shape. Negative numbers are to the left and positive numbers are to the right.\n\ny\n\nThe vertical amount, in points, by which you offset the shape. Negative numbers are up and positive numbers are down.\n\nReturn Value\n\nA shape offset by the specified amount.\n\nDiscussion\n\nThe following example renders two circles. It places one circle at its default position. The second circle is outlined with a stroke, positioned on top of the first circle and offset by 100 points to the left and 50 points below.\n\nCircle()\n.overlay(\n    Circle()\n    .offset(x: -100, y: 50)\n    .stroke()\n)\n\nSee Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "stroke(_:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/stroke(_:style:)",
        "html": "Parameters\ncontent\n\nThe color or gradient with which to stroke this shape.\n\nstyle\n\nThe stroke characteristics \u2014 such as the line\u2019s width and whether the stroke is dashed \u2014 that determine how to render this shape.\n\nReturn Value\n\nA stroked shape.\n\nDiscussion\n\nThe following example adds a dashed purple stroke to a Capsule:\n\nCapsule()\n.stroke(\n    Color.purple,\n    style: StrokeStyle(\n        lineWidth: 5,\n        lineCap: .round,\n        lineJoin: .miter,\n        miterLimit: 0,\n        dash: [5, 10],\n        dashPhase: 0\n    )\n)\n\nSee Also\nSetting the stroke characteristics\nfunc stroke<S>(S, lineWidth: CGFloat) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(lineWidth: CGFloat) -> some Shape\nReturns a new shape that is a stroked copy of self with line-width defined by lineWidth and all other properties of StrokeStyle having their default values.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(style: StrokeStyle) -> some Shape\nReturns a new shape that is a stroked copy of self, using the contents of style to define the stroke characteristics."
    },
    {
        "title": "stroke(style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/stroke(style:)",
        "html": "See Also\nSetting the stroke characteristics\nfunc stroke<S>(S, lineWidth: CGFloat) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(lineWidth: CGFloat) -> some Shape\nReturns a new shape that is a stroked copy of self with line-width defined by lineWidth and all other properties of StrokeStyle having their default values.\nfunc stroke<S>(S, style: StrokeStyle) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient."
    },
    {
        "title": "cornerRadii",
        "url": "https://developer.apple.com/documentation/swiftui/unevenroundedrectangle/cornerradii",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar style: RoundedCornerStyle\nThe style of corners drawn by the rounded rectangle."
    },
    {
        "title": "Auxiliary view modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-auxiliary-views",
        "html": "Overview\n\nUse these modifiers to manage supplemental views that present context-specific controls and information. For example, you can add titles and buttons to navigation bars, manage the status bar, create context menus, and add badges many different kinds of views.\n\nTopics\nNavigation titles\nConfigure your apps navigation titles\nUse a navigation title to display the current navigation state of an interface.\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nNavigation title configuration\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nNavigation bars\nfunc navigationBarBackButtonHidden(Bool) -> some View\nHides the navigation bar back button for the view.\nfunc navigationBarTitleDisplayMode(NavigationBarItem.TitleDisplayMode) -> some View\nConfigures the title display mode for this view.\nNavigation stacks and columns\nfunc navigationDestination<D, C>(for: D.Type, destination: (D) -> C) -> some View\nAssociates a destination view with a presented data type for use within a navigation stack.\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> some View\nAssociates a destination view with a binding that can be used to push the view onto a NavigationStack.\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> some View\nAssociates a destination view with a bound value for use within a navigation stack or navigation split view\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nTab views\nfunc tabItem<V>(() -> V) -> some View\nSets the tab bar item associated with this view.\nToolbars\nFor information about toolbars, see Toolbars.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nfunc toolbar<Content>(id: String, content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items, allowing for user customization.\nfunc toolbar(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the visibility of a bar managed by SwiftUI.\nfunc toolbar(removing: ToolbarDefaultItemKind?) -> some View\nRemove a toolbar item present by default\nfunc toolbarBackground<S>(S, for: ToolbarPlacement...) -> some View\nSpecifies the preferred shape style of the background of a bar managed by SwiftUI.\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the preferred visibility of backgrounds on a bar managed by SwiftUI.\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> some View\nSpecifies the preferred color scheme of a bar managed by SwiftUI.\nfunc toolbarRole(ToolbarRole) -> some View\nConfigures the semantic role for the content populating the toolbar.\nfunc toolbarTitleMenu<C>(content: () -> C) -> some View\nConfigure the title menu of a toolbar.\nfunc toolbarTitleDisplayMode(ToolbarTitleDisplayMode) -> some View\nConfigures the toolbar title display mode for this view.\nfunc ornament<Content>(visibility: Visibility, attachmentAnchor: OrnamentAttachmentAnchor, contentAlignment: Alignment, ornament: () -> Content) -> some View\nPresents an ornament.\nBeta\nContext menus\nFor information about menus in your app, see Menus and commands.\nfunc contextMenu<MenuItems>(menuItems: () -> MenuItems) -> some View\nAdds a context menu to a view.\nfunc contextMenu<M, P>(menuItems: () -> M, preview: () -> P) -> some View\nAdds a context menu with a preview to a view.\nfunc contextMenu<I, M>(forSelectionType: I.Type, menu: (Set<I>) -> M, primaryAction: ((Set<I>) -> Void)?) -> some View\nAdds an item-based context menu to a view.\nBadges\nfunc badge(Text?) -> some View\nGenerates a badge for the view from a text view.\nfunc badge<S>(S?) -> some View\nGenerates a badge for the view from a string.\nfunc badge(LocalizedStringKey?) -> some View\nGenerates a badge for the view from a localized string key.\nfunc badge(Int) -> some View\nGenerates a badge for the view from an integer value.\nfunc badgeProminence(BadgeProminence) -> some View\nSpecifies the prominence of badges created by this view.\nHelp text\nfunc help(LocalizedStringKey) -> some View\nAdds help text to a view using a localized string that you provide.\nfunc help<S>(S) -> some View\nAdds help text to a view using a string that you provide.\nfunc help(Text) -> some View\nAdds help text to a view using a text view that you provide.\nStatus bar\nfunc statusBarHidden(Bool) -> some View\nSets the visibility of the status bar.\nTouch Bar\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nSee Also\nConfiguring view elements\nAccessibility modifiers\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAppearance modifiers\nConfigure a view\u2019s foreground and background styles, controls, and visibility.\nText and symbol modifiers\nManage the rendering, selection, and entry of text in your view.\nChart view modifiers\nConfigure charts that you declare with Swift Charts."
    },
    {
        "title": "GaugeStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/gaugestyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nDescribing the purpose of the gauge\nvar label: GaugeStyleConfiguration.Label\nA view that describes the purpose of the gauge."
    },
    {
        "title": "AngularGradient",
        "url": "https://developer.apple.com/documentation/swiftui/angulargradient",
        "html": "Overview\n\nAn angular gradient is also known as a \u201cconic\u201d gradient. This gradient applies the color function as the angle changes, relative to a center point and defined start and end angles. If endAngle - startAngle > 2\u03c0, the gradient only draws the last complete turn. If endAngle - startAngle < 2\u03c0, the gradient fills the missing area with the colors defined by gradient locations one and zero, transitioning between the two halfway across the missing area. The gradient maps the unit space center point into the bounding rectangle of each shape filled with the gradient.\n\nWhen using an angular gradient as a shape style, you can also use angularGradient(_:center:startAngle:endAngle:), conicGradient(_:center:angle:), or similar methods.\n\nTopics\nCreating a full rotation angular gradient\ninit(gradient: Gradient, center: UnitPoint, angle: Angle)\nCreates a conic gradient that completes a full turn.\ninit(colors: [Color], center: UnitPoint, angle: Angle)\nCreates a conic gradient from a collection of colors that completes a full turn.\ninit(stops: [Gradient.Stop], center: UnitPoint, angle: Angle)\nCreates a conic gradient from a collection of color stops that completes a full turn.\nCreating a partial rotation angular gradient\ninit(gradient: Gradient, center: UnitPoint, startAngle: Angle, endAngle: Angle)\nCreates an angular gradient.\ninit(colors: [Color], center: UnitPoint, startAngle: Angle, endAngle: Angle)\nCreates an angular gradient from a collection of colors.\ninit(stops: [Gradient.Stop], center: UnitPoint, startAngle: Angle, endAngle: Angle)\nCreates an angular gradient from a collection of color stops.\nRelationships\nConforms To\nSendable\nShapeStyle\nView\nSee Also\nSupporting types\nstruct EllipticalGradient\nA radial gradient that draws an ellipse.\nstruct LinearGradient\nA linear gradient.\nstruct RadialGradient\nA radial gradient.\nstruct Material\nA background material type.\nstruct ImagePaint\nA shape style that fills a shape by repeating a region of an image.\nstruct HierarchicalShapeStyle\nA shape style that maps to one of the numbered content styles.\nstruct HierarchicalShapeStyleModifier\nStyles that you can apply to hierarchical shapes.\nstruct ForegroundStyle\nThe foreground style in the current context.\nstruct BackgroundStyle\nThe background style in the current context.\nstruct SelectionShapeStyle\nA style used to visually indicate selection following platform conventional colors and behaviors.\nstruct SeparatorShapeStyle\nA style appropriate for foreground separator or border lines.\nstruct TintShapeStyle\nA style that reflects the current tint color.\nstruct FillShapeStyle\nA shape style that displays one of the overlay fills.\nstruct LinkShapeStyle\nA style appropriate for links.\nstruct PlaceholderTextShapeStyle\nA style appropriate for placeholder text.\nstruct WindowBackgroundShapeStyle\nA style appropriate for elements that should match the background of their containing window."
    },
    {
        "title": "DisclosureGroup",
        "url": "https://developer.apple.com/documentation/swiftui/disclosuregroup",
        "html": "Overview\n\nA disclosure group view consists of a label to identify the contents, and a control to show and hide the contents. Showing the contents puts the disclosure group into the \u201cexpanded\u201d state, and hiding them makes the disclosure group \u201ccollapsed\u201d.\n\nIn the following example, a disclosure group contains two toggles and an embedded disclosure group. The top level disclosure group exposes its expanded state with the bound property, topLevelExpanded. By expanding the disclosure group, the user can use the toggles to update the state of the toggleStates structure.\n\nstruct ToggleStates {\n    var oneIsOn: Bool = false\n    var twoIsOn: Bool = true\n}\n@State private var toggleStates = ToggleStates()\n@State private var topExpanded: Bool = true\n\n\nvar body: some View {\n    DisclosureGroup(\"Items\", isExpanded: $topExpanded) {\n        Toggle(\"Toggle 1\", isOn: $toggleStates.oneIsOn)\n        Toggle(\"Toggle 2\", isOn: $toggleStates.twoIsOn)\n        DisclosureGroup(\"Sub-items\") {\n            Text(\"Sub-item 1\")\n        }\n    }\n}\n\nTopics\nCreating a group with a string label\ninit<S>(S, content: () -> Content)\nCreates a disclosure group, using a provided string to create a text view for the label.\nAvailable when Label is Text and Content conforms to View.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a disclosure group, using a provided localized string key to create a text view for the label.\nAvailable when Label is Text and Content conforms to View.\ninit(LocalizedStringKey, isExpanded: Binding<Bool>, content: () -> Content)\nCreates a disclosure group, using a provided localized string key to create a text view for the label, and a binding to the expansion state (expanded or collapsed).\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, isExpanded: Binding<Bool>, content: () -> Content)\nCreates a disclosure group, using a provided string to create a text view for the label, and a binding to the expansion state (expanded or collapsed).\nAvailable when Label is Text and Content conforms to View.\nCreating a group with a label view\ninit(content: () -> Content, label: () -> Label)\nCreates a disclosure group with the given label and content views.\ninit(isExpanded: Binding<Bool>, content: () -> Content, label: () -> Label)\nCreates a disclosure group with the given label and content views, and a binding to the expansion state (expanded or collapsed).\nRelationships\nConforms To\nView\nSee Also\nDisclosing information progressively\nstruct OutlineGroup\nA structure that computes views and disclosure groups on demand from an underlying collection of tree-structured, identified data.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view."
    },
    {
        "title": "DisclosureGroupStyleConfiguration.Content",
        "url": "https://developer.apple.com/documentation/swiftui/disclosuregroupstyleconfiguration/content-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the content\nlet content: DisclosureGroupStyleConfiguration.Content\nThe content of the disclosure group."
    },
    {
        "title": "ControlGroupStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/controlgroupstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the label\nlet label: ControlGroupStyleConfiguration.Label\nA view that provides the optional label of the ControlGroup."
    },
    {
        "title": "ControlGroupStyleConfiguration.Content",
        "url": "https://developer.apple.com/documentation/swiftui/controlgroupstyleconfiguration/content-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring the content\nlet content: ControlGroupStyleConfiguration.Content\nA view that represents the content of the ControlGroup."
    },
    {
        "title": "DatePickerStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/datepickerstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nLabeling the date picker\nlet label: DatePickerStyleConfiguration.Label\nA description of the DatePicker.\nvar displayedComponents: DatePickerComponents\nThe date components that the user is able to view and edit."
    },
    {
        "title": "DefaultShareLinkLabel",
        "url": "https://developer.apple.com/documentation/swiftui/defaultsharelinklabel",
        "html": "Overview\n\nYou don\u2019t use this type directly. Instead, ShareLink uses it automatically depending on how you create a share link.\n\nRelationships\nConforms To\nView"
    },
    {
        "title": "managedContentStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/managedcontentstyle(_:)",
        "html": "Parameters\nstyle\n\nThe style to apply to the view\n\nReturn Value\n\nThe styled view"
    },
    {
        "title": "DynamicViewContent",
        "url": "https://developer.apple.com/documentation/swiftui/dynamicviewcontent",
        "html": "Topics\nManaging the data\nvar data: Self.Data\nThe collection of underlying data.\n\nRequired\n\nassociatedtype Data : Collection\nThe type of the underlying collection of data.\n\nRequired\n\nResponding to updates\nfunc onDelete(perform: Optional<(IndexSet) -> Void>) -> some DynamicViewContent\nSets the deletion action for the dynamic view.\nfunc onInsert(of: [UTType], perform: (Int, [NSItemProvider]) -> Void) -> some DynamicViewContent\nSets the insert action for the dynamic view.\nfunc onMove(perform: Optional<(IndexSet, Int) -> Void>) -> some DynamicViewContent\nSets the move action for the dynamic view.\nfunc dropDestination<T>(for: T.Type, action: ([T], Int) -> Void) -> some DynamicViewContent\nSets the insert action for the dynamic view.\nDeprecated symbols\nfunc onInsert(of: [String], perform: (Int, [NSItemProvider]) -> Void) -> some DynamicViewContent\nSets the insert action for the dynamic view.\nDeprecated\nRelationships\nInherits From\nView\nConforming Types\nForEach\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\nModifiedContent\nConforms when Content conforms to DynamicViewContent and Modifier conforms to ViewModifier.\nSee Also\nIterating over list content\nstruct ForEach\nA structure that computes views on demand from an underlying collection of identified data.\nAvailable when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View."
    },
    {
        "title": "ButtonStyleConfiguration.Label",
        "url": "https://developer.apple.com/documentation/swiftui/buttonstyleconfiguration/label-swift.struct",
        "html": "Relationships\nConforms To\nView\nSee Also\nConfiguring a button\u2019s label\nlet label: ButtonStyleConfiguration.Label\nA view that describes the effect of pressing the button."
    },
    {
        "title": "RoundedCornerStyle.continuous",
        "url": "https://developer.apple.com/documentation/swiftui/roundedcornerstyle/continuous",
        "html": "See Also\nGetting corner styles\ncase circular\nQuarter-circle rounded rect corners."
    },
    {
        "title": "ellipse",
        "url": "https://developer.apple.com/documentation/swiftui/shape/ellipse",
        "html": "See Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "background",
        "url": "https://developer.apple.com/documentation/swiftui/strokeshapeview/background",
        "html": "See Also\nGetting shape view properties\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape.\nvar style: Style\nThe style that strokes this view\u2019s shape."
    },
    {
        "title": "shape",
        "url": "https://developer.apple.com/documentation/swiftui/strokeshapeview/shape",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape.\nvar style: Style\nThe style that strokes this view\u2019s shape."
    },
    {
        "title": "style",
        "url": "https://developer.apple.com/documentation/swiftui/strokeshapeview/style",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape."
    },
    {
        "title": "strokeStyle",
        "url": "https://developer.apple.com/documentation/swiftui/strokeshapeview/strokestyle",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar style: Style\nThe style that strokes this view\u2019s shape."
    },
    {
        "title": "style",
        "url": "https://developer.apple.com/documentation/swiftui/fillshapeview/style",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar fillStyle: FillStyle\nThe fill style used when filling this view\u2019s shape.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations."
    },
    {
        "title": "lineJoin",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle/linejoin",
        "html": "See Also\nSetting stroke style properties\nvar lineWidth: CGFloat\nThe width of the stroked path.\nvar lineCap: CGLineCap\nThe endpoint style of a line.\nvar miterLimit: CGFloat\nA threshold used to determine whether to use a bevel instead of a miter at a join.\nvar dash: [CGFloat]\nThe lengths of painted and unpainted segments used to make a dashed line.\nvar dashPhase: CGFloat\nHow far into the dash pattern the line starts."
    },
    {
        "title": "miterLimit",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle/miterlimit",
        "html": "See Also\nSetting stroke style properties\nvar lineWidth: CGFloat\nThe width of the stroked path.\nvar lineCap: CGLineCap\nThe endpoint style of a line.\nvar lineJoin: CGLineJoin\nThe join type of a line.\nvar dash: [CGFloat]\nThe lengths of painted and unpainted segments used to make a dashed line.\nvar dashPhase: CGFloat\nHow far into the dash pattern the line starts."
    },
    {
        "title": "init(eoFill:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/fillstyle/init(eofill:antialiased:)",
        "html": "Parameters\neoFill\n\nA Boolean value that indicates whether to use the even-odd rule for rendering a shape. Pass false to use the non-zero winding number rule instead.\n\nantialiased\n\nA Boolean value that indicates whether to use antialiasing when rendering the edges of a shape."
    },
    {
        "title": "isEOFilled",
        "url": "https://developer.apple.com/documentation/swiftui/fillstyle/iseofilled",
        "html": "Discussion\n\nWhen isOEFilled is false, the style uses the non-zero winding number rule.\n\nSee Also\nSetting fill style properties\nvar isAntialiased: Bool\nA Boolean value that indicates whether to apply antialiasing to the edges of a shape."
    },
    {
        "title": "lineIntersection(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/lineintersection(_:eofill:)",
        "html": "Parameters\nother\n\nThe shape to intersect.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the shapes (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new shape.\n\nDiscussion\n\nThe line of the resulting shape is the line of this shape that overlaps the filled region of other.\n\nIntersected subpaths that are clipped create open subpaths. Closed subpaths that do not intersect other remain closed.\n\nSee Also\nPerforming operations on a shape\nfunc intersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions common to both shapes.\nfunc lineSubtraction<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that does not overlap the filled region of the given shape.\nfunc subtracting<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions from this shape that are not in the given shape.\nfunc symmetricDifference<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions either from this shape or the given shape, but not in both.\nfunc union<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions in either this shape or the given shape."
    },
    {
        "title": "lineWidth",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle/linewidth",
        "html": "See Also\nSetting stroke style properties\nvar lineCap: CGLineCap\nThe endpoint style of a line.\nvar lineJoin: CGLineJoin\nThe join type of a line.\nvar miterLimit: CGFloat\nA threshold used to determine whether to use a bevel instead of a miter at a join.\nvar dash: [CGFloat]\nThe lengths of painted and unpainted segments used to make a dashed line.\nvar dashPhase: CGFloat\nHow far into the dash pattern the line starts."
    },
    {
        "title": "symmetricDifference(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/symmetricdifference(_:eofill:)",
        "html": "Parameters\nother\n\nThe shape to difference.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the shapes (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new shape.\n\nDiscussion\n\nThe filled region of the resulting shape is the filled region contained in either this shape or other, but not both.\n\nAny unclosed subpaths in either shape are assumed to be closed. The result of filling this shape using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on a shape\nfunc intersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions common to both shapes.\nfunc lineIntersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that overlaps the filled regions of the given shape.\nfunc lineSubtraction<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that does not overlap the filled region of the given shape.\nfunc subtracting<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions from this shape that are not in the given shape.\nfunc union<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions in either this shape or the given shape."
    },
    {
        "title": "union(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/union(_:eofill:)",
        "html": "Parameters\nother\n\nThe shape to union.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the shapes (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new shape.\n\nDiscussion\n\nThe filled region of resulting shape is the combination of the filled region of both shapes added together.\n\nAny unclosed subpaths in either shape are assumed to be closed. The result of filling this shape using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on a shape\nfunc intersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions common to both shapes.\nfunc lineIntersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that overlaps the filled regions of the given shape.\nfunc lineSubtraction<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that does not overlap the filled region of the given shape.\nfunc subtracting<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions from this shape that are not in the given shape.\nfunc symmetricDifference<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions either from this shape or the given shape, but not in both."
    },
    {
        "title": "subtracting(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/subtracting(_:eofill:)",
        "html": "Parameters\nother\n\nThe shape to subtract.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the shapes (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new shape.\n\nDiscussion\n\nThe filled region of the resulting shape is the filled region of this shape with the filled region other removed from it.\n\nAny unclosed subpaths in either shape are assumed to be closed. The result of filling this shape using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on a shape\nfunc intersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions common to both shapes.\nfunc lineIntersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that overlaps the filled regions of the given shape.\nfunc lineSubtraction<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that does not overlap the filled region of the given shape.\nfunc symmetricDifference<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions either from this shape or the given shape, but not in both.\nfunc union<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions in either this shape or the given shape."
    },
    {
        "title": "intersection(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/intersection(_:eofill:)",
        "html": "Parameters\nother\n\nThe shape to intersect.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the shapes (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new shape.\n\nDiscussion\n\nThe filled region of the resulting shape is the overlapping area of the filled region of both shapes. This can be used to clip the fill of a shape to a mask.\n\nAny unclosed subpaths in either shape are assumed to be closed. The result of filling this shape using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on a shape\nfunc lineIntersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that overlaps the filled regions of the given shape.\nfunc lineSubtraction<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that does not overlap the filled region of the given shape.\nfunc subtracting<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions from this shape that are not in the given shape.\nfunc symmetricDifference<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions either from this shape or the given shape, but not in both.\nfunc union<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions in either this shape or the given shape."
    },
    {
        "title": "shape",
        "url": "https://developer.apple.com/documentation/swiftui/fillshapeview/shape",
        "html": "See Also\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar fillStyle: FillStyle\nThe fill style used when filling this view\u2019s shape.\nvar style: Style\nThe style that fills this view\u2019s shape."
    },
    {
        "title": "isAntialiased",
        "url": "https://developer.apple.com/documentation/swiftui/fillstyle/isantialiased",
        "html": "See Also\nSetting fill style properties\nvar isEOFilled: Bool\nA Boolean value that indicates whether to use the even-odd rule when rendering a shape."
    },
    {
        "title": "shape",
        "url": "https://developer.apple.com/documentation/swiftui/scaledshape/shape",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar anchor: UnitPoint\nvar scale: CGSize"
    },
    {
        "title": "rect(cornerSize:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/rect(cornersize:style:)",
        "html": "See Also\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle."
    },
    {
        "title": "size(width:height:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/size(width:height:)",
        "html": "See Also\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point."
    },
    {
        "title": "fill(_:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/fill(_:style:)-3y2ud",
        "html": "Parameters\ncontent\n\nThe color or gradient to use when filling this shape.\n\nstyle\n\nThe style options that determine how the fill renders.\n\nReturn Value\n\nA shape filled with the color or gradient you supply.\n\nSee Also\nFilling a shape\nfunc fill<S>(S, style: FillStyle) -> some View\nFills this shape with a color or gradient.\nfunc fill(style: FillStyle) -> some View\nFills this shape with the foreground color."
    },
    {
        "title": "fill(_:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shape/fill(_:style:)-5fwbj",
        "html": "Parameters\ncontent\n\nThe color or gradient to use when filling this shape.\n\nstyle\n\nThe style options that determine how the fill renders.\n\nReturn Value\n\nA shape filled with the color or gradient you supply.\n\nSee Also\nFilling a shape\nfunc fill<S>(S, style: FillStyle) -> _ShapeView<Self, S>\nFills this shape with a color or gradient.\nfunc fill(style: FillStyle) -> some View\nFills this shape with the foreground color."
    },
    {
        "title": "navigationDocument(_:preview:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)-lqif",
        "html": "Parameters\ndocument\n\nThe transferable content associated to the navigation title.\n\npreview\n\nThe preview of the document to use when sharing.\n\nDiscussion\n\nIn iOS, iPadOS, this populates the title menu with a header previewing the document. In macOS, this populates a proxy icon.\n\nRefer to the Configure your apps navigation titles article for more information on navigation document modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "navigationDocument(_:preview:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)-il3y",
        "html": "Parameters\ndocument\n\nThe transferable content associated to the navigation title.\n\npreview\n\nThe preview of the document to use when sharing.\n\nDiscussion\n\nIn iOS, iPadOS, this populates the title menu with a header previewing the document. In macOS, this populates a proxy icon.\n\nRefer to the Configure your apps navigation titles article for more information on navigation document modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "forEach(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/foreach(_:)",
        "html": "See Also\nOperating over path elements\nenum Element\nAn element of a path."
    },
    {
        "title": "normalized(eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/normalized(eofill:)",
        "html": "Parameters\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the paths (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new path.\n\nDiscussion\n\nThe returned path is a weakly-simple path, has no self-intersections, and has a normalized orientation. The result of filling this path using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc intersection(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions common to both paths.\nfunc lineIntersection(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that overlaps the filled regions of the given path.\nfunc lineSubtraction(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that does not overlap the filled region of the given path.\nfunc subtracting(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions from this path that are not in the given path.\nfunc symmetricDifference(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions either from this path or the given path, but not in both.\nfunc union(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions in either this path or the given path."
    },
    {
        "title": "union(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/union(_:eofill:)",
        "html": "Parameters\nother\n\nThe path to union.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the paths (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new path.\n\nDiscussion\n\nThe filled region of resulting path is the combination of the filled region of both paths added together.\n\nAny unclosed subpaths in either path are assumed to be closed. The result of filling this path using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc intersection(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions common to both paths.\nfunc lineIntersection(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that overlaps the filled regions of the given path.\nfunc lineSubtraction(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that does not overlap the filled region of the given path.\nfunc normalized(eoFill: Bool) -> Path\nReturns a new weakly-simple copy of this path.\nfunc subtracting(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions from this path that are not in the given path.\nfunc symmetricDifference(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions either from this path or the given path, but not in both."
    },
    {
        "title": "intersection(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/intersection(_:eofill:)",
        "html": "Parameters\nother\n\nThe path to intersect.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the paths (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new path.\n\nDiscussion\n\nThe filled region of the resulting path is the overlapping area of the filled region of both paths. This can be used to clip the fill of a path to a mask.\n\nAny unclosed subpaths in either path are assumed to be closed. The result of filling this path using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc lineIntersection(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that overlaps the filled regions of the given path.\nfunc lineSubtraction(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that does not overlap the filled region of the given path.\nfunc normalized(eoFill: Bool) -> Path\nReturns a new weakly-simple copy of this path.\nfunc subtracting(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions from this path that are not in the given path.\nfunc symmetricDifference(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions either from this path or the given path, but not in both.\nfunc union(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions in either this path or the given path."
    },
    {
        "title": "lineSubtraction(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/linesubtraction(_:eofill:)",
        "html": "Parameters\nother\n\nThe path to subtract.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the paths (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new path.\n\nDiscussion\n\nThe line of the resulting path is the line of this path that does not overlap the filled region of other.\n\nIntersected subpaths that are clipped create open subpaths. Closed subpaths that do not intersect other remain closed.\n\nSee Also\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc intersection(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions common to both paths.\nfunc lineIntersection(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that overlaps the filled regions of the given path.\nfunc normalized(eoFill: Bool) -> Path\nReturns a new weakly-simple copy of this path.\nfunc subtracting(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions from this path that are not in the given path.\nfunc symmetricDifference(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions either from this path or the given path, but not in both.\nfunc union(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions in either this path or the given path."
    },
    {
        "title": "addRoundedRect(in:cornerSize:style:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addroundedrect(in:cornersize:style:transform:)",
        "html": "Parameters\nrect\n\nA rectangle, specified in user space coordinates.\n\ncornerSize\n\nThe size of the corners, specified in user space coordinates.\n\nstyle\n\nThe corner style. Defaults to the continous style if not specified.\n\ntransform\n\nAn affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.\n\nDiscussion\n\nThis is a convenience function that adds a rounded rectangle to a path, starting by moving to the center of the right edge and then adding lines and curves counter-clockwise to create a rounded rectangle, closing the subpath.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "subtracting(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/subtracting(_:eofill:)",
        "html": "Parameters\nother\n\nThe path to subtract.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the paths (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new path.\n\nDiscussion\n\nThe filled region of the resulting path is the filled region of this path with the filled region other removed from it.\n\nAny unclosed subpaths in either path are assumed to be closed. The result of filling this path using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc intersection(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions common to both paths.\nfunc lineIntersection(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that overlaps the filled regions of the given path.\nfunc lineSubtraction(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that does not overlap the filled region of the given path.\nfunc normalized(eoFill: Bool) -> Path\nReturns a new weakly-simple copy of this path.\nfunc symmetricDifference(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions either from this path or the given path, but not in both.\nfunc union(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions in either this path or the given path."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(_:)-3e5z",
        "html": "Parameters\npath\n\nThe CoreGraphics path to initialize the new path from.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(_:)-87w1j",
        "html": "See Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "trimmedPath(from:to:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/trimmedpath(from:to:)",
        "html": "Discussion\n\nThe returned path contains the region between from and to, both of which must be fractions between zero and one defining points linearly-interpolated along the path.\n\nSee Also\nTransforming the path\nfunc applying(CGAffineTransform) -> Path\nReturns a path constructed by applying the transform to all points of the path.\nfunc offsetBy(dx: CGFloat, dy: CGFloat) -> Path\nReturns a path constructed by translating all its points."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/swiftui/path/init()",
        "html": "See Also\nCreating a path\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "lineIntersection(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/lineintersection(_:eofill:)",
        "html": "Parameters\nother\n\nThe path to intersect.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the paths (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new path.\n\nDiscussion\n\nThe line of the resulting path is the line of this path that overlaps the filled region of other.\n\nIntersected subpaths that are clipped create open subpaths. Closed subpaths that do not intersect other remain closed.\n\nSee Also\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc intersection(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions common to both paths.\nfunc lineSubtraction(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that does not overlap the filled region of the given path.\nfunc normalized(eoFill: Bool) -> Path\nReturns a new weakly-simple copy of this path.\nfunc subtracting(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions from this path that are not in the given path.\nfunc symmetricDifference(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions either from this path or the given path, but not in both.\nfunc union(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions in either this path or the given path."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(_:)-912s7",
        "html": "Parameters\nrect\n\nThe rectangle to add.\n\nDiscussion\n\nThis is a convenience function that creates a path of a rectangle. Using this convenience function is more efficient than creating a path and adding a rectangle to it.\n\nCalling this function is equivalent to using minX and related properties to find the corners of the rectangle, then using the move(to:), addLine(to:), and closeSubpath() functions to add the rectangle.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "addRect(_:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addrect(_:transform:)",
        "html": "Parameters\nrect\n\nA rectangle, specified in user space coordinates.\n\ntransform\n\nAn affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.\n\nDiscussion\n\nThis is a convenience function that adds a rectangle to a path, starting by moving to the bottom-left corner and then adding lines counter-clockwise to create a rectangle, closing the subpath.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "addQuadCurve(to:control:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addquadcurve(to:control:)",
        "html": "Discussion\n\ncontrol: The control point of the curve, in user space coordinates.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(_:)-2rlvu",
        "html": "Parameters\ncallback\n\nThe Swift function that will be called to initialize the new path.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "addRects(_:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addrects(_:transform:)",
        "html": "Discussion\n\nCalling this convenience method is equivalent to repeatedly calling the addRect(_:transform:) method for each rectangle in the array.\n\nParameter:\n\nrects: An array of rectangles, specified in user space coordinates.\n\ntransform: An affine transform to apply to the ellipse before adding to the path. Defaults to the identity transform if not specified.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "addRelativeArc(center:radius:startAngle:delta:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addrelativearc(center:radius:startangle:delta:transform:)",
        "html": "Parameters\ncenter\n\nThe center of the arc, in user space coordinates.\n\nradius\n\nThe radius of the arc, in user space coordinates.\n\nstartAngle\n\nThe angle to the starting point of the arc, measured from the positive x-axis.\n\ndelta\n\nThe difference between the starting angle and ending angle of the arc. A positive value creates a counter- clockwise arc (in user space coordinates), and vice versa.\n\ntransform\n\nAn affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified. /\n\nDiscussion\n\nThis method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic B\u00e9zier curves to approximate a segment of a circle between those points, and then appends those curves to the path.\n\nThe delta parameter determines both the length of the arc the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. However, because SwiftUI by default uses a vertically-flipped coordinate system (with the origin in the top-left of the view), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.\n\nIf the path ends with an unclosed subpath, this method adds a line connecting the current point to the starting point of the arc. If there is no unclosed subpath, this method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "closeSubpath()",
        "url": "https://developer.apple.com/documentation/swiftui/path/closesubpath()",
        "html": "Discussion\n\nAppends a line from the current point to the starting point of the current subpath and ends the subpath.\n\nAfter closing the subpath, your application can begin a new subpath without first calling move(to:). In this case, a new subpath is implicitly created with a starting and current point equal to the previous subpath\u2019s starting point.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path."
    },
    {
        "title": "init(ellipseIn:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(ellipsein:)",
        "html": "Parameters\nrect\n\nThe rectangle that bounds the ellipse.\n\nDiscussion\n\nThis is a convenience function that creates a path of an ellipse. Using this convenience function is more efficient than creating a path and adding an ellipse to it.\n\nThe ellipse is approximated by a sequence of B\u00e9zier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.\n\nThe ellipse forms a complete subpath of the path\u2014that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction. If you supply an affine transform, then the constructed B\u00e9zier curves that define the ellipse are transformed before they are added to the path.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "applying(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/applying(_:)",
        "html": "Parameters\ntransform\n\nAn affine transform to apply to the path.\n\nReturn Value\n\na new copy of the path with the transform applied to all points.\n\nSee Also\nTransforming the path\nfunc offsetBy(dx: CGFloat, dy: CGFloat) -> Path\nReturns a path constructed by translating all its points.\nfunc trimmedPath(from: CGFloat, to: CGFloat) -> Path\nReturns a partial copy of the path."
    },
    {
        "title": "colorMode",
        "url": "https://developer.apple.com/documentation/swiftui/canvas/colormode",
        "html": "See Also\nManaging opacity and color\nvar isOpaque: Bool\nA Boolean that indicates whether the canvas is fully opaque."
    },
    {
        "title": "offsetBy(dx:dy:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/offsetby(dx:dy:)",
        "html": "Parameters\ndx\n\nThe offset to apply in the horizontal axis.\n\ndy\n\nThe offset to apply in the vertical axis.\n\nReturn Value\n\na new copy of the path with the offset applied to all points.\n\nSee Also\nTransforming the path\nfunc applying(CGAffineTransform) -> Path\nReturns a path constructed by applying the transform to all points of the path.\nfunc trimmedPath(from: CGFloat, to: CGFloat) -> Path\nReturns a partial copy of the path."
    },
    {
        "title": "init(opaque:colorMode:rendersAsynchronously:renderer:)",
        "url": "https://developer.apple.com/documentation/swiftui/canvas/init(opaque:colormode:rendersasynchronously:renderer:)",
        "html": "Parameters\nopaque\n\nA Boolean that indicates whether the canvas is fully opaque. You might be able to improve performance by setting this value to true, but then drawing a non-opaque image into the context produces undefined results. The default is false.\n\ncolorMode\n\nA working color space and storage format of the canvas. The default is ColorRenderingMode.nonLinear.\n\nrendersAsynchronously\n\nA Boolean that indicates whether the canvas can present its contents to its parent view asynchronously. The default is false.\n\nrenderer\n\nA closure in which you conduct immediate mode drawing. The closure takes two inputs: a context that you use to issue drawing commands and a size \u2014 representing the current size of the canvas \u2014 that you can use to customize the content. The canvas calls the renderer any time it needs to redraw the content.\n\nDiscussion\n\nUse this initializer to create a new canvas that you can draw into. For example, you can draw a path:\n\nCanvas { context, size in\n    context.stroke(\n        Path(ellipseIn: CGRect(origin: .zero, size: size)),\n        with: .color(.green),\n        lineWidth: 4)\n}\n.frame(width: 300, height: 200)\n.border(Color.blue)\n\n\nThe example above draws the outline of an ellipse that exactly inscribes a canvas with a blue border:\n\nFor information about using a context to draw into a canvas, see GraphicsContext. If you want to provide SwiftUI views for the renderer to use as drawing elements, use init(opaque:colorMode:rendersAsynchronously:renderer:symbols:) instead.\n\nSee Also\nCreating a canvas\ninit(opaque: Bool, colorMode: ColorRenderingMode, rendersAsynchronously: Bool, renderer: (inout GraphicsContext, CGSize) -> Void, symbols: () -> Symbols)\nCreates and configures a canvas that you supply with renderable child views."
    },
    {
        "title": "init(opaque:colorMode:rendersAsynchronously:renderer:symbols:)",
        "url": "https://developer.apple.com/documentation/swiftui/canvas/init(opaque:colormode:rendersasynchronously:renderer:symbols:)",
        "html": "Parameters\nopaque\n\nA Boolean that indicates whether the canvas is fully opaque. You might be able to improve performance by setting this value to true, but then drawing a non-opaque image into the context produces undefined results. The default is false.\n\ncolorMode\n\nA working color space and storage format of the canvas. The default is ColorRenderingMode.nonLinear.\n\nrendersAsynchronously\n\nA Boolean that indicates whether the canvas can present its contents to its parent view asynchronously. The default is false.\n\nrenderer\n\nA closure in which you conduct immediate mode drawing. The closure takes two inputs: a context that you use to issue drawing commands and a size \u2014 representing the current size of the canvas \u2014 that you can use to customize the content. The canvas calls the renderer any time it needs to redraw the content.\n\nsymbols\n\nA ViewBuilder that you use to supply SwiftUI views to the canvas for use during drawing. Uniquely tag each view using the tag(_:) modifier, so that you can find them from within your renderer using the resolveSymbol(id:) method.\n\nDiscussion\n\nThis initializer behaves like the init(opaque:colorMode:rendersAsynchronously:renderer:) initializer, except that you also provide a collection of SwiftUI views for the renderer to use as drawing elements.\n\nSwiftUI stores a rendered version of each child view that you specify in the symbols view builder and makes these available to the canvas. Tag each child view so that you can retrieve it from within the renderer using the resolveSymbol(id:) method. For example, you can create a scatter plot using a passed-in child view as the mark for each data point:\n\nstruct ScatterPlotView<Mark: View>: View {\n    let rects: [CGRect]\n    let mark: Mark\n\n\n    enum SymbolID: Int {\n        case mark\n    }\n\n\n    var body: some View {\n        Canvas { context, size in\n            if let mark = context.resolveSymbol(id: SymbolID.mark) {\n                for rect in rects {\n                    context.draw(mark, in: rect)\n                }\n            }\n        } symbols: {\n            mark.tag(SymbolID.mark)\n        }\n        .frame(width: 300, height: 200)\n        .border(Color.blue)\n    }\n}\n\n\nYou can use any SwiftUI view for the mark input:\n\nScatterPlotView(rects: rects, mark: Image(systemName: \"circle\"))\n\n\nIf the rects input contains 50 randomly arranged CGRect instances, SwiftUI draws a plot like this:\n\nThe symbol inputs, like all other elements that you draw to the canvas, lack individual accessibility and interactivity, even if the original SwiftUI view has these attributes. However, you can add accessibility and interactivity modifers to the canvas as a whole.\n\nSee Also\nCreating a canvas\ninit(opaque: Bool, colorMode: ColorRenderingMode, rendersAsynchronously: Bool, renderer: (inout GraphicsContext, CGSize) -> Void)\nCreates and configures a canvas.\nAvailable when Symbols is EmptyView."
    },
    {
        "title": "stroke(_:with:lineWidth:)",
        "url": "https://developer.apple.com/documentation/swiftui/graphicscontext/stroke(_:with:linewidth:)",
        "html": "Parameters\npath\n\nThe path to outline.\n\nshading\n\nThe color or pattern to use when outlining the path.\n\nlineWidth\n\nThe width of the stroke, which defaults to 1.\n\nDiscussion\n\nWhen you call this method, all StrokeStyle properties other than lineWidth take their default values. To control other style properties, use stroke(_:with:style:) instead.\n\nSee Also\nDrawing a path\nfunc stroke(Path, with: GraphicsContext.Shading, style: StrokeStyle)\nDraws a path into the context with a specified stroke style.\nfunc fill(Path, with: GraphicsContext.Shading, style: FillStyle)\nDraws a path into the context and fills the outlined region.\nfunc resolve(GraphicsContext.Shading) -> GraphicsContext.Shading\nReturns a version of a shading resolved with the current values of the graphics context\u2019s environment.\nstruct Shading\nA color or pattern that you can use to outline or fill a path.\nstruct GradientOptions\nOptions that affect the rendering of color gradients."
    },
    {
        "title": "symbols",
        "url": "https://developer.apple.com/documentation/swiftui/canvas/symbols",
        "html": "Discussion\n\nUniquely tag each child view using the tag(_:) modifier, so that you can find them from within your renderer using the resolveSymbol(id:) method."
    },
    {
        "title": "renderer",
        "url": "https://developer.apple.com/documentation/swiftui/canvas/renderer",
        "html": "Parameters\ncontext\n\nThe graphics context to draw into.\n\nsize\n\nThe current size of the view.\n\nSee Also\nRendering\nvar rendersAsynchronously: Bool\nA Boolean that indicates whether the canvas can present its contents to its parent view asynchronously."
    },
    {
        "title": "rendersAsynchronously",
        "url": "https://developer.apple.com/documentation/swiftui/canvas/rendersasynchronously",
        "html": "See Also\nRendering\nvar renderer: (inout GraphicsContext, CGSize) -> Void\nThe drawing callback that you use to draw into the canvas."
    },
    {
        "title": "isOpaque",
        "url": "https://developer.apple.com/documentation/swiftui/canvas/isopaque",
        "html": "Discussion\n\nYou might be able to improve performance by setting this value to true, making the canvas is fully opaque. However, in that case, the result of drawing a non-opaque image into the canvas is undefined.\n\nSee Also\nManaging opacity and color\nvar colorMode: ColorRenderingMode\nThe working color space and storage format of the canvas."
    },
    {
        "title": "init(style:)",
        "url": "https://developer.apple.com/documentation/swiftui/capsule/init(style:)",
        "html": "Parameters\nstyle\n\nthe style of corners drawn by the shape."
    },
    {
        "title": "init(cornerRadii:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/unevenroundedrectangle/init(cornerradii:style:)",
        "html": "Parameters\ncornerRadii\n\nthe radii of each corner.\n\nstyle\n\nthe style of corners drawn by the shape.\n\nSee Also\nCreating an uneven rounded rectangle\ninit(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape with uneven corners."
    },
    {
        "title": "init(topLeadingRadius:bottomLeadingRadius:bottomTrailingRadius:topTrailingRadius:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/unevenroundedrectangle/init(topleadingradius:bottomleadingradius:bottomtrailingradius:toptrailingradius:style:)",
        "html": "See Also\nCreating an uneven rounded rectangle\ninit(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape with uneven corners."
    },
    {
        "title": "init(cornerSize:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/roundedrectangle/init(cornersize:style:)",
        "html": "Parameters\ncornerSize\n\nthe width and height of the rounded corners.\n\nstyle\n\nthe style of corners drawn by the shape.\n\nSee Also\nCreating a rounded rectangle\ninit(cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape."
    },
    {
        "title": "init(cornerRadius:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/roundedrectangle/init(cornerradius:style:)",
        "html": "Parameters\ncornerRadius\n\nthe radius of the rounded corners.\n\nstyle\n\nthe style of corners drawn by the shape.\n\nSee Also\nCreating a rounded rectangle\ninit(cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape."
    },
    {
        "title": "TabView",
        "url": "https://developer.apple.com/documentation/swiftui/tabview",
        "html": "Overview\n\nTo create a user interface with tabs, place views in a TabView and apply the tabItem(_:) modifier to the contents of each tab. On iOS, you can also use one of the badge modifiers, like badge(_:), to assign a badge to each of the tabs.\n\nThe following example creates a tab view with three tabs, each presenting a custom child view. The first tab has a numeric badge and the third has a string badge.\n\nTabView {\n    ReceivedView()\n        .badge(2)\n        .tabItem {\n            Label(\"Received\", systemImage: \"tray.and.arrow.down.fill\")\n        }\n    SentView()\n        .tabItem {\n            Label(\"Sent\", systemImage: \"tray.and.arrow.up.fill\")\n        }\n    AccountView()\n        .badge(\"!\")\n        .tabItem {\n            Label(\"Account\", systemImage: \"person.crop.circle.fill\")\n        }\n}\n\n\nUse a Label for each tab item, or optionally a Text, an Image, or an image followed by text. Passing any other type of view results in a visible but empty tab item.\n\nTopics\nCreating a tab view\ninit(content: () -> Content)\nAvailable when SelectionValue is Int and Content conforms to View.\ninit(selection: Binding<SelectionValue>?, content: () -> Content)\nCreates an instance that selects from content associated with Selection values.\nRelationships\nConforms To\nView\nSee Also\nPresenting views in tabs\nfunc tabViewStyle<S>(S) -> some View\nSets the style for the tab view within the current environment.\nfunc tabItem<V>(() -> V) -> some View\nSets the tab bar item associated with this view."
    },
    {
        "title": "tabItem(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tabitem(_:)",
        "html": "Parameters\nlabel\n\nThe tab bar item to associate with this view.\n\nDiscussion\n\nUse tabItem(_:) to configure a view as a tab bar item in a TabView. The example below adds two views as tabs in a TabView:\n\nstruct View1: View {\n    var body: some View {\n        Text(\"View 1\")\n    }\n}\n\n\nstruct View2: View {\n    var body: some View {\n        Text(\"View 2\")\n    }\n}\n\n\nstruct TabItem: View {\n    var body: some View {\n        TabView {\n            View1()\n                .tabItem {\n                    Label(\"Menu\", systemImage: \"list.dash\")\n                }\n\n\n            View2()\n                .tabItem {\n                    Label(\"Order\", systemImage: \"square.and.pencil\")\n                }\n        }\n    }\n}\n\n\nSee Also\nPresenting views in tabs\nstruct TabView\nA view that switches between multiple child views using interactive user interface elements.\nfunc tabViewStyle<S>(S) -> some View\nSets the style for the tab view within the current environment."
    },
    {
        "title": "subscriptionStatusTask(for:priority:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstatustask(for:priority:action:)",
        "html": "Parameters\ngroupID\n\nThe subscription group ID to get the status for. The task restarts whenever this parameter changes.\n\npriority\n\nThe task priority to use when creating the task.\n\naction\n\nThe action to perform when the task\u2019s state changes.\n\nDiscussion\n\nBefore a view modified with this method appears, a task will start in the background to get the subscription status. While the view is presented, the task will call action whenever the status changes or the task\u2019s state changes.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "VSplitView",
        "url": "https://developer.apple.com/documentation/swiftui/vsplitview",
        "html": "Topics\nCreating a vertical split view\ninit(content: () -> Content)\nRelationships\nConforms To\nView\nSee Also\nDisplaying views in multiple panes\nstruct HSplitView\nA layout container that arranges its children in a horizontal line and allows the user to resize them using dividers placed between them."
    },
    {
        "title": "NavigationBarItem",
        "url": "https://developer.apple.com/documentation/swiftui/navigationbaritem",
        "html": "Overview\n\nUse one of the NavigationBarItem.TitleDisplayMode values to configure a navigation bar title\u2019s display mode with the navigationBarTitleDisplayMode(_:) view modifier.\n\nTopics\nSetting a title display mode\nenum TitleDisplayMode\nA style for displaying the title of a navigation bar.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring the navigation bar\nfunc navigationBarBackButtonHidden(Bool) -> some View\nHides the navigation bar back button for the view.\nfunc navigationBarTitleDisplayMode(NavigationBarItem.TitleDisplayMode) -> some View\nConfigures the title display mode for this view."
    },
    {
        "title": "HSplitView",
        "url": "https://developer.apple.com/documentation/swiftui/hsplitview",
        "html": "Topics\nCreating a horizontal split view\ninit(content: () -> Content)\nRelationships\nConforms To\nView\nSee Also\nDisplaying views in multiple panes\nstruct VSplitView\nA layout container that arranges its children in a vertical line and allows the user to resize them using dividers placed between them."
    },
    {
        "title": "cornerSize",
        "url": "https://developer.apple.com/documentation/swiftui/roundedrectangle/cornersize",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar style: RoundedCornerStyle\nThe style of corners drawn by the rounded rectangle."
    },
    {
        "title": "style",
        "url": "https://developer.apple.com/documentation/swiftui/roundedrectangle/style",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar cornerSize: CGSize\nThe width and height of the rounded rectangle\u2019s corners."
    },
    {
        "title": "SidebarRowSize",
        "url": "https://developer.apple.com/documentation/swiftui/sidebarrowsize",
        "html": "Overview\n\nOn macOS, sidebar rows have three different sizes: small, medium, and large. The size is primarily controlled by the current users\u2019 \u201cSidebar Icon Size\u201d in Appearance settings, and applies to all applications.\n\nOn all other platforms, the only supported sidebar size is .medium.\n\nThis size can be read or written in the environment using EnvironmentValues.sidebarRowSize.\n\nTopics\nGetting row sizes\ncase small\nThe standard \u201csmall\u201d row size\ncase medium\nThe standard \u201cmedium\u201d row size\ncase large\nThe standard \u201clarge\u201d row size\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nConfiguring the sidebar\nvar sidebarRowSize: SidebarRowSize\nThe current size of sidebar rows."
    },
    {
        "title": "NavigationView",
        "url": "https://developer.apple.com/documentation/swiftui/navigationview",
        "html": "Deprecated\n\nUse NavigationStack and NavigationSplitView instead. For more information, see Migrating to new navigation types.\n\nOverview\n\nUse a NavigationView to create a navigation-based app in which the user can traverse a collection of views. Users navigate to a destination view by selecting a NavigationLink that you provide. On iPadOS and macOS, the destination content appears in the next column. Other platforms push a new view onto the stack, and enable removing items from the stack with platform-specific controls, like a Back button or a swipe gesture.\n\nUse the init(content:) initializer to create a navigation view that directly associates navigation links and their destination views:\n\nNavigationView {\n    List(model.notes) { note in\n        NavigationLink(note.title, destination: NoteEditor(id: note.id))\n    }\n    Text(\"Select a Note\")\n}\n\n\nStyle a navigation view by modifying it with the navigationViewStyle(_:) view modifier. Use other modifiers, like navigationTitle(_:), on views presented by the navigation view to customize the navigation interface for the presented view.\n\nTopics\nCreating a navigation view\ninit(content: () -> Content)\nCreates a destination-based navigation view.\nStyling navigation views\nfunc navigationViewStyle<S>(S) -> some View\nSets the style for navigation views within this view.\nprotocol NavigationViewStyle\nA specification for the appearance and interaction of a navigation view.\nRelationships\nConforms To\nView"
    },
    {
        "title": "dash",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle/dash",
        "html": "See Also\nSetting stroke style properties\nvar lineWidth: CGFloat\nThe width of the stroked path.\nvar lineCap: CGLineCap\nThe endpoint style of a line.\nvar lineJoin: CGLineJoin\nThe join type of a line.\nvar miterLimit: CGFloat\nA threshold used to determine whether to use a bevel instead of a miter at a join.\nvar dashPhase: CGFloat\nHow far into the dash pattern the line starts."
    },
    {
        "title": "sidebarRowSize",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/sidebarrowsize",
        "html": "Discussion\n\nOn macOS, reflects the value of the \u201cSidebar icon size\u201d in System Settings\u2019 Appearance settings.\n\nThis can be used to update the content shown in the sidebar in response to this size. And it can be overridden to force a sidebar to a particularly size, regardless of the user preference.\n\nOn other platforms, the value is always .medium and setting a different value has no effect.\n\nSwiftUI views like Label automatically adapt to the sidebar row size.\n\nSee Also\nConfiguring the sidebar\nenum SidebarRowSize\nThe standard sizes of sidebar rows."
    },
    {
        "title": "RoundedCornerStyle.circular",
        "url": "https://developer.apple.com/documentation/swiftui/roundedcornerstyle/circular",
        "html": "See Also\nGetting corner styles\ncase continuous\nContinuous curvature rounded rect corners."
    },
    {
        "title": "init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle/init(linewidth:linecap:linejoin:miterlimit:dash:dashphase:)",
        "html": "Parameters\nlineWidth\n\nThe width of the segment.\n\nlineCap\n\nThe endpoint style of a segment.\n\nlineJoin\n\nThe join type of a segment.\n\nmiterLimit\n\nThe threshold used to determine whether to use a bevel instead of a miter at a join.\n\ndash\n\nThe lengths of painted and unpainted segments used to make a dashed line.\n\ndashPhase\n\nHow far into the dash pattern the line starts."
    },
    {
        "title": "addRoundedRect(in:cornerRadii:style:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addroundedrect(in:cornerradii:style:transform:)",
        "html": "Parameters\nrect\n\nA rectangle, specified in user space coordinates.\n\ncornerRadii\n\nThe radius of each corner of the rectangle, specified in user space coordinates.\n\nstyle\n\nThe corner style. Defaults to the continous style if not specified.\n\ntransform\n\nAn affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.\n\nDiscussion\n\nThis is a convenience function that adds a rounded rectangle to a path, starting by moving to the center of the right edge and then adding lines and curves counter-clockwise to create a rounded rectangle, closing the subpath."
    },
    {
        "title": "lineCap",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle/linecap",
        "html": "See Also\nSetting stroke style properties\nvar lineWidth: CGFloat\nThe width of the stroked path.\nvar lineJoin: CGLineJoin\nThe join type of a line.\nvar miterLimit: CGFloat\nA threshold used to determine whether to use a bevel instead of a miter at a join.\nvar dash: [CGFloat]\nThe lengths of painted and unpainted segments used to make a dashed line.\nvar dashPhase: CGFloat\nHow far into the dash pattern the line starts."
    },
    {
        "title": "subscriptionStoreControlBackground(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolbackground(_:)-7ev89",
        "html": "See Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "productViewStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/productviewstyle(_:)",
        "html": "Discussion\n\nThis modifier styles any ProductView or StoreView instances within a view.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "healthDataAccessRequest(store:objectType:predicate:trigger:completion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:objecttype:predicate:trigger:completion:)",
        "html": "See Also\nAccessing health data\nfunc healthDataAccessRequest(store: HKHealthStore, readTypes: Set<HKObjectType>, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nfunc healthDataAccessRequest(store: HKHealthStore, shareTypes: Set<HKSampleType>, readTypes: Set<HKObjectType>?, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nRequests authorization to read and share the given HealthKit types Parameters: store: Your app\u2019s HKHealthStore, for which authorization will be requested shareTypes: An optional set containing the data types you want to share readTypes: An optional set containing the data types you want to read trigger: A generic equatable value; change this value to initiate a new request completion: A block that will be passed success or error when the request completes."
    },
    {
        "title": "navigationDocument(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:)-66zro",
        "html": "Parameters\ndocument\n\nThe transferable content associated to the navigation title.\n\nDiscussion\n\nIn iOS, iPadOS, this populates the title menu with a header previewing the document. In macOS, this populates a proxy icon.\n\nRefer to the Configure your apps navigation titles article for more information on navigation document modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "NavigationSplitView",
        "url": "https://developer.apple.com/documentation/swiftui/navigationsplitview",
        "html": "Overview\n\nYou create a navigation split view with two or three columns, and typically use it as the root view in a Scene. People choose one or more items in a leading column to display details about those items in subsequent columns.\n\nTo create a two-column navigation split view, use the init(sidebar:detail:) initializer:\n\n@State private var employeeIds: Set<Employee.ID> = []\n\n\nvar body: some View {\n    NavigationSplitView {\n        List(model.employees, selection: $employeeIds) { employee in\n            Text(employee.name)\n        }\n    } detail: {\n        EmployeeDetails(for: employeeIds)\n    }\n}\n\n\nIn the above example, the navigation split view coordinates with the List in its first column, so that when people make a selection, the detail view updates accordingly. Programmatic changes that you make to the selection property also affect both the list appearance and the presented detail view.\n\nTo create a three-column view, use the init(sidebar:content:detail:) initializer. The selection in the first column affects the second, and the selection in the second column affects the third. For example, you can show a list of departments, the list of employees in the selected department, and the details about all of the selected employees:\n\n@State private var departmentId: Department.ID? // Single selection.\n@State private var employeeIds: Set<Employee.ID> = [] // Multiple selection.\n\n\nvar body: some View {\n    NavigationSplitView {\n        List(model.departments, selection: $departmentId) { department in\n            Text(department.name)\n        }\n    } content: {\n        if let department = model.department(id: departmentId) {\n            List(department.employees, selection: $employeeIds) { employee in\n                Text(employee.name)\n            }\n        } else {\n            Text(\"Select a department\")\n        }\n    } detail: {\n        EmployeeDetails(for: employeeIds)\n    }\n}\n\n\nYou can also embed a NavigationStack in a column. Tapping or clicking a NavigationLink that appears in an earlier column sets the view that the stack displays over its root view. Activating a link in the same column adds a view to the stack. Either way, the link must present a data type for which the stack has a corresponding navigationDestination(for:destination:) modifier.\n\nOn watchOS and tvOS, and with narrow sizes like on iPhone or on iPad in Slide Over, the navigation split view collapses all of its columns into a stack, and shows the last column that displays useful information. For example, the three-column example above shows the list of departments to start, the employees in the department after someone selects a department, and the employee details when someone selects an employee. For rows in a list that have NavigationLink instances, the list draws disclosure chevrons while in the collapsed state.\n\nControl column visibility\n\nYou can programmatically control the visibility of navigation split view columns by creating a State value of type NavigationSplitViewVisibility. Then pass a Binding to that state to the appropriate initializer \u2014 such as init(columnVisibility:sidebar:detail:) for two columns, or the init(columnVisibility:sidebar:content:detail:) for three columns.\n\nThe following code updates the first example above to always hide the first column when the view appears:\n\n@State private var employeeIds: Set<Employee.ID> = []\n@State private var columnVisibility =\n    NavigationSplitViewVisibility.detailOnly\n\n\nvar body: some View {\n    NavigationSplitView(columnVisibility: $columnVisibility) {\n        List(model.employees, selection: $employeeIds) { employee in\n            Text(employee.name)\n        }\n    } detail: {\n        EmployeeDetails(for: employeeIds)\n    }\n}\n\n\nThe split view ignores the visibility control when it collapses its columns into a stack.\n\nCollapsed split views\n\nAt narrow size classes, such as on iPhone or Apple Watch, a navigation split view collapses into a single stack. Typically SwiftUI automatically chooses the view to show on top of this single stack, based on the content of the split view\u2019s columns.\n\nFor custom navigation experiences, you can provide more information to help SwiftUI choose the right column. Create a State value of type NavigationSplitViewColumn. Then pass a Binding to that state to the appropriate initializer, such as init(preferredCompactColumn:sidebar:detail:) or init(preferredCompactColumn:sidebar:content:detail:).\n\nThe following code shows the blue detail view when run on iPhone. When the person using the app taps the back button, they\u2019ll see the yellow view. The value of preferredPreferredCompactColumn will change from .detail to .sidebar:\n\n@State private var preferredColumn =\n    NavigationSplitViewColumn.detail\n\n\nvar body: some View {\n    NavigationSplitView(preferredCompactColumn: $preferredColumn) {\n        Color.yellow\n    } detail: {\n        Color.blue\n    }\n}\n\nCustomize a split view\n\nTo specify a preferred column width in a navigation split view, use the navigationSplitViewColumnWidth(_:) modifier. To set minimum, maximum, and ideal sizes for a column, use navigationSplitViewColumnWidth(min:ideal:max:). You can specify a different modifier in each column. The navigation split view does its best to accommodate the preferences that you specify, but might make adjustments based on other constraints.\n\nTo specify how columns in a navigation split view interact, use the navigationSplitViewStyle(_:) modifier with a NavigationSplitViewStyle value. For example, you can specify whether to emphasize the detail column or to give all of the columns equal prominence.\n\nOn some platforms, NavigationSplitView adds a sidebarToggle toolbar item. Use the toolbar(removing:) modifier to remove the default item.\n\nTopics\nCreating a navigation split view\ninit(sidebar: () -> Sidebar, detail: () -> Detail)\nCreates a two-column navigation split view.\ninit(sidebar: () -> Sidebar, content: () -> Content, detail: () -> Detail)\nCreates a three-column navigation split view.\nHiding columns in a navigation split view\ninit(columnVisibility: Binding<NavigationSplitViewVisibility>, sidebar: () -> Sidebar, detail: () -> Detail)\nCreates a two-column navigation split view that enables programmatic control of the sidebar\u2019s visibility.\ninit(columnVisibility: Binding<NavigationSplitViewVisibility>, sidebar: () -> Sidebar, content: () -> Content, detail: () -> Detail)\nCreates a three-column navigation split view that enables programmatic control of leading columns\u2019 visibility.\nSpecifying a preferred compact column\ninit(preferredCompactColumn: Binding<NavigationSplitViewColumn>, sidebar: () -> Sidebar, detail: () -> Detail)\nCreates a two-column navigation split view that enables programmatic control over which column appears on top when the view collapses into a single column in narrow sizes.\nAvailable when Sidebar conforms to View, Content conforms to View, and Detail conforms to View.\ninit(preferredCompactColumn: Binding<NavigationSplitViewColumn>, sidebar: () -> Sidebar, content: () -> Content, detail: () -> Detail)\nCreates a three-column navigation split view that enables programmatic control over which column appears on top when the view collapses into a single column in narrow sizes.\nAvailable when Sidebar conforms to View, Content conforms to View, and Detail conforms to View.\nSpecifying a preferred compact column and column visibility\ninit(columnVisibility: Binding<NavigationSplitViewVisibility>, preferredCompactColumn: Binding<NavigationSplitViewColumn>, sidebar: () -> Sidebar, detail: () -> Detail)\nCreates a two-column navigation split view that enables programmatic control of the sidebar\u2019s visibility in regular sizes and which column appears on top when the view collapses into a single column in narrow sizes.\nAvailable when Sidebar conforms to View, Content conforms to View, and Detail conforms to View.\ninit(columnVisibility: Binding<NavigationSplitViewVisibility>, preferredCompactColumn: Binding<NavigationSplitViewColumn>, sidebar: () -> Sidebar, content: () -> Content, detail: () -> Detail)\nCreates a three-column navigation split view that enables programmatic control of leading columns\u2019 visibility in regular sizes and which column appears on top when the view collapses into a single column in narrow sizes.\nAvailable when Sidebar conforms to View, Content conforms to View, and Detail conforms to View.\nRelationships\nConforms To\nView\nSee Also\nPresenting views in columns\nMigrating to new navigation types\nImprove navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nstruct NavigationSplitViewVisibility\nThe visibility of the leading columns in a navigation split view.\nstruct NavigationLink\nA view that controls a navigation presentation."
    },
    {
        "title": "Migrating to new navigation types",
        "url": "https://developer.apple.com/documentation/swiftui/migrating-to-new-navigation-types",
        "html": "Overview\n\nIf your app has a minimum deployment target of iOS 16, iPadOS 16, macOS 13, tvOS 16, watchOS 9, or visionOS 1, or later, transition away from using NavigationView. In its place, use NavigationStack and NavigationSplitView instances. How you use these depends on whether you perform navigation in one column or across multiple columns. With these newer containers, you get better control over view presentation, container configuration, and programmatic navigation.\n\nUpdate single column navigation\n\nIf your app uses a NavigationView that you style using the stack navigation view style, where people navigate by pushing a new view onto a stack, switch to NavigationStack.\n\nIn particular, stop doing this:\n\nNavigationView { // This is deprecated.\n    /* content */\n}\n.navigationViewStyle(.stack)\n\n\nInstead, create a navigation stack:\n\nNavigationStack {\n    /* content */\n}\n\nUpdate multicolumn navigation\n\nIf your app uses a two- or three-column NavigationView, or for apps that have multiple columns in some cases and a single column in others \u2014 which is typical for apps that run on iPhone and iPad \u2014 switch to NavigationSplitView.\n\nInstead of using a two-column navigation view:\n\nNavigationView { // This is deprecated.\n    /* column 1 */\n    /* column 2 */\n}\n\n\nCreate a navigation split view that has explicit sidebar and detail content using the init(sidebar:detail:) initializer:\n\nNavigationSplitView {\n    /* column 1 */\n} detail: {\n    /* column 2 */\n}\n\n\nSimilarly, instead of using a three-column navigation view:\n\nNavigationView { // This is deprecated.\n    /* column 1 */\n    /* column 2 */\n    /* column 3 */\n}\n\n\nCreate a navigation split view that has explicit sidebar, content, and detail components using the init(sidebar:content:detail:) initializer:\n\nNavigationSplitView {\n    /* column 1 */\n} content: {\n    /* column 2 */\n} detail: {\n    /* column 3 */\n}\n\n\nIf you need navigation within a column, embed a navigation stack in that column. This arrangement provides finer control over what each column displays. NavigationSplitView also enables you to customize column visibility and width.\n\nUpdate programmatic navigation\n\nIf you perform programmatic navigation using one of the NavigationLink initializers that has an isActive input parameter, move the automation to the enclosing stack. Do this by changing your navigation links to use the init(value:label:) initializer, then use one of the navigation stack initializers that takes a path input, like init(path:root:).\n\nFor example, if you have a navigation view with links that activate in response to individual state variables:\n\n@State private var isShowingPurple = false\n@State private var isShowingPink = false\n@State private var isShowingOrange = false\n\n\nvar body: some View {\n    NavigationView { // This is deprecated.\n        List {\n            NavigationLink(\"Purple\", isActive: $isShowingPurple) {\n                ColorDetail(color: .purple)\n            }\n            NavigationLink(\"Pink\", isActive: $isShowingPink) {\n                ColorDetail(color: .pink)\n            }\n            NavigationLink(\"Orange\", isActive: $isShowingOrange) {\n                ColorDetail(color: .orange)\n            }\n        }\n    }\n    .navigationViewStyle(.stack) \n}\n\n\nWhen some other part of your code sets one of the state variables to true, the navigation link that has the matching tag activates in response.\n\nRewrite this as a navigation stack that takes a path input:\n\n@State private var path: [Color] = [] // Nothing on the stack by default.\n\n\nvar body: some View {\n    NavigationStack(path: $path) {\n        List {\n            NavigationLink(\"Purple\", value: .purple)\n            NavigationLink(\"Pink\", value: .pink)\n            NavigationLink(\"Orange\", value: .orange)\n        }\n        .navigationDestination(for: Color.self) { color in\n            ColorDetail(color: color)\n        }\n    }\n}\n\n\nThis version uses the navigationDestination(for:destination:) view modifier to detach the presented data from the corresponding view. That makes it possible for the path array to represent every view on the stack. Changes that you make to the array affect what the container displays right now, as well as what people encounter as they navigate through the stack. You can support even more sophisticated programmatic navigation if you use a NavigationPath to store the path information, rather than a plain collection of data. For more information, see NavigationStack.\n\nUpdate selection-based navigation\n\nIf you perform programmatic navigation on List elements that use one of the NavigationLink initializers with a selection input parameter, you can move the selection to the list. For example, suppose you have a navigation view with links that activate in response to a selection state variable:\n\nlet colors: [Color] = [.purple, .pink, .orange]\n@State private var selection: Color? = nil // Nothing selected by default.\n\n\nvar body: some View {\n    NavigationView { // This is deprecated.\n        List {\n            ForEach(colors, id: \\.self) { color in\n                NavigationLink(color.description, tag: color, selection: $selection) {\n                    ColorDetail(color: color)\n                }\n            }\n        }\n        Text(\"Pick a color\")\n    }\n}\n\n\nUsing the same properties, you can rewrite the body as:\n\nvar body: some View {\n    NavigationSplitView {\n        List(colors, id: \\.self, selection: $selection) { color in\n            NavigationLink(color.description, value: color)\n        }\n    } detail: {\n        if let color = selection {\n            ColorDetail(color: color)\n        } else {\n            Text(\"Pick a color\")\n        }\n    }\n}\n\n\nThe list coordinates with the navigation logic so that changing the selection state variable in another part of your code activates the navigation link with the corresponding color. Similarly, if someone chooses the navigation link associated with a particular color, the list updates the selection value that other parts of your code can read.\n\nProvide backward compatibility with an availability check\n\nIf your app needs to run on platform versions earlier than iOS 16, iPadOS 16, macOS 13, tvOS 16, watchOS 9, or visionOS 1, you can start migration while continuing to support older clients by using an availability condition. For example, you can create a custom wrapper view that conditionally uses either NavigationSplitView or NavigationView:\n\nstruct NavigationSplitViewWrapper<Sidebar, Content, Detail>: View\n    where Sidebar: View, Content: View, Detail: View\n{\n    private var sidebar: Sidebar\n    private var content: Content\n    private var detail: Detail\n    \n    init(\n        @ViewBuilder sidebar: () -> Sidebar,\n        @ViewBuilder content: () -> Content,\n        @ViewBuilder detail:  () -> Detail\n    ) {\n        self.sidebar = sidebar()\n        self.content = content()\n        self.detail = detail()\n    }\n    \n    var body: some View {\n        if #available(iOS 16, macOS 13, tvOS 16, watchOS 9, visionOS 1, *) {\n            // Use the latest API.\n            NavigationSplitView {\n                sidebar\n            } content: {\n                content\n            } detail: {\n                detail\n            }\n        } else {\n            // Support previous platform versions.\n            NavigationView {\n                sidebar\n                content\n                detail\n            }\n            .navigationViewStyle(.columns)\n        }\n    }\n}\n\n\nCustomize the wrapper to meet your app\u2019s needs. For example, you can add a navigation split view style modifier like navigationSplitViewStyle(_:) to the NavigationSplitView in the appropriate branch of the availability check.\n\nSee Also\nPresenting views in columns\nstruct NavigationSplitView\nA view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nstruct NavigationSplitViewVisibility\nThe visibility of the leading columns in a navigation split view.\nstruct NavigationLink\nA view that controls a navigation presentation."
    },
    {
        "title": "navigationBarTitleDisplayMode(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationbartitledisplaymode(_:)",
        "html": "Parameters\ndisplayMode\n\nThe style to use for displaying the title.\n\nSee Also\nConfiguring the navigation bar\nfunc navigationBarBackButtonHidden(Bool) -> some View\nHides the navigation bar back button for the view.\nstruct NavigationBarItem\nA configuration for a navigation bar that represents a view at the top of a navigation stack."
    },
    {
        "title": "navigationSubtitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationsubtitle(_:)-50cfm",
        "html": "Parameters\nsubtitleKey\n\nThe key to a localized string to display.\n\nDiscussion\n\nA view\u2019s navigation subtitle is used to provide additional contextual information alongside the navigation title. On macOS, the primary destination\u2019s subtitle is displayed with the navigation title in the titlebar.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "navigationDocument(_:preview:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)-79zbw",
        "html": "Parameters\ndocument\n\nThe transferable content associated to the navigation title.\n\npreview\n\nThe preview of the document to use when sharing.\n\nDiscussion\n\nIn iOS, iPadOS, this populates the title menu with a header previewing the document. In macOS, this populates a proxy icon.\n\nRefer to the Configure your apps navigation titles article for more information on navigation document modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "symmetricDifference(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/symmetricdifference(_:eofill:)",
        "html": "Parameters\nother\n\nThe path to difference.\n\neoFill\n\nWhether to use the even-odd rule for determining which areas to treat as the interior of the paths (if true), or the non-zero rule (if false).\n\nReturn Value\n\nA new path.\n\nDiscussion\n\nThe filled region of the resulting path is the filled region contained in either this path or other, but not both.\n\nAny unclosed subpaths in either path are assumed to be closed. The result of filling this path using either even-odd or non-zero fill rules is identical.\n\nSee Also\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc intersection(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions common to both paths.\nfunc lineIntersection(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that overlaps the filled regions of the given path.\nfunc lineSubtraction(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that does not overlap the filled region of the given path.\nfunc normalized(eoFill: Bool) -> Path\nReturns a new weakly-simple copy of this path.\nfunc subtracting(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions from this path that are not in the given path.\nfunc union(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions in either this path or the given path."
    },
    {
        "title": "init(roundedRect:cornerRadius:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(roundedrect:cornerradius:style:)",
        "html": "Parameters\nrect\n\nA rectangle, specified in user space coordinates.\n\ncornerRadius\n\nThe radius of all corners of the rectangle, specified in user space coordinates.\n\nstyle\n\nThe corner style. Defaults to the continous style if not specified.\n\nDiscussion\n\nThis is a convenience function that creates a path of a rounded rectangle. Using this convenience function is more efficient than creating a path and adding a rounded rectangle to it.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "addArc(center:radius:startAngle:endAngle:clockwise:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addarc(center:radius:startangle:endangle:clockwise:transform:)",
        "html": "Parameters\ncenter\n\nThe center of the arc, in user space coordinates.\n\nradius\n\nThe radius of the arc, in user space coordinates.\n\nstartAngle\n\nThe angle to the starting point of the arc, measured from the positive x-axis.\n\nendAngle\n\nThe angle to the end point of the arc, measured from the positive x-axis.\n\nclockwise\n\ntrue to make a clockwise arc; false to make a counterclockwise arc.\n\ntransform\n\nAn affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.\n\nDiscussion\n\nThis method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic B\u00e9zier curves to approximate a segment of a circle between those points, and then appends those curves to the path.\n\nThe clockwise parameter determines the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. However, because SwiftUI by default uses a vertically-flipped coordinate system (with the origin in the top-left of the view), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.\n\nIf the path ends with an unclosed subpath, this method adds a line connecting the current point to the starting point of the arc. If there is no unclosed subpath, this method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "navigationDocument(_:preview:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)-3i9fs",
        "html": "Parameters\ndocument\n\nThe transferable content associated to the navigation title.\n\npreview\n\nThe preview of the document to use when sharing.\n\nDiscussion\n\nIn iOS, iPadOS, this populates the title menu with a header previewing the document. In macOS, this populates a proxy icon.\n\nRefer to the Configure your apps navigation titles article for more information on navigation document modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "navigationTitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)-6jofs",
        "html": "Parameters\ntitle\n\nThe view to display.\n\nDiscussion\n\nA view\u2019s navigation title is used to visually display the current navigation state of an interface. On iOS and watchOS, when a view is navigated to inside of a navigation view, that view\u2019s title is displayed in the navigation bar. On iPadOS, the primary destination\u2019s navigation title is reflected as the window\u2019s title in the App Switcher. Similarly on macOS, the primary destination\u2019s title is used as the window title in the titlebar, Windows menu and Mission Control.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "addArc(tangent1End:tangent2End:radius:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addarc(tangent1end:tangent2end:radius:transform:)",
        "html": "Parameters\ntangent1End\n\nThe end point, in user space coordinates, for the first tangent line to be used in constructing the arc. (The start point for this tangent line is the path\u2019s current point.)\n\ntangent2End\n\nThe end point, in user space coordinates, for the second tangent line to be used in constructing the arc. (The start point for this tangent line is the tangent1End point.)\n\nradius\n\nThe radius of the arc, in user space coordinates.\n\ntransform\n\nAn affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.\n\nDiscussion\n\nThis method calculates two tangent lines\u2014the first from the current point to the tangent1End point, and the second from the tangent1End point to the tangent2End point\u2014then calculates the start and end points for a circular arc of the specified radius such that the arc is tangent to both lines. Finally, this method approximates that arc with a sequence of cubic B\u00e9zier curves and appends those curves to the path.\n\nIf the starting point of the arc (that is, the point where a circle of the specified radius must meet the first tangent line in order to also be tangent to the second line) is not the current point, this method appends a straight line segment from the current point to the starting point of the arc.\n\nThe ending point of the arc (that is, the point where a circle of the specified radius must meet the second tangent line in order to also be tangent to the first line) becomes the new current point of the path.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "addPath(_:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addpath(_:transform:)",
        "html": "Parameters\npath\n\nThe path to add.\n\ntransform\n\nAn affine transform to apply to the path parameter before adding to this path. Defaults to the identity transform if not specified.\n\nDiscussion\n\nIf the path parameter is a non-empty empty path, its elements are appended in order to this path. Afterward, the start point and current point of this path are those of the last subpath in the path parameter.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "init(roundedRect:cornerRadii:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(roundedrect:cornerradii:style:)",
        "html": "Parameters\nrect\n\nA rectangle, specified in user space coordinates.\n\ncornerRadii\n\nThe radius of each corner of the rectangle, specified in user space coordinates.\n\nstyle\n\nThe corner style. Defaults to the continous style if not specified.\n\nDiscussion\n\nThis is a convenience function that creates a path of a rounded rectangle. Using this function is more efficient than creating a path and adding a rounded rectangle to it.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle."
    },
    {
        "title": "boundingRect",
        "url": "https://developer.apple.com/documentation/swiftui/path/boundingrect",
        "html": "Discussion\n\nThis is the smallest rectangle completely enclosing all points in the path but not including control points for B\u00e9zier curves.\n\nSee Also\nGetting the path\u2019s characteristics\nvar cgPath: CGPath\nAn immutable path representing the elements in the path.\nfunc contains(CGPoint, eoFill: Bool) -> Bool\nReturns true if the path contains a specified point.\nvar currentPoint: CGPoint?\nReturns the last point in the path, or nil if the path contains no points.\nvar description: String\nA description of the path that may be used to recreate the path via init?(_:).\nvar isEmpty: Bool\nA Boolean value indicating whether the path contains zero elements."
    },
    {
        "title": "addEllipse(in:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addellipse(in:transform:)",
        "html": "Discussion\n\nThe ellipse is approximated by a sequence of B\u00e9zier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.\n\nThe ellipse forms a complete subpath of the path\u2014 that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction.\n\nParameter:\n\nrect: A rectangle that defines the area for the ellipse to fit in.\n\ntransform: An affine transform to apply to the ellipse before adding to the path. Defaults to the identity transform if not specified.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "navigationTitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)-43srq",
        "html": "Parameters\ntitleKey\n\nThe key to a localized string to display.\n\nDiscussion\n\nA view\u2019s navigation title is used to visually display the current navigation state of an interface. On iOS and watchOS, when a view is navigated to inside of a navigation view, that view\u2019s title is displayed in the navigation bar. On iPadOS, the primary destination\u2019s navigation title is reflected as the window\u2019s title in the App Switcher. Similarly on macOS, the primary destination\u2019s title is used as the window title in the titlebar, Windows menu and Mission Control.\n\nRefer to the Configure your apps navigation titles article for more information on navigation title modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "addCurve(to:control1:control2:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addcurve(to:control1:control2:)",
        "html": "Discussion\n\ncontrol1: The first control point of the curve, in user space coordinates.\n\ncontrol2: The second control point of the curve, in user space coordinates.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "navigationSubtitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationsubtitle(_:)-262n7",
        "html": "Parameters\ntitle\n\nThe subtitle to display.\n\nDiscussion\n\nA view\u2019s navigation subtitle is used to provide additional contextual information alongside the navigation title. On macOS, the primary destination\u2019s subtitle is displayed with the navigation title in the titlebar.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "navigationDocument(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:)-6ivu7",
        "html": "Parameters\ndocument\n\nThe URL content associated to the navigation title.\n\npreview\n\nThe preview of the document to use when sharing.\n\nDiscussion\n\nIn iOS, iPadOS, this populates the title menu with a header previewing the document. In macOS, this populates a proxy icon.\n\nRefer to the Configure your apps navigation titles article for more information on navigation document modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "init(roundedRect:cornerSize:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(roundedrect:cornersize:style:)",
        "html": "Parameters\nrect\n\nA rectangle, specified in user space coordinates.\n\ncornerSize\n\nThe size of the corners, specified in user space coordinates.\n\nstyle\n\nThe corner style. Defaults to the continous style if not specified.\n\nDiscussion\n\nThis is a convenience function that creates a path of a rounded rectangle. Using this convenience function is more efficient than creating a path and adding a rounded rectangle to it.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "isEmpty",
        "url": "https://developer.apple.com/documentation/swiftui/path/isempty",
        "html": "See Also\nGetting the path\u2019s characteristics\nvar boundingRect: CGRect\nA rectangle containing all path segments.\nvar cgPath: CGPath\nAn immutable path representing the elements in the path.\nfunc contains(CGPoint, eoFill: Bool) -> Bool\nReturns true if the path contains a specified point.\nvar currentPoint: CGPoint?\nReturns the last point in the path, or nil if the path contains no points.\nvar description: String\nA description of the path that may be used to recreate the path via init?(_:)."
    },
    {
        "title": "move(to:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/move(to:)",
        "html": "Parameters\nend\n\nThe point, in user space coordinates, at which to start a new subpath.\n\nDiscussion\n\nThe specified point becomes the start point of a new subpath. The current point is set to this start point.\n\nSee Also\nDrawing a path\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "currentPoint",
        "url": "https://developer.apple.com/documentation/swiftui/path/currentpoint",
        "html": "See Also\nGetting the path\u2019s characteristics\nvar boundingRect: CGRect\nA rectangle containing all path segments.\nvar cgPath: CGPath\nAn immutable path representing the elements in the path.\nfunc contains(CGPoint, eoFill: Bool) -> Bool\nReturns true if the path contains a specified point.\nvar description: String\nA description of the path that may be used to recreate the path via init?(_:).\nvar isEmpty: Bool\nA Boolean value indicating whether the path contains zero elements."
    },
    {
        "title": "addLine(to:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addline(to:)",
        "html": "Parameters\nend\n\nThe location, in user space coordinates, for the end of the new line segment.\n\nDiscussion\n\nAfter adding the line segment, the current point is set to the endpoint of the line segment.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "contains(_:eoFill:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/contains(_:eofill:)",
        "html": "Discussion\n\nIf eoFill is true, this method uses the even-odd rule to define which points are inside the path. Otherwise, it uses the non-zero rule.\n\nSee Also\nGetting the path\u2019s characteristics\nvar boundingRect: CGRect\nA rectangle containing all path segments.\nvar cgPath: CGPath\nAn immutable path representing the elements in the path.\nvar currentPoint: CGPoint?\nReturns the last point in the path, or nil if the path contains no points.\nvar description: String\nA description of the path that may be used to recreate the path via init?(_:).\nvar isEmpty: Bool\nA Boolean value indicating whether the path contains zero elements."
    },
    {
        "title": "addLines(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/addlines(_:)",
        "html": "Discussion\n\nCalling this convenience method is equivalent to applying the transform to all points in the array, then calling the move(to:) method with the first value in the points array, then calling the addLine(to:) method for each subsequent point until the array is exhausted. After calling this method, the path\u2019s current point is the last point in the array.\n\nParameter:\n\nlines: An array of values that specify the start and end points of the line segments to draw. Each point in the array specifies a position in user space. The first point in the array specifies the initial starting point.\n\ntransform: An affine transform to apply to the points before adding to the path. Defaults to the identity transform if not specified.\n\nSee Also\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath."
    },
    {
        "title": "init(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/path/init(_:)-3n5fl",
        "html": "Parameters\npath\n\nThe immutable CoreGraphics path to initialize the new path from.\n\nSee Also\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii."
    },
    {
        "title": "cgPath",
        "url": "https://developer.apple.com/documentation/swiftui/path/cgpath",
        "html": "See Also\nGetting the path\u2019s characteristics\nvar boundingRect: CGRect\nA rectangle containing all path segments.\nfunc contains(CGPoint, eoFill: Bool) -> Bool\nReturns true if the path contains a specified point.\nvar currentPoint: CGPoint?\nReturns the last point in the path, or nil if the path contains no points.\nvar description: String\nA description of the path that may be used to recreate the path via init?(_:).\nvar isEmpty: Bool\nA Boolean value indicating whether the path contains zero elements."
    },
    {
        "title": "description",
        "url": "https://developer.apple.com/documentation/swiftui/path/description",
        "html": "See Also\nGetting the path\u2019s characteristics\nvar boundingRect: CGRect\nA rectangle containing all path segments.\nvar cgPath: CGPath\nAn immutable path representing the elements in the path.\nfunc contains(CGPoint, eoFill: Bool) -> Bool\nReturns true if the path contains a specified point.\nvar currentPoint: CGPoint?\nReturns the last point in the path, or nil if the path contains no points.\nvar isEmpty: Bool\nA Boolean value indicating whether the path contains zero elements."
    },
    {
        "title": "style",
        "url": "https://developer.apple.com/documentation/swiftui/unevenroundedrectangle/style",
        "html": "See Also\nGetting the shape\u2019s characteristics\nvar cornerRadii: RectangleCornerRadii\nThe radii of each corner of the rounded rectangle."
    },
    {
        "title": "navigationDestination(for:destination:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdestination(for:destination:)",
        "html": "Parameters\ndata\n\nThe type of data that this destination matches.\n\ndestination\n\nA view builder that defines a view to display when the stack\u2019s navigation state contains a value of type data. The closure takes one argument, which is the value of the data to present.\n\nDiscussion\n\nAdd this view modifer to a view inside a NavigationStack to describe the view that the stack displays when presenting a particular kind of data. Use a NavigationLink to present the data. For example, you can present a ColorDetail view for each presentation of a Color instance:\n\nNavigationStack {\n    List {\n        NavigationLink(\"Mint\", value: Color.mint)\n        NavigationLink(\"Pink\", value: Color.pink)\n        NavigationLink(\"Teal\", value: Color.teal)\n    }\n    .navigationDestination(for: Color.self) { color in\n        ColorDetail(color: color)\n    }\n    .navigationTitle(\"Colors\")\n}\n\n\nYou can add more than one navigation destination modifier to the stack if it needs to present more than one kind of data.\n\nDo not put a navigation destination modifier inside a \u201clazy\u201d container, like List or LazyVStack. These containers create child views only when needed to render on screen. Add the navigation destination modifier outside these containers so that the navigation stack can always see the destination.\n\nSee Also\nStacking views in one column\nstruct NavigationStack\nA view that displays a root view and enables you to present additional views over the root view.\nstruct NavigationPath\nA type-erased list of data representing the content of a navigation stack.\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> some View\nAssociates a destination view with a binding that can be used to push the view onto a NavigationStack.\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> some View\nAssociates a destination view with a bound value for use within a navigation stack or navigation split view"
    },
    {
        "title": "NavigationLink",
        "url": "https://developer.apple.com/documentation/swiftui/navigationlink",
        "html": "Overview\n\nPeople click or tap a navigation link to present a view inside a NavigationStack or NavigationSplitView. You control the visual appearance of the link by providing view content in the link\u2019s label closure. For example, you can use a Label to display a link:\n\nNavigationLink {\n    FolderDetail(id: workFolder.id)\n} label: {\n    Label(\"Work Folder\", systemImage: \"folder\")\n}\n\n\nFor a link composed only of text, you can use one of the convenience initializers that takes a string and creates a Text view for you:\n\nNavigationLink(\"Work Folder\") {\n    FolderDetail(id: workFolder.id)\n}\n\nLink to a destination view\n\nYou can perform navigation by initializing a link with a destination view that you provide in the destination closure. For example, consider a ColorDetail view that fills itself with a color:\n\nstruct ColorDetail: View {\n    var color: Color\n\n\n    var body: some View {\n        color.navigationTitle(color.description)\n    }\n}\n\n\nThe following NavigationStack presents three links to color detail views:\n\nNavigationStack {\n    List {\n        NavigationLink(\"Mint\") { ColorDetail(color: .mint) }\n        NavigationLink(\"Pink\") { ColorDetail(color: .pink) }\n        NavigationLink(\"Teal\") { ColorDetail(color: .teal) }\n    }\n    .navigationTitle(\"Colors\")\n}\n\nCreate a presentation link\n\nAlternatively, you can use a navigation link to perform navigation based on a presented data value. To support this, use the navigationDestination(for:destination:) view modifier inside a navigation stack to associate a view with a kind of data, and then present a value of that data type from a navigation link. The following example reimplements the previous example as a series of presentation links:\n\nNavigationStack {\n    List {\n        NavigationLink(\"Mint\", value: Color.mint)\n        NavigationLink(\"Pink\", value: Color.pink)\n        NavigationLink(\"Teal\", value: Color.teal)\n    }\n    .navigationDestination(for: Color.self) { color in\n        ColorDetail(color: color)\n    }\n    .navigationTitle(\"Colors\")\n}\n\n\nSeparating the view from the data facilitates programmatic navigation because you can manage navigation state by recording the presented data.\n\nControl a presentation link programmatically\n\nTo navigate programmatically, introduce a state variable that tracks the items on a stack. For example, you can create an array of colors to store the stack state from the previous example, and initialize it as an empty array to start with an empty stack:\n\n@State private var colors: [Color] = []\n\n\nThen pass a Binding to the state to the navigation stack:\n\nNavigationStack(path: $colors) {\n    // ...\n}\n\n\nYou can use the array to observe the current state of the stack. You can also modify the array to change the contents of the stack. For example, you can programmatically add blue to the array, and navigation to a new color detail view using the following method:\n\nfunc showBlue() {\n    colors.append(.blue)\n}\n\nCoordinate with a list\n\nYou can also use a navigation link to control List selection in a NavigationSplitView:\n\nlet colors: [Color] = [.mint, .pink, .teal]\n@State private var selection: Color? // Nothing selected by default.\n\n\nvar body: some View {\n    NavigationSplitView {\n        List(colors, id: \\.self, selection: $selection) { color in\n            NavigationLink(color.description, value: color)\n        }\n    } detail: {\n        if let color = selection {\n            ColorDetail(color: color)\n        } else {\n            Text(\"Pick a color\")\n        }\n    }\n}\n\n\nThe list coordinates with the navigation logic so that changing the selection state variable in another part of your code activates the navigation link with the corresponding color. Similarly, if someone chooses the navigation link associated with a particular color, the list updates the selection value that other parts of your code can read.\n\nTopics\nPresenting a destination view\ninit(LocalizedStringKey, destination: () -> Destination)\nCreates a navigation link that presents a destination view, with a text label that the link generates from a localized string key.\nAvailable when Label is Text and Destination conforms to View.\ninit<S>(S, destination: () -> Destination)\nCreates a navigation link that presents a destination view, with a text label that the link generates from a title string.\nAvailable when Label is Text and Destination conforms to View.\ninit(destination: () -> Destination, label: () -> Label)\nCreates a navigation link that presents the destination view.\nPresenting a data value\ninit<P>(LocalizedStringKey, value: P?)\nCreates a navigation link that presents the view corresponding to a value, with a text label that the link generates from a localized string key.\nAvailable when Label conforms to View and Destination is Never.\ninit<S, P>(S, value: P?)\nCreates a navigation link that presents the view corresponding to a value, with a text label that the link generates from a title string.\nAvailable when Label conforms to View and Destination is Never.\ninit<P>(value: P?, label: () -> Label)\nCreates a navigation link that presents the view corresponding to a value.\nAvailable when Label conforms to View and Destination is Never.\nPresenting a codable value\ninit<P>(LocalizedStringKey, value: P?)\nCreates a navigation link that presents the view corresponding to a codable value, with a text label that the link generates from a localized string key.\nAvailable when Label conforms to View and Destination is Never.\ninit<S, P>(S, value: P?)\nCreates a navigation link that presents the view corresponding to a codable value, with a text label that the link generates from a title string.\nAvailable when Label conforms to View and Destination is Never.\ninit<P>(value: P?, label: () -> Label)\nCreates a navigation link that presents the view corresponding to a codable value.\nAvailable when Label conforms to View and Destination is Never.\nConfiguring the link\nfunc isDetailLink(Bool) -> some View\nSets the navigation link to present its destination as the detail component of the containing navigation view.\nAvailable when Label conforms to View and Destination conforms to View.\nDeprecated symbols\nDeprecated symbols\nReview deprecated navigation link initializers.\nRelationships\nConforms To\nView\nSee Also\nPresenting views in columns\nMigrating to new navigation types\nImprove navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.\nstruct NavigationSplitView\nA view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nstruct NavigationSplitViewVisibility\nThe visibility of the leading columns in a navigation split view."
    },
    {
        "title": "navigationDestination(isPresented:destination:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdestination(ispresented:destination:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that indicates whether destination is currently presented.\n\ndestination\n\nA view to present.\n\nDiscussion\n\nIn general, favor binding a path to a navigation stack for programmatic navigation. Add this view modifer to a view inside a NavigationStack to programmatically push a single view onto the stack. This is useful for building components that can push an associated view. For example, you can present a ColorDetail view for a particular color:\n\n@State private var showDetails = false\nvar favoriteColor: Color\n\n\nNavigationStack {\n    VStack {\n        Circle()\n            .fill(favoriteColor)\n        Button(\"Show details\") {\n            showDetails = true\n        }\n    }\n    .navigationDestination(isPresented: $showDetails) {\n        ColorDetail(color: favoriteColor)\n    }\n    .navigationTitle(\"My Favorite Color\")\n}\n\n\nDo not put a navigation destination modifier inside a \u201clazy\u201d container, like List or LazyVStack. These containers create child views only when needed to render on screen. Add the navigation destination modifier outside these containers so that the navigation stack can always see the destination.\n\nSee Also\nStacking views in one column\nstruct NavigationStack\nA view that displays a root view and enables you to present additional views over the root view.\nstruct NavigationPath\nA type-erased list of data representing the content of a navigation stack.\nfunc navigationDestination<D, C>(for: D.Type, destination: (D) -> C) -> some View\nAssociates a destination view with a presented data type for use within a navigation stack.\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> some View\nAssociates a destination view with a bound value for use within a navigation stack or navigation split view"
    },
    {
        "title": "NavigationPath",
        "url": "https://developer.apple.com/documentation/swiftui/navigationpath",
        "html": "Overview\n\nYou can manage the state of a NavigationStack by initializing the stack with a binding to a collection of data. The stack stores data items in the collection for each view on the stack. You also can read and write the collection to observe and alter the stack\u2019s state.\n\nWhen a stack displays views that rely on only one kind of data, you can use a standard collection, like an array, to hold the data. If you need to present different kinds of data in a single stack, use a navigation path instead. The path uses type erasure so you can manage a collection of heterogeneous elements. The path also provides the usual collection controls for adding, counting, and removing data elements.\n\nSerialize the path\n\nWhen the values you present on the navigation stack conform to the Codable protocol, you can use the path\u2019s codable property to get a serializable representation of the path. Use that representation to save and restore the contents of the stack. For example, you can define an ObservableObject that handles serializing and deserializing the path:\n\nclass MyModelObject: ObservableObject {\n    @Published var path: NavigationPath\n\n\n    static func readSerializedData() -> Data? {\n        // Read data representing the path from app's persistent storage.\n    }\n\n\n    static func writeSerializedData(_ data: Data) {\n        // Write data representing the path to app's persistent storage.\n    }\n\n\n    init() {\n        if let data = Self.readSerializedData() {\n            do {\n                let representation = try JSONDecoder().decode(\n                    NavigationPath.CodableRepresentation.self,\n                    from: data)\n                self.path = NavigationPath(representation)\n            } catch {\n                self.path = NavigationPath()\n            }\n        } else {\n            self.path = NavigationPath()\n        }\n    }\n\n\n    func save() {\n        guard let representation = path.codable else { return }\n        do {\n            let encoder = JSONEncoder()\n            let data = try encoder.encode(representation)\n            Self.writeSerializedData(data)\n        } catch {\n            // Handle error.\n        }\n    }\n}\n\n\nThen, using that object in your view, you can save the state of the navigation path when the Scene enters the ScenePhase.background state:\n\n@StateObject private var pathState = MyModelObject()\n@Environment(\\.scenePhase) private var scenePhase\n\n\nvar body: some View {\n    NavigationStack(path: $pathState.path) {\n        // Add a root view here.\n    }\n    .onChange(of: scenePhase) { phase in\n        if phase == .background {\n            pathState.save()\n        }\n    }\n}\n\nTopics\nCreating a navigation path\ninit()\nCreates a new, empty navigation path.\ninit(NavigationPath.CodableRepresentation)\nCreates a new navigation path from a serializable version.\ninit<S>(S)\nCreates a new navigation path from the contents of a sequence that contains codable elements.\ninit<S>(S)\nCreates a new navigation path from the contents of a sequence.\nManaging path contents\nvar isEmpty: Bool\nA Boolean that indicates whether this path is empty.\nvar count: Int\nThe number of elements in this path.\nfunc append<V>(V)\nAppends a new codable value to the end of this path.\nfunc append<V>(V)\nAppends a new value to the end of this path.\nfunc removeLast(Int)\nRemoves values from the end of this path.\nEncoding a path\nvar codable: NavigationPath.CodableRepresentation?\nA value that describes the contents of this path in a serializable format.\nstruct CodableRepresentation\nA serializable representation of a navigation path.\nRelationships\nConforms To\nEquatable\nSee Also\nStacking views in one column\nstruct NavigationStack\nA view that displays a root view and enables you to present additional views over the root view.\nfunc navigationDestination<D, C>(for: D.Type, destination: (D) -> C) -> some View\nAssociates a destination view with a presented data type for use within a navigation stack.\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> some View\nAssociates a destination view with a binding that can be used to push the view onto a NavigationStack.\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> some View\nAssociates a destination view with a bound value for use within a navigation stack or navigation split view"
    },
    {
        "title": "controlActiveState",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/controlactivestate",
        "html": "Discussion\n\nThe default is ControlActiveState.key.\n\nSee Also\nActivating controls\nenum ControlActiveState"
    },
    {
        "title": "SensoryFeedback",
        "url": "https://developer.apple.com/documentation/swiftui/sensoryfeedback",
        "html": "Overview\n\nThis feedback can be passed to View.sensoryFeedback to play it.\n\nTopics\nIndicating start and stop\nstatic let start: SensoryFeedback\nIndicates that an activity started.\nstatic let stop: SensoryFeedback\nIndicates that an activity stopped.\nIndicating changes and selections\nstatic let alignment: SensoryFeedback\nIndicates the alignment of a dragged item.\nstatic let decrease: SensoryFeedback\nIndicates that an important value decreased below a significant threshold.\nstatic let increase: SensoryFeedback\nIndicates that an important value increased above a significant threshold.\nstatic let levelChange: SensoryFeedback\nIndicates movement between discrete levels of pressure.\nstatic let selection: SensoryFeedback\nIndicates that a UI element\u2019s values are changing.\nIndicating the outcome of an operation\nstatic let success: SensoryFeedback\nIndicates that a task or action has completed.\nstatic let warning: SensoryFeedback\nIndicates that a task or action has produced a warning of some kind.\nstatic let error: SensoryFeedback\nIndicates that an error has occurred.\nProducing a physical impact\nstatic let impact: SensoryFeedback\nProvides a physical metaphor you can use to complement a visual experience.\nstatic func impact(weight: SensoryFeedback.Weight, intensity: Double) -> SensoryFeedback\nProvides a physical metaphor you can use to complement a visual experience.\nstatic func impact(flexibility: SensoryFeedback.Flexibility, intensity: Double) -> SensoryFeedback\nProvides a physical metaphor you can use to complement a visual experience.\nstruct Flexibility\nThe flexibility to be represented by a type of feedback.\nstruct Weight\nThe weight to be represented by a type of feedback.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nProviding haptic feedback\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> some View\nPlays the specified feedback when the provided trigger value changes.\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> some View\nPlays feedback when returned from the feedback closure after the provided trigger value changes.\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> some View\nPlays the specified feedback when the provided trigger value changes and the condition closure returns true."
    },
    {
        "title": "sensoryFeedback(trigger:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/sensoryfeedback(trigger:_:)",
        "html": "Parameters\ntrigger\n\nA value to monitor for changes to determine when to play.\n\nfeedback\n\nA closure to determine whether to play the feedback and what type of feedback to play when trigger changes.\n\nDiscussion\n\nFor example, you could play different feedback for different state transitions:\n\nstruct MyView: View {\n    @State private var phase = Phase.inactive\n\n\n    var body: some View {\n        ContentView(phase: $phase)\n            .sensoryFeedback(trigger: phase) { old, new in\n                switch (old, new) {\n                    case (.inactive, _): return .success\n                    case (_, .expanded): return .impact\n                    default: return nil\n                }\n            }\n    }\n\n\n    enum Phase {\n        case inactive\n        case preparing\n        case active\n        case expanded\n    }\n}\n\nSee Also\nProviding haptic feedback\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> some View\nPlays the specified feedback when the provided trigger value changes.\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> some View\nPlays the specified feedback when the provided trigger value changes and the condition closure returns true.\nstruct SensoryFeedback\nRepresents a type of haptic and/or audio feedback that can be played."
    },
    {
        "title": "ControlSize",
        "url": "https://developer.apple.com/documentation/swiftui/controlsize",
        "html": "Topics\nGetting control sizes\ncase mini\nA control version that is minimally sized.\ncase small\nA control version that is proportionally smaller size for space-constrained views.\ncase regular\nA control version that is the default size.\ncase large\nA control version that is prominently sized.\ncase extraLarge\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nSizing controls\nfunc controlSize(ControlSize) -> some View\nSets the size for controls within this view.\nvar controlSize: ControlSize\nThe size to apply to controls within a view."
    },
    {
        "title": "controlSize(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/controlsize(_:)",
        "html": "Parameters\ncontrolSize\n\nOne of the control sizes specified in the ControlSize enumeration.\n\nDiscussion\n\nUse controlSize(_:) to override the system default size for controls in this view. In this example, a view displays several typical controls at .mini, .small and .regular sizes.\n\nstruct ControlSize: View {\n    var body: some View {\n        VStack {\n            MyControls(label: \"Mini\")\n                .controlSize(.mini)\n            MyControls(label: \"Small\")\n                .controlSize(.small)\n            MyControls(label: \"Regular\")\n                .controlSize(.regular)\n        }\n        .padding()\n        .frame(width: 450)\n        .border(Color.gray)\n    }\n}\n\n\nstruct MyControls: View {\n    var label: String\n    @State private var value = 3.0\n    @State private var selected = 1\n    var body: some View {\n        HStack {\n            Text(label + \":\")\n            Picker(\"Selection\", selection: $selected) {\n                Text(\"option 1\").tag(1)\n                Text(\"option 2\").tag(2)\n                Text(\"option 3\").tag(3)\n            }\n            Slider(value: $value, in: 1...10)\n            Button(\"OK\") { }\n        }\n    }\n}\n\n\nSee Also\nSizing controls\nvar controlSize: ControlSize\nThe size to apply to controls within a view.\nenum ControlSize\nThe size classes, like regular or small, that you can apply to controls within a view."
    },
    {
        "title": "controlSize",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/controlsize",
        "html": "Discussion\n\nThe default is ControlSize.regular.\n\nSee Also\nSizing controls\nfunc controlSize(ControlSize) -> some View\nSets the size for controls within this view.\nenum ControlSize\nThe size classes, like regular or small, that you can apply to controls within a view."
    },
    {
        "title": "NavigationSplitViewVisibility",
        "url": "https://developer.apple.com/documentation/swiftui/navigationsplitviewvisibility",
        "html": "Overview\n\nUse a value of this type to control the visibility of the columns of a NavigationSplitView. Create a State property with a value of this type, and pass a Binding to that state to the init(columnVisibility:sidebar:detail:) or init(columnVisibility:sidebar:content:detail:) initializer when you create the navigation split view. You can then modify the value elsewhere in your code to:\n\nHide all but the trailing column with detailOnly.\n\nHide the leading column of a three-column navigation split view with doubleColumn.\n\nShow all the columns with all.\n\nRely on the automatic behavior for the current context with automatic.\n\nNote\n\nSome platforms don\u2019t respect every option. For example, macOS always displays the content column.\n\nTopics\nGetting visibilities\nstatic var automatic: NavigationSplitViewVisibility\nUse the default leading column visibility for the current device.\nstatic var all: NavigationSplitViewVisibility\nShow all the columns of a three-column navigation split view.\nstatic var doubleColumn: NavigationSplitViewVisibility\nShow the content column and detail area of a three-column navigation split view, or the sidebar column and detail area of a two-column navigation split view.\nstatic var detailOnly: NavigationSplitViewVisibility\nHide the leading two columns of a three-column navigation split view, so that just the detail area shows.\nRelationships\nConforms To\nDecodable\nEncodable\nEquatable\nSendable\nSee Also\nPresenting views in columns\nMigrating to new navigation types\nImprove navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.\nstruct NavigationSplitView\nA view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nstruct NavigationLink\nA view that controls a navigation presentation."
    },
    {
        "title": "navigationSplitViewColumnWidth(min:ideal:max:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(min:ideal:max:)",
        "html": "Discussion\n\nApply this modifier to the content of a column in a NavigationSplitView to specify a preferred flexible width for the column. Use navigationSplitViewColumnWidth(_:) if you need to specify a fixed width.\n\nThe following example shows a three-column navigation split view where the first column has a preferred width of 150 points, and the second column has a flexible, preferred width between 150 and 400 points:\n\nNavigationSplitView {\n    MySidebar()\n        .navigationSplitViewColumnWidth(150)\n} contents: {\n    MyContents()\n        .navigationSplitViewColumnWidth(\n            min: 150, ideal: 200, max: 400)\n} detail: {\n    MyDetail()\n}\n\n\nOnly some platforms enable resizing columns. If you specify a width that the current presentation environment doesn\u2019t support, SwiftUI may use a different width for your column.\n\nSee Also\nPresenting views in columns\nMigrating to new navigation types\nImprove navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.\nstruct NavigationSplitView\nA view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nstruct NavigationSplitViewVisibility\nThe visibility of the leading columns in a navigation split view.\nstruct NavigationLink\nA view that controls a navigation presentation."
    },
    {
        "title": "Bringing robust navigation structure to your SwiftUI app",
        "url": "https://developer.apple.com/documentation/swiftui/bringing_robust_navigation_structure_to_your_swiftui_app",
        "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC22 session 10054: The SwiftUI cookbook for navigation."
    },
    {
        "title": "sensoryFeedback(_:trigger:condition:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/sensoryfeedback(_:trigger:condition:)",
        "html": "Parameters\nfeedback\n\nWhich type of feedback to play.\n\ntrigger\n\nA value to monitor for changes to determine when to play.\n\ncondition\n\nA closure to determine whether to play the feedback when trigger changes.\n\nDiscussion\n\nFor example, you could play feedback for certain state transitions:\n\nstruct MyView: View {\n    @State private var phase = Phase.inactive\n\n\n    var body: some View {\n        ContentView(phase: $phase)\n            .sensoryFeedback(.selection, trigger: phase) { old, new in\n                old == .inactive || new == .expanded\n            }\n    }\n\n\n    enum Phase {\n        case inactive\n        case preparing\n        case active\n        case expanded\n    }\n}\n\nSee Also\nProviding haptic feedback\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> some View\nPlays the specified feedback when the provided trigger value changes.\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> some View\nPlays feedback when returned from the feedback closure after the provided trigger value changes.\nstruct SensoryFeedback\nRepresents a type of haptic and/or audio feedback that can be played."
    },
    {
        "title": "ProgressView",
        "url": "https://developer.apple.com/documentation/swiftui/progressview",
        "html": "Overview\n\nUse a progress view to show that a task is incomplete but advancing toward completion. A progress view can show both determinate (percentage complete) and indeterminate (progressing or not) types of progress.\n\nCreate a determinate progress view by initializing a ProgressView with a binding to a numeric value that indicates the progress, and a total value that represents completion of the task. By default, the progress is 0.0 and the total is 1.0.\n\nThe example below uses the state property progress to show progress in a determinate ProgressView. The progress view uses its default total of 1.0, and because progress starts with an initial value of 0.5, the progress view begins half-complete. A \u201cMore\u201d button below the progress view allows people to increment the progress in increments of five percent:\n\nstruct LinearProgressDemoView: View {\n    @State private var progress = 0.5\n\n\n    var body: some View {\n        VStack {\n            ProgressView(value: progress)\n            Button(\"More\") { progress += 0.05 }\n        }\n    }\n}\n\n\nTo create an indeterminate progress view, use an initializer that doesn\u2019t take a progress value:\n\nvar body: some View {\n    ProgressView()\n}\n\n\nYou can also create a progress view that covers a closed range of Date values. As long as the current date is within the range, the progress view automatically updates, filling or depleting the progress view as it nears the end of the range. The following example shows a five-minute timer whose start time is that of the progress view\u2019s initialization:\n\nstruct DateRelativeProgressDemoView: View {\n    let workoutDateRange = Date()...Date().addingTimeInterval(5*60)\n\n\n    var body: some View {\n         ProgressView(timerInterval: workoutDateRange) {\n             Text(\"Workout\")\n         }\n    }\n}\n\n\nStyling progress views\n\nYou can customize the appearance and interaction of progress views by creating styles that conform to the ProgressViewStyle protocol. To set a specific style for all progress view instances within a view, use the progressViewStyle(_:) modifier. In the following example, a custom style adds a rounded pink border to all progress views within the enclosing VStack:\n\nstruct BorderedProgressViews: View {\n    var body: some View {\n        VStack {\n            ProgressView(value: 0.25) { Text(\"25% progress\") }\n            ProgressView(value: 0.75) { Text(\"75% progress\") }\n        }\n        .progressViewStyle(PinkBorderedProgressViewStyle())\n    }\n}\n\n\nstruct PinkBorderedProgressViewStyle: ProgressViewStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        ProgressView(configuration)\n            .padding(4)\n            .border(.pink, width: 3)\n            .cornerRadius(4)\n    }\n}\n\n\nSwiftUI provides two built-in progress view styles, linear and circular, as well as an automatic style that defaults to the most appropriate style in the current context. The following example shows a circular progress view that starts at 60 percent completed.\n\nstruct CircularProgressDemoView: View {\n    @State private var progress = 0.6\n\n\n    var body: some View {\n        VStack {\n            ProgressView(value: progress)\n                .progressViewStyle(.circular)\n        }\n    }\n}\n\n\nOn platforms other than macOS, the circular style may appear as an indeterminate indicator instead.\n\nTopics\nCreating an indeterminate progress view\ninit()\nCreates a progress view for showing indeterminate progress, without a label.\nAvailable when Label conforms to View and CurrentValueLabel is EmptyView.\ninit(label: () -> Label)\nCreates a progress view for showing indeterminate progress that displays a custom label.\nAvailable when Label conforms to View and CurrentValueLabel is EmptyView.\ninit(LocalizedStringKey)\nCreates a progress view for showing indeterminate progress that generates its label from a localized string.\nAvailable when Label conforms to View and CurrentValueLabel is EmptyView.\ninit<S>(S)\nCreates a progress view for showing indeterminate progress that generates its label from a string.\nAvailable when Label conforms to View and CurrentValueLabel is EmptyView.\nCreating a determinate progress view\ninit(Progress)\nCreates a progress view for visualizing the given progress instance.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\ninit<V>(value: V?, total: V)\nCreates a progress view for showing determinate progress.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\ninit<V>(LocalizedStringKey, value: V?, total: V)\nCreates a progress view for showing determinate progress that generates its label from a localized string.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\ninit<S, V>(S, value: V?, total: V)\nCreates a progress view for showing determinate progress that generates its label from a string.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\ninit<V>(value: V?, total: V, label: () -> Label)\nCreates a progress view for showing determinate progress, with a custom label.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\ninit<V>(value: V?, total: V, label: () -> Label, currentValueLabel: () -> CurrentValueLabel)\nCreates a progress view for showing determinate progress, with a custom label.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\nCreate a progress view spanning a date range\ninit(timerInterval: ClosedRange<Date>, countsDown: Bool)\nCreates a progress view for showing continuous progress as time passes.\nAvailable when Label is EmptyView and CurrentValueLabel is DefaultDateProgressLabel.\ninit(timerInterval: ClosedRange<Date>, countsDown: Bool, label: () -> Label)\nCreates a progress view for showing continuous progress as time passes, with a descriptive label.\nAvailable when Label conforms to View and CurrentValueLabel is DefaultDateProgressLabel.\ninit(timerInterval: ClosedRange<Date>, countsDown: Bool, label: () -> Label, currentValueLabel: () -> CurrentValueLabel)\nCreates a progress view for showing continuous progress as time passes, with descriptive and current progress labels.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\nCreating a configured progress view\ninit(ProgressViewStyleConfiguration)\nCreates a progress view based on a style configuration.\nAvailable when Label conforms to View and CurrentValueLabel conforms to View.\nRelationships\nConforms To\nView\nSee Also\nIndicating a value\nstruct Gauge\nA view that shows a value within a range.\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nstruct DefaultDateProgressLabel\nThe default type of the current value label when used by a date-relative progress view."
    },
    {
        "title": "Picker",
        "url": "https://developer.apple.com/documentation/swiftui/picker",
        "html": "Overview\n\nYou create a picker by providing a selection binding, a label, and the content for the picker to display. Set the selection parameter to a bound property that provides the value to display as the current selection. Set the label to a view that visually describes the purpose of selecting content in the picker, and then provide the content for the picker to display.\n\nFor example, consider an enumeration of ice cream flavors and a State variable to hold the selected flavor:\n\nenum Flavor: String, CaseIterable, Identifiable {\n    case chocolate, vanilla, strawberry\n    var id: Self { self }\n}\n\n\n@State private var selectedFlavor: Flavor = .chocolate\n\n\nYou can create a picker to select among the values by providing a label, a binding to the current selection, and a collection of views for the picker\u2019s content. Append a tag to each of these content views using the tag(_:) view modifier so that the type of each selection matches the type of the bound state variable:\n\nList {\n    Picker(\"Flavor\", selection: $selectedFlavor) {\n        Text(\"Chocolate\").tag(Flavor.chocolate)\n        Text(\"Vanilla\").tag(Flavor.vanilla)\n        Text(\"Strawberry\").tag(Flavor.strawberry)\n    }\n}\n\n\nIf you provide a string label for the picker, as the example above does, the picker uses it to initialize a Text view as a label. Alternatively, you can use the init(selection:content:label:) initializer to compose the label from other views. The exact appearance of the picker depends on the context. If you use a picker in a List in iOS, it appears in a row with the label and selected value, and a chevron to indicate that you can tap the row to select a new value:\n\nIterating over a picker\u2019s options\n\nTo provide selection values for the Picker without explicitly listing each option, you can create the picker with a ForEach:\n\nPicker(\"Flavor\", selection: $selectedFlavor) {\n    ForEach(Flavor.allCases) { flavor in\n        Text(flavor.rawValue.capitalized)\n    }\n}\n\n\nForEach automatically assigns a tag to the selection views using each option\u2019s id. This is possible because Flavor conforms to the Identifiable protocol.\n\nThe example above relies on the fact that Flavor defines the type of its id parameter to exactly match the selection type. If that\u2019s not the case, you need to override the tag. For example, consider a Topping type and a suggested topping for each flavor:\n\nenum Topping: String, CaseIterable, Identifiable {\n    case nuts, cookies, blueberries\n    var id: Self { self }\n}\n\n\nextension Flavor {\n    var suggestedTopping: Topping {\n        switch self {\n        case .chocolate: return .nuts\n        case .vanilla: return .cookies\n        case .strawberry: return .blueberries\n        }\n    }\n}\n\n\n@State private var suggestedTopping: Topping = .nuts\n\n\nThe following example shows a picker that\u2019s bound to a Topping type, while the options are all Flavor instances. Each option uses the tag modifier to associate the suggested topping with the flavor it displays:\n\nList {\n    Picker(\"Flavor\", selection: $suggestedTopping) {\n        ForEach(Flavor.allCases) { flavor in\n            Text(flavor.rawValue.capitalized)\n                .tag(flavor.suggestedTopping)\n        }\n    }\n    HStack {\n        Text(\"Suggested Topping\")\n        Spacer()\n        Text(suggestedTopping.rawValue.capitalized)\n            .foregroundStyle(.secondary)\n    }\n}\n\n\nWhen the user selects chocolate, the picker sets suggestedTopping to the value in the associated tag:\n\nOther examples of when the views in a picker\u2019s ForEach need an explicit tag modifier include when you:\n\nSelect over the cases of an enumeration that conforms to the Identifiable protocol by using anything besides Self as the id parameter type. For example, a string enumeration might use the case\u2019s rawValue string as the id. That identifier type doesn\u2019t match the selection type, which is the type of the enumeration itself.\n\nUse an optional value for the selection input parameter. For that to work, you need to explicitly cast the tag modifier\u2019s input as Optional to match. For an example of this, see tag(_:).\n\nStyling pickers\n\nYou can customize the appearance and interaction of pickers using styles that conform to the PickerStyle protocol, like segmented or menu. To set a specific style for all picker instances within a view, use the pickerStyle(_:) modifier. The following example applies the segmented style to two pickers that independently select a flavor and a topping:\n\nVStack {\n    Picker(\"Flavor\", selection: $selectedFlavor) {\n        ForEach(Flavor.allCases) { flavor in\n            Text(flavor.rawValue.capitalized)\n        }\n    }\n    Picker(\"Topping\", selection: $selectedTopping) {\n        ForEach(Topping.allCases) { topping in\n            Text(topping.rawValue.capitalized)\n        }\n    }\n}\n.pickerStyle(.segmented)\n\n\nTopics\nCreating a picker\ninit(selection: Binding<SelectionValue>, content: () -> Content, label: () -> Label)\nCreates a picker that displays a custom label.\nAvailable when Label conforms to View, SelectionValue conforms to Hashable, and Content conforms to View.\ninit(LocalizedStringKey, selection: Binding<SelectionValue>, content: () -> Content)\nCreates a picker that generates its label from a localized string key.\nAvailable when Label is Text, SelectionValue conforms to Hashable, and Content conforms to View.\ninit<S>(S, selection: Binding<SelectionValue>, content: () -> Content)\nCreates a picker that generates its label from a string.\nAvailable when Label is Text, SelectionValue conforms to Hashable, and Content conforms to View.\nCreating a picker for a collection\ninit<C>(LocalizedStringKey, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, content: () -> Content)\nCreates a picker that generates its label from a localized string key.\nAvailable when Label is Text, SelectionValue conforms to Hashable, and Content conforms to View.\ninit<C, S>(S, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, content: () -> Content)\nCreates a picker bound to a collection of bindings that generates its label from a string.\nAvailable when Label is Text, SelectionValue conforms to Hashable, and Content conforms to View.\ninit<C>(sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, content: () -> Content, label: () -> Label)\nCreates a picker that displays a custom label.\nAvailable when Label conforms to View, SelectionValue conforms to Hashable, and Content conforms to View.\nCreating a picker with an image resource label\ninit<S>(S, image: ImageResource, selection: Binding<SelectionValue>, content: () -> Content)\nCreates a picker that generates its label from a string and image resource.\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\ninit(LocalizedStringKey, image: ImageResource, selection: Binding<SelectionValue>, content: () -> Content)\nCreates a picker that generates its label from a localized string key and image resource\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\ninit<C, S>(S, image: ImageResource, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, content: () -> Content)\nCreates a picker bound to a collection of bindings that generates its label from a string and image resource.\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\ninit<C>(LocalizedStringKey, image: ImageResource, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, content: () -> Content)\nCreates a picker that generates its label from a localized string key and image resource.\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\nCreating a picker with an system image label\ninit<S>(S, systemImage: String, selection: Binding<SelectionValue>, content: () -> Content)\nCreates a picker that generates its label from a string and system image.\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\ninit(LocalizedStringKey, systemImage: String, selection: Binding<SelectionValue>, content: () -> Content)\nCreates a picker that generates its label from a localized string key and system image.\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\ninit<C>(LocalizedStringKey, systemImage: String, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, content: () -> Content)\nCreates a picker that generates its label from a localized string key.\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\ninit<C, S>(S, systemImage: String, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, content: () -> Content)\nCreates a picker bound to a collection of bindings that generates its label from a string.\nAvailable when Label is Label<Text, Image>, SelectionValue conforms to Hashable, and Content conforms to View.\nDeprecated initializers\ninit(selection: Binding<SelectionValue>, label: Label, content: () -> Content)\nCreates a picker that displays a custom label.\nAvailable when Label conforms to View, SelectionValue conforms to Hashable, and Content conforms to View.\nDeprecated\nRelationships\nConforms To\nView\nSee Also\nChoosing from a set of options\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item.\nstruct PaletteSelectionEffect\nThe selection effect to apply to a palette item."
    },
    {
        "title": "ContentUnavailableView",
        "url": "https://developer.apple.com/documentation/swiftui/contentunavailableview",
        "html": "Overview\n\nIt is recommended to use ContentUnavailableView in situations where a view\u2019s content cannot be displayed. That could be caused by a network error, a list without items, a search that returns no results etc.\n\nYou create an ContentUnavailableView in its simplest form, by providing a label and some additional content such as a description or a call to action:\n\nContentUnavailableView {\n    Label(\"No Mail\", systemImage: \"tray.fill\")\n} description: {\n    Text(\"New mails you receive will appear here.\")\n}\n\n\nThe system provides default ContentUnavailableViews that you can use in specific situations. The example below illustrates the usage of the search view:\n\nstruct ContentView: View {\n    @ObservedObject private var viewModel = ContactsViewModel()\n\n\n    var body: some View {\n        NavigationStack {\n            List {\n                ForEach(viewModel.searchResults) { contact in\n                    NavigationLink {\n                        ContactsView(contact)\n                    } label: {\n                        Text(contact.name)\n                    }\n                }\n            }\n            .navigationTitle(\"Contacts\")\n            .searchable(text: $viewModel.searchText)\n            .overlay {\n                if searchResults.isEmpty {\n                    ContentUnavailableView.search\n                }\n            }\n        }\n    }\n}\n\nTopics\nGetting built-in unavailable views\nstatic var search: ContentUnavailableView<SearchUnavailableContent.Label, SearchUnavailableContent.Description, SearchUnavailableContent.Actions>\nCreates a ContentUnavailableView instance that conveys a search state.\nAvailable when Label is SearchUnavailableContent.Label, Description is SearchUnavailableContent.Description, and Actions is SearchUnavailableContent.Actions.\nstatic func search(text: String) -> ContentUnavailableView<Label, Description, Actions>\nCreates a ContentUnavailableView instance that conveys a search state.\nAvailable when Label is SearchUnavailableContent.Label, Description is SearchUnavailableContent.Description, and Actions is SearchUnavailableContent.Actions.\nCreating an unavailable view\ninit(label: () -> Label, description: () -> Description, actions: () -> Actions)\nCreates an interface, consisting of a label and additional content, that you display when the content of your app is unavailable to users.\nCreating an unavailable view with an image\ninit(LocalizedStringKey, image: String, description: Text?)\nCreates an interface, consisting of a title generated from a localized string, an image and additional content, that you display when the content of your app is unavailable to users.\nAvailable when Label is Label<Text, Image>, Description is Text?, and Actions is EmptyView.\ninit<S>(S, image: String, description: Text?)\nCreates an interface, consisting of a title generated from a string, an image and additional content, that you display when the content of your app is unavailable to users.\nAvailable when Label is Label<Text, Image>, Description is Text?, and Actions is EmptyView.\nCreating an unavailable view with a system image\ninit(LocalizedStringKey, systemImage: String, description: Text?)\nCreates an interface, consisting of a title generated from a localized string, a system icon image and additional content, that you display when the content of your app is unavailable to users.\nAvailable when Label is Label<Text, Image>, Description is Text?, and Actions is EmptyView.\ninit<S>(S, systemImage: String, description: Text?)\nCreates an interface, consisting of a title generated from a string, a system icon image and additional content, that you display when the content of your app is unavailable to users.\nAvailable when Label is Label<Text, Image>, Description is Text?, and Actions is EmptyView.\nSupporting types\nstruct SearchUnavailableContent\nA structure that represents the body of a static placeholder search view.\nRelationships\nConforms To\nView"
    },
    {
        "title": "DefaultDateProgressLabel",
        "url": "https://developer.apple.com/documentation/swiftui/defaultdateprogresslabel",
        "html": "Relationships\nConforms To\nView\nSee Also\nIndicating a value\nstruct Gauge\nA view that shows a value within a range.\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nstruct ProgressView\nA view that shows the progress toward completion of a task.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view."
    },
    {
        "title": "Gauge",
        "url": "https://developer.apple.com/documentation/swiftui/gauge",
        "html": "Overview\n\nA gauge is a view that shows a current level of a value in relation to a specified finite capacity, very much like a fuel gauge in an automobile. Gauge displays are configurable; they can show any combination of the gauge\u2019s current value, the range the gauge can display, and a label describing the purpose of the gauge itself.\n\nIn its most basic form, a gauge displays a single value along the path of the gauge mapped into a range from 0 to 100 percent. The example below sets the gauge\u2019s indicator to a position 40 percent along the gauge\u2019s path:\n\nstruct SimpleGauge: View {\n    @State private var batteryLevel = 0.4\n\n\n    var body: some View {\n        Gauge(value: batteryLevel) {\n            Text(\"Battery Level\")\n        }\n    }\n}\n\n\nYou can make a gauge more descriptive by describing its purpose, showing its current value and its start and end values. This example shows the gauge variant that accepts a range and adds labels using multiple trailing closures describing the current value and the minimum and maximum values of the gauge:\n\nstruct LabeledGauge: View {\n    @State private var current = 67.0\n    @State private var minValue = 0.0\n    @State private var maxValue = 170.0\n\n\n    var body: some View {\n        Gauge(value: current, in: minValue...maxValue) {\n            Text(\"BPM\")\n        } currentValueLabel: {\n            Text(\"\\(Int(current))\")\n        } minimumValueLabel: {\n            Text(\"\\(Int(minValue))\")\n        } maximumValueLabel: {\n            Text(\"\\(Int(maxValue))\")\n        }\n    }\n}\n\n\nAs shown above, the default style for gauges is a linear, continuous bar with an indicator showing the current value, and optional labels describing the gauge\u2019s purpose, current, minimum, and maximum values.\n\nNote\n\nSome visual presentations of Gauge don\u2019t display all the labels required by the API. However, the accessibility system does use the label content and you should use these labels to fully describe the gauge for accessibility users.\n\nTo change the style of a gauge, use the gaugeStyle(_:) view modifier and supply an initializer for a specific gauge style. For example, to display the same gauge in a circular style, apply the circular style to the view:\n\nstruct LabeledGauge: View {\n    @State private var current = 67.0\n    @State private var minValue = 0.0\n    @State private var maxValue = 170.0\n\n\n    var body: some View {\n        Gauge(value: current, in: minValue...maxValue) {\n            Text(\"BPM\")\n        } currentValueLabel: {\n            Text(\"\\(Int(current))\")\n        } minimumValueLabel: {\n            Text(\"\\(Int(minValue))\")\n        } maximumValueLabel: {\n            Text(\"\\(Int(maxValue))\")\n        }\n        .gaugeStyle(.circular)\n    }\n}\n\n\nTo style elements of a gauge\u2019s presentation, you apply view modifiers to the elements that you want to change. In the example below, the current value, minimum and maximum value labels have custom colors:\n\nstruct StyledGauge: View {\n    @State private var current = 67.0\n    @State private var minValue = 50.0\n    @State private var maxValue = 170.0\n\n\n    var body: some View {\n        Gauge(value: current, in: minValue...maxValue) {\n            Image(systemName: \"heart.fill\")\n                .foregroundColor(.red)\n        } currentValueLabel: {\n            Text(\"\\(Int(current))\")\n                .foregroundColor(Color.green)\n        } minimumValueLabel: {\n            Text(\"\\(Int(minValue))\")\n                .foregroundColor(Color.green)\n        } maximumValueLabel: {\n            Text(\"\\(Int(maxValue))\")\n                .foregroundColor(Color.red)\n        }\n        .gaugeStyle(.circular)\n    }\n}\n\n\nYou can further style a gauge\u2019s appearance by supplying a tint color or a gradient to the style\u2019s initializer. The following example shows the effect of a gradient in the initialization of a CircularGaugeStyle gauge with a colorful gradient across the length of the gauge:\n\nstruct StyledGauge: View {\n    @State private var current = 67.0\n    @State private var minValue = 50.0\n    @State private var maxValue = 170.0\n    let gradient = Gradient(colors: [.green, .yellow, .orange, .red])\n\n\n    var body: some View {\n        Gauge(value: current, in: minValue...maxValue) {\n            Image(systemName: \"heart.fill\")\n                .foregroundColor(.red)\n        } currentValueLabel: {\n            Text(\"\\(Int(current))\")\n                .foregroundColor(Color.green)\n        } minimumValueLabel: {\n            Text(\"\\(Int(minValue))\")\n                .foregroundColor(Color.green)\n        } maximumValueLabel: {\n            Text(\"\\(Int(maxValue))\")\n                .foregroundColor(Color.red)\n        }\n        .gaugeStyle(CircularGaugeStyle(tint: gradient))\n    }\n}\n\n\nTopics\nCreating a gauge\ninit<V>(value: V, in: ClosedRange<V>, label: () -> Label)\nCreates a gauge showing a value within a range and describes the gauge\u2019s purpose and current value.\ninit<V>(value: V, in: ClosedRange<V>, label: () -> Label, currentValueLabel: () -> CurrentValueLabel)\nCreates a gauge showing a value within a range and that describes the gauge\u2019s purpose and current value.\ninit<V>(value: V, in: ClosedRange<V>, label: () -> Label, currentValueLabel: () -> CurrentValueLabel, markedValueLabels: () -> MarkedValueLabels)\nCreates a gauge representing a value within a range.\ninit<V>(value: V, in: ClosedRange<V>, label: () -> Label, currentValueLabel: () -> CurrentValueLabel, minimumValueLabel: () -> BoundsLabel, maximumValueLabel: () -> BoundsLabel)\nCreates a gauge showing a value within a range and describes the gauge\u2019s current, minimum, and maximum values.\ninit<V>(value: V, in: ClosedRange<V>, label: () -> Label, currentValueLabel: () -> CurrentValueLabel, minimumValueLabel: () -> BoundsLabel, maximumValueLabel: () -> BoundsLabel, markedValueLabels: () -> MarkedValueLabels)\nCreates a gauge representing a value within a range.\nRelationships\nConforms To\nView\nSee Also\nIndicating a value\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nstruct ProgressView\nA view that shows the progress toward completion of a task.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nstruct DefaultDateProgressLabel\nThe default type of the current value label when used by a date-relative progress view."
    },
    {
        "title": "DatePicker",
        "url": "https://developer.apple.com/documentation/swiftui/datepicker",
        "html": "Overview\n\nUse a DatePicker when you want to provide a view that allows the user to select a calendar date, and optionally a time. The view binds to a Date instance.\n\nThe following example creates a basic DatePicker, which appears on iOS as text representing the date. This example limits the display to only the calendar date, not the time. When the user taps or clicks the text, a calendar view animates in, from which the user can select a date. When the user dismisses the calendar view, the view updates the bound Date.\n\n@State private var date = Date()\n\n\nvar body: some View {\n    DatePicker(\n        \"Start Date\",\n        selection: $date,\n        displayedComponents: [.date]\n    )\n}\n\n\nYou can limit the DatePicker to specific ranges of dates, allowing selections only before or after a certain date, or between two dates. The following example shows a date-and-time picker that only permits selections within the year 2021 (in the UTC time zone).\n\n@State private var date = Date()\nlet dateRange: ClosedRange<Date> = {\n    let calendar = Calendar.current\n    let startComponents = DateComponents(year: 2021, month: 1, day: 1)\n    let endComponents = DateComponents(year: 2021, month: 12, day: 31, hour: 23, minute: 59, second: 59)\n    return calendar.date(from:startComponents)!\n        ...\n        calendar.date(from:endComponents)!\n}()\n\n\nvar body: some View {\n    DatePicker(\n        \"Start Date\",\n         selection: $date,\n         in: dateRange,\n         displayedComponents: [.date, .hourAndMinute]\n    )\n}\n\n\nStyling date pickers\n\nTo use a different style of date picker, use the datePickerStyle(_:) view modifier. The following example shows the graphical date picker style.\n\n@State private var date = Date()\n\n\nvar body: some View {\n    DatePicker(\n        \"Start Date\",\n        selection: $date,\n        displayedComponents: [.date]\n    )\n    .datePickerStyle(.graphical)\n}\n\n\nTopics\nCreating a date picker for any date\ninit(selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components, label: () -> Label)\nCreates an instance that selects a Date with an unbounded range.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date with an unbounded range.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date within the given range.\nAvailable when Label is Text.\nCreating a date picker for a range\ninit(selection: Binding<Date>, in: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components, label: () -> Label)\nCreates an instance that selects a Date in a closed range.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, selection: Binding<Date>, in: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date in a closed range.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Date>, in: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date in a closed range.\nAvailable when Label is Text.\nCreating a date picker with a start date\ninit(selection: Binding<Date>, in: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components, label: () -> Label)\nCreates an instance that selects a Date on or after some start date.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, selection: Binding<Date>, in: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date on or after some start date.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Date>, in: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date on or after some start date.\nAvailable when Label is Text.\nCreating a date picker with an end date\ninit(selection: Binding<Date>, in: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components, label: () -> Label)\nCreates an instance that selects a Date on or before some end date.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, selection: Binding<Date>, in: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date on or before some end date.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Date>, in: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components)\nCreates an instance that selects a Date on or before some end date.\nAvailable when Label is Text.\nSetting date picker components\ntypealias Components\nstruct DatePickerComponents\nRelationships\nConforms To\nView\nSee Also\nChoosing dates\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nstruct MultiDatePicker\nA control for picking multiple dates.\nvar calendar: Calendar\nThe current calendar that views should use when handling dates.\nvar timeZone: TimeZone\nThe current time zone that views should use when handling dates."
    },
    {
        "title": "Toggle",
        "url": "https://developer.apple.com/documentation/swiftui/toggle",
        "html": "Overview\n\nYou create a toggle by providing an isOn binding and a label. Bind isOn to a Boolean property that determines whether the toggle is on or off. Set the label to a view that visually describes the purpose of switching between toggle states. For example:\n\n@State private var vibrateOnRing = false\n\n\nvar body: some View {\n    Toggle(isOn: $vibrateOnRing) {\n        Text(\"Vibrate on Ring\")\n    }\n}\n\n\nFor the common case of Label based labels, you can use the convenience initializer that takes a title string (or localized string key) and the name of a system image:\n\n@State private var vibrateOnRing = true\n\n\nvar body: some View {\n    Toggle(\n        \"Vibrate on Ring\",\n        systemImage: \"dot.radiowaves.left.and.right\",\n        isOn: $vibrateOnRing\n    )\n}\n\n\nFor text-only labels, you can use the convenience initializer that takes a title string (or localized string key) as its first parameter, instead of a trailing closure:\n\n@State private var vibrateOnRing = true\n\n\nvar body: some View {\n    Toggle(\"Vibrate on Ring\", isOn: $vibrateOnRing)\n}\n\nStyling toggles\n\nToggles use a default style that varies based on both the platform and the context. For more information, read about the automatic toggle style.\n\nYou can customize the appearance and interaction of toggles by applying styles using the toggleStyle(_:) modifier. You can apply built-in styles, like switch, to either a toggle, or to a view hierarchy that contains toggles:\n\nVStack {\n    Toggle(\"Vibrate on Ring\", isOn: $vibrateOnRing)\n    Toggle(\"Vibrate on Silent\", isOn: $vibrateOnSilent)\n}\n.toggleStyle(.switch)\n\n\nYou can also define custom styles by creating a type that conforms to the ToggleStyle protocol.\n\nTopics\nCreating a toggle\ninit(isOn: Binding<Bool>, label: () -> Label)\nCreates a toggle that displays a custom label.\ninit(LocalizedStringKey, isOn: Binding<Bool>)\nCreates a toggle that generates its label from a localized string key.\nAvailable when Label is Text.\ninit<S>(S, isOn: Binding<Bool>)\nCreates a toggle that generates its label from a string.\nAvailable when Label is Text.\nCreating a toggle for a collection\ninit<C>(sources: C, isOn: KeyPath<C.Element, Binding<Bool>>, label: () -> Label)\nCreates a toggle representing a collection of values with a custom label.\ninit<S, C>(S, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>)\nCreates a toggle representing a collection of values that generates its label from a string.\nAvailable when Label is Text.\ninit<C>(LocalizedStringKey, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>)\nCreates a toggle representing a collection of values that generates its label from a localized string key.\nAvailable when Label is Text.\nCreating a toggle with an image resource label\ninit(LocalizedStringKey, image: ImageResource, isOn: Binding<Bool>)\nCreates a toggle that generates its label from a localized string key and image resource.\nAvailable when Label is Label<Text, Image>.\ninit<S>(S, image: ImageResource, isOn: Binding<Bool>)\nCreates a toggle that generates its label from a string and image resource.\nAvailable when Label is Label<Text, Image>.\ninit<C>(LocalizedStringKey, image: ImageResource, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>)\nCreates a toggle representing a collection of values that generates its label from a localized string key and image resource.\nAvailable when Label is Label<Text, Image>.\ninit<S, C>(S, image: ImageResource, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>)\nCreates a toggle representing a collection of values that generates its label from a string and image resource.\nAvailable when Label is Label<Text, Image>.\nCreating a toggle with an system image\ninit(LocalizedStringKey, systemImage: String, isOn: Binding<Bool>)\nCreates a toggle that generates its label from a localized string key and system image.\nAvailable when Label is Label<Text, Image>.\ninit<S>(S, systemImage: String, isOn: Binding<Bool>)\nCreates a toggle that generates its label from a string and system image.\nAvailable when Label is Label<Text, Image>.\ninit<C>(LocalizedStringKey, systemImage: String, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>)\nCreates a toggle representing a collection of values that generates its label from a localized string key and system image.\nAvailable when Label is Label<Text, Image>.\ninit<S, C>(S, systemImage: String, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>)\nCreates a toggle representing a collection of values that generates its label from a string.\nAvailable when Label is Label<Text, Image>.\nCreating a toggle from a configuration\ninit(ToggleStyleConfiguration)\nCreates a toggle based on a toggle style configuration.\nAvailable when Label is ToggleStyleConfiguration.Label.\nCreating a toggle for an App Intent\ninit<I>(isOn: Bool, intent: I, label: () -> Label)\nCreates a toggle performing an AppIntent.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, isOn: Bool, intent: some AppIntent)\nCreates a toggle performing an AppIntent and generates its label from a localized string key.\nAvailable when Label is Text.\ninit<S>(S, isOn: Bool, intent: some AppIntent)\nCreates a toggle that generates its label from a string.\nAvailable when Label is Text.\nRelationships\nConforms To\nView\nSee Also\nGetting numeric inputs\nstruct Slider\nA control for selecting a value from a bounded linear range of values.\nstruct Stepper\nA control that performs increment and decrement actions.\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy."
    },
    {
        "title": "ColorPicker",
        "url": "https://developer.apple.com/documentation/swiftui/colorpicker",
        "html": "Overview\n\nThe color picker provides a color well that shows the currently selected color, and displays the larger system color picker that allows users to select a new color.\n\nBy default color picker supports colors with opacity; to disable opacity support, set the supportsOpacity parameter to false. In this mode the color picker won\u2019t show controls for adjusting the opacity of the selected color, and strips out opacity from any color set programmatically or selected from the user\u2019s system favorites.\n\nYou use ColorPicker by embedding it inside a view hierarchy and initializing it with a title string and a Binding to a Color:\n\nstruct FormattingControls: View {\n    @State private var bgColor =\n        Color(.sRGB, red: 0.98, green: 0.9, blue: 0.2)\n\n\n    var body: some View {\n        VStack {\n            ColorPicker(\"Alignment Guides\", selection: $bgColor)\n        }\n    }\n}\n\nTopics\nCreating a color picker\ninit(selection: Binding<Color>, supportsOpacity: Bool, label: () -> Label)\nCreates an instance that selects a color.\ninit(LocalizedStringKey, selection: Binding<Color>, supportsOpacity: Bool)\nCreates a color picker with a text label generated from a title string key.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Color>, supportsOpacity: Bool)\nCreates a color picker with a text label generated from a title string.\nAvailable when Label is Text.\nCreating a core graphics color picker\ninit(selection: Binding<CGColor>, supportsOpacity: Bool, label: () -> Label)\nCreates an instance that selects a color.\ninit(LocalizedStringKey, selection: Binding<CGColor>, supportsOpacity: Bool)\nCreates a color picker with a text label generated from a title string key.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<CGColor>, supportsOpacity: Bool)\nCreates a color picker with a text label generated from a title string.\nAvailable when Label is Text.\nRelationships\nConforms To\nView"
    },
    {
        "title": "Stepper",
        "url": "https://developer.apple.com/documentation/swiftui/stepper",
        "html": "Overview\n\nUse a stepper control when you want the user to have granular control while incrementing or decrementing a value. For example, you can use a stepper to:\n\nChange a value up or down by 1.\n\nOperate strictly over a prescribed range.\n\nStep by specific amounts over a stepper\u2019s range of possible values.\n\nThe example below uses an array that holds a number of Color values, a local state variable, value, to set the control\u2019s background color, and title label. When the user clicks or taps the stepper\u2019s increment or decrement buttons, SwiftUI executes the relevant closure that updates value, wrapping the value to prevent overflow. SwiftUI then re-renders the view, updating the text and background color to match the current index:\n\nstruct StepperView: View {\n    @State private var value = 0\n    let colors: [Color] = [.orange, .red, .gray, .blue,\n                           .green, .purple, .pink]\n\n\n    func incrementStep() {\n        value += 1\n        if value >= colors.count { value = 0 }\n    }\n\n\n    func decrementStep() {\n        value -= 1\n        if value < 0 { value = colors.count - 1 }\n    }\n\n\n    var body: some View {\n        Stepper {\n            Text(\"Value: \\(value) Color: \\(colors[value].description)\")\n        } onIncrement: {\n            incrementStep()\n        } onDecrement: {\n            decrementStep()\n        }\n        .padding(5)\n        .background(colors[value])\n    }\n}\n\n\nThe following example shows a stepper that displays the effect of incrementing or decrementing a value with the step size of step with the bounds defined by range:\n\nstruct StepperView: View {\n    @State private var value = 0\n    let step = 5\n    let range = 1...50\n\n\n    var body: some View {\n        Stepper(\n            value: $value,\n            in: range,\n            step: step\n        ) {\n            Text(\"Current: \\(value) in \\(range.description) \" +\n                 \"stepping by \\(step)\")\n        }\n        .padding(10)\n    }\n}\n\n\nTopics\nCreating a stepper\ninit<V>(value: Binding<V>, step: V.Stride, label: () -> Label, onEditingChanged: (Bool) -> Void)\nCreates a stepper configured to increment or decrement a binding to a value using a step value you provide.\nAvailable when Label conforms to View.\ninit<F>(value: Binding<F.FormatInput>, step: F.FormatInput.Stride, format: F, label: () -> Label, onEditingChanged: (Bool) -> Void)\nCreates a stepper configured to increment or decrement a binding to a value using a step value you provide, displaying its value with an applied format style.\nAvailable when Label conforms to View.\ninit<V>(LocalizedStringKey, value: Binding<V>, step: V.Stride, onEditingChanged: (Bool) -> Void)\nCreates a stepper with a title key and configured to increment and decrement a binding to a value and step amount you provide.\nAvailable when Label is Text.\ninit<S, V>(S, value: Binding<V>, step: V.Stride, onEditingChanged: (Bool) -> Void)\nCreates a stepper with a title and configured to increment and decrement a binding to a value and step amount you provide.\nAvailable when Label is Text.\ninit<S, F>(S, value: Binding<F.FormatInput>, step: F.FormatInput.Stride, format: F, onEditingChanged: (Bool) -> Void)\nCreates a stepper with a title and configured to increment and decrement a binding to a value and step amount you provide, displaying its value with an applied format style.\nAvailable when Label is Text.\ninit<F>(LocalizedStringKey, value: Binding<F.FormatInput>, step: F.FormatInput.Stride, format: F, onEditingChanged: (Bool) -> Void)\nCreates a stepper with a title key and configured to increment and decrement a binding to a value and step amount you provide, displaying its value with an applied format style.\nAvailable when Label is Text.\nCreating a stepper over a range\ninit<V>(value: Binding<V>, in: ClosedRange<V>, step: V.Stride, label: () -> Label, onEditingChanged: (Bool) -> Void)\nCreates a stepper configured to increment or decrement a binding to a value using a step value and within a range of values you provide.\nAvailable when Label conforms to View.\ninit<F>(value: Binding<F.FormatInput>, in: ClosedRange<F.FormatInput>, step: F.FormatInput.Stride, format: F, label: () -> Label, onEditingChanged: (Bool) -> Void)\nCreates a stepper configured to increment or decrement a binding to a value using a step value and within a range of values you provide, displaying its value with an applied format style.\nAvailable when Label conforms to View.\ninit<V>(LocalizedStringKey, value: Binding<V>, in: ClosedRange<V>, step: V.Stride, onEditingChanged: (Bool) -> Void)\nCreates a stepper instance that increments and decrements a binding to a value, by a step size and within a closed range that you provide.\nAvailable when Label is Text.\ninit<S, V>(S, value: Binding<V>, in: ClosedRange<V>, step: V.Stride, onEditingChanged: (Bool) -> Void)\nCreates a stepper instance that increments and decrements a binding to a value, by a step size and within a closed range that you provide.\nAvailable when Label is Text.\ninit<F>(LocalizedStringKey, value: Binding<F.FormatInput>, in: ClosedRange<F.FormatInput>, step: F.FormatInput.Stride, format: F, onEditingChanged: (Bool) -> Void)\nCreates a stepper instance that increments and decrements a binding to a value, by a step size and within a closed range that you provide, displaying its value with an applied format style.\nAvailable when Label is Text.\ninit<S, F>(S, value: Binding<F.FormatInput>, in: ClosedRange<F.FormatInput>, step: F.FormatInput.Stride, format: F, onEditingChanged: (Bool) -> Void)\nCreates a stepper instance that increments and decrements a binding to a value, by a step size and within a closed range that you provide, displaying its value with an applied format style.\nAvailable when Label is Text.\nCreating a stepper with change behavior\ninit(label: () -> Label, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: (Bool) -> Void)\nCreates a stepper instance that performs the closures you provide when the user increments or decrements the stepper.\ninit(LocalizedStringKey, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: (Bool) -> Void)\nCreates a stepper that uses a title key and executes the closures you provide when the user clicks or taps the stepper\u2019s increment and decrement buttons.\nAvailable when Label is Text.\ninit<S>(S, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: (Bool) -> Void)\nCreates a stepper using a title string and that executes closures you provide when the user clicks or taps the stepper\u2019s increment or decrement buttons.\nAvailable when Label is Text.\nDeprecated initializers\ninit<V>(value: Binding<V>, step: V.Stride, onEditingChanged: (Bool) -> Void, label: () -> Label)\nCreates a stepper configured to increment or decrement a binding to a value using a step value you provide.\nAvailable when Label conforms to View.\nDeprecated\ninit<V>(value: Binding<V>, in: ClosedRange<V>, step: V.Stride, onEditingChanged: (Bool) -> Void, label: () -> Label)\nCreates a stepper configured to increment or decrement a binding to a value using a step value and within a range of values you provide.\nAvailable when Label conforms to View.\nDeprecated\ninit(onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: (Bool) -> Void, label: () -> Label)\nCreates a stepper instance that performs the closures you provide when the user increments or decrements the stepper.\nAvailable when Label conforms to View.\nDeprecated\nRelationships\nConforms To\nView\nSee Also\nGetting numeric inputs\nstruct Slider\nA control for selecting a value from a bounded linear range of values.\nstruct Toggle\nA control that toggles between on and off states.\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy."
    },
    {
        "title": "timeZone",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/timezone",
        "html": "See Also\nChoosing dates\nstruct DatePicker\nA control for selecting an absolute date.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nstruct MultiDatePicker\nA control for picking multiple dates.\nvar calendar: Calendar\nThe current calendar that views should use when handling dates."
    },
    {
        "title": "paletteSelectionEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/paletteselectioneffect(_:)",
        "html": "Parameters\neffect\n\nThe type of effect to apply when a palette item is selected.\n\nDiscussion\n\nautomatic applies the system\u2019s default appearance when selected. When using un-tinted SF Symbols or template images, the current tint color is applied to the selected items\u2019 image. If the provided SF Symbols have custom tints, a stroke is drawn around selected items.\n\nIf you wish to provide a specific image (or SF Symbol) to indicate selection, use custom to forgo the system\u2019s default selection appearance allowing the provided image to solely indicate selection instead.\n\nThe following example creates a palette picker that disables the system selection behavior:\n\nMenu {\n    Picker(\"Palettes\", selection: $selection) {\n        ForEach(palettes) { palette in\n            Label(palette.title, image: selection == palette ?\n                  \"selected-palette\" : \"palette\")\n            .tint(palette.tint)\n            .tag(palette)\n        }\n    }\n    .pickerStyle(.palette)\n    .paletteSelectionEffect(.custom)\n} label: {\n    ...\n}\n\n\nIf a specific SF Symbol variant is preferable instead, use symbolVariant(_:).\n\nMenu {\n    ControlGroup {\n        ForEach(ColorTags.allCases) { colorTag in\n            Toggle(isOn: $selectedColorTags[colorTag]) {\n                Label(colorTag.name, systemImage: \"circle\")\n            }\n            .tint(colorTag.color)\n        }\n    }\n    .controlGroupStyle(.palette)\n    .paletteSelectionEffect(.symbolVariant(.fill))\n}\n\nSee Also\nChoosing from a set of options\nstruct Picker\nA control for selecting from a set of mutually exclusive values.\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nstruct PaletteSelectionEffect\nThe selection effect to apply to a palette item."
    },
    {
        "title": "PaletteSelectionEffect",
        "url": "https://developer.apple.com/documentation/swiftui/paletteselectioneffect",
        "html": "Overview\n\nYou can configure the selection effect of a palette item by using the paletteSelectionEffect(_:) view modifier.\n\nTopics\nGetting palette selection effects\nstatic var automatic: PaletteSelectionEffect\nApplies the system\u2019s default effect when selected.\nstatic var custom: PaletteSelectionEffect\nDoes not apply any system effect when selected.\nstatic func symbolVariant(SymbolVariants) -> PaletteSelectionEffect\nApplies the specified symbol variant when selected.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nChoosing from a set of options\nstruct Picker\nA control for selecting from a set of mutually exclusive values.\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item."
    },
    {
        "title": "Slider",
        "url": "https://developer.apple.com/documentation/swiftui/slider",
        "html": "Overview\n\nA slider consists of a \u201cthumb\u201d image that the user moves between two extremes of a linear \u201ctrack\u201d. The ends of the track represent the minimum and maximum possible values. As the user moves the thumb, the slider updates its bound value.\n\nThe following example shows a slider bound to the value speed. As the slider updates this value, a bound Text view shows the value updating. The onEditingChanged closure passed to the slider receives callbacks when the user drags the slider. The example uses this to change the color of the value text.\n\n@State private var speed = 50.0\n@State private var isEditing = false\n\n\nvar body: some View {\n    VStack {\n        Slider(\n            value: $speed,\n            in: 0...100,\n            onEditingChanged: { editing in\n                isEditing = editing\n            }\n        )\n        Text(\"\\(speed)\")\n            .foregroundColor(isEditing ? .red : .blue)\n    }\n}\n\n\nYou can also use a step parameter to provide incremental steps along the path of the slider. For example, if you have a slider with a range of 0 to 100, and you set the step value to 5, the slider\u2019s increments would be 0, 5, 10, and so on. The following example shows this approach, and also adds optional minimum and maximum value labels.\n\n@State private var speed = 50.0\n@State private var isEditing = false\n\n\nvar body: some View {\n    Slider(\n        value: $speed,\n        in: 0...100,\n        step: 5\n    ) {\n        Text(\"Speed\")\n    } minimumValueLabel: {\n        Text(\"0\")\n    } maximumValueLabel: {\n        Text(\"100\")\n    } onEditingChanged: { editing in\n        isEditing = editing\n    }\n    Text(\"\\(speed)\")\n        .foregroundColor(isEditing ? .red : .blue)\n}\n\n\nThe slider also uses the step to increase or decrease the value when a VoiceOver user adjusts the slider with voice commands.\n\nTopics\nCreating a slider\ninit<V>(value: Binding<V>, in: ClosedRange<V>, onEditingChanged: (Bool) -> Void)\nCreates a slider to select a value from a given range.\nAvailable when Label is EmptyView and ValueLabel is EmptyView.\ninit<V>(value: Binding<V>, in: ClosedRange<V>, step: V.Stride, onEditingChanged: (Bool) -> Void)\nCreates a slider to select a value from a given range, subject to a step increment.\nAvailable when Label is EmptyView and ValueLabel is EmptyView.\nCreating a slider with labels\ninit<V>(value: Binding<V>, in: ClosedRange<V>, label: () -> Label, onEditingChanged: (Bool) -> Void)\nCreates a slider to select a value from a given range, which displays the provided label.\nAvailable when Label conforms to View and ValueLabel is EmptyView.\ninit<V>(value: Binding<V>, in: ClosedRange<V>, step: V.Stride, label: () -> Label, onEditingChanged: (Bool) -> Void)\nCreates a slider to select a value from a given range, subject to a step increment, which displays the provided label.\nAvailable when Label conforms to View and ValueLabel is EmptyView.\ninit<V>(value: Binding<V>, in: ClosedRange<V>, label: () -> Label, minimumValueLabel: () -> ValueLabel, maximumValueLabel: () -> ValueLabel, onEditingChanged: (Bool) -> Void)\nCreates a slider to select a value from a given range, which displays the provided labels.\nAvailable when Label conforms to View and ValueLabel conforms to View.\ninit<V>(value: Binding<V>, in: ClosedRange<V>, step: V.Stride, label: () -> Label, minimumValueLabel: () -> ValueLabel, maximumValueLabel: () -> ValueLabel, onEditingChanged: (Bool) -> Void)\nCreates a slider to select a value from a given range, subject to a step increment, which displays the provided labels.\nAvailable when Label conforms to View and ValueLabel conforms to View.\nDeprecated initializers\ninit<V>(value: Binding<V>, in: ClosedRange<V>, onEditingChanged: (Bool) -> Void, label: () -> Label)\nCreates a slider to select a value from a given range, which displays the provided label.\nAvailable when Label conforms to View and ValueLabel is EmptyView.\nDeprecated\ninit<V>(value: Binding<V>, in: ClosedRange<V>, step: V.Stride, onEditingChanged: (Bool) -> Void, label: () -> Label)\nCreates a slider to select a value from a given range, subject to a step increment, which displays the provided label.\nAvailable when Label conforms to View and ValueLabel is EmptyView.\nDeprecated\ninit<V>(value: Binding<V>, in: ClosedRange<V>, onEditingChanged: (Bool) -> Void, minimumValueLabel: ValueLabel, maximumValueLabel: ValueLabel, label: () -> Label)\nCreates a slider to select a value from a given range, which displays the provided labels.\nAvailable when Label conforms to View and ValueLabel conforms to View.\nDeprecated\ninit<V>(value: Binding<V>, in: ClosedRange<V>, step: V.Stride, onEditingChanged: (Bool) -> Void, minimumValueLabel: ValueLabel, maximumValueLabel: ValueLabel, label: () -> Label)\nCreates a slider to select a value from a given range, subject to a step increment, which displays the provided labels.\nAvailable when Label conforms to View and ValueLabel conforms to View.\nDeprecated\nRelationships\nConforms To\nView\nSee Also\nGetting numeric inputs\nstruct Stepper\nA control that performs increment and decrement actions.\nstruct Toggle\nA control that toggles between on and off states.\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy."
    },
    {
        "title": "TextFieldLink",
        "url": "https://developer.apple.com/documentation/swiftui/textfieldlink",
        "html": "Overview\n\nA TextFieldLink should be used to request text input from the user through a button interface.\n\nTopics\nCreating a text field link\ninit(LocalizedStringKey, prompt: Text?, onSubmit: (String) -> Void)\nCreates a TextFieldLink which when pressed will request text input from the user.\nAvailable when Label is Text.\ninit<S>(S, prompt: Text?, onSubmit: (String) -> Void)\nCreates a TextFieldLink which when pressed will request text input from the user.\nAvailable when Label is Text.\ninit(prompt: Text?, label: () -> Label, onSubmit: (String) -> Void)\nCreates a TextFieldLink which when pressed will request text input from the user.\nAvailable when Label conforms to View.\nRelationships\nConforms To\nView\nSee Also\nLinking to other content\nstruct Link\nA control for navigating to a URL.\nstruct ShareLink\nA view that controls a sharing presentation.\nstruct SharePreview\nA representation of a type to display in a share preview.\nstruct HelpLink\nA button with a standard appearance that opens app-specific help documentation."
    },
    {
        "title": "SharePreview",
        "url": "https://developer.apple.com/documentation/swiftui/sharepreview",
        "html": "Overview\n\nUse this type when sharing content that the system can\u2019t preview automatically:\n\nstruct Photo: Transferable {\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation(\\.image)\n    }\n\n\n    public var image: Image\n    public var caption: String\n}\n\n\nstruct PhotoView: View {\n    let photo: Photo\n\n\n    var body: View {\n        photo.image\n            .toolbar {\n                ShareLink(\n                    item: photo,\n                    preview: SharePreview(\n                        photo.caption,\n                        image: photo.image))\n            }\n    }\n}\n\n\nYou can also provide a preview to speed up the sharing process. In the following example the preview appears immediately; if you omit the preview instead, the system fetches the link\u2019s metadata over the network:\n\nShareLink(\n    item: URL(string: \"https://developer.apple.com/xcode/swiftui/\")!,\n    preview: SharePreview(\n        \"SwiftUI\",\n        image: Image(\"SwiftUI\"))\n\n\nYou can provide unique previews for each item in a collection of items that a ShareLink links to:\n\nShareLink(items: photos) { photo in\n    SharePreview(photo.caption, image: photo.image)\n}\n\n\nThe share interface decides how to combine those previews.\n\nEach preview specifies text and images that describe an item of the type. The preview\u2019s image parameter is typically a full-size representation of the item. For instance, if the system prepares a preview for a link to a webpage, the image might be the hero image on that webpage.\n\nThe preview\u2019s icon parameter is typically a thumbnail-sized representation of the source of the item. For instance, if the system prepares a preview for a link to a webpage, the icon might be an image that represents the website overall.\n\nThe system may reuse a single preview representation for multiple previews, and show different images in each context. For more information and recommended sizes for each image, see TN2444: Best Practices for Link Previews in Messages.\n\nTopics\nDisplaying a preview\ninit<S>(S)\nCreates a preview representation.\nAvailable when Image is Never and Icon is Never.\ninit(LocalizedStringKey)\nCreates a preview representation.\nAvailable when Image is Never and Icon is Never.\ninit(Text)\nCreates a preview representation.\nAvailable when Image is Never and Icon is Never.\nDisplaying a preview with an image\ninit<S>(S, image: Image)\nCreates a preview representation.\nAvailable when Image conforms to Transferable and Icon is Never.\ninit(LocalizedStringKey, image: Image)\nCreates a preview representation.\nAvailable when Image conforms to Transferable and Icon is Never.\ninit(Text, image: Image)\nCreates a preview representation.\nAvailable when Image conforms to Transferable and Icon is Never.\nDisplaying a preview with an icon\ninit<S>(S, icon: Icon)\nCreates a preview representation.\nAvailable when Image is Never and Icon conforms to Transferable.\ninit(LocalizedStringKey, icon: Icon)\nCreates a preview representation.\nAvailable when Image is Never and Icon conforms to Transferable.\ninit(Text, icon: Icon)\nCreates a preview representation.\nAvailable when Image is Never and Icon conforms to Transferable.\nDisplaying a preview with an image and an icon\ninit<S>(S, image: Image, icon: Icon)\nCreates a preview representation.\ninit(LocalizedStringKey, image: Image, icon: Icon)\nCreates a preview representation.\ninit(Text, image: Image, icon: Icon)\nCreates a preview representation.\nSee Also\nLinking to other content\nstruct Link\nA control for navigating to a URL.\nstruct ShareLink\nA view that controls a sharing presentation.\nstruct TextFieldLink\nA control that requests text input from the user when pressed.\nstruct HelpLink\nA button with a standard appearance that opens app-specific help documentation."
    },
    {
        "title": "defaultWheelPickerItemHeight",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/defaultwheelpickeritemheight",
        "html": "See Also\nChoosing from a set of options\nstruct Picker\nA control for selecting from a set of mutually exclusive values.\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item.\nstruct PaletteSelectionEffect\nThe selection effect to apply to a palette item."
    },
    {
        "title": "subscriptionStorePolicyDestination(for:destination:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(for:destination:)",
        "html": "Parameters\nbutton\n\nThe policy button to associate the URL with.\n\ndestination\n\nThe view to present when someone chooses to view the policy.\n\nDiscussion\n\nExcept on tvOS, you can also set a URL as the destination using subscriptionStorePolicyDestination(url:for:). If you do not set a destination, the system will use the automatic behavior. Check the documentation for the value you provide for button to understand the automatic behavior.\n\nBy default, the subscription store shows the terms of service & privacy policy buttons if you set a destination for at least one policy. The policy that is not explicitly set will use the automatic behavior. You can override this behavior using the storeButton(_:for:) modifier, with StoreButtonKind/policies as the second parameter.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "tipCornerRadius(_:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tipcornerradius(_:antialiased:)",
        "html": "See Also\nProviding tips\nfunc popoverTip<Content>(Content, arrowEdge: Edge) -> some View\nPresents a popover tip on the modified view.\nfunc popoverTip<Content>(Content, arrowEdge: Edge, action: (Tips.Action) -> Void) -> some View\nPresents a popover tip on the modified view.\nfunc tipBackground(some ShapeStyle) -> some View\nSets the tip\u2019s view background to a style.\nfunc tipImageSize(CGSize) -> some View\nfunc tipViewStyle(some TipViewStyle) -> some View\nSets the given style for TipView within the view hierarchy"
    },
    {
        "title": "subscriptionStoreButtonLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorebuttonlabel(_:)",
        "html": "Discussion\n\nThe button label is not always respected in every context. For example, if you have a subscription store that shows multiple subscribe buttons, setting SubscriptionStoreButtonLabel/action-swift.type.property as the button label will fall back to each subscription\u2019s display name.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "HelpLink",
        "url": "https://developer.apple.com/documentation/swiftui/helplink",
        "html": "Overview\n\nA help link opens documentation relevant to the context where they are used. Typically this is by opening to an anchor in an Apple Help book, but can also perform an arbitrary action such as opening a URL or opening a window.\n\nHelpLink(anchor: \"accountSetupHelp\")\n\n\nHelpLink {\n    openURL(onlineHelpURL)\n}\n\n\nHelp links have a standard appearance, as well as conventional placement within a view. When used within an alert or confirmation dialog\u2019s actions, the help link will automatically be placed in the top trailing corner. Or when used in a sheet toolbar, the help link is automatically placed in the lower leading corner.\n\nstruct SheetContentView: View {\n    var body: some View {\n        Form {\n             ...\n        }\n        .toolbar {\n            ToolbarItem(.confirmationAction) {\n                Button(\"Save\") { ... }\n            }\n            ToolbarItem(.cancellationAction) {\n                Button(\"Cancel\") { ... }\n            }\n            ToolbarItem {\n                HelpLink(anchor: \"sheetHelp\")\n            }\n         }\n    }\n}\n\nTopics\nCreating a help link\ninit(action: () -> Void)\nConstructs a new help link with the specified action.\ninit(destination: URL)\nConstructs a new help link that opens the specified destination URL.\ninit(anchor: NSHelpManager.AnchorName)\nConstructs a new help link with the specified anchor in the main app bundle\u2019s book.\ninit(anchor: NSHelpManager.AnchorName, book: NSHelpManager.BookName)\nConstructs a new help link with the specified anchor and book.\nRelationships\nConforms To\nView\nSee Also\nLinking to other content\nstruct Link\nA control for navigating to a URL.\nstruct ShareLink\nA view that controls a sharing presentation.\nstruct SharePreview\nA representation of a type to display in a share preview.\nstruct TextFieldLink\nA control that requests text input from the user when pressed."
    },
    {
        "title": "subscriptionStoreSignInAction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstoresigninaction(_:)",
        "html": "Parameters\naction\n\nThe action to perform. Pass nil to remove the sign in action for subscription stores within this view. The default value is nil.\n\nDiscussion\n\nYou can only have one sign in action for a view. If an ancestor view specifies a sign in action, using this modifier will replace the ancestor\u2019s sign in action.\n\nIf the value is nil, subscription stores will never show a sign in button. You can also hide the sign in button without removing the action by using the storeButton(_:for:) modifier, providing StoreButtonKind/signIn as the button kind.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "ButtonBorderShape",
        "url": "https://developer.apple.com/documentation/swiftui/buttonbordershape",
        "html": "Topics\nGetting border shapes\nstatic let automatic: ButtonBorderShape\nA shape that defers to the system to determine an appropriate shape for the given context and platform.\nstatic let capsule: ButtonBorderShape\nA capsule shape.\nstatic let circle: ButtonBorderShape\nstatic let roundedRectangle: ButtonBorderShape\nA rounded rectangle shape.\nstatic func roundedRectangle(radius: CGFloat) -> ButtonBorderShape\nA rounded rectangle shape.\nRelationships\nConforms To\nAnimatable\nEquatable\nInsettableShape\nSendable\nShape\nView\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "subscriptionStoreControlBackground(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolbackground(_:)-7jxa9",
        "html": "See Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "healthDataAccessRequest(store:readTypes:trigger:completion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:readtypes:trigger:completion:)",
        "html": "See Also\nAccessing health data\nfunc healthDataAccessRequest(store: HKHealthStore, objectType: HKObjectType, predicate: NSPredicate?, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nRequests authorization to specific samples of the given HealthKit types; used only with types that require authorization per object Parameters: store: Your app\u2019s HKHealthStore, for which authorization will be requested objectType: The data type you want to read; this type must be a type that requires per-object authorization. predicate: An optional predicate that further restricts the objects of interest trigger: A generic equatable value; change this value to initiate a new request completion: A block that will be passed success or error when the request completes.\nfunc healthDataAccessRequest(store: HKHealthStore, shareTypes: Set<HKSampleType>, readTypes: Set<HKObjectType>?, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nRequests authorization to read and share the given HealthKit types Parameters: store: Your app\u2019s HKHealthStore, for which authorization will be requested shareTypes: An optional set containing the data types you want to share readTypes: An optional set containing the data types you want to read trigger: A generic equatable value; change this value to initiate a new request completion: A block that will be passed success or error when the request completes."
    },
    {
        "title": "subscriptionStorePolicyForegroundStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicyforegroundstyle(_:)",
        "html": "See Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "subscriptionStorePolicyDestination(url:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(url:for:)",
        "html": "Parameters\nurl\n\nThe URL of the web page to open when someone chooses to view the policy.\n\nbutton\n\nThe policy button to associate the URL with.\n\nDiscussion\n\nYou can also set a view as the destination using subscriptionStorePolicyDestination(for:destination:). If you do not set a destination, or pass nil for url, the system will use the automatic behavior. Check the documentation for the value you provide for button to understand the automatic behavior.\n\nBy default, the subscription store shows the terms of service & privacy policy buttons if you set a destination for at least one policy. The policy that is not explicitly set will use the automatic behavior. You can override this behavior using the storeButton(_:for:) modifier, with StoreButtonKind/policies as the second parameter.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "storeProductsTask(for:priority:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/storeproductstask(for:priority:action:)",
        "html": "Parameters\nids\n\nThe product IDs to load from the App Store. The task restarts whenever this parameter changes.\n\npriority\n\nThe task priority to use when creating the task.\n\naction\n\nThe action to perform when the task\u2019s state changes.\n\nDiscussion\n\nBefore a view modified with this method appears, a task will start in the background to load the products from the App Store. While the view is presented, the task will call action whenever the products change or the task\u2019s state changes.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "subscriptionStorePickerItemBackground(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/subscriptionstorepickeritembackground(_:)",
        "html": "See Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "productIconBorder()",
        "url": "https://developer.apple.com/documentation/swiftui/view/producticonborder()",
        "html": "Discussion\n\nYou can also use this on an icon provided to StoreView instances.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "storeProductTask(for:priority:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/storeproducttask(for:priority:action:)",
        "html": "Parameters\nid\n\nThe product ID to load from the App Store. The task restarts whenever this parameter changes.\n\npriority\n\nThe task priority to use when creating the task.\n\naction\n\nThe action to perform when the task\u2019s state changes.\n\nDiscussion\n\nBefore a view modified with this method appears, a task will start in the background to load the product from the App Store. While the view is presented, the task will call action whenever the product changes or the task\u2019s state changes.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "navigationBarBackButtonHidden(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationbarbackbuttonhidden(_:)",
        "html": "Parameters\nhidesBackButton\n\nA Boolean value that indicates whether to hide the back button. The default value is true.\n\nDiscussion\n\nUse navigationBarBackButtonHidden(_:) to hide the back button for this view.\n\nThis modifier only takes effect when this view is inside of and visible within a NavigationView.\n\nSee Also\nConfiguring the navigation bar\nfunc navigationBarTitleDisplayMode(NavigationBarItem.TitleDisplayMode) -> some View\nConfigures the title display mode for this view.\nstruct NavigationBarItem\nA configuration for a navigation bar that represents a view at the top of a navigation stack."
    },
    {
        "title": "navigationTitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)-7onr8",
        "html": "Parameters\ntitle\n\nThe text of the title.\n\nDiscussion\n\nIn iOS, iPadOS, and macOS, this allows editing the navigation title when the title is displayed in the toolbar.\n\nRefer to the Configure your apps navigation titles article for more information on navigation title modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "navigationSubtitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationsubtitle(_:)-2h20t",
        "html": "Parameters\nsubtitle\n\nThe subtitle to display.\n\nDiscussion\n\nA view\u2019s navigation subtitle is used to provide additional contextual information alongside the navigation title. On macOS, the primary destination\u2019s subtitle is displayed with the navigation title in the titlebar.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "navigationTitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)-5di1u",
        "html": "Parameters\ntitle\n\nThe title to display.\n\nDiscussion\n\nA view\u2019s navigation title is used to visually display the current navigation state of an interface. On iOS and watchOS, when a view is navigated to inside of a navigation view, that view\u2019s title is displayed in the navigation bar. On iPadOS, the primary destination\u2019s navigation title is reflected as the window\u2019s title in the App Switcher. Similarly on macOS, the primary destination\u2019s title is used as the window title in the titlebar, Windows menu and Mission Control.\n\nRefer to the Configure your apps navigation titles article for more information on navigation title modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "navigationDestination(item:destination:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationdestination(item:destination:)",
        "html": "Parameters\nitem\n\nA binding to the data presented, or nil if nothing is currently presented.\n\ndestination\n\nA view builder that defines a view to display when item is not nil.\n\nDiscussion\n\nAdd this view modifer to a view inside a NavigationStack or NavigationSplitView to describe the view that the stack displays when presenting a particular kind of data. Programmatically update the binding to display or remove the view. For example, you can replace the view showing in the detail column of a navigation split view:\n\n@State private var colorShown: Color?\n\n\nNavigationSplitView {\n    List {\n        Button(\"Mint\") { colorShown = .mint }\n        Button(\"Pink\") { colorShown = .pink }\n        Button(\"Teal\") { colorShown = .teal }\n    }\n    .navigationDestination(item: $colorShown) { color in\n        ColorDetail(color: color)\n    }\n} detail: {\n    Text(\"Select a color\")\n}\n\n\nWhen the person using the app taps on the Mint button, the mint color shows in the detail and colorShown gets the value Color.mint. You can reset the navigation split view to show the message \u201cSelect a color\u201d by setting colorShown back to nil.\n\nYou can add more than one navigation destination modifier to the stack if it needs to present more than one kind of data.\n\nDo not put a navigation destination modifier inside a \u201clazy\u201d container, like List or LazyVStack. These containers create child views only when needed to render on screen. Add the navigation destination modifier outside these containers so that the navigation split view can always see the destination.\n\nSee Also\nStacking views in one column\nstruct NavigationStack\nA view that displays a root view and enables you to present additional views over the root view.\nstruct NavigationPath\nA type-erased list of data representing the content of a navigation stack.\nfunc navigationDestination<D, C>(for: D.Type, destination: (D) -> C) -> some View\nAssociates a destination view with a presented data type for use within a navigation stack.\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> some View\nAssociates a destination view with a binding that can be used to push the view onto a NavigationStack."
    },
    {
        "title": "previewContext(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/previewcontext(_:)",
        "html": "Parameters\nvalue\n\nThe context for the preview; the default is nil.\n\nSee Also\nSetting a context\nprotocol PreviewContext\nA context type for use with a preview.\nprotocol PreviewContextKey\nA key type for a preview context."
    },
    {
        "title": "NavigationSplitViewColumn",
        "url": "https://developer.apple.com/documentation/swiftui/navigationsplitviewcolumn",
        "html": "Overview\n\nA NavigationSplitView collapses into a single stack in some contexts, like on iPhone or Apple Watch. Use this type with the preferredCompactColumn parameter to control which column of the navigation split view appears on top of the collapsed stack.\n\nTopics\nGetting a column\nstatic var sidebar: NavigationSplitViewColumn\nstatic var content: NavigationSplitViewColumn\nstatic var detail: NavigationSplitViewColumn\nRelationships\nConforms To\nEquatable\nHashable\nSendable"
    },
    {
        "title": "Preview(_:windowStyle:traits:body:)",
        "url": "https://developer.apple.com/documentation/swiftui/preview(_:windowstyle:traits:body:)",
        "html": "Parameters\nname\n\nAn optional display name for the preview. If you don\u2019t specify a name, the canvas labels the preview using the line number where the preview appears in source.\n\nwindowStyle\n\nThe WindowStyle to use for the preview. Use this input to display the view as if it appears in a window that has the specified style.\n\ntraits\n\nAn optional list of PreviewTrait instances that customize the appearance of the preview.\n\nbody\n\nA ViewBuilder that produces a SwiftUI view to preview. You typically specify one of your app\u2019s custom views and optionally any inputs, model data, modifiers, and enclosing views that the custom view needs for normal operation.\n\nOverview\n\nThis preview macro behaves like Preview(_:traits:_:body:), except that it also enables you to define a scene context for the view. Specifically, it places the view in a window with the specified window style, like the volumetric style:\n\n#Preview(\"Volume\", windowStyle: .volumetric) {\n   ContentView()\n}\n\n\nUse this preview macro when the view needs scene context to behave as it would during normal operation of your app.\n\nOther preview macros provide different customization options. For example, if you want to see how the view appears in an immersive space rather than a window, you can use Preview(_:immersionStyle:traits:body:). If you want to add custom, fixed viewpoints to a window-based preview, use Preview(_:windowStyle:traits:body:cameras:).\n\nSee Also\nCreating a preview in the context of a scene\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in an immersive space.\nBeta\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in an immersive space with custom viewpoints.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in a window with custom viewpoints.\nBeta"
    },
    {
        "title": "offerCodeRedemption(isPresented:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/offercoderedemption(ispresented:oncompletion:)",
        "html": "Parameters\nisPresented\n\nA Binding to a boolean value indicating whether theonCompletion sheet should be presented.\n\nonCompletion\n\nA closure that returns the result of the presentation.\n\nDiscussion\n\nImportant\n\nThe resulting transaction from redeeming an offer code is emitted in Transaction.updates. Set up a transaction listener as soon as your app launches to receive new transactions while the app is running.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "manageSubscriptionsSheet(isPresented:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/managesubscriptionssheet(ispresented:)",
        "html": "See Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "inAppPurchaseOptions(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/inapppurchaseoptions(_:)",
        "html": "Parameters\noptions\n\nThe system calls this function before processing a purchase, with the product to be purchased is provided as a parameter. Return a set of purchase options to add to the purchase.\n\nDiscussion\n\nIn-app stores within this view will add any default purchase options to the set you return, and use the result for configuring the purchase. If you just want to react to in-app purchases beginning without adding purchase options, you can add an action with onInAppPurchaseStart(perform:).\n\nYou can remove any options ancestor views may have added by providing nil for the action. This will result in using the default set of purchase options.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "manageSubscriptionsSheet(isPresented:subscriptionGroupID:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/managesubscriptionssheet(ispresented:subscriptiongroupid:)",
        "html": "See Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "photosPicker(isPresented:selection:maxSelectionCount:selectionBehavior:matching:preferredItemEncoding:photoLibrary:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:maxselectioncount:selectionbehavior:matching:preferreditemencoding:photolibrary:)",
        "html": "Parameters\nisPresented\n\nThe binding to whether the Photos picker should be shown.\n\nselection\n\nAll items being shown and selected in the Photos picker.\n\nmaxSelectionCount\n\nThe maximum number of items that can be selected. Default is nil. Setting it to nil means maximum supported by the system.\n\nselectionBehavior\n\nThe selection behavior of the Photos picker. Default is .default.\n\nfilter\n\nTypes of items that can be shown. Default is nil. Setting it to nil means all supported types can be shown.\n\npreferredItemEncoding\n\nThe encoding disambiguation policy of selected items. Default is .automatic. Setting it to .automatic means the best encoding determined by the system will be used.\n\nphotoLibrary\n\nThe photo library to choose from.\n\nDiscussion\n\nThe user explicitly grants access only to items they choose, so photo library access authorization is not needed.\n\nSee Also\nSelecting photos\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker."
    },
    {
        "title": "photosPickerStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/photospickerstyle(_:)",
        "html": "Parameters\nmode\n\nOne of the available modes.\n\nReturn Value\n\nA Photos picker that uses the specified mode.\n\nSee Also\nSelecting photos\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker."
    },
    {
        "title": "UIHostingControllerSizingOptions",
        "url": "https://developer.apple.com/documentation/swiftui/uihostingcontrollersizingoptions",
        "html": "Topics\nGetting sizing options\nstatic let intrinsicContentSize: UIHostingControllerSizingOptions\nThe hosting controller\u2019s view automatically invalidate its intrinsic content size when its ideal size changes.\nstatic let preferredContentSize: UIHostingControllerSizingOptions\nThe hosting controller tracks its content\u2019s ideal size in its preferred content size.\nCreating a sizing option\ninit(rawValue: Int)\nCreates a new option set from a raw value.\nlet rawValue: Int\nThe raw value.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nDisplaying SwiftUI views in UIKit\nclass UIHostingController\nA UIKit view controller that manages a SwiftUI view hierarchy.\nstruct UIHostingConfiguration\nA content configuration suitable for hosting a hierarchy of SwiftUI views."
    },
    {
        "title": "activityBackgroundTint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/activitybackgroundtint(_:)",
        "html": "Parameters\ncolor\n\nThe background tint color to apply. To use the system\u2019s default background material, pass nil.\n\nDiscussion\n\nWhen you set a custom background tint color, consider setting a custom text color for the auxiliary button people use to end a Live Activity on the Lock Screen. To set a custom text color, use the activitySystemActionForegroundColor(_:) view modifier.\n\nSee Also\nConfiguring a Live Activity\nfunc activitySystemActionForegroundColor(Color?) -> some View\nThe text color for the auxiliary action button that the system shows next to a Live Activity on the Lock Screen.\nvar isActivityFullscreen: Bool\nA Boolean value that indicates whether the Live Activity appears in a full-screen presentation."
    },
    {
        "title": "familyActivityPicker(headerText:footerText:isPresented:selection:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/familyactivitypicker(headertext:footertext:ispresented:selection:)",
        "html": "Parameters\nheaderText\n\nAn optional string that provides text for the header of the picker view.\n\nfooterText\n\nAn optional string that provides text for the footer of the picker view.\n\nisPresented\n\nA binding that indicates whether the app presents the picker view.\n\nselection\n\nA binding that manages the user-selected categories, apps, and web domains.\n\nDiscussion\n\nUse this view modifier to present a FamilyControls/FamilyActivityPicker.\n\nSee Also\nConfiguring Family Sharing\nfunc familyActivityPicker(isPresented: Binding<Bool>, selection: Binding<FamilyActivitySelection>) -> some View\nPresents an activity picker view as a sheet."
    },
    {
        "title": "DefaultSettingsLinkLabel",
        "url": "https://developer.apple.com/documentation/swiftui/defaultsettingslinklabel",
        "html": "Overview\n\nYou don\u2019t use this type directly. Instead, the system creates it automatically when you construct a SettingsLink with the default label.\n\nRelationships\nConforms To\nView"
    },
    {
        "title": "BlurReplaceTransition.Configuration",
        "url": "https://developer.apple.com/documentation/swiftui/blurreplacetransition/configuration-swift.struct",
        "html": "Topics\nType Properties\nstatic let downUp: BlurReplaceTransition.Configuration\nA configuration that requests a transition that scales the view down while removing it and up while inserting it.\nstatic let upUp: BlurReplaceTransition.Configuration\nA configuration that requests a transition that scales the view up while both removing and inserting it.\nRelationships\nConforms To\nEquatable"
    },
    {
        "title": "sensoryFeedback(_:trigger:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/sensoryfeedback(_:trigger:)",
        "html": "Parameters\nfeedback\n\nWhich type of feedback to play.\n\ntrigger\n\nA value to monitor for changes to determine when to play.\n\nDiscussion\n\nFor example, you could play feedback when a state value changes:\n\nstruct MyView: View {\n    @State private var showAccessory = false\n\n\n    var body: some View {\n        ContentView()\n            .sensoryFeedback(.selection, trigger: showAccessory)\n            .onLongPressGesture {\n                showAccessory.toggle()\n            }\n\n\n        if showAccessory {\n            AccessoryView()\n        }\n    }\n}\n\nSee Also\nProviding haptic feedback\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> some View\nPlays feedback when returned from the feedback closure after the provided trigger value changes.\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> some View\nPlays the specified feedback when the provided trigger value changes and the condition closure returns true.\nstruct SensoryFeedback\nRepresents a type of haptic and/or audio feedback that can be played."
    },
    {
        "title": "ControlActiveState",
        "url": "https://developer.apple.com/documentation/swiftui/controlactivestate",
        "html": "Topics\nGetting control active states\ncase key\ncase active\ncase inactive\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nActivating controls\nvar controlActiveState: ControlActiveState\nThe active state of controls in the view."
    },
    {
        "title": "ShareLink",
        "url": "https://developer.apple.com/documentation/swiftui/sharelink",
        "html": "Overview\n\nPeople tap or click on a share link to present a share interface. The link typically uses a system-standard appearance; you only need to supply the content to share:\n\nShareLink(item: URL(string: \"https://developer.apple.com/xcode/swiftui/\")!)\n\n\nYou can control the appearance of the link by providing view content. For example, you can use a Label to display a link with a custom icon:\n\nShareLink(item: URL(string: \"https://developer.apple.com/xcode/swiftui/\")!) {\n    Label(\"Share\", image: \"MyCustomShareIcon\")\n}\n\n\nIf you only wish to customize the link\u2019s title, you can use one of the convenience initializers that takes a string and creates a Label for you:\n\nShareLink(\"Share URL\", item: URL(string: \"https://developer.apple.com/xcode/swiftui/\")!)\n\n\nThe link can share any content that is Transferable. Many framework types, like URL, already conform to this protocol. You can also make your own types transferable.\n\nFor example, you can use ProxyRepresentation to resolve your own type to a framework type:\n\nstruct Photo: Transferable {\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation(\\.image)\n    }\n\n\n    public var image: Image\n    public var caption: String\n}\n\n\nstruct PhotoView: View {\n    let photo: Photo\n\n\n    var body: View {\n        photo.image\n            .toolbar {\n                ShareLink(\n                    item: photo,\n                    preview: SharePreview(\n                        photo.caption,\n                        image: photo.image))\n            }\n    }\n}\n\n\nSometimes the content that your app shares isn\u2019t immediately available. You can use FileRepresentation or DataRepresentation when you need an asynchronous operation, like a network request, to retrieve and prepare the content.\n\nA Transferable type also lets you provide multiple content types for a single shareable item. The share interface shows relevant sharing services based on the types that you provide.\n\nThe previous example also shows how you provide a preview of your content to show in the share interface.\n\nA preview isn\u2019t required when sharing URLs or non-attributed strings. When sharing these types of content, the system can automatically determine a preview.\n\nYou can provide a preview even when it\u2019s optional. For instance, when sharing URLs, the automatic preview first shows a placeholder link icon alongside the base URL while fetching the link\u2019s metadata over the network. The preview updates once the link\u2019s icon and title become available. If you provide a preview instead, the preview appears immediately without fetching data over the network.\n\nSome share activities support subject and message fields. You can pre-populate these fields with the subject and message parameters:\n\nShareLink(\n    item: photo,\n    subject: Text(\"Cool Photo\"),\n    message: Text(\"Check it out!\")\n    preview: SharePreview(\n        photo.caption,\n        image: photo.image))\n\nTopics\nSharing an item\ninit(item: String, subject: Text?, message: Text?)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(item: URL, subject: Text?, message: Text?)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(item: String, subject: Text?, message: Text?, label: () -> Label)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label conforms to View, and Data.Element conforms to Transferable.\ninit(item: URL, subject: Text?, message: Text?, label: () -> Label)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label conforms to View, and Data.Element conforms to Transferable.\nSharing an item with a preview\ninit<I>(item: I, subject: Text?, message: Text?, preview: SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit<I>(item: I, subject: Text?, message: Text?, preview: SharePreview<PreviewImage, PreviewIcon>, label: () -> Label)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label conforms to View, and Data.Element conforms to Transferable.\nSharing an item with a label\ninit<S>(S, item: URL, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(LocalizedStringKey, item: URL, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(Text, item: String, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit<S>(S, item: String, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(LocalizedStringKey, item: String, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(Text, item: URL, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\nSharing an item with a label and a preview\ninit<S, I>(S, item: I, subject: Text?, message: Text?, preview: SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit<I>(Text, item: I, subject: Text?, message: Text?, preview: SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit<I>(LocalizedStringKey, item: I, subject: Text?, message: Text?, preview: SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\nSharing items\ninit(items: Data, subject: Text?, message: Text?)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is String.\ninit(items: Data, subject: Text?, message: Text?)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is URL.\ninit(items: Data, subject: Text?, message: Text?, label: () -> Label)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label conforms to View, and Data.Element is String.\ninit(items: Data, subject: Text?, message: Text?, label: () -> Label)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label conforms to View, and Data.Element is URL.\nSharing items with a preview\ninit(items: Data, subject: Text?, message: Text?, preview: (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(items: Data, subject: Text?, message: Text?, preview: (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>, label: () -> Label)\nCreates an instance that presents the share interface.\nSharing items with a label\ninit<S>(S, items: Data, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is String.\ninit<S>(S, items: Data, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is URL.\ninit(LocalizedStringKey, items: Data, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is String.\ninit(LocalizedStringKey, items: Data, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is URL.\ninit(Text, items: Data, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is URL.\ninit(Text, items: Data, subject: Text?, message: Text?)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage is Never, PreviewIcon is Never, Label is DefaultShareLinkLabel, and Data.Element is String.\nSharing items with a label and preview\ninit<S>(S, items: Data, subject: Text?, message: Text?, preview: (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(LocalizedStringKey, items: Data, subject: Text?, message: Text?, preview: (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\ninit(Text, items: Data, subject: Text?, message: Text?, preview: (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>)\nCreates an instance, with a custom label, that presents the share interface.\nAvailable when Data conforms to RandomAccessCollection, PreviewImage conforms to Transferable, PreviewIcon conforms to Transferable, Label is DefaultShareLinkLabel, and Data.Element conforms to Transferable.\nSupporting types\nstruct DefaultShareLinkLabel\nThe default label used for a share link.\nRelationships\nConforms To\nView\nSee Also\nLinking to other content\nstruct Link\nA control for navigating to a URL.\nstruct SharePreview\nA representation of a type to display in a share preview.\nstruct TextFieldLink\nA control that requests text input from the user when pressed.\nstruct HelpLink\nA button with a standard appearance that opens app-specific help documentation."
    },
    {
        "title": "MultiDatePicker",
        "url": "https://developer.apple.com/documentation/swiftui/multidatepicker",
        "html": "Overview\n\nUse a MultiDatePicker when you want to provide a view that allows the user to select multiple dates.\n\nThe following example creates a basic MultiDatePicker, which appears as a calendar view representing the selected dates:\n\n@State private var dates: Set<DateComponents> = []\n\n\nvar body: some View {\n    MultiDatePicker(\"Dates Available\", selection: $dates)\n}\n\n\nYou can limit the MultiDatePicker to specific ranges of dates allowing selections only before or after a certain date or between two dates. The following example shows a multi-date picker that only permits selections within the 6th and (excluding) the 16th of December 2021 (in the UTC time zone):\n\n@Environment(\\.calendar) var calendar\n@Environment(\\.timeZone) var timeZone\n\n\nvar bounds: Range<Date> {\n    let start = calendar.date(from: DateComponents(\n        timeZone: timeZone, year: 2022, month: 6, day: 6))!\n    let end = calendar.date(from: DateComponents(\n        timeZone: timeZone, year: 2022, month: 6, day: 16))!\n    return start ..< end\n}\n\n\n@State private var dates: Set<DateComponents> = []\n\n\nvar body: some View {\n    MultiDatePicker(\"Dates Available\", selection: $dates, in: bounds)\n}\n\n\nYou can also specify an alternative locale, calendar and time zone through environment values. This can be useful when using a PreviewProvider to see how your multi-date picker behaves in environments that differ from your own.\n\nThe following example shows a multi-date picker with a custom locale, calendar and time zone:\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        MultiDatePicker(\"Dates Available\", selection: .constant([]))\n            .environment(\\.locale, Locale.init(identifier: \"zh\"))\n            .environment(\n                \\.calendar, Calendar.init(identifier: .chinese))\n            .environment(\\.timeZone, TimeZone(abbreviation: \"HKT\")!)\n    }\n}\n\nTopics\nPicking dates\ninit(LocalizedStringKey, selection: Binding<Set<DateComponents>>)\nCreates an instance that selects multiple dates with an unbounded range.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Set<DateComponents>>)\nCreates an instance that selects multiple dates with an unbounded range.\nAvailable when Label is Text.\ninit(selection: Binding<Set<DateComponents>>, label: () -> Label)\nCreates an instance that selects multiple dates with an unbounded range.\nAvailable when Label conforms to View.\nPicking dates in a range\ninit(LocalizedStringKey, selection: Binding<Set<DateComponents>>, in: Range<Date>)\nCreates an instance that selects multiple dates in a range.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Set<DateComponents>>, in: Range<Date>)\nCreates an instance that selects multiple dates in a range.\nAvailable when Label is Text.\ninit(selection: Binding<Set<DateComponents>>, in: Range<Date>, label: () -> Label)\nCreates an instance that selects multiple dates in a range.\nAvailable when Label conforms to View.\nPicking dates after a date\ninit(LocalizedStringKey, selection: Binding<Set<DateComponents>>, in: PartialRangeFrom<Date>)\nCreates an instance that selects multiple dates on or after some start date.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Set<DateComponents>>, in: PartialRangeFrom<Date>)\nCreates an instance that selects multiple dates on or after some start date.\nAvailable when Label is Text.\ninit(selection: Binding<Set<DateComponents>>, in: PartialRangeFrom<Date>, label: () -> Label)\nCreates an instance that selects multiple dates on or after some start date.\nAvailable when Label conforms to View.\nPicking dates before a date\ninit(LocalizedStringKey, selection: Binding<Set<DateComponents>>, in: PartialRangeUpTo<Date>)\nCreates an instance that selects multiple dates before some end date.\nAvailable when Label is Text.\ninit<S>(S, selection: Binding<Set<DateComponents>>, in: PartialRangeUpTo<Date>)\nCreates an instance that selects multiple dates before some end date.\nAvailable when Label is Text.\ninit(selection: Binding<Set<DateComponents>>, in: PartialRangeUpTo<Date>, label: () -> Label)\nCreates an instance that selects multiple dates before some end date.\nAvailable when Label conforms to View.\nRelationships\nConforms To\nView\nSee Also\nChoosing dates\nstruct DatePicker\nA control for selecting an absolute date.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nvar calendar: Calendar\nThe current calendar that views should use when handling dates.\nvar timeZone: TimeZone\nThe current time zone that views should use when handling dates."
    },
    {
        "title": "calendar",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/calendar",
        "html": "See Also\nChoosing dates\nstruct DatePicker\nA control for selecting an absolute date.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nstruct MultiDatePicker\nA control for picking multiple dates.\nvar timeZone: TimeZone\nThe current time zone that views should use when handling dates."
    },
    {
        "title": "horizontalRadioGroupLayout()",
        "url": "https://developer.apple.com/documentation/swiftui/view/horizontalradiogrouplayout()",
        "html": "Discussion\n\nUse horizontalRadioGroupLayout() to configure the visual layout of radio buttons in a Picker so that the radio buttons are arranged horizontally in the view.\n\nThe example below shows two Picker controls configured as radio button groups; the first group shows the default vertical layout; the second group shows the effect of horizontalRadioGroupLayout() which renders the radio buttons horizontally.\n\nstruct HorizontalRadioGroupLayout: View {\n    @State private var selected = 1\n    var body: some View {\n        VStack(spacing: 20) {\n            Picker(selection: $selected, label: Text(\"Favorite Color\")) {\n                Text(\"Red\").tag(1)\n                Text(\"Green\").tag(2)\n                Text(\"Blue\").tag(3)\n                Text(\"Other\").tag(4)\n            }\n            .pickerStyle(.radioGroup)\n\n\n            Picker(selection: $selected, label: Text(\"Favorite Color\")) {\n                Text(\"Red\").tag(1)\n                Text(\"Green\").tag(2)\n                Text(\"Blue\").tag(3)\n                Text(\"Other\").tag(4)\n            }\n            .pickerStyle(.radioGroup)\n            .horizontalRadioGroupLayout()\n        }\n        .padding(20)\n        .border(Color.gray)\n    }\n}\n\n\nSee Also\nChoosing from a set of options\nstruct Picker\nA control for selecting from a set of mutually exclusive values.\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item.\nstruct PaletteSelectionEffect\nThe selection effect to apply to a palette item."
    },
    {
        "title": "NavigationStack",
        "url": "https://developer.apple.com/documentation/swiftui/navigationstack",
        "html": "Overview\n\nUse a navigation stack to present a stack of views over a root view. People can add views to the top of the stack by clicking or tapping a NavigationLink, and remove views using built-in, platform-appropriate controls, like a Back button or a swipe gesture. The stack always displays the most recently added view that hasn\u2019t been removed, and doesn\u2019t allow the root view to be removed.\n\nTo create navigation links, associate a view with a data type by adding a navigationDestination(for:destination:) modifier inside the stack\u2019s view hierarchy. Then initialize a NavigationLink that presents an instance of the same kind of data. The following stack displays a ParkDetails view for navigation links that present data of type Park:\n\nNavigationStack {\n    List(parks) { park in\n        NavigationLink(park.name, value: park)\n    }\n    .navigationDestination(for: Park.self) { park in\n        ParkDetails(park: park)\n    }\n}\n\n\nIn this example, the List acts as the root view and is always present. Selecting a navigation link from the list adds a ParkDetails view to the stack, so that it covers the list. Navigating back removes the detail view and reveals the list again. The system disables backward navigation controls when the stack is empty and the root view, namely the list, is visible.\n\nManage navigation state\n\nBy default, a navigation stack manages state to keep track of the views on the stack. However, your code can share control of the state by initializing the stack with a binding to a collection of data values that you create. The stack adds items to the collection as it adds views to the stack and removes items when it removes views. For example, you can create a State property to manage the navigation for the park detail view:\n\n@State private var presentedParks: [Park] = []\n\n\nInitializing the state as an empty array indicates a stack with no views. Provide a Binding to this state property using the dollar sign ($) prefix when you create a stack using the init(path:root:) initializer:\n\nNavigationStack(path: $presentedParks) {\n    List(parks) { park in\n        NavigationLink(park.name, value: park)\n    }\n    .navigationDestination(for: Park.self) { park in\n        ParkDetails(park: park)\n    }\n}\n\n\nLike before, when someone taps or clicks the navigation link for a park, the stack displays the ParkDetails view using the associated park data. However, now the stack also puts the park data in the presentedParks array. Your code can observe this array to read the current stack state. It can also modify the array to change the views on the stack. For example, you can create a method that configures the stack with a specific set of parks:\n\nfunc showParks() {\n    presentedParks = [Park(\"Yosemite\"), Park(\"Sequoia\")]\n}\n\n\nThe showParks method replaces the stack\u2019s display with a view that shows details for Sequoia, the last item in the new presentedParks array. Navigating back from that view removes Sequoia from the array, which reveals a view that shows details for Yosemite. Use a path to support deep links, state restoration, or other kinds of programmatic navigation.\n\nNavigate to different view types\n\nTo create a stack that can present more than one kind of view, you can add multiple navigationDestination(for:destination:) modifiers inside the stack\u2019s view hierarchy, with each modifier presenting a different data type. The stack matches navigation links with navigation destinations based on their respective data types.\n\nTo create a path for programmatic navigation that contains more than one kind of data, you can use a NavigationPath instance as the path.\n\nTopics\nCreating a navigation stack\ninit(root: () -> Root)\nCreates a navigation stack that manages its own navigation state.\nCreating a navigation stack with a path\ninit(path: Binding<Data>, root: () -> Root)\nCreates a navigation stack with homogeneous navigation state that you can control.\ninit(path: Binding<NavigationPath>, root: () -> Root)\nCreates a navigation stack with heterogeneous navigation state that you can control.\nRelationships\nConforms To\nView\nSee Also\nStacking views in one column\nstruct NavigationPath\nA type-erased list of data representing the content of a navigation stack.\nfunc navigationDestination<D, C>(for: D.Type, destination: (D) -> C) -> some View\nAssociates a destination view with a presented data type for use within a navigation stack.\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> some View\nAssociates a destination view with a binding that can be used to push the view onto a NavigationStack.\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> some View\nAssociates a destination view with a bound value for use within a navigation stack or navigation split view"
    },
    {
        "title": "defaultWheelPickerItemHeight(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/defaultwheelpickeritemheight(_:)",
        "html": "Parameters\nheight\n\nThe height for the picker items.\n\nDiscussion\n\nUse defaultWheelPickerItemHeight(_:) when you need to change the default item height in a picker control. In this example, the view sets the default height for picker elements to 30 points.\n\nstruct DefaultWheelPickerItemHeight: View {\n    @State private var selected = 1\n    var body: some View {\n        VStack(spacing: 20) {\n            Picker(selection: $selected, label: Text(\"Favorite Color\")) {\n                Text(\"Red\").tag(1)\n                Text(\"Green\").tag(2)\n                Text(\"Blue\").tag(3)\n                Text(\"Other\").tag(4)\n            }\n        }\n        .defaultWheelPickerItemHeight(30)\n    }\n}\n\n\nSee Also\nChoosing from a set of options\nstruct Picker\nA control for selecting from a set of mutually exclusive values.\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item.\nstruct PaletteSelectionEffect\nThe selection effect to apply to a palette item."
    },
    {
        "title": "tipBackground(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tipbackground(_:)",
        "html": "Parameters\nstyle\n\nAn instance of a type that conforms to ShapeStyle that SwiftUI draws behind the modified view.\n\nReturn Value\n\nA view with the specified style drawn behind it.\n\nSee Also\nProviding tips\nfunc popoverTip<Content>(Content, arrowEdge: Edge) -> some View\nPresents a popover tip on the modified view.\nfunc popoverTip<Content>(Content, arrowEdge: Edge, action: (Tips.Action) -> Void) -> some View\nPresents a popover tip on the modified view.\nfunc tipCornerRadius(CGFloat, antialiased: Bool) -> some View\nfunc tipImageSize(CGSize) -> some View\nfunc tipViewStyle(some TipViewStyle) -> some View\nSets the given style for TipView within the view hierarchy"
    },
    {
        "title": "tipImageSize(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tipimagesize(_:)",
        "html": "See Also\nProviding tips\nfunc popoverTip<Content>(Content, arrowEdge: Edge) -> some View\nPresents a popover tip on the modified view.\nfunc popoverTip<Content>(Content, arrowEdge: Edge, action: (Tips.Action) -> Void) -> some View\nPresents a popover tip on the modified view.\nfunc tipBackground(some ShapeStyle) -> some View\nSets the tip\u2019s view background to a style.\nfunc tipCornerRadius(CGFloat, antialiased: Bool) -> some View\nfunc tipViewStyle(some TipViewStyle) -> some View\nSets the given style for TipView within the view hierarchy"
    },
    {
        "title": "navigationSplitViewColumnWidth(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(_:)",
        "html": "Discussion\n\nApply this modifier to the content of a column in a NavigationSplitView to specify a fixed preferred width for the column. Use navigationSplitViewColumnWidth(min:ideal:max:) if you need to specify a flexible width.\n\nThe following example shows a three-column navigation split view where the first column has a preferred width of 150 points, and the second column has a flexible, preferred width between 150 and 400 points:\n\nNavigationSplitView {\n    MySidebar()\n        .navigationSplitViewColumnWidth(150)\n} contents: {\n    MyContents()\n        .navigationSplitViewColumnWidth(\n            min: 150, ideal: 200, max: 400)\n} detail: {\n    MyDetail()\n}\n\n\nOnly some platforms enable resizing columns. If you specify a width that the current presentation environment doesn\u2019t support, SwiftUI may use a different width for your column.\n\nSee Also\nPresenting views in columns\nMigrating to new navigation types\nImprove navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.\nstruct NavigationSplitView\nA view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nstruct NavigationSplitViewVisibility\nThe visibility of the leading columns in a navigation split view.\nstruct NavigationLink\nA view that controls a navigation presentation."
    },
    {
        "title": "tipViewStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tipviewstyle(_:)",
        "html": "Parameters\nstyle\n\nThe style to set.\n\nReturn Value\n\nA view that uses the specified style on its child views.\n\nSee Also\nProviding tips\nfunc popoverTip<Content>(Content, arrowEdge: Edge) -> some View\nPresents a popover tip on the modified view.\nfunc popoverTip<Content>(Content, arrowEdge: Edge, action: (Tips.Action) -> Void) -> some View\nPresents a popover tip on the modified view.\nfunc tipBackground(some ShapeStyle) -> some View\nSets the tip\u2019s view background to a style.\nfunc tipCornerRadius(CGFloat, antialiased: Bool) -> some View\nfunc tipImageSize(CGSize) -> some View"
    },
    {
        "title": "popoverTip(_:arrowEdge:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/popovertip(_:arrowedge:)",
        "html": "See Also\nProviding tips\nfunc popoverTip<Content>(Content, arrowEdge: Edge, action: (Tips.Action) -> Void) -> some View\nPresents a popover tip on the modified view.\nfunc tipBackground(some ShapeStyle) -> some View\nSets the tip\u2019s view background to a style.\nfunc tipCornerRadius(CGFloat, antialiased: Bool) -> some View\nfunc tipImageSize(CGSize) -> some View\nfunc tipViewStyle(some TipViewStyle) -> some View\nSets the given style for TipView within the view hierarchy"
    },
    {
        "title": "healthDataAccessRequest(store:shareTypes:readTypes:trigger:completion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:sharetypes:readtypes:trigger:completion:)",
        "html": "See Also\nAccessing health data\nfunc healthDataAccessRequest(store: HKHealthStore, objectType: HKObjectType, predicate: NSPredicate?, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nRequests authorization to specific samples of the given HealthKit types; used only with types that require authorization per object Parameters: store: Your app\u2019s HKHealthStore, for which authorization will be requested objectType: The data type you want to read; this type must be a type that requires per-object authorization. predicate: An optional predicate that further restricts the objects of interest trigger: A generic equatable value; change this value to initiate a new request completion: A block that will be passed success or error when the request completes.\nfunc healthDataAccessRequest(store: HKHealthStore, readTypes: Set<HKObjectType>, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View"
    },
    {
        "title": "Link",
        "url": "https://developer.apple.com/documentation/swiftui/link",
        "html": "Overview\n\nCreate a link by providing a destination URL and a title. The title tells the user the purpose of the link, and can be a string, a title key that produces a localized string, or a view that acts as a label. The example below creates a link to example.com and displays the title string as a link-styled view:\n\nLink(\"View Our Terms of Service\",\n      destination: URL(string: \"https://www.example.com/TOS.html\")!)\n\n\nWhen a user taps or clicks a Link, the default behavior depends on the contents of the URL. For example, SwiftUI opens a Universal Link in the associated app if possible, or in the user\u2019s default web browser if not. Alternatively, you can override the default behavior by setting the openURL environment value with a custom OpenURLAction:\n\nLink(\"Visit Our Site\", destination: URL(string: \"https://www.example.com\")!)\n    .environment(\\.openURL, OpenURLAction { url in\n        print(\"Open \\(url)\")\n        return .handled\n    })\n\n\nAs with other views, you can style links using standard view modifiers depending on the view type of the link\u2019s label. For example, a Text label could be modified with a custom font(_:) or foregroundColor(_:) to customize the appearance of the link in your app\u2019s UI.\n\nTopics\nCreating a link\ninit(LocalizedStringKey, destination: URL)\nCreates a control, consisting of a URL and a title key, used to navigate to a URL.\nAvailable when Label is Text.\ninit<S>(S, destination: URL)\nCreates a control, consisting of a URL and a title string, used to navigate to a URL.\nAvailable when Label is Text.\ninit(destination: URL, label: () -> Label)\nCreates a control, consisting of a URL and a label, used to navigate to the given URL.\nRelationships\nConforms To\nView\nSee Also\nLinking to other content\nstruct ShareLink\nA view that controls a sharing presentation.\nstruct SharePreview\nA representation of a type to display in a share preview.\nstruct TextFieldLink\nA control that requests text input from the user when pressed.\nstruct HelpLink\nA button with a standard appearance that opens app-specific help documentation."
    },
    {
        "title": "popoverTip(_:arrowEdge:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/popovertip(_:arrowedge:action:)",
        "html": "See Also\nProviding tips\nfunc popoverTip<Content>(Content, arrowEdge: Edge) -> some View\nPresents a popover tip on the modified view.\nfunc tipBackground(some ShapeStyle) -> some View\nSets the tip\u2019s view background to a style.\nfunc tipCornerRadius(CGFloat, antialiased: Bool) -> some View\nfunc tipImageSize(CGSize) -> some View\nfunc tipViewStyle(some TipViewStyle) -> some View\nSets the given style for TipView within the view hierarchy"
    },
    {
        "title": "PasteButton",
        "url": "https://developer.apple.com/documentation/swiftui/pastebutton",
        "html": "Overview\n\nUse a paste button when you want to provide a button for pasting items from the system pasteboard into your app. The system provides a button appearance and label appropriate to the current environment. However, you can use view modifiers like buttonBorderShape(_:), labelStyle(_:), and tint(_:) to customize the button in some contexts.\n\nYou declare what type of items your app will accept; use a type that conforms to the Transferable protocol. When the user taps or clicks the button, your closure receives the pasteboard items in the specified type.\n\nIn the following example, a paste button declares that it accepts a string. When the user taps or clicks the button, the sample\u2019s closure receives an array of strings and sets the first as the value of pastedText, which updates a nearby Text view.\n\n@State private var pastedText: String = \"\"\n\n\nvar body: some View {\n    HStack {\n        PasteButton(payloadType: String.self) { strings in\n            pastedText = strings[0]\n        }\n        Divider()\n        Text(pastedText)\n        Spacer()\n    }\n}\n\n\nA paste button automatically validates and invalidates based on changes to the pasteboard on iOS, but not on macOS.\n\nTopics\nCreating a paste button\ninit(supportedContentTypes: [UTType], payloadAction: ([NSItemProvider]) -> Void)\nCreates a Paste button that accepts specific types of data from the pasteboard.\ninit<T>(payloadType: T.Type, onPaste: ([T]) -> Void)\nCreates an instance that accepts values of the specified type.\nDeprecated initializers\ninit(supportedTypes: [String], payloadAction: ([NSItemProvider]) -> Void)\nCreates a Paste button that accepts specific types of data from the pasteboard.\nDeprecated\ninit<Payload>(supportedTypes: [String], validator: ([NSItemProvider]) -> Payload?, payloadAction: (Payload) -> Void)\nCreates a Paste button that accepts specific types of data from the pasteboard, performing a custom validation of the data before sending it to your app.\nDeprecated\ninit<Payload>(supportedContentTypes: [UTType], validator: ([NSItemProvider]) -> Payload?, payloadAction: (Payload) -> Void)\nCreates a Paste button that accepts specific types of data from the pasteboard, performing a custom validation of the data before sending it to your app.\nDeprecated\nRelationships\nConforms To\nView\nSee Also\nCreating special-purpose buttons\nstruct EditButton\nA button that toggles the edit mode environment value.\nstruct RenameButton\nA button that triggers a standard rename action."
    },
    {
        "title": "EditButton",
        "url": "https://developer.apple.com/documentation/swiftui/editbutton",
        "html": "Overview\n\nAn edit button toggles the environment\u2019s editMode value for content within a container that supports edit mode. In the following example, an edit button placed inside a NavigationView supports editing of a List:\n\n@State private var fruits = [\n    \"Apple\",\n    \"Banana\",\n    \"Papaya\",\n    \"Mango\"\n]\n\n\nvar body: some View {\n    NavigationView {\n        List {\n            ForEach(fruits, id: \\.self) { fruit in\n                Text(fruit)\n            }\n            .onDelete { fruits.remove(atOffsets: $0) }\n            .onMove { fruits.move(fromOffsets: $0, toOffset: $1) }\n        }\n        .navigationTitle(\"Fruits\")\n        .toolbar {\n            EditButton()\n        }\n    }\n}\n\n\nBecause the ForEach in the above example defines behaviors for onDelete(perform:) and onMove(perform:), the editable list displays the delete and move UI when the user taps Edit. Notice that the Edit button displays the title \u201cDone\u201d while edit mode is active:\n\nYou can also create custom views that react to changes in the edit mode state, as described in EditMode.\n\nTopics\nCreating an edit button\ninit()\nCreates an Edit button instance.\nRelationships\nConforms To\nView\nSee Also\nCreating special-purpose buttons\nstruct PasteButton\nA system button that reads items from the pasteboard and delivers it to a closure.\nstruct RenameButton\nA button that triggers a standard rename action."
    },
    {
        "title": "ButtonRepeatBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/buttonrepeatbehavior",
        "html": "Overview\n\nUse values of this type with the buttonRepeatBehavior(_:) modifier.\n\nTopics\nGetting repeat behaviors\nstatic let automatic: ButtonRepeatBehavior\nThe automatic repeat behavior.\nstatic let enabled: ButtonRepeatBehavior\nRepeating button actions will be enabled.\nstatic let disabled: ButtonRepeatBehavior\nRepeating button actions will be disabled.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button."
    },
    {
        "title": "ButtonRole",
        "url": "https://developer.apple.com/documentation/swiftui/buttonrole",
        "html": "Overview\n\nA button role provides a description of a button\u2019s purpose. For example, the destructive role indicates that a button performs a destructive action, like delete user data:\n\nButton(\"Delete\", role: .destructive) { delete() }\n\nTopics\nGetting button roles\nstatic let cancel: ButtonRole\nA role that indicates a button that cancels an operation.\nstatic let destructive: ButtonRole\nA role that indicates a destructive button.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "buttonRepeatBehavior(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/buttonrepeatbehavior(_:)",
        "html": "Parameters\nbehavior\n\nA value of enabled means that buttons should enable repeating behavior and a value of disabled means that buttons should disallow repeating behavior.\n\nDiscussion\n\nApply this to buttons that increment or decrement a value or perform some other inherently iterative operation. Interactions such as pressing-and-holding on the button, holding the button\u2019s keyboard shortcut, or holding down the space key while the button is focused will trigger this repeat behavior.\n\nButton {\n    playbackSpeed.advance(by: 1)\n} label: {\n    Label(\"Speed up\", systemImage: \"hare\")\n}\n.buttonRepeatBehavior(.enabled)\n\n\nThis affects all system button styles, as well as automatically affects custom ButtonStyle conforming types. This does not automatically apply to custom PrimitiveButtonStyle conforming types, and the EnvironmentValues.buttonRepeatBehavior value should be used to adjust their custom gestures as appropriate.\n\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "buttonRepeatBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/buttonrepeatbehavior",
        "html": "Discussion\n\nA value of enabled means that buttons will be able to repeatedly trigger their action, and disabled means they should not. A value of automatic means that buttons will defer to default behavior.\n\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "buttonBorderShape(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/buttonbordershape(_:)",
        "html": "Parameters\nshape\n\nthe shape to use.\n\nDiscussion\n\nThe border shape is used to draw the platter for a bordered button. On macOS, the specified border shape is only applied to bordered buttons in widgets.\n\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "callAsFunction()",
        "url": "https://developer.apple.com/documentation/swiftui/dismissimmersivespaceaction/callasfunction()",
        "html": "Discussion\n\nThe call returns once the space is dismissed.\n\nDon\u2019t call this method directly. SwiftUI calls it when you call the dismissImmersiveSpace action:\n\nawait dismissImmersiveSpace()\n\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language."
    },
    {
        "title": "VolumetricWindowStyle",
        "url": "https://developer.apple.com/documentation/swiftui/volumetricwindowstyle",
        "html": "Overview\n\nUse volumetric to construct this style:\n\nWindowGroup {\n    ContentView()\n}\n.windowStyle(.volumetric)\n\nTopics\nCreating the window style\ninit()\nRelationships\nConforms To\nWindowStyle\nSee Also\nSupporting types\nstruct DefaultWindowStyle\nThe default window style.\nstruct HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nstruct PlainWindowStyle\nThe plain window style.\nBeta\nstruct TitleBarWindowStyle\nA window style which displays the title bar section of the window."
    },
    {
        "title": "accessibilityInputLabels(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityinputlabels(_:)-2upwq",
        "html": "Discussion\n\nProvide labels in descending order of importance. Voice Control and Full Keyboard Access use the input labels.\n\nNote\n\nIf you don\u2019t specify any input labels, the user can still refer to the view using the accessibility label that you add with the accessibilityLabel() modifier.\n\nSee Also\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair."
    },
    {
        "title": "photosPickerAccessoryVisibility(_:edges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/photospickeraccessoryvisibility(_:edges:)",
        "html": "Parameters\nedges\n\nThe accessory visibility to apply.\n\nedges\n\nOne or more of the available edges.\n\nReturn Value\n\nA Photos picker with the specified accessory visibility.\n\nSee Also\nSelecting photos\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker."
    },
    {
        "title": "init(label:)",
        "url": "https://developer.apple.com/documentation/swiftui/settingslink/init(label:)",
        "html": "Parameters\nlabel\n\nA view to use as the label for this settings link.\n\nSee Also\nCreating a settings link\ninit()\nCreates a settings link with the default system label."
    },
    {
        "title": "Accessibility modifiers",
        "url": "https://developer.apple.com/documentation/swiftui/view-accessibility",
        "html": "Overview\n\nLike all Apple UI frameworks, SwiftUI comes with built-in accessibility support. The framework introspects common elements like navigation views, lists, text fields, sliders, buttons, and so on, and provides basic accessibility labels and values by default. You don\u2019t have to do any extra work to enable these standard accessibility features.\n\nSwiftUI also provides tools to help you enhance the accessibility of your app. For example, you can explicitly add accessibility labels to elements in your UI using the accessibilityLabel(_:) or the accessibilityValue(_:) view modifier.\n\nTo learn more about adding accessibility features to your app, see Accessibility fundamentals.\n\nTopics\nLabels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nValues\nfunc accessibilityValue<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nfunc accessibilityValue(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nfunc accessibilityValue(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nHints\nfunc accessibilityHint(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nfunc accessibilityHint(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nfunc accessibilityHint<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nActions\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nGestures\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nElements\nfunc accessibilityElement(children: AccessibilityChildBehavior) -> some View\nCreates a new accessibility element, or modifies the AccessibilityChildBehavior of the existing accessibility element.\nfunc accessibilityChildren<V>(children: () -> V) -> some View\nReplaces the existing accessibility element\u2019s children with one or more new synthetic accessibility elements.\nfunc accessibilityHidden(Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSpecifies whether to hide this view from system accessibility features.\nCustom controls\nfunc accessibilityRepresentation<V>(representation: () -> V) -> some View\nReplaces one or more accessibility elements for this view with new accessibility elements.\nfunc accessibilityRespondsToUserInteraction(Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this Accessibility element responds to user interaction and would thus be interacted with by technologies such as Switch Control, Voice Control or Full Keyboard Access.\nCustom content\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nCreating rotors\nfunc accessibilityRotor<Content>(LocalizedStringKey, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<Content>(Text, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<L, Content>(L, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<EntryModel, ID>(LocalizedStringKey, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<EntryModel, ID>(Text, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel, ID>(L, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<EntryModel>(LocalizedStringKey, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<EntryModel>(Text, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel>(L, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor(LocalizedStringKey, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nfunc accessibilityRotor(Text, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nfunc accessibilityRotor<L>(L, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nReplacing system rotors\nfunc accessibilityRotor<Content>(AccessibilitySystemRotor, entries: () -> Content) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel, ID>(AccessibilitySystemRotor, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel>(AccessibilitySystemRotor, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor(AccessibilitySystemRotor, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nConfiguring rotors\nfunc accessibilityRotorEntry<ID>(id: ID, in: Namespace.ID) -> some View\nDefines an explicit identifier tying an Accessibility element for this view to an entry in an Accessibility Rotor.\nfunc accessibilityLinkedGroup<ID>(id: ID, in: Namespace.ID) -> some View\nLinks multiple accessibility elements so that the user can quickly navigate from one element to another, even when the elements are not near each other in the accessibility hierarchy.\nfunc accessibilitySortPriority(Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the sort priority order for this view\u2019s accessibility element, relative to other elements at the same level.\nFocus\nfunc accessibilityFocused(AccessibilityFocusState<Bool>.Binding) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given boolean state value.\nfunc accessibilityFocused<Value>(AccessibilityFocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given state value.\nTraits\nfunc accessibilityAddTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds the given traits to the view.\nfunc accessibilityRemoveTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nRemoves the given traits from this view.\nIdentity\nfunc accessibilityIdentifier(String) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nUses the string you specify to identify the view.\nColor inversion\nfunc accessibilityIgnoresInvertColors(Bool) -> some View\nSets whether this view should ignore the system Smart Invert setting.\nContent descriptions\nfunc accessibilityTextContentType(AccessibilityTextContentType) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets an accessibility text content type.\nfunc accessibilityHeading(AccessibilityHeadingLevel) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the accessibility level of this heading.\nVoiceOver\nfunc speechAdjustedPitch(Double) -> some View\nRaises or lowers the pitch of spoken text.\nfunc speechAlwaysIncludesPunctuation(Bool) -> some View\nSets whether VoiceOver should always speak all punctuation in the text view.\nfunc speechAnnouncementsQueued(Bool) -> some View\nControls whether to queue pending announcements behind existing speech rather than interrupting speech in progress.\nfunc speechSpellsOutCharacters(Bool) -> some View\nSets whether VoiceOver should speak the contents of the text view character by character.\nCharts\nfunc accessibilityChartDescriptor<R>(R) -> some View\nAdds a descriptor to a View that represents a chart to make the chart\u2019s contents accessible to all users.\nLarge content\nfunc accessibilityShowsLargeContentViewer() -> some View\nAdds a default large content view to be shown by the large content viewer.\nfunc accessibilityShowsLargeContentViewer<V>(() -> V) -> some View\nAdds a custom large content view to be shown by the large content viewer.\nQuick actions\nfunc accessibilityQuickAction<Style, Content>(style: Style, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active.\nfunc accessibilityQuickAction<Style, Content>(style: Style, isActive: Binding<Bool>, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active.\nSee Also\nConfiguring view elements\nAppearance modifiers\nConfigure a view\u2019s foreground and background styles, controls, and visibility.\nText and symbol modifiers\nManage the rendering, selection, and entry of text in your view.\nAuxiliary view modifiers\nAdd and configure supporting views, like toolbars and context menus.\nChart view modifiers\nConfigure charts that you declare with Swift Charts."
    },
    {
        "title": "InterfaceOrientation",
        "url": "https://developer.apple.com/documentation/swiftui/interfaceorientation",
        "html": "Overview\n\nBy default, device previews appear right side up, using orientation portrait. You can change the orientation with a call to the previewInterfaceOrientation(_:) modifier:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n            .previewInterfaceOrientation(.landscapeRight)\n    }\n}\n\nTopics\nGetting an orientation\nstatic let portrait: InterfaceOrientation\nThe device is in portrait mode, with the top of the device on top.\nstatic let portraitUpsideDown: InterfaceOrientation\nThe device is in portrait mode, but is upside down.\nstatic let landscapeLeft: InterfaceOrientation\nThe device is in landscape mode, with the top of the device on the left.\nstatic let landscapeRight: InterfaceOrientation\nThe device is in landscape mode, with the top of the device on the right.\nRelationships\nConforms To\nCaseIterable\nEquatable\nIdentifiable\nSendable\nSee Also\nCustomizing a preview\nfunc previewDevice(PreviewDevice?) -> some View\nOverrides the device for a preview.\nstruct PreviewDevice\nA simulator device that runs a preview.\nfunc previewLayout(PreviewLayout) -> some View\nOverrides the size of the container for the preview.\nfunc previewInterfaceOrientation(InterfaceOrientation) -> some View\nOverrides the orientation of the preview."
    },
    {
        "title": "previewLayout(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/previewlayout(_:)",
        "html": "Parameters\nvalue\n\nA layout to use for preview.\n\nReturn Value\n\nA preview that uses the given layout.\n\nDiscussion\n\nBy default, previews use the PreviewLayout/device layout, which places the view inside a visual representation of the chosen device. You can instead tell a preview to use a different layout by choosing one of the PreviewLayout values, like PreviewLayout/sizeThatFits:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n            .previewLayout(.sizeThatFits)\n    }\n}\n\nSee Also\nCustomizing a preview\nfunc previewDevice(PreviewDevice?) -> some View\nOverrides the device for a preview.\nstruct PreviewDevice\nA simulator device that runs a preview.\nfunc previewInterfaceOrientation(InterfaceOrientation) -> some View\nOverrides the orientation of the preview.\nstruct InterfaceOrientation\nThe orientation of the interface from the user\u2019s perspective."
    },
    {
        "title": "previewDisplayName(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/previewdisplayname(_:)",
        "html": "Parameters\nvalue\n\nA name for the preview.\n\nReturn Value\n\nA preview that uses the given name.\n\nDiscussion\n\nApply this modifier to a view inside your PreviewProvider implementation to associate a display name with that view\u2019s preview:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n            .previewDisplayName(\"Circle\")\n    }\n}\n\n\nAdd a name when you have multiple previews together in the canvas that you need to tell apart. The default value is nil, in which case Xcode displays a default string.\n\nSee Also\nDefining a preview\nprotocol PreviewProvider\nA type that produces view previews in Xcode.\nenum PreviewPlatform\nPlatforms that can run the preview."
    },
    {
        "title": "PreviewProvider",
        "url": "https://developer.apple.com/documentation/swiftui/previewprovider",
        "html": "Overview\n\nImportant\n\nYou can use this protocol to define a preview manually, but you typically use a preview macro like Preview(_:body:) instead.\n\nYou can create an Xcode preview by declaring a structure that conforms to the PreviewProvider protocol. Implement the required previews computed property, and return the view to display:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n    }\n}\n\n\nXcode statically discovers preview providers in your project and generates previews for any providers currently open in the source editor. Xcode generates the preview using the current run destination as a hint for which device to display. For example, Xcode shows the following preview if you\u2019ve selected an iOS target to run on the iPhone 12 Pro Max simulator:\n\nWhen you create a new file (File > New > File) and choose the SwiftUI view template, Xcode automatically inserts a preview structure at the bottom of the file that you can configure. You can also create new preview structures in an existing SwiftUI view file by choosing Editor > Create Preview.\n\nCustomize the preview\u2019s appearance by adding view modifiers, just like you do when building a custom View. This includes preview-specific modifiers that let you control aspects of the preview, like the device orientation:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n            .previewInterfaceOrientation(.landscapeLeft)\n    }\n}\n\n\nFor the complete list of preview customizations, see Previews in Xcode.\n\nXcode creates different previews for each view in your preview, so you can see variations side by side. For example, you might want to see a view\u2019s light and dark appearances simultaneously:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n        CircleImage()\n            .preferredColorScheme(.dark)\n    }\n}\n\n\nUse a Group when you want to maintain different previews, but apply a single modifier to all of them:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            CircleImage()\n            CircleImage()\n                .preferredColorScheme(.dark)\n        }\n        .previewLayout(.sizeThatFits)\n    }\n}\n\n\nTopics\nCreating a preview\nstatic var previews: Self.Previews\nA collection of views to preview.\n\nRequired\n\nassociatedtype Previews : View\nThe type to preview.\n\nRequired\n\nSpecifying the platform\nstatic var platform: PreviewPlatform?\nThe platform on which to run the provider.\n\nRequired Default implementation provided.\n\nSee Also\nDefining a preview\nenum PreviewPlatform\nPlatforms that can run the preview.\nfunc previewDisplayName(String?) -> some View\nSets a user visible name to show in the canvas for a preview."
    },
    {
        "title": "Preview(_:immersionStyle:traits:body:cameras:)",
        "url": "https://developer.apple.com/documentation/swiftui/preview(_:immersionstyle:traits:body:cameras:)",
        "html": "Parameters\nname\n\nAn optional display name for the preview. If you don\u2019t specify a name, the canvas labels the preview using the line number where the preview appears in source.\n\nimmersionStyle\n\nThe ImmersionStyle to use for the preview. Use this input to display the view as if it appears in an immersive space that has the specified style.\n\ntraits\n\nAn optional list of PreviewTrait instances that customize the appearance of the preview.\n\nbody\n\nA ViewBuilder that produces a SwiftUI view to preview. You typically specify one of your app\u2019s custom views and optionally any inputs, model data, modifiers, and enclosing views that the custom view needs for normal operation.\n\ncameras\n\nOne or more preview cameras that indicate the custom, fixed viewpoints that you want to be able to view the preview from. The first of these replaces the front viewpoint as the default.\n\nOverview\n\nThis preview macro behaves like Preview(_:immersionStyle:traits:body:) combined with Preview(_:traits:body:cameras:): it enables you to define an immersive space scene context for the view, and also to define custom, fixed viewpoints for the preview:\n\n#Preview(\"Mixed immersive space\", immersionStyle: .mixed) {\n   ContentView()\n} cameras: {\n   PreviewCamera(from: .front)\n   PreviewCamera(from: .top, zoom: 2)\n   PreviewCamera(from: .leading, zoom: 0.5, name: \"close up\")\n}\n\n\nSee those other preview macros for more information about using scenes and cameras in your preview. If you want to preview in a window rather than an immersive space, use Preview(_:windowStyle:traits:body:cameras:).\n\nSee Also\nCreating a preview in the context of a scene\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in an immersive space.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in a window.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in a window with custom viewpoints.\nBeta"
    },
    {
        "title": "Preview(_:windowStyle:traits:body:cameras:)",
        "url": "https://developer.apple.com/documentation/swiftui/preview(_:windowstyle:traits:body:cameras:)",
        "html": "Parameters\nname\n\nAn optional display name for the preview. If you don\u2019t specify a name, the canvas labels the preview using the line number where the preview appears in source.\n\nwindowStyle\n\nThe WindowStyle to use for the preview. Use this input to display the view as if it appears in a window that has the specified style.\n\ntraits\n\nAn optional list of PreviewTrait instances that customize the appearance of the preview.\n\nbody\n\nA ViewBuilder that produces a SwiftUI view to preview. You typically specify one of your app\u2019s custom views and optionally any inputs, model data, modifiers, and enclosing views that the custom view needs for normal operation.\n\ncameras\n\nOne or more preview cameras that indicate the custom, fixed viewpoints that you want to be able to view the preview from. The first of these replaces the front viewpoint as the default.\n\nOverview\n\nThis preview macro behaves like Preview(_:windowStyle:traits:body:) combined with Preview(_:traits:body:cameras:): it enables you to define a window scene context for the view, and also to define custom, fixed viewpoints for the preview:\n\n#Preview(\"Volume\", windowStyle: .volumetric) {\n   ContentView()\n} cameras: {\n   PreviewCamera(from: .front)\n   PreviewCamera(from: .top, zoom: 2)\n   PreviewCamera(from: .leading, zoom: 0.5, name: \"close up\")\n}\n\n\nSee those other preview macros for more information about using scenes and cameras in your preview. If you want to preview in an immersive space rather than a window, use Preview(_:immersionStyle:traits:body:cameras:).\n\nSee Also\nCreating a preview in the context of a scene\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in an immersive space.\nBeta\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in an immersive space with custom viewpoints.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in a window.\nBeta"
    },
    {
        "title": "Preview(_:immersionStyle:traits:body:)",
        "url": "https://developer.apple.com/documentation/swiftui/preview(_:immersionstyle:traits:body:)",
        "html": "Parameters\nname\n\nAn optional display name for the preview. If you don\u2019t specify a name, the canvas labels the preview using the line number where the preview appears in source.\n\nimmersionStyle\n\nThe ImmersionStyle to use for the preview. Use this input to display the view as if it appears in an immersive space that has the specified style.\n\ntraits\n\nAn optional list of PreviewTrait instances that customize the appearance of the preview.\n\nbody\n\nA ViewBuilder that produces a SwiftUI view to preview. You typically specify one of your app\u2019s custom views and optionally any inputs, model data, modifiers, and enclosing views that the custom view needs for normal operation.\n\nOverview\n\nThis preview macro behaves like Preview(_:traits:_:body:), except that it also enables you to define a scene context for the view. Specifically, it places the view in an immersive space with the specified immersion style, like the mixed style:\n\n#Preview(\"Mixed immersive space\", immersionStyle: .mixed) {\n   ContentView()\n}\n\n\nUse this preview macro when the view needs scene context to behave as it would during normal operation of your app.\n\nOther preview macros provide different customization options. For example, if you want to see how the view appears in a window rather than an immersive space, you can use Preview(_:windowStyle:traits:body:). If you want to add custom, fixed viewpoints to an immersive space preview, use Preview(_:immersionStyle:traits:body:cameras:).\n\nSee Also\nCreating a preview in the context of a scene\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in an immersive space with custom viewpoints.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in a window.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in a window with custom viewpoints.\nBeta"
    },
    {
        "title": "Preview(_:traits:body:cameras:)",
        "url": "https://developer.apple.com/documentation/swiftui/preview(_:traits:body:cameras:)",
        "html": "Parameters\nname\n\nAn optional display name for the preview. If you don\u2019t specify a name, the canvas labels the preview using the line number where the preview appears in source.\n\ntraits\n\nAn optional list of PreviewTrait instances that customize the appearance of the preview.\n\nbody\n\nA ViewBuilder that produces a SwiftUI view to preview. You typically specify one of your app\u2019s custom views and optionally any inputs, model data, modifiers, and enclosing views that the custom view needs for normal operation.\n\ncameras\n\nOne or more preview cameras that indicate the custom, fixed viewpoints that you want to be able to view the preview from. The first of these replaces the front viewpoint as the default.\n\nOverview\n\nThis macro behaves like Preview(_:traits:_:body:) except that it also enables you to specify one or more PreviewCamera instances that define custom, fixed viewpoints from which to view the preview:\n\n#Preview {\n    ContentView()\n} cameras: {\n    PreviewCamera(from: .bottomLeadingBack, name: \"Corner 1\")\n    PreviewCamera(from: .topTrailingFront, name: \"Corner 2\")\n}\n\n\nIf you use one of the preview macros that doesn\u2019t include a cameras closure, the canvas displays the preview from the front by default. It also provides a camera picker to choose other standard, fixed viewpoints \u2014 like the top or the back. When you do specify one or more preview cameras, the canvas adds a submenu to the camera picker that lists the viewpoints that you define, like Corner 1 and Corner 2 in the above example. The canvas also displays the preview from the first of these custom viewpoints by default when it loads the preview.\n\nNote\n\nIn addition to using fixed camera perspectives, you can also interactively alter the viewpoint of a preview in the canvas using controls like those that Simulator provides. For more information, see Interacting with your app in the visionOS simulator.\n\nOther preview macros provide different customization options. For example, if you want to preview the view as it would appear in a particular kind of scene, you can use Preview(_:immersionStyle:traits:body:cameras:) or Preview(_:windowStyle:traits:body:cameras:).\n\nSee Also\nCreating a preview\nmacro Preview(String?, body: () -> View)\nCreates a preview of a SwiftUI view.\nmacro Preview(String?, traits: PreviewTrait<Preview.ViewTraits>, PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view using the specified traits."
    },
    {
        "title": "Preview(_:traits:_:body:)",
        "url": "https://developer.apple.com/documentation/swiftui/preview(_:traits:_:body:)",
        "html": "Parameters\nname\n\nAn optional display name for the preview. If you don\u2019t specify a name, the canvas labels the preview using the line number where the preview appears in source.\n\ntraits\n\nA PreviewTrait instance that customizes the appearance of the preview.\n\nadditionalTraits\n\nOptional additional traits that further customize the preview.\n\nbody\n\nA ViewBuilder that produces a SwiftUI view to preview. You typically specify one of your app\u2019s custom views and optionally any inputs, model data, modifiers, and enclosing views that the custom view needs for normal operation.\n\nOverview\n\nThis macro behaves like Preview(_:body:) except that it also enables you to customize the appearance of the preview by adding one or more traits, which are instances of PreviewTrait. For example, you can display a preview at a fixed size using the fixedLayout(width:height:) trait:\n\n#Preview(\n    \"Content\",\n    traits: .fixedLayout(width: 100, height: 100)\n) {\n    ContentView()\n}\n\n\nThe macro ignores traits that don\u2019t apply to the current context. For example, the portrait trait has no impact on a visionOS preview.\n\nOther preview macros provide different customization options. For example, if you want to specify a custom viewpoint for the preview, use Preview(_:traits:body:cameras:).\n\nSee Also\nCreating a preview\nmacro Preview(String?, body: () -> View)\nCreates a preview of a SwiftUI view.\nmacro Preview(String?, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view using the specified traits and custom viewpoints.\nBeta"
    },
    {
        "title": "UIHostingController",
        "url": "https://developer.apple.com/documentation/swiftui/uihostingcontroller",
        "html": "Overview\n\nCreate a UIHostingController object when you want to integrate SwiftUI views into a UIKit view hierarchy. At creation time, specify the SwiftUI view you want to use as the root view for this view controller; you can change that view later using the rootView property. Use the hosting controller like you would any other view controller, by presenting it or embedding it as a child view controller in your interface.\n\nTopics\nCreating a hosting controller object\ninit(rootView: Content)\nCreates a hosting controller object that wraps the specified SwiftUI view.\ninit?(coder: NSCoder, rootView: Content)\nCreates a hosting controller object from an archive and the specified SwiftUI view.\ninit?(coder: NSCoder)\nCreates a hosting controller object from the contents of the specified archive.\nResponding to view-related events\nfunc loadView()\nfunc viewWillAppear(Bool)\nNotifies the view controller that its view is about to be added to a view hierarchy.\nfunc viewIsAppearing(Bool)\nfunc viewDidAppear(Bool)\nNotifies the view controller that its view has been added to a view hierarchy.\nfunc viewWillDisappear(Bool)\nNotifies the view controller that its view will be removed from a view hierarchy.\nfunc viewDidDisappear(Bool)\nfunc willMove(toParent: UIViewController?)\nfunc didMove(toParent: UIViewController?)\nfunc viewWillTransition(to: CGSize, with: UIViewControllerTransitionCoordinator)\nfunc viewWillLayoutSubviews()\nfunc target(forAction: Selector, withSender: Any?) -> Any?\nvar rootView: Content\nThe root view of the SwiftUI view hierarchy managed by this view controller.\nChecking for modality\nvar isModalInPresentation: Bool\nManaging the size\nvar sizingOptions: UIHostingControllerSizingOptions\nThe options for how the hosting controller tracks changes to the size of its SwiftUI content.\nfunc preferredContentSizeDidChange(forChildContentContainer: UIContentContainer)\nfunc sizeThatFits(in: CGSize) -> CGSize\nCalculates and returns the most appropriate size for the current view.\nvar safeAreaRegions: SafeAreaRegions\nThe safe area regions that this view controller adds to its view.\nAvailable when Content conforms to View.\nConfiguring the status bar\nvar preferredStatusBarStyle: UIStatusBarStyle\nThe preferred status bar style for the view controller.\nvar preferredStatusBarUpdateAnimation: UIStatusBarAnimation\nThe animation style to use when hiding or showing the status bar for this view controller.\nvar prefersStatusBarHidden: Bool\nA Boolean value that indicates whether the view controller prefers the status bar to be hidden or shown.\nvar childForStatusBarStyle: UIViewController?\nvar childForStatusBarHidden: UIViewController?\nConfiguring the home indicator\nvar prefersHomeIndicatorAutoHidden: Bool\nA Boolean value that indicates whether the view controller prefers the home indicator to be hidden or shown.\nvar childForHomeIndicatorAutoHidden: UIViewController?\nConfiguring the interface appearance\nvar preferredUserInterfaceStyle: UIUserInterfaceStyle\nThe preferred interface style for this view controller.\nvar preferredScreenEdgesDeferringSystemGestures: UIRectEdge\nSets the screen edge from which you want your gesture to take precedence over the system gesture.\nvar childForScreenEdgesDeferringSystemGestures: UIViewController?\nAccessing the available key commands\nvar keyCommands: [UIKeyCommand]?\nManaging undo\nvar undoManager: UndoManager?\nInstance Properties\nvar childViewControllerForPreferredContainerBackgroundStyle: UIViewController?\nvar preferredContainerBackgroundStyle: UIContainerBackgroundStyle\nInstance Methods\nfunc addChild(UIViewController)\nRelationships\nInherits From\nUIViewController\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSExtensionRequestHandling\nNSObjectProtocol\nNSTouchBarProvider\nUIActivityItemsConfigurationProviding\nUIAppearanceContainer\nUIContentContainer\nUIFocusEnvironment\nUIPasteConfigurationSupporting\nUIResponderStandardEditActions\nUIStateRestoring\nUITraitChangeObservable\nUITraitEnvironment\nUIUserActivityRestoring\nSee Also\nDisplaying SwiftUI views in UIKit\nstruct UIHostingControllerSizingOptions\nOptions for how a hosting controller tracks its content\u2019s size.\nstruct UIHostingConfiguration\nA content configuration suitable for hosting a hierarchy of SwiftUI views."
    },
    {
        "title": "Preview(_:body:)",
        "url": "https://developer.apple.com/documentation/swiftui/preview(_:body:)",
        "html": "Parameters\nname\n\nAn optional display name for the preview. If you don\u2019t specify a name, the canvas labels the preview using the line number where the preview appears in source.\n\nbody\n\nA ViewBuilder that produces a SwiftUI view to preview. You typically specify one of your app\u2019s custom views and optionally any inputs, model data, modifiers, and enclosing views that the custom view needs for normal operation.\n\nOverview\n\nUse this macro to display a SwiftUI preview in the canvas. You typically specify at least one preview macro for every View that your app defines to help you develop, test, and debug the view:\n\nstruct ContentView: View {\n    var body: some View {\n        // ...\n    }\n}\n\n\n#Preview {\n    ContentView()\n}\n\n\nIf you include more than one preview in a source file, the canvas provides controls that enable you to select which to display when that source file is active. The canvas labels the different previews with the line number where the preview appears in source. To better identify the previews in the canvas, you can give them names. For example if your ContentView takes a Boolean input, you can create named previews for each input state:\n\n#Preview(\"Input true\") {\n    ContentView(someInput: true)\n}\n\n\n#Preview(\"Input false\") {\n    ContentView(someInput: false)\n}\n\n\nInside the preview, you can provide different inputs, model data, and other infrastructure that the view needs for normal operation. For example, you can present a custom view as the sidebar inside a NavigationSplitView if that\u2019s how your app uses the view.\n\nOther preview macros provide different customization options. For example, if you need to modify the appearance of a preview using one or more PreviewTrait, instances, use the Preview(_:traits:_:body:) macro.\n\nSee Also\nCreating a preview\nmacro Preview(String?, traits: PreviewTrait<Preview.ViewTraits>, PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view using the specified traits.\nmacro Preview(String?, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view using the specified traits and custom viewpoints.\nBeta"
    },
    {
        "title": "Body",
        "url": "https://developer.apple.com/documentation/swiftui/view/body-swift.associatedtype",
        "html": "Required\n\nDiscussion\n\nWhen you create a custom view, Swift infers this type from your implementation of the required body property.\n\nSee Also\nImplementing a custom view\nvar body: Self.Body\nThe content and behavior of the view.\n\nRequired Default implementations provided.\n\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nPreviews in Xcode\nGenerate dynamic, interactive previews of your custom views."
    },
    {
        "title": "UIHostingConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/uihostingconfiguration",
        "html": "Overview\n\nUse a value of this type, which conforms to the UIContentConfiguration protocol, with a UICollectionViewCell or UITableViewCell to host a hierarchy of SwiftUI views in a collection or table view, respectively. For example, the following shows a stack with an image and text inside the cell:\n\nmyCell.contentConfiguration = UIHostingConfiguration {\n    HStack {\n        Image(systemName: \"star\").foregroundStyle(.purple)\n        Text(\"Favorites\")\n        Spacer()\n    }\n}\n\n\nYou can also customize the background of the containing cell. The following example draws a blue background:\n\nmyCell.contentConfiguration = UIHostingConfiguration {\n    HStack {\n        Image(systemName: \"star\").foregroundStyle(.purple)\n        Text(\"Favorites\")\n        Spacer()\n    }\n}\n.background {\n    Color.blue\n}\n\n\nWhen used in a list layout, certain APIs are bridged automatically, like swipe actions and separator alignment. The following example shows a trailing yellow star swipe action:\n\ncell.contentConfiguration = UIHostingConfiguration {\n    HStack {\n        Image(systemName: \"airplane\")\n        Text(\"Flight 123\")\n        Spacer()\n    }\n    .swipeActions {\n        Button { ... } label: {\n            Label(\"Favorite\", systemImage: \"star\")\n        }\n        .tint(.yellow)\n    }\n}\n\nTopics\nCreating and updating a configuration\ninit(content: () -> Content)\nCreates a hosting configuration with the given contents.\nAvailable when Content conforms to View and Background is EmptyView.\nSetting the background\nfunc background<S>(S) -> UIHostingConfiguration<Content, _UIHostingConfigurationBackgroundView<S>>\nSets the background contents for the hosting configuration\u2019s enclosing cell.\nfunc background<B>(content: () -> B) -> UIHostingConfiguration<Content, B>\nSets the background contents for the hosting configuration\u2019s enclosing cell.\nSetting margins\nfunc margins(Edge.Set, EdgeInsets) -> UIHostingConfiguration<Content, Background>\nSets the margins around the content of the configuration.\nfunc margins(Edge.Set, CGFloat) -> UIHostingConfiguration<Content, Background>\nSets the margins around the content of the configuration.\nSetting a size\nfunc minSize(width: CGFloat?, height: CGFloat?) -> UIHostingConfiguration<Content, Background>\nSets the minimum size for the configuration.\nfunc minSize() -> UIHostingConfiguration<Content, Background>\nSets the minimum size for the configuration.\nDeprecated\nRelationships\nConforms To\nUIContentConfiguration\nSee Also\nDisplaying SwiftUI views in UIKit\nclass UIHostingController\nA UIKit view controller that manages a SwiftUI view hierarchy.\nstruct UIHostingControllerSizingOptions\nOptions for how a hosting controller tracks its content\u2019s size."
    },
    {
        "title": "UIViewControllerRepresentableContext",
        "url": "https://developer.apple.com/documentation/swiftui/uiviewcontrollerrepresentablecontext",
        "html": "Overview\n\nA UIViewControllerRepresentableContext structure contains details about the current state of the system. When creating and updating your view controller, the system creates one of these structures and passes it to the appropriate method of your custom UIViewControllerRepresentable instance. Use the information in this structure to configure your view controller. For example, use the provided environment values to configure the appearance of your view controller and views. Don\u2019t create this structure yourself.\n\nTopics\nCoordinating view controller interactions\nlet coordinator: Representable.Coordinator\nThe view\u2019s associated coordinator.\nvar transaction: Transaction\nThe current transaction.\nGetting the environment data\nvar environment: EnvironmentValues\nEnvironment values that describe the current state of the system.\nRelationships\nConforms To\nSendable\nSee Also\nAdding UIKit views to SwiftUI view hierarchies\nprotocol UIViewRepresentable\nA wrapper for a UIKit view that you use to integrate that view into your SwiftUI view hierarchy.\nstruct UIViewRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view.\nprotocol UIViewControllerRepresentable\nA view that represents a UIKit view controller."
    },
    {
        "title": "AccessibilityLabeledPairRole",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitylabeledpairrole",
        "html": "Topics\nGetting roles\ncase content\nThis element represents the content part of the label / content pair.\ncase label\nThis element represents the label part of the label / content pair.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content."
    },
    {
        "title": "accessibilityTextContentType(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitytextcontenttype(_:)",
        "html": "Parameters\nvalue\n\nThe accessibility content type from the available AccessibilityTextContentType options.\n\nDiscussion\n\nUse this modifier to set the content type of this accessibility element. Assistive technologies can use this property to choose an appropriate way to output the text. For example, when encountering a source coding context, VoiceOver could choose to speak all punctuation.\n\nThe default content type plain.\n\nSee Also\nDescribing content\nfunc accessibilityHeading(AccessibilityHeadingLevel) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the accessibility level of this heading.\nenum AccessibilityHeadingLevel\nThe hierarchy of a heading in relation other headings.\nstruct AccessibilityTextContentType\nTextual context that assistive technologies can use to improve the presentation of spoken text."
    },
    {
        "title": "UIViewControllerRepresentable",
        "url": "https://developer.apple.com/documentation/swiftui/uiviewcontrollerrepresentable",
        "html": "Overview\n\nUse a UIViewControllerRepresentable instance to create and manage a UIViewController object in your SwiftUI interface. Adopt this protocol in one of your app\u2019s custom instances, and use its methods to create, update, and tear down your view controller. The creation and update processes parallel the behavior of SwiftUI views, and you use them to configure your view controller with your app\u2019s current state information. Use the teardown process to remove your view controller cleanly from your SwiftUI. For example, you might use the teardown process to notify other objects that the view controller is disappearing.\n\nTo add your view controller into your SwiftUI interface, create your UIViewControllerRepresentable instance and add it to your SwiftUI interface. The system calls the methods of your custom instance at appropriate times.\n\nThe system doesn\u2019t automatically communicate changes occurring within your view controller to other parts of your SwiftUI interface. When you want your view controller to coordinate with other SwiftUI views, you must provide a Coordinator instance to facilitate those interactions. For example, you use a coordinator to forward target-action and delegate messages from your view controller to any SwiftUI views.\n\nTopics\nCreating and updating the view controller\nfunc makeUIViewController(context: Self.Context) -> Self.UIViewControllerType\nCreates the view controller object and configures its initial state.\n\nRequired\n\nfunc updateUIViewController(Self.UIViewControllerType, context: Self.Context)\nUpdates the state of the specified view controller with new information from SwiftUI.\n\nRequired\n\ntypealias Context\nassociatedtype UIViewControllerType : UIViewController\nThe type of view controller to present.\n\nRequired\n\nSpecifying a size\nfunc sizeThatFits(ProposedViewSize, uiViewController: Self.UIViewControllerType, context: Self.Context) -> CGSize?\nGiven a proposed size, returns the preferred size of the composite view.\n\nRequired Default implementation provided.\n\nCleaning up the view controller\nstatic func dismantleUIViewController(Self.UIViewControllerType, coordinator: Self.Coordinator)\nCleans up the presented view controller (and coordinator) in anticipation of their removal.\n\nRequired Default implementation provided.\n\nProviding a custom coordinator object\nfunc makeCoordinator() -> Self.Coordinator\nCreates the custom instance that you use to communicate changes from your view controller to other parts of your SwiftUI interface.\n\nRequired Default implementation provided.\n\nassociatedtype Coordinator = Void\nA type to coordinate with the view controller.\n\nRequired\n\nPerforming layout\ntypealias LayoutOptions\nRelationships\nInherits From\nView\nSee Also\nAdding UIKit views to SwiftUI view hierarchies\nprotocol UIViewRepresentable\nA wrapper for a UIKit view that you use to integrate that view into your SwiftUI view hierarchy.\nstruct UIViewRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view.\nstruct UIViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view controller."
    },
    {
        "title": "WKUserNotificationHostingController",
        "url": "https://developer.apple.com/documentation/swiftui/wkusernotificationhostingcontroller",
        "html": "Overview\n\nA WKUserNotificationHostingController presents and manages your app\u2019s notification interface using SwiftUI views. You must subclass WKUserNotificationHostingController and override the body property to provide the set of SwiftUI views you want to display. In the storyboard of your watch app, specify the name of your custom class for your dynamic interactive interface.\n\nTopics\nCreating a hosting controller object\ninit()\nCreates a notification hosting controller object that you can use to implement your notification interfaces using SwiftUI views.\nGetting the root view\nvar body: Body\nThe root view of the view hierarchy to display for your notification interface.\nConfiguring the notification\nclass var coalescedDescriptionFormat: String?\nThe format string to display when multiple notifications of the same type arrive simultaneously. If you specify a custom string, you can use the %d variable to reflect the number of notifications. If nil format will be the system default.\nclass var isInteractive: Bool\nIf the notification should accept user input.\nclass var sashColor: Color?\nColor to use within the sash of the long look interface. If nil the sash will be the default system color.\nclass var subtitleColor: Color?\nThe color to apply to the subtitle text displayed in the short look interface. If nil the text will be the default system color.\nclass var titleColor: Color?\nThe color to apply to the text displayed in the sash. If nil the text will be the default system color.\nclass var wantsSashBlur: Bool\nIf the sash should include a blur over the background.\nRelationships\nInherits From\nWKUserNotificationInterfaceController\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSObjectProtocol\nSee Also\nDisplaying SwiftUI views in WatchKit\nclass WKHostingController\nA WatchKit interface controller that hosts a SwiftUI view hierarchy."
    },
    {
        "title": "UITraitBridgedEnvironmentKey",
        "url": "https://developer.apple.com/documentation/swiftui/uitraitbridgedenvironmentkey",
        "html": "Overview\n\nUse this protocol to allow the same underlying data to be accessed using an environment key in SwiftUI and trait in UIKit. As the bridging is bidirectional, values written to the trait in UIKit can be read using the environment key in SwiftUI, and values written to the environment key in SwiftUI can be read from the trait in UIKit.\n\nGiven a custom UIKit trait named MyTrait with myTrait properties on both UITraitCollection and UIMutableTraits:\n\nstruct MyTrait: UITraitDefinition {\n    static let defaultValue = \"Default value\"\n}\n\n\nextension UITraitCollection {\n    var myTrait: String {\n        self[MyTrait.self]\n    }\n}\n\n\nextension UIMutableTraits {\n    var myTrait: String {\n        get { self[MyTrait.self] }\n        set { self[MyTrait.self] = newValue }\n    }\n}\n\n\nYou can declare an environment key to represent the same data:\n\nstruct MyEnvironmentKey: EnvironmentKey {\n    static let defaultValue = \"Default value\"\n}\n\n\nBridge the environment key and the trait by conforming to the UITraitBridgedEnvironmentKey protocol, providing implementations of read(from:) and write(to:value:) to losslessly convert the environment value from and to the corresponding trait value:\n\nextension MyEnvironmentKey: UITraitBridgedEnvironmentKey {\n    static func read(\n        from traitCollection: UITraitCollection\n    ) -> String {\n        traitCollection.myTrait\n    }\n\n\n    static func write(\n        to mutableTraits: inout UIMutableTraits, value: String\n    ) {\n        mutableTraits.myTrait = value\n    }\n}\n\nTopics\nManaging the keys\nstatic func read(from: UITraitCollection) -> Self.Value\nReads the trait value from the trait collection, and returns the equivalent environment value.\n\nRequired\n\nstatic func write(to: inout UIMutableTraits, value: Self.Value)\n\nRequired\n\nRelationships\nInherits From\nEnvironmentKey"
    },
    {
        "title": "custom(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/immersiveambientbrightness/custom(_:)",
        "html": "Parameters\nvalue\n\nThe value of the brightness, between 0 and 1."
    },
    {
        "title": "accessibilityValue(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityvalue(_:)-8esl7",
        "html": "Discussion\n\nUse this method to describe the value represented by a view, but only if that\u2019s different than the view\u2019s label. For example, for a slider that you label as \u201cVolume\u201d using accessibilityLabel(), you can provide the current volume setting, like \u201c60%\u201d, using accessibilityValue().\n\nSee Also\nDescribing values\nfunc accessibilityValue<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nfunc accessibilityValue(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains."
    },
    {
        "title": "accessibilityValue(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityvalue(_:)-z9mo",
        "html": "Discussion\n\nUse this method to describe the value represented by a view, but only if that\u2019s different than the view\u2019s label. For example, for a slider that you label as \u201cVolume\u201d using accessibilityLabel(), you can provide the current volume setting, like \u201c60%\u201d, using accessibilityValue().\n\nSee Also\nDescribing values\nfunc accessibilityValue<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nfunc accessibilityValue(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains."
    },
    {
        "title": "accessibilityHeading(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityheading(_:)",
        "html": "Parameters\nlevel\n\nThe heading level to associate with this element from the available AccessibilityHeadingLevel levels.\n\nDiscussion\n\nUse this modifier to set the level of this heading in relation to other headings. The system speaks the level number of levels AccessibilityHeadingLevel.h1 through AccessibilityHeadingLevel.h6 alongside the text.\n\nThe default heading level if you don\u2019t use this modifier is AccessibilityHeadingLevel.unspecified.\n\nSee Also\nDescribing content\nfunc accessibilityTextContentType(AccessibilityTextContentType) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets an accessibility text content type.\nenum AccessibilityHeadingLevel\nThe hierarchy of a heading in relation other headings.\nstruct AccessibilityTextContentType\nTextual context that assistive technologies can use to improve the presentation of spoken text."
    },
    {
        "title": "accessibilityCustomContent(_:_:importance:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)-90n8p",
        "html": "Parameters\nlabel\n\nLocalized text describing to the user what is contained in this additional information entry. For example: \u201corientation\u201d.\n\nvalue\n\nText value for the additional accessibility information. For example: \u201clandscape.\u201d\n\nimportance\n\nImportance of the accessibility information. High-importance information gets read out immediately, while default-importance information must be explicitly asked for by the user.\n\nDiscussion\n\nUse this method to add information you want accessibility users to be able to access about this element, beyond the basics of label, value, and hint. For example: accessibilityCustomContent can be used to add information about the orientation of a photograph, or the number of people found in the picture.\n\nNote\n\nRepeated calls of accessibilityCustomContent with different labels will create new entries of additional information. Calling accessibilityAdditionalContent repeatedly with the same label will instead replace the previous value and importance.\n\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information."
    },
    {
        "title": "AccessibilityHeadingLevel",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityheadinglevel",
        "html": "Overview\n\nAssistive technologies can use this to improve a users navigation through multiple headings. When users navigate through top level headings they expect the content for each heading to be unrelated.\n\nFor example, you can categorize a list of available products into sections, like Fruits and Vegetables. With only top level headings, this list requires no heading hierarchy, and you use the AccessibilityHeadingLevel.unspecified heading level. On the other hand, if sections contain subsections, like if the Fruits section has subsections for varieties of Apples, Pears, and so on, you apply the AccessibilityHeadingLevel.h1 level to Fruits and Vegetables, and the AccessibilityHeadingLevel.h2 level to Apples and Pears.\n\nExcept for AccessibilityHeadingLevel.h1, be sure to precede all leveled headings by another heading with a level that\u2019s one less.\n\nTopics\nGetting the heading level\ncase h1\nLevel 1 heading.\ncase h2\nLevel 2 heading.\ncase h3\nLevel 3 heading.\ncase h4\nLevel 4 heading.\ncase h5\nLevel 5 heading.\ncase h6\nLevel 6 heading.\ncase unspecified\nA heading without a hierarchy.\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nDescribing content\nfunc accessibilityTextContentType(AccessibilityTextContentType) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets an accessibility text content type.\nfunc accessibilityHeading(AccessibilityHeadingLevel) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the accessibility level of this heading.\nstruct AccessibilityTextContentType\nTextual context that assistive technologies can use to improve the presentation of spoken text."
    },
    {
        "title": "AccessibilityTextContentType",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitytextcontenttype",
        "html": "Overview\n\nUse an AccessibilityTextContentType value when setting the accessibility text content type of a view using the accessibilityTextContentType(_:) modifier.\n\nTopics\nGetting content types\nstatic let console: AccessibilityTextContentType\nA type that represents text used for input, like in the Terminal app.\nstatic let fileSystem: AccessibilityTextContentType\nA type that represents text used by a file browser, like in the Finder app in macOS.\nstatic let messaging: AccessibilityTextContentType\nA type that represents text used in a message, like in the Messages app.\nstatic let narrative: AccessibilityTextContentType\nA type that represents text used in a story or poem, like in the Books app.\nstatic let plain: AccessibilityTextContentType\nA type that represents generic text that has no specific type.\nstatic let sourceCode: AccessibilityTextContentType\nA type that represents text used in source code, like in Swift Playgrounds.\nstatic let spreadsheet: AccessibilityTextContentType\nA type that represents text used in a grid of data, like in the Numbers app.\nstatic let wordProcessing: AccessibilityTextContentType\nA type that represents text used in a document, like in the Pages app.\nRelationships\nConforms To\nSendable\nSee Also\nDescribing content\nfunc accessibilityTextContentType(AccessibilityTextContentType) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets an accessibility text content type.\nfunc accessibilityHeading(AccessibilityHeadingLevel) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the accessibility level of this heading.\nenum AccessibilityHeadingLevel\nThe hierarchy of a heading in relation other headings."
    },
    {
        "title": "onInAppPurchaseStart(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/oninapppurchasestart(perform:)",
        "html": "Parameters\naction\n\nThe action to perform, with the product to be purchased provided as a parameter.\n\nDiscussion\n\nYou can remove any actions ancestor views may have added by providing nil for the action.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "accessibilityCustomContent(_:_:importance:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)-8uva9",
        "html": "Parameters\nlabelKey\n\nLocalized text describing to the user what is contained in this additional information entry. For example: \u201corientation\u201d.\n\nvalue\n\nText value for the additional accessibility information. For example: \u201clandscape.\u201d\n\nimportance\n\nImportance of the accessibility information. High-importance information gets read out immediately, while default-importance information must be explicitly asked for by the user.\n\nDiscussion\n\nUse this method to add information you want accessibility users to be able to access about this element, beyond the basics of label, value, and hint. For example, accessibilityCustomContent can be used to add information about the orientation of a photograph, or the number of people found in the picture.\n\nNote\n\nRepeated calls of accessibilityCustomContent with different labels will create new entries of additional information. Calling accessibilityAdditionalContent repeatedly with the same label will instead replace the previous value and importance.\n\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information."
    },
    {
        "title": "AXChartDescriptorRepresentable",
        "url": "https://developer.apple.com/documentation/swiftui/axchartdescriptorrepresentable",
        "html": "Overview\n\nNote that you may use the @Environment property wrapper inside the implementation of your AXChartDescriptorRepresentable, in which case you should implement updateChartDescriptor, which will be called when the Environment changes.\n\nFor example, to provide accessibility for a view that represents a chart, you would first declare your chart descriptor representable type:\n\nstruct MyChartDescriptorRepresentable: AXChartDescriptorRepresentable {\n    func makeChartDescriptor() -> AXChartDescriptor {\n        // Build and return your `AXChartDescriptor` here.\n    }\n\n\n    func updateChartDescriptor(_ descriptor: AXChartDescriptor) {\n        // Update your chart descriptor with any new values.\n    }\n}\n\n\nThen, provide an instance of your AXChartDescriptorRepresentable type to your view using the accessibilityChartDescriptor modifier:\n\nvar body: some View {\n    MyChartView()\n        .accessibilityChartDescriptor(MyChartDescriptorRepresentable())\n}\n\nTopics\nManaging a descriptor\nfunc makeChartDescriptor() -> AXChartDescriptor\nCreate the AXChartDescriptor for this view, and return it.\n\nRequired\n\nfunc updateChartDescriptor(AXChartDescriptor)\nUpdate the existing AXChartDescriptor for your view, based on changes in your view or in the Environment.\n\nRequired Default implementation provided.\n\nSee Also\nDescribing charts\nfunc accessibilityChartDescriptor<R>(R) -> some View\nAdds a descriptor to a View that represents a chart to make the chart\u2019s contents accessible to all users."
    },
    {
        "title": "onInAppPurchaseCompletion(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/oninapppurchasecompletion(perform:)",
        "html": "Parameters\naction\n\nThe action to perform, with the product value and the purchase result provided as parameters.\n\nDiscussion\n\nBy default, transactions from successful in-app store view purchases will be emitted from Transaction.updates. If the purchase fails with an error, an alert will be displayed. You can revert a view back to this behavior by providing nil for action.\n\nOnly one action will be performed for each purchase. Descendant views can override the action by using another onInAppPurchaseCompletion(perform:) modifier.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "refundRequestSheet(for:isPresented:onDismiss:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/refundrequestsheet(for:ispresented:ondismiss:)",
        "html": "Parameters\ntransactionID\n\nThe transaction ID to request a refund for.\n\nisPresented\n\nA binding to a Boolean value that determines whether the refund request sheet is presented.\n\nonDismiss\n\nThe closure to execute when dismissing the sheet, with the result of the refund request provided as a parameter.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "accessibilityCustomContent(_:_:importance:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)-9s1t",
        "html": "Parameters\nlabelKey\n\nLocalized text describing to the user what is contained in this additional information entry. For example: \u201corientation\u201d.\n\nvalue\n\nText value for the additional accessibility information. For example: \u201clandscape.\u201d\n\nimportance\n\nImportance of the accessibility information. High-importance information gets read out immediately, while default-importance information must be explicitly asked for by the user.\n\nDiscussion\n\nUse this method to add information you want accessibility users to be able to access about this element, beyond the basics of label, value, and hint. For example, accessibilityCustomContent can be used to add information about the orientation of a photograph, or the number of people found in the picture.\n\nNote\n\nRepeated calls of accessibilityCustomContent with different labels will create new entries of additional information. Calling accessibilityAdditionalContent repeatedly with the same label will instead replace the previous value and importance.\n\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information."
    },
    {
        "title": "currentEntitlementTask(for:priority:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/currententitlementtask(for:priority:action:)",
        "html": "Parameters\nproductID\n\nThe product ID to get the entitlement for. The task restarts whenever this parameter changes.\n\npriority\n\nThe task priority to use when creating the task.\n\naction\n\nThe action to perform when the task\u2019s state changes.\n\nDiscussion\n\nBefore a view modified with this method appears, a task will start in the background to get the current entitlement. While the view is presented, the task will call action whenever the entitlement changes or the task\u2019s state changes.\n\nConsumable in-app purchases will always pass nil to action. For auto-renewable subscriptions, use subscriptionStatusTask(for:priority:action:) to get the full status information for the subscription.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "accessibilityChartDescriptor(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitychartdescriptor(_:)",
        "html": "Parameters\nchartDescriptor\n\nThe AXChartDescriptorRepresentable used to describe your chart and its data.\n\nDiscussion\n\nUse this method to provide information about your chart view to allow VoiceOver and other assistive technology users to perceive and interact with your chart and its data.\n\nThis may be applied to any View that represents a chart, including Image and custom-rendered chart views.\n\nThe accessibilityChartDescriptor modifier can be applied to -any- view representing a chart, the simplest case being just an image of a chart. The implementation details of the view aren\u2019t important, only the fact that it represents a chart, and that the provided chart descriptor accurately describes the content of the chart.\n\nExample usage:\n\nFirst define your AXChartDescriptorRepresentable type.\n\nstruct MyChartDescriptorRepresentable:\nAXChartDescriptorRepresentable {\n    func makeChartDescriptor() -> AXChartDescriptor {\n        // Build and return your `AXChartDescriptor` here.\n    }\n\n\n    func updateChartDescriptor(_ descriptor: AXChartDescriptor) {\n        // Update your chart descriptor with any new values, or\n        // don't override if your chart doesn't have changing\n        // values.\n    }\n}\n\n\nThen use the accessibilityChartDescriptor modifier to provide an instance of your AXChartDescriptorRepresentable type to the view representing your chart:\n\nSomeChartView()\n    .accessibilityChartDescriptor(MyChartDescriptorRepresentable())\n\nSee Also\nDescribing charts\nprotocol AXChartDescriptorRepresentable\nA type to generate an AXChartDescriptor object that you use to provide information about a chart and its data for an accessible experience in VoiceOver or other assistive technologies."
    },
    {
        "title": "musicSubscriptionOffer(isPresented:options:onLoadCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/musicsubscriptionoffer(ispresented:options:onloadcompletion:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that you can set to true to show a sheet with subscription offers for Apple Music.\n\noptions\n\nOptions to use for loading the subscription offer for Apple Music.\n\nonLoadCompletion\n\nThe function to call upon completing the initial loading process for this subscription offer. The subscription offer UI becomes visible when it calls this function with the error argument as nil. If there is an error in the loading process, the subscription offer calls this function with a non-nil error, and it resets the isPresented binding to false.\n\nDiscussion\n\nThe example below displays a simple button that the user can activate to begin presenting subscription offers for Apple Music. The action handler of this button initiates the presentation of those offers by setting the isShowingOffer variable to true.\n\nstruct MusicSubscriptionOfferButton: View {\n    @State var isShowingOffer = false\n    var body: some View {\n        Button(\"Apple Music Subscription Offer\") {\n            isShowingOffer = true\n        }\n        .musicSubscriptionOffer(isPresented: $isShowingOffer)\n    }\n}\n\n\nYou can also configure the Apple Music subscription offer by creating an instance of MusicSubscriptionOffer.Options, setting relevant properties on it, and passing it to .musicSubscriptionOffer(\u2026). For example, to present contextual offers that highlight a specific album, you can configure the subscription offer like the following:\n\nstruct MusicSubscriptionOfferButton: View {\n    var album: Album\n    @State var isShowingOffer = false\n    @State var offerOptions = MusicSubscriptionOffer.Options(\n        affiliateToken: \"<affiliate_token>\", \n        campaignToken: \"<campaign_token>\"\n    )\n\n\n    var body: some View {\n        Button(\"Apple Music Subscription Offer\") {\n            offerOptions.itemID = album.id\n            isShowingOffer = true\n        }\n        .musicSubscriptionOffer(\n            isPresented: $isShowingOffer, \n            options: offerOptions\n        )\n    }\n}\n\n\nThe initial value of offerOptions includes relevant tokens (affiliate and campaign tokens) that allow you to receive compensation for referring new Apple Music subscribers. For more information, see this presentation of the Apple Services Performance Partners Program.\n\nYou may also set isShowingOffer to false to programmatically dismiss the subscription offer (or to abort its loading process).\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "accessibilityCustomContent(_:_:importance:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)-2km9f",
        "html": "Parameters\nkey\n\nKey used to specify the identifier and label of the of the additional accessibility information entry.\n\nvalueKey\n\nText value for the additional accessibility information. For example: \u201clandscape.\u201d A value of nil will remove any entry of additional information added earlier for any key with the same identifier.\n\nimportance\n\nImportance of the accessibility information. High-importance information gets read out immediately, while default-importance information must be explicitly asked for by the user.\n\nDiscussion\n\nUse this method to add information you want accessibility users to be able to access about this element, beyond the basics of label, value, and hint. For example, accessibilityCustomContent can be used to add information about the orientation of a photograph, or the number of people found in the picture.\n\nNote\n\nRepeated calls of accessibilityCustomContent with keys having different identifiers will create new entries of additional information. Calling accessibilityAdditionalContent repeatedly with keys having matching identifiers will replace the previous entry.\n\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information."
    },
    {
        "title": "appStoreOverlay(isPresented:configuration:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/appstoreoverlay(ispresented:configuration:)",
        "html": "Parameters\nisPresented\n\nA Binding to a boolean value indicating whether the overlay should be presented.\n\nconfiguration\n\nA closure providing the configuration of the overlay.\n\nDiscussion\n\nYou use appStoreOverlay to display an overlay that recommends another app. The overlay enables users to instantly view the other app\u2019s page on the App Store.\n\nWhen isPresented is true, the system will run configuration to determine how to configure the overlay. The overlay will automatically be presented over the current scene.\n\nSee Also\n\nSKOverlay.Configuration.\n\nSee Also\nInteracting with the App Store and Apple Music\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view."
    },
    {
        "title": "accessibilityCustomContent(_:_:importance:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)-hcgc",
        "html": "Parameters\nkey\n\nKey used to specify the identifier and label of the of the additional accessibility information entry.\n\nvalue\n\nText value for the additional accessibility information. For example: \u201clandscape.\u201d A value of nil will remove any entry of additional information added earlier for any key with the same identifier.\n\nimportance\n\nImportance of the accessibility information. High-importance information gets read out immediately, while default-importance information must be explicitly asked for by the user.\n\nDiscussion\n\nUse this method to add information you want accessibility users to be able to access about this element, beyond the basics of label, value, and hint. For example, accessibilityCustomContent can be used to add information about the orientation of a photograph, or the number of people found in the picture.\n\nNote\n\nRepeated calls of accessibilityCustomContent with keys having different identifiers will create new entries of additional information. Calling accessibilityAdditionalContent repeatedly with keys having matching identifiers will replace the previous entry.\n\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information."
    },
    {
        "title": "accessibilityCustomContent(_:_:importance:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)-4r2qu",
        "html": "Parameters\nkey\n\nKey used to specify the identifier and label of the of the additional accessibility information entry.\n\nvalue\n\nText value for the additional accessibility information. For example: \u201clandscape.\u201d A value of nil will remove any entry of additional information added earlier for any key with the same identifier.\n\nDiscussion\n\nUse this method to add information you want accessibility users to be able to access about this element, beyond the basics of label, value, and hint. For example, accessibilityCustomContent can be used to add information about the orientation of a photograph, or the number of people found in the picture.\n\nNote\n\nRepeated calls of accessibilityCustomContent with keys having different identifiers will create new entries of additional information. Calling accessibilityAdditionalContent repeatedly with keys having matching identifiers will replace the previous entry.\n\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information."
    },
    {
        "title": "AccessibilityCustomContentKey",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitycustomcontentkey",
        "html": "Overview\n\nUse AccessibilityCustomContentKey and the associated modifiers taking this value as a parameter in order to simplify clearing or replacing entries of additional information that are manipulated from multiple places in your code.\n\nTopics\nCreating a key\ninit(LocalizedStringKey)\nCreate an AccessibilityCustomContentKey with the specified label.\ninit(Text, id: String)\nCreate an AccessibilityCustomContentKey with the specified label and identifier.\ninit(LocalizedStringKey, id: String)\nCreate an AccessibilityCustomContentKey with the specified label and identifier.\nRelationships\nConforms To\nEquatable\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view."
    },
    {
        "title": "accessibilityCustomContent(_:_:importance:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)-59tdk",
        "html": "Parameters\nlabel\n\nLocalized text describing to the user what is contained in this additional information entry. For example: \u201corientation\u201d.\n\nvalue\n\nText value for the additional accessibility information. For example: \u201clandscape.\u201d\n\nimportance\n\nImportance of the accessibility information. High-importance information gets read out immediately, while default-importance information must be explicitly asked for by the user.\n\nDiscussion\n\nUse this method to add information you want accessibility users to be able to access about this element, beyond the basics of label, value, and hint. For example: accessibilityCustomContent can be used to add information about the orientation of a photograph, or the number of people found in the picture.\n\nNote\n\nRepeated calls of accessibilityCustomContent with different labels will create new entries of additional information. Calling accessibilityAdditionalContent repeatedly with the same label will instead replace the previous value and importance.\n\nSee Also\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information."
    },
    {
        "title": "accessibilityRemoveTraits(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityremovetraits(_:)",
        "html": "See Also\nAssigning traits to content\nfunc accessibilityAddTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds the given traits to the view.\nstruct AccessibilityTraits\nA set of accessibility traits that describe how an element behaves."
    },
    {
        "title": "accessibilityAddTraits(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityaddtraits(_:)",
        "html": "See Also\nAssigning traits to content\nfunc accessibilityRemoveTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nRemoves the given traits from this view.\nstruct AccessibilityTraits\nA set of accessibility traits that describe how an element behaves."
    },
    {
        "title": "isActivityFullscreen",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/isactivityfullscreen",
        "html": "Discussion\n\nWhen a Live Activity fills the entire screen, the system extends the background tint color you set with the activityBackgroundTint(_:) modifier to fill the screen.\n\nNote that this environment variable is always false in iOS 16.\n\nSee Also\nConfiguring a Live Activity\nfunc activitySystemActionForegroundColor(Color?) -> some View\nThe text color for the auxiliary action button that the system shows next to a Live Activity on the Lock Screen.\nfunc activityBackgroundTint(Color?) -> some View\nSets the tint color for the background of a Live Activity that appears on the Lock Screen."
    },
    {
        "title": "activitySystemActionForegroundColor(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/activitysystemactionforegroundcolor(_:)",
        "html": "Parameters\ncolor\n\nThe text color to use. Pass nil to use the system\u2019s default color.\n\nSee Also\nConfiguring a Live Activity\nfunc activityBackgroundTint(Color?) -> some View\nSets the tint color for the background of a Live Activity that appears on the Lock Screen.\nvar isActivityFullscreen: Bool\nA Boolean value that indicates whether the Live Activity appears in a full-screen presentation."
    },
    {
        "title": "quickLookPreview(_:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/quicklookpreview(_:in:)",
        "html": "Parameters\nselection\n\nA Binding to an element that\u2019s part of the items collection. This is the URL that you currently want to preview.\n\nitems\n\nA collection of URLs to preview.\n\nReturn Value\n\nA view that presents the preview of the contents of the URL.\n\nDiscussion\n\nThe Quick Look preview appears when you set the binding to a non-nil item. When you set the item back to nil, Quick Look dismisses the preview. If the value of the selection binding isn\u2019t contained in the items collection, Quick Look treats it the same as a nil selection.\n\nQuick Look updates the value of the selection binding to match the URL of the file the user is previewing. Upon dismissal by the user, Quick Look automatically sets the item binding to nil.\n\nSee Also\nPreviewing content\nfunc quickLookPreview(Binding<URL?>) -> some View\nPresents a Quick Look preview of the contents of a single URL."
    },
    {
        "title": "quickLookPreview(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/quicklookpreview(_:)",
        "html": "Parameters\nitem\n\nA Binding to a URL that should be previewed.\n\nReturn Value\n\nA view that presents the preview of the contents of the URL.\n\nDiscussion\n\nThe Quick Look preview appears when you set the binding to a non-nil item. When you set the item back to nil, Quick Look dismisses the preview.\n\nUpon dismissal by the user, Quick Look automatically sets the item binding to nil. Quick Look displays the preview when a non-nil item is set. Set item to nil to dismiss the preview.\n\nSee Also\nPreviewing content\nfunc quickLookPreview<Items>(Binding<Items.Element?>, in: Items) -> some View\nPresents a Quick Look preview of the URLs you provide."
    },
    {
        "title": "authorizationController",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/authorizationcontroller",
        "html": "Discussion\n\nFor example, you can perform authorization requests when the user taps a button:\n\nstruct AuthorizationControllerExample: View {\n    @Environment(\\.authorizationController) private var authorizationController\n\n\n    var body: some View {\n        Button(\"Sign In\") {\n            Task {\n                do {\n                    async let requests = authorizationRequests() // defined elsewhere\n                    let result = try await authorizationController\n                        .performRequests(requests)\n\n\n                    switch result {\n                    // code to handle the authorization result\n                    }\n                } catch {\n                    // code to handle the authorization error\n                }\n            }\n        }\n    }\n}\n\nSee Also\nAuthorizing and authenticating\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style).\nvar webAuthenticationSession: WebAuthenticationSession\nA value provided in the SwiftUI environment that views can use to authenticate a user through a web service."
    },
    {
        "title": "webAuthenticationSession",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/webauthenticationsession",
        "html": "Discussion\n\nFor example, you can start a web authentication session when the user taps a button:\n\nstruct WebAuthenticationSessionExample: View {\n    @Environment(\\.webAuthenticationSession) private var webAuthenticationSession\n\n\n    var body: some View {\n        Button(\"Sign In\") {\n            Task {\n                do {\n                    let urlWithToken = try await webAuthenticationSession.authenticate(\n                        using: URL(string: \"https://www.example.com\")!,\n                        callbackURLScheme: \"x-example-app\")\n                    try await signIn(using: urlWithToken) // defined elsewhere\n                } catch {\n                    // code to handle authentication errors\n                }\n            }\n        }\n    }\n}\n\n\nUse WebAuthenticationSession/BrowserSession/ephemeral to request that the browser doesn\u2019t share cookies or other browsing data between the authentication session and the user\u2019s normal browser session. Whether the request is honored depends on the user\u2019s default web browser. Safari always honors the request.\n\nlet urlWithToken = try await webAuthenticationSession.authenticate(\n    using: URL(string: \"https://www.example.com\")!,\n    callbackURLScheme: \"x-example-app\",\n    preferredBrowserSession: .ephemeral)\n\n\nAfter the user authenticates, the authentication provider redirects the browser to a URL that uses the callback scheme. The browser detects the redirect, dismisses itself, and the complete URL will be returned. Inspect the URL to determine the outcome of the authentication:\n\nlet queryItems = URLComponents(string: urlWithToken.absoluteString)?.queryItems\nlet token = queryItems?.first(where: { $0.name == \"token\" })?.value\n\n\nThe above example looks for a token stored as a query parameter. The specific parsing that you have to do depends on how the authentication provider structures the callback URL.\n\nSee Also\nAuthorizing and authenticating\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style).\nvar authorizationController: AuthorizationController\nA value provided in the SwiftUI environment that views can use to perform authorization requests."
    },
    {
        "title": "familyActivityPicker(isPresented:selection:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/familyactivitypicker(ispresented:selection:)",
        "html": "Parameters\nisPresented\n\nA binding that indicates whether the app presents the picker view.\n\nselection\n\nA binding that manages the user-selected categories, apps, and web domains.\n\nDiscussion\n\nUse this view modifier to present a FamilyControls/FamilyActivityPicker.\n\nstruct ExampleView: View {\n    @State var selection = FamilyActivitySelection()\n    @State var isPresented = false\n\n\n   var body: some View {\n       Button(\"Present FamilyActivityPicker\") { isPresented = true }\n       .familyActivityPicker(isPresented: $isPresented,\n                             selection: $selection)\n       .onChange(of: selection) { newSelection in\n           let applications = selection.applications\n           let categories = selection.categories\n           let webDomains = selection.webDomains\n       }\n   }\n}\n\nSee Also\nConfiguring Family Sharing\nfunc familyActivityPicker(headerText: String?, footerText: String?, isPresented: Binding<Bool>, selection: Binding<FamilyActivitySelection>) -> some View\nPresents an activity picker view as a sheet."
    },
    {
        "title": "photosPicker(isPresented:selection:matching:preferredItemEncoding:photoLibrary:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:matching:preferreditemencoding:photolibrary:)",
        "html": "Parameters\nisPresented\n\nThe binding to whether the Photos picker should be shown.\n\nselection\n\nThe item being shown and selected in the Photos picker.\n\nfilter\n\nTypes of items that can be shown. Default is nil. Setting it to nil means all supported types can be shown.\n\npreferredItemEncoding\n\nThe encoding disambiguation policy of the selected item. Default is .automatic. Setting it to .automatic means the best encoding determined by the system will be used.\n\nphotoLibrary\n\nThe photo library to choose from.\n\nDiscussion\n\nThe user explicitly grants access only to items they choose, so photo library access authorization is not needed.\n\nSee Also\nSelecting photos\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker."
    },
    {
        "title": "photosPicker(isPresented:selection:matching:preferredItemEncoding:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:matching:preferreditemencoding:)",
        "html": "Parameters\nisPresented\n\nThe binding to whether the Photos picker should be shown.\n\nselection\n\nThe item being shown and selected in the Photos picker.\n\nfilter\n\nTypes of items that can be shown. Default is nil. Setting it to nil means all supported types can be shown.\n\npreferredItemEncoding\n\nThe encoding disambiguation policy of the selected item. Default is .automatic. Setting it to .automatic means the best encoding determined by the system will be used.\n\nDiscussion\n\nThe user explicitly grants access only to items they choose, so photo library access authorization is not needed.\n\nSee Also\nSelecting photos\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker."
    },
    {
        "title": "AccessibilityActionKind",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityactionkind",
        "html": "Topics\nGetting the kind of action\nstatic let `default`: AccessibilityActionKind\nThe value that represents the default accessibility action.\nstatic let delete: AccessibilityActionKind\nstatic let escape: AccessibilityActionKind\nThe value that represents an accessibility action that dismisses a modal view or cancels an operation.\nstatic let magicTap: AccessibilityActionKind\nstatic let showMenu: AccessibilityActionKind\nCreating an action type\ninit(named: Text)\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "AccessibilityAdjustmentDirection",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityadjustmentdirection",
        "html": "Topics\nGetting an adjustment direction\ncase decrement\ncase increment\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions."
    },
    {
        "title": "NSHostingView",
        "url": "https://developer.apple.com/documentation/swiftui/nshostingview",
        "html": "Overview\n\nYou use NSHostingView objects to integrate SwiftUI views into your AppKit view hierarchies. A hosting view is an NSView object that manages a single SwiftUI view, which may itself contain other SwiftUI views. Because it is an NSView object, you can integrate it into your existing AppKit view hierarchies to implement portions of your UI. For example, you can use a hosting view to implement a custom control.\n\nA hosting view acts as a bridge between your SwiftUI views and your AppKit interface. During layout, the hosting view reports the content size preferences of your SwiftUI views back to the AppKit layout system so that it can size the view appropriately. The hosting view also coordinates event delivery.\n\nTopics\nCreating a hosting view\ninit(rootView: Content)\nCreates a hosting view object that wraps the specified SwiftUI view.\ninit?(coder: NSCoder)\nCreates a hosting view object from the contents of the specified archive.\nfunc prepareForReuse()\nGetting the root view\nvar rootView: Content\nThe root view of the SwiftUI view hierarchy managed by this view controller.\nConfiguring the view layout behavior\nclass var requiresConstraintBasedLayout: Bool\nvar userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection\nvar isFlipped: Bool\nvar layerContentsRedrawPolicy: NSView.LayerContentsRedrawPolicy\nfunc updateConstraints()\nfunc layout()\nvar safeAreaRegions: SafeAreaRegions\nThe safe area regions that this view controller adds to its view.\nManaging keyboard interaction\nfunc keyDown(with: NSEvent)\nCalled when the user presses a key on the keyboard while this view is in the responder chain.\nfunc keyUp(with: NSEvent)\nCalled when the user releases a key on the keyboard while this view is in the responder chain.\nfunc performKeyEquivalent(with: NSEvent) -> Bool\nfunc insertText(Any)\nfunc didChangeValue(forKey: String)\nfunc makeTouchBar() -> NSTouchBar?\nResponding to mouse events\nfunc mouseDown(with: NSEvent)\nfunc mouseUp(with: NSEvent)\nfunc otherMouseDown(with: NSEvent)\nfunc otherMouseUp(with: NSEvent)\nfunc rightMouseDown(with: NSEvent)\nfunc rightMouseUp(with: NSEvent)\nfunc mouseEntered(with: NSEvent)\nfunc mouseExited(with: NSEvent)\nfunc mouseDragged(with: NSEvent)\nfunc mouseMoved(with: NSEvent)\nfunc otherMouseDragged(with: NSEvent)\nfunc rightMouseDragged(with: NSEvent)\nfunc cursorUpdate(with: NSEvent)\nResponding to touch events\nfunc touchesBegan(with: NSEvent)\nfunc touchesCancelled(with: NSEvent)\nfunc touchesEnded(with: NSEvent)\nfunc touchesMoved(with: NSEvent)\nResponding to gestures\nfunc magnify(with: NSEvent)\nfunc rotate(with: NSEvent)\nfunc scrollWheel(with: NSEvent)\nHandling drag and drop\nfunc validRequestor(forSendType: NSPasteboard.PasteboardType?, returnType: NSPasteboard.PasteboardType?) -> Any?\nProviding a context menu\nfunc menu(for: NSEvent) -> NSMenu?\nResponding to actions\nfunc responds(to: Selector!) -> Bool\nfunc forwardingTarget(for: Selector!) -> Any?\nfunc doCommand(by: Selector)\nConfiguring the responder behavior\nvar acceptsFirstResponder: Bool\nvar needsPanelToBecomeKey: Bool\nManaging the view hierarchy\nfunc viewWillMove(toWindow: NSWindow?)\nfunc viewDidMoveToWindow()\nfunc viewDidChangeBackingProperties()\nfunc viewDidChangeEffectiveAppearance()\nfunc renewGState()\nModifying the frame rectangle\nvar intrinsicContentSize: NSSize\nfunc setFrameSize(NSSize)\nvar firstBaselineOffsetFromTop: CGFloat\nvar lastBaselineOffsetFromBottom: CGFloat\nvar sizingOptions: NSHostingSizingOptions\nThe options for how the hosting view creates and updates constraints based on the size of its SwiftUI content.\nvar firstTextLineCenter: CGFloat?\nTesting for hits\nfunc hitTest(NSPoint) -> NSView?\nManaging accessibility behaviors\nvar accessibilityFocusedUIElement: Any?\nfunc accessibilityChildren() -> [Any]?\nfunc accessibilityChildrenInNavigationOrder() -> [NSAccessibilityElementProtocol]?\nfunc accessibilityHitTest(NSPoint) -> Any?\nfunc accessibilityRole() -> NSAccessibility.Role?\nfunc accessibilitySubrole() -> NSAccessibility.Subrole?\nfunc isAccessibilityElement() -> Bool\nBridging with SwiftUI\nvar sceneBridgingOptions: NSHostingSceneBridgingOptions\nThe options for which aspects of the window will be managed by this hosting view.\nRelationships\nInherits From\nNSView\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSAccessibilityElementProtocol\nNSAccessibilityProtocol\nNSAnimatablePropertyContainer\nNSAppearanceCustomization\nNSCoding\nNSDraggingDestination\nNSDraggingSource\nNSObjectProtocol\nNSStandardKeyBindingResponding\nNSTouchBarProvider\nNSUserActivityRestoring\nNSUserInterfaceItemIdentification\nNSUserInterfaceValidations\nSee Also\nDisplaying SwiftUI views in AppKit\nclass NSHostingController\nAn AppKit view controller that hosts SwiftUI view hierarchy.\nstruct NSHostingSizingOptions\nOptions for how hosting views and controllers reflect their content\u2019s size into Auto Layout constraints.\nstruct NSHostingSceneBridgingOptions\nOptions for how hosting views and controllers manage aspects of the associated window."
    },
    {
        "title": "NSHostingController",
        "url": "https://developer.apple.com/documentation/swiftui/nshostingcontroller",
        "html": "Overview\n\nCreate an NSHostingController object when you want to integrate SwiftUI views into an AppKit view hierarchy. At creation time, specify the SwiftUI view you want to use as the root view for this view controller; you can change that view later using the rootView property. Use the hosting controller like you would any other view controller, by presenting it or embedding it as a child view controller in your interface.\n\nTopics\nCreating a hosting controller object\ninit(rootView: Content)\nCreates a hosting controller object that wraps the specified SwiftUI view.\ninit?(coder: NSCoder, rootView: Content)\nCreates a hosting controller object from an archive and the specified SwiftUI view.\ninit?(coder: NSCoder)\nCreates a hosting controller object from the contents of the specified archive.\nGetting the root view\nvar rootView: Content\nThe root view of the SwiftUI view hierarchy managed by this view controller.\nvar identifier: NSUserInterfaceItemIdentifier?\nConfiguring the controller\nfunc sizeThatFits(in: CGSize) -> CGSize\nCalculates and returns the most appropriate size for the current view.\nvar preferredContentSize: NSSize\nvar sizingOptions: NSHostingSizingOptions\nThe options for how the hosting controller\u2019s view creates and updates constraints based on the size of its SwiftUI content.\nvar safeAreaRegions: SafeAreaRegions\nThe safe area regions that this view controller adds to its view.\nvar sceneBridgingOptions: NSHostingSceneBridgingOptions\nThe options for which aspects of the window will be managed by this controller\u2019s hosting view.\nRelationships\nInherits From\nNSViewController\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSEditor\nNSExtensionRequestHandling\nNSObjectProtocol\nNSSeguePerforming\nNSStandardKeyBindingResponding\nNSTouchBarProvider\nNSUserActivityRestoring\nNSUserInterfaceItemIdentification\nSee Also\nDisplaying SwiftUI views in AppKit\nclass NSHostingView\nAn AppKit view that hosts a SwiftUI view hierarchy.\nstruct NSHostingSizingOptions\nOptions for how hosting views and controllers reflect their content\u2019s size into Auto Layout constraints.\nstruct NSHostingSceneBridgingOptions\nOptions for how hosting views and controllers manage aspects of the associated window."
    },
    {
        "title": "onOpenURL(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onopenurl(perform:)",
        "html": "Parameters\naction\n\nA function that takes a URL object as its parameter when delivering the URL to the scene or window the view is in.\n\nDiscussion\n\nNote\n\nThis method handles the reception of Universal Links, rather than a NSUserActivity.\n\nSee Also\nHandling URLs\nvar openURL: OpenURLAction\nAn action that opens a URL.\nstruct OpenURLAction\nAn action that opens a URL."
    },
    {
        "title": "accessibilityHint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityhint(_:)-3i2vu",
        "html": "Discussion\n\nProvide a hint in the form of a brief phrase, like \u201cPurchases the item\u201d or \u201cDownloads the attachment\u201d.\n\nSee Also\nOffering hints\nfunc accessibilityHint(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nfunc accessibilityHint<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action."
    },
    {
        "title": "accessibilityAction(named:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityaction(named:_:)-9ra29",
        "html": "Discussion\n\nFor example, this is how a custom action to compose a new email could be added to a view.\n\nvar body: some View {\n    ContentView()\n        .accessibilityAction(named: \"New Message\") {\n            // Handle action\n        }\n}\n\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "AccessibilityTraits",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitytraits",
        "html": "Topics\nGetting traits\nstatic let allowsDirectInteraction: AccessibilityTraits\nThe accessibility element allows direct touch interaction for VoiceOver users.\nstatic let causesPageTurn: AccessibilityTraits\nThe accessibility element causes an automatic page turn when VoiceOver finishes reading the text within it.\nstatic let isButton: AccessibilityTraits\nThe accessibility element is a button.\nstatic let isHeader: AccessibilityTraits\nThe accessibility element is a header that divides content into sections, like the title of a navigation bar.\nstatic let isImage: AccessibilityTraits\nThe accessibility element is an image.\nstatic let isKeyboardKey: AccessibilityTraits\nThe accessibility element behaves as a keyboard key.\nstatic let isLink: AccessibilityTraits\nThe accessibility element is a link.\nstatic let isModal: AccessibilityTraits\nThe accessibility element is modal.\nstatic let isSearchField: AccessibilityTraits\nThe accessibility element is a search field.\nstatic let isSelected: AccessibilityTraits\nThe accessibility element is currently selected.\nstatic let isStaticText: AccessibilityTraits\nThe accessibility element is a static text that cannot be modified by the user.\nstatic let isSummaryElement: AccessibilityTraits\nThe accessibility element provides summary information when the application starts.\nstatic let isToggle: AccessibilityTraits\nThe accessibility element is a toggle.\nstatic let playsSound: AccessibilityTraits\nThe accessibility element plays its own sound when activated.\nstatic let startsMediaSession: AccessibilityTraits\nThe accessibility element starts a media session when it is activated.\nstatic let updatesFrequently: AccessibilityTraits\nThe accessibility element frequently updates its label or value.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nSendable\nSetAlgebra\nSee Also\nAssigning traits to content\nfunc accessibilityAddTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds the given traits to the view.\nfunc accessibilityRemoveTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nRemoves the given traits from this view."
    },
    {
        "title": "accessibilityAction(action:label:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityaction(action:label:)",
        "html": "Discussion\n\nFor example, this is how a custom action to compose a new email could be added to a view.\n\nvar body: some View {\n    ContentView()\n        .accessibilityAction {\n            // Handle action\n        } label: {\n            Label(\"New Message\", systemImage: \"plus\")\n        }\n}\n\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "accessibilityAction(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityaction(_:_:)",
        "html": "Discussion\n\nFor example, this is how a .default action to compose a new email could be added to a view.\n\nvar body: some View {\n    ContentView()\n        .accessibilityAction {\n            // Handle action\n        }\n}\n\nSee Also\nAdding actions to views\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "accessibilityDifferentiateWithoutColor",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilitydifferentiatewithoutcolor",
        "html": "Discussion\n\nIf this is true, UI should not convey information using color alone and instead should use shapes or glyphs to convey information.\n\nSee Also\nManaging color\nfunc accessibilityIgnoresInvertColors(Bool) -> some View\nSets whether this view should ignore the system Smart Invert setting.\nvar accessibilityInvertColors: Bool\nWhether the system preference for Invert Colors is enabled."
    },
    {
        "title": "accessibilityAction(named:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityaction(named:_:)-6t20v",
        "html": "Discussion\n\nFor example, this is how a custom action to compose a new email could be added to a view.\n\nvar body: some View {\n    ContentView()\n        .accessibilityAction(named: Text(\"New Message\")) {\n            // Handle action\n        }\n}\n\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "accessibilityAction(named:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityaction(named:_:)-8ssvg",
        "html": "Discussion\n\nFor example, this is how a custom action to compose a new email could be added to a view.\n\nvar body: some View {\n    ContentView()\n        .accessibilityAction(named: \"New Message\") {\n            // Handle action\n        }\n}\n\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "NSHostingSizingOptions",
        "url": "https://developer.apple.com/documentation/swiftui/nshostingsizingoptions",
        "html": "Topics\nGeting sizing options\nstatic let intrinsicContentSize: NSHostingSizingOptions\nThe hosting view creates and updates constraints that represent its content\u2019s ideal size. These constraints in turn influence the hosting view\u2019s intrinsicContentSize.\nstatic let maxSize: NSHostingSizingOptions\nThe hosting view creates and updates constraints that represent its content\u2019s maximum size.\nstatic let minSize: NSHostingSizingOptions\nThe hosting view creates and updates constraints that represent its content\u2019s minimum size.\nstatic let preferredContentSize: NSHostingSizingOptions\nThe hosting controller creates and updates constraints that represent its content\u2019s ideal size. These constraints in turn influence the hosting controller\u2019s preferredContentSize.\nstatic let standardBounds: NSHostingSizingOptions\nThe hosting view creates constraints for its minimum, ideal, and maximum sizes.\nCreating a sizing option\ninit(rawValue: Int)\nCreates a new options from a raw value.\nlet rawValue: Int\nThe raw value.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nDisplaying SwiftUI views in AppKit\nclass NSHostingController\nAn AppKit view controller that hosts SwiftUI view hierarchy.\nclass NSHostingView\nAn AppKit view that hosts a SwiftUI view hierarchy.\nstruct NSHostingSceneBridgingOptions\nOptions for how hosting views and controllers manage aspects of the associated window."
    },
    {
        "title": "NSViewRepresentableContext",
        "url": "https://developer.apple.com/documentation/swiftui/nsviewrepresentablecontext",
        "html": "Overview\n\nAn NSViewRepresentableContext structure contains details about the current state of the system. When creating and updating your view, the system creates one of these structures and passes it to the appropriate method of your custom NSViewRepresentable instance. Use the information in this structure to configure your view. For example, use the provided environment values to configure the appearance of your view. Don\u2019t create this structure yourself.\n\nTopics\nCoordinating view-related interactions\nlet coordinator: View.Coordinator\nAn instance you use to communicate your AppKit view\u2019s behavior and state out to SwiftUI objects.\nvar transaction: Transaction\nThe current transaction.\nGetting the current environment data\nvar environment: EnvironmentValues\nEnvironment data that describes the current state of the system.\nRelationships\nConforms To\nSendable\nSee Also\nAdding AppKit views to SwiftUI view hierarchies\nprotocol NSViewRepresentable\nA wrapper that you use to integrate an AppKit view into your SwiftUI view hierarchy.\nprotocol NSViewControllerRepresentable\nA wrapper that you use to integrate an AppKit view controller into your SwiftUI interface.\nstruct NSViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view controller."
    },
    {
        "title": "accessibilityShowsLargeContentViewer()",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityshowslargecontentviewer()",
        "html": "Discussion\n\nRely on the large content viewer only in situations where items must remain small due to unavoidable design constraints. For example, buttons in a tab bar remain small to leave more room for the main app content.\n\nThe following example shows how to add a custom large content view:\n\nvar body: some View {\n    Button(\"New Message\", action: newMessage)\n        .accessibilityShowsLargeContentViewer()\n}\n\n\nDon\u2019t use the large content viewer as a replacement for proper Dynamic Type support. For example, Dynamic Type allows items in a list to grow or shrink vertically to accommodate the user\u2019s preferred font size. Rely on the large content viewer only in situations where items must remain small due to unavoidable design constraints.\n\nFor example, views that have their Dynamic Type size constrained with dynamicTypeSize(_:) or dynamicTypeSize(_:) may require a large content view.\n\nSee Also\nEnlarging content\nfunc accessibilityShowsLargeContentViewer<V>(() -> V) -> some View\nAdds a custom large content view to be shown by the large content viewer.\nvar accessibilityLargeContentViewerEnabled: Bool\nWhether the Large Content Viewer is enabled."
    },
    {
        "title": "NSViewControllerRepresentable",
        "url": "https://developer.apple.com/documentation/swiftui/nsviewcontrollerrepresentable",
        "html": "Overview\n\nUse an NSViewControllerRepresentable instance to create and manage an NSViewController object in your SwiftUI interface. Adopt this protocol in one of your app\u2019s custom instances, and use its methods to create, update, and tear down your view controller. The creation and update processes parallel the behavior of SwiftUI views, and you use them to configure your view controller with your app\u2019s current state information. Use the teardown process to remove your view controller cleanly from your SwiftUI. For example, you might use the teardown process to notify other objects that the view controller is disappearing.\n\nTo add your view controller into your SwiftUI interface, create your NSViewControllerRepresentable instance and add it to your SwiftUI interface. The system calls the methods of your custom instance at appropriate times.\n\nThe system doesn\u2019t automatically communicate changes occurring within your view controller to other parts of your SwiftUI interface. When you want your view controller to coordinate with other SwiftUI views, you must provide a Coordinator instance to facilitate those interactions. For example, you use a coordinator to forward target-action and delegate messages from your view controller to any SwiftUI views.\n\nTopics\nCreating and updating the view controller\nfunc makeNSViewController(context: Self.Context) -> Self.NSViewControllerType\nCreates the view controller object and configures its initial state.\n\nRequired\n\nfunc updateNSViewController(Self.NSViewControllerType, context: Self.Context)\nUpdates the state of the specified view controller with new information from SwiftUI.\n\nRequired\n\ntypealias Context\nassociatedtype NSViewControllerType : NSViewController\nThe type of view controller to present.\n\nRequired\n\nSpecifying a size\nfunc sizeThatFits(ProposedViewSize, nsViewController: Self.NSViewControllerType, context: Self.Context) -> CGSize?\nGiven a proposed size, returns the preferred size of the composite view.\n\nRequired Default implementation provided.\n\nCleaning up the view controller\nstatic func dismantleNSViewController(Self.NSViewControllerType, coordinator: Self.Coordinator)\nCleans up the presented view controller (and coordinator) in anticipation of its removal.\n\nRequired Default implementation provided.\n\nProviding a custom coordinator object\nfunc makeCoordinator() -> Self.Coordinator\nCreates the custom object that you use to communicate changes from your view controller to other parts of your SwiftUI interface.\n\nRequired Default implementation provided.\n\nassociatedtype Coordinator = Void\nA type to coordinate with the view controller.\n\nRequired\n\nPerforming layout\ntypealias LayoutOptions\nRelationships\nInherits From\nView\nSee Also\nAdding AppKit views to SwiftUI view hierarchies\nprotocol NSViewRepresentable\nA wrapper that you use to integrate an AppKit view into your SwiftUI view hierarchy.\nstruct NSViewRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view.\nstruct NSViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view controller."
    },
    {
        "title": "photosPicker(isPresented:selection:maxSelectionCount:selectionBehavior:matching:preferredItemEncoding:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:maxselectioncount:selectionbehavior:matching:preferreditemencoding:)",
        "html": "Parameters\nisPresented\n\nThe binding to whether the Photos picker should be shown.\n\nselection\n\nAll items being shown and selected in the Photos picker.\n\nmaxSelectionCount\n\nThe maximum number of items that can be selected. Default is nil. Setting it to nil means maximum supported by the system.\n\nselectionBehavior\n\nThe selection behavior of the Photos picker. Default is .default.\n\nfilter\n\nTypes of items that can be shown. Default is nil. Setting it to nil means all supported types can be shown.\n\npreferredItemEncoding\n\nThe encoding disambiguation policy of selected items. Default is .automatic. Setting it to .automatic means the best encoding determined by the system will be used.\n\nDiscussion\n\nThe user explicitly grants access only to items they choose, so photo library access authorization is not needed.\n\nSee Also\nSelecting photos\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker."
    },
    {
        "title": "accessibilityAdjustableAction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityadjustableaction(_:)",
        "html": "Discussion\n\nFor example, this is how an adjustable action to navigate through pages could be added to a view.\n\nvar body: some View {\n    PageControl()\n        .accessibilityAdjustableAction { direction in\n            switch direction {\n            case .increment:\n                // Go to next page\n            case .decrement:\n                // Go to previous page\n            }\n        }\n}\n\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "photosPickerDisabledCapabilities(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/photospickerdisabledcapabilities(_:)",
        "html": "Parameters\ndisabledCapabilities\n\nOne or more of the available capabilities.\n\nReturn Value\n\nA Photos picker with specified capabilities that are disabled.\n\nSee Also\nSelecting photos\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker."
    },
    {
        "title": "defersSystemGestures(on:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/deferssystemgestures(on:)",
        "html": "Parameters\nedges\n\nA value that indicates the screen edge from which you want your gesture to take precedence over the system gesture.\n\nDiscussion\n\nThe following code defers the vertical screen edges system gestures of a given canvas.\n\nstruct DeferredView: View {\n    var body: some View {\n        Canvas()\n            .defersSystemGestures(on: .vertical)\n    }\n}\n\nSee Also\nDefining custom gestures\nfunc highPriorityGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a higher precedence than gestures defined by the view.\nprotocol Gesture\nAn instance that matches a sequence of events to a gesture, and returns a stream of values for each of its states.\nstruct AnyGesture\nA type-erased gesture.\nstruct HandActivationBehavior\nAn activation behavior specific to hand-driven input.\nBeta"
    },
    {
        "title": "NSViewControllerRepresentableContext",
        "url": "https://developer.apple.com/documentation/swiftui/nsviewcontrollerrepresentablecontext",
        "html": "Overview\n\nAn NSViewControllerRepresentableContext structure contains details about the current state of the system. When creating and updating your view controller, the system creates one of these structures and passes it to the appropriate method of your custom NSViewControllerRepresentable instance. Use the information in this structure to configure your view controller. For example, use the provided environment values to configure the appearance of your view controller and views. Don\u2019t create this structure yourself.\n\nTopics\nCoordinating view-related interactions\nlet coordinator: ViewController.Coordinator\nAn object you use to communicate your AppKit view controller\u2019s behavior and state out to SwiftUI objects.\nvar transaction: Transaction\nThe current transaction.\nGetting the current environment data\nvar environment: EnvironmentValues\nEnvironment data that describes the current state of the system.\nRelationships\nConforms To\nSendable\nSee Also\nAdding AppKit views to SwiftUI view hierarchies\nprotocol NSViewRepresentable\nA wrapper that you use to integrate an AppKit view into your SwiftUI view hierarchy.\nstruct NSViewRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view.\nprotocol NSViewControllerRepresentable\nA wrapper that you use to integrate an AppKit view controller into your SwiftUI interface."
    },
    {
        "title": "PreviewDevice",
        "url": "https://developer.apple.com/documentation/swiftui/previewdevice",
        "html": "Overview\n\nCreate a preview device by name, like \u201ciPhone X\u201d, or by model number, like \u201ciPad8,1\u201d. Use the device in a call to the previewDevice(_:) modifier to set a preview device that doesn\u2019t change when you change the run destination in Xcode:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n            .previewDevice(PreviewDevice(rawValue: \"iPad Pro (11-inch)\"))\n    }\n}\n\n\nYou can get a list of supported preview device names by using the xcrun command in the Terminal app:\n\n% xcrun simctl list devicetypes\n\n\nAdditionally, you can use the following values for macOS platform development:\n\n\u201cMac\u201d\n\n\u201cMac Catalyst\u201d\n\nRelationships\nConforms To\nExpressibleByExtendedGraphemeClusterLiteral\nExpressibleByStringLiteral\nExpressibleByUnicodeScalarLiteral\nRawRepresentable\nSendable\nSee Also\nCustomizing a preview\nfunc previewDevice(PreviewDevice?) -> some View\nOverrides the device for a preview.\nfunc previewLayout(PreviewLayout) -> some View\nOverrides the size of the container for the preview.\nfunc previewInterfaceOrientation(InterfaceOrientation) -> some View\nOverrides the orientation of the preview.\nstruct InterfaceOrientation\nThe orientation of the interface from the user\u2019s perspective."
    },
    {
        "title": "previewInterfaceOrientation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/previewinterfaceorientation(_:)",
        "html": "Parameters\nvalue\n\nAn orientation to use for preview.\n\nReturn Value\n\nA preview that uses the given orientation.\n\nDiscussion\n\nBy default, device previews appear right side up, using orientation portrait. You can change the orientation of a preview using one of the values in the InterfaceOrientation structure:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n            .previewInterfaceOrientation(.landscapeRight)\n    }\n}\n\nSee Also\nCustomizing a preview\nfunc previewDevice(PreviewDevice?) -> some View\nOverrides the device for a preview.\nstruct PreviewDevice\nA simulator device that runs a preview.\nfunc previewLayout(PreviewLayout) -> some View\nOverrides the size of the container for the preview.\nstruct InterfaceOrientation\nThe orientation of the interface from the user\u2019s perspective."
    },
    {
        "title": "PreviewContextKey",
        "url": "https://developer.apple.com/documentation/swiftui/previewcontextkey",
        "html": "Overview\n\nThe default value is nil.\n\nTopics\nSetting a default\nstatic var defaultValue: Self.Value\nThe default value of the key.\n\nRequired\n\nassociatedtype Value\nThe type of the value returned by the key.\n\nRequired\n\nSee Also\nSetting a context\nfunc previewContext<C>(C) -> some View\nDeclares a context for the preview.\nprotocol PreviewContext\nA context type for use with a preview."
    },
    {
        "title": "previewDevice(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/previewdevice(_:)",
        "html": "Parameters\nvalue\n\nA device to use for preview, or nil to let Xcode automatically choose a device based on the run destination.\n\nReturn Value\n\nA preview that uses the given device.\n\nDiscussion\n\nBy default, Xcode automatically chooses a preview device based on your currently selected run destination. If you want to choose a device that doesn\u2019t change based on Xcode settings, provide a PreviewDevice instance that you initialize with the name or model of a specific device:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n            .previewDevice(PreviewDevice(rawValue: \"iPad Pro (11-inch)\"))\n    }\n}\n\n\nYou can get a list of supported preview device names, like \u201ciPhone 11\u201d, \u201ciPad Pro (11-inch)\u201d, and \u201cApple Watch Series 5 - 44mm\u201d, by using the xcrun command in the Terminal app:\n\n% xcrun simctl list devicetypes\n\n\nAdditionally, you can use the following values for macOS platform development:\n\n\u201cMac\u201d\n\n\u201cMac Catalyst\u201d\n\nSee Also\nCustomizing a preview\nstruct PreviewDevice\nA simulator device that runs a preview.\nfunc previewLayout(PreviewLayout) -> some View\nOverrides the size of the container for the preview.\nfunc previewInterfaceOrientation(InterfaceOrientation) -> some View\nOverrides the orientation of the preview.\nstruct InterfaceOrientation\nThe orientation of the interface from the user\u2019s perspective."
    },
    {
        "title": "PreviewContext",
        "url": "https://developer.apple.com/documentation/swiftui/previewcontext",
        "html": "Topics\nAccessing a preview context\nsubscript<Key>(Key.Type) -> Key.Value\nReturns the context\u2019s value for a key, or a the key\u2019s default value if the context doesn\u2019t define a value for the key.\n\nRequired\n\nSee Also\nSetting a context\nfunc previewContext<C>(C) -> some View\nDeclares a context for the preview.\nprotocol PreviewContextKey\nA key type for a preview context."
    },
    {
        "title": "init(configuration:)",
        "url": "https://developer.apple.com/documentation/swiftui/blurreplacetransition/init(configuration:)",
        "html": "Parameters\nconfiguration\n\nthe transition configuration."
    },
    {
        "title": "PreviewPlatform",
        "url": "https://developer.apple.com/documentation/swiftui/previewplatform",
        "html": "Overview\n\nXcode infers the platform for a preview based on the currently selected target. If you have a multiplatform target and want to suggest a particular target for a preview, implement the platform computed property as a hint, and specify one of the preview platforms:\n\nstruct CircleImage_Previews: PreviewProvider {\n    static var previews: some View {\n        CircleImage()\n    }\n\n\n    static var platform: PreviewPlatform? {\n        PreviewPlatform.tvOS\n    }\n}\n\nTopics\nGetting an operating system\ncase iOS\nSpecifies iOS as the preview platform.\ncase macOS\nSpecifies macOS as the preview platform.\ncase tvOS\nSpecifies tvOS as the preview platform.\ncase watchOS\nSpecifies watchOS as the preview platform.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nDefining a preview\nprotocol PreviewProvider\nA type that produces view previews in Xcode.\nfunc previewDisplayName(String?) -> some View\nSets a user visible name to show in the canvas for a preview."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/swiftui/settingslink/init()",
        "html": "Discussion\n\nThe display of the label may be customized using the labelStyle(_:) modifier.\n\nSee Also\nCreating a settings link\ninit(label: () -> Label)\nCreates a settings link with a custom label."
    },
    {
        "title": "accessibilityLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(_:)-5f0zj",
        "html": "Discussion\n\nUse this method to provide an accessibility label for a view that doesn\u2019t display text, like an icon. For example, you could use this method to label a button that plays music with the text \u201cPlay\u201d. Don\u2019t include text in the label that repeats information that users already have. For example, don\u2019t use the label \u201cPlay button\u201d because a button already has a trait that identifies it as a button.\n\nSee Also\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair."
    },
    {
        "title": "accessibilityLabeledPair(role:id:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitylabeledpair(role:id:in:)",
        "html": "Parameters\nrole\n\nDetermines whether this element should be used as the label in the pair, or the content in the pair.\n\nid\n\nThe identifier for the label / content pair. Elements with matching identifiers within the same namespace will be paired together.\n\nnamespace\n\nThe namespace used to organize label and content. Label and content under the same namespace with matching identifiers will be paired together.\n\nDiscussion\n\nUse accessibilityLabeledPair with a role of AccessibilityLabeledPairRole.label to identify the label, and a role of AccessibilityLabeledPairRole.content to identify the content. This improves the behavior of accessibility features such as VoiceOver when navigating such elements, allowing users to better understand the relationship between them.\n\nSee Also\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair."
    },
    {
        "title": "accessibilityLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(_:)-9ek2h",
        "html": "Discussion\n\nUse this method to provide an accessibility label for a view that doesn\u2019t display text, like an icon. For example, you could use this method to label a button that plays music with the text \u201cPlay\u201d. Don\u2019t include text in the label that repeats information that users already have. For example, don\u2019t use the label \u201cPlay button\u201d because a button already has a trait that identifies it as a button.\n\nSee Also\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair."
    },
    {
        "title": "accessibilityInputLabels(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityinputlabels(_:)-6nafd",
        "html": "Discussion\n\nProvide labels in descending order of importance. Voice Control and Full Keyboard Access use the input labels.\n\nNote\n\nIf you don\u2019t specify any input labels, the user can still refer to the view using the accessibility label that you add with the accessibilityLabel() modifier.\n\nSee Also\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair."
    },
    {
        "title": "WKInterfaceObjectRepresentable",
        "url": "https://developer.apple.com/documentation/swiftui/wkinterfaceobjectrepresentable",
        "html": "Overview\n\nUse a WKInterfaceObjectRepresentable instance to create and manage a WKInterfaceObject in your SwiftUI interface. Adopt this protocol in one of your app\u2019s custom instances, and use its methods to create, update, and tear down your interface object. The creation and update processes parallel the behavior of SwiftUI views, and you use them to configure your interface object with your app\u2019s current state information. Use the teardown process to remove your interface object cleanly from your SwiftUI. For example, you might use the teardown process to notify other parts of your app that the interface object is disappearing.\n\nTo add your interface object into your SwiftUI interface, create your WKInterfaceObjectRepresentable instance and add it to your SwiftUI interface. The system calls the methods of your representable instance at appropriate times to create and update the interface object.\n\nThe system doesn\u2019t automatically communicate changes occurring within your interface object to other parts of your SwiftUI interface. When you want your interface object to coordinate with other SwiftUI views, you must provide a Coordinator instance to facilitate those interactions. For example, you use a coordinator to forward target-action and delegate messages from your interface object to any SwiftUI views.\n\nTopics\nCreating and updating the interface object\nfunc makeWKInterfaceObject(context: Self.Context) -> Self.WKInterfaceObjectType\nCreates a WatchKit interface object and configures its initial state.\n\nRequired\n\nfunc updateWKInterfaceObject(Self.WKInterfaceObjectType, context: Self.Context)\nUpdates the presented WatchKit interface object (and its coordinator) to the latest configuration.\n\nRequired\n\ntypealias Context\nCleaning up the interface object\nstatic func dismantleWKInterfaceObject(Self.WKInterfaceObjectType, coordinator: Self.Coordinator)\nCleans up the presented WatchKit interface object (and its coordinator) in anticipation of their removal.\n\nRequired Default implementation provided.\n\nProviding a custom coordinator object\nfunc makeCoordinator() -> Self.Coordinator\nCreates the custom instance that you use to communicate changes from your interface object to other parts of your SwiftUI interface.\n\nRequired Default implementation provided.\n\nassociatedtype Coordinator = Void\nA type to coordinate with the WatchKit interface object.\n\nRequired\n\nassociatedtype WKInterfaceObjectType : WKInterfaceObject\nThe type of WatchKit interface object to be presented.\n\nRequired\n\nRelationships\nInherits From\nView\nSee Also\nAdding WatchKit views to SwiftUI view hierarchies\nstruct WKInterfaceObjectRepresentableContext\nContextual information about the state of the system that you use to create and update your WatchKit interface object."
    },
    {
        "title": "UIHostingOrnament",
        "url": "https://developer.apple.com/documentation/swiftui/uihostingornament",
        "html": "Overview\n\nUse a UIHostingOrnament when you want to add ornaments to a UIKit view controller. For example, the following adds a single bottom ornament to the current view controller:\n\nself.ornaments = [\n    UIHostingOrnament(sceneAnchor: .bottom) {\n        OrnamentContent()\n    }\n]\n\nTopics\nCreating a hosting ornament\nvar rootView: Content\nThe root view of the SwiftUI view hierarchy managed by this ornament.\nSetting the alignment\nvar contentAlignment: Alignment\nThe alignment in the ornament used to position it.\nInitializers\ninit(sceneAnchor: UnitPoint, contentAlignment: Alignment, content: () -> Content)\nCreates an ornament with the specified alignment and content.\nInstance Properties\nvar sceneAnchor: UnitPoint\nThe anchor point for aligning the ornament\u2019s content (based on the contentAlignment) with the scene.\nRelationships\nInherits From\nUIOrnament\nSee Also\nHosting an ornament in UIKit\nclass UIOrnament\nThe abstract base class that represents an ornament.\nBeta"
    },
    {
        "title": "accessibilityInputLabels(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityinputlabels(_:)-9q3yf",
        "html": "Parameters\ninputLabels\n\nAn array of Text elements to use as input labels.\n\nDiscussion\n\nProvide labels in descending order of importance. Voice Control and Full Keyboard Access use the input labels.\n\nNote\n\nIf you don\u2019t specify any input labels, the user can still refer to the view using the accessibility label that you add with the accessibilityLabel() modifier.\n\nSee Also\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair."
    },
    {
        "title": "WKHostingController",
        "url": "https://developer.apple.com/documentation/swiftui/wkhostingcontroller",
        "html": "Overview\n\nA WKHostingController presents and manages your app\u2019s main interface using SwiftUI views. You must subclass WKHostingController and override the body property to provide the set of SwiftUI views you want to display. Display the content of your hosting controller as you would any other WKInterfaceController object. For example, you can include it as one of your app\u2019s root interface controllers, or present it modally.\n\nTopics\nCreating a hosting controller object\ninit()\nCreates a hosting controller object that you can use to implement your app\u2019s main interface using SwiftUI views\nGetting the root view\nvar body: Body\nThe root view of the view hierarchy to display for your interface controller.\nUpdating the root view\nfunc updateBodyIfNeeded()\nUpdates the interface controller\u2019s set of views immediately, if updates are pending.\nfunc setNeedsBodyUpdate()\nInvalidates the current SwiftUI views and triggers an update during the next cycle.\nRelationships\nInherits From\nWKInterfaceController\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSObjectProtocol\nSee Also\nDisplaying SwiftUI views in WatchKit\nclass WKUserNotificationHostingController\nA WatchKit user notification interface controller that hosts a SwiftUI view hierarchy."
    },
    {
        "title": "UIViewRepresentableContext",
        "url": "https://developer.apple.com/documentation/swiftui/uiviewrepresentablecontext",
        "html": "Overview\n\nA UIViewRepresentableContext structure contains details about the current state of the system. When creating and updating your view, the system creates one of these structures and passes it to the appropriate method of your custom UIViewRepresentable instance. Use the information in this structure to configure your view. For example, use the provided environment values to configure the appearance of your view. Don\u2019t create this structure yourself.\n\nTopics\nCoordinating view-related interactions\nlet coordinator: Representable.Coordinator\nThe view\u2019s associated coordinator.\nvar transaction: Transaction\nThe current transaction.\nGetting the current environment data\nvar environment: EnvironmentValues\nThe current environment.\nRelationships\nConforms To\nSendable\nSee Also\nAdding UIKit views to SwiftUI view hierarchies\nprotocol UIViewRepresentable\nA wrapper for a UIKit view that you use to integrate that view into your SwiftUI view hierarchy.\nprotocol UIViewControllerRepresentable\nA view that represents a UIKit view controller.\nstruct UIViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view controller."
    },
    {
        "title": "speechSpellsOutCharacters(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/speechspellsoutcharacters(_:)",
        "html": "Parameters\nvalue\n\nA Boolean value that when true indicates VoiceOver should speak text as individual characters. Defaults to true.\n\nDiscussion\n\nUse this modifier when you want VoiceOver to speak text as individual letters, character by character. This is important for text that is not meant to be spoken together, like:\n\nAn acronym that isn\u2019t a word, like APPL, spoken as \u201cA-P-P-L\u201d.\n\nA number representing a series of digits, like 25, spoken as \u201ctwo-five\u201d rather than \u201ctwenty-five\u201d.\n\nSee Also\nConfiguring VoiceOver\nfunc speechAdjustedPitch(Double) -> some View\nRaises or lowers the pitch of spoken text.\nfunc speechAlwaysIncludesPunctuation(Bool) -> some View\nSets whether VoiceOver should always speak all punctuation in the text view.\nfunc speechAnnouncementsQueued(Bool) -> some View\nControls whether to queue pending announcements behind existing speech rather than interrupting speech in progress."
    },
    {
        "title": "WKInterfaceObjectRepresentableContext",
        "url": "https://developer.apple.com/documentation/swiftui/wkinterfaceobjectrepresentablecontext",
        "html": "Overview\n\nA WKInterfaceObjectRepresentableContext structure contains details about the current state of the system. When creating and updating your interface objects, the system creates one of these structures and passes it to the appropriate method of your custom WKInterfaceObjectRepresentable instance. Use the information in this structure to configure your object. Don\u2019t create this structure yourself.\n\nTopics\nCoordinating interactions\nlet coordinator: Representable.Coordinator\nThe view\u2019s associated coordinator.\nvar transaction: Transaction\nThe current transaction.\nGetting the current environment data\nvar environment: EnvironmentValues\nThe current environment.\nRelationships\nConforms To\nSendable\nSee Also\nAdding WatchKit views to SwiftUI view hierarchies\nprotocol WKInterfaceObjectRepresentable\nA view that represents a WatchKit interface object."
    },
    {
        "title": "speechAdjustedPitch(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/speechadjustedpitch(_:)",
        "html": "Parameters\nvalue\n\nThe amount to raise or lower the pitch. Values between -1 and 0 result in a lower pitch while values between 0 and 1 result in a higher pitch. The method clamps values to the range -1 to 1.\n\nDiscussion\n\nUse this modifier when you want to change the pitch of spoken text. The value indicates how much higher or lower to change the pitch.\n\nSee Also\nConfiguring VoiceOver\nfunc speechAlwaysIncludesPunctuation(Bool) -> some View\nSets whether VoiceOver should always speak all punctuation in the text view.\nfunc speechAnnouncementsQueued(Bool) -> some View\nControls whether to queue pending announcements behind existing speech rather than interrupting speech in progress.\nfunc speechSpellsOutCharacters(Bool) -> some View\nSets whether VoiceOver should speak the contents of the text view character by character."
    },
    {
        "title": "speechAnnouncementsQueued(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/speechannouncementsqueued(_:)",
        "html": "Parameters\nvalue\n\nA Boolean value that determines if VoiceOver speaks changes to text immediately or enqueues them behind existing speech. Defaults to true.\n\nDiscussion\n\nUse this modifier when you want affect the order in which the accessibility system delivers spoken text. Announcements can occur automatically when the label or value of an accessibility element changes.\n\nSee Also\nConfiguring VoiceOver\nfunc speechAdjustedPitch(Double) -> some View\nRaises or lowers the pitch of spoken text.\nfunc speechAlwaysIncludesPunctuation(Bool) -> some View\nSets whether VoiceOver should always speak all punctuation in the text view.\nfunc speechSpellsOutCharacters(Bool) -> some View\nSets whether VoiceOver should speak the contents of the text view character by character."
    },
    {
        "title": "speechAlwaysIncludesPunctuation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/speechalwaysincludespunctuation(_:)",
        "html": "Parameters\nvalue\n\nA Boolean value that you set to true if VoiceOver should speak all punctuation in the text. Defaults to true.\n\nDiscussion\n\nUse this modifier to control whether the system speaks punctuation characters in the text. You might use this for code or other text where the punctuation is relevant, or where you want VoiceOver to speak a verbatim transcription of the text you provide. For example, given the text:\n\nText(\"All the world's a stage, \" +\n     \"And all the men and women merely players;\")\n     .speechAlwaysIncludesPunctuation()\n\n\nVoiceOver would speak \u201cAll the world apostrophe s a stage comma and all the men and women merely players semicolon\u201d.\n\nBy default, VoiceOver voices punctuation based on surrounding context.\n\nSee Also\nConfiguring VoiceOver\nfunc speechAdjustedPitch(Double) -> some View\nRaises or lowers the pitch of spoken text.\nfunc speechAnnouncementsQueued(Bool) -> some View\nControls whether to queue pending announcements behind existing speech rather than interrupting speech in progress.\nfunc speechSpellsOutCharacters(Bool) -> some View\nSets whether VoiceOver should speak the contents of the text view character by character."
    },
    {
        "title": "accessibilityHint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityhint(_:)-6gek2",
        "html": "Discussion\n\nProvide a hint in the form of a brief phrase, like \u201cPurchases the item\u201d or \u201cDownloads the attachment\u201d.\n\nSee Also\nOffering hints\nfunc accessibilityHint(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nfunc accessibilityHint(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action."
    },
    {
        "title": "UIOrnament",
        "url": "https://developer.apple.com/documentation/swiftui/uiornament",
        "html": "Overview\n\nYou don\u2019t create an instance of this class directly. Instead use UIHostingOrnament when you want to add ornaments to a UIKit view controller.\n\nRelationships\nInherited By\nUIHostingOrnament\nSee Also\nHosting an ornament in UIKit\nclass UIHostingOrnament\nA model that represents an ornament suitable for being hosted in UIKit.\nBeta"
    },
    {
        "title": "accessibilityHint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityhint(_:)-3rdgs",
        "html": "Discussion\n\nProvide a hint in the form of a brief phrase, like \u201cPurchases the item\u201d or \u201cDownloads the attachment\u201d.\n\nNote\n\nOn macOS, if the view does not have an action and it has been made into a container with accessibilityElement(children: .contain), this will be used to describe the container. For example, if the container is for a graph, the hint could be \u201cgraph\u201d.\n\nSee Also\nOffering hints\nfunc accessibilityHint(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nfunc accessibilityHint<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action."
    },
    {
        "title": "accessibilityQuickAction(style:isActive:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityquickaction(style:isactive:content:)",
        "html": "Discussion\n\nThe following example shows how to add a quick action to pause and resume a workout, with the prompt style.\n\n@State private var isPaused = false\n@State private var isQuickActionActive = false\n\n\nvar body: some View {\n    WorkoutView(isPaused: $isPaused)\n        .accessibilityQuickAction(style: .prompt, isActive: $isQuickActionActive) {\n            Button(isPaused ? \"Resume\" : \"Pause\") {\n                isPaused.toggle()\n            }\n        }\n}\n\n\nThe following example shows how to add a quick action to play and pause music, with the outline style.\n\n@State private var isPlaying = false\n@State private var isQuickActionActive = false\n\n\nvar body: some View {\n    PlayButton(isPlaying: $isPlaying)\n        .contentShape(.focusEffect, Circle())\n        .accessibilityQuickAction(style: .outline, isActive: $isQuickActionActive) {\n            Button(isPlaying ? \"Pause\" : \"Play\") {\n                isPlaying.toggle()\n            }\n        }\n}\n\nSee Also\nOffering Quick Actions to people\nfunc accessibilityQuickAction<Style, Content>(style: Style, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active.\nprotocol AccessibilityQuickActionStyle\nA type that describes the presentation style of an accessibility quick action."
    },
    {
        "title": "accessibilityScrollAction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityscrollaction(_:)",
        "html": "Discussion\n\nFor example, this is how a scroll action to trigger a refresh could be added to a view.\n\nvar body: some View {\n    ScrollView {\n        ContentView()\n    }\n    .accessibilityScrollAction { edge in\n        if edge == .top {\n            // Refresh content\n        }\n    }\n}\n\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "accessibilityActivationPoint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityactivationpoint(_:)-9l0w0",
        "html": "Discussion\n\nUse this modifier to ensure that the activation point for a small element remains accurate even if you present a larger version of the element to VoiceOver.\n\nIf an activation point is not provided, an activation point will be derrived from one of the accessibility elements decendents or from the center of the accessibility frame.\n\nSee Also\nMaking gestures accessible\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityDirectTouchOptions\nAn option set that defines the functionality of a view\u2019s direct touch area.\nstruct AccessibilityZoomGestureAction\nPosition and direction information of a zoom gesture that someone performs with an assistive technology like VoiceOver."
    },
    {
        "title": "accessibilityQuickAction(style:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityquickaction(style:content:)",
        "html": "Discussion\n\nThe quick action will automatically become active when the view appears. If the view is disabled, the action will defer becoming active until the view is no longer disabled.\n\nThe following example shows how to add a quick action to pause and resume a workout, with the prompt style.\n\n@State private var isPaused = false\n\n\nvar body: some View {\n    WorkoutView(isPaused: $isPaused)\n        .accessibilityQuickAction(style: .prompt) {\n            Button(isPaused ? \"Resume\" : \"Pause\") {\n                isPaused.toggle()\n            }\n        }\n}\n\n\nThe following example shows how to add a quick action to play and pause music, with the outline style.\n\n@State private var isPlaying = false\n\n\nvar body: some View {\n    PlayButton(isPlaying: $isPlaying)\n        .contentShape(.focusEffect, Circle())\n        .accessibilityQuickAction(style: .outline) {\n            Button(isPlaying ? \"Pause\" : \"Play\") {\n                isPlaying.toggle()\n            }\n        }\n}\n\nSee Also\nOffering Quick Actions to people\nfunc accessibilityQuickAction<Style, Content>(style: Style, isActive: Binding<Bool>, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active.\nprotocol AccessibilityQuickActionStyle\nA type that describes the presentation style of an accessibility quick action."
    },
    {
        "title": "AccessibilityQuickActionStyle",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityquickactionstyle",
        "html": "Topics\nGetting built-in menu styles\nstatic var outline: AccessibilityQuickActionOutlineStyle\nA presentation style that animates an outline around the view when the accessibility quick action is active.\nAvailable when Self is AccessibilityQuickActionOutlineStyle.\nstatic var prompt: AccessibilityQuickActionPromptStyle\nA presentation style that displays a prompt to the user when the accessibility quick action is active.\nAvailable when Self is AccessibilityQuickActionPromptStyle.\nSupporting types\nstruct AccessibilityQuickActionOutlineStyle\nA presentation style that displays a prompt to the user when the accessibility quick action is active.\nstruct AccessibilityQuickActionPromptStyle\nA presentation style that displays a prompt to the user when the accessibility quick action is active.\nRelationships\nConforming Types\nAccessibilityQuickActionOutlineStyle\nAccessibilityQuickActionPromptStyle\nSee Also\nOffering Quick Actions to people\nfunc accessibilityQuickAction<Style, Content>(style: Style, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active.\nfunc accessibilityQuickAction<Style, Content>(style: Style, isActive: Binding<Bool>, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active."
    },
    {
        "title": "accessibilityDirectTouch(_:options:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitydirecttouch(_:options:)",
        "html": "Discussion\n\nFor example, this is how a direct touch area would allow a VoiceOver user to interact with a view with a rotationEffect controlled by a RotationGesture. The direct touch area would require a user to activate the area before using the direct touch area.\n\nvar body: some View {\n    Rectangle()\n        .frame(width: 200, height: 200, alignment: .center)\n        .rotationEffect(angle)\n        .gesture(rotation)\n        .accessibilityDirectTouch(options: .requiresActivation)\n}\n\nSee Also\nMaking gestures accessible\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityDirectTouchOptions\nAn option set that defines the functionality of a view\u2019s direct touch area.\nstruct AccessibilityZoomGestureAction\nPosition and direction information of a zoom gesture that someone performs with an assistive technology like VoiceOver."
    },
    {
        "title": "accessibilityActivationPoint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityactivationpoint(_:)-10po1",
        "html": "Discussion\n\nUse this modifier to ensure that the activation point for a small element remains accurate even if you present a larger version of the element to VoiceOver.\n\nIf an activation point is not provided, an activation point will be derrived from one of the accessibility elements decendents or from the center of the accessibility frame.\n\nSee Also\nMaking gestures accessible\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityDirectTouchOptions\nAn option set that defines the functionality of a view\u2019s direct touch area.\nstruct AccessibilityZoomGestureAction\nPosition and direction information of a zoom gesture that someone performs with an assistive technology like VoiceOver."
    },
    {
        "title": "accessibilityZoomAction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityzoomaction(_:)",
        "html": "Discussion\n\nFor example, this is how a zoom action is used to transform the scale of a shape which has a MagnificationGesture.\n\nvar body: some View {\n    Circle()\n        .scaleEffect(magnifyBy)\n        .gesture(magnification)\n        .accessibilityLabel(\"Circle Magnifier\")\n        .accessibilityZoomAction { action in\n            switch action.direction {\n            case .zoomIn:\n                magnifyBy += 0.5\n            case .zoomOut:\n                 magnifyBy -= 0.5\n            }\n        }\n}\n\nSee Also\nMaking gestures accessible\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nstruct AccessibilityDirectTouchOptions\nAn option set that defines the functionality of a view\u2019s direct touch area.\nstruct AccessibilityZoomGestureAction\nPosition and direction information of a zoom gesture that someone performs with an assistive technology like VoiceOver."
    },
    {
        "title": "accessibilityFocused(_:equals:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityfocused(_:equals:)",
        "html": "Parameters\nbinding\n\nThe state binding to register. When accessibility focus moves to the accessibility element of the modified view, SwiftUI sets the bound value to the corresponding match value. If you set the state value programmatically to the matching value, then accessibility focus moves to the accessibility element of the modified view. SwiftUI sets the value to nil if accessibility focus leaves the accessibility element associated with the modified view, and programmatically setting the value to nil dismisses focus automatically.\n\nvalue\n\nThe value to match against when determining whether the binding should change.\n\nReturn Value\n\nThe modified view.\n\nSee Also\nControlling focus\nfunc accessibilityFocused(AccessibilityFocusState<Bool>.Binding) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given boolean state value.\nstruct AccessibilityFocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the focus of any active accessibility technology, such as VoiceOver, changes."
    },
    {
        "title": "AccessibilityDirectTouchOptions",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitydirecttouchoptions",
        "html": "Topics\nGetting the options\nstatic let requiresActivation: AccessibilityDirectTouchOptions\nPrevents touch passthrough with the direct touch area until an assistive technology, such as VoiceOver, has activated the direct touch area through a user action, for example a double tap.\nstatic let silentOnTouch: AccessibilityDirectTouchOptions\nAllows a direct touch area to immediately receive touch events without an assitive technology, such as VoiceOver, speaking. Appropriate for apps that provide direct audio feedback on touch that would conflict with speech feedback.\nCreating a set of options\ninit(rawValue: AccessibilityDirectTouchOptions.RawValue)\nCreate a set of direct touch options\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nMaking gestures accessible\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityZoomGestureAction\nPosition and direction information of a zoom gesture that someone performs with an assistive technology like VoiceOver."
    },
    {
        "title": "AccessibilityFocusState",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityfocusstate",
        "html": "Overview\n\nUse this capability to request that VoiceOver or other accessibility technologies programmatically focus on a specific element, or to determine whether VoiceOver or other accessibility technologies are focused on particular elements. Use accessibilityFocused(_:equals:) or accessibilityFocused(_:) in conjunction with this property wrapper to identify accessibility elements for which you want to get or set accessibility focus. When accessibility focus enters the modified accessibility element, the framework updates the wrapped value of this property to match a given prototype value. When accessibility focus leaves, SwiftUI resets the wrapped value of an optional property to nil or the wrapped value of a Boolean property to false. Setting the property\u2019s value programmatically has the reverse effect, causing accessibility focus to move to whichever accessibility element is associated with the updated value.\n\nIn the example below, when notification changes, and its isPriority property is true, the accessibility focus moves to the notification Text element above the rest of the view\u2019s content:\n\nstruct CustomNotification: Equatable {\n    var text: String\n    var isPriority: Bool\n}\n\n\nstruct ContentView: View {\n    @Binding var notification: CustomNotification?\n    @AccessibilityFocusState var isNotificationFocused: Bool\n\n\n    var body: some View {\n        VStack {\n            if let notification = self.notification {\n                Text(notification.text)\n                    .accessibilityFocused($isNotificationFocused)\n            }\n            Text(\"The main content for this view.\")\n        }\n        .onChange(of: notification) { notification in\n            if (notification?.isPriority == true)  {\n                isNotificationFocused = true\n            }\n        }\n\n\n    }\n}\n\n\nTo allow for cases where accessibility focus is completely absent from the tree of accessibility elements, or accessibility technologies are not active, the wrapped value must be either optional or Boolean.\n\nSome initializers of AccessibilityFocusState also allow specifying accessibility technologies, determining to which types of accessibility focus this binding applies. If you specify no accessibility technologies, SwiftUI uses an aggregate of any and all active accessibility technologies.\n\nTopics\nCreating a focus state\ninit<T>()\nCreates a new accessibility focus state of the type you provide.\ninit()\nCreates a new accessibility focus state for a Boolean value.\ninit<T>(for: AccessibilityTechnologies)\nCreates a new accessibility focus state of the type and using the accessibility technologies you specify.\ninit(for: AccessibilityTechnologies)\nCreates a new accessibility focus state for a Boolean value, using the accessibility technologies you specify.\nGetting the state\nvar projectedValue: AccessibilityFocusState<Value>.Binding\nA projection of the state value that can be used to establish bindings between view content and accessibility focus placement.\nvar wrappedValue: Value\nThe current state value, taking into account whatever bindings might be in effect due to the current location of focus.\nstruct Binding\nRelationships\nConforms To\nDynamicProperty\nSee Also\nControlling focus\nfunc accessibilityFocused(AccessibilityFocusState<Bool>.Binding) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given boolean state value.\nfunc accessibilityFocused<Value>(AccessibilityFocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given state value."
    },
    {
        "title": "AccessibilityZoomGestureAction",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityzoomgestureaction",
        "html": "Topics\nGetting the action\u2019s direction\nlet direction: AccessibilityZoomGestureAction.Direction\nThe zoom gesture\u2019s direction.\nenum Direction\nA direction that matches the movement of a zoom gesture performed by an assistive technology, such as a swipe up and down in Voiceover\u2019s zoom rotor.\nGetting location information\nlet location: UnitPoint\nThe zoom gesture\u2019s activation point, normalized to the accessibility element\u2019s frame.\nlet point: CGPoint\nThe zoom gesture\u2019s activation point within the window\u2019s coordinate space.\nSee Also\nMaking gestures accessible\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityDirectTouchOptions\nAn option set that defines the functionality of a view\u2019s direct touch area."
    },
    {
        "title": "accessibilityRespondsToUserInteraction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrespondstouserinteraction(_:)",
        "html": "Discussion\n\nIf this is not set, the value is inferred from the traits of the Accessibility element, the presence of Accessibility actions on the element, or the presence of gestures on the element or containing views."
    },
    {
        "title": "accessibilityFocused(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityfocused(_:)",
        "html": "Parameters\ncondition\n\nThe accessibility focus state to bind. When accessibility focus moves to the accessibility element of the modified view, the focus value is set to true. If the value is set to true programmatically, then accessibility focus will move to accessibility element of the modified view. The value will be set to false if accessibility focus leaves the accessibility element of the modified view, and accessibility focus will be dismissed automatically if the value is set to false programmatically.\n\nReturn Value\n\nThe modified view.\n\nSee Also\nControlling focus\nfunc accessibilityFocused<Value>(AccessibilityFocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given state value.\nstruct AccessibilityFocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the focus of any active accessibility technology, such as VoiceOver, changes."
    },
    {
        "title": "BackgroundTask",
        "url": "https://developer.apple.com/documentation/swiftui/backgroundtask",
        "html": "Overview\n\nUse a value of this type with the backgroundTask(_:action:) scene modifier to create a handler for background tasks that the system sends to your app or extension. For example, you can use urlSession to define an asynchronous closure that the system calls when it launches your app or extension to handle a response from a background URLSession.\n\nTopics\nRefreshing the app\nstatic var appRefresh: BackgroundTask<String?, Void>\nA task that updates your app\u2019s state in the background.\nstatic func appRefresh(String) -> BackgroundTask<Void, Void>\nA task that updates your app\u2019s state in the background for a matching identifier.\nPreparing for a snapshot\nstatic var snapshot: BackgroundTask<SnapshotData, SnapshotResponse>\nA background task used to update your app\u2019s user interface in preparation for a snapshot.\nReceiving connectivity updates\nstatic var bluetoothAlert: BackgroundTask<Void, Void>\nA background task used to receive critical alerts from paired bluetooth accessories.\nstatic var watchConnectivity: BackgroundTask<Void, Void>\nA background task used to receive background updates from the Watch Connectivity framework.\nResponding to URL sessions\nstatic var urlSession: BackgroundTask<String, Void>\nA task that responds to background URL sessions.\nstatic func urlSession(String) -> BackgroundTask<Void, Void>\nA task that responds to background URL sessions matching the given identifier.\nstatic func urlSession(matching: (String) -> Bool) -> BackgroundTask<String, Void>\nA task that responds to background URL sessions matching the given predicate.\nUpdating intents and shortcuts\nstatic var intentDidRun: BackgroundTask<Void, Void>\nA background task used to update your app after a SiriKit intent runs.\nstatic var relevantShortcut: BackgroundTask<Void, Void>\nA background task used to periodically donate relevant Siri shortcuts.\nRelationships\nConforms To\nSendable\nSee Also\nHandling background tasks\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some Scene\nRuns the specified action when the system provides a background task.\nstruct SnapshotData\nThe associated data of a snapshot background task.\nstruct SnapshotResponse\nYour appplication\u2019s response to a snapshot background task."
    },
    {
        "title": "backgroundTask(_:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/backgroundtask(_:action:)",
        "html": "Parameters\ntask\n\nThe type of task with which to associate the provided action.\n\naction\n\nAn async closure that the system runs for the specified task type.\n\nDiscussion\n\nWhen the system wakes your app or extension for one or more background tasks, it will call any actions associated with matching tasks. When your async actions return, the system put your app back into a suspended state. The system considers the task completed when the action closure that you provide returns. If the action closure has not returned when the task runs out of time to complete, the system cancels the task. Use withTaskCancellationHandler(operation:onCancel:) to observe whether the task is low on runtime.\n\n/// An example of a Weather Application.\nstruct WeatherApp: App {\n    var body: some Scene {\n        WindowGroup {\n            Text(\"Responds to App Refresh\")\n        }\n        .backgroundTask(.appRefresh(\"WEATHER_DATA\")) {\n            await updateWeatherData()\n        }\n    }\n    func updateWeatherData() async {\n        // fetches new weather data and updates app state\n    }\n}\n\nSee Also\nHandling background tasks\nstruct BackgroundTask\nThe kinds of background tasks that your app or extension can handle.\nstruct SnapshotData\nThe associated data of a snapshot background task.\nstruct SnapshotResponse\nYour appplication\u2019s response to a snapshot background task."
    },
    {
        "title": "onContinueUserActivity(_:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/oncontinueuseractivity(_:perform:)",
        "html": "Parameters\nactivityType\n\nThe type of activity to handle.\n\naction\n\nA function to call that takes a NSUserActivity object as its parameter when delivering the activity to the scene or window the view is in.\n\nSee Also\nHandling user activities\nfunc userActivity<P>(String, element: P?, (P, NSUserActivity) -> ()) -> some View\nAdvertises a user activity type.\nfunc userActivity(String, isActive: Bool, (NSUserActivity) -> ()) -> some View\nAdvertises a user activity type."
    },
    {
        "title": "userActivity(_:element:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/useractivity(_:element:_:)",
        "html": "Parameters\nactivityType\n\nThe type of activity to advertise.\n\nelement\n\nIf the element is nil, the handler will not be associated with the activity (and if there are no handlers, no activity is advertised). The method passes the non-nil element to the handler as a convenience so the handlers don\u2019t all need to implement an early exit with guard element = element else { return }.\n\nupdate\n\nA function that modifies the passed-in activity for advertisement.\n\nDiscussion\n\nThe scope of the activity applies only to the scene or window the view is in.\n\nSee Also\nHandling user activities\nfunc userActivity(String, isActive: Bool, (NSUserActivity) -> ()) -> some View\nAdvertises a user activity type.\nfunc onContinueUserActivity(String, perform: (NSUserActivity) -> ()) -> some View\nRegisters a handler to invoke when the view receives the specified activity type for the scene or window the view is in."
    },
    {
        "title": "userActivity(_:isActive:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/useractivity(_:isactive:_:)",
        "html": "Parameters\nactivityType\n\nThe type of activity to advertise.\n\nisActive\n\nWhen false, avoids advertising the activity. Defaults to true.\n\nupdate\n\nA function that modifies the passed-in activity for advertisement.\n\nDiscussion\n\nYou can use userActivity(_:isActive:_:) to start, stop, or modify the advertisement of a specific type of user activity.\n\nThe scope of the activity applies only to the scene or window the view is in.\n\nSee Also\nHandling user activities\nfunc userActivity<P>(String, element: P?, (P, NSUserActivity) -> ()) -> some View\nAdvertises a user activity type.\nfunc onContinueUserActivity(String, perform: (NSUserActivity) -> ()) -> some View\nRegisters a handler to invoke when the view receives the specified activity type for the scene or window the view is in."
    },
    {
        "title": "accessibilityLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(_:)-1d7jv",
        "html": "Discussion\n\nUse this method to provide an accessibility label for a view that doesn\u2019t display text, like an icon. For example, you could use this method to label a button that plays music with the text \u201cPlay\u201d. Don\u2019t include text in the label that repeats information that users already have. For example, don\u2019t use the label \u201cPlay button\u201d because a button already has a trait that identifies it as a button.\n\nSee Also\nApplying labels\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair."
    },
    {
        "title": "OpenURLAction",
        "url": "https://developer.apple.com/documentation/swiftui/openurlaction",
        "html": "Overview\n\nRead the openURL environment value to get an instance of this structure for a given Environment. Call the instance to open a URL. You call the instance directly because it defines a callAsFunction(_:) method that Swift calls when you call the instance.\n\nFor example, you can open a web site when the user taps a button:\n\nstruct OpenURLExample: View {\n    @Environment(\\.openURL) private var openURL\n\n\n    var body: some View {\n        Button {\n            if let url = URL(string: \"https://www.example.com\") {\n                openURL(url)\n            }\n        } label: {\n            Label(\"Get Help\", systemImage: \"person.fill.questionmark\")\n        }\n    }\n}\n\n\nIf you want to know whether the action succeeds, add a completion handler that takes a Boolean value. In this case, Swift implicitly calls the callAsFunction(_:completion:) method instead. That method calls your completion handler after it determines whether it can open the URL, but possibly before it finishes opening the URL. You can add a handler to the example above so that it prints the outcome to the console:\n\nopenURL(url) { accepted in\n    print(accepted ? \"Success\" : \"Failure\")\n}\n\n\nThe system provides a default open URL action with behavior that depends on the contents of the URL. For example, the default action opens a Universal Link in the associated app if possible, or in the user\u2019s default web browser if not.\n\nYou can also set a custom action using the environment(_:_:) view modifier. Any views that read the action from the environment, including the built-in Link view and Text views with markdown links, or links in attributed strings, use your action. Initialize an action by calling the init(handler:) initializer with a handler that takes a URL and returns an OpenURLAction.Result:\n\nText(\"Visit [Example Company](https://www.example.com) for details.\")\n    .environment(\\.openURL, OpenURLAction { url in\n        handleURL(url) // Define this method to take appropriate action.\n        return .handled\n    })\n\n\nSwiftUI translates the value that your custom action\u2019s handler returns into an appropriate Boolean result for the action call. For example, a view that uses the action declared above receives true when calling the action, because the handler always returns handled.\n\nTopics\nCreating the action\ninit(handler: (URL) -> OpenURLAction.Result)\nCreates an action that opens a URL.\nstruct Result\nThe result of a custom open URL action.\nCalling the action\nfunc callAsFunction(URL)\nOpens a URL, following system conventions.\nfunc callAsFunction(URL, completion: (Bool) -> Void)\nAsynchronously opens a URL, following system conventions.\nSee Also\nHandling URLs\nfunc onOpenURL(perform: (URL) -> ()) -> some View\nRegisters a handler to invoke when the view receives a url for the scene or window the view is in.\nvar openURL: OpenURLAction\nAn action that opens a URL."
    },
    {
        "title": "SnapshotData",
        "url": "https://developer.apple.com/documentation/swiftui/snapshotdata",
        "html": "Topics\nGetting the data\nlet identifier: String?\nThe identifier associated with this snapshot request.\nlet reason: SnapshotData.SnapshotReason\nThe reason for a background snapshot task.\nenum SnapshotReason\nThe reason for a background snapshot task.\nRelationships\nConforms To\nSendable\nSee Also\nHandling background tasks\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some Scene\nRuns the specified action when the system provides a background task.\nstruct BackgroundTask\nThe kinds of background tasks that your app or extension can handle.\nstruct SnapshotResponse\nYour appplication\u2019s response to a snapshot background task."
    },
    {
        "title": "SnapshotResponse",
        "url": "https://developer.apple.com/documentation/swiftui/snapshotresponse",
        "html": "Topics\nCreating a response\ninit(restoredDefaultState: Bool, estimatedSnapshotExpiration: Date?, identifier: String?)\nCreates a snapshot response.\nRelationships\nConforms To\nSendable\nSee Also\nHandling background tasks\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some Scene\nRuns the specified action when the system provides a background task.\nstruct BackgroundTask\nThe kinds of background tasks that your app or extension can handle.\nstruct SnapshotData\nThe associated data of a snapshot background task."
    },
    {
        "title": "accessibilityReduceMotion",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilityreducemotion",
        "html": "Discussion\n\nIf this property\u2019s value is true, UI should avoid large animations, especially those that simulate the third dimension.\n\nSee Also\nMinimizing motion\nvar accessibilityDimFlashingLights: Bool\nWhether the setting to reduce flashing or strobing lights in video content is on. This setting can also be used to determine if UI in playback controls should be shown to indicate upcoming content that includes flashing or strobing lights.\nvar accessibilityPlayAnimatedImages: Bool\nWhether the setting for playing animations in an animated image is on. When this value is false, any presented image that contains animation should not play automatically."
    },
    {
        "title": "openURL",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/openurl",
        "html": "Discussion\n\nRead this environment value to get an OpenURLAction instance for a given Environment. Call the instance to open a URL. You call the instance directly because it defines a callAsFunction(_:) method that Swift calls when you call the instance.\n\nFor example, you can open a web site when the user taps a button:\n\nstruct OpenURLExample: View {\n    @Environment(\\.openURL) private var openURL\n\n\n    var body: some View {\n        Button {\n            if let url = URL(string: \"https://www.example.com\") {\n                openURL(url)\n            }\n        } label: {\n            Label(\"Get Help\", systemImage: \"person.fill.questionmark\")\n        }\n    }\n}\n\n\nIf you want to know whether the action succeeds, add a completion handler that takes a Boolean value. In this case, Swift implicitly calls the callAsFunction(_:completion:) method instead. That method calls your completion handler after it determines whether it can open the URL, but possibly before it finishes opening the URL. You can add a handler to the example above so that it prints the outcome to the console:\n\nopenURL(url) { accepted in\n    print(accepted ? \"Success\" : \"Failure\")\n}\n\n\nThe system provides a default open URL action with behavior that depends on the contents of the URL. For example, the default action opens a Universal Link in the associated app if possible, or in the user\u2019s default web browser if not.\n\nYou can also set a custom action using the environment(_:_:) view modifier. Any views that read the action from the environment, including the built-in Link view and Text views with markdown links, or links in attributed strings, use your action. Initialize an action by calling the init(handler:) initializer with a handler that takes a URL and returns an OpenURLAction.Result:\n\nText(\"Visit [Example Company](https://www.example.com) for details.\")\n    .environment(\\.openURL, OpenURLAction { url in\n        handleURL(url) // Define this method to take appropriate action.\n        return .handled\n    })\n\n\nSwiftUI translates the value that your custom action\u2019s handler returns into an appropriate Boolean result for the action call. For example, a view that uses the action declared above receives true when calling the action, because the handler always returns handled.\n\nSee Also\nHandling URLs\nfunc onOpenURL(perform: (URL) -> ()) -> some View\nRegisters a handler to invoke when the view receives a url for the scene or window the view is in.\nstruct OpenURLAction\nAn action that opens a URL."
    },
    {
        "title": "accessibilityDimFlashingLights",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilitydimflashinglights",
        "html": "See Also\nMinimizing motion\nvar accessibilityPlayAnimatedImages: Bool\nWhether the setting for playing animations in an animated image is on. When this value is false, any presented image that contains animation should not play automatically.\nvar accessibilityReduceMotion: Bool\nWhether the system preference for Reduce Motion is enabled."
    },
    {
        "title": "accessibilityIgnoresInvertColors(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityignoresinvertcolors(_:)",
        "html": "Parameters\nactive\n\nA true value ignores the system Smart Invert setting. A false value follows the system setting.\n\nDiscussion\n\nUse this modifier to suppress Smart Invert in a view that shouldn\u2019t be inverted. Or pass an active argument of false to begin following the Smart Invert setting again when it was previously disabled.\n\nSee Also\nManaging color\nvar accessibilityInvertColors: Bool\nWhether the system preference for Invert Colors is enabled.\nvar accessibilityDifferentiateWithoutColor: Bool\nWhether the system preference for Differentiate without Color is enabled."
    },
    {
        "title": "accessibilityShowButtonShapes",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilityshowbuttonshapes",
        "html": "Discussion\n\nIf this property\u2019s value is true, interactive custom controls such as buttons should be drawn in such a way that their edges and borders are clearly visible.\n\nSee Also\nImproving legibility\nvar accessibilityReduceTransparency: Bool\nWhether the system preference for Reduce Transparency is enabled.\nvar legibilityWeight: LegibilityWeight?\nThe font weight to apply to text.\nenum LegibilityWeight\nThe Accessibility Bold Text user setting options."
    },
    {
        "title": "accessibilityInvertColors",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilityinvertcolors",
        "html": "Discussion\n\nIf this property\u2019s value is true then the display will be inverted. In these cases it may be needed for UI drawing to be adjusted to in order to display optimally when inverted.\n\nSee Also\nManaging color\nfunc accessibilityIgnoresInvertColors(Bool) -> some View\nSets whether this view should ignore the system Smart Invert setting.\nvar accessibilityDifferentiateWithoutColor: Bool\nWhether the system preference for Differentiate without Color is enabled."
    },
    {
        "title": "accessibilityLargeContentViewerEnabled",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilitylargecontentviewerenabled",
        "html": "Discussion\n\nThe system can automatically provide a large content view with accessibilityShowsLargeContentViewer() or you can provide your own with accessibilityShowsLargeContentViewer(_:).\n\nWhile it is not necessary to check this value before adding a large content view, it may be helpful if you need to adjust the behavior of a gesture. For example, a button with a long press handler might increase its long press duration so the user can read the text in the large content viewer first.\n\nSee Also\nEnlarging content\nfunc accessibilityShowsLargeContentViewer() -> some View\nAdds a default large content view to be shown by the large content viewer.\nfunc accessibilityShowsLargeContentViewer<V>(() -> V) -> some View\nAdds a custom large content view to be shown by the large content viewer."
    },
    {
        "title": "accessibilityShowsLargeContentViewer(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityshowslargecontentviewer(_:)",
        "html": "Discussion\n\nRely on the large content viewer only in situations where items must remain small due to unavoidable design constraints. For example, buttons in a tab bar remain small to leave more room for the main app content.\n\nThe following example shows how to add a custom large content view:\n\nvar body: some View {\n    Button(action: newMessage) {\n        Image(systemName: \"plus\")\n    }\n    .accessibilityShowsLargeContentViewer {\n        Label(\"New Message\", systemImage: \"plus\")\n    }\n}\n\n\nDon\u2019t use the large content viewer as a replacement for proper Dynamic Type support. For example, Dynamic Type allows items in a list to grow or shrink vertically to accommodate the user\u2019s preferred font size. Rely on the large content viewer only in situations where items must remain small due to unavoidable design constraints.\n\nFor example, views that have their Dynamic Type size constrained with dynamicTypeSize(_:) or dynamicTypeSize(_:) may require a large content view.\n\nSee Also\nEnlarging content\nfunc accessibilityShowsLargeContentViewer() -> some View\nAdds a default large content view to be shown by the large content viewer.\nvar accessibilityLargeContentViewerEnabled: Bool\nWhether the Large Content Viewer is enabled."
    },
    {
        "title": "legibilityWeight",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/legibilityweight",
        "html": "Discussion\n\nThis value reflects the value of the Bold Text display setting found in the Accessibility settings.\n\nSee Also\nImproving legibility\nvar accessibilityShowButtonShapes: Bool\nWhether the system preference for Show Button Shapes is enabled.\nvar accessibilityReduceTransparency: Bool\nWhether the system preference for Reduce Transparency is enabled.\nenum LegibilityWeight\nThe Accessibility Bold Text user setting options."
    },
    {
        "title": "copyable(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/copyable(_:)",
        "html": "Parameters\npayload\n\nA closure that returns an array of items to copy to the Clipboard when someone issues a Copy command. The items in the array must conform to the Transferable protocol.\n\nReturn Value\n\nA view that adds one or more items to the Clipboard in response to a Copy command.\n\nDiscussion\n\nUse this modifier to specify one or more items that the system copies to the Clipboard when someone issues a Copy command while the modified view has focus. People issue a Copy command by choosing Edit > Copy from the app\u2019s menu, or by using the Command-C keyboard shortcut. The system enables the Copy command for your app when it detects copyable content.\n\nFor example, the following code enables people to copy all of the strings that they select in a List:\n\nstruct CopyableExample: View {\n    let strings = [\"Alpha\", \"Beta\", \"Gamma\"]\n    @State private var selection: Set<String> = []\n\n\n    var body: some View {\n        List(strings, id: \\.self, selection: $selection) {\n            Text($0)\n        }\n        .copyable(Array(selection))\n    }\n}\n\n\nThe command copies each item\u2019s representation as specified by the item\u2019s conformance to the Transferable protocol. The above example records selection using each list item\u2019s corresponding string, and strings conform to the Transferable protocol by default. For more complex cases, you might need to take additional steps.\n\nFor example, the following code displays colors composed from a list of Item instances that contain both a color and its name, as well as an identifier. The list manages selection using item identifiers:\n\nstruct Item: Identifiable, Transferable {\n    let color: Color\n    let name: String\n    let id = UUID()\n\n\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation(exporting: \\.name)\n    }\n}\n\n\nstruct CopyableIDExample: View {\n    let items: [Item] = [\n        Item(color: .red, name: \"red\"),\n        Item(color: .green, name: \"green\"),\n        Item(color: .blue, name: \"blue\")\n    ]\n\n\n    @State private var selection: Set<Item.ID> = []\n\n\n    var body: some View {\n        List(items, selection: $selection) { item in\n            item.color\n        }\n        .copyable(items.filter { selection.contains($0.id) })\n    }\n}\n\n\nThis example does two things that the previous example didn\u2019t have to:\n\nIt converts the list of selected item identifiers into a list of selected items for use with the copyable modifier.\n\nIt ensures that the copyable items conform to the Transferable protocol, using the item\u2019s name property as the representation.\n\nWhen someone copies the first item in the list, which appears in the interface as a red rectangle, and then pastes into a text editor, they get the string \u201cred\u201d.\n\nNote\n\nTo enable people to copy using a custom action \u2014 like from a context menu item \u2014 rather than using the system Copy command, update the Clipboard directly using an NSPasteboard or a UIPasteboard instance.\n\nSee Also\nCopying transferable items\nfunc cuttable<T>(for: T.Type, action: () -> [T]) -> some View\nSpecifies an action that moves items to the Clipboard in response to the system\u2019s Cut command.\nfunc pasteDestination<T>(for: T.Type, action: ([T]) -> Void, validator: ([T]) -> [T]) -> some View\nSpecifies an action that adds validated items to a view in response to the system\u2019s Paste command."
    },
    {
        "title": "LegibilityWeight",
        "url": "https://developer.apple.com/documentation/swiftui/legibilityweight",
        "html": "Overview\n\nThe app can\u2019t override the user\u2019s choice before iOS 16, tvOS 16 or watchOS 9.0.\n\nTopics\nGetting weights\ncase regular\nUse regular font weight (no Accessibility Bold).\ncase bold\nUse heavier font weight (force Accessibility Bold).\nCreating a weight\ninit?(UILegibilityWeight)\nCreates a legibility weight from its UILegibilityWeight equivalent.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nImproving legibility\nvar accessibilityShowButtonShapes: Bool\nWhether the system preference for Show Button Shapes is enabled.\nvar accessibilityReduceTransparency: Bool\nWhether the system preference for Reduce Transparency is enabled.\nvar legibilityWeight: LegibilityWeight?\nThe font weight to apply to text."
    },
    {
        "title": "accessibilityPlayAnimatedImages",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilityplayanimatedimages",
        "html": "See Also\nMinimizing motion\nvar accessibilityDimFlashingLights: Bool\nWhether the setting to reduce flashing or strobing lights in video content is on. This setting can also be used to determine if UI in playback controls should be shown to indicate upcoming content that includes flashing or strobing lights.\nvar accessibilityReduceMotion: Bool\nWhether the system preference for Reduce Motion is enabled."
    },
    {
        "title": "onCopyCommand(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/oncopycommand(perform:)",
        "html": "Parameters\npayloadAction\n\nAn action closure returning the NSItemProvider items that should be copied to the Clipboard when the Copy command is triggered. If action is nil, the Copy command is considered disabled.\n\nReturn Value\n\nA view that triggers action when a system Copy command occurs.\n\nSee Also\nCopying items using item providers\nfunc onCutCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Cut command.\nfunc onPasteCommand(of: [UTType], perform: ([NSItemProvider]) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command.\nfunc onPasteCommand<Payload>(of: [UTType], validator: ([NSItemProvider]) -> Payload?, perform: (Payload) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command with items that you validate."
    },
    {
        "title": "accessibilityReduceTransparency",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/accessibilityreducetransparency",
        "html": "Discussion\n\nIf this property\u2019s value is true, UI (mainly window) backgrounds should not be semi-transparent; they should be opaque.\n\nSee Also\nImproving legibility\nvar accessibilityShowButtonShapes: Bool\nWhether the system preference for Show Button Shapes is enabled.\nvar legibilityWeight: LegibilityWeight?\nThe font weight to apply to text.\nenum LegibilityWeight\nThe Accessibility Bold Text user setting options."
    },
    {
        "title": "onPasteCommand(of:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onpastecommand(of:perform:)-9s227",
        "html": "Parameters\nsupportedContentTypes\n\nThe uniform type identifiers that describe the types of content this view can accept through a paste action. If the Clipboard doesn\u2019t contain any of the supported types, the Paste command doesn\u2019t trigger.\n\npayloadAction\n\nThe action to perform when the Paste command triggers. The action closure\u2019s parameter contains items from the Clipboard with the types you specify in the supportedContentTypes parameter.\n\nReturn Value\n\nA view that triggers action when a system Paste command occurs.\n\nDiscussion\n\nPass an array of uniform type identifiers to the supportedContentTypes parameter. Place the higher priority types closer to the beginning of the array. The Clipboard items that the action closure receives have the most preferred type out of all the types the source supports.\n\nFor example, if your app can handle plain text and rich text, but you prefer rich text, place the rich text type first in the array. If rich text is available when the paste action occurs, the action closure passes that rich text along.\n\nSee Also\nCopying items using item providers\nfunc onCopyCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Copy command.\nfunc onCutCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Cut command.\nfunc onPasteCommand<Payload>(of: [UTType], validator: ([NSItemProvider]) -> Payload?, perform: (Payload) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command with items that you validate."
    },
    {
        "title": "pasteDestination(for:action:validator:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/pastedestination(for:action:validator:)",
        "html": "Parameters\npayloadType\n\nThe type of data that the paste destination accepts. The type must conform to the Transferable protocol.\n\naction\n\nThe action to perform when someone uses the system\u2019s Paste command to paste one or more items of the payload type. The closure takes one parameter, which is the array of items to paste.\n\nvalidator\n\nA closure that you implement to validate the data to paste. SwiftUI calls this before it calls the action closure, and passes in an array of items to validate. Inspect the items, and return an array that includes only those from the input array that you consider valid. The array that you return from this closure becomes the input to the action closure. If you return an empty array, SwiftUI doesn\u2019t call the action closure.\n\nReturn Value\n\nA view that people can paste into using the system Paste command.\n\nDiscussion\n\nUse this modifier to paste one or more items into a view from the Clipboard when someone issues a Paste command. People issue a Paste command by choosing Edit > Paste from the app\u2019s menu, or by using the Command-V keyboard shortcut. The system enables the Paste command for your app when the view in focus provides a paste destination.\n\nFor example, the following code enables people to paste bird names into a list:\n\nstruct PasteDestinationExample: View {\n    @State private var birds: [String] = []\n    @State private var selection: Set<String> = []\n\n\n    let knownBirds = [\"owl\", \"parrot\", \"swift\",\n                      \"sparrow\", \"robin\", \"bluebird\"]\n\n\n    var body: some View {\n        List(birds, id: \\.self, selection: $selection) {\n            Text($0)\n        }\n        .pasteDestination(for: String.self) { values in\n            birds.append(contentsOf: values)\n        } validator: { values in\n            values.filter { knownBirds.contains($0) }\n        }\n    }\n}\n\n\nThe paste destination handles only pasted content with a type that matches the payloadType that you specify. The list in the above example only accepts strings.\n\nUse the validator closure to restrict the pasted content to items that make sense in the context of the view. The above example allows people to paste only strings that match one of a known list of bird names because the list is meant to contain only birds. You can omit the final closure if you don\u2019t need to perform any validation.\n\nNote\n\nTo enable people to paste using a custom action \u2014 like from a context menu item \u2014 rather than using the system Paste command, access the Clipboard directly using an NSPasteboard or a UIPasteboard instance.\n\nSee Also\nCopying transferable items\nfunc copyable<T>(() -> [T]) -> some View\nSpecifies a list of items to copy in response to the system\u2019s Copy command.\nfunc cuttable<T>(for: T.Type, action: () -> [T]) -> some View\nSpecifies an action that moves items to the Clipboard in response to the system\u2019s Cut command."
    },
    {
        "title": "draggable(_:preview:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/draggable(_:preview:)",
        "html": "Parameters\npayload\n\nA closure that returns a single class instance or a value conforming to Transferable that represents the draggable data from this view.\n\npreview\n\nA View to use as the source for the dragging preview, once the drag operation has begun. The preview is centered over the source view.\n\nReturn Value\n\nA view that activates this view as the source of a drag and drop operation, beginning with user gesture input.\n\nDiscussion\n\nApplying the draggable(_:preview:) modifier adds the appropriate gestures for drag and drop to this view. When a drag operation begins, a rendering of preview is generated and used as the preview image.\n\nvar title: String\nvar body: some View {\n    Color.pink\n        .frame(width: 400, height: 400)\n        .draggable(title) {\n             Text(\"Drop me\")\n         }\n}\n\nSee Also\nMoving transferable items\nfunc draggable<T>(() -> T) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc dropDestination<T>(for: T.Type, action: ([T], CGPoint) -> Bool, isTargeted: (Bool) -> Void) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify."
    },
    {
        "title": "draggable(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/draggable(_:)",
        "html": "Parameters\npayload\n\nA closure that returns a single instance or a value conforming to Transferable that represents the draggable data from this view.\n\nReturn Value\n\nA view that activates this view as the source of a drag and drop operation, beginning with user gesture input.\n\nDiscussion\n\nApplying the draggable(_:) modifier adds the appropriate gestures for drag and drop to this view. When a drag operation begins, a rendering of this view is generated and used as the preview image.\n\nSee Also\nMoving transferable items\nfunc draggable<V, T>(() -> T, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc dropDestination<T>(for: T.Type, action: ([T], CGPoint) -> Bool, isTargeted: (Bool) -> Void) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify."
    },
    {
        "title": "cuttable(for:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/cuttable(for:action:)",
        "html": "Parameters\npayloadType\n\nThe type of items to cut.\n\naction\n\nA closure that you implement to delete the selected items from the collection, and return them for addition to the Clipboard. The items must conform to the Transferable protocol.\n\nReturn Value\n\nA view that sends one or more items to the Clipboard in response to a Cut command.\n\nDiscussion\n\nUse this modifier to remove one or more items from a collection of items and then move the items to the Clipboard when someone issues a Cut command. People issue a Cut command by choosing Edit > Cut from the app\u2019s menu, or by using the Command-X keyboard shortcut. The system enables the Cut command for your app when it detects cuttable content.\n\nFor example, the following code enables people to remove bird names from a list of birds:\n\nstruct CuttableExample: View {\n    @State private var birds = [\"owl\", \"parrot\", \"swift\"]\n    @State private var selection: Set<String> = []\n\n\n    var body: some View {\n        List(birds, id: \\.self, selection: $selection) {\n            Text($0)\n        }\n        .cuttable(for: String.self) {\n            for bird in selection {\n                birds.removeAll(where: { $0 == bird })\n            }\n            return Array(selection)\n        }\n    }\n}\n\n\nWhen someone selects \u201cowl\u201d and issues a Cut command, the action closure removes the selected item from the list and returns it. In response, SwiftUI moves it to the Clipboard. If you want to copy the item without removing it, use the copyable(_:) modifier instead.\n\nNote\n\nTo enable people to cut using a custom action \u2014 like from a context menu item \u2014 rather than using the system Cut command, update the Clipboard directly using an NSPasteboard or a UIPasteboard instance.\n\nSee Also\nCopying transferable items\nfunc copyable<T>(() -> [T]) -> some View\nSpecifies a list of items to copy in response to the system\u2019s Copy command.\nfunc pasteDestination<T>(for: T.Type, action: ([T]) -> Void, validator: ([T]) -> [T]) -> some View\nSpecifies an action that adds validated items to a view in response to the system\u2019s Paste command."
    },
    {
        "title": "onCutCommand(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/oncutcommand(perform:)",
        "html": "Parameters\npayloadAction\n\nAn action closure that should delete the selected data and return NSItemProvider items corresponding to that data, which should be written to the Clipboard. If action is nil, the Cut command is considered disabled.\n\nReturn Value\n\nA view that triggers action when a system Cut command occurs.\n\nSee Also\nCopying items using item providers\nfunc onCopyCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Copy command.\nfunc onPasteCommand(of: [UTType], perform: ([NSItemProvider]) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command.\nfunc onPasteCommand<Payload>(of: [UTType], validator: ([NSItemProvider]) -> Payload?, perform: (Payload) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command with items that you validate."
    },
    {
        "title": "TableColumn",
        "url": "https://developer.apple.com/documentation/swiftui/tablecolumn",
        "html": "Overview\n\nYou create a column with a label, content view, and optional key path. The table calls the content view builder with the value for each row in the table. The column uses a key path to map to a property of each row value, which sortable tables use to reflect the current sort order.\n\nThe following example creates a sortable column for a table with Person rows, displaying each person\u2019s given name:\n\nTableColumn(\"Given name\", value: \\.givenName) { person in\n    Text(person.givenName)\n}\n\n\nFor the common case of String properties, you can use the convenience initializer that doesn\u2019t require an explicit content closure and displays that string verbatim as a Text view. This means you can write the previous example as:\n\nTableColumn(\"Given name\", value: \\.givenName)\n\nTopics\nCreating an unsortable column\ninit(LocalizedStringKey, value: KeyPath<RowValue, String>)\nCreates an unsortable column that displays a string property that generates its label from a localized string key.\nAvailable when RowValue conforms to Identifiable, Sort is Never, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, String>)\nCreates an unsortable column that displays a string property that generates its label from a string.\nAvailable when RowValue conforms to Identifiable, Sort is Never, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, String>)\nCreates an unsortable column that displays a string property with a text label.\nAvailable when RowValue conforms to Identifiable, Sort is Never, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, content: (RowValue) -> Content)\nCreates an unsortable column that generates its label from a localized string key.\nAvailable when RowValue conforms to Identifiable, Sort is Never, Content conforms to View, and Label is Text.\ninit<S>(S, content: (RowValue) -> Content)\nCreates an unsortable column that generates its label from a string.\nAvailable when RowValue conforms to Identifiable, Sort is Never, Content conforms to View, and Label is Text.\ninit(Text, content: (RowValue) -> Content)\nCreates an unsortable column with a text label\nAvailable when RowValue conforms to Identifiable, Sort is Never, Content conforms to View, and Label is Text.\nCreating a column with strings\ninit(LocalizedStringKey, value: KeyPath<RowValue, String>, comparator: String.StandardComparator)\nCreates a sortable column that displays a string property, and generates its label from a localized string key.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, String>, comparator: String.StandardComparator)\nCreates a sortable column that displays a string property, and generates its label from a string.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, String>, comparator: String.StandardComparator)\nCreates a sortable column that displays a string property and has a text label.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, String>, comparator: String.StandardComparator)\nCreates an unsortable column that displays a string property, and which generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, String>, comparator: String.StandardComparator)\nCreates a sortable column that displays a string property, and which generates its label from a string.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, String>, comparator: String.StandardComparator)\nCreates an unsortable column that displays a string property and has a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, String>, comparator: String.StandardComparator, content: (RowValue) -> Content)\nCreates a sortable column that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, String>, comparator: String.StandardComparator, content: (RowValue) -> Content)\nCreates a sortable column that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, String>, comparator: String.StandardComparator, content: (RowValue) -> Content)\nCreates a sortable column with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, String?>, comparator: String.StandardComparator, content: (RowValue) -> Content)\nCreates a sortable column that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, String?>, comparator: String.StandardComparator, content: (RowValue) -> Content)\nCreates a sortable column that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, String?>, comparator: String.StandardComparator, content: (RowValue) -> Content)\nCreates a sortable column with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with integers\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int>, content: (RowValue) -> Content)\nCreates a sortable column for integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int>, content: (RowValue) -> Content)\nCreates a sortable column for integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int>, content: (RowValue) -> Content)\nCreates a sortable column for integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int?>, content: (RowValue) -> Content)\nCreates a sortable column for optional integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int?>, content: (RowValue) -> Content)\nCreates a sortable column for optional integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int?>, content: (RowValue) -> Content)\nCreates a sortable column for optional integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with 64-bit integers\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int64>, content: (RowValue) -> Content)\nCreates a sortable column for 64-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int64>, content: (RowValue) -> Content)\nCreates a sortable column for 64-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int64>, content: (RowValue) -> Content)\nCreates a sortable column for 64-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int64?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 64-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int64?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 64-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int64?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 64-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt64>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 64-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt64>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 64-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt64>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 64-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt64?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 64-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt64?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 64-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt64?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 64-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with 32-bit integers\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int32>, content: (RowValue) -> Content)\nCreates a sortable column for 32-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int32>, content: (RowValue) -> Content)\nCreates a sortable column for 32-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int32>, content: (RowValue) -> Content)\nCreates a sortable column for 32-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int32?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 32-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int32?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 32-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int32?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 32-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt32>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 32-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt32>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 32-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt32>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 32-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt32?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 32-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt32?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 32-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt32?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 32-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with 16-bit integers\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int16>, content: (RowValue) -> Content)\nCreates a sortable column for 16-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int16>, content: (RowValue) -> Content)\nCreates a sortable column for 16-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int16>, content: (RowValue) -> Content)\nCreates a sortable column for 16-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int16?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 16-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int16?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 16-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int16?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 16-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt16>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 16-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt16>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 16-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt16>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 16-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt16?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 16-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt16?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 16-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt16?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 16-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with 8-bit integers\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int8>, content: (RowValue) -> Content)\nCreates a sortable column for 8-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int8>, content: (RowValue) -> Content)\nCreates a sortable column for 8-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int8>, content: (RowValue) -> Content)\nCreates a sortable column for 8-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Int8?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 8-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Int8?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 8-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Int8?>, content: (RowValue) -> Content)\nCreates a sortable column for optional 8-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt8>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 8-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt8>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 8-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt8>, content: (RowValue) -> Content)\nCreates a sortable column for unsigned 8-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UInt8?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 8-bit integer values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UInt8?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 8-bit integer values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UInt8?>, content: (RowValue) -> Content)\nCreates a sortable column for optional unsigned 8-bit integer values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with Booleans\ninit(LocalizedStringKey, value: KeyPath<RowValue, Bool>, content: (RowValue) -> Content)\nCreates a sortable column for Boolean values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Bool>, content: (RowValue) -> Content)\nCreates a sortable column for Boolean values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Bool>, content: (RowValue) -> Content)\nCreates a sortable column for Boolean values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Bool?>, content: (RowValue) -> Content)\nCreates a sortable column for optional Boolean values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Bool?>, content: (RowValue) -> Content)\nCreates a sortable column for optional Boolean values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Bool?>, content: (RowValue) -> Content)\nCreates a sortable column for optional Boolean values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with floats\ninit(LocalizedStringKey, value: KeyPath<RowValue, Float>, content: (RowValue) -> Content)\nCreates a sortable column for single-precision floating-point values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Float>, content: (RowValue) -> Content)\nCreates a sortable column for single-precision floating-point values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Float>, content: (RowValue) -> Content)\nCreates a sortable column for single-precision floating-point values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Float?>, content: (RowValue) -> Content)\nCreates a sortable column for optional single-precision floating-point values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Float?>, content: (RowValue) -> Content)\nCreates a sortable column for optional single-precision floating-point values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Float?>, content: (RowValue) -> Content)\nCreates a sortable column for optional single-precision floating-point values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with doubles\ninit(LocalizedStringKey, value: KeyPath<RowValue, Double>, content: (RowValue) -> Content)\nCreates a sortable column for double-precision floating-point values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Double>, content: (RowValue) -> Content)\nCreates a sortable column for double-precision floating-point values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Double>, content: (RowValue) -> Content)\nCreates a sortable column for double-precision floating-point values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Double?>, content: (RowValue) -> Content)\nCreates a sortable column for optional double-precision floating-point values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Double?>, content: (RowValue) -> Content)\nCreates a sortable column for optional double-precision floating-point values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Double?>, content: (RowValue) -> Content)\nCreates a sortable column for optional double-precision floating-point values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with dates\ninit(LocalizedStringKey, value: KeyPath<RowValue, Date>, content: (RowValue) -> Content)\nCreates a sortable column for date values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Date>, content: (RowValue) -> Content)\nCreates a sortable column for date values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Date>, content: (RowValue) -> Content)\nCreates a sortable column for date values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, Date?>, content: (RowValue) -> Content)\nCreates a sortable column for optional date values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, Date?>, content: (RowValue) -> Content)\nCreates a sortable column for optional date values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, Date?>, content: (RowValue) -> Content)\nCreates a sortable column for optional date values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with UUIDs\ninit(LocalizedStringKey, value: KeyPath<RowValue, UUID>, content: (RowValue) -> Content)\nCreates a sortable column for UUID values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UUID>, content: (RowValue) -> Content)\nCreates a sortable column for UUID values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UUID>, content: (RowValue) -> Content)\nCreates a sortable column for UUID values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(LocalizedStringKey, value: KeyPath<RowValue, UUID?>, content: (RowValue) -> Content)\nCreates a sortable column for optional UUID values that generates its label from a localized string key.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit<S>(S, value: KeyPath<RowValue, UUID?>, content: (RowValue) -> Content)\nCreates a sortable column for optional UUID values that displays a string property.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\ninit(Text, value: KeyPath<RowValue, UUID?>, content: (RowValue) -> Content)\nCreates a sortable column for optional UUID values with a text label.\nAvailable when RowValue inherits NSObject, RowValue conforms to Identifiable, Sort is SortDescriptor<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with comparable values\ninit<V>(LocalizedStringKey, value: KeyPath<RowValue, V>, content: (RowValue) -> Content)\nCreates a sortable column for comparable values that generates its label from a localized string key.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit<S, V>(S, value: KeyPath<RowValue, V>, content: (RowValue) -> Content)\nCreates a sortable column for comparable values that generates its label from a string.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit<V>(Text, value: KeyPath<RowValue, V>, content: (RowValue) -> Content)\nCreates a sortable column for comparable values with a text label.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit<V, C>(LocalizedStringKey, value: KeyPath<RowValue, V>, comparator: C, content: (RowValue) -> Content)\nCreates a sortable column that generates its label from a localized string key, and uses an explicit comparator for sorting values.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit<S, V, C>(S, value: KeyPath<RowValue, V>, comparator: C, content: (RowValue) -> Content)\nCreates a sortable column that generates its label from a string, and uses an explicit comparator for sorting values.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\ninit<V, C>(Text, value: KeyPath<RowValue, V>, comparator: C, content: (RowValue) -> Content)\nCreates a sortable column that has a text label, and uses an explicit comparator for sorting values.\nAvailable when RowValue conforms to Identifiable, Sort is KeyPathComparator<RowValue>, Content conforms to View, and Label is Text.\nCreating a column with a comparator\ninit(LocalizedStringKey, sortUsing: Sort, content: (RowValue) -> Content)\nCreates a sortable column that generates its label from a localized string key.\nAvailable when RowValue conforms to Identifiable, RowValue is Sort.Compared, Sort conforms to SortComparator, Content conforms to View, and Label is Text.\ninit<S>(S, sortUsing: Sort, content: (RowValue) -> Content)\nCreates a sortable column that generates its label from a string.\nAvailable when RowValue conforms to Identifiable, RowValue is Sort.Compared, Sort conforms to SortComparator, Content conforms to View, and Label is Text.\ninit(Text, sortUsing: Sort, content: (RowValue) -> Content)\nCreates a sortable column with text label.\nAvailable when RowValue conforms to Identifiable, RowValue is Sort.Compared, Sort conforms to SortComparator, Content conforms to View, and Label is Text.\nSetting the column width\nfunc width(CGFloat?) -> TableColumn<RowValue, Sort, Content, Label>\nCreates a fixed width table column that isn\u2019t user resizable.\nAvailable when RowValue conforms to Identifiable, Sort conforms to SortComparator, Content conforms to View, and Label conforms to View.\nfunc width(min: CGFloat?, ideal: CGFloat?, max: CGFloat?) -> TableColumn<RowValue, Sort, Content, Label>\nCreates a resizable table column with the provided constraints.\nAvailable when RowValue conforms to Identifiable, Sort conforms to SortComparator, Content conforms to View, and Label conforms to View.\nfunc width() -> TableColumn<RowValue, Sort, Content, Label>\nSets the column\u2019s width.\nAvailable when RowValue conforms to Identifiable, Sort conforms to SortComparator, Content conforms to View, and Label conforms to View.\nDeprecated\nRelationships\nConforms To\nTableColumnContent\nSee Also\nCreating columns\nprotocol TableColumnContent\nA type used to represent columns within a table.\nstruct TableColumnAlignment\nDescribes the alignment of the content of a table column.\nstruct TableColumnBuilder\nA result builder that creates table column content from closures."
    },
    {
        "title": "onPasteCommand(of:validator:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onpastecommand(of:validator:perform:)-4r73j",
        "html": "Parameters\nsupportedContentTypes\n\nThe uniform type identifiers that describe the types of content this view can accept through a paste action. If the Clipboard doesn\u2019t contain any of the supported types, the Paste command doesn\u2019t trigger.\n\nvalidator\n\nA handler that validates the command. This handler receives items from the Clipboard with the types you specify in the supportedContentTypes. Use this handler to decide whether the items are valid and preprocess them for the action closure. If you return nil instead, the Paste command doesn\u2019t trigger.\n\npayloadAction\n\nThe action to perform when the Paste command triggers.\n\nReturn Value\n\nA view that triggers action when the system Paste command is invoked, validating the Paste command with validator.\n\nDiscussion\n\nPass an array of uniform type identifiers to the supportedContentTypes parameter. Place the higher priority types closer to the beginning of the array. The Clipboard items that the validator closure receives have the most preferred type out of all the types the source supports.\n\nFor example, if your app can handle plain text and rich text, but you prefer rich text, place the rich text type first in the array. If rich text is available when the paste action occurs, the validator closure passes that rich text along.\n\nSee Also\nCopying items using item providers\nfunc onCopyCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Copy command.\nfunc onCutCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Cut command.\nfunc onPasteCommand(of: [UTType], perform: ([NSItemProvider]) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command."
    },
    {
        "title": "dropDestination(for:action:isTargeted:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dropdestination(for:action:istargeted:)",
        "html": "Parameters\npayloadType\n\nThe expected type of the dropped models.\n\naction\n\nA closure that takes the dropped content and responds appropriately. The first parameter to action contains the dropped items. The second parameter contains the drop location in this view\u2019s coordinate space. Return true if the drop operation was successful; otherwise, return false.\n\nisTargeted\n\nA closure that is called when a drag and drop operation enters or exits the drop target area. The received value is true when the cursor is inside the area, and false when the cursor is outside.\n\nReturn Value\n\nA view that provides a drop destination for a drag operation of the specified type.\n\nDiscussion\n\nThe dropped content can be provided as binary data, file URLs, or file promises.\n\nThe drop destination is the same size and position as this view.\n\n@State private var isDropTargeted = false\n\n\nvar body: some View {\n    Color.pink\n        .frame(width: 400, height: 400)\n        .dropDestination(for: String.self) { receivedTitles, location in\n            animateDrop(at: location)\n            process(titles: receivedTitles)\n        } isTargeted: {\n            isDropTargeted = $0\n        }\n}\n\n\nfunc process(titles: [String]) { ... }\nfunc animateDrop(at: CGPoint) { ... }\n\nSee Also\nMoving transferable items\nfunc draggable<T>(() -> T) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc draggable<V, T>(() -> T, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation."
    },
    {
        "title": "itemProvider(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/itemprovider(_:)",
        "html": "See Also\nMoving items using item providers\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "onDrag(_:preview:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ondrag(_:preview:)",
        "html": "Parameters\ndata\n\nA closure that returns a single NSItemProvider that represents the draggable data from this view.\n\npreview\n\nA View to use as the source for the dragging preview, once the drag operation has begun. The preview is centered over the source view.\n\nReturn Value\n\nA view that activates this view as the source of a drag-and- drop operation, beginning with user gesture input.\n\nDiscussion\n\nApplying the onDrag(_:preview:) modifier adds the appropriate gestures for drag and drop to this view. When a drag operation begins, a rendering of preview is generated and used as the preview image.\n\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "Table",
        "url": "https://developer.apple.com/documentation/swiftui/table",
        "html": "Overview\n\nYou commonly create tables from collections of data. The following example shows how to create a simple, three-column table from an array of Person instances that conform to the Identifiable protocol:\n\nstruct Person: Identifiable {\n    let givenName: String\n    let familyName: String\n    let emailAddress: String\n    let id = UUID()\n\n\n    var fullName: String { givenName + \" \" + familyName }\n}\n\n\n@State private var people = [\n    Person(givenName: \"Juan\", familyName: \"Chavez\", emailAddress: \"juanchavez@icloud.com\"),\n    Person(givenName: \"Mei\", familyName: \"Chen\", emailAddress: \"meichen@icloud.com\"),\n    Person(givenName: \"Tom\", familyName: \"Clark\", emailAddress: \"tomclark@icloud.com\"),\n    Person(givenName: \"Gita\", familyName: \"Kumar\", emailAddress: \"gitakumar@icloud.com\")\n]\n\n\nstruct PeopleTable: View {\n    var body: some View {\n        Table(people) {\n            TableColumn(\"Given Name\", value: \\.givenName)\n            TableColumn(\"Family Name\", value: \\.familyName)\n            TableColumn(\"E-Mail Address\", value: \\.emailAddress)\n        }\n    }\n}\n\n\nIf there are more rows than can fit in the available space, Table provides vertical scrolling automatically. On macOS, the table also provides horizontal scrolling if there are more columns than can fit in the width of the view. Scroll bars appear as needed on iOS; on macOS, the Table shows or hides scroll bars based on the \u201cShow scroll bars\u201d system preference.\n\nSupporting selection in tables\n\nTo make rows of a table selectable, provide a binding to a selection variable. Binding to a single instance of the table data\u2019s id type creates a single-selection table. Binding to a Set creates a table that supports multiple selections. The following example shows how to add multi-select to the previous example. A Text view below the table shows the number of items currently selected.\n\nstruct SelectableTable: View {\n    @State private var selectedPeople = Set<Person.ID>()\n\n\n    var body: some View {\n        Table(people, selection: $selectedPeople) {\n            TableColumn(\"Given Name\", value: \\.givenName)\n            TableColumn(\"Family Name\", value: \\.familyName)\n            TableColumn(\"E-Mail Address\", value: \\.emailAddress)\n        }\n        Text(\"\\(selectedPeople.count) people selected\")\n    }\n}\n\nSupporting sorting in tables\n\nTo make the columns of a table sortable, provide a binding to an array of SortComparator instances. The table reflects the sorted state through its column headers, allowing sorting for any columns with key paths.\n\nWhen the table sort descriptors update, re-sort the data collection that underlies the table; the table itself doesn\u2019t perform a sort operation. You can watch for changes in the sort descriptors by using a onChange(of:perform:) modifier, and then sort the data in the modifier\u2019s perform closure.\n\nThe following example shows how to add sorting capability to the previous example:\n\nstruct SortableTable: View {\n    @State private var sortOrder = [KeyPathComparator(\\Person.givenName)]\n\n\n    var body: some View {\n        Table(people, sortOrder: $sortOrder) {\n            TableColumn(\"Given Name\", value: \\.givenName)\n            TableColumn(\"Family Name\", value: \\.familyName)\n            TableColumn(\"E-Mail address\", value: \\.emailAddress)\n        }\n        .onChange(of: sortOrder) { _, sortOrder in\n            people.sort(using: sortOrder)\n        }\n    }\n}\n\nBuilding tables with static rows\n\nTo create a table from static rows, rather than the contents of a collection of data, you provide both the columns and the rows.\n\nThe following example shows a table that calculates prices from applying varying gratuities (\u201ctips\u201d) to a fixed set of prices. It creates the table with the init(of:columns:rows:) initializer, with the rows parameter providing the base price that each row uses for its calculations. Each column receives each price and performs its calculation, producing a Text to display the formatted result.\n\nstruct Purchase: Identifiable {\n    let price: Decimal\n    let id = UUID()\n}\n\n\nstruct TipTable: View {\n    let currencyStyle = Decimal.FormatStyle.Currency(code: \"USD\")\n\n\n    var body: some View {\n        Table(of: Purchase.self) {\n            TableColumn(\"Base price\") { purchase in\n                Text(purchase.price, format: currencyStyle)\n            }\n            TableColumn(\"With 15% tip\") { purchase in\n                Text(purchase.price * 1.15, format: currencyStyle)\n            }\n            TableColumn(\"With 20% tip\") { purchase in\n                Text(purchase.price * 1.2, format: currencyStyle)\n            }\n            TableColumn(\"With 25% tip\") { purchase in\n                Text(purchase.price * 1.25, format: currencyStyle)\n            }\n        } rows: {\n            TableRow(Purchase(price: 20))\n            TableRow(Purchase(price: 50))\n            TableRow(Purchase(price: 75))\n        }\n    }\n}\n\n\nStyling tables\n\nUse the tableStyle(_:) modifier to set a TableStyle for all tables within a view. SwiftUI provides several table styles, such as InsetTableStyle and, on macOS, BorderedTableStyle. The default style is AutomaticTableStyle, which is available on all platforms that support Table.\n\nUsing tables on different platforms\n\nYou can define a single table for use on macOS, iOS, and iPadOS. However, in a compact horizontal size class environment \u2014 typical on iPhone or on iPad in certain modes, like Slide Over \u2014 the table has limited space to display its columns. To conserve space, the table automatically hides headers and all columns after the first when it detects this condition.\n\nTo provide a good user experience in a space-constrained environment, you can customize the first column to show more information when you detect that the horizontalSizeClass environment value becomes UserInterfaceSizeClass.compact. For example, you can modify the sortable table from above to conditionally show all the information in the first column:\n\nstruct CompactableTable: View {\n    #if os(iOS)\n    @Environment(\\.horizontalSizeClass) private var horizontalSizeClass\n    private var isCompact: Bool { horizontalSizeClass == .compact }\n    #else\n    private let isCompact = false\n    #endif\n\n\n    @State private var sortOrder = [KeyPathComparator(\\Person.givenName)]\n\n\n    var body: some View {\n        Table(people, sortOrder: $sortOrder) {\n            TableColumn(\"Given Name\", value: \\.givenName) { person in\n                VStack(alignment: .leading) {\n                    Text(isCompact ? person.fullName : person.givenName)\n                    if isCompact {\n                        Text(person.emailAddress)\n                            .foregroundStyle(.secondary)\n                    }\n                }\n            }\n            TableColumn(\"Family Name\", value: \\.familyName)\n            TableColumn(\"E-Mail Address\", value: \\.emailAddress)\n        }\n        .onChange(of: sortOrder) { _, sortOrder in\n            people.sort(using: sortOrder)\n        }\n    }\n}\n\n\nBy making this change, you provide a list-like appearance for narrower displays, while displaying the full table on wider ones. Because you use the same table instance in both cases, you get a seamless transition when the size class changes, like when someone moves your app into or out of Slide Over.\n\nTopics\nCreating a table from columns\ninit<Data>(Data, columns: () -> Columns)\nCreates a table that computes its rows based on a collection of identifiable data.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data>(Data, selection: Binding<Value.ID?>, columns: () -> Columns)\nCreates a table that computes its rows based on a collection of identifiable data, and that supports selecting zero or one row.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data>(Data, selection: Binding<Set<Value.ID>>, columns: () -> Columns)\nCreates a table that computes its rows based on a collection of identifiable data, and that supports selecting multiple rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\nCreating a sortable table from columns\ninit<Data, Sort>(Data, sortOrder: Binding<[Sort]>, columns: () -> Columns)\nCreates a sortable table that computes its rows based on a collection of identifiable data.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columns: () -> Columns)\nCreates a sortable table that computes its rows based on a collection of identifiable data, and supports selecting zero or one row.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columns: () -> Columns)\nCreates a sortable table that computes its rows based on a collection of identifiable data, and supports selecting multiple rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\nCreating a table from columns and rows\ninit(of: Value.Type, columns: () -> Columns, rows: () -> Rows)\nCreates a table with the given columns and rows that generates its contents using values of the given type.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit(of: Value.Type, selection: Binding<Set<Value.ID>>, columns: () -> Columns, rows: () -> Rows)\nCreates a table with the given columns and rows that supports selecting multiple rows that generates its data using values of the given type.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit(of: Value.Type, selection: Binding<Value.ID?>, columns: () -> Columns, rows: () -> Rows)\nCreates a table with the given columns and rows that supports selecting zero or one row that generates its data using values of the given type.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\nCreating a sortable table from columns and rows\ninit<Sort>(of: Value.Type, sortOrder: Binding<[Sort]>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(of: Value.Type, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows that supports selecting zero or one row.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(of: Value.Type, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows that supports selecting multiple rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(sortOrder: Binding<[Sort]>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows that supports selecting zero or one row.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows that supports selecting multiple rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\nCreating a table with customizable columns\ninit<Data>(Data, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns)\nCreates a table that computes its rows based on a collection of identifiable data and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data>(Data, selection: Binding<Value.ID?>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns)\nCreates a table that computes its rows based on a collection of identifiable data, that supports selecting zero or one row, and that has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data>(Data, selection: Binding<Set<Value.ID>>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns)\nCreates a table that computes its rows based on a collection of identifiable data, that supports selecting multiple rows, and that has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns)\nCreates a sortable table that computes its rows based on a collection of identifiable data, supports selecting multiple rows, and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns)\nCreates a sortable table that computes its rows based on a collection of identifiable data, supports selecting zero or one row, and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns)\nCreates a sortable table that computes its rows based on a collection of identifiable data and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\nCreating a table with dynamically customizable columns\ninit(of: Value.Type, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns, rows: () -> Rows)\nCreates a table with the given columns and rows that generates its contents using values of the given type and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit(of: Value.Type, selection: Binding<Set<Value.ID>>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns, rows: () -> Rows)\nCreates a table with the given columns and rows that supports selecting multiple rows that generates its data using values of the given type and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit(of: Value.Type, selection: Binding<Value.ID?>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns, rows: () -> Rows)\nCreates a table with the given columns and rows that supports selecting zero or one row that generates its data using values of the given type and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(of: Value.Type, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows that supports selecting multiple rows and dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(of: Value.Type, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows that supports selecting zero or one row and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Sort>(of: Value.Type, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, columns: () -> Columns, rows: () -> Rows)\nCreates a sortable table with the given columns and rows and has dynamically customizable columns.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\nCreating a hierarchical table\ninit<Data>(Data, children: KeyPath<Value, Data?>, columnCustomization: Binding<TableColumnCustomization<Value>>?, columns: () -> Columns)\nCreates a hierarchical table that computes its rows based on a collection of identifiable data and key path to the children of that data.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data>(Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<Value.ID>>, columnCustomization: Binding<TableColumnCustomization<Value>>?, columns: () -> Columns)\nCreates a hierarchical table that computes its rows based on a collection of identifiable data and key path to the children of that data, and supports selecting multiple rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data>(Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Value.ID?>, columnCustomization: Binding<TableColumnCustomization<Value>>?, columns: () -> Columns)\nCreates a hierarchical table that computes its rows based on a collection of identifiable data and key path to the children of that data, and supports selecting zero or one row.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>?, columns: () -> Columns)\nCreates a sortable, hierarchical table that computes its rows based on a collection of identifiable data and key path to the children of that data, and supports selecting zero or one row.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>?, columns: () -> Columns)\nCreates a sortable, hierarchical table that computes its rows based on a collection of identifiable data and key path to the children of that data, and supports selecting multiple rows.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\ninit<Data, Sort>(Data, children: KeyPath<Data.Element, Data?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>?, columns: () -> Columns)\nCreates a sortable, hierarchical table that computes its rows based on a collection of identifiable data and key path to the children of that data.\nAvailable when Value is Rows.TableRowValue, Rows conforms to TableRowContent, Columns conforms to TableColumnContent, and Rows.TableRowValue is Columns.TableRowValue.\nRelationships\nConforms To\nView\nSee Also\nCreating a table\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view."
    },
    {
        "title": "onDrop(of:isTargeted:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ondrop(of:istargeted:perform:)-982eu",
        "html": "Parameters\nsupportedContentTypes\n\nThe uniform type identifiers that describe the types of content this view can accept through drag and drop. If the drag and drop operation doesn\u2019t contain any of the supported types, then this drop destination doesn\u2019t activate and isTargeted doesn\u2019t update.\n\nisTargeted\n\nA binding that updates when a drag and drop operation enters or exits the drop target area. The binding\u2019s value is true when the cursor is inside the area, and false when the cursor is outside.\n\naction\n\nA closure that takes the dropped content and responds appropriately. The first parameter to action contains the dropped items, with types specified by supportedContentTypes. The second parameter contains the drop location in this view\u2019s coordinate space. Return true if the drop operation was successful; otherwise, return false.\n\nReturn Value\n\nA view that provides a drop destination for a drag operation of the specified types.\n\nDiscussion\n\nThe drop destination is the same size and position as this view.\n\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "onDrag(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ondrag(_:)",
        "html": "Parameters\ndata\n\nA closure that returns a single NSItemProvider that represents the draggable data from this view.\n\nReturn Value\n\nA view that activates this view as the source of a drag and drop operation, beginning with user gesture input.\n\nDiscussion\n\nApplying the onDrag(_:) modifier adds the appropriate gestures for drag and drop to this view. When a drag operation begins, a rendering of this view is generated and used as the preview image.\n\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "onDrop(of:isTargeted:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ondrop(of:istargeted:perform:)-f15m",
        "html": "Parameters\nsupportedContentTypes\n\nThe uniform type identifiers that describe the types of content this view can accept through drag and drop. If the drag-and-drop operation doesn\u2019t contain any of the supported types, then this drop destination doesn\u2019t activate and isTargeted doesn\u2019t update.\n\nisTargeted\n\nA binding that updates when a drag and drop operation enters or exits the drop target area. The binding\u2019s value is true when the cursor is inside the area, and false when the cursor is outside.\n\naction\n\nA closure that takes the dropped content and responds appropriately. The parameter to action contains the dropped items, with types specified by supportedContentTypes. Return true if the drop operation was successful; otherwise, return false.\n\nReturn Value\n\nA view that provides a drop destination for a drag operation of the specified types.\n\nDiscussion\n\nThe drop destination is the same size and position as this view.\n\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "gesture(_:including:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/gesture(_:including:)",
        "html": "Parameters\ngesture\n\nA gesture to attach to the view.\n\nmask\n\nA value that controls how adding this gesture to the view affects other gestures recognized by the view and its subviews. Defaults to all.\n\nDiscussion\n\nUse this method when you need to attach a gesture to a view. The example below defines a custom gesture that prints a message to the console and attaches it to the view\u2019s VStack. Inside the VStack a red heart Image defines its own TapGesture handler that also prints a message to the console, and blue rectangle with no custom gesture handlers. Tapping or clicking the image prints a message to the console from the tap gesture handler on the image, while tapping or clicking the rectangle inside the VStack prints a message in the console from the enclosing vertical stack gesture handler.\n\nstruct GestureExample: View {\n    @State private var message = \"Message\"\n    let newGesture = TapGesture().onEnded {\n        print(\"Tap on VStack.\")\n    }\n\n\n    var body: some View {\n        VStack(spacing:25) {\n            Image(systemName: \"heart.fill\")\n                .resizable()\n                .frame(width: 75, height: 75)\n                .padding()\n                .foregroundColor(.red)\n                .onTapGesture {\n                    print(\"Tap on image.\")\n                }\n            Rectangle()\n                .fill(Color.blue)\n        }\n        .gesture(newGesture)\n        .frame(width: 200, height: 200)\n        .border(Color.purple)\n    }\n}\n\nSee Also\nRecognizing gestures that change over time\nstruct DragGesture\nA dragging motion that invokes an action as the drag-event sequence changes.\nstruct MagnifyGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nstruct RotateGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nstruct RotateGesture3D\nA gesture that recognizes 3D rotation motion and tracks the angle and axis of the rotation.\nBeta\nstruct GestureMask\nOptions that control how adding a gesture to a view affects other gestures recognized by the view and its subviews."
    },
    {
        "title": "NSHostingSceneBridgingOptions",
        "url": "https://developer.apple.com/documentation/swiftui/nshostingscenebridgingoptions",
        "html": "Topics\nGeting bridging options\nstatic let all: NSHostingSceneBridgingOptions\nThe hosting view\u2019s associated window will have both its title bars and toolbars populated with values from their respective modifiers.\nstatic let title: NSHostingSceneBridgingOptions\nThe hosting view\u2019s associated window will have its title and subtitle populated with the values provided to the navigationTitle(_:) and navigationSubtitle(_:) modifiers, respectively.\nstatic let toolbars: NSHostingSceneBridgingOptions\nThe hosting view\u2019s associated window will have its toolbar populated with any items provided to the toolbar(content:) modifier.\nCreating a bridging options\ninit(rawValue: Int)\nCreates a new set from a raw value.\nlet rawValue: Int\nThe raw value.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nDisplaying SwiftUI views in AppKit\nclass NSHostingController\nAn AppKit view controller that hosts SwiftUI view hierarchy.\nclass NSHostingView\nAn AppKit view that hosts a SwiftUI view hierarchy.\nstruct NSHostingSizingOptions\nOptions for how hosting views and controllers reflect their content\u2019s size into Auto Layout constraints."
    },
    {
        "title": "accessibilityActions(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityactions(_:)",
        "html": "Discussion\n\nActions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action. For example, this is how a dynamic number of custom action could be added to a view.\n\nvar isDraft: Bool\n\n\nvar body: some View {\n    ContentView()\n        .accessibilityActions {\n            ForEach(actions) { action in\n                Button {\n                    action()\n                } label: {\n                    Text(action.title)\n                }\n            }\n\n\n            if isDraft {\n                Button {\n                    // Handle Delete\n                } label: {\n                    Text(\"Delete\")\n                }\n            }\n        }\n\nSee Also\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment."
    },
    {
        "title": "HandActivationBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/handactivationbehavior",
        "html": "Overview\n\nHand activation behavior determines what hand input modes activate a gesture.\n\nTopics\nGetting the behaviors\nstatic let automatic: HandActivationBehavior\nThe default activation behavior, including direct touch, direct pinch, and indirect pinch.\nstatic let pinch: HandActivationBehavior\nActivation that requires a pinched hand.\nRelationships\nConforms To\nEquatable\nSee Also\nDefining custom gestures\nfunc highPriorityGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a higher precedence than gestures defined by the view.\nfunc defersSystemGestures(on: Edge.Set) -> some View\nSets the screen edge from which you want your gesture to take precedence over the system gesture.\nprotocol Gesture\nAn instance that matches a sequence of events to a gesture, and returns a stream of values for each of its states.\nstruct AnyGesture\nA type-erased gesture."
    },
    {
        "title": "focusable(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusable(_:)",
        "html": "Parameters\ns isFocusable\n\nA Boolean value that indicates whether this view is focusable.\n\nReturn Value\n\nA view that sets whether a view is focusable.\n\nSee Also\nIndicating that a view can receive focus\nfunc focusable(Bool, interactions: FocusInteractions) -> some View\nSpecifies if the view is focusable, and if so, what focus-driven interactions it supports.\nstruct FocusInteractions\nValues describe different focus interactions that a view can support."
    },
    {
        "title": "DropInfo",
        "url": "https://developer.apple.com/documentation/swiftui/dropinfo",
        "html": "Topics\nGetting the drop location\nvar location: CGPoint\nThe location of the drag in the coordinate space of the drop view.\nChecking for items\nfunc hasItemsConforming(to: [UTType]) -> Bool\nIndicates whether at least one item conforms to at least one of the specified uniform type identifiers.\nfunc itemProviders(for: [UTType]) -> [NSItemProvider]\nFinds item providers that conform to at least one of the specified uniform type identifiers.\nDeprecated symbols\nfunc hasItemsConforming(to: [String]) -> Bool\nReturns whether at least one item conforms to at least one of the specified uniform type identifiers.\nDeprecated\nfunc itemProviders(for: [String]) -> [NSItemProvider]\nReturns an array of items that each conform to at least one of the specified uniform type identifiers.\nDeprecated\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item."
    },
    {
        "title": "isFocusEffectEnabled",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/isfocuseffectenabled",
        "html": "Discussion\n\nThe default value is true.\n\nSee Also\nConfiguring effects\nfunc focusEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display focus effects, such as a default focus ring or hover effect."
    },
    {
        "title": "Adding interactivity with gestures",
        "url": "https://developer.apple.com/documentation/swiftui/adding-interactivity-with-gestures",
        "html": "Overview\n\nGesture modifiers handle all of the logic needed to process user-input events such as touches, and recognize when those events match a known gesture pattern, such as a long press or rotation. When recognizing a pattern, SwiftUI runs a callback you use to update the state of a view or perform an action.\n\nAdd gesture modifiers to a view\n\nEach gesture you add applies to a specific view in the view hierarchy. To recognize a gesture event on a particular view, create and configure the gesture, and then use the gesture(_:including:) modifier:\n\nstruct ShapeTapView: View {\n    var body: some View {\n        let tap = TapGesture()\n            .onEnded { _ in\n                print(\"View tapped!\")\n            }\n        \n        return Circle()\n            .fill(Color.blue)\n            .frame(width: 100, height: 100, alignment: .center)\n            .gesture(tap)\n    }\n}\n\nRespond to gesture callbacks\n\nDepending on the callbacks you add to a gesture modifier, SwiftUI reports back to your code whenever the state of the gesture changes. Gesture modifiers offer three ways to receive updates: updating(_:body:), onChanged(_:), and onEnded(_:).\n\nUpdate transient UI state\n\nTo update a view as a gesture changes, add a GestureState property to your view and update it in the updating(_:body:) callback. SwiftUI invokes the updating callback as soon as it recognizes the gesture and whenever the value of the gesture changes. For example, SwiftUI invokes the updating callback as soon as a magnification gesture begins and then again whenever the magnification value changes. SwiftUI doesn\u2019t invoke the updating callback when the user ends or cancels a gesture. Instead, the gesture state property automatically resets its state back to its initial value.\n\nFor example, to make a view that changes color while the user performs a long press, add a gesture state property and update it in the updating callback.\n\nstruct CounterView: View {\n    @GestureState private var isDetectingLongPress = false\n    \n    var body: some View {\n        let press = LongPressGesture(minimumDuration: 1)\n            .updating($isDetectingLongPress) { currentState, gestureState, transaction in\n                gestureState = currentState\n            }\n        \n        return Circle()\n            .fill(isDetectingLongPress ? Color.yellow : Color.green)\n            .frame(width: 100, height: 100, alignment: .center)\n            .gesture(press)\n    }\n}\n\nUpdate permanent state during a gesture\n\nTo track changes to a gesture that shouldn\u2019t reset once the gesture ends, use the onChanged(_:) callback. For example, to count the number of times your app recognizes a long press, add an onChanged(_:) callback and increment a counter.\n\nstruct CounterView: View {\n    @GestureState private var isDetectingLongPress = false\n    @State private var totalNumberOfTaps = 0\n    \n    var body: some View {\n        let press = LongPressGesture(minimumDuration: 1)\n            .updating($isDetectingLongPress) { currentState, gestureState, transaction in\n                gestureState = currentState\n            }.onChanged { _ in\n                self.totalNumberOfTaps += 1\n            }\n        \n        return VStack {\n            Text(\"\\(totalNumberOfTaps)\")\n                .font(.largeTitle)\n            \n            Circle()\n                .fill(isDetectingLongPress ? Color.yellow : Color.green)\n                .frame(width: 100, height: 100, alignment: .center)\n                .gesture(press)\n        }\n    }\n}\n\nUpdate permanent state when a gesture ends\n\nTo recognize when a gesture successfully completes and to retrieve the gesture\u2019s final value, use the onEnded(_:) function to update your app\u2019s state in the callback. SwiftUI only invokes the onEnded(_:) callback when the gesture succeeds. For example, during a LongPressGesture if the user stops touching the view before minimumDuration seconds have elapsed or moves their finger more than maximumDistance points SwiftUI does not invoke the onEnded(_:) callback.\n\nFor example, to stop counting long press attempts after the user completes a long press, add an onEnded(_:) callback and conditionally apply the gesture modifier.\n\nstruct CounterView: View {\n    @GestureState private var isDetectingLongPress = false\n    @State private var totalNumberOfTaps = 0\n    @State private var doneCounting = false\n    \n    var body: some View {\n        let press = LongPressGesture(minimumDuration: 1)\n            .updating($isDetectingLongPress) { currentState, gestureState, transaction in\n                gestureState = currentState\n            }.onChanged { _ in\n                self.totalNumberOfTaps += 1\n            }\n            .onEnded { _ in\n                self.doneCounting = true\n            }\n        \n        return VStack {\n            Text(\"\\(totalNumberOfTaps)\")\n                .font(.largeTitle)\n            \n            Circle()\n                .fill(doneCounting ? Color.red : isDetectingLongPress ? Color.yellow : Color.green)\n                .frame(width: 100, height: 100, alignment: .center)\n                .gesture(doneCounting ? nil : press)\n        }\n    }\n}\n"
    },
    {
        "title": "onDrop(of:delegate:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ondrop(of:delegate:)-6lin8",
        "html": "Parameters\nsupportedContentTypes\n\nThe uniform type identifiers that describe the types of content this view can accept through drag and drop. If the drag and drop operation doesn\u2019t contain any of the supported types, then this drop destination doesn\u2019t activate and isTargeted doesn\u2019t update.\n\ndelegate\n\nA type that conforms to the DropDelegate protocol. You have comprehensive control over drop behavior when you use a delegate.\n\nReturn Value\n\nA view that provides a drop destination for a drag operation of the specified types.\n\nDiscussion\n\nThe drop destination is the same size and position as this view.\n\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "FocusInteractions",
        "url": "https://developer.apple.com/documentation/swiftui/focusinteractions",
        "html": "Topics\nCreating the interaction types\nstatic var automatic: FocusInteractions\nThe view supports whatever focus-driven interactions are commonly expected for interactive content on the current platform.\nstatic let activate: FocusInteractions\nThe view has a primary action that can be activated via focus gestures.\nstatic let edit: FocusInteractions\nThe view captures input from non-spatial sources like a keyboard or Digital Crown.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nIndicating that a view can receive focus\nfunc focusable(Bool) -> some View\nSpecifies if the view is focusable.\nfunc focusable(Bool, interactions: FocusInteractions) -> some View\nSpecifies if the view is focusable, and if so, what focus-driven interactions it supports."
    },
    {
        "title": "DropOperation",
        "url": "https://developer.apple.com/documentation/swiftui/dropoperation",
        "html": "Topics\nGetting operation types\ncase cancel\nCancel the drag operation and transfer no data.\ncase copy\nCopy the data to the modified view.\ncase forbidden\nThe drop activity is not allowed at this time or location.\ncase move\nMove the data represented by the drag items instead of copying it.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "DropDelegate",
        "url": "https://developer.apple.com/documentation/swiftui/dropdelegate",
        "html": "Overview\n\nThe DropDelegate protocol provides a comprehensive and flexible way to interact with a drop operation. Specify a drop delegate when you modify a view to accept drops with the onDrop(of:delegate:) method.\n\nAlternatively, for simple drop cases that don\u2019t require the full functionality of a drop delegate, you can modify a view to accept drops using the onDrop(of:isTargeted:perform:) or the onDrop(of:isTargeted:perform:) method. These methods handle the drop using a closure you provide as part of the modifier.\n\nTopics\nReceiving drop information\nfunc dropEntered(info: DropInfo)\nTells the delegate a validated drop has entered the modified view.\n\nRequired Default implementation provided.\n\nfunc dropExited(info: DropInfo)\nTells the delegate a validated drop operation has exited the modified view.\n\nRequired Default implementation provided.\n\nfunc dropUpdated(info: DropInfo) -> DropProposal?\nTells the delegate that a validated drop moved inside the modified view.\n\nRequired Default implementation provided.\n\nfunc validateDrop(info: DropInfo) -> Bool\nTells the delegate that a drop containing items conforming to one of the expected types entered a view that accepts drops.\n\nRequired Default implementation provided.\n\nfunc performDrop(info: DropInfo) -> Bool\nTells the delegate it can request the item provider data from the given information.\n\nRequired\n\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "EmptyTableRowContent",
        "url": "https://developer.apple.com/documentation/swiftui/emptytablerowcontent",
        "html": "Overview\n\nYou will rarely, if ever, need to create an EmptyTableRowContent directly. Instead, EmptyTableRowContent represents the absence of a row.\n\nRelationships\nConforms To\nTableRowContent\nConforms when Value conforms to Identifiable.\nSee Also\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nprotocol TableRowContent\nA type used to represent table rows.\nAvailable when Value conforms to Identifiable.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data.\nstruct TableRowBuilder\nA result builder that creates table row content from closures."
    },
    {
        "title": "focusable(_:interactions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusable(_:interactions:)",
        "html": "Parameters\nisFocusable\n\ntrue if the view should participate in focus; false otherwise. The default value is true.\n\ninteractions\n\nThe types of focus interactions supported by the view. The default value is .automatic.\n\nReturn Value\n\nA view that sets whether its child is focusable.\n\nDiscussion\n\nBy default, SwiftUI enables all possible focus interactions. However, on macOS and iOS it is conventional for button-like views to only accept focus when the user has enabled keyboard navigation system-wide in the Settings app. Clients can reproduce this behavior with custom views by only supporting .activate interactions.\n\nMyTapGestureView(...)\n    .focusable(interactions: .activate)\n\n\nNote\n\nThe focus interactions allowed for custom views changed in macOS 14\u2014previously, custom views could only become focused with keyboard navigation enabled system-wide. Clients built using older SDKs will continue to see the older focus behavior, while custom views in clients built using macOS 14 or later will always be focusable unless the client requests otherwise by specifying a restricted set of focus interactions.\n\nSee Also\nIndicating that a view can receive focus\nfunc focusable(Bool) -> some View\nSpecifies if the view is focusable.\nstruct FocusInteractions\nValues describe different focus interactions that a view can support."
    },
    {
        "title": "DropProposal",
        "url": "https://developer.apple.com/documentation/swiftui/dropproposal",
        "html": "Topics\nCreating a drop proposal\ninit(operation: DropOperation)\nlet operation: DropOperation\nThe drop operation that the drop proposes to perform.\nRelationships\nConforms To\nSendable\nSee Also\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop."
    },
    {
        "title": "Focus Cookbook: Supporting and enhancing focus-driven interactions in your SwiftUI app",
        "url": "https://developer.apple.com/documentation/swiftui/focus-cookbook-sample",
        "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC23 session 10162: The SwiftUI cookbook for focus."
    },
    {
        "title": "springLoadingBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/springloadingbehavior",
        "html": "Discussion\n\nSpring loading refers to a view being activated during a drag and drop interaction. On iOS this can occur when pausing briefly on top of a view with dragged content. On macOS this can occur with similar brief pauses or on pressure-sensitive systems by \u201cforce clicking\u201d during the drag. This has no effect on tvOS or watchOS.\n\nThis is commonly used with views that have a navigation or presentation effect, allowing the destination to be revealed without pausing the drag interaction. For example, a button that reveals a list of folders that a dragged item can be dropped onto.\n\nA value of enabled means that a view should support spring loaded interactions if it is able, and disabled means it should not. A value of automatic means that a view should follow its default behavior, such as a TabView automatically allowing spring loading, but a Picker with segmented style would not.\n\nSee Also\nConfiguring spring loading\nfunc springLoadingBehavior(SpringLoadingBehavior) -> some View\nSets the spring loading behavior this view.\nstruct SpringLoadingBehavior\nThe options for controlling the spring loading behavior of views."
    },
    {
        "title": "FocusedValueKey",
        "url": "https://developer.apple.com/documentation/swiftui/focusedvaluekey",
        "html": "Overview\n\nUnlike EnvironmentKey, FocusedValueKey has no default value requirement, because the default value for a key is always nil.\n\nTopics\nSpecifying the value type\nassociatedtype Value\n\nRequired\n\nSee Also\nManaging focus state\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nstruct FocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the placement of focus within the scene changes.\nstruct FocusedValue\nA property wrapper for observing values from the focused view or one of its ancestors.\nstruct FocusedBinding\nA convenience property wrapper for observing and automatically unwrapping state bindings from the focused view or one of its ancestors."
    },
    {
        "title": "focused(_:equals:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focused(_:equals:)",
        "html": "Parameters\nbinding\n\nThe state binding to register. When focus moves to the modified view, the binding sets the bound value to the corresponding match value. If a caller sets the state value programmatically to the matching value, then focus moves to the modified view. When focus leaves the modified view, the binding sets the bound value to nil. If a caller sets the value to nil, SwiftUI automatically dismisses focus.\n\nvalue\n\nThe value to match against when determining whether the binding should change.\n\nReturn Value\n\nThe modified view.\n\nDiscussion\n\nUse this modifier to cause the view to receive focus whenever the the binding equals the value. Typically, you create an enumeration of fields that may receive focus, bind an instance of this enumeration, and assign its cases to focusable views.\n\nThe following example uses the cases of a LoginForm enumeration to bind the focus state of two TextField views. A sign-in button validates the fields and sets the bound focusedField value to any field that requires the user to correct a problem.\n\nstruct LoginForm {\n    enum Field: Hashable {\n        case usernameField\n        case passwordField\n    }\n\n\n    @State private var username = \"\"\n    @State private var password = \"\"\n    @FocusState private var focusedField: Field?\n\n\n    var body: some View {\n        Form {\n            TextField(\"Username\", text: $username)\n                .focused($focusedField, equals: .usernameField)\n\n\n            SecureField(\"Password\", text: $password)\n                .focused($focusedField, equals: .passwordField)\n\n\n            Button(\"Sign In\") {\n                if username.isEmpty {\n                    focusedField = .usernameField\n                } else if password.isEmpty {\n                    focusedField = .passwordField\n                } else {\n                    handleLogin(username, password)\n                }\n            }\n        }\n    }\n}\n\n\nTo control focus using a Boolean, use the focused(_:) method instead.\n\nSee Also\nManaging focus state\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nstruct FocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the placement of focus within the scene changes.\nstruct FocusedValue\nA property wrapper for observing values from the focused view or one of its ancestors.\nprotocol FocusedValueKey\nA protocol for identifier types used when publishing and observing focused values.\nstruct FocusedBinding\nA convenience property wrapper for observing and automatically unwrapping state bindings from the focused view or one of its ancestors."
    },
    {
        "title": "FocusState",
        "url": "https://developer.apple.com/documentation/swiftui/focusstate",
        "html": "Overview\n\nUse this property wrapper in conjunction with focused(_:equals:) and focused(_:) to describe views whose appearance and contents relate to the location of focus in the scene. When focus enters the modified view, the wrapped value of this property updates to match a given prototype value. Similarly, when focus leaves, the wrapped value of this property resets to nil or false. Setting the property\u2019s value programmatically has the reverse effect, causing focus to move to the view associated with the updated value.\n\nIn the following example of a simple login screen, when the user presses the Sign In button and one of the fields is still empty, focus moves to that field. Otherwise, the sign-in process proceeds.\n\nstruct LoginForm {\n    enum Field: Hashable {\n        case username\n        case password\n    }\n\n\n    @State private var username = \"\"\n    @State private var password = \"\"\n    @FocusState private var focusedField: Field?\n\n\n    var body: some View {\n        Form {\n            TextField(\"Username\", text: $username)\n                .focused($focusedField, equals: .username)\n\n\n            SecureField(\"Password\", text: $password)\n                .focused($focusedField, equals: .password)\n\n\n            Button(\"Sign In\") {\n                if username.isEmpty {\n                    focusedField = .username\n                } else if password.isEmpty {\n                    focusedField = .password\n                } else {\n                    handleLogin(username, password)\n                }\n            }\n        }\n    }\n}\n\n\nTo allow for cases where focus is completely absent from a view tree, the wrapped value must be either an optional or a Boolean. Set the focus binding to false or nil as appropriate to remove focus from all bound fields. You can also use this to remove focus from a TextField and thereby dismiss the keyboard.\n\nAvoid ambiguous focus bindings\n\nThe same view can have multiple focus bindings. In the following example, setting focusedField to either name or fullName causes the field to receive focus:\n\nstruct ContentView: View {\n    enum Field: Hashable {\n        case name\n        case fullName\n    }\n    @FocusState private var focusedField: Field?\n\n\n    var body: some View {\n        TextField(\"Full Name\", ...)\n            .focused($focusedField, equals: .name)\n            .focused($focusedField, equals: .fullName)\n    }\n}\n\n\nOn the other hand, binding the same value to two views is ambiguous. In the following example, two separate fields bind focus to the name value:\n\nstruct ContentView: View {\n    enum Field: Hashable {\n        case name\n        case fullName\n    }\n    @FocusState private var focusedField: Field?\n\n\n    var body: some View {\n        TextField(\"Name\", ...)\n            .focused($focusedField, equals: .name)\n        TextField(\"Full Name\", ...)\n            .focused($focusedField, equals: .name) // incorrect re-use of .name\n    }\n}\n\n\nIf the user moves focus to either field, the focusedField binding updates to name. However, if the app programmatically sets the value to name, SwiftUI chooses the first candidate, which in this case is the \u201cName\u201d field. SwiftUI also emits a runtime warning in this case, since the repeated binding is likely a programmer error.\n\nTopics\nCreating a focus state\ninit<T>()\nCreates a focus state that binds to an optional type.\ninit()\nCreates a focus state that binds to a Boolean.\nInspecting the focus state\nvar projectedValue: FocusState<Value>.Binding\nA projection of the focus state value that returns a binding.\nstruct Binding\nA property wrapper type that can read and write a value that indicates the current focus location.\nvar wrappedValue: Value\nThe current state value, taking into account whatever bindings might be in effect due to the current location of focus.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nManaging focus state\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nstruct FocusedValue\nA property wrapper for observing values from the focused view or one of its ancestors.\nprotocol FocusedValueKey\nA protocol for identifier types used when publishing and observing focused values.\nstruct FocusedBinding\nA convenience property wrapper for observing and automatically unwrapping state bindings from the focused view or one of its ancestors."
    },
    {
        "title": "focusedSceneValue(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedscenevalue(_:_:)-57boz",
        "html": "Parameters\nkeyPath\n\nThe key path to associate value with when adding it to the existing table of published focus values.\n\nvalue\n\nThe focus value to publish, or nil if no value is currently available.\n\nReturn Value\n\nA modified representation of this view.\n\nDiscussion\n\nUse this method instead of View/focusedValue(_:_:) for values that must be visible regardless of where focus is located in the active scene. For example, if an app needs a command for moving focus to a particular text field in the sidebar, it could use this modifier to publish a button action that\u2019s visible to command views as long as the scene is active, and regardless of where focus happens to be in it.\n\nstruct Sidebar: View {\n    @FocusState var isFiltering: Bool\n\n\n    var body: some View {\n        VStack {\n            TextField(...)\n                .focused(when: $isFiltering)\n                .focusedSceneValue(\\.filterAction) {\n                    isFiltering = true\n                }\n        }\n    }\n}\n\n\nstruct NavigationCommands: Commands {\n    @FocusedValue(\\.filterAction) var filterAction\n\n\n    var body: some Commands {\n        CommandMenu(\"Navigate\") {\n            Button(\"Filter in Sidebar\") {\n                filterAction?()\n            }\n        }\n        .disabled(filterAction == nil)\n    }\n}\n\n\nstruct FilterActionKey: FocusedValuesKey {\n    typealias Value = () -> Void\n}\n\n\nextension FocusedValues {\n    var filterAction: (() -> Void)? {\n        get { self[FilterActionKey.self] }\n        set { self[FilterActionKey.self] = newValue }\n    }\n}\n\nSee Also\nExposing value types to focused views\nfunc focusedValue<T>(T?) -> some View\nSets the focused value for the given object type.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused view hierarchy.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused scene.\nstruct FocusedValues\nA collection of state exported by the focused view and its ancestors."
    },
    {
        "title": "focusedSceneValue(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedscenevalue(_:_:)-5iugx",
        "html": "Parameters\nkeyPath\n\nThe key path to associate value with when adding it to the existing table of published focus values.\n\nvalue\n\nThe focus value to publish.\n\nReturn Value\n\nA modified representation of this view.\n\nDiscussion\n\nUse this method instead of View/focusedValue(_:_:) for values that must be visible regardless of where focus is located in the active scene. For example, if an app needs a command for moving focus to a particular text field in the sidebar, it could use this modifier to publish a button action that\u2019s visible to command views as long as the scene is active, and regardless of where focus happens to be in it.\n\nstruct Sidebar: View {\n    @FocusState var isFiltering: Bool\n\n\n    var body: some View {\n        VStack {\n            TextField(...)\n                .focused(when: $isFiltering)\n                .focusedSceneValue(\\.filterAction) {\n                    isFiltering = true\n                }\n        }\n    }\n}\n\n\nstruct NavigationCommands: Commands {\n    @FocusedValue(\\.filterAction) var filterAction\n\n\n    var body: some Commands {\n        CommandMenu(\"Navigate\") {\n            Button(\"Filter in Sidebar\") {\n                filterAction?()\n            }\n        }\n        .disabled(filterAction == nil)\n    }\n}\n\n\nstruct FilterActionKey: FocusedValuesKey {\n    typealias Value = () -> Void\n}\n\n\nextension FocusedValues {\n    var filterAction: (() -> Void)? {\n        get { self[FilterActionKey.self] }\n        set { self[FilterActionKey.self] = newValue }\n    }\n}\n\nSee Also\nExposing value types to focused views\nfunc focusedValue<T>(T?) -> some View\nSets the focused value for the given object type.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused view hierarchy.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the active scene.\nstruct FocusedValues\nA collection of state exported by the focused view and its ancestors."
    },
    {
        "title": "Edge3D",
        "url": "https://developer.apple.com/documentation/swiftui/edge3d",
        "html": "Topics\nGetting the edges\ncase top\ncase bottom\ncase leading\ncase trailing\ncase front\ncase back\nCreating an edge\ninit(Edge)\nAccessing sets of edges\nstruct Set\nAn efficient set of 3D edges.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nAccessing edges and regions\nenum Edge\nAn enumeration to indicate one edge of a rectangle.\nenum HorizontalEdge\nAn edge on the horizontal axis.\nenum VerticalEdge\nAn edge on the vertical axis.\nstruct EdgeInsets\nThe inset distances for the sides of a rectangle.\nstruct EdgeInsets3D\nThe inset distances for the faces of a 3D volume.\nBeta"
    },
    {
        "title": "Group",
        "url": "https://developer.apple.com/documentation/swiftui/group",
        "html": "Overview\n\nUse a group to collect multiple views into a single instance, without affecting the layout of those views, like an HStack, VStack, or Section would. After creating a group, any modifier you apply to the group affects all of that group\u2019s members. For example, the following code applies the headline font to three views in a group.\n\nGroup {\n    Text(\"SwiftUI\")\n    Text(\"Combine\")\n    Text(\"Swift System\")\n}\n.font(.headline)\n\n\nBecause you create a group of views with a ViewBuilder, you can use the group\u2019s initializer to produce different kinds of views from a conditional, and then optionally apply modifiers to them. The following example uses a Group to add a navigation bar title, regardless of the type of view the conditional produces:\n\nGroup {\n    if isLoggedIn {\n        WelcomeView()\n    } else {\n        LoginView()\n    }\n}\n.navigationBarTitle(\"Start\")\n\n\nThe modifier applies to all members of the group \u2014 and not to the group itself. For example, if you apply onAppear(perform:) to the above group, it applies to all of the views produced by the if isLoggedIn conditional, and it executes every time isLoggedIn changes.\n\nBecause a group of views itself is a view, you can compose a group within other view builders, including nesting within other groups. This allows you to add large numbers of views to different view builder containers. The following example uses a Group to collect 10 Text instances, meaning that the vertical stack\u2019s view builder returns only two views \u2014 the group, plus an additional Text:\n\nvar body: some View {\n    VStack {\n        Group {\n            Text(\"1\")\n            Text(\"2\")\n            Text(\"3\")\n            Text(\"4\")\n            Text(\"5\")\n            Text(\"6\")\n            Text(\"7\")\n            Text(\"8\")\n            Text(\"9\")\n            Text(\"10\")\n        }\n        Text(\"11\")\n    }\n}\n\n\nYou can initialize groups with several types other than View, such as Scene and ToolbarContent. The closure you provide to the group initializer uses the corresponding builder type (SceneBuilder, ToolbarContentBuilder, and so on), and the capabilities of these builders vary between types. For example, you can use groups to return large numbers of scenes or toolbar content instances, but not to return different scenes or toolbar content based on conditionals.\n\nTopics\nCreating a group\ninit(content: () -> Content)\nCreates a group of views.\nAvailable when Content conforms to View.\ninit(content: () -> Content)\nCreates a group of scenes.\nAvailable when Content conforms to Scene.\ninit(content: () -> Content)\nCreates a group of commands.\nAvailable when Content conforms to Commands.\ninit(content: () -> Content)\nCreates a group of toolbar content instances.\nAvailable when Content conforms to ToolbarContent.\ninit(content: () -> Content)\nCreates a group of customizable toolbar content instances.\nAvailable when Content conforms to CustomizableToolbarContent.\ninit<R>(content: () -> Content)\nCreates a group of table rows.\nAvailable when Content conforms to TableRowContent.\ninit<R, C>(content: () -> Content)\nCreates a group of table columns.\nAvailable when Content conforms to TableColumnContent.\ninit(content: () -> Content)\nCreates an instance that generates Rotor content by combining, in order, all the Rotor content specified in the passed-in result builder.\nAvailable when Content conforms to AccessibilityRotorContent.\nRelationships\nConforms To\nAccessibilityRotorContent\nConforms when Content conforms to AccessibilityRotorContent.\nCommands\nConforms when Content conforms to Commands.\nCustomizableToolbarContent\nConforms when Content conforms to CustomizableToolbarContent.\nScene\nConforms when Content conforms to Scene.\nTableColumnContent\nConforms when Content conforms to TableColumnContent.\nTableRowContent\nConforms when Content conforms to TableRowContent.\nToolbarContent\nConforms when Content conforms to CustomizableToolbarContent.\nView\nConforms when Content conforms to View."
    },
    {
        "title": "UIViewRepresentable",
        "url": "https://developer.apple.com/documentation/swiftui/uiviewrepresentable",
        "html": "Overview\n\nUse a UIViewRepresentable instance to create and manage a UIView object in your SwiftUI interface. Adopt this protocol in one of your app\u2019s custom instances, and use its methods to create, update, and tear down your view. The creation and update processes parallel the behavior of SwiftUI views, and you use them to configure your view with your app\u2019s current state information. Use the teardown process to remove your view cleanly from your SwiftUI. For example, you might use the teardown process to notify other objects that the view is disappearing.\n\nTo add your view into your SwiftUI interface, create your UIViewRepresentable instance and add it to your SwiftUI interface. The system calls the methods of your representable instance at appropriate times to create and update the view. The following example shows the inclusion of a custom MyRepresentedCustomView structure in the view hierarchy.\n\nstruct ContentView: View {\n   var body: some View {\n      VStack {\n         Text(\"Global Sales\")\n         MyRepresentedCustomView()\n      }\n   }\n}\n\n\nThe system doesn\u2019t automatically communicate changes occurring within your view to other parts of your SwiftUI interface. When you want your view to coordinate with other SwiftUI views, you must provide a Coordinator instance to facilitate those interactions. For example, you use a coordinator to forward target-action and delegate messages from your view to any SwiftUI views.\n\nTopics\nCreating and updating the view\nfunc makeUIView(context: Self.Context) -> Self.UIViewType\nCreates the view object and configures its initial state.\n\nRequired\n\nfunc updateUIView(Self.UIViewType, context: Self.Context)\nUpdates the state of the specified view with new information from SwiftUI.\n\nRequired\n\ntypealias Context\nassociatedtype UIViewType : UIView\nThe type of view to present.\n\nRequired\n\nSpecifying a size\nfunc sizeThatFits(ProposedViewSize, uiView: Self.UIViewType, context: Self.Context) -> CGSize?\nGiven a proposed size, returns the preferred size of the composite view.\n\nRequired Default implementation provided.\n\nCleaning up the view\nstatic func dismantleUIView(Self.UIViewType, coordinator: Self.Coordinator)\nCleans up the presented UIKit view (and coordinator) in anticipation of their removal.\n\nRequired Default implementation provided.\n\nProviding a custom coordinator object\nfunc makeCoordinator() -> Self.Coordinator\nCreates the custom instance that you use to communicate changes from your view to other parts of your SwiftUI interface.\n\nRequired Default implementation provided.\n\nassociatedtype Coordinator = Void\nA type to coordinate with the view.\n\nRequired\n\nPerforming layout\ntypealias LayoutOptions\nRelationships\nInherits From\nView\nSee Also\nAdding UIKit views to SwiftUI view hierarchies\nstruct UIViewRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view.\nprotocol UIViewControllerRepresentable\nA view that represents a UIKit view controller.\nstruct UIViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view controller."
    },
    {
        "title": "exportableToServices(_:onEdit:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/exportabletoservices(_:onedit:)",
        "html": "Parameters\npayload\n\nA closure that will be called on request of the items by the shortcut or service.\n\nonEdit\n\nA closure that will be called after the shortcut or service completes with its output data. This should replace the selected subpart that was exported with onExport. Return false to indicate that there was a failure to receive the items.\n\nDiscussion\n\nIf the associated view supports selection, the exported item should reflect that selected subpart.\n\n@State private var title: String\nvar body: some View {\n    Color.pink\n        .frame(width: 400, height: 400)\n        .exportableToServices([title]) { editedTitles\n            title = editedTitles.first ?? title\n            return !editedTitles.isEmpty\n        }\n}\n\nSee Also\nImporting and exporting transferable items\nfunc importableFromServices<T>(for: T.Type, action: ([T]) -> Bool) -> some View\nEnables importing items from services, such as Continuity Camera on macOS.\nfunc exportableToServices<T>(() -> [T]) -> some View\nExports items for consumption by shortcuts, quick actions, and services."
    },
    {
        "title": "accessibilityValue(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityvalue(_:)-2bwuz",
        "html": "Discussion\n\nUse this method to describe the value represented by a view, but only if that\u2019s different than the view\u2019s label. For example, for a slider that you label as \u201cVolume\u201d using accessibilityLabel(), you can provide the current volume setting, like \u201c60%\u201d, using accessibilityValue().\n\nSee Also\nDescribing values\nfunc accessibilityValue(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nfunc accessibilityValue(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains."
    },
    {
        "title": "exportableToServices(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/exportabletoservices(_:)",
        "html": "Parameters\npayload\n\nA closure that will be called on request of the items by the shortcut or service.\n\nDiscussion\n\nIf the associated view supports selection, the exported item should reflect that selected subpart.\n\nvar title: String\nvar body: some View {\n    Color.pink\n        .frame(width: 400, height: 400)\n        .exportableToServices([title])\n}\n\nSee Also\nImporting and exporting transferable items\nfunc importableFromServices<T>(for: T.Type, action: ([T]) -> Bool) -> some View\nEnables importing items from services, such as Continuity Camera on macOS.\nfunc exportableToServices<T>(() -> [T], onEdit: ([T]) -> Bool) -> some View\nExports read-write items for consumption by shortcuts, quick actions, and services."
    },
    {
        "title": "importableFromServices(for:action:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/importablefromservices(for:action:)",
        "html": "Parameters\npayloadType\n\nThe expected type of the imported models.\n\naction\n\nA closure that will be called with the imported service item. Return false to indicate that there was a failure to receive the items.\n\nDiscussion\n@State private var title: String\nvar body: some View {\n    Color.pink\n        .frame(width: 400, height: 400)\n        .importableFromServices(for: String.self) { titles\n            title = titles.first ?? title\n            return !titles.isEmpty\n        }\n}\n\nSee Also\nImporting and exporting transferable items\nfunc exportableToServices<T>(() -> [T]) -> some View\nExports items for consumption by shortcuts, quick actions, and services.\nfunc exportableToServices<T>(() -> [T], onEdit: ([T]) -> Bool) -> some View\nExports read-write items for consumption by shortcuts, quick actions, and services."
    },
    {
        "title": "exportsItemProviders(_:onExport:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/exportsitemproviders(_:onexport:)",
        "html": "Parameters\ncontentTypes\n\nThe types of content that the view supports exporting. An empty array means the view does not currently support exporting.\n\nonExport\n\nA closure that will be called on request of the items by the shortcut or service.\n\nDiscussion\n\nIf the associated view supports selection, the exported item should reflect that selected subpart.\n\nSee Also\nImporting and exporting using item providers\nfunc importsItemProviders([UTType], onImport: ([NSItemProvider]) -> Bool) -> some View\nEnables importing item providers from services, such as Continuity Camera on macOS.\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider], onEdit: ([NSItemProvider]) -> Bool) -> some View\nExports a read-write item provider for consumption by shortcuts, quick actions, and services."
    },
    {
        "title": "AccessibilityAttachmentModifier",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilityattachmentmodifier",
        "html": "Relationships\nConforms To\nViewModifier\nSee Also\nSupporting types\nstruct AccessibilityTechnologies\nAccessibility technologies available to the system."
    },
    {
        "title": "NSViewRepresentable",
        "url": "https://developer.apple.com/documentation/swiftui/nsviewrepresentable",
        "html": "Overview\n\nUse an NSViewRepresentable instance to create and manage an NSView object in your SwiftUI interface. Adopt this protocol in one of your app\u2019s custom instances, and use its methods to create, update, and tear down your view. The creation and update processes parallel the behavior of SwiftUI views, and you use them to configure your view with your app\u2019s current state information. Use the teardown process to remove your view cleanly from your SwiftUI. For example, you might use the teardown process to notify other objects that the view is disappearing.\n\nTo add your view into your SwiftUI interface, create your NSViewRepresentable instance and add it to your SwiftUI interface. The system calls the methods of your representable instance at appropriate times to create and update the view. The following example shows the inclusion of a custom MyRepresentedCustomView struct in the view hierarchy.\n\nstruct ContentView: View {\n   var body: some View {\n      VStack {\n         Text(\"Global Sales\")\n         MyRepresentedCustomView()\n      }\n   }\n}\n\n\nThe system doesn\u2019t automatically communicate changes occurring within your view controller to other parts of your SwiftUI interface. When you want your view controller to coordinate with other SwiftUI views, you must provide a Coordinator object to facilitate those interactions. For example, you use a coordinator to forward target-action and delegate messages from your view controller to any SwiftUI views.\n\nTopics\nCreating and updating the view\nfunc makeNSView(context: Self.Context) -> Self.NSViewType\nCreates the view object and configures its initial state.\n\nRequired\n\nfunc updateNSView(Self.NSViewType, context: Self.Context)\nUpdates the state of the specified view with new information from SwiftUI.\n\nRequired\n\ntypealias Context\nassociatedtype NSViewType : NSView\nThe type of view to present.\n\nRequired\n\nSpecifying a size\nfunc sizeThatFits(ProposedViewSize, nsView: Self.NSViewType, context: Self.Context) -> CGSize?\nGiven a proposed size, returns the preferred size of the composite view.\n\nRequired Default implementation provided.\n\nCleaning up the view\nstatic func dismantleNSView(Self.NSViewType, coordinator: Self.Coordinator)\nCleans up the presented AppKit view (and coordinator) in anticipation of their removal.\n\nRequired Default implementation provided.\n\nProviding a custom coordinator object\nfunc makeCoordinator() -> Self.Coordinator\nCreates the custom instance that you use to communicate changes from your view to other parts of your SwiftUI interface.\n\nRequired Default implementation provided.\n\nassociatedtype Coordinator = Void\nA type to coordinate with the view.\n\nRequired\n\nPerforming layout\ntypealias LayoutOptions\nRelationships\nInherits From\nView\nSee Also\nAdding AppKit views to SwiftUI view hierarchies\nstruct NSViewRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view.\nprotocol NSViewControllerRepresentable\nA wrapper that you use to integrate an AppKit view controller into your SwiftUI interface.\nstruct NSViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view controller."
    },
    {
        "title": "importsItemProviders(_:onImport:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/importsitemproviders(_:onimport:)",
        "html": "Parameters\ncontentTypes\n\nThe types of content that the view supports importing. An empty array means the view does not currently support importing.\n\nonImport\n\nA closure that will be called with the imported service item. Return false to indicate that there was a failure to receive the items.\n\nSee Also\nImporting and exporting using item providers\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider]) -> some View\nExports a read-only item provider for consumption by shortcuts, quick actions, and services.\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider], onEdit: ([NSItemProvider]) -> Bool) -> some View\nExports a read-write item provider for consumption by shortcuts, quick actions, and services."
    },
    {
        "title": "exportsItemProviders(_:onExport:onEdit:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/exportsitemproviders(_:onexport:onedit:)",
        "html": "Parameters\ncontentTypes\n\nThe types of content that the view supports exporting and importing. An empty array means the view does not currently support exporting.\n\nonExport\n\nA closure that will be called on request of the items by the shortcut or service.\n\nonEdit\n\nA closure that will be called after the shortcut or service completes with its output data. This should replace the selected subpart that was exported with onExport. Return false to indicate that there was a failure to receive the items.\n\nDiscussion\n\nIf the associated view supports selection, the exported item should reflect that selected subpart.\n\nSee Also\nImporting and exporting using item providers\nfunc importsItemProviders([UTType], onImport: ([NSItemProvider]) -> Bool) -> some View\nEnables importing item providers from services, such as Continuity Camera on macOS.\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider]) -> some View\nExports a read-only item provider for consumption by shortcuts, quick actions, and services."
    },
    {
        "title": "handlesExternalEvents(preferring:allowing:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/handlesexternalevents(preferring:allowing:)",
        "html": "Parameters\npreferring\n\nA Set of Strings that are checked to see if they are contained in the targetContentIdenfifier to see if the Scene this View is in prefers to handle the Exernal Event. The empty Set and empty Strings never match. The String value \u201c*\u201d always matches. The String comparisons are case/diacritic insensitive\n\nallowing\n\nA Set of Strings that are checked to see if they are contained in the targetContentIdenfifier to see if the Scene this View is in allows handling the External Event. The empty Set and empty Strings never match. The String value \u201c*\u201d always matches.\n\nDiscussion\n\nIf no modifier is set in any Views within a Scene, the behavior is platform dependent. On macOS, a new Scene will be created to use for the External Event. On iOS, the system will choose an existing Scene to use.\n\nOn platforms that only allow a single Window/Scene, this method is ignored, and incoming External Events are always routed to the existing single Scene."
    },
    {
        "title": "accessibilityChildren(children:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilitychildren(children:)",
        "html": "Parameters\nchildren\n\nA ViewBuilder that represents the replacement child views the framework uses to generate accessibility elements.\n\nDiscussion\n\nUse this modifier to replace an existing element\u2019s children with one or more new synthetic accessibility elements you provide. This allows for synthetic, non-visual accessibility elements to be set as children of a visual accessibility element.\n\nSwiftUI creates an accessibility container implicitly when needed. If an accessibility element already exists, the framework converts it into an accessibility container.\n\nIn the example below, a Canvas displays a graph of vertical bars that don\u2019t have any inherent accessibility elements. You make the view accessible by adding the accessibilityChildren(children:) modifier with views whose accessibility elements represent the values of each bar drawn in the canvas:\n\nvar body: some View {\n    Canvas { context, size in\n        // Draw Graph\n        for data in dataSet {\n            let path = Path(\n                roundedRect: CGRect(\n                    x: (size.width / CGFloat(dataSet.count))\n                    * CGFloat(data.week),\n                    y: 0,\n                    width: size.width / CGFloat(dataSet.count),\n                    height: CGFloat(data.lines),\n                cornerRadius: 5)\n            context.fill(path, with: .color(.blue))\n        }\n        // Draw Axis and Labels\n        ...\n    }\n    .accessibilityLabel(\"Lines of Code per Week\")\n    .accessibilityChildren {\n        HStack {\n            ForEach(dataSet) { data in\n                RoundedRectangle(cornerRadius: 5)\n                    .accessibilityLabel(\"Week \\(data.week)\")\n                    .accessibilityValue(\"\\(data.lines) lines\")\n            }\n        }\n    }\n}\n\n\nSwiftUI hides any views that you provide with the children parameter, then the framework uses the views to generate the accessibility elements.\n\nSee Also\nCreating accessible elements\nfunc accessibilityElement(children: AccessibilityChildBehavior) -> some View\nCreates a new accessibility element, or modifies the AccessibilityChildBehavior of the existing accessibility element.\nfunc accessibilityRepresentation<V>(representation: () -> V) -> some View\nReplaces one or more accessibility elements for this view with new accessibility elements.\nstruct AccessibilityChildBehavior\nDefines the behavior for the child elements of the new parent element."
    },
    {
        "title": "accessibilityElement(children:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityelement(children:)",
        "html": "Parameters\nchildren\n\nThe behavior to use when creating or transforming an accessibility element. The default is ignore\n\nDiscussion\n\nSee also:\n\nignore\n\ncombine\n\ncontain\n\nSee Also\nCreating accessible elements\nfunc accessibilityChildren<V>(children: () -> V) -> some View\nReplaces the existing accessibility element\u2019s children with one or more new synthetic accessibility elements.\nfunc accessibilityRepresentation<V>(representation: () -> V) -> some View\nReplaces one or more accessibility elements for this view with new accessibility elements.\nstruct AccessibilityChildBehavior\nDefines the behavior for the child elements of the new parent element."
    },
    {
        "title": "accessibilityIdentifier(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityidentifier(_:)",
        "html": "Discussion\n\nUse this value for testing. It isn\u2019t visible to the user."
    },
    {
        "title": "Creating Accessible Views",
        "url": "https://developer.apple.com/documentation/swiftui/creating_accessible_views",
        "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC21 session 10119: SwiftUI Accessibility: Beyond the Basics."
    },
    {
        "title": "accessibilityRepresentation(representation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/accessibilityrepresentation(representation:)",
        "html": "Parameters\nrepresentation\n\nA hidden view that the accessibility system uses to generate accessibility elements.\n\nDiscussion\n\nYou can make controls accessible by using a custom style. For example, a custom ToggleStyle that you create inherits the accessibility features of Toggle automatically. When you can\u2019t use the parent view\u2019s accessibility elements, use the accessibilityRepresentation(representation:) modifier instead. This modifier replaces default accessibility elements with different accessibility elements that you provide. You use synthetic, non-visual accessibility elements to represent what the view displays.\n\nThe example below makes a custom adjustable control accessible by explicitly defining the representation of its step increments using a Slider:\n\nvar body: some View {\n    VStack {\n        SliderTrack(...) // Custom slider implementation.\n    }\n    .accessibilityRepresentation {\n        Slider(value: $value, in: 0...100) {\n            Text(\"Label\")\n        }\n    }\n}\n\n\nSwiftUI hides the view that you provide in the representation closure and makes it non-interactive. The framework uses it only to generate accessibility elements.\n\nSee Also\nCreating accessible elements\nfunc accessibilityElement(children: AccessibilityChildBehavior) -> some View\nCreates a new accessibility element, or modifies the AccessibilityChildBehavior of the existing accessibility element.\nfunc accessibilityChildren<V>(children: () -> V) -> some View\nReplaces the existing accessibility element\u2019s children with one or more new synthetic accessibility elements.\nstruct AccessibilityChildBehavior\nDefines the behavior for the child elements of the new parent element."
    },
    {
        "title": "AccessibilityChildBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitychildbehavior",
        "html": "Topics\nGetting behaviors\nstatic let combine: AccessibilityChildBehavior\nAny child accessibility element\u2019s properties are merged into the new accessibility element.\nstatic let contain: AccessibilityChildBehavior\nAny child accessibility elements become children of the new accessibility element.\nstatic let ignore: AccessibilityChildBehavior\nAny child accessibility elements become hidden.\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nCreating accessible elements\nfunc accessibilityElement(children: AccessibilityChildBehavior) -> some View\nCreates a new accessibility element, or modifies the AccessibilityChildBehavior of the existing accessibility element.\nfunc accessibilityChildren<V>(children: () -> V) -> some View\nReplaces the existing accessibility element\u2019s children with one or more new synthetic accessibility elements.\nfunc accessibilityRepresentation<V>(representation: () -> V) -> some View\nReplaces one or more accessibility elements for this view with new accessibility elements."
    },
    {
        "title": "AccessibilityTechnologies",
        "url": "https://developer.apple.com/documentation/swiftui/accessibilitytechnologies",
        "html": "Topics\nGetting technology types\nstatic var switchControl: AccessibilityTechnologies\nThe value that represents a Switch Control, allowing the use of the entire system using controller buttons, a breath-controlled switch or similar hardware.\nstatic var voiceOver: AccessibilityTechnologies\nThe value that represents the VoiceOver screen reader, allowing use of the system without seeing the screen visually.\nCreating a technology type\ninit()\nCreates a new accessibility technologies structure with an empy accessibility technology set.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nSendable\nSetAlgebra\nSee Also\nSupporting types\nstruct AccessibilityAttachmentModifier\nA view modifier that adds accessibility properties to the view"
    },
    {
        "title": "exclusively(before:)",
        "url": "https://developer.apple.com/documentation/swiftui/gesture/exclusively(before:)",
        "html": "Parameters\nother\n\nA gesture you combine with your gesture, to create a new, combined gesture.\n\nReturn Value\n\nA gesture that\u2019s the result of combining two gestures where only one of them can succeed. SwiftUI gives precedence to the first gesture.\n\nSee Also\nComposing gestures\nfunc simultaneously<Other>(with: Other) -> SimultaneousGesture<Self, Other>\nCombines a gesture with another gesture to create a new gesture that recognizes both gestures at the same time.\nfunc sequenced<Other>(before: Other) -> SequenceGesture<Self, Other>\nSequences a gesture with another one to create a new gesture, which results in the second gesture only receiving events after the first gesture succeeds."
    },
    {
        "title": "layoutPriority(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/layoutpriority(_:)",
        "html": "Parameters\nvalue\n\nThe priority by which a parent layout apportions space to the child.\n\nDiscussion\n\nViews typically have a default priority of 0 which causes space to be apportioned evenly to all sibling views. Raising a view\u2019s layout priority encourages the higher priority view to shrink later when the group is shrunk and stretch sooner when the group is stretched.\n\nHStack {\n    Text(\"This is a moderately long string.\")\n        .font(.largeTitle)\n        .border(Color.gray)\n\n\n    Spacer()\n\n\n    Text(\"This is a higher priority string.\")\n        .font(.largeTitle)\n        .layoutPriority(1)\n        .border(Color.gray)\n}\n\n\nIn the example above, the first Text element has the default priority 0 which causes its view to shrink dramatically due to the higher priority of the second Text element, even though all of their other attributes (font, font size and character count) are the same.\n\nA parent layout offers the child views with the highest layout priority all the space offered to the parent minus the minimum space required for all its lower-priority children.\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions."
    },
    {
        "title": "Aligning views across stacks",
        "url": "https://developer.apple.com/documentation/swiftui/aligning-views-across-stacks",
        "html": "Overview\n\nAs you nest stacks together, you may want specific items within those stacks to align with each other. By default, the alignment you specify for a stack applies only to that stack\u2019s child views. To align child views that reside in the nested stacks, define a custom alignment, assign it to the enclosing view, and use the alignment guide modifier to identify specific views to align.\n\nBegin with the default center alignment\n\nTo illustrate aligning items across stacks, the following view shows a horizontal stack wrapping around two nested vertical stacks that have a different number of child views. The enclosing HStack doesn\u2019t define an alignment, so it defaults to center.\n\nstruct ImageRow: View {\n    var body: some View {\n        HStack {\n            VStack {\n                Image(\"bell_peppers\")\n                    .resizable()\n                    .scaledToFit()\n                Text(\"Bell Peppers\")\n                    .font(.title)\n            }\n            VStack {\n                Image(\"chili_peppers\")\n                    .resizable()\n                    .scaledToFit()\n                Text(\"Chili Peppers\")\n                    .font(.title)\n                Text(\"Higher levels of capsicum\")\n                    .font(.caption)\n            }\n        }\n    }\n}\n\n\nThe image below shows the contents of a nested vertical stack aligning at the center of the stack. The child elements within the vertical stacks, such as the titles beneath each image, don\u2019t align with each other.\n\nDefine a custom alignment\n\nTo create a new vertical alignment guide, extend VerticalAlignment with a new static property for your guide. Name the guide according to what it aligns to make it easier to use. The following example uses bottom positioning as the default value for this guide:\n\nextension VerticalAlignment {\n    /// A custom alignment for image titles.\n    private struct ImageTitleAlignment: AlignmentID {\n        static func defaultValue(in context: ViewDimensions) -> CGFloat {\n            // Default to bottom alignment if no guides are set.\n            context[VerticalAlignment.bottom]\n        }\n    }\n\n\n    /// A guide for aligning titles.\n    static let imageTitleAlignmentGuide = VerticalAlignment(\n        ImageTitleAlignment.self\n    )\n}\n\nAssign and apply the custom alignment\n\nTo use the alignment guide, assign it to a parent view that encloses the views you want to align. The following example specifies imageTitleAlignmentGuide as the alignment for the horizontal stack:\n\nstruct RowOfAlignedImages: View {\n    var body: some View {\n        HStack(alignment: .imageTitleAlignmentGuide) {\n            VStack {\n                Image(\"bell_peppers\")\n                    .resizable()\n                    .scaledToFit()\n\n\n                Text(\"Bell Peppers\")\n                    .font(.title)\n            }\n            VStack {\n                Image(\"chili_peppers\")\n                    .resizable()\n                    .scaledToFit()\n\n\n                Text(\"Chili Peppers\")\n                    .font(.title)\n\n\n                Text(\"Higher levels of capsicum\")\n                    .font(.caption)\n            }\n        }\n    }\n}\n\n\nThe two vertical stacks now align on the bottoms of the stacks, using the default from your specification for the custom guide.\n\nWhen you define an alignment on a stack, it projects through enclosed child views. Within the nested VStack instances, apply alignmentGuide(_:computeValue:) to the views to align, using your custom guide for the HStack.\n\nstruct RowOfAlignedImages: View {\n    var body: some View {\n        HStack(alignment: .imageTitleAlignmentGuide) {\n            VStack {\n                Image(\"bell_peppers\")\n                    .resizable()\n                    .scaledToFit()\n\n\n                Text(\"Bell Peppers\")\n                    .font(.title)\n                    .alignmentGuide(.imageTitleAlignmentGuide) { context in\n                        context[.firstTextBaseline]\n                    }\n            }\n            VStack {\n                Image(\"chili_peppers\")\n                    .resizable()\n                    .scaledToFit()\n\n\n                Text(\"Chili Peppers\")\n                    .font(.title)\n                    .alignmentGuide(.imageTitleAlignmentGuide) { context in\n                        context[.firstTextBaseline]\n                    }\n\n\n                Text(\"Higher levels of capsicum\")\n                    .font(.caption)\n            }\n        }\n    }\n}\n\n\nThe closure from the alignment guide modifier returns firstTextBaseline, which aligns the baselines of the titles with the alignment guide imageTitleAlignmentGuide.\n\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "FocusedValues",
        "url": "https://developer.apple.com/documentation/swiftui/focusedvalues",
        "html": "Topics\nGetting the value for a key\nsubscript<Key>(Key.Type) -> Key.Value?\nReads and writes values associated with a given focused value key.\nRelationships\nConforms To\nEquatable\nSee Also\nExposing value types to focused views\nfunc focusedValue<T>(T?) -> some View\nSets the focused value for the given object type.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused view hierarchy.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the active scene.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused scene."
    },
    {
        "title": "AnyGesture",
        "url": "https://developer.apple.com/documentation/swiftui/anygesture",
        "html": "Topics\nImplementing a custom gesture\ninit<T>(T)\nCreates an instance from another gesture.\nRelationships\nConforms To\nGesture\nSee Also\nDefining custom gestures\nfunc highPriorityGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a higher precedence than gestures defined by the view.\nfunc defersSystemGestures(on: Edge.Set) -> some View\nSets the screen edge from which you want your gesture to take precedence over the system gesture.\nprotocol Gesture\nAn instance that matches a sequence of events to a gesture, and returns a stream of values for each of its states.\nstruct HandActivationBehavior\nAn activation behavior specific to hand-driven input.\nBeta"
    },
    {
        "title": "Gesture",
        "url": "https://developer.apple.com/documentation/swiftui/gesture",
        "html": "Overview\n\nCreate custom gestures by declaring types that conform to the Gesture protocol.\n\nTopics\nImplementing a custom gesture\nvar body: Self.Body\nThe content and behavior of the gesture.\n\nRequired\n\nassociatedtype Body : Gesture\nThe type of gesture representing the body of Self.\n\nRequired\n\nPerforming the gesture\nfunc updating<State>(GestureState<State>, body: (Self.Value, inout State, inout Transaction) -> Void) -> GestureStateGesture<Self, State>\nUpdates the provided gesture state property as the gesture\u2019s value changes.\nfunc onChanged((Self.Value) -> Void) -> _ChangedGesture<Self>\nAdds an action to perform when the gesture\u2019s value changes.\nAvailable when Value conforms to Equatable.\nfunc onEnded((Self.Value) -> Void) -> _EndedGesture<Self>\nAdds an action to perform when the gesture ends.\nassociatedtype Value\nThe type representing the gesture\u2019s value.\n\nRequired\n\nComposing gestures\nfunc simultaneously<Other>(with: Other) -> SimultaneousGesture<Self, Other>\nCombines a gesture with another gesture to create a new gesture that recognizes both gestures at the same time.\nfunc sequenced<Other>(before: Other) -> SequenceGesture<Self, Other>\nSequences a gesture with another one to create a new gesture, which results in the second gesture only receiving events after the first gesture succeeds.\nfunc exclusively<Other>(before: Other) -> ExclusiveGesture<Self, Other>\nCombines two gestures exclusively to create a new gesture where only one gesture succeeds, giving precedence to the first gesture.\nAdding modifier keys to a gesture\nfunc modifiers(EventModifiers) -> _ModifiersGesture<Self>\nCombines a gesture with keyboard modifiers.\nTransforming a gesture\nfunc map<T>((Self.Value) -> T) -> _MapGesture<Self, T>\nReturns a gesture that\u2019s the result of mapping the given closure over the gesture.\nCustomizing gesture activation\nfunc handActivationBehavior(HandActivationBehavior) -> some Gesture<Self.Value>\nCustomizes the activation behavior for a gesture when driven by hand or hand-like input.\nBeta\nUsing a gesture with a RealityKit entity\nfunc targetedToAnyEntity() -> some Gesture<EntityTargetValue<Self.Value>>\nRequire this gesture to target an entity.\nBeta\nfunc targetedToEntity(Entity) -> some Gesture<EntityTargetValue<Self.Value>>\nRequire this gesture to target entity or a descendant of entity. This is equivalent to targetedToEntity(.descendingFrom(entity)).\nBeta\nfunc targetedToEntity(where: QueryPredicate<Entity>) -> some Gesture<EntityTargetValue<Self.Value>>\nRequire this gesture to target an entity that can be found in the results of the specified QueryPredicate\nBeta\nRelationships\nConforming Types\nAnyGesture\nDragGesture\nExclusiveGesture\nGestureStateGesture\nLongPressGesture\nMagnificationGesture\nMagnifyGesture\nRotateGesture\nRotateGesture3D\nRotationGesture\nSequenceGesture\nSimultaneousGesture\nSpatialEventGesture\nSpatialTapGesture\nTapGesture\nSee Also\nDefining custom gestures\nfunc highPriorityGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a higher precedence than gestures defined by the view.\nfunc defersSystemGestures(on: Edge.Set) -> some View\nSets the screen edge from which you want your gesture to take precedence over the system gesture.\nstruct AnyGesture\nA type-erased gesture.\nstruct HandActivationBehavior\nAn activation behavior specific to hand-driven input.\nBeta"
    },
    {
        "title": "SimultaneousGesture",
        "url": "https://developer.apple.com/documentation/swiftui/simultaneousgesture",
        "html": "Overview\n\nA simultaneous gesture is a container-event handler that evaluates its two child gestures at the same time. Its value is a struct with two optional values, each representing the phases of one of the two gestures.\n\nTopics\nCreating the gesture\ninit(First, Second)\nCreates a gesture with two gestures that can receive updates or succeed independently of each other.\nvar first: First\nThe first of two gestures that can happen simultaneously.\nvar second: Second\nThe second of two gestures that can happen simultaneously.\nGetting the gesture\u2019s values\nstruct Value\nThe value of a simultaneous gesture that indicates which of its two gestures receives events.\nRelationships\nConforms To\nGesture\nSee Also\nCombining gestures\nComposing SwiftUI gestures\nCombine gestures to create complex interactions.\nfunc simultaneousGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view to process simultaneously with gestures defined by the view.\nstruct SequenceGesture\nA gesture that\u2019s a sequence of two gestures.\nstruct ExclusiveGesture\nA gesture that consists of two gestures where only one of them can succeed."
    },
    {
        "title": "highPriorityGesture(_:including:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/highprioritygesture(_:including:)",
        "html": "Parameters\ngesture\n\nA gesture to attach to the view.\n\nmask\n\nA value that controls how adding this gesture to the view affects other gestures recognized by the view and its subviews. Defaults to all.\n\nDiscussion\n\nUse this method when you need to define a high priority gesture to take precedence over the view\u2019s existing gestures. The example below defines a custom gesture that prints a message to the console and attaches it to the view\u2019s VStack. Inside the VStack a red heart Image defines its own TapGesture handler that also prints a message to the console, and a blue rectangle with no custom gesture handlers. Tapping or clicking any of the views results in a console message from the high priority gesture attached to the enclosing VStack.\n\nstruct HighPriorityGestureExample: View {\n    @State private var message = \"Message\"\n    let newGesture = TapGesture().onEnded {\n        print(\"Tap on VStack.\")\n    }\n\n\n    var body: some View {\n        VStack(spacing:25) {\n            Image(systemName: \"heart.fill\")\n                .resizable()\n                .frame(width: 75, height: 75)\n                .padding()\n                .foregroundColor(.red)\n                .onTapGesture {\n                    print(\"Tap on image.\")\n                }\n            Rectangle()\n                .fill(Color.blue)\n        }\n        .highPriorityGesture(newGesture)\n        .frame(width: 200, height: 200)\n        .border(Color.purple)\n    }\n}\n\nSee Also\nDefining custom gestures\nfunc defersSystemGestures(on: Edge.Set) -> some View\nSets the screen edge from which you want your gesture to take precedence over the system gesture.\nprotocol Gesture\nAn instance that matches a sequence of events to a gesture, and returns a stream of values for each of its states.\nstruct AnyGesture\nA type-erased gesture.\nstruct HandActivationBehavior\nAn activation behavior specific to hand-driven input.\nBeta"
    },
    {
        "title": "ExclusiveGesture",
        "url": "https://developer.apple.com/documentation/swiftui/exclusivegesture",
        "html": "Overview\n\nThe ExclusiveGesture gives precedence to its first gesture.\n\nTopics\nCreating the gesture\ninit(First, Second)\nCreates a gesture from two gestures where only one of them succeeds.\nvar first: First\nThe first of two gestures.\nvar second: Second\nThe second of two gestures.\nSupporting types\nenum Value\nThe value of an exclusive gesture that indicates which of two gestures succeeded.\nRelationships\nConforms To\nGesture\nSee Also\nCombining gestures\nComposing SwiftUI gestures\nCombine gestures to create complex interactions.\nfunc simultaneousGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view to process simultaneously with gestures defined by the view.\nstruct SequenceGesture\nA gesture that\u2019s a sequence of two gestures.\nstruct SimultaneousGesture\nA gesture containing two gestures that can happen at the same time with neither of them preceding the other."
    },
    {
        "title": "SequenceGesture",
        "url": "https://developer.apple.com/documentation/swiftui/sequencegesture",
        "html": "Overview\n\nRead Composing SwiftUI gestures to learn how you can create a sequence of two gestures.\n\nTopics\nCreating the gesture\ninit(First, Second)\nCreates a sequence gesture with two gestures.\nvar first: First\nThe first gesture in a sequence of two gestures.\nvar second: Second\nThe second gesture in a sequence of two gestures.\nGetting the gesture\u2019s values\nenum Value\nThe value of a sequence gesture that helps to detect whether the first gesture succeeded, so the second gesture can start.\nRelationships\nConforms To\nGesture\nSee Also\nCombining gestures\nComposing SwiftUI gestures\nCombine gestures to create complex interactions.\nfunc simultaneousGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view to process simultaneously with gestures defined by the view.\nstruct SimultaneousGesture\nA gesture containing two gestures that can happen at the same time with neither of them preceding the other.\nstruct ExclusiveGesture\nA gesture that consists of two gestures where only one of them can succeed."
    },
    {
        "title": "simultaneousGesture(_:including:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/simultaneousgesture(_:including:)",
        "html": "Parameters\ngesture\n\nA gesture to attach to the view.\n\nmask\n\nA value that controls how adding this gesture to the view affects other gestures recognized by the view and its subviews. Defaults to all.\n\nDiscussion\n\nUse this method when you need to define and process a view specific gesture simultaneously with the same priority as the view\u2019s existing gestures. The example below defines a custom gesture that prints a message to the console and attaches it to the view\u2019s VStack. Inside the VStack is a red heart Image defines its own TapGesture handler that also prints a message to the console and a blue rectangle with no custom gesture handlers.\n\nTapping or clicking the \u201cheart\u201d image sends two messages to the console: one for the image\u2019s tap gesture handler, and the other from a custom gesture handler attached to the enclosing vertical stack. Tapping or clicking on the blue rectangle results only in the single message to the console from the tap recognizer attached to the VStack:\n\nstruct SimultaneousGestureExample: View {\n    @State private var message = \"Message\"\n    let newGesture = TapGesture().onEnded {\n        print(\"Gesture on VStack.\")\n    }\n\n\n    var body: some View {\n        VStack(spacing:25) {\n            Image(systemName: \"heart.fill\")\n                .resizable()\n                .frame(width: 75, height: 75)\n                .padding()\n                .foregroundColor(.red)\n                .onTapGesture {\n                    print(\"Gesture on image.\")\n                }\n            Rectangle()\n                .fill(Color.blue)\n        }\n        .simultaneousGesture(newGesture)\n        .frame(width: 200, height: 200)\n        .border(Color.purple)\n    }\n}\n\nSee Also\nCombining gestures\nComposing SwiftUI gestures\nCombine gestures to create complex interactions.\nstruct SequenceGesture\nA gesture that\u2019s a sequence of two gestures.\nstruct SimultaneousGesture\nA gesture containing two gestures that can happen at the same time with neither of them preceding the other.\nstruct ExclusiveGesture\nA gesture that consists of two gestures where only one of them can succeed."
    },
    {
        "title": "GestureMask",
        "url": "https://developer.apple.com/documentation/swiftui/gesturemask",
        "html": "Topics\nGetting gesture options\nstatic let all: GestureMask\nEnable both the added gesture as well as all other gestures on the view and its subviews.\nstatic let gesture: GestureMask\nEnable the added gesture but disable all gestures in the subview hierarchy.\nstatic let subviews: GestureMask\nEnable all gestures in the subview hierarchy but disable the added gesture.\nstatic let none: GestureMask\nDisable all gestures in the subview hierarchy, including the added gesture.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nRecognizing gestures that change over time\nfunc gesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a lower precedence than gestures defined by the view.\nstruct DragGesture\nA dragging motion that invokes an action as the drag-event sequence changes.\nstruct MagnifyGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nstruct RotateGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nstruct RotateGesture3D\nA gesture that recognizes 3D rotation motion and tracks the angle and axis of the rotation.\nBeta"
    },
    {
        "title": "Composing SwiftUI gestures",
        "url": "https://developer.apple.com/documentation/swiftui/composing-swiftui-gestures",
        "html": "Overview\n\nWhen you add multiple gestures to your app\u2019s view hierarchy, you need to decide how the gestures interact with each other. You use gesture composition to define the order SwiftUI recognizes gestures. There are three gesture composition types:\n\nSimultaneous\n\nSequenced\n\nExclusive\n\nWhen you combine gesture modifiers simultaneously, SwiftUI must recognize all subgesture patterns at the same time for it to recognize the combining gesture. When you sequence gesture modifiers one after the other, SwiftUI must recognize each subgesture in order. Finally, when you combine gestures exclusively, SwiftUI recognizes the entire gesture pattern when SwiftUI only recognizes one subgesture but not the others.\n\nSequence one gesture after another\n\nWhen you sequence one gesture after another, SwiftUI recognizes the first gesture before it recognizes the second. For example, to require a long press before the user can drag a view, you sequence a DragGesture after a LongPressGesture.\n\nModel sequenced gesture states\n\nTo make it easier to track complicated states, use an enumeration that captures all of the states you need to configure your views. In the following example, there are three important states: no interaction (inactive), long press in progress (pressing), and dragging (dragging).\n\nstruct DraggableCircle: View {\n\n\n    enum DragState {\n        case inactive\n        case pressing\n        case dragging(translation: CGSize)\n        \n        var translation: CGSize {\n            switch self {\n            case .inactive, .pressing:\n                return .zero\n            case .dragging(let translation):\n                return translation\n            }\n        }\n        \n        var isActive: Bool {\n            switch self {\n            case .inactive:\n                return false\n            case .pressing, .dragging:\n                return true\n            }\n        }\n        \n        var isDragging: Bool {\n            switch self {\n            case .inactive, .pressing:\n                return false\n            case .dragging:\n                return true\n            }\n        }\n    }\n    \n    @GestureState private var dragState = DragState.inactive\n    @State private var viewState = CGSize.zero\n\nCreate gestures and update the UI state\n\nWhen you sequence two gestures, the callbacks capture the state of both gestures. In the update callback, the new value uses an enumeration to represent the combination of the possible gesture states. The code below converts the underlying gesture states into the high-level DragState enumeration defined above.\n\nvar body: some View {\n        let minimumLongPressDuration = 0.5\n        let longPressDrag = LongPressGesture(minimumDuration: minimumLongPressDuration)\n            .sequenced(before: DragGesture())\n            .updating($dragState) { value, state, transaction in\n                switch value {\n                // Long press begins.\n                case .first(true):\n                    state = .pressing\n                // Long press confirmed, dragging may begin.\n                case .second(true, let drag):\n                    state = .dragging(translation: drag?.translation ?? .zero)\n                // Dragging ended or the long press cancelled.\n                default:\n                    state = .inactive\n                }\n            }\n            .onEnded { value in\n                guard case .second(true, let drag?) = value else { return }\n                self.viewState.width += drag.translation.width\n                self.viewState.height += drag.translation.height\n            }\n\n\nWhen the user begins pressing the view, the drag state changes to pressing and a shadow animates under the shape. After the user finishes the long press and the drag state changes to dragging, a border appears around the shape to indicate that the user may begin moving the view.\n\n        return Circle()\n            .fill(Color.blue)\n            .overlay(dragState.isDragging ? Circle().stroke(Color.white, lineWidth: 2) : nil)\n            .frame(width: 100, height: 100, alignment: .center)\n            .offset(\n                x: viewState.width + dragState.translation.width,\n                y: viewState.height + dragState.translation.height\n            )\n            .animation(nil)\n            .shadow(radius: dragState.isActive ? 8 : 0)\n            .animation(.linear(duration: minimumLongPressDuration))\n            .gesture(longPressDrag)\n    }\n}\n\nSee Also\nCombining gestures\nfunc simultaneousGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view to process simultaneously with gestures defined by the view.\nstruct SequenceGesture\nA gesture that\u2019s a sequence of two gestures.\nstruct SimultaneousGesture\nA gesture containing two gestures that can happen at the same time with neither of them preceding the other.\nstruct ExclusiveGesture\nA gesture that consists of two gestures where only one of them can succeed."
    },
    {
        "title": "RotateGesture",
        "url": "https://developer.apple.com/documentation/swiftui/rotategesture",
        "html": "Overview\n\nA rotate gesture tracks how a rotation event sequence changes. To recognize a rotate gesture on a view, create and configure the gesture, and then add it to the view using the gesture(_:including:) modifier.\n\nAdd a rotate gesture to a Rectangle and apply a rotation effect:\n\nstruct RotateGestureView: View {\n    @State private var angle = Angle(degrees: 0.0)\n\n\n    var rotation: some Gesture {\n        RotateGesture()\n            .onChanged { value in\n                angle = value.rotation\n            }\n    }\n\n\n    var body: some View {\n        Rectangle()\n            .frame(width: 200, height: 200, alignment: .center)\n            .rotationEffect(angle)\n            .gesture(rotation)\n    }\n}\n\nTopics\nCreating the gesture\ninit(minimumAngleDelta: Angle)\nCreates a rotation gesture with a minimum delta for the gesture to start.\nvar minimumAngleDelta: Angle\nThe minimum delta required before the gesture succeeds.\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing gestures that change over time\nfunc gesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a lower precedence than gestures defined by the view.\nstruct DragGesture\nA dragging motion that invokes an action as the drag-event sequence changes.\nstruct MagnifyGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nstruct RotateGesture3D\nA gesture that recognizes 3D rotation motion and tracks the angle and axis of the rotation.\nBeta\nstruct GestureMask\nOptions that control how adding a gesture to a view affects other gestures recognized by the view and its subviews."
    },
    {
        "title": "RotateGesture3D",
        "url": "https://developer.apple.com/documentation/swiftui/rotategesture3d",
        "html": "Overview\n\nYou can constrain this gesture to recognize rotation about a specific 3D axis. For example, RotateGesture3D(constrainedToAxis: .x) creates a gesture that recognizes rotation only around the global X axis. The axis you provide will be normalized.\n\nA rotation gesture tracks how a rotation event sequence changes. To recognize a rotation gesture on a view, create and configure the gesture, and then add it to the view using the gesture(_:including:) modifier.\n\nTopics\nCreating the gesture\ninit(constrainedToAxis: RotationAxis3D?, minimumAngleDelta: Angle)\nCreates a rotation gesture with a minimum delta for the gesture to start and axis to constrain measurement of rotation.\nvar minimumAngleDelta: Angle\nThe minimum angle delta before the gesture becomes active.\nvar constrainedAxis: RotationAxis3D?\nAn axis around which the rotation is constrained.\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing gestures that change over time\nfunc gesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a lower precedence than gestures defined by the view.\nstruct DragGesture\nA dragging motion that invokes an action as the drag-event sequence changes.\nstruct MagnifyGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nstruct RotateGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nstruct GestureMask\nOptions that control how adding a gesture to a view affects other gestures recognized by the view and its subviews."
    },
    {
        "title": "DragGesture",
        "url": "https://developer.apple.com/documentation/swiftui/draggesture",
        "html": "Overview\n\nTo recognize a drag gesture on a view, create and configure the gesture, and then add it to the view using the gesture(_:including:) modifier.\n\nAdd a drag gesture to a Circle and change its color while the user performs the drag gesture:\n\nstruct DragGestureView: View {\n    @State private var isDragging = false\n\n\n    var drag: some Gesture {\n        DragGesture()\n            .onChanged { _ in self.isDragging = true }\n            .onEnded { _ in self.isDragging = false }\n    }\n\n\n    var body: some View {\n        Circle()\n            .fill(self.isDragging ? Color.red : Color.blue)\n            .frame(width: 100, height: 100, alignment: .center)\n            .gesture(drag)\n    }\n}\n\nTopics\nCreating a drag gesture\ninit(minimumDistance: CGFloat, coordinateSpace: some CoordinateSpaceProtocol)\nCreates a dragging gesture with the minimum dragging distance before the gesture succeeds and the coordinate space of the gesture\u2019s location.\nvar minimumDistance: CGFloat\nThe minimum dragging distance before the gesture succeeds.\nvar coordinateSpace: CoordinateSpace\nThe coordinate space in which to receive location values.\nDeprecated initializers\ninit(minimumDistance: CGFloat, coordinateSpace: CoordinateSpace)\nCreates a dragging gesture with the minimum dragging distance before the gesture succeeds and the coordinate space of the gesture\u2019s location.\nDeprecated\nStructures\nstruct Value\nThe attributes of a drag gesture.\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing gestures that change over time\nfunc gesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a lower precedence than gestures defined by the view.\nstruct MagnifyGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nstruct RotateGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nstruct RotateGesture3D\nA gesture that recognizes 3D rotation motion and tracks the angle and axis of the rotation.\nBeta\nstruct GestureMask\nOptions that control how adding a gesture to a view affects other gestures recognized by the view and its subviews."
    },
    {
        "title": "MagnifyGesture",
        "url": "https://developer.apple.com/documentation/swiftui/magnifygesture",
        "html": "Overview\n\nA magnify gesture tracks how a magnification event sequence changes. To recognize a magnify gesture on a view, create and configure the gesture, and then add it to the view using the gesture(_:including:) modifier.\n\nAdd a magnify gesture to a Circle that changes its size while the user performs the gesture:\n\nstruct MagnifyGestureView: View {\n    @GestureState private var magnifyBy = 1.0\n\n\n    var magnification: some Gesture {\n        MagnifyGesture()\n            .updating($magnifyBy) { value, gestureState, transaction in\n                gestureState = value.magnification\n            }\n    }\n\n\n    var body: some View {\n        Circle()\n            .frame(width: 100, height: 100)\n            .scaleEffect(magnifyBy)\n            .gesture(magnification)\n    }\n}\n\nTopics\nCreating the gesture\ninit(minimumScaleDelta: CGFloat)\nCreates a magnify gesture with a given minimum delta for the gesture to start.\nvar minimumScaleDelta: CGFloat\nThe minimum required delta before the gesture starts.\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing gestures that change over time\nfunc gesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a lower precedence than gestures defined by the view.\nstruct DragGesture\nA dragging motion that invokes an action as the drag-event sequence changes.\nstruct RotateGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nstruct RotateGesture3D\nA gesture that recognizes 3D rotation motion and tracks the angle and axis of the rotation.\nBeta\nstruct GestureMask\nOptions that control how adding a gesture to a view affects other gestures recognized by the view and its subviews."
    },
    {
        "title": "SpatialEventCollection",
        "url": "https://developer.apple.com/documentation/swiftui/spatialeventcollection",
        "html": "Overview\n\nYou receive a structure of this type as an input to the onChanged(_:) or onEnded(_:) method of a SpatialEventGesture. The structure contains a collection of SpatialEventCollection.Event values that correspond to ongoing input events. You can look up a specific event in the collection by its id value or iterate over all events in the collection to apply logic depending on the event\u2019s state.\n\nTopics\nAccessing the collection\u2019s events\nstruct Event\nA spatial event generated from an input like a touch or click that can drive gestures in the system.\nsubscript(SpatialEventCollection.Event.ID) -> SpatialEventCollection.Event?\nRetrieves an event using its unique identifier.\nIterating over events in the collection\nfunc makeIterator() -> SpatialEventCollection.Iterator\nMakes an iterator over all events in the collection.\nstruct Iterator\nAn iterator over all events in the collection.\nRelationships\nConforms To\nCollection\nEquatable\nSequence\nSee Also\nRecognizing spatial events\nstruct SpatialEventGesture\nA gesture that provides information about ongoing spatial events like clicks and touches.\nBeta"
    },
    {
        "title": "onLongTouchGesture(minimumDuration:perform:onTouchingChanged:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onlongtouchgesture(minimumduration:perform:ontouchingchanged:)",
        "html": "Parameters\nminimumDuration\n\nThe minimum duration of the long touch that must elapse before the gesture succeeds.\n\naction\n\nThe action to perform when a long touch is recognized\n\nonTouchingChanged\n\nA closure to run when the touching state of the gesture changes, passing the current state as a parameter.\n\nSee Also\nRecognizing long press gestures\nfunc onLongPressGesture(minimumDuration: Double, maximumDistance: CGFloat, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongPressGesture(minimumDuration: Double, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nstruct LongPressGesture\nA gesture that succeeds when the user performs a long press."
    },
    {
        "title": "PhysicalMetricsConverter",
        "url": "https://developer.apple.com/documentation/swiftui/physicalmetricsconverter",
        "html": "Overview\n\nConverters are available from the environment of a View or other type that inherits a View\u2018s environments, and are associated with the scene that contains that environment. The conversions expect (or emit) values in points in that scene\u2019s coordinate system, and convert these to (or from) measurements of length in the user\u2019s reference frame. For example, if the scene is scaled, that scale will be taken into account.\n\nTo obtain a converter, use the physicalMetrics key:\n\nstruct MyView: View {\n    @Environment(\\.physicalMetrics) var physicalMetrics\n    \u2026\n}\n\n\nWhen user action modifies a scene so that measurements have changed (e.g., by changing its scale), the view that accessed that environment key and its hierarchy will be reevaluated.\n\nAttempting to obtain a converter inside a type not associated with a scene\u2019s contents (for example, from an App or Scene\u2019s environment) is not supported.\n\nTopics\nConverting from a unit length\nfunc convert(CGPoint, from: UnitLength) -> CGPoint\nConverts a point, whose coordinates are in the specified unit, to a point suitable for use in the environment this converter is associated with.\nfunc convert(Rect3D, from: UnitLength) -> Rect3D\nConverts a Rect3D, whose coordinates are in the specified unit, to a Rect3D with coordinates specified in points, suitable for use in the environment this converter is associated with.\nfunc convert(Size3D, from: UnitLength) -> Size3D\nConverts a size, given in the specified unit, to a size in points suitable for use in the environment this converter is associated with.\nfunc convert(CGFloat, from: UnitLength) -> CGFloat\nConverts a length in the specified unit to a length in points suitable for use in the environment this converter is associated with.\nfunc convert(Point3D, from: UnitLength) -> Point3D\nConverts a point, whose coordinates are in the specified unit, to a point value suitable for use in the environment this converter is associated with.\nfunc convert(CGSize, from: UnitLength) -> CGSize\nConverts a size, given in the specified unit, to a size in points suitable for use in the environment this converter is associated with.\nfunc convert<V>(V, from: UnitLength) -> V\nConverts a vector of physical length measurements, in the specified unit, to a vector of values in points suitable for use in the environment this converter is associated with.\nfunc convert(CGRect, from: UnitLength) -> CGRect\nConverts a rectangle, whose coordinates are in the specified unit, to a rectangle with coordinates specified in points, suitable for use in the environment this converter is associated with.\nConverting to a unit length\nfunc convert(Rect3D, to: UnitLength) -> Rect3D\nConverts a Rect3D\u2019s coordinates to physical length measurements in the specified unit.\nfunc convert(CGRect, to: UnitLength) -> CGRect\nConverts a rectangle\u2019s coordinates to physical length measurements in the specified unit.\nfunc convert(CGPoint, to: UnitLength) -> CGPoint\nConverts a point\u2019s coordinates to physical length measurements in the specified unit.\nfunc convert<V>(V, to: UnitLength) -> V\nConverts a vector of values in points to corresponding physical length measurements in the specified unit.\nfunc convert(Point3D, to: UnitLength) -> Point3D\nConverts a point\u2019s coordinates to physical length measurements in the specified unit.\nfunc convert(CGSize, to: UnitLength) -> CGSize\nConverts a size, specified in points, to physical length measurements in the specified unit.\nfunc convert(Size3D, to: UnitLength) -> Size3D\nConverts a size, specified in points, to physical length measurements in the specified unit.\nfunc convert(CGFloat, to: UnitLength) -> CGFloat\nConverts a length in points to a physical length measurement in the specified unit.\nRelationships\nConforms To\nEquatable\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta"
    },
    {
        "title": "onTapGesture(count:coordinateSpace:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ontapgesture(count:coordinatespace:perform:)-21n4i",
        "html": "Parameters\ncount\n\nThe number of taps or clicks required to trigger the action closure provided in action. Defaults to 1.\n\ncoordinateSpace\n\nThe coordinate space in which to receive location values. Defaults to CoordinateSpace.local.\n\naction\n\nThe action to perform. This closure receives an input that indicates where the interaction occurred.\n\nDiscussion\n\nUse this method to perform the specified action when the user clicks or taps on the modified view count times. The action closure receives the location of the interaction.\n\nNote\n\nIf you create a control that\u2019s functionally equivalent to a Button, use ButtonStyle to create a customized button instead.\n\nThe following code adds a tap gesture to a Circle that toggles the color of the circle based on the tap location.\n\nstruct TapGestureExample: View {\n    @State private var location: CGPoint = .zero\n\n\n    var body: some View {\n        Circle()\n            .fill(self.location.y > 50 ? Color.blue : Color.red)\n            .frame(width: 100, height: 100, alignment: .center)\n            .onTapGesture { location in\n                self.location = location\n            }\n    }\n}\n\nSee Also\nRecognizing tap gestures\nfunc onTapGesture(count: Int, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture.\nstruct TapGesture\nA gesture that recognizes one or more taps.\nstruct SpatialTapGesture\nA gesture that recognizes one or more taps and reports their location."
    },
    {
        "title": "SpatialEventGesture",
        "url": "https://developer.apple.com/documentation/swiftui/spatialeventgesture",
        "html": "Overview\n\nUse a gesture of this type to track multiple simultaneous spatial events and gain access to detailed information about each. For example, you can place a particle emitter at every location in a Canvas that has an ongoing spatial event:\n\nstruct ParticlePlayground: View {\n    @State var model = ParticlesModel()\n\n\n    var body: some View {\n        Canvas { context, size in\n            for particle in model.particles {\n                context.fill(Path(ellipseIn: particle.frame),\n                             with: .color(particle.color))\n            }\n        }\n        .gesture(\n            SpatialEventGesture()\n                .onChanged { events in\n                    for event in events {\n                        if event.phase == .active {\n                            // Update particle emitters.\n                            model.emitters[event.id] = ParticlesModel.Emitter(\n                                location: event.location\n                            )\n                        } else {\n                            // Remove emitters when no longer active.\n                            model.emitters[event.id] = nil\n                        }\n                    }\n                }\n                .onEnded { events in\n                    for event in events {\n                        // Remove emitters when no longer active.\n                        model.emitters[event.id] = nil\n                    }\n                }\n        )\n    }\n}\n\n\nThe gesture provides a SpatialEventCollection structure when it detects changes. The collection contains SpatialEventCollection.Event values that represent ongoing spatial events. Each event contains a stable, unique identifier so that you can track how the event changes over time. The event also indicates its current location, a timestamp, the pose of the input device that creates it, and other useful information.\n\nThe phase of events in the collection can change to SpatialEventCollection.Event.Phase.ended or SpatialEventCollection.Event.Phase.cancelled while the gesture itself remains active. Individually track state for each event inside onChanged(_:) or updating(_:body:) and clean up all state in onEnded(_:).\n\nTip\n\nOnly use a spatial event gesture if you need to access low-level event information, like when you create a complex multi-touch experience. For most use cases, it\u2019s better to rely on gestures that recognize targeted interactions, like a SpatialTapGesture, MagnifyGesture, or DragGesture.\n\nTopics\nCreating a spatial event gesture\ninit(coordinateSpace: CoordinateSpaceProtocol)\nCreates the gesture with a desired coordinate space.\nGetting gesture properties\nlet coordinateSpace: CoordinateSpace\nThe coordinate space of the gesture.\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing spatial events\nstruct SpatialEventCollection\nA collection of spatial input events that target a specific view.\nBeta"
    },
    {
        "title": "onLongPressGesture(minimumDuration:maximumDistance:perform:onPressingChanged:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onlongpressgesture(minimumduration:maximumdistance:perform:onpressingchanged:)",
        "html": "Parameters\nminimumDuration\n\nThe minimum duration of the long press that must elapse before the gesture succeeds.\n\nmaximumDistance\n\nThe maximum distance that the fingers or cursor performing the long press can move before the gesture fails.\n\naction\n\nThe action to perform when a long press is recognized.\n\nonPressingChanged\n\nA closure to run when the pressing state of the gesture changes, passing the current state as a parameter.\n\nSee Also\nRecognizing long press gestures\nfunc onLongPressGesture(minimumDuration: Double, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongTouchGesture(minimumDuration: Double, perform: () -> Void, onTouchingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a remote long touch gesture. A long touch gesture is when the finger is on the remote touch surface without actually pressing.\nstruct LongPressGesture\nA gesture that succeeds when the user performs a long press."
    },
    {
        "title": "onLongPressGesture(minimumDuration:perform:onPressingChanged:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onlongpressgesture(minimumduration:perform:onpressingchanged:)",
        "html": "Parameters\nminimumDuration\n\nThe minimum duration of the long press that must elapse before the gesture succeeds.\n\naction\n\nThe action to perform when a long press is recognized.\n\nonPressingChanged\n\nA closure to run when the pressing state of the gesture changes, passing the current state as a parameter.\n\nSee Also\nRecognizing long press gestures\nfunc onLongPressGesture(minimumDuration: Double, maximumDistance: CGFloat, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongTouchGesture(minimumDuration: Double, perform: () -> Void, onTouchingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a remote long touch gesture. A long touch gesture is when the finger is on the remote touch surface without actually pressing.\nstruct LongPressGesture\nA gesture that succeeds when the user performs a long press."
    },
    {
        "title": "containerRelativeFrame(_:alignment:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/containerrelativeframe(_:alignment:)",
        "html": "Discussion\n\nUse this modifier to specify a size for a view\u2019s width, height, or both that is dependent on the size of the nearest container. Different things can represent a \u201ccontainer\u201d including:\n\nThe window presenting a view on iPadOS or macOS, or the screen of a device on iOS.\n\nA column of a NavigationSplitView\n\nA NavigationStack\n\nA tab of a TabView\n\nA scrollable view like ScrollView or List\n\nThe size provided to this modifier is the size of a container like the ones listed above subtracting any safe area insets that might be applied to that container.\n\nThe following example will have each purple rectangle occupy the full size of the screen on iOS:\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 0.0) {\n        ForEach(items) { item in\n            Rectangle()\n                .fill(.purple)\n                .containerRelativeFrame([.horizontal, .vertical])\n        }\n    }\n}\n\n\nUse the containerRelativeFrame(_:count:span:spacing:alignment:) modifier to size a view such that multiple views will be visible in the container. When using this modifier, the count refers to the total number of rows or columns that the length of the container size in a particular axis should be divided into. The span refers to the number of rows or columns that the modified view should actually occupy. Thus the size of the element can be described like so:\n\nlet availableWidth = (containerWidth - (spacing * (count - 1)))\nlet columnWidth = (availableWidth / count)\nlet itemWidth = (columnWidth * span) + ((span - 1) * spacing)\n\n\nThe following example only uses the nearest container size in the horizontal axis, allowing the vertical axis to be determined using the aspectRatio(_:contentMode:) modifier.\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 10.0) {\n        ForEach(items) { item in\n            Rectangle()\n                .fill(.purple)\n                .aspectRatio(3.0 / 2.0, contentMode: .fit)\n                .containerRelativeFrame(\n                    .horizontal, count: 4, span: 3, spacing: 10.0)\n        }\n    }\n}\n.safeAreaPadding(.horizontal, 20.0)\n\n\nUse the containerRelativeFrame(_:alignment:_:) modifier to apply your own custom logic to adjust the size of the nearest container for your view. The following example will result in the container frame\u2019s width being divided by 3 and using that value as the width of the purple rectangle.\n\nRectangle()\n    .fill(.purple)\n    .aspectRatio(1.0, contentMode: .fill)\n    .containerRelativeFrame(\n        .horizontal, alignment: .topLeading\n    ) { length, axis in\n        if axis == .vertical {\n            return length / 3.0\n        } else {\n            return length / 5.0\n        }\n    }\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "LayoutDirection",
        "url": "https://developer.apple.com/documentation/swiftui/layoutdirection",
        "html": "Overview\n\nSwiftUI supports both left-to-right and right-to-left directions for laying out content to support different languages and locales. The system sets the value based on the user\u2019s locale, but you can also use the environment(_:_:) modifier to override the direction for a view and its child views:\n\nMyView()\n    .environment(\\.layoutDirection, .rightToLeft)\n\n\nYou can also read the layoutDirection environment value to find out which direction applies to a particular environment. However, in many cases, you don\u2019t need to take any action based on this value. SwiftUI horizontally flips the x position of each view within its parent, so layout calculations automatically produce the desired effect for both modes without any changes.\n\nTopics\nGetting layout directions\ncase leftToRight\nA left-to-right layout direction.\ncase rightToLeft\nA right-to-left layout direction.\nCreating a layout direction\ninit?(UITraitEnvironmentLayoutDirection)\nCreate a direction from its UITraitEnvironmentLayoutDirection equivalent.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nSetting a layout direction\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> some View\nSets the behavior of this view for different layout directions.\nenum LayoutDirectionBehavior\nA description of what should happen when the layout direction changes.\nvar layoutDirection: LayoutDirection\nThe layout direction associated with the current environment."
    },
    {
        "title": "Inspecting view layout",
        "url": "https://developer.apple.com/documentation/swiftui/inspecting-view-layout",
        "html": "Overview\n\nTo learn how SwiftUI sizes and positions views, take advantage of Xcode previews to inspect a single view\u2019s boundaries. You can also add temporary borders to see how SwiftUI positions and sizes multiple views together.\n\nHighlight views with Xcode previews\n\nUsing Xcode previews, you can quickly see the size of a specific view element by selecting the view or child view in the editor. To illustrate this, the following example uses a VStack to vertically group an image, provided by SF Symbols, above a name:\n\nstruct StatusRow: View {\n \u00a0\u00a0\u00a0let name: String\n\n\n \u00a0\u00a0\u00a0var body: some View {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0VStack {\n            Image(systemName: \"person.circle\")\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Text(name)\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n \u00a0\u00a0\u00a0}\n}\n\n\nstruct StatusRow_Previews: PreviewProvider {\n    static var previews: some View {\n        StatusRow(name: \"Maria\")\n    }\n}\n\n\nWith the VStack selected, you\u2019ll see a blue border around the view in the Xcode preview:\n\nUse temporary borders to explore complex layouts\n\nTo see the border of more than one view, or to see a border when the view isn\u2019t selected, temporarily add a border with the view modifier border(_:width:). Set the border\u2019s color to something other than blue to easily distinguish it from a border added by Xcode:\n\nstruct StatusRow: View {\n \u00a0\u00a0\u00a0let name: String\n\n\n \u00a0\u00a0\u00a0var body: some View {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0VStack {\n            Image(systemName: \"person.circle\")\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Text(name)\n                .border(Color.red)\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n        .padding()\n        .border(Color.gray)\n \u00a0\u00a0\u00a0}\n}\n\n\nSee Also\nFinetuning a layout\nLaying out a simple view\nCreate a view layout by adjusting the size of views."
    },
    {
        "title": "TableColumnCustomizationBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/tablecolumncustomizationbehavior",
        "html": "Overview\n\nThis is used as a value provided to disabledCustomizationBehavior(_:).\n\nSetting any of these values as the disabledCustomizationBehavior(_:) doesn\u2019t have any effect on iOS.\n\nTopics\nGetting the customization behavior\nstatic var all: TableColumnCustomizationBehavior\nAll customization behaviors.\nstatic let reorder: TableColumnCustomizationBehavior\nA behavior that allows the column to be reordered by the user.\nstatic let resize: TableColumnCustomizationBehavior\nA behavior that allows the column to be resized by the user.\nstatic let visibility: TableColumnCustomizationBehavior\nA behavior that allows the column to be hidden or revealed by the user.\nCreating a behavior\ninit()\nCreates an empty customization behavior, representing no customization\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nSendable\nSetAlgebra\nSee Also\nCustomizing columns\nfunc tableColumnHeaders(Visibility) -> some View\nControls the visibility of a Table\u2019s column header views.\nstruct TableColumnCustomization\nA representation of the state of the columns in a table."
    },
    {
        "title": "SpatialTapGesture",
        "url": "https://developer.apple.com/documentation/swiftui/spatialtapgesture",
        "html": "Overview\n\nTo recognize a tap gesture on a view, create and configure the gesture, and then add it to the view using the gesture(_:including:) modifier. The following code adds a tap gesture to a Circle that toggles the color of the circle based on the tap location:\n\nstruct TapGestureView: View {\n    @State private var location: CGPoint = .zero\n\n\n    var tap: some Gesture {\n        SpatialTapGesture()\n            .onEnded { event in\n                self.location = event.location\n             }\n    }\n\n\n    var body: some View {\n        Circle()\n            .fill(self.location.y > 50 ? Color.blue : Color.red)\n            .frame(width: 100, height: 100, alignment: .center)\n            .gesture(tap)\n    }\n}\n\nTopics\nCreating a spatial tap gesture\ninit(count: Int, coordinateSpace: some CoordinateSpaceProtocol)\nCreates a tap gesture with the number of required taps and the coordinate space of the gesture\u2019s location.\nvar coordinateSpace: CoordinateSpace\nThe coordinate space in which to receive location values.\nvar count: Int\nThe required number of tap events.\nGetting the gesture\u2019s value\nstruct Value\nThe attributes of a tap gesture.\nDeprecated initializers\ninit(count: Int, coordinateSpace: CoordinateSpace)\nCreates a tap gesture with the number of required taps and the coordinate space of the gesture\u2019s location.\nDeprecated\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing tap gestures\nfunc onTapGesture(count: Int, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture.\nfunc onTapGesture(count: Int, coordinateSpace: some CoordinateSpaceProtocol, perform: (CGPoint) -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture, and provides the action with the location of the interaction.\nstruct TapGesture\nA gesture that recognizes one or more taps."
    },
    {
        "title": "blur(radius:opaque:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/blur(radius:opaque:)",
        "html": "Parameters\nradius\n\nThe radial size of the blur. A blur is more diffuse when its radius is large.\n\nopaque\n\nA Boolean value that indicates whether the blur renderer permits transparency in the blur output. Set to true to create an opaque blur, or set to false to permit transparency.\n\nDiscussion\n\nUse blur(radius:opaque:) to apply a gaussian blur effect to the rendering of this view.\n\nThe example below shows two Text views, the first with no blur effects, the second with blur(radius:opaque:) applied with the radius set to 2. The larger the radius, the more diffuse the effect.\n\nstruct Blur: View {\n    var body: some View {\n        VStack {\n            Text(\"This is some text.\")\n                .padding()\n            Text(\"This is some blurry text.\")\n                .blur(radius: 2.0)\n        }\n    }\n}\n\n\nSee Also\nApplying blur and shadows\nfunc shadow(color: Color, radius: CGFloat, x: CGFloat, y: CGFloat) -> some View\nAdds a shadow to this view.\nstruct ColorMatrix\nA matrix to use in an RGBA color transformation."
    },
    {
        "title": "TapGesture",
        "url": "https://developer.apple.com/documentation/swiftui/tapgesture",
        "html": "Overview\n\nTo recognize a tap gesture on a view, create and configure the gesture, and then add it to the view using the gesture(_:including:) modifier. The following code adds a tap gesture to a Circle that toggles the color of the circle:\n\nstruct TapGestureView: View {\n    @State private var tapped = false\n\n\n    var tap: some Gesture {\n        TapGesture(count: 1)\n            .onEnded { _ in self.tapped = !self.tapped }\n    }\n\n\n    var body: some View {\n        Circle()\n            .fill(self.tapped ? Color.blue : Color.red)\n            .frame(width: 100, height: 100, alignment: .center)\n            .gesture(tap)\n    }\n}\n\nTopics\nCreating a tap gesture\ninit(count: Int)\nCreates a tap gesture with the number of required taps.\nvar count: Int\nThe required number of tap events.\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing tap gestures\nfunc onTapGesture(count: Int, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture.\nfunc onTapGesture(count: Int, coordinateSpace: some CoordinateSpaceProtocol, perform: (CGPoint) -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture, and provides the action with the location of the interaction.\nstruct SpatialTapGesture\nA gesture that recognizes one or more taps and reports their location."
    },
    {
        "title": "padding(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/padding(_:)-6pgqq",
        "html": "Parameters\ninsets\n\nAn EdgeInsets instance that contains padding amounts for each edge.\n\nReturn Value\n\nA view that\u2019s padded by different amounts on each edge.\n\nDiscussion\n\nUse this modifier to add a different amount of padding on each edge of a view:\n\nVStack {\n    Text(\"Text padded by different amounts on each edge.\")\n        .padding(EdgeInsets(top: 10, leading: 20, bottom: 40, trailing: 0))\n        .border(.gray)\n    Text(\"Unpadded text for comparison.\")\n        .border(.yellow)\n}\n\n\nThe order in which you apply modifiers matters. The example above applies the padding before applying the border to ensure that the border encompasses the padded region:\n\nTo pad a view on specific edges with equal padding for all padded edges, use padding(_:_:). To pad all edges of a view equally, use padding(_:).\n\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "shadow(color:radius:x:y:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/shadow(color:radius:x:y:)",
        "html": "Parameters\ncolor\n\nThe shadow\u2019s color.\n\nradius\n\nA measure of how much to blur the shadow. Larger values result in more blur.\n\nx\n\nAn amount to offset the shadow horizontally from the view.\n\ny\n\nAn amount to offset the shadow vertically from the view.\n\nReturn Value\n\nA view that adds a shadow to this view.\n\nDiscussion\n\nUse this modifier to add a shadow of a specified color behind a view. You can offset the shadow from its view independently in the horizontal and vertical dimensions using the x and y parameters. You can also blur the edges of the shadow using the radius parameter. Use a radius of zero to create a sharp shadow. Larger radius values produce softer shadows.\n\nThe example below creates a grid of boxes with varying offsets and blur. Each box displays its radius and offset values for reference.\n\nstruct Shadow: View {\n    let steps = [0, 5, 10]\n\n\n    var body: some View {\n        VStack(spacing: 50) {\n            ForEach(steps, id: \\.self) { offset in\n                HStack(spacing: 50) {\n                    ForEach(steps, id: \\.self) { radius in\n                        Color.blue\n                            .shadow(\n                                color: .primary,\n                                radius: CGFloat(radius),\n                                x: CGFloat(offset), y: CGFloat(offset))\n                            .overlay {\n                                VStack {\n                                    Text(\"\\(radius)\")\n                                    Text(\"(\\(offset), \\(offset))\")\n                                }\n                            }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nThe example above uses primary as the color to make the shadow easy to see for the purpose of illustration. In practice, you might prefer something more subtle, like gray. If you don\u2019t specify a color, the method uses a semi-transparent black.\n\nSee Also\nApplying blur and shadows\nfunc blur(radius: CGFloat, opaque: Bool) -> some View\nApplies a Gaussian blur to this view.\nstruct ColorMatrix\nA matrix to use in an RGBA color transformation."
    },
    {
        "title": "visualEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/visualeffect(_:)",
        "html": "Parameters\neffect\n\nA closure that returns the effect to be applied. The first argument provided to the closure is a placeholder representing this view. The second argument is a GeometryProxy.\n\nReturn Value\n\nA view with the effect applied.\n\nDiscussion\n\nYou return new effects by calling functions on the first argument provided to the effect closure. In this example, ContentView is offset by its own size, causing its top left corner to appear where the bottom right corner was originally located:\n\nContentView()\n    .visualEffect { content, geometryProxy in\n        content.offset(geometryProxy.size)\n    }\n\nSee Also\nApplying effects based on geometry\nfunc visualEffect3D((EmptyVisualEffect, GeometryProxy3D) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a 3D geometry proxy.\nBeta\nprotocol VisualEffect\nVisual Effects change the visual appearance of a view without changing its ancestors or descendents.\nstruct EmptyVisualEffect\nThe base visual effect that you apply additional effect to."
    },
    {
        "title": "padding(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/padding(_:)-68shk",
        "html": "Parameters\nlength\n\nThe amount, given in points, to pad this view on all edges.\n\nReturn Value\n\nA view that\u2019s padded by the amount you specify.\n\nDiscussion\n\nUse this modifier to add padding all the way around a view.\n\nVStack {\n    Text(\"Text padded by 10 points on each edge.\")\n        .padding(10)\n        .border(.gray)\n    Text(\"Unpadded text for comparison.\")\n        .border(.yellow)\n}\n\n\nThe order in which you apply modifiers matters. The example above applies the padding before applying the border to ensure that the border encompasses the padded region:\n\nTo independently control the amount of padding for each edge, use padding(_:). To pad a select set of edges by the same amount, use padding(_:_:).\n\nSee Also\nAdding padding around a view\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "focused(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focused(_:)",
        "html": "Parameters\ncondition\n\nThe focus state to bind. When focus moves to the view, the binding sets the bound value to true. If a caller sets the value to true programmatically, then focus moves to the modified view. When focus leaves the modified view, the binding sets the value to false. If a caller sets the value to false, SwiftUI automatically dismisses focus.\n\nReturn Value\n\nThe modified view.\n\nDiscussion\n\nUse this modifier to cause the view to receive focus whenever the the condition value is true. You can use this modifier to observe the focus state of a single view, or programmatically set and remove focus from the view.\n\nIn the following example, a single TextField accepts a user\u2019s desired username. The text field binds its focus state to the Boolean value usernameFieldIsFocused. A \u201cSubmit\u201d button\u2019s action verifies whether the name is available. If the name is unavailable, the button sets usernameFieldIsFocused to true, which causes focus to return to the text field, so the user can enter a different name.\n\n@State private var username: String = \"\"\n@FocusState private var usernameFieldIsFocused: Bool\n@State private var showUsernameTaken = false\n\n\nvar body: some View {\n    VStack {\n        TextField(\"Choose a username.\", text: $username)\n            .focused($usernameFieldIsFocused)\n        if showUsernameTaken {\n            Text(\"That username is taken. Please choose another.\")\n        }\n        Button(\"Submit\") {\n            showUsernameTaken = false\n            if !isUserNameAvailable(username: username) {\n                usernameFieldIsFocused = true\n                showUsernameTaken = true\n            }\n        }\n    }\n}\n\n\nTo control focus by matching a value, use the focused(_:equals:) method instead.\n\nSee Also\nManaging focus state\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nstruct FocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the placement of focus within the scene changes.\nstruct FocusedValue\nA property wrapper for observing values from the focused view or one of its ancestors.\nprotocol FocusedValueKey\nA protocol for identifier types used when publishing and observing focused values.\nstruct FocusedBinding\nA convenience property wrapper for observing and automatically unwrapping state bindings from the focused view or one of its ancestors."
    },
    {
        "title": "springLoadingBehavior(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/springloadingbehavior(_:)",
        "html": "Parameters\nbehavior\n\nWhether spring loading is enabled or not. If unspecified, the default behavior is .automatic.\n\nDiscussion\n\nSpring loading refers to a view being activated during a drag and drop interaction. On iOS this can occur when pausing briefly on top of a view with dragged content. On macOS this can occur with similar brief pauses or on pressure-sensitive systems by \u201cforce clicking\u201d during the drag. This has no effect on tvOS or watchOS.\n\nThis is commonly used with views that have a navigation or presentation effect, allowing the destination to be revealed without pausing the drag interaction. For example, a button that reveals a list of folders that a dragged item can be dropped onto.\n\nButton {\n    showFolders = true\n} label: {\n    Label(\"Show Folders\", systemImage: \"folder\")\n}\n.springLoadingBehavior(.enabled)\n\n\nUnlike disabled(_:), this modifier overrides the value set by an ancestor view rather than being unioned with it. For example, the below button would allow spring loading:\n\nHStack {\n    Button {\n        showFolders = true\n    } label: {\n        Label(\"Show Folders\", systemImage: \"folder\")\n    }\n    .springLoadingBehavior(.enabled)\n\n\n    ...\n}\n.springLoadingBehavior(.disabled)\n\nSee Also\nConfiguring spring loading\nvar springLoadingBehavior: SpringLoadingBehavior\nThe behavior of spring loaded interactions for the views associated with this environment.\nstruct SpringLoadingBehavior\nThe options for controlling the spring loading behavior of views."
    },
    {
        "title": "SpringLoadingBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/springloadingbehavior",
        "html": "Overview\n\nUse values of this type with the springLoadingBehavior(_:) modifier.\n\nTopics\nGetting the behaviors\nstatic let automatic: SpringLoadingBehavior\nThe automatic spring loading behavior.\nstatic let enabled: SpringLoadingBehavior\nSpring loaded interactions will be enabled for applicable views.\nstatic let disabled: SpringLoadingBehavior\nSpring loaded interactions will be disabled for applicable views.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nConfiguring spring loading\nfunc springLoadingBehavior(SpringLoadingBehavior) -> some View\nSets the spring loading behavior this view.\nvar springLoadingBehavior: SpringLoadingBehavior\nThe behavior of spring loaded interactions for the views associated with this environment."
    },
    {
        "title": "isFocused",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/isfocused",
        "html": "Discussion\n\nIf there is no focusable ancestor, the value is false.\n\nSee Also\nManaging focus state\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nstruct FocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the placement of focus within the scene changes.\nstruct FocusedValue\nA property wrapper for observing values from the focused view or one of its ancestors.\nprotocol FocusedValueKey\nA protocol for identifier types used when publishing and observing focused values.\nstruct FocusedBinding\nA convenience property wrapper for observing and automatically unwrapping state bindings from the focused view or one of its ancestors."
    },
    {
        "title": "focusEffectDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focuseffectdisabled(_:)",
        "html": "Parameters\ndisabled\n\nA Boolean value that determines whether this view can display focus effects.\n\nReturn Value\n\nA view that controls whether focus effects can be displayed in this view.\n\nDiscussion\n\nThe higher views in a view hierarchy can override the value you set on this view. In the following example, the button does not display a focus effect because the outer focusEffectDisabled(_:) modifier overrides the inner one:\n\nHStack {\n    Button(\"Press\") {}\n        .focusEffectDisabled(false)\n}\n.focusEffectDisabled(true)\n\nSee Also\nConfiguring effects\nvar isFocusEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows focus effects to be displayed."
    },
    {
        "title": "ResetFocusAction",
        "url": "https://developer.apple.com/documentation/swiftui/resetfocusaction",
        "html": "Overview\n\nGet the resetFocus environment value and call it as a function to force a default focus reevaluation at runtime.\n\n@Namespace var mainNamespace\n@Environment(\\.resetFocus) var resetFocus\n\n\nvar body: some View {\n    // ...\n    resetFocus(in: mainNamespace)\n    // ...\n}\n\nTopics\nCalling the action\nfunc callAsFunction(in: Namespace.ID)\nAsks the focus sytem to reevaluate the default focus item.\nSee Also\nResetting focus\nvar resetFocus: ResetFocusAction\nAn action that requests the focus system to reevaluate default focus."
    },
    {
        "title": "FocusedValue",
        "url": "https://developer.apple.com/documentation/swiftui/focusedvalue",
        "html": "Overview\n\nIf multiple views publish values using the same key, the wrapped property will reflect the value from the view closest to focus.\n\nTopics\nCreating the value\ninit(Value.Type)\nA new property wrapper for the given object type.\ninit(KeyPath<FocusedValues, Value?>)\nA new property wrapper for the given key path.\nGetting the value\nvar wrappedValue: Value?\nThe value for the focus key given the current scope and state of the focused view hierarchy.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nManaging focus state\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nstruct FocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the placement of focus within the scene changes.\nprotocol FocusedValueKey\nA protocol for identifier types used when publishing and observing focused values.\nstruct FocusedBinding\nA convenience property wrapper for observing and automatically unwrapping state bindings from the focused view or one of its ancestors."
    },
    {
        "title": "FocusedBinding",
        "url": "https://developer.apple.com/documentation/swiftui/focusedbinding",
        "html": "Overview\n\nIf multiple views publish bindings using the same key, the wrapped property will reflect the value of the binding from the view closest to focus.\n\nTopics\nCreating the binding\ninit(KeyPath<FocusedValues, Binding<Value>?>)\nA new property wrapper for the given key path.\nGetting the value\nvar projectedValue: Binding<Value?>\nA binding to the optional value.\nvar wrappedValue: Value?\nThe unwrapped value for the focus key given the current scope and state of the focused view hierarchy.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nManaging focus state\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nstruct FocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the placement of focus within the scene changes.\nstruct FocusedValue\nA property wrapper for observing values from the focused view or one of its ancestors.\nprotocol FocusedValueKey\nA protocol for identifier types used when publishing and observing focused values."
    },
    {
        "title": "List",
        "url": "https://developer.apple.com/documentation/swiftui/list",
        "html": "Overview\n\nIn its simplest form, a List creates its contents statically, as shown in the following example:\n\nvar body: some View {\n    List {\n        Text(\"A List Item\")\n        Text(\"A Second List Item\")\n        Text(\"A Third List Item\")\n    }\n}\n\n\nMore commonly, you create lists dynamically from an underlying collection of data. The following example shows how to create a simple list from an array of an Ocean type which conforms to Identifiable:\n\nstruct Ocean: Identifiable {\n    let name: String\n    let id = UUID()\n}\n\n\nprivate var oceans = [\n    Ocean(name: \"Pacific\"),\n    Ocean(name: \"Atlantic\"),\n    Ocean(name: \"Indian\"),\n    Ocean(name: \"Southern\"),\n    Ocean(name: \"Arctic\")\n]\n\n\nvar body: some View {\n    List(oceans) {\n        Text($0.name)\n    }\n}\n\n\nSupporting selection in lists\n\nTo make members of a list selectable, provide a binding to a selection variable. Binding to a single instance of the list data\u2019s Identifiable.ID type creates a single-selection list. Binding to a Set creates a list that supports multiple selections. The following example shows how to add multiselect to the previous example:\n\nstruct Ocean: Identifiable, Hashable {\n    let name: String\n    let id = UUID()\n}\n\n\nprivate var oceans = [\n    Ocean(name: \"Pacific\"),\n    Ocean(name: \"Atlantic\"),\n    Ocean(name: \"Indian\"),\n    Ocean(name: \"Southern\"),\n    Ocean(name: \"Arctic\")\n]\n\n\n@State private var multiSelection = Set<UUID>()\n\n\nvar body: some View {\n    NavigationView {\n        List(oceans, selection: $multiSelection) {\n            Text($0.name)\n        }\n        .navigationTitle(\"Oceans\")\n        .toolbar { EditButton() }\n    }\n    Text(\"\\(multiSelection.count) selections\")\n}\n\n\nWhen people make a single selection by tapping or clicking, the selected cell changes its appearance to indicate the selection. To enable multiple selections with tap gestures, put the list into edit mode by either modifying the editMode value, or adding an EditButton to your app\u2019s interface. When you put the list into edit mode, the list shows a circle next to each list item. The circle contains a checkmark when the user selects the associated item. The example above uses an Edit button, which changes its title to Done while in edit mode:\n\nPeople can make multiple selections without needing to enter edit mode on devices that have a keyboard and mouse or trackpad, like Mac and iPad.\n\nRefreshing the list content\n\nTo make the content of the list refreshable using the standard refresh control, use the refreshable(action:) modifier.\n\nThe following example shows how to add a standard refresh control to a list. When the user drags the top of the list downward, SwiftUI reveals the refresh control and executes the specified action. Use an await expression inside the action closure to refresh your data. The refresh indicator remains visible for the duration of the awaited operation.\n\nstruct Ocean: Identifiable, Hashable {\n     let name: String\n     let id = UUID()\n     let stats: [String: String]\n }\n\n\n class OceanStore: ObservableObject {\n     @Published var oceans = [Ocean]()\n     func loadStats() async {}\n }\n\n\n @EnvironmentObject var store: OceanStore\n\n\n var body: some View {\n     NavigationView {\n         List(store.oceans) { ocean in\n             HStack {\n                 Text(ocean.name)\n                 StatsSummary(stats: ocean.stats) // A custom view for showing statistics.\n             }\n         }\n         .refreshable {\n             await store.loadStats()\n         }\n         .navigationTitle(\"Oceans\")\n     }\n }\n\nSupporting multidimensional lists\n\nTo create two-dimensional lists, group items inside Section instances. The following example creates sections named after the world\u2019s oceans, each of which has Text views named for major seas attached to those oceans. The example also allows for selection of a single list item, identified by the id of the example\u2019s Sea type.\n\nstruct ContentView: View {\n    struct Sea: Hashable, Identifiable {\n        let name: String\n        let id = UUID()\n    }\n\n\n    struct OceanRegion: Identifiable {\n        let name: String\n        let seas: [Sea]\n        let id = UUID()\n    }\n\n\n    private let oceanRegions: [OceanRegion] = [\n        OceanRegion(name: \"Pacific\",\n                    seas: [Sea(name: \"Australasian Mediterranean\"),\n                           Sea(name: \"Philippine\"),\n                           Sea(name: \"Coral\"),\n                           Sea(name: \"South China\")]),\n        OceanRegion(name: \"Atlantic\",\n                    seas: [Sea(name: \"American Mediterranean\"),\n                           Sea(name: \"Sargasso\"),\n                           Sea(name: \"Caribbean\")]),\n        OceanRegion(name: \"Indian\",\n                    seas: [Sea(name: \"Bay of Bengal\")]),\n        OceanRegion(name: \"Southern\",\n                    seas: [Sea(name: \"Weddell\")]),\n        OceanRegion(name: \"Arctic\",\n                    seas: [Sea(name: \"Greenland\")])\n    ]\n\n\n    @State private var singleSelection: UUID?\n\n\n    var body: some View {\n        NavigationView {\n            List(selection: $singleSelection) {\n                ForEach(oceanRegions) { region in\n                    Section(header: Text(\"Major \\(region.name) Ocean Seas\")) {\n                        ForEach(region.seas) { sea in\n                            Text(sea.name)\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"Oceans and Seas\")\n        }\n    }\n}\n\n\nBecause this example uses single selection, people can make selections outside of edit mode on all platforms.\n\nNote\n\nIn iOS 15, iPadOS 15, and tvOS 15 and earlier, lists support selection only in edit mode, even for single selections.\n\nCreating hierarchical lists\n\nYou can also create a hierarchical list of arbitrary depth by providing tree-structured data and a children parameter that provides a key path to get the child nodes at any level. The following example uses a deeply-nested collection of a custom FileItem type to simulate the contents of a file system. The list created from this data uses collapsing cells to allow the user to navigate the tree structure.\n\nstruct ContentView: View {\n    struct FileItem: Hashable, Identifiable, CustomStringConvertible {\n        var id: Self { self }\n        var name: String\n        var children: [FileItem]? = nil\n        var description: String {\n            switch children {\n            case nil:\n                return \"\ud83d\udcc4 \\(name)\"\n            case .some(let children):\n                return children.isEmpty ? \"\ud83d\udcc2 \\(name)\" : \"\ud83d\udcc1 \\(name)\"\n            }\n        }\n    }\n    let fileHierarchyData: [FileItem] = [\n      FileItem(name: \"users\", children:\n        [FileItem(name: \"user1234\", children:\n          [FileItem(name: \"Photos\", children:\n            [FileItem(name: \"photo001.jpg\"),\n             FileItem(name: \"photo002.jpg\")]),\n           FileItem(name: \"Movies\", children:\n             [FileItem(name: \"movie001.mp4\")]),\n              FileItem(name: \"Documents\", children: [])\n          ]),\n         FileItem(name: \"newuser\", children:\n           [FileItem(name: \"Documents\", children: [])\n           ])\n        ]),\n        FileItem(name: \"private\", children: nil)\n    ]\n    var body: some View {\n        List(fileHierarchyData, children: \\.children) { item in\n            Text(item.description)\n        }\n    }\n}\n\n\nStyling lists\n\nSwiftUI chooses a display style for a list based on the platform and the view type in which it appears. Use the listStyle(_:) modifier to apply a different ListStyle to all lists within a view. For example, adding .listStyle(.plain) to the example shown in the \u201cCreating Multidimensional Lists\u201d topic applies the plain style, the following screenshot shows:\n\nTopics\nCreating a list with arbitrary content\ninit(content: () -> Content)\nCreates a list with the given content.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit(selection: Binding<SelectionValue>, content: () -> Content)\nCreates a list with the given content that supports selecting a single row that cannot be deselcted.\ninit(selection: Binding<SelectionValue?>?, content: () -> Content)\nCreates a list with the given content that supports selecting a single row.\ninit(selection: Binding<Set<SelectionValue>>?, content: () -> Content)\nCreates a list with the given content that supports selecting multiple rows.\nCreating a list from a range\ninit<RowContent>(Range<Int>, rowContent: (Int) -> RowContent)\nCreates a list that computes its views on demand over a constant range.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<RowContent>(Range<Int>, selection: Binding<SelectionValue>, rowContent: (Int) -> RowContent)\nCreates a list that computes its views on demand over a constant range and allowing users to have exactly one row always selected.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<RowContent>(Range<Int>, selection: Binding<SelectionValue?>?, rowContent: (Int) -> RowContent)\nCreates a list that computes its views on demand over a constant range, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<RowContent>(Range<Int>, selection: Binding<Set<SelectionValue>>?, rowContent: (Int) -> RowContent)\nCreates a list that computes its views on demand over a constant range, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nListing data\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, rowContent: (Data.Element) -> RowContent)\nCreates a list that identifies its rows based on a key path to the identifier of the underlying data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, selection: Binding<SelectionValue>, rowContent: (Data.Element) -> RowContent)\nCreates a list that identifies its rows based on a key path to the identifier of the underlying data and allowing users to have exactly one row always selected.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, selection: Binding<SelectionValue?>?, rowContent: (Data.Element) -> RowContent)\nCreates a list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, selection: Binding<Set<SelectionValue>>?, rowContent: (Data.Element) -> RowContent)\nCreates a list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nListing identifiable data\ninit<Data, RowContent>(Data, rowContent: (Data.Element) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, RowContent>(Data, selection: Binding<SelectionValue>, rowContent: (Data.Element) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data and allowing users to have exactly one row always selected.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Data, selection: Binding<SelectionValue?>?, rowContent: (Data.Element) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Data, selection: Binding<Set<SelectionValue>>?, rowContent: (Data.Element) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nListing bound data\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that identifies its rows based on a key path to the identifier of the underlying data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, selection: Binding<SelectionValue?>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, selection: Binding<Set<SelectionValue>>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nListing bound, identifiable data\ninit<Data, RowContent>(Binding<Data>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, selection: Binding<SelectionValue?>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, selection: Binding<Set<SelectionValue>>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nListing hierarchical data\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<SelectionValue>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data and allowing users to have exactly one row always selected.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Data, children: KeyPath<Data.Element, Data?>, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from an underlying collection of identifiable data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, RowContent>(Data, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue>, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from an underlying collection of identifiable data and allowing users to have exactly one row always selected.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Data, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from an underlying collection of identifiable data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from an underlying collection of identifiable data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nListing bound, hierarchical data\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, children: WritableKeyPath<Data.Element, Data?>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, ID, RowContent>(Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue>, rowContent: (Data.Element) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data and allowing users to have exactly one row always selected.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that identifies its rows based on a key path to the identifier of the underlying data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, children: WritableKeyPath<Data.Element, Data?>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from a binding to an underlying collection of identifiable data.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<SelectionValue>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from a binding to an underlying collection of identifiable data and allowing users to have exactly one row always selected.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from a binding to an underlying collection of identifiable data, optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a hierarchical list that computes its rows on demand from a binding to an underlying collection of identifiable data, optionally allowing users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nListing editable data\ninit<Data, RowContent>(Binding<Data>, editActions: EditActions<Data>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data and allows to edit the collection.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, editActions: EditActions<Data>, selection: Binding<SelectionValue>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data, allows to edit the collection, and requires a selection of a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, editActions: EditActions<Data>, selection: Binding<SelectionValue?>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data, allows to edit the collection, and optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, RowContent>(Binding<Data>, editActions: EditActions<Data>, selection: Binding<Set<SelectionValue>>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable, allows to edit the collection, and optionally allows users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, editActions: EditActions<Data>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data and allows to edit the collection.\nAvailable when SelectionValue is Never and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, editActions: EditActions<Data>, selection: Binding<Set<SelectionValue>>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable, allows to edit the collection, and optionally allows users to select multiple rows.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, editActions: EditActions<Data>, selection: Binding<SelectionValue>, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable, allows to edit the collection, and requires a selection of a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\ninit<Data, ID, RowContent>(Binding<Data>, id: KeyPath<Data.Element, ID>, editActions: EditActions<Data>, selection: Binding<SelectionValue?>?, rowContent: (Binding<Data.Element>) -> RowContent)\nCreates a list that computes its rows on demand from an underlying collection of identifiable data, allows to edit the collection, and optionally allowing users to select a single row.\nAvailable when SelectionValue conforms to Hashable and Content conforms to View.\nSupporting types\nvar body: some View\nThe content of the list.\nRelationships\nConforms To\nView\nSee Also\nCreating a list\nDisplaying data in lists\nVisualize collections of data with platform-appropriate appearance.\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nstruct Section\nA container view that you can use to add hierarchy within certain views."
    },
    {
        "title": "focusedValue(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedvalue(_:)",
        "html": "Discussion\n\nImportant\n\nThis initializer only accepts objects conforming to the Observable protocol. For reading environment objects that conform to ObservableObject, use focusedObject(_:), instead.\n\nTo read this value, use the FocusedValue property wrapper.\n\nSee Also\nExposing value types to focused views\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused view hierarchy.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the active scene.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused scene.\nstruct FocusedValues\nA collection of state exported by the focused view and its ancestors."
    },
    {
        "title": "focusedValue(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedvalue(_:_:)-8079u",
        "html": "Parameters\nkeyPath\n\nThe key path to associate value with when adding it to the existing table of exported focus values.\n\nvalue\n\nThe focus value to export.\n\nReturn Value\n\nA modified representation of this view.\n\nSee Also\nExposing value types to focused views\nfunc focusedValue<T>(T?) -> some View\nSets the focused value for the given object type.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the active scene.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused scene.\nstruct FocusedValues\nA collection of state exported by the focused view and its ancestors."
    },
    {
        "title": "focusedValue(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedvalue(_:_:)-odf9",
        "html": "Parameters\nkeyPath\n\nThe key path to associate value with when adding it to the existing table of exported focus values.\n\nvalue\n\nThe focus value to export, or nil if no value is currently available.\n\nReturn Value\n\nA modified representation of this view.\n\nDiscussion\n\nUse this method instead of View/focusedSceneValue(_:_:) when your scene includes multiple focusable views with their own associated values, and you need an app- or scene-scoped element like a command or toolbar item that operates on the value associated with whichever view currently has focus. Each focusable view can supply its own value:\n\nSee Also\nExposing value types to focused views\nfunc focusedValue<T>(T?) -> some View\nSets the focused value for the given object type.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the active scene.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused scene.\nstruct FocusedValues\nA collection of state exported by the focused view and its ancestors."
    },
    {
        "title": "ProjectionTransform",
        "url": "https://developer.apple.com/documentation/swiftui/projectiontransform",
        "html": "Topics\nCreating a transform\ninit()\ninit(CGAffineTransform)\ninit(CATransform3D)\nGetting transform characteristics\nvar isAffine: Bool\nvar isIdentity: Bool\nManipulating transforms\nfunc invert() -> Bool\nfunc inverted() -> ProjectionTransform\nfunc concatenating(ProjectionTransform) -> ProjectionTransform\nAccessing the transform\u2019s coefficients\nvar m11: CGFloat\nvar m12: CGFloat\nvar m13: CGFloat\nvar m21: CGFloat\nvar m22: CGFloat\nvar m23: CGFloat\nvar m31: CGFloat\nvar m32: CGFloat\nvar m33: CGFloat\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "TableColumnBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/tablecolumnbuilder",
        "html": "Overview\n\nThe buildBlock methods in this type create TableColumnContent instances based on the number and types of sources provided as parameters.\n\nDon\u2019t use this type directly; instead, SwiftUI annotates the columns parameter of the various Table initializers with the @TableColumnBuilder annotation, implicitly calling this builder for you.\n\nTopics\nBuilding an unsortable column\nstatic func buildBlock<Column>(Column) -> Column\nCreates a single, unsortable column result.\nstatic func buildBlock<C0, C1>(C0, C1) -> TupleTableColumnContent<RowValue, Never, (C0, C1)>\nCreates an unsortable column result from two sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2)>\nCreates an unsortable column result from three sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3)>\nCreates an unsortable column result from four sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4)>\nCreates an unsortable column result from five sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5)>\nCreates an unsortable column result from six sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6)>\nCreates an unsortable column result from seven sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6, C7)>\nCreates an unsortable column result from eight sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6, C7, C8)>\nCreates an unsortable column result from nine sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)>\nCreates an unsortable column result from ten sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildExpression<Column>(Column) -> Column\nCreates a generic, unsortable single column expression.\nstatic func buildExpression<Content, Label>(TableColumn<RowValue, Never, Content, Label>) -> TableColumn<RowValue, Never, Content, Label>\nCreates a sortable table column expression whose value type matches that of the builder.\nBuilding a sortable column\nstatic func buildBlock<Column>(Column) -> Column\nCreates a single, sortable column result.\nstatic func buildBlock<C0, C1>(C0, C1) -> TupleTableColumnContent<RowValue, Sort, (C0, C1)>\nCreates a sortable column result from two sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2)>\nCreates a sortable column result from three sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3)>\nCreates a sortable column result from four sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4)>\nCreates a sortable column result from five sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5)>\nCreates a sortable column result from six sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6)>\nCreates a sortable column result from seven sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6, C7)>\nCreates a sortable column result from eight sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6, C7, C8)>\nCreates a sortable column result from nine sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)>\nCreates a sortable column result from ten sources.\nAvailable when RowValue conforms to Identifiable and Sort conforms to SortComparator.\nstatic func buildExpression<Column>(Column) -> Column\nCreates a generic, sortable single column expression.\nstatic func buildExpression<Content, Label>(TableColumn<RowValue, Sort, Content, Label>) -> TableColumn<RowValue, Sort, Content, Label>\nCreates a sortable table column expression whose value and sort types match those of the builder.\nSupporting types\nstruct TupleTableColumnContent\nA type of table column content that creates table columns created from a Swift tuple of table columns.\nSee Also\nCreating columns\nstruct TableColumn\nA column that displays a view for each row in a table.\nprotocol TableColumnContent\nA type used to represent columns within a table.\nstruct TableColumnAlignment\nDescribes the alignment of the content of a table column."
    },
    {
        "title": "ContentMode",
        "url": "https://developer.apple.com/documentation/swiftui/contentmode",
        "html": "Topics\nGetting content modes\ncase fill\nAn option that resizes the content so it occupies all available space, both vertically and horizontally.\ncase fit\nAn option that resizes the content so it\u2019s all within the available space, both vertically and horizontally.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform"
    },
    {
        "title": "transform3DEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transform3deffect(_:)",
        "html": "Parameters\ntransform\n\nThe 3D transformation to apply to the view, interpreting it as a 3D plane in space.\n\nReturn Value\n\nA view that renders transformed according to the provided transform\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "clipped(antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/clipped(antialiased:)",
        "html": "Parameters\nantialiased\n\nA Boolean value that indicates whether the rendering system applies smoothing to the edges of the clipping rectangle.\n\nReturn Value\n\nA view that clips this view to its bounding frame.\n\nDiscussion\n\nUse the clipped(antialiased:) modifier to hide any content that extends beyond the layout bounds of the shape.\n\nBy default, a view\u2019s bounding frame is used only for layout, so any content that extends beyond the edges of the frame is still visible.\n\nText(\"This long text string is clipped\")\n    .fixedSize()\n    .frame(width: 175, height: 100)\n    .clipped()\n    .border(Color.gray)\n\n\nSee Also\nMasking and clipping\nfunc mask<Mask>(alignment: Alignment, () -> Mask) -> some View\nMasks this view using the alpha channel of the given view.\nfunc clipShape<S>(S, style: FillStyle) -> some View\nSets a clipping shape for this view."
    },
    {
        "title": "projectionEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/projectioneffect(_:)",
        "html": "Parameters\ntransform\n\nA ProjectionTransform to apply to the view.\n\nDiscussion\n\nUse projectionEffect(_:) to apply a 3D transformation to the view.\n\nThe example below rotates the text 30\u02da around the z axis, which is the axis pointing out of the screen:\n\n// This transform represents a 30\u02da rotation around the z axis.\nlet transform = CATransform3DMakeRotation(\n    -30 * (.pi / 180), 0.0, 0.0, 1.0)\n\n\nText(\"Projection effects using transforms\")\n    .projectionEffect(.init(transform))\n    .border(Color.gray)\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "transformEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transformeffect(_:)",
        "html": "Parameters\ntransform\n\nA CGAffineTransform to apply to the view.\n\nDiscussion\n\nUse transformEffect(_:) to rotate, scale, translate, or skew the output of the view according to the provided CGAffineTransform.\n\nIn the example below, the text is rotated at -30\u02da on the y axis.\n\nlet transform = CGAffineTransform(rotationAngle: -30 * (.pi / 180))\n\n\nText(\"Projection effect using transforms\")\n    .transformEffect(transform)\n    .border(Color.gray)\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "rotation3DEffect(_:axis:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/rotation3deffect(_:axis:anchor:)-8vi88",
        "html": "Parameters\nangle\n\nThe angle by which to rotate the view\u2019s content.\n\naxis\n\nThe axis of rotation.\n\nanchor\n\nThe unit point within the view about which to perform the rotation. The default value is center.\n\nReturn Value\n\nA view with rotated content.\n\nDiscussion\n\nThis modifier rotates the view\u2019s content without changing the view\u2019s frame. The following code displays a 3D model with a rotation of 45\u00b0 about the y-axis using the default anchor point at the center of the view:\n\nModel3D(named: \"robot\")\n    .rotation3DEffect(.degrees(45), axis: .y)\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "visualEffect3D(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/visualeffect3d(_:)",
        "html": "Parameters\neffect\n\nA closure that returns the effect to be applied. The first argument provided to the closure is a placeholder representing this view. The second argument is a GeometryProxy3D.\n\nReturn Value\n\nA view with the effect applied.\n\nDiscussion\n\nYou return new effects by calling functions on the first argument provided to the effect closure. In this example, ContentView is offset in Z by its own depth, causing its back face to appear where the front face of the view was originally located:\n\nContentView()\n    .visualEffect3D { content, geometryProxy in\n        content.offset(z: geometryProxy.size.depth)\n    }\n\nSee Also\nApplying effects based on geometry\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a geometry proxy.\nprotocol VisualEffect\nVisual Effects change the visual appearance of a view without changing its ancestors or descendents.\nstruct EmptyVisualEffect\nThe base visual effect that you apply additional effect to."
    },
    {
        "title": "TableRowBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/tablerowbuilder",
        "html": "Overview\n\nThe buildBlock methods in this type create TableRowContent instances based on the number and types of sources provided as parameters.\n\nDon\u2019t use this type directly; instead, SwiftUI annotates the rows parameter of the various Table initializers with the @TableRowBuilder annotation, implicitly calling this builder for you.\n\nTopics\nBuilding a row from sources\nstatic func buildBlock<C>(C) -> C\nCreates a single row result.\nstatic func buildBlock<C0, C1>(C0, C1) -> TupleTableRowContent<Value, (C0, C1)>\nCreates a row result from two sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> TupleTableRowContent<Value, (C0, C1, C2)>\nCreates a row result from three sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> TupleTableRowContent<Value, (C0, C1, C2, C3)>\nCreates a row result from four sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4)>\nCreates a row result from five sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5)>\nCreates a row result from six sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6)>\nCreates a row result from seven sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6, C7)>\nCreates a row result from eight sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6, C7, C8)>\nCreates a row result from nine sources.\nAvailable when Value conforms to Identifiable.\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)>\nCreates a row result from ten sources.\nAvailable when Value conforms to Identifiable.\nBuilding a row from conditionals\nstatic func buildIf<C>(C?) -> C?\nCreates a row result for conditional statements.\nAvailable when Value conforms to Identifiable.\nstatic func buildEither<T, F>(first: T) -> _ConditionalContent<T, F>\nCreates a row result for the first of two row content alternatives.\nAvailable when Value conforms to Identifiable.\nstatic func buildEither<T, F>(second: F) -> _ConditionalContent<T, F>\nCreates a row result for the second of two row content alternatives.\nAvailable when Value conforms to Identifiable.\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nSee Also\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nprotocol TableRowContent\nA type used to represent table rows.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data."
    },
    {
        "title": "TableRowContent",
        "url": "https://developer.apple.com/documentation/swiftui/tablerowcontent",
        "html": "Overview\n\nLike with the View protocol, you can create custom table row content by declaring a type that conforms to the TableRowContent protocol and implementing the required tableRowBody property.\n\nstruct GroupOfPeopleRows: TableRowContent {\n    @Binding var people: [Person]\n\n\n    var tableRowBody: some TableRowContent<Person> {\n        ForEach(people) { person in\n            TableRow(person)\n                .itemProvider { person.itemProvider }\n        }\n        .dropDestination(for: Person.self) { destination, newPeople in\n            people.insert(contentsOf: newPeople, at: destination)\n        }\n    }\n}\n\n\nThis example uses an opaque result type and specifies that the primary associated type TableRowValue for the tableRowBody property is a Person. From this, SwiftUI can infer TableRowValue for the GroupOfPeopleRows structure is also Person.\n\nTopics\nGetting the row body\nvar tableRowBody: Self.TableRowBody\nThe composition of content that comprise the table row content.\n\nRequired\n\nassociatedtype TableRowBody : TableRowContent\nThe type of content representing the body of this table row content.\n\nRequired\n\nDefining the row value\nassociatedtype TableRowValue : Identifiable = Self.TableRowBody.TableRowValue\nThe type of value represented by this table row content.\n\nRequired\n\nManaging interaction\nfunc draggable<T>(() -> T) -> some TableRowContent<Self.TableRowValue>\nActivates this row as the source of a drag and drop operation.\nfunc dropDestination<T>(for: T.Type, action: ([T]) -> Void) -> some TableRowContent<Self.TableRowValue>\nDefines the entire row as a destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onHover(perform: (Bool) -> Void) -> some TableRowContent<Self.TableRowValue>\nAdds an action to perform when the pointer moves onto or away from the entire row.\nfunc itemProvider((() -> NSItemProvider?)?) -> ModifiedContent<Self, ItemProviderTableRowModifier>\nProvides a closure that vends the drag representation for a particular data element.\nstruct ItemProviderTableRowModifier\nA table row modifier that associates an item provider with some base row content.\nAdding a context menu to a row\nfunc contextMenu<M>(menuItems: () -> M) -> ModifiedContent<Self, _ContextMenuTableRowModifier<M>>\nAdds a context menu to a table row.\nfunc contextMenu<M, P>(menuItems: () -> M, preview: () -> P) -> ModifiedContent<Self, _ContextMenuPreviewTableRowModifier<M, P>>\nAdds a context menu with a preview to a table row.\nInstance Methods\nfunc selectionDisabled(Bool) -> some TableRowContent<Self.TableRowValue>\nAdds a condition that controls whether users can select this row.\nRelationships\nInherited By\nDynamicTableRowContent\nConforming Types\nDisclosureTableRow\nEmptyTableRowContent\nConforms when Value conforms to Identifiable.\nForEach\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\nGroup\nConforms when Content conforms to TableRowContent.\nModifiedContent\nConforms when Content conforms to TableRowContent and Modifier conforms to _TableRowContentModifier.\nOutlineGroup\nConforms when Data conforms to RandomAccessCollection, ID is Data.Element.ID, Parent conforms to TableRowContent, Parent is Leaf, Leaf is Subgroup, and Data.Element is Parent.TableRowValue.\nSection\nConforms when Parent conforms to TableRowContent, Content conforms to TableRowContent, and Footer conforms to TableRowContent.\nTableForEachContent\nTableHeaderRowContent\nTableOutlineGroupContent\nTableRow\nTupleTableRowContent\nSee Also\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nAvailable when Value conforms to Identifiable.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data.\nstruct TableRowBuilder\nA result builder that creates table row content from closures."
    },
    {
        "title": "frame(depth:alignment:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/frame(depth:alignment:)",
        "html": "Parameters\ndepth\n\nA fixed depth for the resulting view. If depth is nil, the resulting view assumes this view\u2019s sizing behavior.\n\nalignment\n\nThe alignment of this view inside the resulting view. alignment applies if this view is smaller than the size given by the resulting frame.\n\nReturn Value\n\nA view with a fixed dimension of depth if non-nil.\n\nDiscussion\n\nUse this method to specify a fixed size for a view\u2019s depth. If you don\u2019t specify a dimension, the resulting view assumes this view\u2019s sizing behavior in depth.\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "DynamicTableRowContent",
        "url": "https://developer.apple.com/documentation/swiftui/dynamictablerowcontent",
        "html": "Overview\n\nThis table row content type provides drag-and-drop support for tables. Use the onInsert(of:perform:) modifier to add an action to call when the table inserts new contents into its underlying collection.\n\nTopics\nGetting row data\nvar data: Self.Data\nThe collection of underlying data.\n\nRequired\n\nassociatedtype Data : Collection\nThe type of the underlying collection of data.\n\nRequired\n\nInserting rows\nfunc onInsert(of: [UTType], perform: (Int, [NSItemProvider]) -> Void) -> ModifiedContent<Self, OnInsertTableRowModifier>\nSets the insert action for the dynamic table rows.\nstruct OnInsertTableRowModifier\nA table row modifier that adds the ability to insert data in some base row content.\nSupporting drag and drop\nfunc dropDestination<T>(for: T.Type, action: (Int, [T]) -> Void) -> ModifiedContent<Self, OnInsertTableRowModifier>\nSets the insert action for the dynamic table rows.\nRelationships\nInherits From\nTableRowContent\nConforming Types\nForEach\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to TableRowContent.\nModifiedContent\nConforms when Content conforms to DynamicTableRowContent and Modifier conforms to _TableRowContentModifier.\nSee Also\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nprotocol TableRowContent\nA type used to represent table rows.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nstruct TableRowBuilder\nA result builder that creates table row content from closures."
    },
    {
        "title": "TableHeaderRowContent",
        "url": "https://developer.apple.com/documentation/swiftui/tableheaderrowcontent",
        "html": "Overview\n\nYou do not create this type directly. The framework creates it on your behalf.\n\nRelationships\nConforms To\nTableRowContent\nSee Also\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nprotocol TableRowContent\nA type used to represent table rows.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data.\nstruct TableRowBuilder\nA result builder that creates table row content from closures."
    },
    {
        "title": "frame(width:height:alignment:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/frame(width:height:alignment:)",
        "html": "Parameters\nwidth\n\nA fixed width for the resulting view. If width is nil, the resulting view assumes this view\u2019s sizing behavior.\n\nheight\n\nA fixed height for the resulting view. If height is nil, the resulting view assumes this view\u2019s sizing behavior.\n\nalignment\n\nThe alignment of this view inside the resulting frame. Note that most alignment values have no apparent effect when the size of the frame happens to match that of this view.\n\nReturn Value\n\nA view with fixed dimensions of width and height, for the parameters that are non-nil.\n\nDiscussion\n\nUse this method to specify a fixed size for a view\u2019s width, height, or both. If you only specify one of the dimensions, the resulting view assumes this view\u2019s sizing behavior in the other dimension.\n\nFor example, the following code lays out an ellipse in a fixed 200 by 100 frame. Because a shape always occupies the space offered to it by the layout system, the first ellipse is 200x100 points. The second ellipse is laid out in a frame with only a fixed height, so it occupies that height, and whatever width the layout system offers to its parent.\n\nVStack {\n    Ellipse()\n        .fill(Color.purple)\n        .frame(width: 200, height: 100)\n    Ellipse()\n        .fill(Color.blue)\n        .frame(height: 100)\n}\n\n\nThe alignment parameter specifies this view\u2019s alignment within the frame.\n\nText(\"Hello world!\")\n    .frame(width: 200, height: 30, alignment: .topLeading)\n    .border(Color.gray)\n\n\nIn the example above, the text is positioned at the top, leading corner of the frame. If the text is taller than the frame, its bounds may extend beyond the bottom of the frame\u2019s bounds.\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "EdgeInsets",
        "url": "https://developer.apple.com/documentation/swiftui/edgeinsets",
        "html": "Topics\nGetting edge insets\nvar top: CGFloat\nvar bottom: CGFloat\nvar leading: CGFloat\nvar trailing: CGFloat\nCreating an edge inset\ninit()\ninit(top: CGFloat, leading: CGFloat, bottom: CGFloat, trailing: CGFloat)\ninit(EdgeInsets3D)\nCreates a 2D EdgeInsets from an EdgeInsets3D, dropping its front and back values.\nBeta\ninit(NSDirectionalEdgeInsets)\nCreate edge insets from the equivalent NSDirectionalEdgeInsets.\nRelationships\nConforms To\nAnimatable\nEquatable\nSendable\nSee Also\nAccessing edges and regions\nenum Edge\nAn enumeration to indicate one edge of a rectangle.\nenum Edge3D\nAn edge or face of a 3D volume.\nBeta\nenum HorizontalEdge\nAn edge on the horizontal axis.\nenum VerticalEdge\nAn edge on the vertical axis.\nstruct EdgeInsets3D\nThe inset distances for the faces of a 3D volume.\nBeta"
    },
    {
        "title": "TableColumnContent",
        "url": "https://developer.apple.com/documentation/swiftui/tablecolumncontent",
        "html": "Overview\n\nThis type provides the body content of the column, as well as the types of the column\u2019s row values and the comparator used to sort rows.\n\nYou can factor column content out into separate types or properties, or by creating a custom type conforming to TableColumnContent.\n\nvar body: some View {\n    Table(people, selection: $selectedPeople, sortOrder: $sortOrder) {\n        nameColumns\n\n\n        TableColumn(\"Location\", value: \\.location) {\n            LocationView($0.location)\n        }\n    }\n}\n\n\n@TableColumnBuilder<Person, KeyPathComparator<Person>>\nprivate var nameColumns: some TableColumnContent<\n    Person, KeyPathComparator<Person>\n> {\n    TableColumn(\"First Name\", value: \\.firstName) {\n        PrimaryColumnView(person: $0)\n    }\n    TableColumn(\"Last Name\", value: \\.lastName)\n    TableColumn(\"Nickname\", value: \\.nickname)\n}\n\n\nThe above example factors three table columns into a separate computed property that has an opaque type. The property\u2019s primary associated type TableRowValue is a Person and its associated type TableColumnSortComparator is a key comparator for the Person type.\n\nTopics\nGetting the column body\nvar tableColumnBody: Self.TableColumnBody\nThe composition of content that comprise the table column content.\n\nRequired\n\nassociatedtype TableColumnBody : TableColumnContent\nThe type of content representing the body of this table column content.\n\nRequired\n\nDefining the row value\nassociatedtype TableRowValue : Identifiable = Self.TableColumnBody.TableRowValue\nThe type of value of rows presented by this column content.\n\nRequired\n\nDefining the comparator\nassociatedtype TableColumnSortComparator : SortComparator = Self.TableColumnBody.TableColumnSortComparator\nThe type of sort comparator associated with this table column content.\n\nRequired\n\nConfiguring the content\nfunc alignment(TableColumnAlignment) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>\nSets the alignment of the column, applying to both its column header label and the row view content for that column.\nfunc customizationID(String) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>\nSets the identifier to be associated with a column when persisting its state with TableColumnCustomization.\nfunc defaultVisibility(Visibility) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>\nSets the default visibility of a table column.\nfunc disabledCustomizationBehavior(TableColumnCustomizationBehavior) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>\nSets the disabled customization behavior for a table column.\nRelationships\nConforming Types\nGroup\nConforms when Content conforms to TableColumnContent.\nTableColumn\nTupleTableColumnContent\nSee Also\nCreating columns\nstruct TableColumn\nA column that displays a view for each row in a table.\nstruct TableColumnAlignment\nDescribes the alignment of the content of a table column.\nstruct TableColumnBuilder\nA result builder that creates table column content from closures."
    },
    {
        "title": "ScenePadding",
        "url": "https://developer.apple.com/documentation/swiftui/scenepadding",
        "html": "Overview\n\nAdd scene padding to a view using the scenePadding(_:edges:) modifier.\n\nTopics\nGetting padding values\nstatic let minimum: ScenePadding\nThe minimum scene padding value.\nstatic let navigationBar: ScenePadding\nThe navigation bar content scene padding.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene."
    },
    {
        "title": "VerticalEdge",
        "url": "https://developer.apple.com/documentation/swiftui/verticaledge",
        "html": "Topics\nGetting the edges\ncase top\nThe top edge.\ncase bottom\nThe bottom edge.\nAccessing sets of edges\nstruct Set\nAn efficient set of vertical edges.\nRelationships\nConforms To\nCaseIterable\nDecodable\nEncodable\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nAccessing edges and regions\nenum Edge\nAn enumeration to indicate one edge of a rectangle.\nenum Edge3D\nAn edge or face of a 3D volume.\nBeta\nenum HorizontalEdge\nAn edge on the horizontal axis.\nstruct EdgeInsets\nThe inset distances for the sides of a rectangle.\nstruct EdgeInsets3D\nThe inset distances for the faces of a 3D volume.\nBeta"
    },
    {
        "title": "TableForEachContent",
        "url": "https://developer.apple.com/documentation/swiftui/tableforeachcontent",
        "html": "Overview\n\nYou don\u2019t use this type directly. The various Table.init(_:,...) initializers create this type as the table\u2019s Rows generic type.\n\nTo explicitly create dynamic collection-based rows, use ForEach instead.\n\nRelationships\nConforms To\nTableRowContent\nSee Also\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nprotocol TableRowContent\nA type used to represent table rows.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data.\nstruct TableRowBuilder\nA result builder that creates table row content from closures."
    },
    {
        "title": "Form",
        "url": "https://developer.apple.com/documentation/swiftui/form",
        "html": "Overview\n\nSwiftUI applies platform-appropriate styling to views contained inside a form, to group them together. Form-specific styling applies to things like buttons, toggles, labels, lists, and more. Keep in mind that these stylings may be platform-specific. For example, forms apppear as grouped lists on iOS, and as aligned vertical stacks on macOS.\n\nThe following example shows a simple data entry form on iOS, grouped into two sections. The supporting types (NotifyMeAboutType and ProfileImageSize) and state variables (notifyMeAbout, profileImageSize, playNotificationSounds, and sendReadReceipts) are omitted for simplicity.\n\nvar body: some View {\n    NavigationView {\n        Form {\n            Section(header: Text(\"Notifications\")) {\n                Picker(\"Notify Me About\", selection: $notifyMeAbout) {\n                    Text(\"Direct Messages\").tag(NotifyMeAboutType.directMessages)\n                    Text(\"Mentions\").tag(NotifyMeAboutType.mentions)\n                    Text(\"Anything\").tag(NotifyMeAboutType.anything)\n                }\n                Toggle(\"Play notification sounds\", isOn: $playNotificationSounds)\n                Toggle(\"Send read receipts\", isOn: $sendReadReceipts)\n            }\n            Section(header: Text(\"User Profiles\")) {\n                Picker(\"Profile Image Size\", selection: $profileImageSize) {\n                    Text(\"Large\").tag(ProfileImageSize.large)\n                    Text(\"Medium\").tag(ProfileImageSize.medium)\n                    Text(\"Small\").tag(ProfileImageSize.small)\n                }\n                Button(\"Clear Image Cache\") {}\n            }\n        }\n    }\n}\n\n\nOn macOS, a similar form renders as a vertical stack. To adhere to macOS platform conventions, this version doesn\u2019t use sections, and uses colons at the end of its labels. It also sets the picker to use the inline style, which produces radio buttons on macOS.\n\nvar body: some View {\n    Spacer()\n    HStack {\n        Spacer()\n        Form {\n            Picker(\"Notify Me About:\", selection: $notifyMeAbout) {\n                Text(\"Direct Messages\").tag(NotifyMeAboutType.directMessages)\n                Text(\"Mentions\").tag(NotifyMeAboutType.mentions)\n                Text(\"Anything\").tag(NotifyMeAboutType.anything)\n            }\n            Toggle(\"Play notification sounds\", isOn: $playNotificationSounds)\n            Toggle(\"Send read receipts\", isOn: $sendReadReceipts)\n\n\n            Picker(\"Profile Image Size:\", selection: $profileImageSize) {\n                Text(\"Large\").tag(ProfileImageSize.large)\n                Text(\"Medium\").tag(ProfileImageSize.medium)\n                Text(\"Small\").tag(ProfileImageSize.small)\n            }\n            .pickerStyle(.inline)\n\n\n            Button(\"Clear Image Cache\") {}\n        }\n        Spacer()\n    }\n    Spacer()\n}\n\n\nTopics\nCreating a form\ninit(content: () -> Content)\nCreates a form with the provided content.\nCreating a form from a configuration\ninit(FormStyleConfiguration)\nCreates a form based on a form style configuration.\nAvailable when Content is FormStyleConfiguration.Content.\nRelationships\nConforms To\nView\nSee Also\nGrouping inputs\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nstruct LabeledContent\nA container for attaching a label to a value-bearing view.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content."
    },
    {
        "title": "offset(z:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/offset(z:)",
        "html": "Parameters\ndistance\n\nThe distance to extrude the view forward in Z, in points.\n\nReturn Value\n\nA view that is extruded forward in Z by distance.\n\nSee Also\nAdjusting a view\u2019s position\nMaking fine adjustments to a view\u2019s position\nShift the position of a view by applying the offset or position modifier.\nfunc position(CGPoint) -> some View\nPositions the center of this view at the specified point in its parent\u2019s coordinate space.\nfunc position(x: CGFloat, y: CGFloat) -> some View\nPositions the center of this view at the specified coordinates in its parent\u2019s coordinate space.\nfunc offset(CGSize) -> some View\nOffset this view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(x: CGFloat, y: CGFloat) -> some View\nOffset this view by the specified horizontal and vertical distances."
    },
    {
        "title": "Building a Great Mac App with SwiftUI",
        "url": "https://developer.apple.com/documentation/swiftui/building_a_great_mac_app_with_swiftui",
        "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC21 sessions: 10062: SwiftUI on the Mac: Build the Fundamentals and 10289: SwiftUI on the Mac: The Finishing Touches."
    },
    {
        "title": "fixedSize()",
        "url": "https://developer.apple.com/documentation/swiftui/view/fixedsize()",
        "html": "Return Value\n\nA view that fixes this view at its ideal size.\n\nDiscussion\n\nDuring the layout of the view hierarchy, each view proposes a size to each child view it contains. If the child view doesn\u2019t need a fixed size it can accept and conform to the size offered by the parent.\n\nFor example, a Text view placed in an explicitly sized frame wraps and truncates its string to remain within its parent\u2019s bounds:\n\nText(\"A single line of text, too long to fit in a box.\")\n    .frame(width: 200, height: 200)\n    .border(Color.gray)\n\n\nThe fixedSize() modifier can be used to create a view that maintains the ideal size of its children both dimensions:\n\nText(\"A single line of text, too long to fit in a box.\")\n    .fixedSize()\n    .frame(width: 200, height: 200)\n    .border(Color.gray)\n\n\nThis can result in the view exceeding the parent\u2019s bounds, which may or may not be the effect you want.\n\nYou can think of fixedSize() as the creation of a counter proposal to the view size proposed to a view by its parent. The ideal size of a view, and the specific effects of fixedSize() depends on the particular view and how you have configured it.\n\nTo create a view that fixes the view\u2019s size in either the horizontal or vertical dimensions, see fixedSize(horizontal:vertical:).\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "Making fine adjustments to a view\u2019s position",
        "url": "https://developer.apple.com/documentation/swiftui/making-fine-adjustments-to-a-view-s-position",
        "html": "Overview\n\nUse SwiftUI to adaptively lay out and position your views. If you can\u2019t achieve your design with composition alone, fine tune the layout with view modifiers. Add an offset modifier to shift the rendered content of a view from its current position, or a position modifier to set an explicit position within its parent.\n\nCreate a view layout\n\nThe following example provides a view to illustrate how to position views, providing a rough layout of views composed within a ZStack. The stack contains a quadrant with an overlaid circle image:\n\nstruct Crosshairs: View { ... } // Draws crosshairs.\n\n\nstruct Quadrant: View {\n    var body: some View {\n        ZStack {\n            Crosshairs()\n            Rectangle()\n                .stroke(Color.primary)\n            Image(systemName: \"circle\")\n        }\n        .frame(width: 160, height: 160)\n    }\n}\n\n\nFor more detail on composing views with stacks, see Building layouts with stack views.\n\nShift the location of a view\u2019s content\n\nFine-tune the position of the circle within the quadrant by using an offset modifier to shift where the parent view places the circle. An offset modifier shifts the image from its default center position. For example, the offset(x:y:) modifier uses the parameters of x and y to represent a relative location within the view\u2019s coordinate space.\n\nIn SwiftUI, the view\u2019s coordinate space uses x to represent a horizontal direction and y to represent a vertical direction. The value of x starts at 0 at the leading edge of a view, and increases as the location moves toward the trailing edge of a view. The value of y starts at 0 at the top edge of a view, and increases as the location moves toward the bottom edge of a view. Don\u2019t assume the leading edge is always on the left, because it changes with the layout direction. When the layout direction is set to right-to-left, the 0 horizontal value is on the right side of the view.\n\nThe following diagram shows the coordinates in the left-to-right layout direction against a rectangle, with the origin at the top, leading corner:\n\nThe following example shifts the circle 40 points from the center, up and toward the trailing edge:\n\nstruct Quadrant: View {\n    var body: some View {\n        ZStack {\n            Crosshairs()\n            Rectangle()\n                .stroke(Color.primary)\n            Image(systemName: \"circle\")\n                .offset(x: 40.0, y: -40.0)\n        }\n        .frame(width: 160, height: 160)\n    }\n}\n\n\nPosition view content explicitly\n\nTo explicitly position elements within a view, use the position(x:y:) view modifier. A position modifier overrides where the parent view places its content. The modifier renders the view at a location offset from the origin of the parent view, unlike an offset modifier that shifts the view from the location chosen by the parent view. The position modifier uses the same x, y coordinate system as the offset modifier, and similarly doesn\u2019t influence the size of the view. In this example, the position of the circle is set halfway down on the right side of the quadrant with explicit values:\n\nstruct Quadrant: View {\n    var body: some View {\n        ZStack {\n            Crosshairs()\n            Rectangle()\n                .stroke(Color.primary)\n            Image(systemName: \"circle\")\n                .position(x: 144, y: 80)\n        }\n        .frame(width: 160, height: 160)\n    }\n}\n\n\nSee Also\nAdjusting a view\u2019s position\nfunc position(CGPoint) -> some View\nPositions the center of this view at the specified point in its parent\u2019s coordinate space.\nfunc position(x: CGFloat, y: CGFloat) -> some View\nPositions the center of this view at the specified coordinates in its parent\u2019s coordinate space.\nfunc offset(CGSize) -> some View\nOffset this view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(x: CGFloat, y: CGFloat) -> some View\nOffset this view by the specified horizontal and vertical distances.\nfunc offset(z: CGFloat) -> some View\nBrings a view forward in Z by the provided distance in points.\nBeta"
    },
    {
        "title": "offset(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/offset(_:)",
        "html": "Parameters\noffset\n\nThe distance to offset this view.\n\nReturn Value\n\nA view that offsets this view by offset.\n\nDiscussion\n\nUse offset(_:) to shift the displayed contents by the amount specified in the offset parameter.\n\nThe original dimensions of the view aren\u2019t changed by offsetting the contents; in the example below the gray border drawn by this view surrounds the original position of the text:\n\nText(\"Offset by passing CGSize()\")\n    .border(Color.green)\n    .offset(CGSize(width: 20, height: 25))\n    .border(Color.gray)\n\n\nSee Also\nAdjusting a view\u2019s position\nMaking fine adjustments to a view\u2019s position\nShift the position of a view by applying the offset or position modifier.\nfunc position(CGPoint) -> some View\nPositions the center of this view at the specified point in its parent\u2019s coordinate space.\nfunc position(x: CGFloat, y: CGFloat) -> some View\nPositions the center of this view at the specified coordinates in its parent\u2019s coordinate space.\nfunc offset(x: CGFloat, y: CGFloat) -> some View\nOffset this view by the specified horizontal and vertical distances.\nfunc offset(z: CGFloat) -> some View\nBrings a view forward in Z by the provided distance in points.\nBeta"
    },
    {
        "title": "position(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/position(_:)",
        "html": "Parameters\nposition\n\nThe point at which to place the center of this view.\n\nReturn Value\n\nA view that fixes the center of this view at position.\n\nDiscussion\n\nUse the position(_:) modifier to place the center of a view at a specific coordinate in the parent view using a CGPoint to specify the x and y offset.\n\nText(\"Position by passing a CGPoint()\")\n    .position(CGPoint(x: 175, y: 100))\n    .border(Color.gray)\n\nSee Also\nAdjusting a view\u2019s position\nMaking fine adjustments to a view\u2019s position\nShift the position of a view by applying the offset or position modifier.\nfunc position(x: CGFloat, y: CGFloat) -> some View\nPositions the center of this view at the specified coordinates in its parent\u2019s coordinate space.\nfunc offset(CGSize) -> some View\nOffset this view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(x: CGFloat, y: CGFloat) -> some View\nOffset this view by the specified horizontal and vertical distances.\nfunc offset(z: CGFloat) -> some View\nBrings a view forward in Z by the provided distance in points.\nBeta"
    },
    {
        "title": "Alignment",
        "url": "https://developer.apple.com/documentation/swiftui/alignment",
        "html": "Overview\n\nAn Alignment contains a HorizontalAlignment guide and a VerticalAlignment guide. Specify an alignment to direct the behavior of certain layout containers and modifiers, like when you place views in a ZStack, or layer a view in front of or behind another view using overlay(alignment:content:) or background(alignment:content:), respectively. During layout, SwiftUI brings the specified guides of the affected views together, aligning the views.\n\nSwiftUI provides a set of built-in alignments that represent common combinations of the built-in horizontal and vertical alignment guides. The blue boxes in the following diagram demonstrate the alignment named by each box\u2019s label, relative to the background view:\n\nThe following code generates the diagram above, where each blue box appears in an overlay that\u2019s configured with a different alignment:\n\nstruct AlignmentGallery: View {\n    var body: some View {\n        BackgroundView()\n            .overlay(alignment: .topLeading) { box(\".topLeading\") }\n            .overlay(alignment: .top) { box(\".top\") }\n            .overlay(alignment: .topTrailing) { box(\".topTrailing\") }\n            .overlay(alignment: .leading) { box(\".leading\") }\n            .overlay(alignment: .center) { box(\".center\") }\n            .overlay(alignment: .trailing) { box(\".trailing\") }\n            .overlay(alignment: .bottomLeading) { box(\".bottomLeading\") }\n            .overlay(alignment: .bottom) { box(\".bottom\") }\n            .overlay(alignment: .bottomTrailing) { box(\".bottomTrailing\") }\n            .overlay(alignment: .leadingLastTextBaseline) { box(\".leadingLastTextBaseline\") }\n            .overlay(alignment: .trailingFirstTextBaseline) { box(\".trailingFirstTextBaseline\") }\n    }\n\n\n    private func box(_ name: String) -> some View {\n        Text(name)\n            .font(.system(.caption, design: .monospaced))\n            .padding(2)\n            .foregroundColor(.white)\n            .background(.blue.opacity(0.8), in: Rectangle())\n    }\n}\n\n\nprivate struct BackgroundView: View {\n    var body: some View {\n        Grid(horizontalSpacing: 0, verticalSpacing: 0) {\n            GridRow {\n                Text(\"Some text in an upper quadrant\")\n                Color.gray.opacity(0.3)\n            }\n            GridRow {\n                Color.gray.opacity(0.3)\n                Text(\"More text in a lower quadrant\")\n            }\n        }\n        .aspectRatio(1, contentMode: .fit)\n        .foregroundColor(.secondary)\n        .border(.gray)\n    }\n}\n\n\nTo avoid crowding, the alignment diagram shows only two of the available text baseline alignments. The others align as their names imply. Notice that the first text baseline alignment aligns with the top-most line of text in the background view, while the last text baseline aligns with the bottom-most line. For more information about text baseline alignment, see VerticalAlignment.\n\nIn a left-to-right language like English, the leading and trailing alignments appear on the left and right edges, respectively. SwiftUI reverses these in right-to-left language environments. For more information, see HorizontalAlignment.\n\nCustom alignment\n\nYou can create custom alignments \u2014 which you typically do to make use of custom horizontal or vertical guides \u2014 by using the init(horizontal:vertical:) initializer. For example, you can combine a custom vertical guide called firstThird with the built-in horizontal center guide, and use it to configure a ZStack:\n\nZStack(alignment: Alignment(horizontal: .center, vertical: .firstThird)) {\n    // ...\n}\n\n\nFor more information about creating custom guides, including the code that creates the custom firstThird alignment in the example above, see AlignmentID.\n\nTopics\nGetting top guides\nstatic let topLeading: Alignment\nA guide that marks the top and leading edges of the view.\nstatic let top: Alignment\nA guide that marks the top edge of the view.\nstatic let topTrailing: Alignment\nA guide that marks the top and trailing edges of the view.\nGetting middle guides\nstatic let leading: Alignment\nA guide that marks the leading edge of the view.\nstatic let center: Alignment\nA guide that marks the center of the view.\nstatic let trailing: Alignment\nA guide that marks the trailing edge of the view.\nGetting bottom guides\nstatic let bottomLeading: Alignment\nA guide that marks the bottom and leading edges of the view.\nstatic let bottom: Alignment\nA guide that marks the bottom edge of the view.\nstatic let bottomTrailing: Alignment\nA guide that marks the bottom and trailing edges of the view.\nGetting text baseline guides\nstatic var leadingFirstTextBaseline: Alignment\nA guide that marks the leading edge and top-most text baseline in a view.\nstatic var centerFirstTextBaseline: Alignment\nA guide that marks the top-most text baseline in a view.\nstatic var trailingFirstTextBaseline: Alignment\nA guide that marks the trailing edge and top-most text baseline in a view.\nstatic var leadingLastTextBaseline: Alignment\nA guide that marks the leading edge and bottom-most text baseline in a view.\nstatic var centerLastTextBaseline: Alignment\nA guide that marks the bottom-most text baseline in a view.\nstatic var trailingLastTextBaseline: Alignment\nA guide that marks the trailing edge and bottom-most text baseline in a view.\nCreating a custom alignment\ninit(horizontal: HorizontalAlignment, vertical: VerticalAlignment)\nCreates a custom alignment value with the specified horizontal and vertical alignment guides.\nvar horizontal: HorizontalAlignment\nThe alignment on the horizontal axis.\nvar vertical: VerticalAlignment\nThe alignment on the vertical axis.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "Button",
        "url": "https://developer.apple.com/documentation/swiftui/button",
        "html": "Overview\n\nYou create a button by providing an action and a label. The action is either a method or closure property that does something when a user clicks or taps the button. The label is a view that describes the button\u2019s action \u2014 for example, by showing text, an icon, or both.\n\nThe label of a button can be any kind of view, such as a Text view for text-only labels:\n\nButton(action: signIn) {\n    Text(\"Sign In\")\n}\n\n\nOr a Label view, for buttons with both a title and an icon:\n\nButton(action: signIn) {\n    Label(\"Sign In\", systemImage: \"arrow.up\")\n}\n\n\nFor those common cases, you can also use the convenience initializers that take a title string or LocalizedStringKey as their first parameter, and optionally a system image name or ImageResource as their second parameter, instead of a trailing closure:\n\nButton(\"Sign In\", systemImage: \"arrow.up\", action: signIn)\n\n\nPrefer to use these convenience initializers, or a Label view, when providing both a title and an icon. This allows the button to dynamically adapt its appearance to render its title and icon correctly in containers such as toolbars and menus. For example, on iOS, buttons only display their icons by default when placed in toolbars, but show both a leading title and trailing icon in menus. Defining labels this way also helps with accessibility \u2014 for example, applying the labelStyle(_:) modifier with an iconOnly style to the button will cause it to only visually display its icon, but still use its title to describe the button in accessibility modes like VoiceOver:\n\nButton(\"Sign In\", systemImage: \"arrow.up\", action: signIn)\n    .labelStyle(.iconOnly)\n\n\nAvoid labels that only use images or exclusively visual components without an accessibility label.\n\nHow the user activates the button varies by platform:\n\nIn iOS and watchOS, the user taps the button.\n\nIn macOS, the user clicks the button.\n\nIn tvOS, the user presses \u201cselect\u201d on an external remote, like the Siri Remote, while focusing on the button.\n\nThe appearance of the button depends on factors like where you place it, whether you assign it a role, and how you style it.\n\nAdding buttons to containers\n\nUse buttons for any user interface element that initiates an action. Buttons automatically adapt their visual style to match the expected style within these different containers and contexts. For example, to create a List cell that initiates an action when selected by the user, add a button to the list\u2019s content:\n\nList {\n    // Cells that show all the current folders.\n    ForEach(folders) { folder in\n        Text(folder.title)\n    }\n\n\n    // A cell that, when selected, adds a new folder.\n    Button(action: addItem) {\n        Label(\"Add Folder\", systemImage: \"folder.badge.plus\")\n    }\n}\n\n\nSimilarly, to create a context menu item that initiates an action, add a button to the contextMenu(_:) modifier\u2019s content closure:\n\n.contextMenu {\n    Button(\"Cut\", action: cut)\n    Button(\"Copy\", action: copy)\n    Button(\"Paste\", action: paste)\n}\n\n\nThis pattern extends to most other container views in SwiftUI that have customizable, interactive content, like Form instances.\n\nAssigning a role\n\nYou can optionally initialize a button with a ButtonRole that characterizes the button\u2019s purpose. For example, you can create a destructive button for a deletion action:\n\n Button(\"Delete\", role: .destructive, action: delete)\n\n\nThe system uses the button\u2019s role to style the button appropriately in every context. For example, a destructive button in a contextual menu appears with a red foreground color:\n\nIf you don\u2019t specify a role for a button, the system applies an appropriate default appearance.\n\nStyling buttons\n\nYou can customize a button\u2019s appearance using one of the standard button styles, like bordered, and apply the style with the buttonStyle(_:) modifier:\n\nHStack {\n    Button(\"Sign In\", action: signIn)\n    Button(\"Register\", action: register)\n}\n.buttonStyle(.bordered)\n\n\nIf you apply the style to a container view, as in the example above, all the buttons in the container use the style:\n\nYou can also create custom styles. To add a custom appearance with standard interaction behavior, create a style that conforms to the ButtonStyle protocol. To customize both appearance and interaction behavior, create a style that conforms to the PrimitiveButtonStyle protocol. Custom styles can also read the button\u2019s role and use it to adjust the button\u2019s appearance.\n\nTopics\nCreating a button\ninit(action: () -> Void, label: () -> Label)\nCreates a button that displays a custom label.\ninit(LocalizedStringKey, action: () -> Void)\nCreates a button that generates its label from a localized string key.\nAvailable when Label is Text.\ninit<S>(S, action: () -> Void)\nCreates a button that generates its label from a string.\nAvailable when Label is Text.\nCreating a button with a role\ninit(role: ButtonRole?, action: () -> Void, label: () -> Label)\nCreates a button with a specified role that displays a custom label.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, role: ButtonRole?, action: () -> Void)\nCreates a button with a specified role that generates its label from a localized string key.\nAvailable when Label is Text.\ninit<S>(S, role: ButtonRole?, action: () -> Void)\nCreates a button with a specified role that generates its label from a string.\nAvailable when Label is Text.\nCreating a button with an image resource\ninit(LocalizedStringKey, image: ImageResource, action: () -> Void)\nCreates a button that generates its label from a localized string key and image resource.\nAvailable when Label is Label<Text, Image>.\ninit<S>(S, image: ImageResource, action: () -> Void)\nCreates a button that generates its label from a string and image resource.\nAvailable when Label is Label<Text, Image>.\ninit(LocalizedStringKey, image: ImageResource, role: ButtonRole?, action: () -> Void)\nCreates a button with a specified role that generates its label from a localized string key and an image resource.\nAvailable when Label is Label<Text, Image>.\ninit<S>(S, image: ImageResource, role: ButtonRole?, action: () -> Void)\nCreates a button with a specified role that generates its label from a string and an image resource.\nAvailable when Label is Label<Text, Image>.\nCreating a button with a system image\ninit<S>(S, systemImage: String, action: () -> Void)\nCreates a button that generates its label from a string and system image name.\nAvailable when Label is Label<Text, Image>.\ninit(LocalizedStringKey, systemImage: String, action: () -> Void)\nCreates a button that generates its label from a localized string key and system image name.\nAvailable when Label is Label<Text, Image>.\ninit<S>(S, systemImage: String, role: ButtonRole?, action: () -> Void)\nCreates a button with a specified role that generates its label from a string and a system image and an image resource.\nAvailable when Label is Label<Text, Image>.\ninit(LocalizedStringKey, systemImage: String, role: ButtonRole?, action: () -> Void)\nCreates a button with a specified role that generates its label from a localized string key and a system image.\nAvailable when Label is Label<Text, Image>.\nCreating a button from a configuration\ninit(PrimitiveButtonStyleConfiguration)\nCreates a button based on a configuration for a style with a custom appearance and custom interaction behavior.\nAvailable when Label is PrimitiveButtonStyleConfiguration.Label.\nCreating a button to perform an App Intent\ninit<I>(intent: I, label: () -> Label)\nCreates a button that performs an AppIntent.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, intent: some AppIntent)\nCreates a button that performs an AppIntent and generates its label from a localized string key.\nAvailable when Label is Text.\ninit<S>(S, intent: some AppIntent)\nCreates a button that performs an AppIntent and generates its label from a string.\nAvailable when Label is Text.\ninit(LocalizedStringKey, image: ImageResource, role: ButtonRole?, intent: some AppIntent)\nCreates a button with a specified role that performs an AppIntent and generates its label from a localized string key and an image resource.\nAvailable when Label is Label<Text, Image>.\ninit(some StringProtocol, image: ImageResource, role: ButtonRole?, intent: some AppIntent)\nCreates a button with a specified role that generates its label from a string and an image resource.\nAvailable when Label is Label<Text, Image>.\ninit(LocalizedStringKey, role: ButtonRole?, intent: some AppIntent)\nCreates a button with a specified role that performs an AppIntent and generates its label from a localized string key.\nAvailable when Label is Text.\ninit(some StringProtocol, role: ButtonRole?, intent: some AppIntent)\nCreates a button with a specified role that performs an AppIntent and generates its label from a string.\nAvailable when Label is Text.\ninit(LocalizedStringKey, systemImage: String, role: ButtonRole?, intent: some AppIntent)\nCreates a button with a specified role that performs an AppIntent and generates its label from a localized string key and a system image.\nAvailable when Label is Label<Text, Image>.\ninit(some StringProtocol, systemImage: String, role: ButtonRole?, intent: some AppIntent)\nCreates a button with a specified role that generates its label from a string and a system image.\nAvailable when Label is Label<Text, Image>.\ninit(role: ButtonRole?, intent: some AppIntent, label: () -> Label)\nCreates a button with a specified role that performs an AppIntent.\nAvailable when Label conforms to View.\nRelationships\nConforms To\nView\nSee Also\nCreating buttons\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "GestureStateGesture",
        "url": "https://developer.apple.com/documentation/swiftui/gesturestategesture",
        "html": "Overview\n\nA gesture\u2019s updating(_:body:) callback returns a GestureStateGesture instance for updating a transient state property that\u2019s annotated with the GestureState property wrapper.\n\nTopics\nCreating an in-progress gesture\ninit(base: Base, state: GestureState<State>, body: (GestureStateGesture<Base, State>.Value, inout State, inout Transaction) -> Void)\nCreates a new gesture that\u2019s the result of an ongoing gesture.\nvar base: Base\nThe originating gesture.\nvar state: GestureState<State>\nA value that changes as the user performs the gesture.\nSupporting types\nvar body: (GestureStateGesture<Base, State>.Value, inout State, inout Transaction) -> Void\nThe updating gesture containing the originating gesture\u2019s value, the updated state of the gesture, and a transaction.\nRelationships\nConforms To\nGesture\nSee Also\nManaging gesture state\nstruct GestureState\nA property wrapper type that updates a property while the user performs a gesture and resets the property back to its initial state when the gesture ends."
    },
    {
        "title": "RotationGesture",
        "url": "https://developer.apple.com/documentation/swiftui/rotationgesture",
        "html": "Deprecated\n\nUse RotateGesture instead.\n\nTopics\nCreating the gesture\ninit(minimumAngleDelta: Angle)\nCreates a rotation gesture with a minimum delta for the gesture to start.\nvar minimumAngleDelta: Angle\nThe minimum delta required before the gesture succeeds.\nRelationships\nConforms To\nGesture\nSee Also\nDeprecated gestures\nstruct MagnificationGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nDeprecated"
    },
    {
        "title": "alignmentGuide(_:computeValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alignmentguide(_:computevalue:)-6y3u2",
        "html": "Parameters\ng\n\nA VerticalAlignment value at which to base the offset.\n\ncomputeValue\n\nA closure that returns the offset value to apply to this view.\n\nReturn Value\n\nA view modified with respect to its vertical alignment according to the computation performed in the method\u2019s closure.\n\nDiscussion\n\nUse alignmentGuide(_:computeValue:) to calculate specific offsets to reposition views in relationship to one another. You can return a constant or can use the ViewDimensions argument to the closure to calculate a return value.\n\nIn the example below, the weather emoji are offset 20 points from the vertical center of the HStack.\n\nVStack {\n    Text(\"Today's Weather\")\n        .font(.title)\n        .border(.gray)\n\n\n    HStack {\n        Text(\"\ud83c\udf27\")\n            .alignmentGuide(VerticalAlignment.center) { _ in -20 }\n            .border(.gray)\n        Text(\"Rain & Thunderstorms\")\n            .border(.gray)\n        Text(\"\u26c8\")\n            .alignmentGuide(VerticalAlignment.center) { _ in 20 }\n            .border(.gray)\n    }\n}\n\n\nChanging the alignment of one view may have effects on surrounding views. Here the offset values inside a stack and its contained views is the difference of their absolute offsets.\n\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "GestureState",
        "url": "https://developer.apple.com/documentation/swiftui/gesturestate",
        "html": "Overview\n\nDeclare a property as @GestureState, pass as a binding to it as a parameter to a gesture\u2019s updating(_:body:) callback, and receive updates to it. A property that\u2019s declared as @GestureState implicitly resets when the gesture becomes inactive, making it suitable for tracking transient state.\n\nAdd a long-press gesture to a Circle, and update the interface during the gesture by declaring a property as @GestureState:\n\nstruct SimpleLongPressGestureView: View {\n    @GestureState private var isDetectingLongPress = false\n\n\n    var longPress: some Gesture {\n        LongPressGesture(minimumDuration: 3)\n            .updating($isDetectingLongPress) { currentState, gestureState, transaction in\n                gestureState = currentState\n            }\n    }\n\n\n    var body: some View {\n        Circle()\n            .fill(self.isDetectingLongPress ? Color.red : Color.green)\n            .frame(width: 100, height: 100, alignment: .center)\n            .gesture(longPress)\n    }\n}\n\nTopics\nCreating a gesture state\ninit(initialValue: Value)\nCreates a view state that\u2019s derived from a gesture with an initial value.\ninit(initialValue: Value, reset: (Value, inout Transaction) -> Void)\nCreates a view state that\u2019s derived from a gesture with an initial state value and a closure that provides a transaction to reset it.\ninit(initialValue: Value, resetTransaction: Transaction)\nCreates a view state that\u2019s derived from a gesture with an initial state value and a transaction to reset it.\ninit(reset: (Value, inout Transaction) -> Void)\nCreates a view state that\u2019s derived from a gesture with a closure that provides a transaction to reset it.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(resetTransaction: Transaction)\nCreates a view state that\u2019s derived from a gesture with a transaction to reset it.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(wrappedValue: Value)\nCreates a view state that\u2019s derived from a gesture.\ninit(wrappedValue: Value, reset: (Value, inout Transaction) -> Void)\nCreates a view state that\u2019s derived from a gesture with a wrapped state value and a closure that provides a transaction to reset it.\ninit(wrappedValue: Value, resetTransaction: Transaction)\nCreates a view state that\u2019s derived from a gesture with a wrapped state value and a transaction to reset it.\nGetting the state\nvar wrappedValue: Value\nThe wrapped value referenced by the gesture state property.\nvar projectedValue: GestureState<Value>\nA binding to the gesture state property.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nManaging gesture state\nstruct GestureStateGesture\nA gesture that updates the state provided by a gesture\u2019s updating callback."
    },
    {
        "title": "FocusedObject",
        "url": "https://developer.apple.com/documentation/swiftui/focusedobject",
        "html": "Overview\n\nFocused objects invalidate the current view whenever the observable object changes. If multiple views publish a focused object using the same key, the wrapped property will reflect the object that\u2019s closest to the focused view.\n\nTopics\nCreating the focused object\ninit()\nCreates a focused object.\nGetting the value\nvar projectedValue: FocusedObject<ObjectType>.Wrapper?\nA projection of the focused object that creates bindings to its properties using dynamic member lookup.\nvar wrappedValue: ObjectType?\nThe underlying value referenced by the focused object.\nstruct Wrapper\nA wrapper around the underlying focused object that can create bindings to its properties using dynamic member lookup.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nExposing reference types to focused views\nfunc focusedObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose state depends on the focused view hierarchy.\nfunc focusedObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the focused view hierarchy.\nfunc focusedSceneObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nfunc focusedSceneObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene."
    },
    {
        "title": "focusedObject(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedobject(_:)-26zv7",
        "html": "Parameters\nobject\n\nThe observable object to associate with focus, or nil if no object is currently available.\n\nReturn Value\n\nA view that supplies an observable object when in focus.\n\nDiscussion\n\nUse this method instead of View/focusedSceneObject(_:) when your scene includes multiple focusable views with their own associated data, and you need an app- or scene-scoped element like a command or toolbar item that operates on the data associated with whichever view currently has focus. Each focusable view can supply its own object:\n\nstruct MessageView: View {\n    @StateObject private var message = Message(...)\n\n\n    var body: some View {\n        TextField(...)\n            .focusedObject(message)\n    }\n}\n\n\nInterested views can then use the FocusedObject property wrapper to observe and update the focused view\u2019s object. In this example, an app command updates the focused view\u2019s data, and is automatically disabled when focus is in an unrelated part of the scene:\n\nstruct MessageCommands: Commands {\n    @FocusedObject private var message: Message?\n\n\n    var body: some Commands {\n        CommandGroup(after: .pasteboard) {\n            Button(\"Add Duck to Message\") {\n                message?.text.append(\" \ud83e\udd86\")\n            }\n            .keyboardShortcut(\"d\")\n            .disabled(message == nil)\n        }\n    }\n}\n\nSee Also\nExposing reference types to focused views\nfunc focusedObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the focused view hierarchy.\nfunc focusedSceneObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nfunc focusedSceneObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nstruct FocusedObject\nA property wrapper type for an observable object supplied by the focused view or one of its ancestors."
    },
    {
        "title": "offset(x:y:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/offset(x:y:)",
        "html": "Parameters\nx\n\nThe horizontal distance to offset this view.\n\ny\n\nThe vertical distance to offset this view.\n\nReturn Value\n\nA view that offsets this view by x and y.\n\nDiscussion\n\nUse offset(x:y:) to shift the displayed contents by the amount specified in the x and y parameters.\n\nThe original dimensions of the view aren\u2019t changed by offsetting the contents; in the example below the gray border drawn by this view surrounds the original position of the text:\n\nText(\"Offset by passing horizontal & vertical distance\")\n    .border(Color.green)\n    .offset(x: 20, y: 50)\n    .border(Color.gray)\n\n\nSee Also\nAdjusting a view\u2019s position\nMaking fine adjustments to a view\u2019s position\nShift the position of a view by applying the offset or position modifier.\nfunc position(CGPoint) -> some View\nPositions the center of this view at the specified point in its parent\u2019s coordinate space.\nfunc position(x: CGFloat, y: CGFloat) -> some View\nPositions the center of this view at the specified coordinates in its parent\u2019s coordinate space.\nfunc offset(CGSize) -> some View\nOffset this view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(z: CGFloat) -> some View\nBrings a view forward in Z by the provided distance in points.\nBeta"
    },
    {
        "title": "focusedSceneObject(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedsceneobject(_:)-8ovym",
        "html": "Parameters\nobject\n\nThe observable object to associate with the scene, or nil if no object is currently available.\n\nReturn Value\n\nA view that supplies an observable object while the scene is active.\n\nDiscussion\n\nUse this method instead of View/focusedObject(_:) for observable objects that must be visible regardless of where focus is located in the active scene. This is sometimes needed for things like main menu and discoverability HUD commands that observe and update data from the active scene but aren\u2019t concerned with what the user is actually focused on. The scene\u2019s root view can supply the scene\u2019s state object:\n\nstruct RootView: View {\n    @StateObject private var sceneData = SceneData()\n\n\n    var body: some View {\n        NavigationSplitView {\n            ...\n        }\n        .focusedSceneObject(sceneData)\n    }\n}\n\n\nInterested views can then use the FocusedObject property wrapper to observe and update the active scene\u2019s state object. In this example, an app command updates the active scene\u2019s data, and is enabled as long as any scene is active.\n\nstruct MessageCommands: Commands {\n    @FocusedObject private var sceneData: SceneData?\n\n\n    var body: some Commands {\n        CommandGroup(after: .newItem) {\n            Button(\"New Message\") {\n                sceneData?.addMessage()\n            }\n            .keyboardShortcut(\"n\", modifiers: [.option, .command])\n            .disabled(sceneData == nil)\n        }\n    }\n}\n\nSee Also\nExposing reference types to focused views\nfunc focusedObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose state depends on the focused view hierarchy.\nfunc focusedObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the focused view hierarchy.\nfunc focusedSceneObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nstruct FocusedObject\nA property wrapper type for an observable object supplied by the focused view or one of its ancestors."
    },
    {
        "title": "focusSection()",
        "url": "https://developer.apple.com/documentation/swiftui/view/focussection()",
        "html": "Return Value\n\nA view that can guide focus to its focusable descendents.\n\nDiscussion\n\nUse focus sections to customize SwiftUI\u2019s behavior when the user moves focus between views.\n\nThe following tvOS example places three buttons (\u201c1\u201d, \u201c2\u201d, and \u201c3\u201d) at the upper left of the screen and three buttons (\u201cA\u201d, \u201cB\u201d, and \u201cC\u201d) at the bottom right. By default, swiping right on the Siri Remote on any of the buttons in the \u201c1\u201d - \u201c3\u201d group would do nothing, since the focus system finds no focusable views directly to their right. But by declaring the VStack that encloses buttons \u201cA\u201d - \u201cC\u201d as a focus section, the VStack can receive focus, and deliver that focus to its first focusable child (button \u201cA\u201d). The example puts a border on the VStack to illustrate this spatial arrangement.\n\nvar body: some View {\n    HStack {\n        VStack {\n            Button (\"1\") {}\n            Button (\"2\") {}\n            Button (\"3\") {}\n            Spacer()\n        }\n        .border(Color.white, width: 2)\n\n\n        Spacer()\n        VStack {\n            Spacer()\n            Button (\"A\") {}\n            Button (\"B\") {}\n            Button (\"C\") {}\n        }\n        .border(Color.white, width: 2)\n        .focusSection()\n    }\n}\n\n\nNote that because the VStack containing buttons \u201c1\u201d - \u201c3\u201d does not declare itself as a focus section, it is impossible to direct focus back to the left from buttons \u201cA\u201d - \u201cC\u201d. None of those buttons has a focusable view \u2014 in this case either a button or a VStack with the focusSection() modifier \u2014 directly to its left.\n\nApplying this modifier to a view affects focus behavior based on the style of movement:\n\nDirectional movement: Navigating with Siri Remote gestures, arrow keys on a keyboard, or any other type of input that works in terms of cardinal directions (up, down, left, right) produces directional movement. When modified with focusSection(), the view\u2019s frame becomes capable of accepting focus in order to direct it at its nearest focusable descendant in the direction of travel. In the earlier example, declaring the right-side VStack as a focus section allowed it to receive right-directed focus from the buttons on the left.\n\nSequential movement: Navigating with a Digital Crown, the Tab key on a keyboard, or any other type of input that works in terms of the next or previous item in a sequence, produces sequential movement. When you use the focusSection() modifier, SwiftUI deviates from its default layout-based sequence to visit each of the modified view\u2019s focusable descendants before resuming the default sequence. Within the set of focusable descendants, SwiftUI continues to visit views in layout order (leading-to-trailing, top-to-bottom).\n\nfocusSection() does not affect the focusability of the modified view. If the modified view has no focusable descendants, then the modifier does nothing.\n\nSee Also\nSetting focus scope\nfunc focusScope(Namespace.ID) -> some View\nCreates a focus scope that SwiftUI uses to limit default focus preferences."
    },
    {
        "title": "simultaneously(with:)",
        "url": "https://developer.apple.com/documentation/swiftui/gesture/simultaneously(with:)",
        "html": "Parameters\nother\n\nA gesture that you want to combine with your gesture to create a new, combined gesture.\n\nReturn Value\n\nA gesture with two simultaneous gestures.\n\nSee Also\nComposing gestures\nfunc sequenced<Other>(before: Other) -> SequenceGesture<Self, Other>\nSequences a gesture with another one to create a new gesture, which results in the second gesture only receiving events after the first gesture succeeds.\nfunc exclusively<Other>(before: Other) -> ExclusiveGesture<Self, Other>\nCombines two gestures exclusively to create a new gesture where only one gesture succeeds, giving precedence to the first gesture."
    },
    {
        "title": "sequenced(before:)",
        "url": "https://developer.apple.com/documentation/swiftui/gesture/sequenced(before:)",
        "html": "Parameters\nother\n\nA gesture you want to combine with another gesture to create a new, sequenced gesture.\n\nReturn Value\n\nA gesture that\u2019s a sequence of two gestures.\n\nSee Also\nComposing gestures\nfunc simultaneously<Other>(with: Other) -> SimultaneousGesture<Self, Other>\nCombines a gesture with another gesture to create a new gesture that recognizes both gestures at the same time.\nfunc exclusively<Other>(before: Other) -> ExclusiveGesture<Self, Other>\nCombines two gestures exclusively to create a new gesture where only one gesture succeeds, giving precedence to the first gesture."
    },
    {
        "title": "focusedSceneObject(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedsceneobject(_:)-8td7y",
        "html": "Parameters\nobject\n\nThe observable object to associate with the scene.\n\nReturn Value\n\nA view that supplies an observable object while the scene is active.\n\nDiscussion\n\nUse this method instead of View/focusedObject(_:) for observable objects that must be visible regardless of where focus is located in the active scene. This is sometimes needed for things like main menu and discoverability HUD commands that observe and update data from the active scene but aren\u2019t concerned with what the user is actually focused on. The scene\u2019s root view can supply the scene\u2019s state object:\n\nstruct RootView: View {\n    @StateObject private var sceneData = SceneData()\n\n\n    var body: some View {\n        NavigationSplitView {\n            ...\n        }\n        .focusedSceneObject(sceneData)\n    }\n}\n\n\nInterested views can then use the FocusedObject property wrapper to observe and update the active scene\u2019s state object. In this example, an app command updates the active scene\u2019s data, and is enabled as long as any scene is active.\n\nstruct MessageCommands: Commands {\n    @FocusedObject private var sceneData: SceneData?\n\n\n    var body: some Commands {\n        CommandGroup(after: .newItem) {\n            Button(\"New Message\") {\n                sceneData?.addMessage()\n            }\n            .keyboardShortcut(\"n\", modifiers: [.option, .command])\n            .disabled(sceneData == nil)\n        }\n    }\n}\n\nSee Also\nExposing reference types to focused views\nfunc focusedObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose state depends on the focused view hierarchy.\nfunc focusedObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the focused view hierarchy.\nfunc focusedSceneObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nstruct FocusedObject\nA property wrapper type for an observable object supplied by the focused view or one of its ancestors."
    },
    {
        "title": "focusedObject(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusedobject(_:)-4rq6n",
        "html": "Parameters\nobject\n\nThe observable object to associate with focus.\n\nReturn Value\n\nA view that supplies an observable object when in focus.\n\nDiscussion\n\nUse this method instead of View/focusedSceneObject(_:) when your scene includes multiple focusable views with their own associated data, and you need an app- or scene-scoped element like a command or toolbar item that operates on the data associated with whichever view currently has focus. Each focusable view can supply its own object:\n\nstruct MessageView: View {\n    @StateObject private var message = Message(...)\n\n\n    var body: some View {\n        TextField(...)\n            .focusedObject(message)\n    }\n}\n\n\nInterested views can then use the FocusedObject property wrapper to observe and update the focused view\u2019s object. In this example, an app command updates the focused view\u2019s data, and is automatically disabled when focus is in an unrelated part of the scene:\n\nstruct MessageCommands: Commands {\n    @FocusedObject private var message: Message?\n\n\n    var body: some Commands {\n        CommandGroup(after: .pasteboard) {\n            Button(\"Add Duck to Message\") {\n                message?.text.append(\" \ud83e\udd86\")\n            }\n            .keyboardShortcut(\"d\")\n            .disabled(message == nil)\n        }\n    }\n}\n\nSee Also\nExposing reference types to focused views\nfunc focusedObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nfunc focusedSceneObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nstruct FocusedObject\nA property wrapper type for an observable object supplied by the focused view or one of its ancestors."
    },
    {
        "title": "defaultFocus(_:_:priority:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/defaultfocus(_:_:priority:)",
        "html": "Parameters\nbinding\n\nA focus state binding to update when evaluating default focus in the modified view hierarchy.\n\nvalue\n\nThe value to set the binding to during evaluation.\n\npriority\n\nAn indication of how to prioritize the preferred default focus target when focus moves into the modified view hierarchy. The default value is automatic, which means the preference will be given priority when focus is being initialized or relocated programmatically, but not when responding to user-directed navigation commands.\n\nReturn Value\n\nThe modified view.\n\nDiscussion\n\nBy default, SwiftUI evaluates default focus when the window first appears, and when a focus state binding update moves focus automatically, but not when responding to user-driven navigation commands.\n\nClients can override the default behavior by specifying an evaluation priority of userInitiated, which causes SwiftUI to use the client\u2019s preferred default focus in response to user-driven focus navigation as well as automatic changes.\n\nIn the following example, focus automatically goes to the second of the two text fields when the view is first presented in the window.\n\nWindowGroup {\n    VStack {\n        TextField(...)\n            .focused($focusedField, equals: .firstField)\n        TextField(...)\n            .focused($focusedField, equals: .secondField)\n    }\n    .defaultFocus($focusedField, .secondField)\n}\n\nSee Also\nControlling default focus\nfunc prefersDefaultFocus(Bool, in: Namespace.ID) -> some View\nIndicates that the view should receive focus by default for a given namespace.\nstruct DefaultFocusEvaluationPriority\nPrioritizations for default focus preferences when evaluating where to move focus in different circumstances."
    },
    {
        "title": "modifiers(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/gesture/modifiers(_:)",
        "html": "Parameters\nmodifiers\n\nA set of flags that correspond to the modifier keys that the user needs to hold down.\n\nReturn Value\n\nA new gesture that combines a gesture with keyboard modifiers.\n\nDiscussion\n\nThe gesture receives updates while the user presses the modifier keys that correspond to the given modifiers option set."
    },
    {
        "title": "DefaultFocusEvaluationPriority",
        "url": "https://developer.apple.com/documentation/swiftui/defaultfocusevaluationpriority",
        "html": "Topics\nGetting the priorities\nstatic let automatic: DefaultFocusEvaluationPriority\nUse the default focus preference when focus moves into the affected branch automatically, but ignore it when the movement is driven by a user-initiated navigation command.\nstatic let userInitiated: DefaultFocusEvaluationPriority\nAlways use the default focus preference when focus moves into the affected branch.\nRelationships\nConforms To\nSendable\nSee Also\nControlling default focus\nfunc prefersDefaultFocus(Bool, in: Namespace.ID) -> some View\nIndicates that the view should receive focus by default for a given namespace.\nfunc defaultFocus<V>(FocusState<V>.Binding, V, priority: DefaultFocusEvaluationPriority) -> some View\nDefines a region of the window in which default focus is evaluated by assigning a value to a given focus state binding."
    },
    {
        "title": "prefersDefaultFocus(_:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/prefersdefaultfocus(_:in:)",
        "html": "Parameters\nprefersDefaultFocus\n\nA Boolean value that indicates whether this view prefers to receive focus by default. The default value, true, causes the view to receive focus by default.\n\nnamespace\n\nThe namespace associated with the focus scope within which this view prefers default focus.\n\nReturn Value\n\nA modified view that sets whether it prefers to be focused by default.\n\nDiscussion\n\nThis modifier sets the initial focus preference when no other view has focus. Use the environment value resetFocus to force a reevaluation of default focus at any time.\n\nThe following tvOS example shows three buttons, labeled \u201c1\u201d, \u201c2\u201d, and \u201c3\u201d, in a VStack. By default, the \u201c1\u201d button would receive focus, because it is the first child in the stack. However, the prefersDefaultFocus(_:in:) modifier allows button \u201c3\u201d to receive default focus instead. Once the buttons are visible, the user can move down to and focus the \u201cReset to default focus\u201d button. When the user activates this button, it uses the ResetFocusAction to reevaluate default focus in the mainNamespace, which returns the focus to button \u201c3\u201d.\n\nstruct ContentView: View {\n    @Namespace var mainNamespace\n    @Environment(\\.resetFocus) var resetFocus\n\n\n    var body: some View {\n        VStack {\n            Button (\"1\") {}\n            Button (\"2\") {}\n            Button (\"3\") {}\n                .prefersDefaultFocus(in: mainNamespace)\n            Button (\"Reset to default focus\") {\n                resetFocus(in: mainNamespace)\n            }\n        }\n        .focusScope(mainNamespace)\n    }\n}\n\n\nThe default focus preference is limited to the focusable ancestor that matches the provided namespace. If multiple views express this preference, then SwiftUI applies the current platform rules to determine which view receives focus.\n\nSee Also\nControlling default focus\nfunc defaultFocus<V>(FocusState<V>.Binding, V, priority: DefaultFocusEvaluationPriority) -> some View\nDefines a region of the window in which default focus is evaluated by assigning a value to a given focus state binding.\nstruct DefaultFocusEvaluationPriority\nPrioritizations for default focus preferences when evaluating where to move focus in different circumstances."
    },
    {
        "title": "focusScope(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/focusscope(_:)",
        "html": "Parameters\nnamespace\n\nA namespace identifier that SwiftUI can use to scope default focus preferences.\n\nReturn Value\n\nA view that sets the namespace of descendants for default focus.\n\nDiscussion\n\nThe returned view gets associated with the provided namespace. Pass this namespace to prefersDefaultFocus(_:in:) and the resetFocus function.\n\nSee Also\nSetting focus scope\nfunc focusSection() -> some View\nIndicates that the view\u2019s frame and cohort of focusable descendants should be used to guide focus movement."
    },
    {
        "title": "MagnificationGesture",
        "url": "https://developer.apple.com/documentation/swiftui/magnificationgesture",
        "html": "Deprecated\n\nUse MagnifyGesture instead.\n\nTopics\nCreating the gesture\ninit(minimumScaleDelta: CGFloat)\nCreates a magnification gesture with a given minimum delta for the gesture to start.\nvar minimumScaleDelta: CGFloat\nThe minimum required delta before the gesture starts.\nRelationships\nConforms To\nGesture\nSee Also\nDeprecated gestures\nstruct RotationGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nDeprecated"
    },
    {
        "title": "resetFocus",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/resetfocus",
        "html": "Discussion\n\nGet this environment value and call and call it as a function to force a default focus reevaluation at runtime.\n\n@Namespace var mainNamespace\n@Environment(\\.resetFocus) var resetFocus\n\n\nvar body: some View {\n    // ...\n    resetFocus(in: mainNamespace)\n    // ...\n}\n\nSee Also\nResetting focus\nstruct ResetFocusAction\nAn environment value that provides the ability to reevaluate default focus."
    },
    {
        "title": "LongPressGesture",
        "url": "https://developer.apple.com/documentation/swiftui/longpressgesture",
        "html": "Overview\n\nTo recognize a long-press gesture on a view, create and configure the gesture, then add it to the view using the gesture(_:including:) modifier.\n\nAdd a long-press gesture to a Circle to animate its color from blue to red, and then change it to green when the gesture ends:\n\nstruct LongPressGestureView: View {\n    @GestureState private var isDetectingLongPress = false\n    @State private var completedLongPress = false\n\n\n    var longPress: some Gesture {\n        LongPressGesture(minimumDuration: 3)\n            .updating($isDetectingLongPress) { currentState, gestureState,\n                    transaction in\n                gestureState = currentState\n                transaction.animation = Animation.easeIn(duration: 2.0)\n            }\n            .onEnded { finished in\n                self.completedLongPress = finished\n            }\n    }\n\n\n    var body: some View {\n        Circle()\n            .fill(self.isDetectingLongPress ?\n                Color.red :\n                (self.completedLongPress ? Color.green : Color.blue))\n            .frame(width: 100, height: 100, alignment: .center)\n            .gesture(longPress)\n    }\n}\n\nTopics\nCreating a long press gesture\ninit(minimumDuration: Double)\nCreates a long-press gesture with a minimum duration\ninit(minimumDuration: Double, maximumDistance: CGFloat)\nCreates a long-press gesture with a minimum duration and a maximum distance that the interaction can move before the gesture fails.\nvar minimumDuration: Double\nThe minimum duration of the long press that must elapse before the gesture succeeds.\nvar maximumDistance: CGFloat\nThe maximum distance that the long press can move before the gesture fails.\nRelationships\nConforms To\nGesture\nSee Also\nRecognizing long press gestures\nfunc onLongPressGesture(minimumDuration: Double, maximumDistance: CGFloat, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongPressGesture(minimumDuration: Double, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongTouchGesture(minimumDuration: Double, perform: () -> Void, onTouchingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a remote long touch gesture. A long touch gesture is when the finger is on the remote touch surface without actually pressing."
    },
    {
        "title": "LayoutProperties",
        "url": "https://developer.apple.com/documentation/swiftui/layoutproperties",
        "html": "Overview\n\nThis structure contains configuration information that\u2019s applicable to a layout container. For example, the stackOrientation value indicates the layout\u2019s primary axis, if any.\n\nYou can use an instance of this type to characterize a custom layout container, which is a type that conforms to the Layout protocol. Implement the protocol\u2019s layoutProperties property to return an instance. For example, you can indicate that your layout has a vertical stack orientation:\n\nextension BasicVStack {\n    static var layoutProperties: LayoutProperties {\n        var properties = LayoutProperties()\n        properties.stackOrientation = .vertical\n        return properties\n    }\n}\n\n\nIf you don\u2019t implement the property in your custom layout, the protocol provides a default implementation that returns a LayoutProperties instance with default values.\n\nTopics\nCreating a layout properties instance\ninit()\nCreates a default set of properties.\nGetting layout properties\nvar stackOrientation: Axis?\nThe orientation of the containing stack-like container.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring a custom layout\nstruct ProposedViewSize\nA proposal for the size of a view.\nstruct ViewSpacing\nA collection of the geometric spacing preferences of a view."
    },
    {
        "title": "onTapGesture(count:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ontapgesture(count:perform:)",
        "html": "Parameters\ncount\n\nThe number of taps or clicks required to trigger the action closure provided in action. Defaults to 1.\n\naction\n\nThe action to perform.\n\nDiscussion\n\nUse this method to perform the specified action when the user clicks or taps on the view or container count times.\n\nNote\n\nIf you create a control that\u2019s functionally equivalent to a Button, use ButtonStyle to create a customized button instead.\n\nIn the example below, the color of the heart images changes to a random color from the colors array whenever the user clicks or taps on the view twice:\n\nstruct TapGestureExample: View {\n    let colors: [Color] = [.gray, .red, .orange, .yellow,\n                           .green, .blue, .purple, .pink]\n    @State private var fgColor: Color = .gray\n\n\n    var body: some View {\n        Image(systemName: \"heart.fill\")\n            .resizable()\n            .frame(width: 200, height: 200)\n            .foregroundColor(fgColor)\n            .onTapGesture(count: 2) {\n                fgColor = colors.randomElement()!\n            }\n    }\n}\n\n\nSee Also\nRecognizing tap gestures\nfunc onTapGesture(count: Int, coordinateSpace: some CoordinateSpaceProtocol, perform: (CGPoint) -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture, and provides the action with the location of the interaction.\nstruct TapGesture\nA gesture that recognizes one or more taps.\nstruct SpatialTapGesture\nA gesture that recognizes one or more taps and reports their location."
    },
    {
        "title": "VerticalAlignment",
        "url": "https://developer.apple.com/documentation/swiftui/verticalalignment",
        "html": "Overview\n\nUse vertical alignment guides to position views relative to one another vertically, like when you place views side-by-side in an HStack or when you create a row of views in a Grid using GridRow. The following example demonstrates common built-in vertical alignments:\n\nYou can generate the example above by creating a series of rows implemented as horizontal stacks, where you configure each stack with a different alignment guide:\n\nprivate struct VerticalAlignmentGallery: View {\n    var body: some View {\n        VStack(spacing: 30) {\n            row(alignment: .top, text: \"Top\")\n            row(alignment: .center, text: \"Center\")\n            row(alignment: .bottom, text: \"Bottom\")\n            row(alignment: .firstTextBaseline, text: \"First Text Baseline\")\n            row(alignment: .lastTextBaseline, text: \"Last Text Baseline\")\n        }\n    }\n\n\n    private func row(alignment: VerticalAlignment, text: String) -> some View {\n        HStack(alignment: alignment, spacing: 0) {\n            Color.red.frame(height: 1)\n            Text(text).font(.title).border(.gray)\n            Color.red.frame(height: 1)\n        }\n    }\n}\n\n\nDuring layout, SwiftUI aligns the views inside each stack by bringing together the specified guides of the affected views. SwiftUI calculates the position of a guide for a particular view based on the characteristics of the view. For example, the center guide appears at half the height of the view. You can override the guide calculation for a particular view using the alignmentGuide(_:computeValue:) view modifier.\n\nText baseline alignment\n\nUse the firstTextBaseline or lastTextBaseline guide to match the bottom of either the top- or bottom-most line of text that a view contains, respectively. Text baseline alignment excludes the parts of characters that descend below the baseline, like the tail on lower case g and j:\n\nrow(alignment: .firstTextBaseline, text: \"fghijkl\")\n\n\nIf you use a text baseline alignment on a view that contains no text, SwiftUI applies the equivalent of bottom alignment instead. For the row in the example above, SwiftUI matches the bottom of the horizontal lines with the baseline of the text:\n\nAligning a text view to its baseline rather than to the bottom of its frame produces the best layout effect in many cases, like when creating forms. For example, you can align the baseline of descriptive text in one GridRow cell with the baseline of a text field, or the label of a checkbox, in another cell in the same row.\n\nCustom alignment guides\n\nYou can create a custom vertical alignment guide by first creating a type that conforms to the AlignmentID protocol, and then using that type to initalize a new static property on VerticalAlignment:\n\nprivate struct FirstThirdAlignment: AlignmentID {\n    static func defaultValue(in context: ViewDimensions) -> CGFloat {\n        context.height / 3\n    }\n}\n\n\nextension VerticalAlignment {\n    static let firstThird = VerticalAlignment(FirstThirdAlignment.self)\n}\n\n\nYou implement the defaultValue(in:) method to calculate a default value for the custom alignment guide. The method receives a ViewDimensions instance that you can use to calculate a value based on characteristics of the view. The example above places the guide at one-third of the height of the view as measured from the view\u2019s origin.\n\nYou can then use the custom alignment guide like any built-in guide. For example, you can use it as the alignment parameter to an HStack, or to alter the guide calculation for a specific view using the alignmentGuide(_:computeValue:) view modifier.\n\nComposite alignment\n\nCombine a VerticalAlignment with a HorizontalAlignment to create a composite Alignment that indicates both vertical and horizontal positioning in one value. For example, you could combine your custom firstThird vertical alignment from the previous section with a built-in center horizontal alignment to use in a ZStack:\n\nstruct LayeredHorizontalStripes: View {\n    var body: some View {\n        ZStack(alignment: Alignment(horizontal: .center, vertical: .firstThird)) {\n            horizontalStripes(color: .blue)\n                .frame(width: 180, height: 90)\n            horizontalStripes(color: .green)\n                .frame(width: 70, height: 60)\n        }\n    }\n\n\n    private func horizontalStripes(color: Color) -> some View {\n        VStack(spacing: 1) {\n            ForEach(0..<3) { _ in color }\n        }\n    }\n}\n\n\nThe example above uses widths and heights that generate two mismatched sets of three vertical stripes. The ZStack centers the two sets horizontally and aligns them vertically one-third from the top of each set. This aligns the bottom edges of the top stripe from each set:\n\nTopics\nGetting guides\nstatic let top: VerticalAlignment\nA guide that marks the top edge of the view.\nstatic let center: VerticalAlignment\nA guide that marks the vertical center of the view.\nstatic let bottom: VerticalAlignment\nA guide that marks the bottom edge of the view.\nstatic let firstTextBaseline: VerticalAlignment\nA guide that marks the top-most text baseline in a view.\nstatic let lastTextBaseline: VerticalAlignment\nA guide that marks the bottom-most text baseline in a view.\nCreating a custom alignment\ninit(AlignmentID.Type)\nCreates a custom vertical alignment of the specified type.\nfunc combineExplicit<S>(S) -> CGFloat?\nMerges a sequence of explicit alignment values produced by this instance.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "HorizontalAlignment",
        "url": "https://developer.apple.com/documentation/swiftui/horizontalalignment",
        "html": "Overview\n\nUse horizontal alignment guides to tell SwiftUI how to position views relative to one another horizontally, like when you place views vertically in an VStack. The following example demonstrates common built-in horizontal alignments:\n\nYou can generate the example above by creating a series of columns implemented as vertical stacks, where you configure each stack with a different alignment guide:\n\nprivate struct HorizontalAlignmentGallery: View {\n    var body: some View {\n        HStack(spacing: 30) {\n            column(alignment: .leading, text: \"Leading\")\n            column(alignment: .center, text: \"Center\")\n            column(alignment: .trailing, text: \"Trailing\")\n        }\n        .frame(height: 150)\n    }\n\n\n    private func column(alignment: HorizontalAlignment, text: String) -> some View {\n        VStack(alignment: alignment, spacing: 0) {\n            Color.red.frame(width: 1)\n            Text(text).font(.title).border(.gray)\n            Color.red.frame(width: 1)\n        }\n    }\n}\n\n\nDuring layout, SwiftUI aligns the views inside each stack by bringing together the specified guides of the affected views. SwiftUI calculates the position of a guide for a particular view based on the characteristics of the view. For example, the center guide appears at half the width of the view. You can override the guide calculation for a particular view using the alignmentGuide(_:computeValue:) view modifier.\n\nLayout direction\n\nWhen a user configures their device to use a left-to-right language like English, the system places the leading alignment on the left and the trailing alignment on the right, as the example from the previous section demonstrates. However, in a right-to-left language, the system reverses these. You can see this by using the environment(_:_:) view modifier to explicitly override the layoutDirection environment value for the view defined above:\n\nHorizontalAlignmentGallery()\n    .environment(\\.layoutDirection, .rightToLeft)\n\n\nThis automatic layout adjustment makes it easier to localize your app, but it\u2019s still important to test your app for the different locales that you ship into. For more information about the localization process, see Localization.\n\nCustom alignment guides\n\nYou can create a custom horizontal alignment by creating a type that conforms to the AlignmentID protocol, and then using that type to initalize a new static property on HorizontalAlignment:\n\nprivate struct OneQuarterAlignment: AlignmentID {\n    static func defaultValue(in context: ViewDimensions) -> CGFloat {\n        context.width / 4\n    }\n}\n\n\nextension HorizontalAlignment {\n    static let oneQuarter = HorizontalAlignment(OneQuarterAlignment.self)\n}\n\n\nYou implement the defaultValue(in:) method to calculate a default value for the custom alignment guide. The method receives a ViewDimensions instance that you can use to calculate an appropriate value based on characteristics of the view. The example above places the guide at one quarter of the width of the view, as measured from the view\u2019s origin.\n\nYou can then use the custom alignment guide like any built-in guide. For example, you can use it as the alignment parameter to a VStack, or you can change it for a specific view using the alignmentGuide(_:computeValue:) view modifier. Custom alignment guides also automatically reverse in a right-to-left environment, just like built-in guides.\n\nComposite alignment\n\nCombine a VerticalAlignment with a HorizontalAlignment to create a composite Alignment that indicates both vertical and horizontal positioning in one value. For example, you could combine your custom oneQuarter horizontal alignment from the previous section with a built-in center vertical alignment to use in a ZStack:\n\nstruct LayeredVerticalStripes: View {\n    var body: some View {\n        ZStack(alignment: Alignment(horizontal: .oneQuarter, vertical: .center)) {\n            verticalStripes(color: .blue)\n                .frame(width: 300, height: 150)\n            verticalStripes(color: .green)\n                .frame(width: 180, height: 80)\n        }\n    }\n\n\n    private func verticalStripes(color: Color) -> some View {\n        HStack(spacing: 1) {\n            ForEach(0..<4) { _ in color }\n        }\n    }\n}\n\n\nThe example above uses widths and heights that generate two mismatched sets of four vertical stripes. The ZStack centers the two sets vertically and aligns them horizontally one quarter of the way from the leading edge of each set. In a left-to-right locale, this aligns the right edges of the left-most stripes of each set:\n\nTopics\nGetting guides\nstatic let leading: HorizontalAlignment\nA guide that marks the leading edge of the view.\nstatic let center: HorizontalAlignment\nA guide that marks the horizontal center of the view.\nstatic let trailing: HorizontalAlignment\nA guide that marks the trailing edge of the view.\nstatic let listRowSeparatorLeading: HorizontalAlignment\nA guide marking the leading edge of a List row separator.\nstatic let listRowSeparatorTrailing: HorizontalAlignment\nA guide marking the trailing edge of a List row separator.\nCreating a custom alignment\ninit(AlignmentID.Type)\nCreates a custom horizontal alignment of the specified type.\nfunc combineExplicit<S>(S) -> CGFloat?\nMerges a sequence of explicit alignment values produced by this instance.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "padding(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/padding(_:_:)",
        "html": "Parameters\nedges\n\nThe set of edges to pad for this view. The default is all.\n\nlength\n\nAn amount, given in points, to pad this view on the specified edges. If you set the value to nil, SwiftUI uses a platform-specific default amount. The default value of this parameter is nil.\n\nReturn Value\n\nA view that\u2019s padded by the specified amount on the specified edges.\n\nDiscussion\n\nUse this modifier to add a specified amount of padding to one or more edges of the view. Indicate the edges to pad by naming either a single value from Edge.Set, or by specifying an OptionSet that contains edge values:\n\nVStack {\n    Text(\"Text padded by 20 points on the bottom and trailing edges.\")\n        .padding([.bottom, .trailing], 20)\n        .border(.gray)\n    Text(\"Unpadded text for comparison.\")\n        .border(.yellow)\n}\n\n\nThe order in which you apply modifiers matters. The example above applies the padding before applying the border to ensure that the border encompasses the padded region:\n\nYou can omit either or both of the parameters. If you omit the length, SwiftUI uses a default amount of padding. If you omit the edges, SwiftUI applies the padding to all edges. Omit both to add a default padding all the way around a view. SwiftUI chooses a default amount of padding that\u2019s appropriate for the platform and the presentation context.\n\nVStack {\n    Text(\"Text with default padding.\")\n        .padding()\n        .border(.gray)\n    Text(\"Unpadded text for comparison.\")\n        .border(.yellow)\n}\n\n\nThe example above looks like this in iOS under typical conditions:\n\nTo control the amount of padding independently for each edge, use padding(_:). To pad all outside edges of a view by a specified amount, use padding(_:).\n\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "layoutDirection",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/layoutdirection",
        "html": "Discussion\n\nUse this value to determine or set whether the environment uses a left-to-right or right-to-left direction.\n\nSee Also\nSetting a layout direction\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> some View\nSets the behavior of this view for different layout directions.\nenum LayoutDirectionBehavior\nA description of what should happen when the layout direction changes.\nenum LayoutDirection\nA direction in which SwiftUI can lay out content."
    },
    {
        "title": "scaledToFill()",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaledtofill()",
        "html": "Return Value\n\nA view that scales this view to fill its parent, maintaining this view\u2019s aspect ratio.\n\nDiscussion\n\nUse scaledToFill() to scale this view to fill its parent, while maintaining the view\u2019s aspect ratio as the view scales:\n\nCircle()\n    .fill(Color.pink)\n    .scaledToFill()\n    .frame(width: 300, height: 150)\n    .border(Color(white: 0.75))\n\n\nThis method is equivalent to calling aspectRatio(_:contentMode:) with a nil aspectRatio and a content mode of ContentMode.fill.\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "scaleEffect(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-8licv",
        "html": "Parameters\ns\n\nThe amount to scale the view in the view in both the horizontal and vertical directions.\n\nanchor\n\nThe anchor point with a default of center that indicates the starting position for the scale operation.\n\nDiscussion\n\nUse scaleEffect(_:anchor:) to apply a horizontally and vertically scaling transform to a view.\n\nImage(systemName: \"envelope.badge.fill\")\n    .resizable()\n    .frame(width: 100, height: 100, alignment: .center)\n    .foregroundColor(Color.red)\n    .scaleEffect(2, anchor: .leading)\n    .border(Color.gray)\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "UnitPoint",
        "url": "https://developer.apple.com/documentation/swiftui/unitpoint",
        "html": "Overview\n\nUse a unit point to represent a location in a view without having to know the view\u2019s rendered size. The point stores a value in each dimension that indicates the fraction of the view\u2019s size in that dimension \u2014 measured from the view\u2019s origin \u2014 where the point appears. For example, you can create a unit point that represents the center of any view by using the value 0.5 for each dimension:\n\nlet unitPoint = UnitPoint(x: 0.5, y: 0.5)\n\n\nTo project the unit point into the rendered view\u2019s coordinate space, multiply each component of the unit point with the corresponding component of the view\u2019s size:\n\nlet projectedPoint = CGPoint(\n    x: unitPoint.x * size.width,\n    y: unitPoint.y * size.height\n)\n\n\nYou can perform this calculation yourself if you happen to know a view\u2019s size, or if you want to use the unit point for some custom purpose, but SwiftUI typically does this for you to carry out operations that you request, like when you:\n\nTransform a shape using a shape modifier. For example, to rotate a shape with rotation(_:anchor:), you indicate an anchor point that you want to rotate the shape around.\n\nOverride the alignment of the view in a Grid cell using the gridCellAnchor(_:) view modifier. The grid aligns the projection of a unit point onto the view with the projection of the same unit point onto the cell.\n\nCreate a gradient that has a center, or start and stop points, relative to the shape that you are styling. See the gradient methods in ShapeStyle.\n\nYou can create custom unit points with explicit values, like the example above, or you can use one of the built-in unit points that SwiftUI provides, like zero, center, or topTrailing. The built-in values correspond to the alignment positions of the similarly named, built-in Alignment types.\n\nNote\n\nA unit point with one or more components outside the range [0, 1] projects to a point outside of the view.\n\nLayout direction\n\nWhen a person configures their device to use a left-to-right language like English, the system places the view\u2019s origin in its top-left corner, with positive x toward the right and positive y toward the bottom of the view. In a right-to-left environment, the origin moves to the upper-right corner, and the positive x direction changes to be toward the left. You don\u2019t typically need to do anything to handle this change, because SwiftUI applies the change to all aspects of the system. For example, see the discussion about layout direction in HorizontalAlignment.\n\nIt\u2019s important to test your app for the different locales that you distribute your app in. For more information about the localization process, see Localization.\n\nTopics\nGetting the origin\nstatic let zero: UnitPoint\nThe origin of a view.\nGetting top points\nstatic let topLeading: UnitPoint\nA point that\u2019s in the top, leading corner of a view.\nstatic let top: UnitPoint\nA point that\u2019s centered horizontally on the top edge of a view.\nstatic let topTrailing: UnitPoint\nA point that\u2019s in the top, trailing corner of a view.\nGetting middle points\nstatic let leading: UnitPoint\nA point that\u2019s centered vertically on the leading edge of a view.\nstatic let center: UnitPoint\nA point that\u2019s centered in a view.\nstatic let trailing: UnitPoint\nA point that\u2019s centered vertically on the trailing edge of a view.\nGetting bottom points\nstatic let bottomLeading: UnitPoint\nA point that\u2019s in the bottom, leading corner of a view.\nstatic let bottom: UnitPoint\nA point that\u2019s centered horizontally on the bottom edge of a view.\nstatic let bottomTrailing: UnitPoint\nA point that\u2019s in the bottom, trailing corner of a view.\nCreating a point\ninit()\nCreates a unit point at the origin.\ninit(x: CGFloat, y: CGFloat)\nCreates a unit point with the specified horizontal and vertical offsets.\nGetting the point\u2019s coordinates\nvar x: CGFloat\nThe normalized distance from the origin to the point in the horizontal direction.\nvar y: CGFloat\nThe normalized distance from the origin to the point in the vertical dimension.\nRelationships\nConforms To\nAnimatable\nEquatable\nHashable\nSendable\nSee Also\nAccessing geometric constructs\nenum Axis\nThe horizontal or vertical dimension in a 2D coordinate system.\nstruct Angle\nA geometric angle whose value you access in either radians or degrees.\nstruct UnitPoint3D\nA normalized 3D point in a view\u2019s coordinate space.\nBeta\nstruct Anchor\nAn opaque value derived from an anchor source and a particular view."
    },
    {
        "title": "LayoutDirectionBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/layoutdirectionbehavior",
        "html": "Overview\n\nA LayoutDirectionBehavior can be used with the layoutDirectionBehavior view modifier or the layoutDirectionBehavior property of Shape.\n\nTopics\nGetting behaviors\ncase fixed\nA behavior that doesn\u2019t mirror when the layout direction changes.\nstatic var mirrors: LayoutDirectionBehavior\nA behavior that mirrors when the layout direction is right-to-left.\ncase mirrors(in: LayoutDirection)\nA behavior that mirrors when the layout direction has the specified value.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nSetting a layout direction\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> some View\nSets the behavior of this view for different layout directions.\nvar layoutDirection: LayoutDirection\nThe layout direction associated with the current environment.\nenum LayoutDirection\nA direction in which SwiftUI can lay out content."
    },
    {
        "title": "mask(alignment:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/mask(alignment:_:)",
        "html": "Parameters\nalignment\n\nThe alignment for mask in relation to this view.\n\nmask\n\nThe view whose alpha the rendering system applies to the specified view.\n\nDiscussion\n\nUse mask(_:) when you want to apply the alpha (opacity) value of another view to the current view.\n\nThis example shows an image masked by rectangle with a 10% opacity:\n\nImage(systemName: \"envelope.badge.fill\")\n    .foregroundColor(Color.blue)\n    .font(.system(size: 128, weight: .regular))\n    .mask {\n        Rectangle().opacity(0.1)\n    }\n\n\nSee Also\nMasking and clipping\nfunc clipped(antialiased: Bool) -> some View\nClips this view to its bounding rectangular frame.\nfunc clipShape<S>(S, style: FillStyle) -> some View\nSets a clipping shape for this view."
    },
    {
        "title": "compositingGroup()",
        "url": "https://developer.apple.com/documentation/swiftui/view/compositinggroup()",
        "html": "Return Value\n\nA view that wraps this view in a compositing group.\n\nDiscussion\n\nA compositing group makes compositing effects in this view\u2019s ancestor views, such as opacity and the blend mode, take effect before this view is rendered.\n\nUse compositingGroup() to apply effects to a parent view before applying effects to this view.\n\nIn the example below the compositingGroup() modifier separates the application of effects into stages. It applies the opacity(_:) effect to the VStack before the blur(radius:) effect is applied to the views inside the enclosed ZStack. This limits the scope of the opacity change to the outermost view.\n\nVStack {\n    ZStack {\n        Text(\"CompositingGroup\")\n            .foregroundColor(.black)\n            .padding(20)\n            .background(Color.red)\n        Text(\"CompositingGroup\")\n            .blur(radius: 2)\n    }\n    .font(.largeTitle)\n    .compositingGroup()\n    .opacity(0.9)\n}\n\n\nSee Also\nCompositing views\nfunc blendMode(BlendMode) -> some View\nSets the blend mode for compositing this view with overlapping views.\nfunc drawingGroup(opaque: Bool, colorMode: ColorRenderingMode) -> some View\nComposites this view\u2019s contents into an offscreen image before final display.\nenum BlendMode\nModes for compositing a view with overlapping content.\nenum ColorRenderingMode\nThe set of possible working color spaces for color-compositing operations."
    },
    {
        "title": "scenePadding(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scenepadding(_:)",
        "html": "Parameters\nedges\n\nThe set of edges along which to pad this view.\n\nReturn Value\n\nA view that\u2019s padded on specified edges by a scene-appropriate amount.\n\nDiscussion\n\nUse this modifier to add a scene-appropriate amount of padding to a view. Specify either a single edge value from Edge.Set, or an OptionSet that describes the edges to pad.\n\nIn macOS, use scene padding to produce the recommended spacing around the root view of a window. In watchOS, use scene padding to align elements of your user interface with top level elements, like the title of a navigation view. For example, compare the effects of different kinds of padding on text views presented inside a NavigationView in watchOS:\n\nVStack(alignment: .leading, spacing: 10) {\n    Text(\"Scene padding\")\n        .scenePadding(.horizontal)\n        .border(.red) // Border added for reference.\n    Text(\"Regular padding\")\n        .padding(.horizontal)\n        .border(.green)\n    Text(\"Text with no padding\")\n        .border(.blue)\n    Button(\"Button\") { }\n}\n.navigationTitle(\"Hello World\")\n\n\nThe text with scene padding automatically aligns with the title, unlike the text that uses the default padding or the text without padding:\n\nScene padding in watchOS also ensures that your content avoids the curved edges of a device like Apple Watch Series 7. In other platforms, scene padding produces the same default padding that you get from the padding(_:_:) modifier.\n\nImportant\n\nScene padding doesn\u2019t pad the top and bottom edges of a view in watchOS, even if you specify those edges as part of the input. For example, if you specify vertical instead of horizontal in the example above, the modifier would have no effect in watchOS. It does, however, apply to all the edges that you specify in other platforms.\n\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "padding3D(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/padding3d(_:)-1je1m",
        "html": "Parameters\nlength\n\nThe amount to inset this view on each edge.\n\nReturn Value\n\nA view that pads this view by the amount you specify.\n\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "padding3D(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/padding3d(_:)-6bex4",
        "html": "Parameters\ninsets\n\nThe edges to inset.\n\nReturn Value\n\nA view that pads this view using edge the insets you specify.\n\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "Angle",
        "url": "https://developer.apple.com/documentation/swiftui/angle",
        "html": "Topics\nGetting constant angles\nstatic var zero: Angle\nstatic func degrees(Double) -> Angle\nstatic func radians(Double) -> Angle\nCreating an angle\ninit()\ninit(degrees: Double)\ninit(radians: Double)\ninit(Angle2D)\nBeta\nGetting the angle size\nvar degrees: Double\nvar radians: Double\nRelationships\nConforms To\nAnimatable\nComparable\nEquatable\nHashable\nSendable\nSee Also\nAccessing geometric constructs\nenum Axis\nThe horizontal or vertical dimension in a 2D coordinate system.\nstruct UnitPoint\nA normalized 2D point in a view\u2019s coordinate space.\nstruct UnitPoint3D\nA normalized 3D point in a view\u2019s coordinate space.\nBeta\nstruct Anchor\nAn opaque value derived from an anchor source and a particular view."
    },
    {
        "title": "padding3D(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/padding3d(_:_:)",
        "html": "Parameters\nedges\n\nThe set of edges along which to inset this view.\n\nlength\n\nThe amount to inset this view on each edge. If nil, the amount is the system default amount.\n\nReturn Value\n\nA view that pads this view using edge the insets you specify.\n\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "ColorRenderingMode",
        "url": "https://developer.apple.com/documentation/swiftui/colorrenderingmode",
        "html": "Overview\n\nEach color space guarantees the preservation of a particular range of color values.\n\nTopics\nGetting rendering modes\ncase extendedLinear\nThe extended linear sRGB working color space.\ncase linear\nThe linear sRGB working color space.\ncase nonLinear\nThe non-linear sRGB working color space.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCompositing views\nfunc blendMode(BlendMode) -> some View\nSets the blend mode for compositing this view with overlapping views.\nfunc compositingGroup() -> some View\nWraps this view in a compositing group.\nfunc drawingGroup(opaque: Bool, colorMode: ColorRenderingMode) -> some View\nComposites this view\u2019s contents into an offscreen image before final display.\nenum BlendMode\nModes for compositing a view with overlapping content."
    },
    {
        "title": "Laying out a simple view",
        "url": "https://developer.apple.com/documentation/swiftui/laying-out-a-simple-view",
        "html": "Overview\n\nTo create a layout for a view, start by composing a hierarchy of child views. Then, refine the size and spacing of the child views with configuration parameters, and by adding view modifiers, like those that affect a view\u2019s frame and padding. To review how to compose layouts, see Building layouts with stack views.\n\nEstablish a view hierarchy\n\nThe following example creates a view to display an incoming message from a messaging service. The view uses an HStack to collect a view that identifies the sender and another that provides the content of the message:\n\nstruct MessageRow: View {\n    let message: Message\n\n\n    var body: some View {\n        HStack {\n            ZStack {\n                Circle()\n                    .fill(Color.yellow)\n                Text(message.initials)\n            }\n\n\n            Text(message.content)\n        }\n    }\n}\n\n\nThe following screenshot of a MessageRow view includes a border that shows its bounds. Note the large size of the circle, which fills the space available to it:\n\nWhen SwiftUI renders a view hierarchy, it recursively evaluates each child view: The parent view proposes a size to the child views it contains, and the child views respond with a computed size.\n\nThe MessageRow view proposes a size to its only child, the HStack, which is the full size proposed to it by its own parent. The stack proportionally divides this space between its child views, with system-default spacing between each child. This continues recursively:\n\nThe ZStack proposes a size to its child views, the Circle and Text views.\n\nThe Circle expands up to the size offered, while the Text takes just enough space for the string it contains.\n\nThe ZStack returns the size of its largest child view, in this case the Circle.\n\nWhen all child views have reported their size, the parent view renders them. For a hands-on approach to learning how the SwiftUI view hierarchy works, see the Building lists and navigation section in the Introducing SwiftUI tutorial.\n\nLimit the view size\n\nIn the example above, SwiftUI has built-in views that manage size in different ways, including views that:\n\nExpand to fill the space offered by their parent, like Color, LinearGradient, and Circle.\n\nHave an ideal size that varies according to their contents, like Text and the container views.\n\nHave an ideal size that never varies, like Toggle or DatePicker.\n\nYou can constrain a view to a fixed size by adding a frame modifier. For example, use the frame(width:height:alignment:) modifier to limit the width the circle to 40 points:\n\nstruct MessageRow: View {\n    let message: Message\n\n\n    var body: some View {\n        HStack {\n            ZStack {\n                Circle()\n                    .fill(Color.yellow)\n                Text(message.initials)\n            }\n            .frame(width: 40)\n\n\n            Text(message.content)\n        }\n    }\n}\n\n\nWhen you add a frame modifier, SwiftUI wraps the affected view, effectively adding a new view to the view hierarchy.\n\nWhen SwiftUI evaluates this new hierarchy, the frame modifier fixes the width of the ZStack that it wraps by passing along the value you specified as its parameter. The remainder of the size evaluation proceeds as before, where the Circle now expands to fill a smaller space, constrained by the frame\u2019s 40 point width. This enables the HStack to provide more space to its other child, which displays the message text.\n\nPosition content with alignment\n\nIf you want the top of the circle aligned with the top of the message content text, you can refine the view by applying an alignment to the HStack. To position the content vertically within the stack, specify the alignment parameter to top:\n\nstruct MessageRow: View {\n    let message: Message\n\n\n    var body: some View {\n        HStack(alignment: .top) {\n            ZStack {\n                Circle()\n                    .fill(Color.yellow)\n                Text(message.initials)\n            }\n            .frame(width: 40)\n\n\n            Text(message.content)\n        }\n    }\n}\n\n\nWith the alignment applied, you get an unexpected result. The tops of the views don\u2019t appear to align:\n\nHowever, if you select the circle in Xcode, or temporarily add a border to the circle, you can see the tops of the views do in fact align. For more information on inspecting the size of a view, see Inspecting view layout.\n\nIn the previous section, you applied a frame with only a width constraint. SwiftUI drew a circle limited by that width. But because the height was left unspecified, the circle\u2019s frame separately expanded to fill the available height, even though that extra space had no visible impact on the rendered circle. You can resolve this problem by adding an explicit height parameter:\n\nstruct MessageRow: View {\n    let message: Message\n\n\n    var body: some View {\n        HStack(alignment: .top) {\n            ZStack {\n                Circle()\n                    .fill(Color.yellow)\n                Text(message.initials)\n            }\n            .frame(width: 40, height: 40)\n\n\n            Text(message.content)\n        }\n    }\n}\n\n\nThe contents of the HStack are now top aligned, although the stack itself is centered in the MessageRow view as shown by the border displaying the row\u2019s boundaries.\n\nAdd padding to the view\n\nTo avoid visually crowding the outer edges of a view, add padding. This introduces a fixed amount of space along the specified edges, reducing the space available for the contents of the view by a corresponding amount. For example, you can use padding(_:_:) to add extra space along the horizontal edges of the HStack:\n\nstruct MessageRow: View {\n    let message: Message\n\n\n    var body: some View {\n        HStack(alignment: .top) {\n            ZStack {\n                Circle()\n                    .fill(Color.yellow)\n                Text(message.initials)\n            }\n            .frame(width: 40, height: 40)\n\n\n            Text(message.content)\n        }\n        .padding([.horizontal])\n    }\n}\n\n\nThe padding modifier defaults to system-standard spacing, although you can alternatively choose different values for the padding modifier.\n\nSee Also\nFinetuning a layout\nInspecting view layout\nDetermine the position and extent of a view using Xcode previews or by adding temporary borders."
    },
    {
        "title": "LabeledContent",
        "url": "https://developer.apple.com/documentation/swiftui/labeledcontent",
        "html": "Overview\n\nThe instance\u2019s content represents a read-only or read-write value, and its label identifies or describes the purpose of that value. The resulting element has a layout that\u2019s consistent with other framework controls and automatically adapts to its container, like a form or toolbar. Some styles of labeled content also apply styling or behaviors to the value content, like making Text views selectable.\n\nThe following example associates a label with a custom view and has a layout that matches the label of the Picker:\n\nForm {\n    LabeledContent(\"Custom Value\") {\n        MyCustomView(value: $value)\n    }\n    Picker(\"Selected Value\", selection: $selection) {\n        Text(\"Option 1\").tag(1)\n        Text(\"Option 2\").tag(2)\n    }\n}\n\nCustom view labels\n\nYou can assemble labeled content with an explicit view for its label using the init(content:label:) initializer. For example, you can rewrite the previous labeled content example using a Text view:\n\nLabeledContent {\n    MyCustomView(value: $value)\n} label: {\n    Text(\"Custom Value\")\n}\n\n\nThe label view builder accepts any kind of view, like a Label:\n\nLabeledContent {\n    MyCustomView(value: $value)\n} label: {\n    Label(\"Custom Value\", systemImage: \"hammer\")\n}\n\nTextual labeled content\n\nYou can construct labeled content with string values or formatted values to create read-only displays of textual values:\n\nForm {\n    Section(\"Information\") {\n        LabeledContent(\"Name\", value: person.name)\n        LabeledContent(\"Age\", value: person.age, format: .number)\n        LabeledContent(\"Height\", value: person.height,\n            format: .measurement(width: .abbreviated))\n    }\n    if !person.pets.isEmpty {\n        Section(\"Pets\") {\n            ForEach(pet) { pet in\n                LabeledContent(pet.species, value: pet.name)\n            }\n        }\n    }\n}\n\n\nWherever possible, SwiftUI makes this text selectable.\n\nCompositional elements\n\nYou can use labeled content as the label for other elements. For example, a NavigationLink can present a summary value for the destination it links to:\n\nForm {\n    NavigationLink(value: Settings.wifiDetail) {\n        LabeledContent(\"Wi-Fi\", value: ssidName)\n    }\n}\n\n\nIn some cases, the styling of views used as the value content is specialized as well. For example, while a Toggle in an inset group form on macOS is styled as a switch by default, it\u2019s styled as a checkbox when used as a value element within a surrounding LabeledContent instance:\n\nForm {\n    LabeledContent(\"Source Control\") {\n        Toggle(\"Refresh local status automatically\",\n            isOn: $refreshLocalStatus)\n        Toggle(\"Fetch and refresh server status automatically\",\n            isOn: $refreshServerStatus)\n        Toggle(\"Add and remove files automatically\",\n            isOn: $addAndRemoveFiles)\n        Toggle(\"Select files to commit automatically\",\n            isOn: $selectFiles)\n    }\n}\n\nControlling label visibility\n\nA label communicates the identity or purpose of the value, which is important for accessibility. However, you might want to hide the label in the display, and some controls or contexts may visually hide their label by default. The labelsHidden() modifier allows controlling that visibility. The following example hides both labels, producing only a group of the two value views:\n\nGroup {\n    LabeledContent(\"Custom Value\") {\n        MyCustomView(value: $value)\n    }\n    Picker(\"Selected Value\", selection: $selection) {\n        Text(\"Option 1\").tag(1)\n        Text(\"Option 2\").tag(2)\n    }\n}\n.labelsHidden()\n\nStyling labeled content\n\nYou can set label styles using the labeledContentStyle(_:) modifier. You can also build custom styles using LabeledContentStyle.\n\nTopics\nCreating labeled content\ninit(LocalizedStringKey, content: () -> Content)\nCreates a labeled view that generates its label from a localized string key.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a labeled view that generates its label from a string.\nAvailable when Label is Text and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a standard labeled element, with a view that conveys the value of the element and a label.\nAvailable when Label conforms to View and Content conforms to View.\nCreating informational views\ninit<S>(LocalizedStringKey, value: S)\nCreates a labeled informational view.\nAvailable when Label is Text and Content is Text.\ninit<S1, S2>(S1, value: S2)\nCreates a labeled informational view.\nAvailable when Label is Text and Content is Text.\nCreating formatted labeled content\ninit<F>(LocalizedStringKey, value: F.FormatInput, format: F)\nCreates a labeled informational view from a formatted value.\nAvailable when Label is Text and Content is Text.\ninit<S, F>(S, value: F.FormatInput, format: F)\nCreates a labeled informational view from a formatted value.\nAvailable when Label is Text and Content is Text.\nCreating labeled content from a configuration\ninit(LabeledContentStyleConfiguration)\nCreates labeled content based on a labeled content style configuration.\nAvailable when Label is LabeledContentStyleConfiguration.Label and Content is LabeledContentStyleConfiguration.Content.\nRelationships\nConforms To\nView\nConforms when Label conforms to View and Content conforms to View.\nSee Also\nGrouping inputs\nstruct Form\nA container for grouping controls used for data entry, such as in settings or inspectors.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content."
    },
    {
        "title": "ControlGroup",
        "url": "https://developer.apple.com/documentation/swiftui/controlgroup",
        "html": "Overview\n\nYou can provide an optional label to this view that describes its children. This view may be used in different ways depending on the surrounding context. For example, when you place the control group in a toolbar item, SwiftUI uses the label when the group is moved to the toolbar\u2019s overflow menu.\n\nContentView()\n    .toolbar(id: \"items\") {\n        ToolbarItem(id: \"media\") {\n            ControlGroup {\n                MediaButton()\n                ChartButton()\n                GraphButton()\n            } label: {\n                Label(\"Plus\", systemImage: \"plus\")\n            }\n        }\n    }\n\nTopics\nCreating a control group\ninit(content: () -> Content)\nCreates a new ControlGroup with the specified children\ninit<C, L>(content: () -> C, label: () -> L)\nCreates a new control group with the specified content and a label.\nAvailable when Content conforms to View.\ninit<C, S>(S, content: () -> C)\nCreates a new control group with the specified content that generates its label from a string.\nAvailable when Content conforms to View.\ninit<C>(LocalizedStringKey, content: () -> C)\nCreates a new control group with the specified content that generates its label from a localized string key.\nAvailable when Content conforms to View.\nCreating a control group with an image\ninit<C>(LocalizedStringKey, image: ImageResource, content: () -> C)\nCreates a new control group with the specified content that generates its label from a localized string key and image resource.\nAvailable when Content conforms to View.\ninit<C, S>(S, image: ImageResource, content: () -> C)\nCreates a new control group with the specified content that generates its label from a string and image name.\nAvailable when Content conforms to View.\ninit<C>(LocalizedStringKey, systemImage: String, content: () -> C)\nCreates a new control group with the specified content that generates its label from a localized string key and image name.\nAvailable when Content conforms to View.\ninit<C, S>(S, systemImage: String, content: () -> C)\nCreates a new control group with the specified content that generates its label from a string and image name.\nAvailable when Content conforms to View.\nCreating a configured control group\ninit(ControlGroupStyleConfiguration)\nCreates a control group based on a style configuration.\nAvailable when Content is ControlGroupStyleConfiguration.Content.\nSupporting types\nstruct LabeledControlGroupContent\nA view that represents the body of a control group with a specified label.\nRelationships\nConforms To\nView\nSee Also\nPresenting a group of controls\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view."
    },
    {
        "title": "GroupBox",
        "url": "https://developer.apple.com/documentation/swiftui/groupbox",
        "html": "Overview\n\nUse a group box when you want to visually distinguish a portion of your user interface with an optional title for the boxed content.\n\nThe following example sets up a GroupBox with the label \u201cEnd-User Agreement\u201d, and a long agreementText string in a Text view wrapped by a ScrollView. The box also contains a Toggle for the user to interact with after reading the text.\n\nvar body: some View {\n    GroupBox(label:\n        Label(\"End-User Agreement\", systemImage: \"building.columns\")\n    ) {\n        ScrollView(.vertical, showsIndicators: true) {\n            Text(agreementText)\n                .font(.footnote)\n        }\n        .frame(height: 100)\n        Toggle(isOn: $userAgreed) {\n            Text(\"I agree to the above terms\")\n        }\n    }\n}\n\n\nTopics\nCreating a group box\ninit(content: () -> Content)\nCreates an unlabeled group box with the provided view content.\nAvailable when Label is EmptyView and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a group box with the provided label and view content.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a group box with the provided view content and title.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a group box with the provided view content.\nAvailable when Label is Text and Content conforms to View.\nCreating a group box from a configuration\ninit(GroupBoxStyleConfiguration)\nCreates a group box based on a style configuration.\nAvailable when Label is GroupBoxStyleConfiguration.Label and Content is GroupBoxStyleConfiguration.Content.\nDeprecated initializers\ninit(label: Label, content: () -> Content)\nAvailable when Label conforms to View and Content conforms to View.\nRelationships\nConforms To\nView\nSee Also\nGrouping views into a box\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view."
    },
    {
        "title": "tableColumnHeaders(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tablecolumnheaders(_:)",
        "html": "Parameters\nvisibility\n\nA value of visible will show table columns, hidden will remove them, and automatic will defer to default behavior.\n\nDiscussion\n\nBy default, Table will display a global header view with the labels of each table column. This area is also where users can sort, resize, and rearrange the columns. For simple cases that don\u2019t require those features, this header can be hidden.\n\nThis will not affect the header of any Sections in a table.\n\nTable(article.authors) {\n    TableColumn(\"Name\", value: \\.name)\n    TableColumn(\"Title\", value: \\.title)\n}\n.tableColumnHeaders(.hidden)\n\nSee Also\nCustomizing columns\nstruct TableColumnCustomization\nA representation of the state of the columns in a table.\nstruct TableColumnCustomizationBehavior\nA set of customization behaviors of a column that a table can offer to a user."
    },
    {
        "title": "TableColumnAlignment",
        "url": "https://developer.apple.com/documentation/swiftui/tablecolumnalignment",
        "html": "Overview\n\nThe alignment of a column applies to both its header label as well as the default alignment of its content view for each row.\n\nTopics\nGetting the alignment\nstatic var automatic: TableColumnAlignment\nThe default column alignment.\nstatic var leading: TableColumnAlignment\nLeading column alignment.\nstatic var center: TableColumnAlignment\nCenter column alignment.\nstatic var trailing: TableColumnAlignment\nTrailing column alignment.\nstatic var numeric: TableColumnAlignment\nColumn alignment appropriate for numeric content.\nstatic func numeric(Locale.NumberingSystem) -> TableColumnAlignment\nColumn alignment appropriate for numeric content.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCreating columns\nstruct TableColumn\nA column that displays a view for each row in a table.\nprotocol TableColumnContent\nA type used to represent columns within a table.\nstruct TableColumnBuilder\nA result builder that creates table column content from closures."
    },
    {
        "title": "TupleTableRowContent",
        "url": "https://developer.apple.com/documentation/swiftui/tupletablerowcontent",
        "html": "Overview\n\nDon\u2019t use this type directly; instead, SwiftUI uses this type as the return value from the various buildBlock methods in TableRowBuilder. The size of the tuple corresponds to how many columns you create in the rows closure you provide to the Table initializer.\n\nTopics\nAccessing the value\nvar value: T\nRelationships\nConforms To\nTableRowContent\nSee Also\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nprotocol TableRowContent\nA type used to represent table rows.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data.\nstruct TableRowBuilder\nA result builder that creates table row content from closures."
    },
    {
        "title": "TableRow",
        "url": "https://developer.apple.com/documentation/swiftui/tablerow",
        "html": "Overview\n\nCreate instances of TableRow in the closure you provide to the rows parameter in Table initializers that take columns and rows. The table provides the value of a row to each column of a table, which produces the cells for each row in the column.\n\nTopics\nCreating a row\ninit(Value)\nCreates a table row for the given value.\nRelationships\nConforms To\nTableRowContent\nSee Also\nCreating rows\nprotocol TableRowContent\nA type used to represent table rows.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data.\nstruct TableRowBuilder\nA result builder that creates table row content from closures."
    },
    {
        "title": "TableColumnCustomization",
        "url": "https://developer.apple.com/documentation/swiftui/tablecolumncustomization",
        "html": "Overview\n\nTableColumnCustomization can be created and provided to a table to enable column reordering and column visibility. The state can be queried and updated programmatically, as well as bound to persistent app or scene storage.\n\nstruct BugReportTable: View {\n    @ObservedObject var dataModel: DataModel\n    @Binding var selectedBugReports: Set<BugReport.ID>\n\n\n    @SceneStorage(\"BugReportTableConfig\")\n    private var columnCustomization: TableColumnCustomization<BugReport>\n\n\n    var body: some View {\n        Table(dataModel.bugReports, selection: $selectedBugReports,\n            sortOrder: $dataModel.sortOrder,\n            columnCustomization: $columnCustomization\n        ) {\n            TableColumn(\"Title\", value: \\.title)\n                .customizationID(\"title\")\n            TableColumn(\"ID\", value: \\.id) {\n                Link(\"\\($0.id)\", destination: $0.url)\n            }\n            .customizationID(\"id\")\n            TableColumn(\"Number of Reports\", value: \\.duplicateCount) {\n                Text($0.duplicateCount, format: .number)\n            }\n            .customizationID(\"duplicates\")\n        }\n    }\n}\n\n\nThe above example creates a table with three columns. On macOS, these columns can be reordered or hidden and shown by the user of the app. Their configuration will be saved and restored with the window on relaunches of the app, using the \u201cBugReportTableConfig\u201d scene storage identifier.\n\nThe state of a specific column is stored relative to its customization identifier, using using the value from the customizationID(_:) modifier. When column customization is encoded and decoded, it relies on stable identifiers to restore the associate the saved state with a specific column. If a table column does not have a customization identifier, it will not be customizable.\n\nThese identifiers can also be used to programmatically change column customizations, such as programmatically hiding a column:\n\ncolumnCustomization[visibility: \"duplicates\"] = .hidden\n\n\nWith a binding to the overall customization, a binding to the visibility of a column can be accessed using the same subscript syntax:\n\nstruct BugReportTable: View {\n    @SceneStorage(\"BugReportTableConfig\")\n    private var columnCustomization: TableColumnCustomization<BugReport>\n\n\n    var body: some View {\n        ...\n        MyVisibilityView($columnCustomization[visibility: \"duplicates\"])\n    }\n}\n\n\nstruct MyVisibilityView: View {\n    @Binding var visibility: Visibility\n    ...\n}\n\nTopics\nCreating a table column customization\ninit()\nCreates an empty table column customization.\nManaging the customization\nfunc resetOrder()\nResets the column order back to the default, preserving the customized visibility and size.\nsubscript(visibility _: String) -> Visibility\nThe visibility of the column identified by its identifier.\nRelationships\nConforms To\nDecodable\nEncodable\nEquatable\nSendable\nSee Also\nCustomizing columns\nfunc tableColumnHeaders(Visibility) -> some View\nControls the visibility of a Table\u2019s column header views.\nstruct TableColumnCustomizationBehavior\nA set of customization behaviors of a column that a table can offer to a user."
    },
    {
        "title": "scenePadding(_:edges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scenepadding(_:edges:)",
        "html": "Parameters\npadding\n\nThe kind of padding to add.\n\nedges\n\nThe set of edges along which to pad this view.\n\nReturn Value\n\nA view that\u2019s padded on specified edges by a scene-appropriate amount.\n\nDiscussion\n\nUse this modifier to add a scene-appropriate amount of padding to a view. Specify either a single edge value from Edge.Set, or an OptionSet that describes the edges to pad.\n\nIn macOS, use scene padding to produce the recommended spacing around the root view of a window. In watchOS, use scene padding to align elements of your user interface with top level elements, like the title of a navigation view. For example, compare the effects of different kinds of padding on text views presented inside a NavigationView in watchOS:\n\nVStack(alignment: .leading, spacing: 10) {\n    Text(\"Minimum Scene padding\")\n        .scenePadding(.minimum, edges: .horizontal)\n        .border(.red) // Border added for reference.\n    Text(\"Navigation Bar Scene padding\")\n        .scenePadding(.navigationBar, edges: .horizontal)\n        .border(.yellow)\n    Text(\"Regular padding\")\n        .padding(.horizontal)\n        .border(.green)\n    Text(\"Text with no padding\")\n        .border(.blue)\n    Button(\"Button\") { }\n}\n.navigationTitle(\"Hello World\")\n\n\nThe text with minimum scene padding uses the system minimum padding and the text with navigation bar scene padding automatically aligns with the navigation bar content. In contrast, the text that uses the default padding and the text without padding do not align with scene elements.\n\nScene padding in watchOS also ensures that your content avoids the curved edges of a device like Apple Watch Series 7. In other platforms, scene padding produces the same default padding that you get from the padding(_:_:) modifier.\n\nImportant\n\nScene padding doesn\u2019t pad the top and bottom edges of a view in watchOS, even if you specify those edges as part of the input. For example, if you specify vertical instead of horizontal in the example above, the modifier would have no effect in watchOS. It does, however, apply to all the edges that you specify in other platforms.\n\nSee Also\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene."
    },
    {
        "title": "containerRelativeFrame(_:alignment:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/containerrelativeframe(_:alignment:_:)",
        "html": "Discussion\n\nUse the containerRelativeFrame(_:alignment:) modifier to specify a size for a view\u2019s width, height, or both that is dependent on the size of the nearest container. Different things can represent a \u201ccontainer\u201d including:\n\nThe window presenting a view on iPadOS or macOS, or the screen of a device on iOS.\n\nA column of a NavigationSplitView\n\nA NavigationStack\n\nA tab of a TabView\n\nA scrollable view like ScrollView or List\n\nThe size provided to this modifier is the size of a container like the ones listed above subtracting any safe area insets that might be applied to that container.\n\nThe following example will have each purple rectangle occupy the full size of the screen on iOS:\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 0.0) {\n        ForEach(items) { item in\n            Rectangle()\n                .fill(.purple)\n                .containerRelativeFrame([.horizontal, .vertical])\n        }\n    }\n}\n\n\nUse the View/containerRelativeFrame(_:count:spacing:alignment:) modifier to size a view such that multiple views will be visible in the container. When using this modifier, the count refers to the total number of rows or columns that the length of the container size in a particular axis should be divided into. The span refers to the number of rows or columns that the modified view should actually occupy. Thus the size of the element can be described like so:\n\nlet availableWidth = (containerWidth - (spacing * (count - 1)))\nlet columnWidth = (availableWidth / count)\nlet itemWidth = (columnWidth * span) + ((span - 1) * spacing)\n\n\nThe following example only uses the nearest container size in the horizontal axis, allowing the vertical axis to be determined using the aspectRatio(_:contentMode:) modifier.\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 10.0) {\n        ForEach(items) { item in\n            Rectangle()\n                .fill(.purple)\n                .aspectRatio(3.0 / 2.0, contentMode: .fit)\n                .containerRelativeFrame(\n                    .horizontal, count: 4, span: 3, spacing: 10.0)\n        }\n    }\n}\n.safeAreaPadding(.horizontal, 20.0)\n\n\nUse this modifier to apply your own custom logic to adjust the size of the nearest container for your view. The following example will result in the container frame\u2019s width being divided by 3 and using that value as the width of the purple rectangle.\n\nRectangle()\n    .fill(.purple)\n    .aspectRatio(1.0, contentMode: .fill)\n    .containerRelativeFrame(\n        .horizontal, alignment: .topLeading\n    ) { length, axis in\n        if axis == .vertical {\n            return length / 3.0\n        } else {\n            return length / 5.0\n        }\n    }\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "DisclosureTableRow",
        "url": "https://developer.apple.com/documentation/swiftui/disclosuretablerow",
        "html": "Overview\n\nA disclosure group row consists of a label row that is always visible, and some content rows that are conditionally visible depending on the state. Toggling the control will flip the state between \u201cexpanded\u201d and \u201ccollapsed\u201d.\n\nIn the following example, a disclosure group has allDevices as the label row, and exposes its expanded state with the bound property, expanded. Upon toggling the disclosure control, the user can update the expanded state which will in turn show or hide the three content rows for iPhone, iPad, and Mac.\n\nprivate struct DeviceStats: Identifiable {\n    // ...\n}\n@State private var expanded: Bool = true\n@State private var allDevices: DeviceStats = /* ... */\n@State private var iPhone: DeviceStats = /* ... */\n@State private var iPad: DeviceStats = /* ... */\n@State private var Mac: DeviceStats = /* ... */\n\n\nvar body: some View {\n    Table(of: DeviceStats.self) {\n        // ...\n    } rows: {\n        DisclosureTableRow(allDevices, isExpanded: $expanded) {\n            TableRow(iPhone)\n            TableRow(iPad)\n            TableRow(Mac)\n        }\n    }\n}\n\nTopics\nCreating a disclosure table row\ninit<Value>(Value, isExpanded: Binding<Bool>?, content: () -> Content)\nCreates a disclosure group with the given value and table rows, and a binding to the expansion state (expanded or collapsed).\nRelationships\nConforms To\nTableRowContent\nSee Also\nAdding progressive disclosure\nstruct TableOutlineGroupContent\nAn opaque table row type created by a table\u2019s hierarchical initializers."
    },
    {
        "title": "containerRelativeFrame(_:count:span:spacing:alignment:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/containerrelativeframe(_:count:span:spacing:alignment:)",
        "html": "Discussion\n\nUse the containerRelativeFrame(_:alignment:) modifier to specify a size for a view\u2019s width, height, or both that is dependent on the size of the nearest container. Different things can represent a \u201ccontainer\u201d including:\n\nThe window presenting a view on iPadOS or macOS, or the screen of a device on iOS.\n\nA column of a NavigationSplitView\n\nA NavigationStack\n\nA tab of a TabView\n\nA scrollable view like ScrollView or List\n\nThe size provided to this modifier is the size of a container like the ones listed above subtracting any safe area insets that might be applied to that container.\n\nThe following example will have each purple rectangle occupy the full size of the screen on iOS:\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 0.0) {\n        ForEach(items) { item in\n            Rectangle()\n                .fill(.purple)\n                .containerRelativeFrame([.horizontal, .vertical])\n        }\n    }\n}\n\n\nUse this modifier to size a view such that multiple views will be visible in the container. When using this modifier, the count refers to the total number of rows or columns that the length of the container size in a particular axis should be divided into. The span refers to the number of rows or columns that the modified view should actually occupy. Thus the size of the element can be described like so:\n\nlet availableWidth = (containerWidth - (spacing * (count - 1)))\nlet columnWidth = (availableWidth / count)\nlet itemWidth = (columnWidth * span) + ((span - 1) * spacing)\n\n\nThe following example only uses the nearest container size in the horizontal axis, allowing the vertical axis to be determined using the aspectRatio(_:contentMode:) modifier.\n\nScrollView(.horizontal) {\n    LazyHStack(spacing: 10.0) {\n        ForEach(items) { item in\n            Rectangle()\n                .fill(.purple)\n                .aspectRatio(3.0 / 2.0, contentMode: .fit)\n                .containerRelativeFrame(\n                    .horizontal, count: 4, span: 3, spacing: 10.0)\n        }\n    }\n}\n.safeAreaPadding(.horizontal, 20.0)\n\n\nUse the containerRelativeFrame(_:alignment:_:) modifier to apply your own custom logic to adjust the size of the nearest container for your view. The following example will result in the container frame\u2019s width being divided by 3 and using that value as the width of the purple rectangle.\n\nRectangle()\n    .fill(.purple)\n    .aspectRatio(1.0, contentMode: .fill)\n    .containerRelativeFrame(\n        .horizontal, alignment: .topLeading\n    ) { length, axis in\n        if axis == .vertical {\n            return length / 3.0\n        } else {\n            return length / 5.0\n        }\n    }\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "EdgeInsets3D",
        "url": "https://developer.apple.com/documentation/swiftui/edgeinsets3d",
        "html": "Topics\nGetting edge insets\nvar top: CGFloat\nThe inset distance along the top face of a 3D volume.\nvar bottom: CGFloat\nThe inset distance along the bottom face of a 3D volume.\nvar leading: CGFloat\nThe inset distance along the leading face of a 3D volume.\nvar trailing: CGFloat\nThe inset distance along the top trailing of a 3D volume.\nvar front: CGFloat\nThe inset distance along the top front of a 3D volume.\nvar back: CGFloat\nThe inset distance along the top back of a 3D volume.\nCreating an edge inset\ninit(horizontal: CGFloat, vertical: CGFloat, depth: CGFloat)\nCreates an EdgeInsets3D value with values provided for each axis.\ninit(top: CGFloat, leading: CGFloat, bottom: CGFloat, trailing: CGFloat, front: CGFloat, back: CGFloat)\nCreates an EdgeInsets3D value with values provided for each face.\nRelationships\nConforms To\nAnimatable\nEquatable\nSendable\nSee Also\nAccessing edges and regions\nenum Edge\nAn enumeration to indicate one edge of a rectangle.\nenum Edge3D\nAn edge or face of a 3D volume.\nBeta\nenum HorizontalEdge\nAn edge on the horizontal axis.\nenum VerticalEdge\nAn edge on the vertical axis.\nstruct EdgeInsets\nThe inset distances for the sides of a rectangle."
    },
    {
        "title": "pixelLength",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/pixellength",
        "html": "Discussion\n\nThis value is usually equal to 1 divided by displayScale.\n\nSee Also\nReacting to interface characteristics\nvar isLuminanceReduced: Bool\nA Boolean value that indicates whether the display or environment currently requires reduced luminance.\nvar displayScale: CGFloat\nThe display scale of this environment.\nvar horizontalSizeClass: UserInterfaceSizeClass?\nThe horizontal size class of this environment.\nvar verticalSizeClass: UserInterfaceSizeClass?\nThe vertical size class of this environment.\nenum UserInterfaceSizeClass\nA set of values that indicate the visual size available to the view."
    },
    {
        "title": "frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/frame(minwidth:idealwidth:maxwidth:minheight:idealheight:maxheight:alignment:)",
        "html": "Parameters\nminWidth\n\nThe minimum width of the resulting frame.\n\nidealWidth\n\nThe ideal width of the resulting frame.\n\nmaxWidth\n\nThe maximum width of the resulting frame.\n\nminHeight\n\nThe minimum height of the resulting frame.\n\nidealHeight\n\nThe ideal height of the resulting frame.\n\nmaxHeight\n\nThe maximum height of the resulting frame.\n\nalignment\n\nThe alignment of this view inside the resulting frame. Note that most alignment values have no apparent effect when the size of the frame happens to match that of this view.\n\nReturn Value\n\nA view with flexible dimensions given by the call\u2019s non-nil parameters.\n\nDiscussion\n\nAlways specify at least one size characteristic when calling this method. Pass nil or leave out a characteristic to indicate that the frame should adopt this view\u2019s sizing behavior, constrained by the other non-nil arguments.\n\nThe size proposed to this view is the size proposed to the frame, limited by any constraints specified, and with any ideal dimensions specified replacing any corresponding unspecified dimensions in the proposal.\n\nIf no minimum or maximum constraint is specified in a given dimension, the frame adopts the sizing behavior of its child in that dimension. If both constraints are specified in a dimension, the frame unconditionally adopts the size proposed for it, clamped to the constraints. Otherwise, the size of the frame in either dimension is:\n\nIf a minimum constraint is specified and the size proposed for the frame by the parent is less than the size of this view, the proposed size, clamped to that minimum.\n\nIf a maximum constraint is specified and the size proposed for the frame by the parent is greater than the size of this view, the proposed size, clamped to that maximum.\n\nOtherwise, the size of this view.\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "HorizontalEdge",
        "url": "https://developer.apple.com/documentation/swiftui/horizontaledge",
        "html": "Overview\n\nUse a horizontal edge for tasks like setting a swipe action with the swipeActions(edge:allowsFullSwipe:content:) view modifier. The positions of the leading and trailing edges depend on the locale chosen by the user.\n\nTopics\nGetting the edges\ncase leading\nThe leading edge.\ncase trailing\nThe trailing edge.\nAccessing sets of edges\nstruct Set\nAn efficient set of horizontal edges.\nRelationships\nConforms To\nCaseIterable\nDecodable\nEncodable\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nAccessing edges and regions\nenum Edge\nAn enumeration to indicate one edge of a rectangle.\nenum Edge3D\nAn edge or face of a 3D volume.\nBeta\nenum VerticalEdge\nAn edge on the vertical axis.\nstruct EdgeInsets\nThe inset distances for the sides of a rectangle.\nstruct EdgeInsets3D\nThe inset distances for the faces of a 3D volume.\nBeta"
    },
    {
        "title": "Edge",
        "url": "https://developer.apple.com/documentation/swiftui/edge",
        "html": "Topics\nGetting the edges\ncase top\ncase bottom\ncase leading\ncase trailing\nCreating an edge\ninit?(Edge3D)\nConverts a 3D edge to a 2D edge, if possible.\nBeta\nAccessing sets of edges\nstruct Set\nAn efficient set of edges.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nAccessing edges and regions\nenum Edge3D\nAn edge or face of a 3D volume.\nBeta\nenum HorizontalEdge\nAn edge on the horizontal axis.\nenum VerticalEdge\nAn edge on the vertical axis.\nstruct EdgeInsets\nThe inset distances for the sides of a rectangle.\nstruct EdgeInsets3D\nThe inset distances for the faces of a 3D volume.\nBeta"
    },
    {
        "title": "TableOutlineGroupContent",
        "url": "https://developer.apple.com/documentation/swiftui/tableoutlinegroupcontent",
        "html": "Overview\n\nThis row content is created by Table.init(_:,children:,...) initializers as the table\u2019s Rows generic type.\n\nTo explicitly create hierarchical rows, use OutlineGroup instead.\n\nRelationships\nConforms To\nTableRowContent\nSee Also\nAdding progressive disclosure\nstruct DisclosureTableRow\nA kind of table row that shows or hides additional rows based on the state of a disclosure control."
    },
    {
        "title": "UserInterfaceSizeClass",
        "url": "https://developer.apple.com/documentation/swiftui/userinterfacesizeclass",
        "html": "Overview\n\nYou receive a size class value when you read either the horizontalSizeClass or verticalSizeClass environment value. The value tells you about the amount of space available to your views in a given direction. You can read the size class like any other of the EnvironmentValues, by creating a property with the Environment property wrapper:\n\n@Environment(\\.horizontalSizeClass) private var horizontalSizeClass\n@Environment(\\.verticalSizeClass) private var verticalSizeClass\n\n\nSwiftUI sets the size class based on several factors, including:\n\nThe current device type.\n\nThe orientation of the device.\n\nThe appearance of Slide Over and Split View on iPad.\n\nSeveral built-in views change their behavior based on the size class. For example, a NavigationView presents a multicolumn view when the horizontal size class is UserInterfaceSizeClass.regular, but a single column otherwise. You can also adjust the appearance of custom views by reading the size class and conditioning your views. If you do, be prepared to handle size class changes while your app runs, because factors like device orientation can change at runtime.\n\nTopics\nGetting size classes\ncase compact\nThe compact size class.\ncase regular\nThe regular size class.\nCreating a size class\ninit?(UIUserInterfaceSizeClass)\nCreates a SwiftUI size class from the specified UIKit size class.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nReacting to interface characteristics\nvar isLuminanceReduced: Bool\nA Boolean value that indicates whether the display or environment currently requires reduced luminance.\nvar displayScale: CGFloat\nThe display scale of this environment.\nvar pixelLength: CGFloat\nThe size of a pixel on the screen.\nvar horizontalSizeClass: UserInterfaceSizeClass?\nThe horizontal size class of this environment.\nvar verticalSizeClass: UserInterfaceSizeClass?\nThe vertical size class of this environment."
    },
    {
        "title": "horizontalSizeClass",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/horizontalsizeclass",
        "html": "Discussion\n\nYou receive a UserInterfaceSizeClass value when you read this environment value. The value tells you about the amount of horizontal space available to the view that reads it. You can read this size class like any other of the EnvironmentValues, by creating a property with the Environment property wrapper:\n\n@Environment(\\.horizontalSizeClass) private var horizontalSizeClass\n\n\nSwiftUI sets this size class based on several factors, including:\n\nThe current device type.\n\nThe orientation of the device.\n\nThe appearance of Slide Over and Split View on iPad.\n\nSeveral built-in views change their behavior based on this size class. For example, a NavigationView presents a multicolumn view when the horizontal size class is UserInterfaceSizeClass.regular, but a single column otherwise. You can also adjust the appearance of custom views by reading the size class and conditioning your views. If you do, be prepared to handle size class changes while your app runs, because factors like device orientation can change at runtime.\n\nIn watchOS, the horizontal size class is always UserInterfaceSizeClass.compact. In macOS, and tvOS, it\u2019s always UserInterfaceSizeClass.regular.\n\nWriting to the horizontal size class in the environment before macOS 14.0, tvOS 17.0, and watchOS 10.0 is not supported.\n\nSee Also\nReacting to interface characteristics\nvar isLuminanceReduced: Bool\nA Boolean value that indicates whether the display or environment currently requires reduced luminance.\nvar displayScale: CGFloat\nThe display scale of this environment.\nvar pixelLength: CGFloat\nThe size of a pixel on the screen.\nvar verticalSizeClass: UserInterfaceSizeClass?\nThe vertical size class of this environment.\nenum UserInterfaceSizeClass\nA set of values that indicate the visual size available to the view."
    },
    {
        "title": "fixedSize(horizontal:vertical:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fixedsize(horizontal:vertical:)",
        "html": "Parameters\nhorizontal\n\nA Boolean value that indicates whether to fix the width of the view.\n\nvertical\n\nA Boolean value that indicates whether to fix the height of the view.\n\nReturn Value\n\nA view that fixes this view at its ideal size in the dimensions specified by horizontal and vertical.\n\nDiscussion\n\nThis function behaves like fixedSize(), except with fixedSize(horizontal:vertical:) the fixing of the axes can be optionally specified in one or both dimensions. For example, if you horizontally fix a text view before wrapping it in the frame view, you\u2019re telling the text view to maintain its ideal width. The view calculates this to be the space needed to represent the entire string.\n\nText(\"A single line of text, too long to fit in a box.\")\n    .fixedSize(horizontal: true, vertical: false)\n    .frame(width: 200, height: 200)\n    .border(Color.gray)\n\n\nThis can result in the view exceeding the parent\u2019s bounds, which may or may not be the effect you want.\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "verticalSizeClass",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/verticalsizeclass",
        "html": "Discussion\n\nYou receive a UserInterfaceSizeClass value when you read this environment value. The value tells you about the amount of vertical space available to the view that reads it. You can read this size class like any other of the EnvironmentValues, by creating a property with the Environment property wrapper:\n\n@Environment(\\.verticalSizeClass) private var verticalSizeClass\n\n\nSwiftUI sets this size class based on several factors, including:\n\nThe current device type.\n\nThe orientation of the device.\n\nYou can adjust the appearance of custom views by reading this size class and conditioning your views. If you do, be prepared to handle size class changes while your app runs, because factors like device orientation can change at runtime.\n\nIn watchOS, the vertical size class is always UserInterfaceSizeClass.compact. In macOS, and tvOS, it\u2019s always UserInterfaceSizeClass.regular.\n\nWriting to the vertical size class in the environment before macOS 14.0, tvOS 17.0, and watchOS 10.0 is not supported.\n\nSee Also\nReacting to interface characteristics\nvar isLuminanceReduced: Bool\nA Boolean value that indicates whether the display or environment currently requires reduced luminance.\nvar displayScale: CGFloat\nThe display scale of this environment.\nvar pixelLength: CGFloat\nThe size of a pixel on the screen.\nvar horizontalSizeClass: UserInterfaceSizeClass?\nThe horizontal size class of this environment.\nenum UserInterfaceSizeClass\nA set of values that indicate the visual size available to the view."
    },
    {
        "title": "isLuminanceReduced",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/isluminancereduced",
        "html": "Discussion\n\nWhen you detect this condition, lower the overall brightness of your view. For example, you can change large, filled shapes to be stroked, and choose less bright colors:\n\n@Environment(\\.isLuminanceReduced) var isLuminanceReduced\n\n\nvar body: some View {\n    if isLuminanceReduced {\n        Circle()\n            .stroke(Color.gray, lineWidth: 10)\n    } else {\n        Circle()\n            .fill(Color.white)\n    }\n}\n\n\nIn addition to the changes that you make, the system could also dim the display to achieve a suitable brightness. By reacting to isLuminanceReduced, you can preserve contrast and readability while helping to satisfy the reduced brightness requirement.\n\nNote\n\nOn watchOS, the system typically sets this value to true when the user lowers their wrist, but the display remains on. Starting in watchOS 8, the system keeps your view visible on wrist down by default. If you want the system to blur the screen instead, as it did in earlier versions of watchOS, set the value for the WKSupportsAlwaysOnDisplay key in your app\u2019s Information Property List file to false.\n\nSee Also\nReacting to interface characteristics\nvar displayScale: CGFloat\nThe display scale of this environment.\nvar pixelLength: CGFloat\nThe size of a pixel on the screen.\nvar horizontalSizeClass: UserInterfaceSizeClass?\nThe horizontal size class of this environment.\nvar verticalSizeClass: UserInterfaceSizeClass?\nThe vertical size class of this environment.\nenum UserInterfaceSizeClass\nA set of values that indicate the visual size available to the view."
    },
    {
        "title": "displayScale",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/displayscale",
        "html": "See Also\nReacting to interface characteristics\nvar isLuminanceReduced: Bool\nA Boolean value that indicates whether the display or environment currently requires reduced luminance.\nvar pixelLength: CGFloat\nThe size of a pixel on the screen.\nvar horizontalSizeClass: UserInterfaceSizeClass?\nThe horizontal size class of this environment.\nvar verticalSizeClass: UserInterfaceSizeClass?\nThe vertical size class of this environment.\nenum UserInterfaceSizeClass\nA set of values that indicate the visual size available to the view."
    },
    {
        "title": "frame(minDepth:idealDepth:maxDepth:alignment:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/frame(mindepth:idealdepth:maxdepth:alignment:)",
        "html": "Parameters\nminDepth\n\nThe minimum depth of the resulting frame.\n\nidealDepth\n\nThe ideal depth of the resulting frame.\n\nmaxDepth\n\nThe maximum depth of the resulting frame.\n\nalignment\n\nThe alignment of this view inside the resulting frame. Note that most alignment values have no apparent effect when the size of the frame happens to match that of this view.\n\nReturn Value\n\nA view with flexible dimensions given by the call\u2019s non-nil parameters.\n\nDiscussion\n\nAlways specify at least one size characteristic when calling this method. Pass nil or leave out a characteristic to indicate that the frame should adopt this view\u2019s sizing behavior, constrained by the other non-nil arguments.\n\nThe size proposed to this view is the size proposed to the frame, limited by any constraints specified, and with an ideal dimension specified replacing any corresponding unspecified dimensions in the proposal.\n\nIf no minimum or maximum constraint is specified in a given dimension, the frame adopts the sizing behavior of its child in that dimension. If both constraints are specified in a dimension, the frame unconditionally adopts the size proposed for it, clamped to the constraints. Otherwise, the size of the frame in either dimension is:\n\nIf a minimum constraint is specified and the size proposed for the frame by the parent is less than the size of this view, the proposed size, clamped to that minimum.\n\nIf a maximum constraint is specified and the size proposed for the frame by the parent is greater than the size of this view, the proposed size, clamped to that maximum.\n\nOtherwise, the size of this view.\n\nSee Also\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child."
    },
    {
        "title": "Aligning views within a stack",
        "url": "https://developer.apple.com/documentation/swiftui/aligning-views-within-a-stack",
        "html": "Overview\n\nStacks place their child views to match their alignment, which defaults to center alignment. When you initialize the stack, you can specify an alignment for the stack to use that also applies to a stack\u2019s child views. If you want to modify the placement of individual child views, use the alignment guide modifier to make adjustments that offset the view from the alignment the stack provides.\n\nTo align views across multiple stacks, see Aligning views across stacks.\n\nUse defaults for basic alignment\n\nFor an example of how SwiftUI applies default alignment to the views in an HStack, examine the following code used to provide a status view for a recording app. The HStack contains an image view for the icon and two text views with labels that use the font(_:) modifier to adjust the font size of the text.\n\nHStack {\n    Image(\"microphone\")\n    Text(\"Connecting\")\n        .font(.caption)\n    Text(\"Bryan\")\n        .font(.title)\n}\n.padding()\n.border(Color.blue, width: 1)\n\n\nThe orange reference line in the following figure shows the default alignment position of the views within the stack. The line functions as a visual reference for the purposes of this article.\n\nCustomize stack alignment\n\nYou can align content within a stack based on guides provided by the alignments that the stack supports. The various kinds of stacks support the following alignments:\n\nHStack uses the guides defined in VerticalAlignment.\n\nVStack uses the guides defined in HorizontalAlignment.\n\nZStack uses the guides defined in Alignment, and a combination of HorizontalAlignment and VerticalAlignment.\n\nUse the alignment parameter when initializing a stack to define the alignment guide for the stack. The following example sets the alignment of the HStack to firstTextBaseline, which aligns its child views to the baseline of the first text view (which contains the string \u201cConnecting\u201d):\n\nHStack(alignment: .firstTextBaseline) {\n    Image(\"microphone\")\n    Text(\"Connecting\")\n        .font(.caption)\n    Text(\"Bryan\")\n        .font(.title)\n}\n.padding()\n.border(Color.blue, width: 1)\n\n\nAdjust the alignment of individual views within a stack\n\nCustom images don\u2019t provide a text baseline guide, so the bottom of the image aligns to the text view\u2019s baseline. Adjust the alignment of the image using alignmentGuide(_:computeValue:) to get the visual alignment you desire. The alignment guide\u2019s closure provides an instance of ViewDimensions, the parameter context in this example \u2014 which you can use to return an offset value. The value looked up from context with bottom, provides an offset that aligns the bottom of the image adjusted by an offset to the baseline guide defined on the stack:\n\nHStack(alignment: .firstTextBaseline) {\n    Image(\"microphone\")\n        .alignmentGuide(.firstTextBaseline) { context in\n            context[.bottom] - 0.12 * context.height\n        }\n    Text(\"Connecting\")\n        .font(.caption)\n    Text(\"Bryan\")\n        .font(.title)\n}\n.padding()\n.border(Color.blue, width: 1)\n\n\nWhen you use an alignment guide modifier, make sure to specify an active alignment of the stack. Otherwise, SwiftUI doesn\u2019t invoke the closure to offset the view. In the example above, the firstTextBaseline input to the alignment guide matches the stack\u2019s alignment, so the adjustment affects the placement of the image:\n\nUse SF Symbols to simplify views when aligning with text\n\nYou can replace the microphone image with a similar icon from SF Symbols to simplify the view. The icons from SF Symbols use text baseline guides, which means they support whatever font styling you apply to the view.\n\nHStack(alignment: .firstTextBaseline) {\n    Image(systemName: \"mic.circle\")\n        .font(.title)\n    Text(\"Connecting\")\n        .font(.caption)\n    Text(\"Bryan\")\n        .font(.title)\n}\n.padding()\n.border(Color.blue, width: 1)\n\n\nSee Also\nAligning views\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "position(x:y:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/position(x:y:)",
        "html": "Parameters\nx\n\nThe x-coordinate at which to place the center of this view.\n\ny\n\nThe y-coordinate at which to place the center of this view.\n\nReturn Value\n\nA view that fixes the center of this view at x and y.\n\nDiscussion\n\nUse the position(x:y:) modifier to place the center of a view at a specific coordinate in the parent view using an x and y offset.\n\nText(\"Position by passing the x and y coordinates\")\n    .position(x: 175, y: 100)\n    .border(Color.gray)\n\nSee Also\nAdjusting a view\u2019s position\nMaking fine adjustments to a view\u2019s position\nShift the position of a view by applying the offset or position modifier.\nfunc position(CGPoint) -> some View\nPositions the center of this view at the specified point in its parent\u2019s coordinate space.\nfunc offset(CGSize) -> some View\nOffset this view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(x: CGFloat, y: CGFloat) -> some View\nOffset this view by the specified horizontal and vertical distances.\nfunc offset(z: CGFloat) -> some View\nBrings a view forward in Z by the provided distance in points.\nBeta"
    },
    {
        "title": "alignmentGuide(_:computeValue:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alignmentguide(_:computevalue:)-9mdoh",
        "html": "Parameters\ng\n\nA HorizontalAlignment value at which to base the offset.\n\ncomputeValue\n\nA closure that returns the offset value to apply to this view.\n\nReturn Value\n\nA view modified with respect to its horizontal alignment according to the computation performed in the method\u2019s closure.\n\nDiscussion\n\nUse alignmentGuide(_:computeValue:) to calculate specific offsets to reposition views in relationship to one another. You can return a constant or can use the ViewDimensions argument to the closure to calculate a return value.\n\nIn the example below, the HStack is offset by a constant of 50 points to the right of center:\n\nVStack {\n    Text(\"Today's Weather\")\n        .font(.title)\n        .border(.gray)\n    HStack {\n        Text(\"\ud83c\udf27\")\n        Text(\"Rain & Thunderstorms\")\n        Text(\"\u26c8\")\n    }\n    .alignmentGuide(HorizontalAlignment.center) { _ in  50 }\n    .border(.gray)\n}\n.border(.gray)\n\n\nChanging the alignment of one view may have effects on surrounding views. Here the offset values inside a stack and its contained views is the difference of their absolute offsets.\n\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "VStackLayout",
        "url": "https://developer.apple.com/documentation/swiftui/vstacklayout",
        "html": "Overview\n\nThis layout container behaves like a VStack, but conforms to the Layout protocol so you can use it in the conditional layouts that you construct with AnyLayout. If you don\u2019t need a conditional layout, use VStack instead.\n\nTopics\nCreating a vertical stack\ninit(alignment: HorizontalAlignment, spacing: CGFloat?)\nCreates a vertical stack with the specified spacing and horizontal alignment.\nGetting the stack\u2019s properties\nvar alignment: HorizontalAlignment\nThe horizontal alignment of subviews.\nvar spacing: CGFloat?\nThe distance between adjacent subviews.\nRelationships\nConforms To\nAnimatable\nLayout\nSendable\nSee Also\nTransitioning between layout types\nstruct AnyLayout\nA type-erased instance of the layout protocol.\nstruct HStackLayout\nA horizontal container that you can use in conditional layouts.\nstruct ZStackLayout\nAn overlaying container that you can use in conditional layouts.\nstruct GridLayout\nA grid that you can use in conditional layouts."
    },
    {
        "title": "ZStackLayout",
        "url": "https://developer.apple.com/documentation/swiftui/zstacklayout",
        "html": "Overview\n\nThis layout container behaves like a ZStack, but conforms to the Layout protocol so you can use it in the conditional layouts that you construct with AnyLayout. If you don\u2019t need a conditional layout, use ZStack instead.\n\nTopics\nCreating a stack\ninit(alignment: Alignment)\nCreates a stack with the specified alignment.\nGetting the stack\u2019s properties\nvar alignment: Alignment\nThe alignment of subviews.\nRelationships\nConforms To\nAnimatable\nLayout\nSendable\nSee Also\nTransitioning between layout types\nstruct AnyLayout\nA type-erased instance of the layout protocol.\nstruct HStackLayout\nA horizontal container that you can use in conditional layouts.\nstruct VStackLayout\nA vertical container that you can use in conditional layouts.\nstruct GridLayout\nA grid that you can use in conditional layouts."
    },
    {
        "title": "GridLayout",
        "url": "https://developer.apple.com/documentation/swiftui/gridlayout",
        "html": "Overview\n\nThis layout container behaves like a Grid, but conforms to the Layout protocol so you can use it in the conditional layouts that you construct with AnyLayout. If you don\u2019t need a conditional layout, use Grid instead.\n\nTopics\nCreating a grid\ninit(alignment: Alignment, horizontalSpacing: CGFloat?, verticalSpacing: CGFloat?)\nCreates a grid with the specified spacing and alignment.\nGetting the grid\u2019s properties\nvar alignment: Alignment\nThe alignment of subviews.\nvar horizontalSpacing: CGFloat?\nThe horizontal distance between adjacent subviews.\nvar verticalSpacing: CGFloat?\nThe vertical distance between adjacent subviews.\nDefault Implementations\nLayout Implementations\nRelationships\nConforms To\nAnimatable\nLayout\nSendable\nSee Also\nTransitioning between layout types\nstruct AnyLayout\nA type-erased instance of the layout protocol.\nstruct HStackLayout\nA horizontal container that you can use in conditional layouts.\nstruct VStackLayout\nA vertical container that you can use in conditional layouts.\nstruct ZStackLayout\nAn overlaying container that you can use in conditional layouts."
    },
    {
        "title": "HStackLayout",
        "url": "https://developer.apple.com/documentation/swiftui/hstacklayout",
        "html": "Overview\n\nThis layout container behaves like an HStack, but conforms to the Layout protocol so you can use it in the conditional layouts that you construct with AnyLayout. If you don\u2019t need a conditional layout, use HStack instead.\n\nTopics\nCreating a horizontal stack\ninit(alignment: VerticalAlignment, spacing: CGFloat?)\nCreates a horizontal stack with the specified spacing and vertical alignment.\nGetting the stack\u2019s properties\nvar alignment: VerticalAlignment\nThe vertical alignment of subviews.\nvar spacing: CGFloat?\nThe distance between adjacent subviews.\nRelationships\nConforms To\nAnimatable\nLayout\nSendable\nSee Also\nTransitioning between layout types\nstruct AnyLayout\nA type-erased instance of the layout protocol.\nstruct VStackLayout\nA vertical container that you can use in conditional layouts.\nstruct ZStackLayout\nAn overlaying container that you can use in conditional layouts.\nstruct GridLayout\nA grid that you can use in conditional layouts."
    },
    {
        "title": "layoutValue(key:value:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/layoutvalue(key:value:)",
        "html": "Parameters\nkey\n\nThe type of the key that you want to set a value for. Create the key as a type that conforms to the LayoutValueKey protocol.\n\nvalue\n\nThe value to assign to the key for this view. The value must be of the type that you establish for the key\u2019s associated value when you implement the key\u2019s defaultValue property.\n\nReturn Value\n\nA view that has the specified value for the specified key.\n\nDiscussion\n\nUse this method to set a value for a custom property that you define with LayoutValueKey. For example, if you define a Flexibility key, you can set the key on a Text view using the key\u2019s type and a value:\n\nText(\"Another View\")\n    .layoutValue(key: Flexibility.self, value: 3)\n\n\nFor convenience, you might define a method that does this in an extension to View:\n\nextension View {\n    func layoutFlexibility(_ value: CGFloat?) -> some View {\n        layoutValue(key: Flexibility.self, value: value)\n    }\n}\n\n\nThis method makes the call site easier to read:\n\nText(\"Another View\")\n    .layoutFlexibility(3)\n\n\nIf you perform layout operations in a type that conforms to the Layout protocol, you can read the key\u2019s associated value for each subview of your custom layout type. Do this by indexing the subview\u2019s proxy with the key. For more information, see LayoutValueKey.\n\nSee Also\nAssociating values with views in a custom layout\nprotocol LayoutValueKey\nA key for accessing a layout value of a layout container\u2019s subviews."
    },
    {
        "title": "LayoutValueKey",
        "url": "https://developer.apple.com/documentation/swiftui/layoutvaluekey",
        "html": "Overview\n\nIf you create a custom layout by defining a type that conforms to the Layout protocol, you can also create custom layout values that you set on individual views, and that your container view can access to guide its layout behavior. Your custom values resemble the built-in layout values that you set with view modifiers like layoutPriority(_:) and zIndex(_:), but have a purpose that you define.\n\nTo create a custom layout value, define a type that conforms to the LayoutValueKey protocol and implement the one required property that returns the default value of the property. For example, you can create a property that defines an amount of flexibility for a view, defined as an optional floating point number with a default value of nil:\n\nprivate struct Flexibility: LayoutValueKey {\n    static let defaultValue: CGFloat? = nil\n}\n\n\nThe Swift compiler infers this particular key\u2019s associated type as an optional CGFloat from this definition.\n\nSet a value on a view\n\nSet the value on a view by adding the layoutValue(key:value:) view modifier to the view. To make your custom value easier to work with, you can do this in a convenience modifier in an extension of the View protocol:\n\nextension View {\n    func layoutFlexibility(_ value: CGFloat?) -> some View {\n        layoutValue(key: Flexibility.self, value: value)\n    }\n}\n\n\nUse your modifier to set the value on any views that need a nondefault value:\n\nBasicVStack {\n    Text(\"One View\")\n    Text(\"Another View\")\n        .layoutFlexibility(3)\n}\n\n\nAny view that you don\u2019t explicitly set a value for uses the default value, as with the first Text view, above.\n\nRetrieve a value during layout\n\nAccess a custom layout value using the key as an index on subview\u2019s proxy (an instance of LayoutSubview) and use the value to make decisions about sizing, placement, or other layout operations. For example, you might read the flexibility value in your layout view\u2019s sizeThatFits(_:) method, and adjust your size calculations accordingly:\n\nextension BasicVStack {\n    func sizeThatFits(\n        proposal: ProposedViewSize,\n        subviews: Subviews,\n        cache: inout Void\n    ) -> CGSize {\n\n\n        // Map the flexibility property of each subview into an array.\n        let flexibilities = subviews.map { subview in\n            subview[Flexibility.self]\n        }\n\n\n        // Calculate and return the size of the layout container.\n        // ...\n    }\n}\n\nTopics\nProviding a default value\nstatic var defaultValue: Self.Value\nThe default value of the key.\n\nRequired\n\nassociatedtype Value\nThe type of the key\u2019s value.\n\nRequired\n\nSee Also\nAssociating values with views in a custom layout\nfunc layoutValue<K>(key: K.Type, value: K.Value) -> some View\nAssociates a value with a custom layout property."
    },
    {
        "title": "scaledToFit()",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaledtofit()",
        "html": "Return Value\n\nA view that scales this view to fit its parent, maintaining this view\u2019s aspect ratio.\n\nDiscussion\n\nUse scaledToFit() to scale this view to fit its parent, while maintaining the view\u2019s aspect ratio as the view scales.\n\nCircle()\n    .fill(Color.pink)\n    .scaledToFit()\n    .frame(width: 300, height: 150)\n    .border(Color(white: 0.75))\n\n\nThis method is equivalent to calling aspectRatio(_:contentMode:) with a nil aspectRatio and a content mode of ContentMode.fit.\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "AnyLayout",
        "url": "https://developer.apple.com/documentation/swiftui/anylayout",
        "html": "Overview\n\nUse an AnyLayout instance to enable dynamically changing the type of a layout container without destroying the state of the subviews. For example, you can create a layout that changes between horizontal and vertical layouts based on the current Dynamic Type setting:\n\nstruct DynamicLayoutExample: View {\n    @Environment(\\.dynamicTypeSize) var dynamicTypeSize\n\n\n    var body: some View {\n        let layout = dynamicTypeSize <= .medium ?\n            AnyLayout(HStackLayout()) : AnyLayout(VStackLayout())\n\n\n        layout {\n            Text(\"First label\")\n            Text(\"Second label\")\n        }\n    }\n}\n\n\nThe types that you use with AnyLayout must conform to the Layout protocol. The above example chooses between the HStackLayout and VStackLayout types, which are versions of the built-in HStack and VStack containers that conform to the protocol. You can also use custom layout types that you define.\n\nTopics\nCreating the layout\ninit<L>(L)\nCreates a type-erased value that wraps the specified layout.\nRelationships\nConforms To\nAnimatable\nLayout\nSee Also\nTransitioning between layout types\nstruct HStackLayout\nA horizontal container that you can use in conditional layouts.\nstruct VStackLayout\nA vertical container that you can use in conditional layouts.\nstruct ZStackLayout\nAn overlaying container that you can use in conditional layouts.\nstruct GridLayout\nA grid that you can use in conditional layouts."
    },
    {
        "title": "safeAreaPadding(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/safeareapadding(_:)-6nbmg",
        "html": "Discussion\n\nUse this modifier when you would like to add a fixed amount of space to the safe area a view sees.\n\nScrollView(.horizontal) {\n    HStack(spacing: 10.0) {\n        ForEach(items) { item in\n            ItemView(item)\n        }\n    }\n}\n.safeAreaPadding(.horizontal, 20.0)\n\n\nSee the View/safeAreaInset(edge:alignment:spacing:content) modifier for adding to the safe area based on the size of a view.\n\nSee Also\nStaying in the safe areas\nfunc ignoresSafeArea(SafeAreaRegions, edges: Edge.Set) -> some View\nExpands the view out of its safe area.\nfunc safeAreaInset<V>(edge: HorizontalEdge, alignment: VerticalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content beside the modified view.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(EdgeInsets) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> some View\nAdds the provided insets into the safe area of this view.\nstruct SafeAreaRegions\nA set of symbolic safe area regions."
    },
    {
        "title": "ProposedViewSize",
        "url": "https://developer.apple.com/documentation/swiftui/proposedviewsize",
        "html": "Overview\n\nDuring layout in SwiftUI, views choose their own size, but they do that in response to a size proposal from their parent view. When you create a custom layout using the Layout protocol, your layout container participates in this process using ProposedViewSize instances. The layout protocol\u2019s methods take a proposed size input that you can take into account when arranging views and calculating the size of the composite container. Similarly, your layout proposes a size to each of its own subviews when it measures and places them.\n\nLayout containers typically measure their subviews by proposing several sizes and looking at the responses. The container can use this information to decide how to allocate space among its subviews. A layout might try the following special proposals:\n\nThe zero proposal; the view responds with its minimum size.\n\nThe infinity proposal; the view responds with its maximum size.\n\nThe unspecified proposal; the view responds with its ideal size.\n\nA layout might also try special cases for one dimension at a time. For example, an HStack might measure the flexibility of its subviews\u2019 widths, while using a fixed value for the height.\n\nTopics\nGetting standard proposals\nstatic let zero: ProposedViewSize\nA size proposal that contains zero in both dimensions.\nstatic let infinity: ProposedViewSize\nA size proposal that contains infinity in both dimensions.\nstatic let unspecified: ProposedViewSize\nThe proposed size with both dimensions left unspecified.\nCreating a custom size proposal\ninit(CGSize)\nCreates a new proposed size from a specified size.\ninit(width: CGFloat?, height: CGFloat?)\nCreates a new proposed size using the specified width and height.\nGetting the proposal\u2019s dimensions\nvar height: CGFloat?\nThe proposed vertical size measured in points.\nvar width: CGFloat?\nThe proposed horizontal size measured in points.\nModifying a proposal\nfunc replacingUnspecifiedDimensions(by: CGSize) -> CGSize\nCreates a new proposal that replaces unspecified dimensions in this proposal with the corresponding dimension of the specified size.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nConfiguring a custom layout\nstruct LayoutProperties\nLayout-specific properties of a layout container.\nstruct ViewSpacing\nA collection of the geometric spacing preferences of a view."
    },
    {
        "title": "DepthAlignment",
        "url": "https://developer.apple.com/documentation/swiftui/depthalignment",
        "html": "Topics\nGetting guides\nstatic let back: DepthAlignment\nA guide marking the bottom edge of the view.\nstatic let center: DepthAlignment\nA guide marking the vertical center of the view.\nstatic let front: DepthAlignment\nA guide marking the top edge of the view.\nRelationships\nConforms To\nEquatable\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "layerEffect(_:maxSampleOffset:isEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/layereffect(_:maxsampleoffset:isenabled:)",
        "html": "Parameters\nshader\n\nThe shader to apply as a layer effect.\n\nmaxSampleOffset\n\nIf the shader function samples from the layer at locations not equal to the destination position, this value must specify the maximum sampling distance in each axis, for all source pixels.\n\nisEnabled\n\nWhether the effect is enabled or not.\n\nReturn Value\n\nA new view that renders self with the shader applied as a distortion effect.\n\nDiscussion\n\nFor a shader function to act as a layer effect it must have a function signature matching:\n\n[[ stitchable ]] half4 name(float2 position,\n  SwiftUI::Layer layer, args...)\n\n\nwhere position is the user-space coordinates of the destination pixel applied to the shader, and layer is a subregion of the rasterized contents of self. args... should be compatible with the uniform arguments bound to shader.\n\nThe SwiftUI::Layer type is defined in the <SwiftUI/SwiftUI.h> header file. It exports a single sample() function that returns a linearly-filtered pixel value from a position in the source content, as a premultiplied RGBA pixel value:\n\nnamespace SwiftUI {\n  struct Layer {\n    half4 sample(float2 position) const;\n  };\n};\n\n\nThe function should return the color mapping to the destination pixel, typically by sampling one or more pixels from layer at location(s) derived from position and them applying some kind of transformation to produce a new color.\n\nImportant\n\nViews backed by AppKit or UIKit views may not render into the filtered layer. Instead, they log a warning and display a placeholder image to highlight the error.\n\nSee Also\nAccessing Metal shaders\nfunc colorEffect(Shader, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter effect on the color of each pixel.\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a geometric distortion effect on the location of each pixel.\nstruct Shader\nA reference to a function in a Metal shader library, along with its bound uniform argument values.\nstruct ShaderFunction\nA reference to a function in a Metal shader library.\nstruct ShaderLibrary\nA Metal shader library."
    },
    {
        "title": "ContentMarginPlacement",
        "url": "https://developer.apple.com/documentation/swiftui/contentmarginplacement",
        "html": "Overview\n\nDifferent views can support customizating margins that appear in different parts of that view. Use values of this type to customize those margins of a particular placement.\n\nFor example, use a scrollIndicators placement to customize the margins of scrollable view\u2019s scroll indicators separately from the margins of a scrollable view\u2019s content.\n\nUse this type with the contentMargins(_:for:) modifier.\n\nTopics\nGetting the placement\nstatic var automatic: ContentMarginPlacement\nThe automatic placement.\nstatic var scrollContent: ContentMarginPlacement\nThe scroll content placement.\nstatic var scrollIndicators: ContentMarginPlacement\nThe scroll indicators placement.\nSee Also\nSetting margins\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement."
    },
    {
        "title": "ViewSpacing",
        "url": "https://developer.apple.com/documentation/swiftui/viewspacing",
        "html": "Overview\n\nThis type represents how much space a view prefers to have between it and the next view in a layout. The type stores independent values for each of the top, bottom, leading, and trailing edges, and can also record different values for different kinds of adjacent views. For example, it might contain one value for the spacing to the next text view along the top and bottom edges, other values for the spacing to text views on other edges, and yet other values for other kinds of views. Spacing preferences can also vary by platform.\n\nYour Layout type doesn\u2019t have to take preferred spacing into account, but if it does, you can use the spacing preferences of the subviews in your layout container to:\n\nAdd space between subviews when you implement the placeSubviews(in:proposal:subviews:cache:) method.\n\nCreate a spacing preferences instance for the container view by implementing the spacing(subviews:cache:) method.\n\nTopics\nCreating spacing instances\ninit()\nInitializes an instance with default spacing values.\nstatic let zero: ViewSpacing\nA view spacing instance that contains zero on all edges.\nMeasuring spacing distance\nfunc distance(to: ViewSpacing, along: Axis) -> CGFloat\nGets the preferred spacing distance along the specified axis to the view that returns a specified spacing preference.\nMerging spacing instances\nfunc formUnion(ViewSpacing, edges: Edge.Set)\nMerges the spacing preferences of another spacing instance with this instance for a specified set of edges.\nfunc union(ViewSpacing, edges: Edge.Set) -> ViewSpacing\nGets a new value that merges the spacing preferences of another spacing instance with this instance for a specified set of edges.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring a custom layout\nstruct LayoutProperties\nLayout-specific properties of a layout container.\nstruct ProposedViewSize\nA proposal for the size of a view."
    },
    {
        "title": "Layout",
        "url": "https://developer.apple.com/documentation/swiftui/layout",
        "html": "Overview\n\nYou traditionally arrange views in your app\u2019s user interface using built-in layout containers like HStack and Grid. If you need more complex layout behavior, you can define a custom layout container by creating a type that conforms to the Layout protocol and implementing its required methods:\n\nsizeThatFits(proposal:subviews:cache:) reports the size of the composite layout view.\n\nplaceSubviews(in:proposal:subviews:cache:) assigns positions to the container\u2019s subviews.\n\nYou can define a basic layout type with only these two methods:\n\nstruct BasicVStack: Layout {\n    func sizeThatFits(\n        proposal: ProposedViewSize,\n        subviews: Subviews,\n        cache: inout ()\n    ) -> CGSize {\n        // Calculate and return the size of the layout container.\n    }\n\n\n    func placeSubviews(\n        in bounds: CGRect,\n        proposal: ProposedViewSize,\n        subviews: Subviews,\n        cache: inout ()\n    ) {\n        // Tell each subview where to appear.\n    }\n}\n\n\nUse your layout the same way you use a built-in layout container, by providing a ViewBuilder with the list of subviews to arrange:\n\nBasicVStack {\n    Text(\"A Subview\")\n    Text(\"Another Subview\")\n}\n\nSupport additional behaviors\n\nYou can optionally implement other protocol methods and properties to provide more layout container features:\n\nDefine explicit horizontal and vertical layout guides for the container by implementing explicitAlignment(of:in:proposal:subviews:cache:) and explicitAlignment(of:in:proposal:subviews:cache:), respectively.\n\nEstablish the preferred spacing around the container by implementing spacing(subviews:cache:).\n\nIndicate the axis of orientation for a container that has characteristics of a stack by implementing the layoutProperties static property.\n\nCreate and manage a cache to store computed values across different layout protocol calls by implementing makeCache(subviews:).\n\nThe protocol provides default implementations for these symbols if you don\u2019t implement them. See each method or property for details.\n\nAdd input parameters\n\nYou can define parameters as inputs to the layout, like you might for a View:\n\nstruct BasicVStack: Layout {\n    var alignment: HorizontalAlignment\n\n\n    // ...\n}\n\n\nSet the parameters at the point where you instantiate the layout:\n\nBasicVStack(alignment: .leading) {\n    // ...\n}\n\n\nIf the layout provides default values for its parameters, you can omit the parameters at the call site, but you might need to keep the parentheses after the name of the layout, depending on how you specify the defaults. For example, suppose you set a default alignment for the basic stack in the parameter declaration:\n\nstruct BasicVStack: Layout {\n    var alignment: HorizontalAlignment = .center\n\n\n    // ...\n}\n\n\nTo instantiate this layout using the default center alignment, you don\u2019t have to specify the alignment value, but you do need to add empty parentheses:\n\nBasicVStack() {\n    // ...\n}\n\n\nThe Swift compiler requires the parentheses in this case because of how the layout protocol implements this call site syntax. Specifically, the layout\u2019s callAsFunction(_:) method looks for an initializer with exactly zero input arguments when you omit the parentheses from the call site. You can enable the simpler call site for a layout that doesn\u2019t have an implicit initializer of this type by explicitly defining one:\n\ninit() {\n    self.alignment = .center\n}\n\n\nFor information about Swift initializers, see Initialization in The Swift Programming Language.\n\nInteract with subviews through their proxies\n\nTo perform layout, you need information about all of its subviews, which are the views that your container arranges. While your layout can\u2019t interact directly with its subviews, it can access a set of subview proxies through the Layout.Subviews collection that each protocol method receives as an input parameter. That type is an alias for the LayoutSubviews collection type, which in turn contains LayoutSubview instances that are the subview proxies.\n\nYou can get information about each subview from its proxy, like its dimensions and spacing preferences. This enables you to measure subviews before you commit to placing them. You also assign a position to each subview by calling its proxy\u2019s place(at:anchor:proposal:) method. Call the method on each subview from within your implementation of the layout\u2019s placeSubviews(in:proposal:subviews:cache:) method.\n\nAccess layout values\n\nViews have layout values that you set with view modifiers. Layout containers can choose to condition their behavior accordingly. For example, a built-in HStack allocates space to its subviews based in part on the priorities that you set with the layoutPriority(_:) view modifier. Your layout container accesses this value for a subview by reading the proxy\u2019s priority property.\n\nYou can also create custom layout values by creating a layout key. Set a value on a view with the layoutValue(key:value:) view modifier. Read the corresponding value from the subview\u2019s proxy using the key as an index on the subview. For more information about creating, setting, and accessing custom layout values, see LayoutValueKey.\n\nTopics\nSizing the container and placing subviews\nfunc sizeThatFits(proposal: ProposedViewSize, subviews: Self.Subviews, cache: inout Self.Cache) -> CGSize\nReturns the size of the composite view, given a proposed size and the view\u2019s subviews.\n\nRequired\n\nfunc placeSubviews(in: CGRect, proposal: ProposedViewSize, subviews: Self.Subviews, cache: inout Self.Cache)\nAssigns positions to each of the layout\u2019s subviews.\n\nRequired\n\ntypealias Subviews\nA collection of proxies for the subviews of a layout view.\nReporting layout container characteristics\nfunc explicitAlignment(of: HorizontalAlignment, in: CGRect, proposal: ProposedViewSize, subviews: Self.Subviews, cache: inout Self.Cache) -> CGFloat?\nReturns the position of the specified horizontal alignment guide along the x axis.\n\nRequired Default implementations provided.\n\nfunc explicitAlignment(of: VerticalAlignment, in: CGRect, proposal: ProposedViewSize, subviews: Self.Subviews, cache: inout Self.Cache) -> CGFloat?\nReturns the position of the specified vertical alignment guide along the y axis.\n\nRequired Default implementations provided.\n\nfunc spacing(subviews: Self.Subviews, cache: inout Self.Cache) -> ViewSpacing\nReturns the preferred spacing values of the composite view.\n\nRequired Default implementation provided.\n\nstatic var layoutProperties: LayoutProperties\nProperties of a layout container.\n\nRequired Default implementation provided.\n\nManaging a cache\nfunc makeCache(subviews: Self.Subviews) -> Self.Cache\nCreates and initializes a cache for a layout instance.\n\nRequired Default implementation provided.\n\nfunc updateCache(inout Self.Cache, subviews: Self.Subviews)\nUpdates the layout\u2019s cache when something changes.\n\nRequired Default implementation provided.\n\nassociatedtype Cache = Void\nCached values associated with the layout instance.\n\nRequired\n\nSupporting types\nfunc callAsFunction<V>(() -> V) -> some View\nCombines the specified views into a single composite view using the layout algorithms of the custom layout container.\nRelationships\nInherits From\nAnimatable\nConforming Types\nAnyLayout\nGridLayout\nHStackLayout\nVStackLayout\nZStackLayout\nSee Also\nCreating a custom layout container\nstruct LayoutSubview\nA proxy that represents one subview of a layout.\nstruct LayoutSubviews\nA collection of proxy values that represent the subviews of a layout view."
    },
    {
        "title": "safeAreaPadding(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/safeareapadding(_:)-5lh9p",
        "html": "Discussion\n\nUse this modifier when you would like to add a fixed amount of space to the safe area a view sees.\n\nScrollView(.horizontal) {\n    HStack(spacing: 10.0) {\n        ForEach(items) { item in\n            ItemView(item)\n        }\n    }\n}\n.safeAreaPadding(.horizontal, 20.0)\n\n\nSee the View/safeAreaInset(edge:alignment:spacing:content) modifier for adding to the safe area based on the size of a view.\n\nSee Also\nStaying in the safe areas\nfunc ignoresSafeArea(SafeAreaRegions, edges: Edge.Set) -> some View\nExpands the view out of its safe area.\nfunc safeAreaInset<V>(edge: HorizontalEdge, alignment: VerticalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content beside the modified view.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(CGFloat) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> some View\nAdds the provided insets into the safe area of this view.\nstruct SafeAreaRegions\nA set of symbolic safe area regions."
    },
    {
        "title": "LayoutSubviews",
        "url": "https://developer.apple.com/documentation/swiftui/layoutsubviews",
        "html": "Overview\n\nYou receive a LayoutSubviews input to your implementations of Layout protocol methods, like placeSubviews(in:proposal:subviews:cache:) and sizeThatFits(proposal:subviews:cache:). The subviews parameter (which the protocol aliases to the Layout.Subviews type) is a collection that contains proxies for the layout\u2019s subviews (of type LayoutSubview). The proxies appear in the collection in the same order that they appear in the ViewBuilder input to the layout container. Use the proxies to perform layout operations.\n\nAccess the proxies in the collection as you would the contents of any Swift random-access collection. For example, you can enumerate all of the subviews and their indices to inspect or operate on them:\n\nfor (index, subview) in subviews.enumerated() {\n    // ...\n}\n\nTopics\nGetting the layout direction\nvar layoutDirection: LayoutDirection\nThe layout direction inherited by the container view.\nAccessing subviews\nsubscript(Int) -> LayoutSubviews.Element\nGets the subview proxy at a specified index.\nsubscript<S>(S) -> LayoutSubviews\nGets the subview proxies with the specified indicies.\nsubscript(Range<Int>) -> LayoutSubviews\nGets the subview proxies in the specified range.\nvar startIndex: Int\nThe index of the first subview.\nvar endIndex: Int\nAn index that\u2019s one higher than the last subview.\ntypealias Element\nA type that contains a proxy value.\ntypealias Index\nA type that you can use to index proxy values.\ntypealias SubSequence\nA type that contains a subsequence of proxy values.\nRelationships\nConforms To\nBidirectionalCollection\nCollection\nEquatable\nRandomAccessCollection\nSendable\nSequence\nSee Also\nCreating a custom layout container\nprotocol Layout\nA type that defines the geometry of a collection of views.\nstruct LayoutSubview\nA proxy that represents one subview of a layout."
    },
    {
        "title": "SafeAreaRegions",
        "url": "https://developer.apple.com/documentation/swiftui/safearearegions",
        "html": "Topics\nGetting safe area regions\nstatic let all: SafeAreaRegions\nAll safe area regions.\nstatic let container: SafeAreaRegions\nThe safe area defined by the device and containers within the user interface, including elements such as top and bottom bars.\nstatic let keyboard: SafeAreaRegions\nThe safe area matching the current extent of any software keyboard displayed over the view content.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nStaying in the safe areas\nfunc ignoresSafeArea(SafeAreaRegions, edges: Edge.Set) -> some View\nExpands the view out of its safe area.\nfunc safeAreaInset<V>(edge: HorizontalEdge, alignment: VerticalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content beside the modified view.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(EdgeInsets) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(CGFloat) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> some View\nAdds the provided insets into the safe area of this view."
    },
    {
        "title": "safeAreaInset(edge:alignment:spacing:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/safeareainset(edge:alignment:spacing:content:)-6gwby",
        "html": "Parameters\nedge\n\nThe horizontal edge of the view to inset by the width of content, to make space for content.\n\nspacing\n\nExtra distance placed between the two views, or nil to use the default amount of spacing.\n\nalignment\n\nThe alignment guide used to position content vertically.\n\ncontent\n\nA view builder function providing the view to display in the inset space of the modified view.\n\nReturn Value\n\nA new view that displays content beside the modified view, making space for the content view by horizontally insetting the modified view.\n\nDiscussion\n\nThe content view is anchored to the specified horizontal edge in the parent view, aligning its vertical axis to the specified alignment guide. The modified view is inset by the width of content, from edge, with its safe area increased by the same amount.\n\nstruct ScrollableViewWithSideBar: View {\n    var body: some View {\n        ScrollView {\n            ScrolledContent()\n        }\n        .safeAreaInset(edge: .leading, spacing: 0) {\n            SideBarContent()\n        }\n    }\n}\n\nSee Also\nStaying in the safe areas\nfunc ignoresSafeArea(SafeAreaRegions, edges: Edge.Set) -> some View\nExpands the view out of its safe area.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(EdgeInsets) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(CGFloat) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> some View\nAdds the provided insets into the safe area of this view.\nstruct SafeAreaRegions\nA set of symbolic safe area regions."
    },
    {
        "title": "layoutDirectionBehavior(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/layoutdirectionbehavior(_:)",
        "html": "Parameters\nbehavior\n\nA LayoutDirectionBehavior value that indicates whether this view should mirror in a particular layout direction. By default, views will adjust their layouts automatically in a right-to-left context and do not need to be mirrored.\n\nReturn Value\n\nA view that conditionally mirrors its contents horizontally in a given layout direction.\n\nDiscussion\n\nUse layoutDirectionBehavior(_:) when you need the system to horizontally mirror the contents of the view when presented in a layout direction.\n\nTo override the layout direction for a specific view, use the environment(_:_:) view modifier to explicitly override the layoutDirection environment value for the view.\n\nSee Also\nSetting a layout direction\nenum LayoutDirectionBehavior\nA description of what should happen when the layout direction changes.\nvar layoutDirection: LayoutDirection\nThe layout direction associated with the current environment.\nenum LayoutDirection\nA direction in which SwiftUI can lay out content."
    },
    {
        "title": "safeAreaPadding(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/safeareapadding(_:_:)",
        "html": "Discussion\n\nUse this modifier when you would like to add a fixed amount of space to the safe area a view sees.\n\nScrollView(.horizontal) {\n    HStack(spacing: 10.0) {\n        ForEach(items) { item in\n            ItemView(item)\n        }\n    }\n}\n.safeAreaPadding(.horizontal, 20.0)\n\n\nSee the View/safeAreaInset(edge:alignment:spacing:content) modifier for adding to the safe area based on the size of a view.\n\nSee Also\nStaying in the safe areas\nfunc ignoresSafeArea(SafeAreaRegions, edges: Edge.Set) -> some View\nExpands the view out of its safe area.\nfunc safeAreaInset<V>(edge: HorizontalEdge, alignment: VerticalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content beside the modified view.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(EdgeInsets) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(CGFloat) -> some View\nAdds the provided insets into the safe area of this view.\nstruct SafeAreaRegions\nA set of symbolic safe area regions."
    },
    {
        "title": "Spacer",
        "url": "https://developer.apple.com/documentation/swiftui/spacer",
        "html": "Overview\n\nA spacer creates an adaptive view with no content that expands as much as it can. For example, when placed within an HStack, a spacer expands horizontally as much as the stack allows, moving sibling views out of the way, within the limits of the stack\u2019s size. SwiftUI sizes a stack that doesn\u2019t contain a spacer up to the combined ideal widths of the content of the stack\u2019s child views.\n\nThe following example provides a simple checklist row to illustrate how you can use a spacer:\n\nstruct ChecklistRow: View {\n    let name: String\n\n\n    var body: some View {\n        HStack {\n            Image(systemName: \"checkmark\")\n            Text(name)\n        }\n        .border(Color.blue)\n    }\n}\n\n\nAdding a spacer before the image creates an adaptive view with no content that expands to push the image and text to the right side of the stack. The stack also now expands to take as much space as the parent view allows, shown by the blue border that indicates the boundary of the stack:\n\nstruct ChecklistRow: View {\n    let name: String\n\n\n    var body: some View {\n        HStack {\n            Spacer()\n            Image(systemName: \"checkmark\")\n            Text(name)\n        }\n        .border(Color.blue)\n    }\n}\n\n\nMoving the spacer between the image and the name pushes those elements to the left and right sides of the HStack, respectively. Because the stack contains the spacer, it expands to take as much horizontal space as the parent view allows; the blue border indicates its size:\n\nstruct ChecklistRow: View {\n    let name: String\n\n\n    var body: some View {\n        HStack {\n            Image(systemName: \"checkmark\")\n            Spacer()\n            Text(name)\n        }\n        .border(Color.blue)\n    }\n}\n\n\nAdding two spacer views on the outside of the stack leaves the image and text together, while the stack expands to take as much horizontal space as the parent view allows:\n\nstruct ChecklistRow: View {\n    let name: String\n\n\n    var body: some View {\n        HStack {\n            Spacer()\n            Image(systemName: \"checkmark\")\n            Text(name)\n            Spacer()\n        }\n        .border(Color.blue)\n    }\n}\n\n\nTopics\nCreating a spacer\ninit(minLength: CGFloat?)\nvar minLength: CGFloat?\nThe minimum length this spacer can be shrunk to, along the axis or axes of expansion.\nRelationships\nConforms To\nSendable\nView\nSee Also\nSeparators\nstruct Divider\nA visual element that can be used to separate other content."
    },
    {
        "title": "ignoresSafeArea(_:edges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ignoressafearea(_:edges:)",
        "html": "Parameters\nregions\n\nthe kinds of rectangles removed from the safe area that should be ignored (i.e. added back to the safe area of the new child view).\n\nedges\n\nthe edges of the view that may be outset, any edges not in this set will be unchanged, even if that edge is abutting a safe area listed in regions.\n\nReturn Value\n\na new view with its safe area expanded.\n\nSee Also\nStaying in the safe areas\nfunc safeAreaInset<V>(edge: HorizontalEdge, alignment: VerticalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content beside the modified view.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(EdgeInsets) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(CGFloat) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> some View\nAdds the provided insets into the safe area of this view.\nstruct SafeAreaRegions\nA set of symbolic safe area regions."
    },
    {
        "title": "contentMargins(_:_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contentmargins(_:_:for:)-1lt8b",
        "html": "Parameters\nedges\n\nThe edges to add the margins to.\n\nlength\n\nThe amount of margins to add.\n\nplacement\n\nWhere the margins should be added.\n\nDiscussion\n\nUse this modifier to customize the content margins of different kinds of views. For example, you can use this modifier to customize the margins of scrollable views like ScrollView. In the following example, the scroll view will automatically inset its content by the safe area plus an additional 20 points on the leading and trailing edge.\n\nScrollView(.horizontal) {\n    // ...\n}\n.contentMargins(.horizontal, 20.0)\n\n\nYou can provide a ContentMarginPlacement to target specific parts of a view to customize. For example, provide a ContentMargingPlacement/scrollContent placement to inset the content of a TextEditor without affecting the insets of its scroll indicators.\n\nTextEditor(text: $text)\n    .contentMargins(.horizontal, 20.0, for: .scrollContent)\n\n\nSimilarly, you can customize the insets of scroll indicators separately from scroll content. Consider doing this when applying a custom clip shape that may clip the indicators.\n\nScrollView {\n    // ...\n}\n.clipShape(.rect(cornerRadius: 20.0))\n.contentMargins(10.0, for: .scrollIndicators)\n\n\nWhen applying multiple contentMargins modifiers, modifiers with the same placement will override modifiers higher up in the view hierarchy.\n\nSee Also\nSetting margins\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nstruct ContentMarginPlacement\nThe placement of margins."
    },
    {
        "title": "contentMargins(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contentmargins(_:for:)",
        "html": "Parameters\nlength\n\nThe amount of margins to add on all edges.\n\nplacement\n\nWhere the margins should be added.\n\nDiscussion\n\nUse this modifier to customize the content margins of different kinds of views. For example, you can use this modifier to customize the margins of scrollable views like ScrollView. In the following example, the scroll view will automatically inset its content by the safe area plus an additional 20 points on the leading and trailing edge.\n\nScrollView(.horizontal) {\n    // ...\n}\n.contentMargins(.horizontal, 20.0)\n\n\nYou can provide a ContentMarginPlacement to target specific parts of a view to customize. For example, provide a ContentMargingPlacement/scrollContent placement to inset the content of a TextEditor without affecting the insets of its scroll indicators.\n\nTextEditor(text: $text)\n    .contentMargins(.horizontal, 20.0, for: .scrollContent)\n\n\nSimilarly, you can customize the insets of scroll indicators separately from scroll content. Consider doing this when applying a custom clip shape that may clip the indicators.\n\nScrollView {\n    // ...\n}\n.clipShape(.rect(cornerRadius: 20.0))\n.contentMargins(10.0, for: .scrollIndicators)\n\n\nWhen applying multiple contentMargins modifiers, modifiers with the same placement will override modifiers higher up in the view hierarchy.\n\nSee Also\nSetting margins\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nstruct ContentMarginPlacement\nThe placement of margins."
    },
    {
        "title": "Color",
        "url": "https://developer.apple.com/documentation/swiftui/color",
        "html": "Overview\n\nYou can create a color in one of several ways:\n\nLoad a color from an Asset Catalog:\n\nlet aqua = Color(\"aqua\") // Looks in your app's main bundle by default.\n\n\nSpecify component values, like red, green, and blue; hue, saturation, and brightness; or white level:\n\nlet skyBlue = Color(red: 0.4627, green: 0.8392, blue: 1.0)\nlet lemonYellow = Color(hue: 0.1639, saturation: 1, brightness: 1)\nlet steelGray = Color(white: 0.4745)\n\n\nCreate a color instance from another color, like a UIColor or an NSColor:\n\n#if os(iOS)\nlet linkColor = Color(uiColor: .link)\n#elseif os(macOS)\nlet linkColor = Color(nsColor: .linkColor)\n#endif\n\n\nUse one of a palette of predefined colors, like black, green, and purple.\n\nSome view modifiers can take a color as an argument. For example, foregroundStyle(_:) uses the color you provide to set the foreground color for view elements, like text or SF Symbols:\n\nImage(systemName: \"leaf.fill\")\n    .foregroundStyle(Color.green)\n\n\nBecause SwiftUI treats colors as View instances, you can also directly add them to a view hierarchy. For example, you can layer a rectangle beneath a sun image using colors defined above:\n\nZStack {\n    skyBlue\n    Image(systemName: \"sun.max.fill\")\n        .foregroundStyle(lemonYellow)\n}\n.frame(width: 200, height: 100)\n\n\nA color used as a view expands to fill all the space it\u2019s given, as defined by the frame of the enclosing ZStack in the above example:\n\nSwiftUI only resolves a color to a concrete value just before using it in a given environment. This enables a context-dependent appearance for system defined colors, or those that you load from an Asset Catalog. For example, a color can have distinct light and dark variants that the system chooses from at render time.\n\nTopics\nCreating a color from an asset\ninit(String, bundle: Bundle?)\nCreates a color from a color set that you indicate by name.\nCreating a color from component values\ninit(hue: Double, saturation: Double, brightness: Double, opacity: Double)\nCreates a constant color from hue, saturation, and brightness values.\ninit(Color.RGBColorSpace, white: Double, opacity: Double)\nCreates a constant grayscale color.\ninit(Color.RGBColorSpace, red: Double, green: Double, blue: Double, opacity: Double)\nCreates a constant color from red, green, and blue component values.\nenum RGBColorSpace\nA profile that specifies how to interpret a color value for display.\nCreating a color from another color\ninit(uiColor: UIColor)\nCreates a color from a UIKit color.\ninit(nsColor: NSColor)\nCreates a color from an AppKit color.\ninit(cgColor: CGColor)\nCreates a color from a Core Graphics color.\nCreating a color from a color resource\ninit(ColorResource)\nInitialize a Color with a color resource.\nCreating a custom color\ninit<T>(T)\nCreates a color that represents the specified custom color.\ninit(Color.Resolved)\nCreates a constant color with the values specified by the resolved color.\nfunc resolve(in: EnvironmentValues) -> Color.Resolved\nEvaluates this color to a resolved color given the current context.\nGetting standard colors\nstatic let black: Color\nA black color suitable for use in UI elements.\nstatic let blue: Color\nA context-dependent blue color suitable for use in UI elements.\nstatic let brown: Color\nA context-dependent brown color suitable for use in UI elements.\nstatic let clear: Color\nA clear color suitable for use in UI elements.\nstatic let cyan: Color\nA context-dependent cyan color suitable for use in UI elements.\nstatic let gray: Color\nA context-dependent gray color suitable for use in UI elements.\nstatic let green: Color\nA context-dependent green color suitable for use in UI elements.\nstatic let indigo: Color\nA context-dependent indigo color suitable for use in UI elements.\nstatic let mint: Color\nA context-dependent mint color suitable for use in UI elements.\nstatic let orange: Color\nA context-dependent orange color suitable for use in UI elements.\nstatic let pink: Color\nA context-dependent pink color suitable for use in UI elements.\nstatic let purple: Color\nA context-dependent purple color suitable for use in UI elements.\nstatic let red: Color\nA context-dependent red color suitable for use in UI elements.\nstatic let teal: Color\nA context-dependent teal color suitable for use in UI elements.\nstatic let white: Color\nA white color suitable for use in UI elements.\nstatic let yellow: Color\nA context-dependent yellow color suitable for use in UI elements.\nGetting semantic colors\nstatic var accentColor: Color\nA color that reflects the accent color of the system or app.\nstatic let primary: Color\nThe color to use for primary content.\nstatic let secondary: Color\nThe color to use for secondary content.\nModifying a color\nfunc opacity(Double) -> Color\nMultiplies the opacity of the color by the given amount.\nvar gradient: AnyGradient\nReturns the standard gradient for the color self.\nDescribing a color\nvar description: String\nA textual representation of the color.\nComparing colors\nstatic func == (Color, Color) -> Bool\nIndicates whether two colors are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the color by feeding them into the given hash function.\nDeprecated symbols\ninit(UIColor)\nCreates a color from a UIKit color.\nDeprecated\ninit(NSColor)\nCreates a color from an AppKit color.\nDeprecated\ninit(CGColor)\nCreates a color from a Core Graphics color.\nDeprecated\nvar cgColor: CGColor?\nA Core Graphics representation of the color, if available.\nDefault Implementations\nShapeStyle Implementations\nTransferable Implementations\nRelationships\nConforms To\nCustomStringConvertible\nEquatable\nHashable\nSendable\nShapeStyle\nTransferable\nView\nSee Also\nSetting a color\nfunc tint<S>(S?) -> some View\nSets the tint within this view.\nfunc tint(Color?) -> some View\nSets the tint color within this view."
    },
    {
        "title": "AlignmentID",
        "url": "https://developer.apple.com/documentation/swiftui/alignmentid",
        "html": "Overview\n\nEvery built-in alignment guide that VerticalAlignment or HorizontalAlignment defines as a static property, like top or leading, has a unique alignment identifier type that produces the default offset for that guide. To create a custom alignment guide, define your own alignment identifier as a type that conforms to the AlignmentID protocol, and implement the required defaultValue(in:) method:\n\nprivate struct FirstThirdAlignment: AlignmentID {\n    static func defaultValue(in context: ViewDimensions) -> CGFloat {\n        context.height / 3\n    }\n}\n\n\nWhen implementing the method, calculate the guide\u2019s default offset from the view\u2019s origin. If it\u2019s helpful, you can use information from the ViewDimensions input in the calculation. This parameter provides context about the specific view that\u2019s using the guide. The above example creates an identifier called FirstThirdAlignment and calculates a default value that\u2019s one-third of the height of the aligned view.\n\nUse the identifier\u2019s type to create a static property in an extension of one of the alignment guide types, like VerticalAlignment:\n\nextension VerticalAlignment {\n    static let firstThird = VerticalAlignment(FirstThirdAlignment.self)\n}\n\n\nYou can apply your custom guide like any of the built-in guides. For example, you can use an HStack to align its views at one-third of their height using the guide defined above:\n\nstruct StripesGroup: View {\n    var body: some View {\n        HStack(alignment: .firstThird, spacing: 1) {\n            HorizontalStripes().frame(height: 60)\n            HorizontalStripes().frame(height: 120)\n            HorizontalStripes().frame(height: 90)\n        }\n    }\n}\n\n\nstruct HorizontalStripes: View {\n    var body: some View {\n        VStack(spacing: 1) {\n            ForEach(0..<3) { _ in Color.blue }\n        }\n    }\n}\n\n\nBecause each set of stripes has three equal, vertically stacked rectangles, they align at the bottom edge of the top rectangle. This corresponds in each case to a third of the overall height, as measured from the origin at the top of each set of stripes:\n\nYou can also use the alignmentGuide(_:computeValue:) view modifier to alter the behavior of your custom guide for a view, as you might alter a built-in guide. For example, you can change one of the stacks of stripes from the previous example to align its firstThird guide at two thirds of the height instead:\n\nstruct StripesGroupModified: View {\n    var body: some View {\n        HStack(alignment: .firstThird, spacing: 1) {\n            HorizontalStripes().frame(height: 60)\n            HorizontalStripes().frame(height: 120)\n            HorizontalStripes().frame(height: 90)\n                .alignmentGuide(.firstThird) { context in\n                    2 * context.height / 3\n                }\n        }\n    }\n}\n\n\nThe modified guide calculation causes the affected view to place the bottom edge of its middle rectangle on the firstThird guide, which aligns with the bottom edge of the top rectangle in the other two groups:\n\nTopics\nGetting the default value\nstatic func defaultValue(in: ViewDimensions) -> CGFloat\nCalculates a default value for the corresponding guide in the specified context.\n\nRequired\n\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space."
    },
    {
        "title": "ViewDimensions",
        "url": "https://developer.apple.com/documentation/swiftui/viewdimensions",
        "html": "Overview\n\nThis structure contains the size and alignment guides of a view. You receive an instance of this structure to use in a variety of layout calculations, like when you:\n\nDefine a default value for a custom alignment guide; see defaultValue(in:).\n\nModify an alignment guide on a view; see alignmentGuide(_:computeValue:).\n\nAsk for the dimensions of a subview of a custom view layout; see dimensions(in:).\n\nCustom alignment guides\n\nYou receive an instance of this structure as the context parameter to the defaultValue(in:) method that you implement to produce the default offset for an alignment guide, or as the first argument to the closure you provide to the alignmentGuide(_:computeValue:) view modifier to override the default calculation for an alignment guide. In both cases you can use the instance, if helpful, to calculate the offset for the guide. For example, you could compute a default offset for a custom VerticalAlignment as a fraction of the view\u2019s height:\n\nprivate struct FirstThirdAlignment: AlignmentID {\n    static func defaultValue(in context: ViewDimensions) -> CGFloat {\n        context.height / 3\n    }\n}\n\n\nextension VerticalAlignment {\n    static let firstThird = VerticalAlignment(FirstThirdAlignment.self)\n}\n\n\nAs another example, you could use the view dimensions instance to look up the offset of an existing guide and modify it:\n\nstruct ViewDimensionsOffset: View {\n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"Default\")\n            Text(\"Indented\")\n                .alignmentGuide(.leading) { context in\n                    context[.leading] - 10\n                }\n        }\n    }\n}\n\n\nThe example above indents the second text view because the subtraction moves the second text view\u2019s leading guide in the negative x direction, which is to the left in the view\u2019s coordinate space. As a result, SwiftUI moves the second text view to the right, relative to the first text view, to keep their leading guides aligned:\n\nLayout direction\n\nThe discussion above describes a left-to-right language environment, but you don\u2019t change your guide calculation to operate in a right-to-left environment. SwiftUI moves the view\u2019s origin from the left to the right side of the view and inverts the positive x direction. As a result, the existing calculation produces the same effect, but in the opposite direction.\n\nYou can see this if you use the environment(_:_:) modifier to set the layoutDirection property for the view that you defined above:\n\nViewDimensionsOffset()\n    .environment(\\.layoutDirection, .rightToLeft)\n\n\nWith no change in your guide, this produces the desired effect \u2014 it indents the second text view\u2019s right side, relative to the first text view\u2019s right side. The leading edge is now on the right, and the direction of the offset is reversed:\n\nTopics\nGetting dimensions\nvar height: CGFloat\nThe view\u2019s height.\nvar width: CGFloat\nThe view\u2019s width.\nAccessing guide values\nsubscript(VerticalAlignment) -> CGFloat\nGets the value of the given vertical guide.\nsubscript(HorizontalAlignment) -> CGFloat\nGets the value of the given horizontal guide.\nsubscript(explicit _: VerticalAlignment) -> CGFloat?\nGets the explicit value of the given vertical alignment guide\nsubscript(explicit _: HorizontalAlignment) -> CGFloat?\nGets the explicit value of the given horizontal alignment guide.\nRelationships\nConforms To\nEquatable\nSee Also\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides."
    },
    {
        "title": "contentMargins(_:_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contentmargins(_:_:for:)-lgl5",
        "html": "Parameters\nedges\n\nThe edges to add the margins to.\n\ninsets\n\nThe amount of margins to add.\n\nplacement\n\nWhere the margins should be added.\n\nDiscussion\n\nUse this modifier to customize the content margins of different kinds of views. For example, you can use this modifier to customize the margins of scrollable views like ScrollView. In the following example, the scroll view will automatically inset its content by the safe area plus an additional 20 points on the leading and trailing edge.\n\nScrollView(.horizontal) {\n    // ...\n}\n.contentMargins(.horizontal, 20.0)\n\n\nYou can provide a ContentMarginPlacement to target specific parts of a view to customize. For example, provide a ContentMargingPlacement/scrollContent placement to inset the content of a TextEditor without affecting the insets of its scroll indicators.\n\nTextEditor(text: $text)\n    .contentMargins(.horizontal, 20.0, for: .scrollContent)\n\n\nSimilarly, you can customize the insets of scroll indicators separately from scroll content. Consider doing this when applying a custom clip shape that may clip the indicators.\n\nScrollView {\n    // ...\n}\n.clipShape(.rect(cornerRadius: 20.0))\n.contentMargins(10.0, for: .scrollIndicators)\n\n\nWhen applying multiple contentMargins modifiers, modifiers with the same placement will override modifiers higher up in the view hierarchy.\n\nSee Also\nSetting margins\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nstruct ContentMarginPlacement\nThe placement of margins."
    },
    {
        "title": "LayoutSubview",
        "url": "https://developer.apple.com/documentation/swiftui/layoutsubview",
        "html": "Overview\n\nThis type acts as a proxy for a view that your custom layout container places in the user interface. Layout protocol methods receive a LayoutSubviews collection that contains exactly one proxy for each of the subviews arranged by your container.\n\nUse a proxy to get information about the associated subview, like its dimensions, layout priority, or custom layout values. You also use the proxy to tell its corresponding subview where to appear by calling the proxy\u2019s place(at:anchor:proposal:) method. Do this once for each subview from your implementation of the layout\u2019s placeSubviews(in:proposal:subviews:cache:) method.\n\nYou can read custom layout values associated with a subview by using the property\u2019s key as an index on the subview. For more information about defining, setting, and reading custom values, see LayoutValueKey.\n\nTopics\nPlacing the subview\nfunc place(at: CGPoint, anchor: UnitPoint, proposal: ProposedViewSize)\nAssigns a position and proposed size to the subview.\nGetting subview characteristics\nfunc dimensions(in: ProposedViewSize) -> ViewDimensions\nAsks the subview for its dimensions and alignment guides.\nfunc sizeThatFits(ProposedViewSize) -> CGSize\nAsks the subview for its size.\nvar spacing: ViewSpacing\nThe subviews\u2019s preferred spacing values.\nvar priority: Double\nThe layout priority of the subview.\nGetting custom values\nsubscript<K>(K.Type) -> K.Value\nGets the value for the subview that\u2019s associated with the specified key.\nRelationships\nConforms To\nEquatable\nSee Also\nCreating a custom layout container\nprotocol Layout\nA type that defines the geometry of a collection of views.\nstruct LayoutSubviews\nA collection of proxy values that represent the subviews of a layout view."
    },
    {
        "title": "Anchor",
        "url": "https://developer.apple.com/documentation/swiftui/anchor",
        "html": "Overview\n\nYou can convert the anchor to a Value in the coordinate space of a target view by using a GeometryProxy to specify the target view.\n\nTopics\nGetting the anchor\u2019s source\nstruct Source\nA type-erased geometry value that produces an anchored value of a given type.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nAccessing geometric constructs\nenum Axis\nThe horizontal or vertical dimension in a 2D coordinate system.\nstruct Angle\nA geometric angle whose value you access in either radians or degrees.\nstruct UnitPoint\nA normalized 2D point in a view\u2019s coordinate space.\nstruct UnitPoint3D\nA normalized 3D point in a view\u2019s coordinate space.\nBeta"
    },
    {
        "title": "Composing custom layouts with SwiftUI",
        "url": "https://developer.apple.com/documentation/swiftui/composing_custom_layouts_with_swiftui",
        "html": "Overview\n\nThis sample app demonstrates many of the layout tools that SwiftUI provides by building an interface that enables people to vote for their favorite kind of pet. The app offers buttons to vote for a specific pet type, and displays the vote counts and relative rankings of the various contenders on a leaderboard. It also shows avatars for the pets, arranged in a way that reflects the current rankings.\n\nNote\n\nThis sample code project is associated with WWDC22 session 10056: Compose custom layouts with SwiftUI.\n\nArrange views in two dimensions with a grid\n\nTo draw a leaderboard in the middle of the display that shows vote counts and percentages, the sample uses a Grid view.\n\nThe grid contains a GridRow inside a ForEach, where each view in the row creates a column cell. So the first view appears in the first column, the second in the second column, and so on. Because the Divider appears outside of a grid row instance, it creates a row that spans the width of the grid.\n\nGrid(alignment: .leading) {\n    ForEach(model.pets) { pet in\n        GridRow {\n            Text(pet.type)\n            ProgressView(\n                value: Double(pet.votes),\n                total: Double(max(1, model.totalVotes))) // Avoid dividing by zero.\n            Text(\"\\(pet.votes)\")\n                .gridColumnAlignment(.trailing)\n        }\n\n\n        Divider()\n    }\n}\n\n\nThe sample initializes the grid with leading-edge alignment, which applies to every cell in the grid. Meanwhile, the gridColumnAlignment(_:) view modifier that appears on the vote count cell overrides the alignment of cells in that column to use trailing-edge alignment.\n\nCreate a custom equal-width layout\n\nThe app offers buttons for voting at the bottom of the interface.\n\nTo ensure the buttons all have the same width, but are no wider than the widest button text, the app creates a custom layout container type that conforms to the Layout protocol. The equal-width horizontal stack (MyEqualWidthHStack) measures the ideal sizes of all its subviews, and offers the widest ideal size to each subview.\n\nThe custom stack implements the protocol\u2019s two required methods. First, sizeThatFits(proposal:subviews:cache:) reports the container\u2019s size, given a set of subviews.\n\nfunc sizeThatFits(\n    proposal: ProposedViewSize,\n    subviews: Subviews,\n    cache: inout Void\n) -> CGSize {\n    guard !subviews.isEmpty else { return .zero }\n\n\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n    let totalSpacing = spacing.reduce(0) { $0 + $1 }\n\n\n    return CGSize(\n        width: maxSize.width * CGFloat(subviews.count) + totalSpacing,\n        height: maxSize.height)\n}\n\n\nThis method combines the largest size in each dimension with the horizontal spacing between subviews to find the container\u2019s total size. Then, placeSubviews(in:proposal:subviews:cache:) tells each of the subviews where to appear within the layout\u2019s bounds.\n\nfunc placeSubviews(\n    in bounds: CGRect,\n    proposal: ProposedViewSize,\n    subviews: Subviews,\n    cache: inout Void\n) {\n    guard !subviews.isEmpty else { return }\n\n\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n\n\n    let placementProposal = ProposedViewSize(width: maxSize.width, height: maxSize.height)\n    var nextX = bounds.minX + maxSize.width / 2\n\n\n    for index in subviews.indices {\n        subviews[index].place(\n            at: CGPoint(x: nextX, y: bounds.midY),\n            anchor: .center,\n            proposal: placementProposal)\n        nextX += maxSize.width + spacing[index]\n    }\n}\n\n\nThe method creates a single size proposal for the subviews, and then uses that, along with a point that changes for each subview, to arrange the buttons in a horizontal line with default spacing.\n\nChoose the view that fits\n\nThe size of the voting buttons depends on the width of the text they contain. For people that speak another language or that use a larger text size, the horizontally arranged buttons might not fit in the display. So the app uses ViewThatFits to let SwiftUI choose between a horizontal and a vertical arrangement of the buttons for the one that fits in the available space.\n\nViewThatFits { // Choose the first view that fits.\n    MyEqualWidthHStack { // Arrange horizontally if it fits...\n        Buttons()\n    }\n    MyEqualWidthVStack { // ...or vertically, otherwise.\n        Buttons()\n    }\n}\n\n\nTo ensure that the buttons maintain their equal-width property when arranged vertically, the app uses a custom equal-width vertical stack (MyEqualWidthVStack) that\u2019s very similar to the horizontal version.\n\nImprove layout efficiency with a cache\n\nThe methods of the Layout protocol take a bidirectional cache parameter. The cache provides access to optional storage that\u2019s shared among all the methods of a particular layout instance. To demonstrate the use of a cache, the sample app\u2019s equal-width vertical layout creates storage to share size and spacing calculations between its sizeThatFits(proposal:subviews:cache:) and placeSubviews(in:proposal:subviews:cache:) implementations.\n\nFirst, the layout defines a CacheData type for the storage.\n\nstruct CacheData {\n    let maxSize: CGSize\n    let spacing: [CGFloat]\n    let totalSpacing: CGFloat\n}\n\n\nIt then implements the protocol\u2019s optional makeCache(subviews:) method to do the calculations for a set of subviews, returning a value of the type defined above.\n\nfunc makeCache(subviews: Subviews) -> CacheData {\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n    let totalSpacing = spacing.reduce(0) { $0 + $1 }\n\n\n    return CacheData(\n        maxSize: maxSize,\n        spacing: spacing,\n        totalSpacing: totalSpacing)\n}\n\n\nIf the subviews change, SwiftUI calls the layout\u2019s updateCache(_:subviews:) method. The default implementation of that method calls makeCache(subviews:) again, which recalculates the data. Then the sizeThatFits(proposal:subviews:cache:) and placeSubviews(in:proposal:subviews:cache:) methods make use of their cache parameter to retrieve the data. For example, placeSubviews(in:proposal:subviews:cache:) reads the size and the spacing array from the cache.\n\nlet maxSize = cache.maxSize\nlet spacing = cache.spacing\n\n\nContrast this with the equal-width horizontal stack, which doesn\u2019t use a cache, and instead calculates the size and spacing information every time it needs that information.\n\nNote\n\nMost simple layouts, including the equal-width vertical stack, don\u2019t gain much efficiency from using a cache. Developers can profile their app with Instruments to find out whether a particular layout type actually benefits from a cache.\n\nCreate a custom radial layout with an offset\n\nTo display the pet avatars in a circle, the app defines a radial layout (MyRadialLayout).\n\nLike other custom layouts, this layout needs the two required methods. For sizeThatFits(proposal:subviews:cache:), the layout fills the available space by returning whatever size its container proposes.\n\nproposal.replacingUnspecifiedDimensions()\n\n\nThe app uses the proposal\u2019s replacingUnspecifiedDimensions(by:) method to convert the proposal into a concrete size. Then, to place subviews, the layout rotates a vector, translates the vector to the middle of the placement region, and uses that as the anchor for the subview.\n\nfor (index, subview) in subviews.enumerated() {\n    // Find a vector with an appropriate size and rotation.\n    var point = CGPoint(x: 0, y: -radius)\n        .applying(CGAffineTransform(\n            rotationAngle: angle * Double(index) + offset))\n\n\n    // Shift the vector to the middle of the region.\n    point.x += bounds.midX\n    point.y += bounds.midY\n\n\n    // Place the subview.\n    subview.place(at: point, anchor: .center, proposal: .unspecified)\n}\n\n\nThe offset that the app applies to the rotation accounts for the current rankings, placing higher-ranked pets closer to the top of the interface. The app stores ranks on the subviews using the LayoutValueKey protocol, and then reads the values to calculate the offset before placing views.\n\nAnimate transitions between layouts\n\nThe radial layout can calculate an offset that creates an appropriate arrangement for all but one set of rankings: there\u2019s no way to show a three-way tie with the avatars in a circle. To resolve this, the app detects this condition, and uses it to put the avatars in a line instead, using a the HStackLayout type, which is a version of the built-in HStack that conforms to the Layout protocol. To transition between these layout types, the app uses the AnyLayout type.\n\nlet layout = model.isAllWayTie ? AnyLayout(HStackLayout()) : AnyLayout(MyRadialLayout())\n\n\nPodium()\n    .overlay(alignment: .top) {\n        layout {\n            ForEach(model.pets) { pet in\n                Avatar(pet: pet)\n                    .rank(model.rank(pet))\n            }\n        }\n        .animation(.default, value: model.pets)\n    }\n\n\nBecause the structural identity of the views remains the same throughout, the animation(_:value:) view modifier creates animated transitions between layout types. The modifier also animates radial layout changes that result from changes in the rankings because the calculated offsets depend on the same pet data.\n\nBuild documentation for the app\n\nTo see more information about the symbols defined by this app, you can build the app\u2019s documentation. Open the project in Xcode and select Product > Build Documentation.\n\nFor information about how to include documentation in your own apps, see DocC."
    },
    {
        "title": "ColorMatrix",
        "url": "https://developer.apple.com/documentation/swiftui/colormatrix",
        "html": "Overview\n\nThe matrix has five columns, each with a red, green, blue, and alpha component. You can use the matrix for tasks like creating a color transformation GraphicsContext.Filter for a GraphicsContext using the colorMatrix(_:) method.\n\nTopics\nCreating an identity matrix\ninit()\nCreates the identity matrix.\nFirst column\nvar r1: Float\nvar g1: Float\nvar b1: Float\nvar a1: Float\nSecond column\nvar r2: Float\nvar g2: Float\nvar b2: Float\nvar a2: Float\nThird column\nvar r3: Float\nvar g3: Float\nvar b3: Float\nvar a3: Float\nFourth column\nvar r4: Float\nvar g4: Float\nvar b4: Float\nvar a4: Float\nFifth column\nvar r5: Float\nvar g5: Float\nvar b5: Float\nvar a5: Float\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nApplying blur and shadows\nfunc blur(radius: CGFloat, opaque: Bool) -> some View\nApplies a Gaussian blur to this view.\nfunc shadow(color: Color, radius: CGFloat, x: CGFloat, y: CGFloat) -> some View\nAdds a shadow to this view."
    },
    {
        "title": "drawingGroup(opaque:colorMode:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/drawinggroup(opaque:colormode:)",
        "html": "Parameters\nopaque\n\nA Boolean value that indicates whether the image is opaque. The default is false; if set to true, the alpha channel of the image must be 1.\n\ncolorMode\n\nOne of the working color space and storage formats defined in ColorRenderingMode. The default is ColorRenderingMode.nonLinear.\n\nReturn Value\n\nA view that composites this view\u2019s contents into an offscreen image before display.\n\nDiscussion\n\nThe drawingGroup(opaque:colorMode:) modifier flattens a subtree of views into a single view before rendering it.\n\nIn the example below, the contents of the view are composited to a single bitmap; the bitmap is then displayed in place of the view:\n\nVStack {\n    ZStack {\n        Text(\"DrawingGroup\")\n            .foregroundColor(.black)\n            .padding(20)\n            .background(Color.red)\n        Text(\"DrawingGroup\")\n            .blur(radius: 2)\n    }\n    .font(.largeTitle)\n    .compositingGroup()\n    .opacity(1.0)\n}\n .background(Color.white)\n .drawingGroup()\n\n\nNote\n\nViews backed by native platform views may not render into the image. Instead, they log a warning and display a placeholder image to highlight the error.\n\nSee Also\nCompositing views\nfunc blendMode(BlendMode) -> some View\nSets the blend mode for compositing this view with overlapping views.\nfunc compositingGroup() -> some View\nWraps this view in a compositing group.\nenum BlendMode\nModes for compositing a view with overlapping content.\nenum ColorRenderingMode\nThe set of possible working color spaces for color-compositing operations."
    },
    {
        "title": "blendMode(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/blendmode(_:)",
        "html": "Parameters\nblendMode\n\nThe BlendMode for compositing this view.\n\nReturn Value\n\nA view that applies blendMode to this view.\n\nDiscussion\n\nUse blendMode(_:) to combine overlapping views and use a different visual effect to produce the result. The BlendMode enumeration defines many possible effects.\n\nIn the example below, the two overlapping rectangles have a BlendMode.colorBurn effect applied, which effectively removes the non-overlapping portion of the second image:\n\nHStack {\n    Color.yellow.frame(width: 50, height: 50, alignment: .center)\n\n\n    Color.red.frame(width: 50, height: 50, alignment: .center)\n        .rotationEffect(.degrees(45))\n        .padding(-20)\n        .blendMode(.colorBurn)\n}\n\n\nSee Also\nCompositing views\nfunc compositingGroup() -> some View\nWraps this view in a compositing group.\nfunc drawingGroup(opaque: Bool, colorMode: ColorRenderingMode) -> some View\nComposites this view\u2019s contents into an offscreen image before final display.\nenum BlendMode\nModes for compositing a view with overlapping content.\nenum ColorRenderingMode\nThe set of possible working color spaces for color-compositing operations."
    },
    {
        "title": "VisualEffect",
        "url": "https://developer.apple.com/documentation/swiftui/visualeffect",
        "html": "Overview\n\nBecause effects do not impact layout, they are safe to use in situations where layout modification is not allowed. For example, effects may be applied as a function of position, accessed through a geometry proxy:\n\nvar body: some View {\n    ContentRow()\n        .visualEffect { content, geometryProxy in\n            content.offset(x: geometryProxy.frame(in: .global).origin.y)\n        }\n}\n\n\nYou don\u2019t conform to this protocol yourself. Instead, visual effects are created by calling modifier functions (such as .offset(x:y:) on other effects, as seen in the example above.\n\nTopics\nAdjusting Color\nfunc brightness(Double) -> some VisualEffect\nBrightens the view by the specified amount.\nfunc colorEffect(Shader, isEnabled: Bool) -> some VisualEffect\nReturns a new visual effect that applies shader to self as a filter effect on the color of each pixel.\nfunc contrast(Double) -> some VisualEffect\nSets the contrast and separation between similar colors in the view.\nfunc grayscale(Double) -> some VisualEffect\nAdds a grayscale effect to the view.\nfunc hueRotation(Angle) -> some VisualEffect\nApplies a hue rotation effect to the view.\nfunc saturation(Double) -> some VisualEffect\nAdjusts the color saturation of the view.\nfunc opacity(Double) -> some VisualEffect\nSets the transparency of the view.\nScaling\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some VisualEffect\nScales the view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some VisualEffect\nScales the view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some VisualEffect\nScales the view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some VisualEffect\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some VisualEffect\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some VisualEffect\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nRotating\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some VisualEffect\nRotates content in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some VisualEffect\nRenders content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D, perspective: CGFloat) -> some VisualEffect\nRenders content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some VisualEffect\nRotates content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some VisualEffect\nRotates content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some VisualEffect\nRotates content by an angle about an axis that you specify as a tuple of elements.\nBeta\nTranslating\nfunc offset(CGSize) -> some VisualEffect\nOffsets the view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(x: CGFloat, y: CGFloat) -> some VisualEffect\nOffsets the view by the specified horizontal and vertical distances.\nfunc offset(z: CGFloat) -> some VisualEffect\nBrings a view forward in Z by the provided distance in points.\nBeta\nApplying a transform\nfunc transform3DEffect(AffineTransform3D) -> some VisualEffect\nApplies a 3D transformation to the receiver.\nBeta\nfunc transformEffect(CGAffineTransform) -> some VisualEffect\nApplies an affine transformation to the view\u2019s rendered output.\nfunc transformEffect(ProjectionTransform) -> some VisualEffect\nApplies a projection transformation to the view\u2019s rendered output.\nApplying other effects\nfunc blur(radius: CGFloat, opaque: Bool) -> some VisualEffect\nApplies a Gaussian blur to the view.\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some VisualEffect\nReturns a new visual effect that applies shader to self as a geometric distortion effect on the location of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some VisualEffect\nReturns a new visual effect that applies shader to self as a filter on the raster layer created from self.\nRelationships\nInherits From\nAnimatable\nSendable\nConforming Types\nEmptyVisualEffect\nSee Also\nApplying effects based on geometry\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a geometry proxy.\nfunc visualEffect3D((EmptyVisualEffect, GeometryProxy3D) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a 3D geometry proxy.\nBeta\nstruct EmptyVisualEffect\nThe base visual effect that you apply additional effect to."
    },
    {
        "title": "EmptyVisualEffect",
        "url": "https://developer.apple.com/documentation/swiftui/emptyvisualeffect",
        "html": "Overview\n\nEmptyVisualEffect does not change the appearance of the view that it is applied to.\n\nTopics\nCreating an empty visual effect\ninit()\nCreates a new empty visual effect.\nRelationships\nConforms To\nAnimatable\nSendable\nVisualEffect\nSee Also\nApplying effects based on geometry\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a geometry proxy.\nfunc visualEffect3D((EmptyVisualEffect, GeometryProxy3D) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a 3D geometry proxy.\nBeta\nprotocol VisualEffect\nVisual Effects change the visual appearance of a view without changing its ancestors or descendents."
    },
    {
        "title": "PhysicalMetric",
        "url": "https://developer.apple.com/documentation/swiftui/physicalmetric",
        "html": "Overview\n\nUse this property wrapper inside a View or a type that inherits a View\u2019s environment, like a ViewModifier. Its value will be the equivalent in points of the physical measurement of length you specify.\n\nFor example, to have a variable that contains the amount of points corresponding to one meter, you can do the following:\n\nstruct MyView: View {\n    @PhysicalMetric(from: .meters)\n    var twoAndAHalfMeters = 2.5\n    \u2026\n}\n\n\nUsing this wrapper for a property of a type not associated with a scene\u2019s view contents, like an App or a Scene, is unsupported.\n\nTopics\nCreating a metric\ninit(wrappedValue: Value, from: UnitLength)\nCreates a value that maps the specified set of physical length measurements, in the specified unit, to a corresponding set of values measured in points in the associated scene.\ninit(wrappedValue: CGPoint, from: UnitLength)\nCreates a value that maps the specified point, whose dimensions are specified in physical length measurements in the given unit, to the corresponding value in points in the associated scene.\ninit(wrappedValue: CGSize, from: UnitLength)\nCreates a value that maps the specified size, in the specified unit to the corresponding value in points in the associated scene.\ninit(wrappedValue: Size3D, from: UnitLength)\nCreates a value that maps the specified size, in the specified unit to the corresponding value in points in the associated scene.\ninit(wrappedValue: Point3D, from: UnitLength)\nCreates a value that maps the specified point, whose dimensions are specified in physical length measurements in the given unit, to the corresponding value in points in the associated scene.\ninit(wrappedValue: Value, from: UnitLength)\nCreates a value that maps the specified single physical length measurement, in the specified unit, to the corresponding value in points in the associated scene.\ninit(wrappedValue: CGRect, from: UnitLength)\nCreates a value that maps the specified rectangle, whose dimensions are specified in physical length measurements in the given unit, to the corresponding value in points in the associated scene.\ninit(wrappedValue: Rect3D, from: UnitLength)\nCreates a value that maps the specified Rect3D, whose dimensions are specified in physical length measurements in the given unit, to the corresponding value in points in the associated scene.\nGetting the value\nvar wrappedValue: Value\nA value in points in the coordinate system of the associated scene.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "coordinateSpace(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/coordinatespace(_:)",
        "html": "Parameters\nname\n\nA name used to identify this coordinate space.\n\nDiscussion\n\nUse coordinateSpace(_:) to allow another function to find and operate on a view and operate on dimensions relative to that view.\n\nThe example below demonstrates how a nested view can find and operate on its enclosing view\u2019s coordinate space:\n\nstruct ContentView: View {\n    @State private var location = CGPoint.zero\n\n\n    var body: some View {\n        VStack {\n            Color.red.frame(width: 100, height: 100)\n                .overlay(circle)\n            Text(\"Location: \\(Int(location.x)), \\(Int(location.y))\")\n        }\n        .coordinateSpace(.named(\"stack\"))\n    }\n\n\n    var circle: some View {\n        Circle()\n            .frame(width: 25, height: 25)\n            .gesture(drag)\n            .padding(5)\n    }\n\n\n    var drag: some Gesture {\n        DragGesture(coordinateSpace: .named(\"stack\"))\n            .onChanged { info in location = info.location }\n    }\n}\n\n\nHere, the VStack in the ContentView named \u201cstack\u201d is composed of a red frame with a custom Circle view overlay(_:alignment:) at its center.\n\nThe circle view has an attached DragGesture that targets the enclosing VStack\u2019s coordinate space. As the gesture recognizer\u2019s closure registers events inside circle it stores them in the shared location state variable and the VStack displays the coordinates in a Text view.\n\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "CoordinateSpaceProtocol",
        "url": "https://developer.apple.com/documentation/swiftui/coordinatespaceprotocol",
        "html": "Overview\n\nAll geometric properties of a view, including size, position, and transform, are defined within the local coordinate space of the view\u2019s parent. These values can be converted into other coordinate spaces by passing types conforming to this protocol into functions such as GeometryProxy.frame(in:).\n\nFor example, a named coordinate space allows you to convert the frame of a view into the local coordinate space of an ancestor view by defining a named coordinate space using the coordinateSpace(_:) modifier, then passing that same named coordinate space into the frame(in:) function.\n\nVStack {\n    GeometryReader { geometryProxy in\n        let distanceFromTop = geometryProxy.frame(in: \"container\").origin.y\n        Text(\"This view is \\(distanceFromTop) points from the top of the VStack\")\n    }\n    .padding()\n}\n.coordinateSpace(.named(\"container\"))\n\n\nYou don\u2019t typically create types conforming to this protocol yourself. Instead, use the system-provided .global, .local, and .named(_:) implementations.\n\nTopics\nGetting built-in coordinate spaces\nstatic var global: GlobalCoordinateSpace\nThe global coordinate space at the root of the view hierarchy.\nAvailable when Self is GlobalCoordinateSpace.\nstatic var local: LocalCoordinateSpace\nThe local coordinate space of the current view.\nAvailable when Self is LocalCoordinateSpace.\nstatic func named(some Hashable) -> NamedCoordinateSpace\nCreates a named coordinate space using the given value.\nAvailable when Self is NamedCoordinateSpace.\nstatic var scrollView: NamedCoordinateSpace\nThe named coordinate space that is added by the system for the innermost containing scroll view.\nAvailable when Self is NamedCoordinateSpace.\nstatic func scrollView(axis: Axis) -> Self\nThe named coordinate space that is added by the system for the innermost containing scroll view that allows scrolling along the provided axis.\nAvailable when Self is NamedCoordinateSpace.\nGetting the resolved coordinate space\nvar coordinateSpace: CoordinateSpace\nThe resolved coordinate space.\n\nRequired\n\nSupporting types\nstruct GlobalCoordinateSpace\nThe global coordinate space at the root of the view hierarchy.\nstruct LocalCoordinateSpace\nThe local coordinate space of the current view.\nstruct NamedCoordinateSpace\nA named coordinate space.\nRelationships\nConforming Types\nGlobalCoordinateSpace\nLocalCoordinateSpace\nNamedCoordinateSpace\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "GeometryProxy3D",
        "url": "https://developer.apple.com/documentation/swiftui/geometryproxy3d",
        "html": "Overview\n\nYou can use a proxy for anchor resolution.\n\nTopics\nAccessing geometry characteristics\nfunc frame(in: some CoordinateSpaceProtocol) -> Rect3D\nThe container view\u2019s bounds rectangle converted to a defined coordinate space.\nvar size: Size3D\nThe size of the container view.\nvar safeAreaInsets: EdgeInsets3D\nThe safe area inset of the container view.\nsubscript<T>(Anchor<T>) -> T\nResolves the value of an anchor to the container view.\nfunc transform(in: some CoordinateSpaceProtocol) -> AffineTransform3D?\nThe container view\u2019s 3D transform converted to a defined coordinate space.\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "rotation3DEffect(_:axis:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/rotation3deffect(_:axis:anchor:)-4kzwf",
        "html": "Parameters\nangle\n\nThe angle by which to rotate the view\u2019s content.\n\naxis\n\nThe axis of rotation, specified as a tuple with named elements for each of the three spatial dimensions.\n\nanchor\n\nThe unit point within the view about which to perform the rotation. The default value is center.\n\nReturn Value\n\nA view with rotated content.\n\nDiscussion\n\nThis modifier rotates the view\u2019s content without changing the view\u2019s frame. The following code displays a 3D model with a rotation of 45\u00b0 about the y-axis using the default anchor point at the center of the view:\n\nModel3D(named: \"robot\")\n    .rotation3DEffect(.degrees(45), axis: (x: 0, y: 1, z: 0))\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "EmptyCommands",
        "url": "https://developer.apple.com/documentation/swiftui/emptycommands",
        "html": "Topics\nCreating the command group\ninit()\nCreates an empty command hierarchy.\nRelationships\nConforms To\nCommands\nSee Also\nGetting built-in command groups\nstruct SidebarCommands\nA built-in set of commands for manipulating window sidebars.\nstruct TextEditingCommands\nA built-in group of commands for searching, editing, and transforming selections of text.\nstruct TextFormattingCommands\nA built-in set of commands for transforming the styles applied to selections of text.\nstruct ToolbarCommands\nA built-in set of commands for manipulating window toolbars.\nstruct ImportFromDevicesCommands\nA built-in set of commands that enables importing content from nearby devices.\nstruct InspectorCommands\nA built-in set of commands for manipulating inspectors."
    },
    {
        "title": "menuOrder(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/menuorder(_:)",
        "html": "Parameters\norder\n\nThe menu item ordering strategy to apply.\n\nReturn Value\n\nA view that uses the specified menu ordering strategy.\n\nDiscussion\n\nUse this modifier to override the default menu order. On supported platforms, priority order keeps the first items closer to the user\u2019s point of interaction, whereas fixed order always orders items from top to bottom.\n\nOn iOS, the automatic order resolves to fixed for menus presented within scrollable content. Pickers that use the menu style also default to fixed order. In all other cases, menus default to priority order.\n\nOn macOS, tvOS and watchOS, the automatic order always resolves to fixed order.\n\nThe following example creates a menu that presents its content in a fixed order from top to bottom:\n\nMenu {\n    Button(\"Select\", action: selectFolders)\n    Button(\"New Folder\", action: createFolder)\n    Picker(\"Appearance\", selection: $appearance) {\n        Label(\"Icons\", systemImage: \"square.grid.2x2\").tag(Appearance.icons)\n        Label(\"List\", systemImage: \"list.bullet\").tag(Appearance.list)\n    }\n} label: {\n    Label(\"Settings\", systemImage: \"ellipsis.circle\")\n}\n.menuOrder(.fixed)\n\n\nYou can use this modifier on controls that present a menu. For example, the code below creates a Picker using the menu style with a priority-based order:\n\nPicker(\"Flavor\", selection: $selectedFlavor) {\n    Text(\"Chocolate\").tag(Flavor.chocolate)\n    Text(\"Vanilla\").tag(Flavor.vanilla)\n    Text(\"Strawberry\").tag(Flavor.strawberry)\n}\n.pickerStyle(.menu)\n.menuOrder(.priority)\n\n\nYou can also use this modifier on context menus. The example below creates a context menu that presents its content in a fixed order:\n\nText(\"Favorite Card Suit\")\n    .padding()\n    .contextMenu {\n        Button(\"\u2665\ufe0f - Hearts\", action: selectHearts)\n        Button(\"\u2663\ufe0f - Clubs\", action: selectClubs)\n        Button(\"\u2660\ufe0f - Spades\", action: selectSpades)\n        Button(\"\u2666\ufe0f - Diamonds\", action: selectDiamonds)\n    }\n    .menuOrder(.fixed)\n\n\nThe modifier has no effect when applied to a subsection or submenu of a menu.\n\nSee Also\nSetting a preferred order\nvar menuOrder: MenuOrder\nThe preferred order of items for menus presented from this view.\nstruct MenuOrder\nThe order in which a menu presents its content."
    },
    {
        "title": "MenuActionDismissBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/menuactiondismissbehavior",
        "html": "Overview\n\nConfigure the menu dismissal behavior for a view hierarchy using the menuActionDismissBehavior(_:) view modifier.\n\nTopics\nGetting dismiss behaviors\nstatic let automatic: MenuActionDismissBehavior\nUse the a dismissal behavior that\u2019s appropriate for the given context.\nstatic let disabled: MenuActionDismissBehavior\nNever dismiss the presented menu after performing an action.\nstatic let enabled: MenuActionDismissBehavior\nAlways dismiss the presented menu after performing an action.\nRelationships\nConforms To\nEquatable\nSee Also\nConfiguring menu dismissal\nfunc menuActionDismissBehavior(MenuActionDismissBehavior) -> some View\nTells a menu whether to dismiss after performing an action."
    },
    {
        "title": "SidebarCommands",
        "url": "https://developer.apple.com/documentation/swiftui/sidebarcommands",
        "html": "Overview\n\nThese commands are optional and can be explicitly requested by passing a value of this type to the commands(content:) modifier.\n\nTopics\nCreating the command group\ninit()\nA new value describing the built-in sidebar-related commands.\nRelationships\nConforms To\nCommands\nSee Also\nGetting built-in command groups\nstruct TextEditingCommands\nA built-in group of commands for searching, editing, and transforming selections of text.\nstruct TextFormattingCommands\nA built-in set of commands for transforming the styles applied to selections of text.\nstruct ToolbarCommands\nA built-in set of commands for manipulating window toolbars.\nstruct ImportFromDevicesCommands\nA built-in set of commands that enables importing content from nearby devices.\nstruct InspectorCommands\nA built-in set of commands for manipulating inspectors.\nstruct EmptyCommands\nAn empty group of commands."
    },
    {
        "title": "rotation3DEffect(_:axis:anchor:anchorZ:perspective:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/rotation3deffect(_:axis:anchor:anchorz:perspective:)",
        "html": "Parameters\nangle\n\nThe angle by which to rotate the view\u2019s content.\n\naxis\n\nThe axis of rotation, specified as a tuple with named elements for each of the three spatial dimensions.\n\nanchor\n\nA two dimensional unit point within the view about which to perform the rotation. The default value is center.\n\nanchorZ\n\nThe location on the z-axis around which to rotate the content. The default is 0.\n\nperspective\n\nThe relative vanishing point for the rotation. The default is 1.\n\nReturn Value\n\nA view with rotated content.\n\nDiscussion\n\nUse this method to create the effect of rotating a view in three dimensions around a specified axis of rotation. The modifier projects the rotated content onto the original view\u2019s plane. Use the perspective value to control the renderer\u2019s vanishing point. The following example creates the appearance of rotating text 45\u02da about the y-axis:\n\nText(\"Rotation by passing an angle in degrees\")\n    .rotation3DEffect(\n        .degrees(45),\n        axis: (x: 0.0, y: 1.0, z: 0.0),\n        anchor: .center,\n        anchorZ: 0,\n        perspective: 1)\n    .border(Color.gray)\n\n\nImportant\n\nIn visionOS, create this effect with perspectiveRotationEffect(_:axis:anchor:anchorZ:perspective:) instead. To truly rotate a view in three dimensions, use a 3D rotation modifier without a perspective input like rotation3DEffect(_:axis:anchor:).\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "Grid",
        "url": "https://developer.apple.com/documentation/swiftui/grid",
        "html": "Overview\n\nCreate a two dimensional layout by initializing a Grid with a collection of GridRow structures. The first view in each grid row appears in the grid\u2019s first column, the second view in the second column, and so on. The following example creates a grid with two rows and two columns:\n\nGrid {\n    GridRow {\n        Text(\"Hello\")\n        Image(systemName: \"globe\")\n    }\n    GridRow {\n        Image(systemName: \"hand.wave\")\n        Text(\"World\")\n    }\n}\n\n\nA grid and its rows behave something like a collection of HStack instances wrapped in a VStack. However, the grid handles row and column creation as a single operation, which applies alignment and spacing to cells, rather than first to rows and then to a column of unrelated rows. The grid produced by the example above demonstrates this:\n\nNote\n\nIf you need a grid that conforms to the Layout protocol, like when you want to create a conditional layout using AnyLayout, use GridLayout instead.\n\nMulticolumn cells\n\nIf you provide a view rather than a GridRow as an element in the grid\u2019s content, the grid uses the view to create a row that spans all of the grid\u2019s columns. For example, you can add a Divider between the rows of the previous example:\n\nGrid {\n    GridRow {\n        Text(\"Hello\")\n        Image(systemName: \"globe\")\n    }\n    Divider()\n    GridRow {\n        Image(systemName: \"hand.wave\")\n        Text(\"World\")\n    }\n}\n\n\nBecause a divider takes as much horizontal space as its parent offers, the entire grid widens to fill the width offered by its parent view.\n\nTo prevent a flexible view from taking more space on a given axis than the other cells in a row or column require, add the gridCellUnsizedAxes(_:) view modifier to the view:\n\nDivider()\n    .gridCellUnsizedAxes(.horizontal)\n\n\nThis restores the grid to the width that the text and images require:\n\nTo make a cell span a specific number of columns rather than the whole grid, use the gridCellColumns(_:) modifier on a view that\u2019s contained inside a GridRow.\n\nColumn count\n\nThe grid\u2019s column count grows to handle the row with the largest number of columns. If you create rows with different numbers of columns, the grid adds empty cells to the trailing edge of rows that have fewer columns. The example below creates three rows with different column counts:\n\nGrid {\n    GridRow {\n        Text(\"Row 1\")\n        ForEach(0..<2) { _ in Color.red }\n    }\n    GridRow {\n        Text(\"Row 2\")\n        ForEach(0..<5) { _ in Color.green }\n    }\n    GridRow {\n        Text(\"Row 3\")\n        ForEach(0..<4) { _ in Color.blue }\n    }\n}\n\n\nThe resulting grid has as many columns as the widest row, adding empty cells to rows that don\u2019t specify enough views:\n\nThe grid sets the width of all the cells in a column to match the needs of column\u2019s widest cell. In the example above, the width of the first column depends on the width of the widest Text view that the column contains. The other columns, which contain flexible Color views, share the remaining horizontal space offered by the grid\u2019s parent view equally.\n\nSimilarly, the tallest cell in a row sets the height of the entire row. The cells in the first column of the grid above need only the height required for each string, but the Color cells expand to equally share the total height available to the grid. As a result, the color cells determine the row heights.\n\nCell spacing and alignment\n\nYou can control the spacing between cells in both the horizontal and vertical dimensions and set a default alignment for the content in all the grid cells when you initialize the grid using the init(alignment:horizontalSpacing:verticalSpacing:content:) initializer. Consider a modified version of the previous example:\n\nGrid(alignment: .bottom, horizontalSpacing: 1, verticalSpacing: 1) {\n    // ...\n}\n\n\nThis configuration causes all of the cells to use bottom alignment \u2014 which only affects the text cells because the colors fill their cells completely \u2014 and it reduces the spacing between cells:\n\nYou can override the alignment of specific cells or groups of cells. For example, you can change the horizontal alignment of the cells in a column by adding the gridColumnAlignment(_:) modifier, or the vertical alignment of the cells in a row by configuring the row\u2019s init(alignment:content:) initializer. You can also align a single cell with the gridCellAnchor(_:) modifier.\n\nPerformance considerations\n\nA grid can size its rows and columns correctly because it renders all of its child views immediately. If your app exhibits poor performance when it first displays a large grid that appears inside a ScrollView, consider switching to a LazyVGrid or LazyHGrid instead.\n\nLazy grids render their cells when SwiftUI needs to display them, rather than all at once. This reduces the initial cost of displaying a large scrollable grid that\u2019s never fully visible, but also reduces the grid\u2019s ability to optimally lay out cells. Switch to a lazy grid only if profiling your code shows a worthwhile performance improvement.\n\nTopics\nCreating a grid\ninit(alignment: Alignment, horizontalSpacing: CGFloat?, verticalSpacing: CGFloat?, content: () -> Content)\nCreates a grid with the specified spacing, alignment, and child views.\nRelationships\nConforms To\nView\nConforms when Content conforms to View.\nSee Also\nStatically arranging views in two dimensions\nstruct GridRow\nA horizontal row in a two dimensional grid container.\nfunc gridCellColumns(Int) -> some View\nTells a view that acts as a cell in a grid to span the specified number of columns.\nfunc gridCellAnchor(UnitPoint) -> some View\nSpecifies a custom alignment anchor for a view that acts as a grid cell.\nfunc gridCellUnsizedAxes(Axis.Set) -> some View\nAsks grid layouts not to offer the view extra size in the specified axes.\nfunc gridColumnAlignment(HorizontalAlignment) -> some View\nOverrides the default horizontal alignment of the grid column that the view appears in."
    },
    {
        "title": "aspectRatio(_:contentMode:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/aspectratio(_:contentmode:)-771ow",
        "html": "Parameters\naspectRatio\n\nA size that specifies the ratio of width to height to use for the resulting view.\n\ncontentMode\n\nA flag indicating whether this view should fit or fill the parent context.\n\nReturn Value\n\nA view that constrains this view\u2019s dimensions to aspectRatio, using contentMode as its scaling algorithm.\n\nDiscussion\n\nUse aspectRatio(_:contentMode:) to constrain a view\u2019s dimensions to an aspect ratio specified by a CGSize.\n\nIf this view is resizable, the resulting view uses aspectRatio as its own aspect ratio. In this example, the purple ellipse has a 3:4 width-to-height ratio, and scales to fill its frame:\n\nEllipse()\n    .fill(Color.purple)\n    .aspectRatio(CGSize(width: 3, height: 4), contentMode: .fill)\n    .frame(width: 200, height: 200)\n    .border(Color(white: 0.75))\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "perspectiveRotationEffect(_:axis:anchor:anchorZ:perspective:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/perspectiverotationeffect(_:axis:anchor:anchorz:perspective:)",
        "html": "Parameters\nangle\n\nThe angle by which to rotate the view\u2019s content.\n\naxis\n\nThe axis of rotation, specified as a tuple with named elements for each of the three spatial dimensions.\n\nanchor\n\nA two dimensional unit point within the view about which to perform the rotation. The default value is center.\n\nanchorZ\n\nThe location on the z-axis around which to rotate the content. The default is 0.\n\nperspective\n\nThe relative vanishing point for the rotation. The default is 1.\n\nReturn Value\n\nA view with rotated content.\n\nDiscussion\n\nUse this method to create the effect of rotating a view in three dimensions around a specified axis of rotation. The modifier projects the rotated, two-dimensional content onto the original view\u2019s plane. Use the perspective input to control the renderer\u2019s vanishing point. The following example creates the appearance of rotating text 45\u02da about the y-axis:\n\nText(\"Rotation by passing an angle in degrees\")\n    .perspectiveRotationEffect(\n        .degrees(45),\n        axis: (x: 0.0, y: 1.0, z: 0.0),\n        anchor: .center,\n        anchorZ: 0,\n        perspective: 1)\n    .border(Color.gray)\n\n\nImportant\n\nTo truly rotate a view in three dimensions, use a 3D rotation modifier without a perspective input like rotation3DEffect(_:axis:anchor:).\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "rotationEffect(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/rotationeffect(_:anchor:)",
        "html": "Parameters\nangle\n\nThe angle by which to rotate the view.\n\nanchor\n\nA unit point within the view about which to perform the rotation. The default value is center.\n\nReturn Value\n\nA view with rotated content.\n\nDiscussion\n\nThis modifier rotates the view\u2019s content around the axis that points out of the xy-plane. It has no effect on the view\u2019s frame. The following code rotates text by 22\u02da and then draws a border around the modified view to show that the frame remains unchanged by the rotation modifier:\n\nText(\"Rotation by passing an angle in degrees\")\n    .rotationEffect(.degrees(22))\n    .border(Color.gray)\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "aspectRatio(_:contentMode:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/aspectratio(_:contentmode:)-6j7xz",
        "html": "Parameters\naspectRatio\n\nThe ratio of width to height to use for the resulting view. Use nil to maintain the current aspect ratio in the resulting view.\n\ncontentMode\n\nA flag that indicates whether this view fits or fills the parent context.\n\nReturn Value\n\nA view that constrains this view\u2019s dimensions to the aspect ratio of the given size using contentMode as its scaling algorithm.\n\nDiscussion\n\nUse aspectRatio(_:contentMode:) to constrain a view\u2019s dimensions to an aspect ratio specified by a CGFloat using the specified content mode.\n\nIf this view is resizable, the resulting view will have aspectRatio as its aspect ratio. In this example, the purple ellipse has a 3:4 width-to-height ratio, and scales to fit its frame:\n\nEllipse()\n    .fill(Color.purple)\n    .aspectRatio(0.75, contentMode: .fit)\n    .frame(width: 200, height: 200)\n    .border(Color(white: 0.75))\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "scaleEffect(x:y:z:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaleeffect(x:y:z:anchor:)",
        "html": "Parameters\nx\n\nThe horizontal scale factor for this view.\n\ny\n\nThe vertical scale factor for this view.\n\nz\n\nThe depth scale factor for this view.\n\nanchor\n\nThe anchor point about which to scale the view. Defaults to center.\n\nReturn Value\n\nA view that scales this view by x,y, and z.\n\nDiscussion\n\nThe original dimensions of the view are considered to be unchanged by scaling the contents. To change the dimensions of the view, use a modifier like frame() instead.\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "scaleEffect(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-689z7",
        "html": "Parameters\nscale\n\nThe scale factor for this view in each dimension.\n\nanchor\n\nThe anchor point about which to scale the view. Defaults to center.\n\nReturn Value\n\nA view that scales this view by scale.\n\nDiscussion\n\nThe original dimensions of the view are considered to be unchanged by scaling the contents. To change the dimensions of the view, use a modifier like frame() instead.\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "scaleEffect(x:y:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaleeffect(x:y:anchor:)",
        "html": "Parameters\nx\n\nAn amount that represents the horizontal amount to scale the view. The default value is 1.0.\n\ny\n\nAn amount that represents the vertical amount to scale the view. The default value is 1.0.\n\nanchor\n\nThe anchor point that indicates the starting position for the scale operation.\n\nDiscussion\n\nUse scaleEffect(x:y:anchor:) to apply a scaling transform to a view by a specific horizontal and vertical amount.\n\nImage(systemName: \"envelope.badge.fill\")\n    .resizable()\n    .frame(width: 100, height: 100, alignment: .center)\n    .foregroundColor(Color.red)\n    .scaleEffect(x: 0.5, y: 0.5, anchor: .bottomTrailing)\n    .border(Color.gray)\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "scaleEffect(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-7q7as",
        "html": "Parameters\nscale\n\nA CGSize that represents the horizontal and vertical amount to scale the view.\n\nanchor\n\nThe point with a default of center that defines the location within the view from which to apply the transformation.\n\nDiscussion\n\nUse scaleEffect(_:anchor:) to scale a view by applying a scaling transform of a specific size, specified by scale.\n\nImage(systemName: \"envelope.badge.fill\")\n    .resizable()\n    .frame(width: 100, height: 100, alignment: .center)\n    .foregroundColor(Color.red)\n    .scaleEffect(CGSize(x: 0.9, y: 1.3), anchor: .leading)\n    .border(Color.gray)\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "distortionEffect(_:maxSampleOffset:isEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/distortioneffect(_:maxsampleoffset:isenabled:)",
        "html": "Parameters\nshader\n\nThe shader to apply as a distortion effect.\n\nmaxSampleOffset\n\nThe maximum distance in each axis between the returned source pixel position and the destination pixel position, for all source pixels.\n\nisEnabled\n\nWhether the effect is enabled or not.\n\nReturn Value\n\nA new view that renders self with the shader applied as a distortion effect.\n\nDiscussion\n\nFor a shader function to act as a distortion effect it must have a function signature matching:\n\n[[ stitchable ]] float2 name(float2 position, args...)\n\n\nwhere position is the user-space coordinates of the destination pixel applied to the shader. args... should be compatible with the uniform arguments bound to shader. The function should return the user-space coordinates of the corresponding source pixel.\n\nImportant\n\nViews backed by AppKit or UIKit views may not render into the filtered layer. Instead, they log a warning and display a placeholder image to highlight the error.\n\nSee Also\nAccessing Metal shaders\nfunc colorEffect(Shader, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter effect on the color of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter on the raster layer created from self.\nstruct Shader\nA reference to a function in a Metal shader library, along with its bound uniform argument values.\nstruct ShaderFunction\nA reference to a function in a Metal shader library.\nstruct ShaderLibrary\nA Metal shader library."
    },
    {
        "title": "UnitPoint3D",
        "url": "https://developer.apple.com/documentation/swiftui/unitpoint3d",
        "html": "Overview\n\nUse a 3D unit point to represent a three-dimensional location in a view without having to know the view\u2019s rendered size. The point stores a value in each dimension that indicates the fraction of the view\u2019s size in that dimension \u2014 measured from the view\u2019s origin \u2014 where the point appears. For example, you can create a unit point that represents the center of any view by using the value 0.5 for each dimension:\n\nlet unitPoint = UnitPoint3D(x: 0.5, y: 0.5, z: 0.5)\n\n\nNote\n\nIf you need a two-dimensional unit point, use UnitPoint instead.\n\nTo project the unit point into the rendered view\u2019s coordinate space, multiply each component of the unit point with the corresponding component of the view\u2019s size:\n\nlet projectedPoint = Point3D(\n    x: unitPoint.x * size.width,\n    y: unitPoint.y * size.height,\n    z: unitPoint.z * size.depth\n)\n\n\nYou can perform this calculation yourself if you happen to know a view\u2019s size, or if you want to use a unit point for some custom purpose, but SwiftUI typically does this for you to carry out operations that you request, like when you rotate a view with the rotation3DEffect(_:anchor:) modifier and indicate the anchor point that you want to rotate the view around.\n\nYou can create custom unit points with explicit values, like the example above, or you can use one of the built-in unit points that SwiftUI provides, like zero, center, or topTrailing. The built-in values correspond to common anchor points that you might want to refer to, like the center of one of a view\u2019s edges.\n\nNote\n\nA unit point with one or more components outside the range [0, 1] projects to a point outside of the view.\n\nLayout direction\n\nWhen a person configures their device to use a left-to-right language like English, the system places the view\u2019s origin in its top-left-back corner, with positive x toward the right, positive y toward the bottom of the view, and positive z toward the front. In a right-to-left environment, the origin moves to the upper-right-back corner, and the positive x direction changes to be toward the left. You don\u2019t typically need to do anything to handle this change, because SwiftUI applies the change to all aspects of the system. For example, see the discussion about layout direction in HorizontalAlignment.\n\nIt\u2019s important to test your app for the different locales that you distribute your app in. For more information about the localization process, see Localization.\n\nTopics\nGetting the origin\nstatic let origin: UnitPoint3D\nThe origin of a view.\nstatic let zero: UnitPoint3D\nA 3D unit point with all components equal to zero.\nGetting top points\nstatic let topLeadingBack: UnitPoint3D\nA point that\u2019s in the top-leading-back corner of a view.\nstatic let topLeading: UnitPoint3D\nA point that\u2019s centered in the depth dimension on the top-leading edge of a view.\nstatic let topLeadingFront: UnitPoint3D\nA point that\u2019s in the top-leading-front corner of a view.\nstatic let topBack: UnitPoint3D\nA point that\u2019s centered horizontally on the top-back edge of a view.\nstatic let top: UnitPoint3D\nA point that\u2019s centered horizontally and in the depth dimension on the top face of a view.\nstatic let topFront: UnitPoint3D\nA point that\u2019s centered horizontally on the top-front edge of a view.\nstatic let topTrailingBack: UnitPoint3D\nA point that\u2019s in the top-trailing-back corner of a view.\nstatic let topTrailing: UnitPoint3D\nA point that\u2019s centered in the depth dimension on the top-trailing edge of a view.\nstatic let topTrailingFront: UnitPoint3D\nA point that\u2019s in the top-trailing-front corner of a view.\nGetting middle points\nstatic let leadingBack: UnitPoint3D\nA point that\u2019s centered vertically on the leading-back edge of a view.\nstatic let leading: UnitPoint3D\nA point that\u2019s centered vertically and in the depth dimension on the leading face of a view.\nstatic let leadingFront: UnitPoint3D\nA point that\u2019s centered vertically on the leading-front edge of a view.\nstatic let back: UnitPoint3D\nA point that\u2019s centered horizontally and vertically on the back face of a view.\nstatic let center: UnitPoint3D\nA point that\u2019s centered in a view.\nstatic let front: UnitPoint3D\nA point that\u2019s centered horizontally and vertically on the front face of a view.\nstatic let trailingBack: UnitPoint3D\nA point that\u2019s centered vertically on the trailing-back edge of a view.\nstatic let trailing: UnitPoint3D\nA point that\u2019s centered vertically and in the depth dimension on the trailing face of a view.\nstatic let trailingFront: UnitPoint3D\nA point that\u2019s centered vertically on the trailing-front edge of a view.\nGetting bottom points\nstatic let bottomLeadingBack: UnitPoint3D\nA point that\u2019s in the bottom-leading-back corner of a view.\nstatic let bottomLeading: UnitPoint3D\nA point that\u2019s centered in the depth dimension on the bottom-leading edge of a view.\nstatic let bottomLeadingFront: UnitPoint3D\nA point that\u2019s in the bottom-leading-front corner of a view.\nstatic let bottomBack: UnitPoint3D\nA point that\u2019s centered horizontally on the bottom-back edge of a view.\nstatic let bottom: UnitPoint3D\nA point that\u2019s centered horizontally and in the depth dimension on the bottom face of a view.\nstatic let bottomFront: UnitPoint3D\nA point that\u2019s centered horizontally on the bottom-front edge of a view.\nstatic let bottomTrailingBack: UnitPoint3D\nA point that\u2019s in the bottom-trailing-back corner of a view.\nstatic let bottomTrailing: UnitPoint3D\nA point that\u2019s centered in the depth dimension on the bottom-trailing edge of a view.\nstatic let bottomTrailingFront: UnitPoint3D\nA point that\u2019s in the bottom-trailing-front corner of a view.\nCreating a point\ninit()\nCreates a 3D unit point at the origin.\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\nCreates a 3D unit point with the specified offsets.\nGetting the point\u2019s coordinates\nvar x: CGFloat\nThe normalized distance from the origin to the point in the horizontal direction.\nvar y: CGFloat\nThe normalized distance from the origin to the point in the vertical dimension.\nvar z: CGFloat\nThe normalized distance from the origin to the point in the depth dimension.\nRelationships\nConforms To\nAnimatable\nDecodable\nEncodable\nEquatable\nHashable\nSendable\nSee Also\nAccessing geometric constructs\nenum Axis\nThe horizontal or vertical dimension in a 2D coordinate system.\nstruct Angle\nA geometric angle whose value you access in either radians or degrees.\nstruct UnitPoint\nA normalized 2D point in a view\u2019s coordinate space.\nstruct Anchor\nAn opaque value derived from an anchor source and a particular view."
    },
    {
        "title": "GraphicsContext",
        "url": "https://developer.apple.com/documentation/swiftui/graphicscontext",
        "html": "Overview\n\nUse a context to execute 2D drawing primitives. For example, you can draw filled shapes using the fill(_:with:style:) method inside a Canvas view:\n\nCanvas { context, size in\n    context.fill(\n        Path(ellipseIn: CGRect(origin: .zero, size: size)),\n        with: .color(.green))\n}\n.frame(width: 300, height: 200)\n\n\nThe example above draws an ellipse that just fits inside a canvas that\u2019s constrained to 300 points wide and 200 points tall:\n\nIn addition to outlining or filling paths, you can draw images, text, and SwiftUI views. You can also use the context to perform many common graphical operations, like adding masks, applying filters and transforms, and setting a blend mode. For example you can add a mask using the clip(to:style:options:) method:\n\nlet halfSize = size.applying(CGAffineTransform(scaleX: 0.5, y: 0.5))\ncontext.clip(to: Path(CGRect(origin: .zero, size: halfSize)))\ncontext.fill(\n    Path(ellipseIn: CGRect(origin: .zero, size: size)),\n    with: .color(.green))\n\n\nThe rectangular mask hides all but one quadrant of the ellipse:\n\nThe order of operations matters. Changes that you make to the state of the context, like adding a mask or a filter, apply to later drawing operations. If you reverse the fill and clip operations in the example above, so that the fill comes first, the mask doesn\u2019t affect the ellipse.\n\nEach context references a particular layer in a tree of transparency layers, and also contains a full copy of the drawing state. You can modify the state of one context without affecting the state of any other, even if they refer to the same layer. For example you can draw the masked ellipse from the previous example into a copy of the main context, and then add a rectangle into the main context:\n\n// Create a copy of the context to draw a clipped ellipse.\nvar maskedContext = context\nlet halfSize = size.applying(CGAffineTransform(scaleX: 0.5, y: 0.5))\nmaskedContext.clip(to: Path(CGRect(origin: .zero, size: halfSize)))\nmaskedContext.fill(\n    Path(ellipseIn: CGRect(origin: .zero, size: size)),\n    with: .color(.green))\n\n\n// Go back to the original context to draw the rectangle.\nlet origin = CGPoint(x: size.width / 4, y: size.height / 4)\ncontext.fill(\n    Path(CGRect(origin: origin, size: halfSize)),\n    with: .color(.blue))\n\n\nThe mask doesn\u2019t clip the rectangle because the mask isn\u2019t part of the main context. However, both contexts draw into the same view because you created one context as a copy of the other:\n\nThe context has access to an EnvironmentValues instance called environment that\u2019s initially copied from the environment of its enclosing view. SwiftUI uses environment values \u2014 like the display resolution and color scheme \u2014 to resolve types like Image and Color that appear in the context. You can also access values stored in the environment for your own purposes.\n\nTopics\nDrawing a path\nfunc stroke(Path, with: GraphicsContext.Shading, lineWidth: CGFloat)\nDraws a path into the context with a specified line width.\nfunc stroke(Path, with: GraphicsContext.Shading, style: StrokeStyle)\nDraws a path into the context with a specified stroke style.\nfunc fill(Path, with: GraphicsContext.Shading, style: FillStyle)\nDraws a path into the context and fills the outlined region.\nfunc resolve(GraphicsContext.Shading) -> GraphicsContext.Shading\nReturns a version of a shading resolved with the current values of the graphics context\u2019s environment.\nstruct Shading\nA color or pattern that you can use to outline or fill a path.\nstruct GradientOptions\nOptions that affect the rendering of color gradients.\nDrawing an image\nfunc draw(Image, at: CGPoint, anchor: UnitPoint)\nDraws an image into the context, aligning an anchor within the image to a point in the context.\nfunc draw(Image, in: CGRect, style: FillStyle)\nDraws an image into the context, using the specified rectangle as a layout frame.\nfunc draw(GraphicsContext.ResolvedImage, at: CGPoint, anchor: UnitPoint)\nDraws a resolved image into the context, aligning an anchor within the image to a point in the context.\nfunc draw(GraphicsContext.ResolvedImage, in: CGRect, style: FillStyle)\nDraws a resolved image into the context, using the specified rectangle as a layout frame.\nfunc resolve(Image) -> GraphicsContext.ResolvedImage\nGets a version of an image that\u2019s fixed with the current values of the graphics context\u2019s environment.\nstruct ResolvedImage\nAn image resolved to a particular environment.\nDrawing text\nfunc draw(Text, at: CGPoint, anchor: UnitPoint)\nDraws text into the context, aligning an anchor within the ideal size of the rendered text to a point in the context.\nfunc draw(Text, in: CGRect)\nDraws text into the context using the specified rectangle as a layout frame.\nfunc draw(GraphicsContext.ResolvedText, at: CGPoint, anchor: UnitPoint)\nDraws resolved text into the context, aligning an anchor within the ideal size of the text to a point in the context.\nfunc draw(GraphicsContext.ResolvedText, in: CGRect)\nDraws resolved text into the context using the specified rectangle as a layout frame.\nfunc resolve(Text) -> GraphicsContext.ResolvedText\nGets a version of a text view that\u2019s fixed with the current values of the graphics context\u2019s environment.\nstruct ResolvedText\nA text view resolved to a particular environment.\nDrawing a child view\nfunc draw(GraphicsContext.ResolvedSymbol, at: CGPoint, anchor: UnitPoint)\nDraws a resolved symbol into the context, aligning an anchor within the symbol to a point in the context.\nfunc draw(GraphicsContext.ResolvedSymbol, in: CGRect)\nDraws a resolved symbol into the context, using the specified rectangle as a layout frame.\nfunc resolveSymbol<ID>(id: ID) -> GraphicsContext.ResolvedSymbol?\nGets the identified child view as a resolved symbol, if the view exists.\nstruct ResolvedSymbol\nA static sequence of drawing operations that may be drawn multiple times, preserving their resolution independence.\nDrawing into a new layer\nfunc drawLayer(content: (inout GraphicsContext) throws -> Void) rethrows\nDraws a new layer, created by drawing code that you provide, into the context.\nMasking\nfunc clip(to: Path, style: FillStyle, options: GraphicsContext.ClipOptions)\nAdds a path to the context\u2019s array of clip shapes.\nfunc clipToLayer(opacity: Double, options: GraphicsContext.ClipOptions, content: (inout GraphicsContext) throws -> Void) rethrows\nAdds a clip shape that you define in a new layer to the context\u2019s array of clip shapes.\nvar clipBoundingRect: CGRect\nThe bounding rectangle of the intersection of all current clip shapes in the current user space.\nstruct ClipOptions\nOptions that affect the use of clip shapes.\nSetting opacity and the blend mode\nvar opacity: Double\nThe opacity of drawing operations in the context.\nvar blendMode: GraphicsContext.BlendMode\nThe blend mode used by drawing operations in the context.\nstruct BlendMode\nThe ways that a graphics context combines new content with background content.\nFiltering\nfunc addFilter(GraphicsContext.Filter, options: GraphicsContext.FilterOptions)\nAdds a filter that applies to subsequent drawing operations.\nstruct Filter\nA type that applies image processing operations to rendered content.\nstruct FilterOptions\nOptions that configure a filter that you add to a graphics context.\nstruct BlurOptions\nOptions that configure the graphics context filter that creates blur.\nstruct ShadowOptions\nOptions that configure the graphics context filter that creates shadows.\nApplying transforms\nfunc scaleBy(x: CGFloat, y: CGFloat)\nScales subsequent drawing operations by an amount in each dimension.\nfunc rotate(by: Angle)\nRotates subsequent drawing operations by an angle.\nfunc translateBy(x: CGFloat, y: CGFloat)\nMoves subsequent drawing operations by an amount in each dimension.\nfunc concatenate(CGAffineTransform)\nAppends the given transform to the context\u2019s existing transform.\nvar transform: CGAffineTransform\nThe current transform matrix, defining user space coordinates.\nDrawing with a core graphics context\nfunc withCGContext(content: (CGContext) throws -> Void) rethrows\nProvides a Core Graphics context that you can use as a proxy to draw into this context.\nAccessing the environment\nvar environment: EnvironmentValues\nThe environment associated with the graphics context.\nSee Also\nImmediate mode drawing\nstruct Canvas\nA view type that supports immediate mode drawing."
    },
    {
        "title": "scaleEffect(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-5rqwl",
        "html": "Parameters\ns\n\nThe scale factor for this view.\n\nanchor\n\nThe anchor point about which to scale the view. Defaults to center.\n\nReturn Value\n\nA view that scales this view by s in all dimensions.\n\nDiscussion\n\nThe original dimensions of the view are considered to be unchanged by scaling the contents. To change the dimensions of the view, use a modifier like frame() instead.\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "Shader",
        "url": "https://developer.apple.com/documentation/swiftui/shader",
        "html": "Overview\n\nShader values can be used as filter effects on views, see the colorEffect(_:isEnabled:), distortionEffect(_:maxSampleOffset:isEnabled:), and layerEffect(_:maxSampleOffset:isEnabled:) functions.\n\nShaders also conform to the ShapeStyle protocol, letting their MSL shader function provide per-pixel color to fill any shape or text view. For a shader function to act as a fill pattern it must have a function signature matching:\n\n[[ stitchable ]] half4 name(float2 position, args...)\n\n\nwhere position is the user-space coordinates of the pixel applied to the shader, and args... should be compatible with the uniform arguments bound to shader. The function should return the premultiplied color value in the color space of the destination (typically extended sRGB).\n\nTopics\nCreating a shader\ninit(function: ShaderFunction, arguments: [Shader.Argument])\nCreates a new shader from a function and the uniform argument values to bind to the function.\nstruct Argument\nA single uniform argument value to a shader function.\nGetting the shader function\nvar function: ShaderFunction\nThe shader function called by the shader.\nvar arguments: [Shader.Argument]\nThe uniform argument values passed to the shader function.\nConfiguring the shader\nvar dithersColor: Bool\nFor shader functions that return color values, whether the returned color has dither noise added to it, or is simply rounded to the output bit-depth. For shaders generating smooth gradients, dithering is usually necessary to prevent visible banding in the result.\nRelationships\nConforms To\nEquatable\nSendable\nShapeStyle\nSee Also\nAccessing Metal shaders\nfunc colorEffect(Shader, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter effect on the color of each pixel.\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a geometric distortion effect on the location of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter on the raster layer created from self.\nstruct ShaderFunction\nA reference to a function in a Metal shader library.\nstruct ShaderLibrary\nA Metal shader library."
    },
    {
        "title": "ShaderLibrary",
        "url": "https://developer.apple.com/documentation/swiftui/shaderlibrary",
        "html": "Topics\nGetting the default shader library\nstatic let `default`: ShaderLibrary\nThe default shader library of the main (i.e. app) bundle.\nstatic func bundle(Bundle) -> ShaderLibrary\nReturns the default shader library of the specified bundle.\nCreating a shader library\ninit(url: URL)\nCreates a new Metal shader library from the contents of url, which must be the location of precompiled Metal library. Functions compiled from the returned library will only be cached as long as the returned library exists.\ninit(data: Data)\nCreates a new Metal shader library from data, which must be the contents of precompiled Metal library. Functions compiled from the returned library will only be cached as long as the returned library exists.\nAccess shader functions\nstatic subscript(dynamicMember _: String) -> ShaderFunction\nReturns a new shader function representing the stitchable MSL function called name in the default shader library.\nSubscripts\nsubscript(dynamicMember _: String) -> ShaderFunction\nReturns a new shader function representing the stitchable MSL function in the library called name.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nAccessing Metal shaders\nfunc colorEffect(Shader, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter effect on the color of each pixel.\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a geometric distortion effect on the location of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter on the raster layer created from self.\nstruct Shader\nA reference to a function in a Metal shader library, along with its bound uniform argument values.\nstruct ShaderFunction\nA reference to a function in a Metal shader library."
    },
    {
        "title": "border(_:width:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/border(_:width:)",
        "html": "Parameters\ncontent\n\nA value that conforms to the ShapeStyle protocol, like a Color or HierarchicalShapeStyle, that SwiftUI uses to fill the border.\n\nwidth\n\nThe thickness of the border. The default is 1 pixel.\n\nReturn Value\n\nA view that adds a border with the specified style and width to this view.\n\nDiscussion\n\nUse this modifier to draw a border of a specified width around the view\u2019s frame. By default, the border appears inside the bounds of this view. For example, you can add a four-point wide border covers the text:\n\nText(\"Purple border inside the view bounds.\")\n    .border(Color.purple, width: 4)\n\n\nTo place a border around the outside of this view, apply padding of the same width before adding the border:\n\nText(\"Purple border outside the view bounds.\")\n    .padding(4)\n    .border(Color.purple, width: 4)\n\n\nSee Also\nStyling content\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "scaleEffect(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-pmi7",
        "html": "Parameters\ns\n\nThe amount to scale the view in the view in both the horizontal and vertical directions.\n\nanchor\n\nThe anchor point with a default of center that indicates the starting position for the scale operation.\n\nDiscussion\n\nUse scaleEffect(_:anchor:) to apply a horizontally and vertically scaling transform to a view.\n\nImage(systemName: \"envelope.badge.fill\")\n    .resizable()\n    .frame(width: 100, height: 100, alignment: .center)\n    .foregroundColor(Color.red)\n    .scaleEffect(2, anchor: .leading)\n    .border(Color.gray)\n\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "ShaderFunction",
        "url": "https://developer.apple.com/documentation/swiftui/shaderfunction",
        "html": "Topics\nCreating a shader function\ninit(library: ShaderLibrary, name: String)\nCreates a new function reference from the provided shader library and function name string.\nConfiguring a function\nvar library: ShaderLibrary\nThe shader library storing the function.\nvar name: String\nThe name of the shader function in the library.\nfunc dynamicallyCall(withArguments: [Shader.Argument]) -> Shader\nReturns a new shader by applying the provided argument values to the referenced function.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nAccessing Metal shaders\nfunc colorEffect(Shader, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter effect on the color of each pixel.\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a geometric distortion effect on the location of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter on the raster layer created from self.\nstruct Shader\nA reference to a function in a Metal shader library, along with its bound uniform argument values.\nstruct ShaderLibrary\nA Metal shader library."
    },
    {
        "title": "BlendMode",
        "url": "https://developer.apple.com/documentation/swiftui/blendmode",
        "html": "Topics\nGetting the default\ncase normal\nDarkening\ncase darken\ncase multiply\ncase colorBurn\ncase plusDarker\nLightening\ncase lighten\ncase screen\ncase colorDodge\ncase plusLighter\nAdding contrast\ncase overlay\ncase softLight\ncase hardLight\nInverting\ncase difference\ncase exclusion\nMixing color components\ncase hue\ncase saturation\ncase color\ncase luminosity\nAccessing porter-duff modes\ncase sourceAtop\ncase destinationOver\ncase destinationOut\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCompositing views\nfunc blendMode(BlendMode) -> some View\nSets the blend mode for compositing this view with overlapping views.\nfunc compositingGroup() -> some View\nWraps this view in a compositing group.\nfunc drawingGroup(opaque: Bool, colorMode: ColorRenderingMode) -> some View\nComposites this view\u2019s contents into an offscreen image before final display.\nenum ColorRenderingMode\nThe set of possible working color spaces for color-compositing operations."
    },
    {
        "title": "foregroundStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/foregroundstyle(_:)",
        "html": "Parameters\nstyle\n\nThe color or pattern to use when filling in the foreground elements. To indicate a specific value, use Color or image(_:sourceRect:scale:), or one of the gradient types, like linearGradient(colors:startPoint:endPoint:). To set a style that\u2019s relative to the containing view\u2019s style, use one of the semantic styles, like primary.\n\nReturn Value\n\nA view that uses the given foreground style.\n\nDiscussion\n\nUse this method to style foreground content like text, shapes, and template images (including symbols):\n\nHStack {\n    Image(systemName: \"triangle.fill\")\n    Text(\"Hello, world!\")\n    RoundedRectangle(cornerRadius: 5)\n        .frame(width: 40, height: 20)\n}\n.foregroundStyle(.teal)\n\n\nThe example above creates a row of teal foreground elements:\n\nYou can use any style that conforms to the ShapeStyle protocol, like the teal color in the example above, or the linearGradient(colors:startPoint:endPoint:) gradient shown below:\n\nText(\"Gradient Text\")\n    .font(.largeTitle)\n    .foregroundStyle(\n        .linearGradient(\n            colors: [.yellow, .blue],\n            startPoint: .top,\n            endPoint: .bottom\n        )\n    )\n\n\nTip\n\nIf you want to fill a single Shape instance with a style, use the fill(style:) shape modifier instead because it\u2019s more efficient.\n\nSwiftUI creates a context-dependent render for a given style. For example, a Color that you load from an asset catalog can have different light and dark appearances, while some styles also vary by platform.\n\nHierarchical foreground styles like ShapeStyle/secondary don\u2019t impose a style of their own, but instead modify other styles. In particular, they modify the primary level of the current foreground style to the degree given by the hierarchical style\u2019s name. To find the current foreground style to modify, SwiftUI looks for the innermost containing style that you apply with the foregroundStyle(_:) or the foregroundColor(_:) modifier. If you haven\u2019t specified a style, SwiftUI uses the default foreground style, as in the following example:\n\nVStack(alignment: .leading) {\n    Label(\"Primary\", systemImage: \"1.square.fill\")\n    Label(\"Secondary\", systemImage: \"2.square.fill\")\n        .foregroundStyle(.secondary)\n}\n\n\nIf you add a foreground style on the enclosing VStack, the hierarchical styling responds accordingly:\n\nVStack(alignment: .leading) {\n    Label(\"Primary\", systemImage: \"1.square.fill\")\n    Label(\"Secondary\", systemImage: \"2.square.fill\")\n        .foregroundStyle(.secondary)\n}\n.foregroundStyle(.blue)\n\n\nWhen you apply a custom style to a view, the view disables the vibrancy effect for foreground elements in that view, or in any of its child views, that it would otherwise gain from adding a background material \u2014 for example, using the background(_:ignoresSafeAreaEdges:) modifier. However, hierarchical styles applied to the default foreground don\u2019t disable vibrancy.\n\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "saturation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/saturation(_:)",
        "html": "Parameters\namount\n\nThe amount of saturation to apply to this view.\n\nReturn Value\n\nA view that adjusts the saturation of this view.\n\nDiscussion\n\nUse color saturation to increase or decrease the intensity of colors in a view.\n\nThe example below shows a series of red squares with their saturation increasing from 0 (gray) to 100% (fully-red) in 20% increments:\n\nstruct Saturation: View {\n    var body: some View {\n        HStack {\n            ForEach(0..<6) {\n                Color.red.frame(width: 60, height: 60, alignment: .center)\n                    .saturation(Double($0) * 0.2)\n                    .overlay(Text(\"\\(Double($0) * 0.2 * 100, specifier: \"%.0f\")%\"),\n                             alignment: .bottom)\n                    .border(Color.gray)\n            }\n        }\n    }\n}\n\n\nSee Also\n\ncontrast(_:)\n\nSee Also\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view."
    },
    {
        "title": "foregroundStyle(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/foregroundstyle(_:_:)",
        "html": "Parameters\nprimary\n\nThe primary color or pattern to use when filling in the foreground elements. To indicate a specific value, use Color or image(_:sourceRect:scale:), or one of the gradient types, like linearGradient(colors:startPoint:endPoint:). To set a style that\u2019s relative to the containing view\u2019s style, use one of the semantic styles, like primary.\n\nsecondary\n\nThe secondary color or pattern to use when filling in the foreground elements.\n\nReturn Value\n\nA view that uses the given foreground styles.\n\nDiscussion\n\nSwiftUI uses these styles when rendering child views that don\u2019t have an explicit rendering style, like images, text, shapes, and so on.\n\nSymbol images within the view hierarchy use the palette rendering mode when you apply this modifier, if you don\u2019t explicitly specify another mode.\n\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "GeometryProxy",
        "url": "https://developer.apple.com/documentation/swiftui/geometryproxy",
        "html": "Topics\nAccessing geometry characteristics\nfunc bounds(of: NamedCoordinateSpace) -> CGRect?\nReturns the given coordinate space\u2019s bounds rectangle, converted to the local coordinate space.\nfunc frame(in: CoordinateSpace) -> CGRect\nReturns the container view\u2019s bounds rectangle, converted to a defined coordinate space.\nfunc frame(in: some CoordinateSpaceProtocol) -> CGRect\nReturns the container view\u2019s bounds rectangle, converted to a defined coordinate space.\nvar size: CGSize\nThe size of the container view.\nvar safeAreaInsets: EdgeInsets\nThe safe area inset of the container view.\nsubscript<T>(Anchor<T>) -> T\nResolves the value of an anchor to the container view.\nfunc transform(in: some CoordinateSpaceProtocol) -> AffineTransform3D?\nThe container view\u2019s 3D transform converted to a defined coordinate space.\nBeta\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "backgroundStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/backgroundstyle(_:)",
        "html": "Discussion\n\nThe following example uses this modifier to set the backgroundStyle environment value to a blue color that includes a subtle gradient. SwiftUI fills the Circle shape that acts as a background element with this style:\n\nImage(systemName: \"swift\")\n    .padding()\n    .background(in: Circle())\n    .backgroundStyle(.blue.gradient)\n\n\nTo restore the default background style, set the backgroundStyle environment value to nil using the environment(_:_:) modifer:\n\n.environment(\\.backgroundStyle, nil)\n\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "foregroundStyle(_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/foregroundstyle(_:_:_:)",
        "html": "Parameters\nprimary\n\nThe primary color or pattern to use when filling in the foreground elements. To indicate a specific value, use Color or image(_:sourceRect:scale:), or one of the gradient types, like linearGradient(colors:startPoint:endPoint:). To set a style that\u2019s relative to the containing view\u2019s style, use one of the semantic styles, like primary.\n\nsecondary\n\nThe secondary color or pattern to use when filling in the foreground elements.\n\ntertiary\n\nThe tertiary color or pattern to use when filling in the foreground elements.\n\nReturn Value\n\nA view that uses the given foreground styles.\n\nDiscussion\n\nSwiftUI uses these styles when rendering child views that don\u2019t have an explicit rendering style, like images, text, shapes, and so on.\n\nSymbol images within the view hierarchy use the palette rendering mode when you apply this modifier, if you don\u2019t explicitly specify another mode.\n\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "Axis",
        "url": "https://developer.apple.com/documentation/swiftui/axis",
        "html": "Topics\nGetting axes\ncase horizontal\nThe horizontal dimension.\ncase vertical\nThe vertical dimension.\nGetting all axes\nstruct Set\nAn efficient set of axes.\nRelationships\nConforms To\nCaseIterable\nCustomStringConvertible\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nAccessing geometric constructs\nstruct Angle\nA geometric angle whose value you access in either radians or degrees.\nstruct UnitPoint\nA normalized 2D point in a view\u2019s coordinate space.\nstruct UnitPoint3D\nA normalized 3D point in a view\u2019s coordinate space.\nBeta\nstruct Anchor\nAn opaque value derived from an anchor source and a particular view."
    },
    {
        "title": "tint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tint(_:)-23xyq",
        "html": "Parameters\ntint\n\nThe tint Color to apply.\n\nDiscussion\n\nUse this method to override the default accent color for this view. Unlike an app\u2019s accent color, which can be overridden by user preference, the tint color is always respected and should be used as a way to provide additional meaning to the control.\n\nThis example shows Answer and Decline buttons with green and red tint colors, respectively.\n\nstruct ControlTint: View {\n    var body: some View {\n        HStack {\n            Button {\n                // Answer the call\n            } label: {\n                Label(\"Answer\", systemImage: \"phone\")\n            }\n            .tint(.green)\n            Button {\n                // Decline the call\n            } label: {\n                Label(\"Decline\", systemImage: \"phone.down\")\n            }\n            .tint(.red)\n        }\n        .padding()\n    }\n}\n\nSee Also\nSetting a color\nfunc tint<S>(S?) -> some View\nSets the tint within this view.\nstruct Color\nA representation of a color that adapts to a given context."
    },
    {
        "title": "colorEffect(_:isEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/coloreffect(_:isenabled:)",
        "html": "Parameters\nshader\n\nThe shader to apply to self as a color filter.\n\nisEnabled\n\nWhether the effect is enabled or not.\n\nReturn Value\n\nA new view that renders self with the shader applied as a color filter.\n\nDiscussion\n\nFor a shader function to act as a color filter it must have a function signature matching:\n\n[[ stitchable ]] half4 name(float2 position, half4 color, args...)\n\n\nwhere position is the user-space coordinates of the pixel applied to the shader and color its source color, as a pre-multiplied color in the destination color space. args... should be compatible with the uniform arguments bound to shader. The function should return the modified color value.\n\nImportant\n\nViews backed by AppKit or UIKit views may not render into the filtered layer. Instead, they log a warning and display a placeholder image to highlight the error.\n\nSee Also\nAccessing Metal shaders\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a geometric distortion effect on the location of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter on the raster layer created from self.\nstruct Shader\nA reference to a function in a Metal shader library, along with its bound uniform argument values.\nstruct ShaderFunction\nA reference to a function in a Metal shader library.\nstruct ShaderLibrary\nA Metal shader library."
    },
    {
        "title": "CoordinateSpace",
        "url": "https://developer.apple.com/documentation/swiftui/coordinatespace",
        "html": "Overview\n\nYou don\u2019t typically use CoordinateSpace directly. Instead, use the static properties and functions of CoordinateSpaceProtocol such as .global, .local, and .named(_:).\n\nTopics\nGetting coordinate spaces\ncase global\nThe global coordinate space at the root of the view hierarchy.\ncase local\nThe local coordinate space of the current view.\ncase named(AnyHashable)\nA named reference to a view\u2019s local coordinate space.\nTesting a space\nvar isGlobal: Bool\nvar isLocal: Bool\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "GeometryReader3D",
        "url": "https://developer.apple.com/documentation/swiftui/geometryreader3d",
        "html": "Overview\n\nThis view returns a flexible preferred size to its own container view.\n\nThis container differs from GeometryReader in that it also reads available depth, and thus also returns a flexible preferred depth to its parent layout. Use the 3D version only in situations where you need to read depth, because it affects depth layout when used in a container like a ZStack.\n\nTopics\nCreating a geometry reader\ninit(content: (GeometryProxy3D) -> Content)\nvar content: (GeometryProxy3D) -> Content\nRelationships\nConforms To\nView\nSee Also\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "tint(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tint(_:)-93mfq",
        "html": "Parameters\ntint\n\nThe tint to apply.\n\nDiscussion\n\nUse this method to override the default accent color for this view with a given styling. Unlike an app\u2019s accent color, which can be overridden by user preference, tint is always respected and should be used as a way to provide additional meaning to the control.\n\nControls which are unable to style themselves using the given type of ShapeStyle will try to approximate the styling as best as they can (i.e. controls which can not style themselves using a gradient will attempt to use the color of the gradient\u2019s first stop).\n\nThis example shows a linear dashboard styled gauge tinted with a gradient from green to red.\n\nstruct ControlTint: View {\n    var body: some View {\n        Gauge(value: 75, in: 0...100)\n            .gaugeStyle(.linearDashboard)\n            .tint(Gradient(colors: [.red, .yellow, .green]))\n    }\n}\n\nSee Also\nSetting a color\nfunc tint(Color?) -> some View\nSets the tint color within this view.\nstruct Color\nA representation of a color that adapts to a given context."
    },
    {
        "title": "Add Rich Graphics to Your SwiftUI App",
        "url": "https://developer.apple.com/documentation/swiftui/add_rich_graphics_to_your_swiftui_app",
        "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC21 session 10021: Add Rich Graphics to Your SwiftUI App."
    },
    {
        "title": "GeometryReader",
        "url": "https://developer.apple.com/documentation/swiftui/geometryreader",
        "html": "Overview\n\nThis view returns a flexible preferred size to its parent layout.\n\nTopics\nCreating a geometry reader\ninit(content: (GeometryProxy) -> Content)\nvar content: (GeometryProxy) -> Content\nRelationships\nConforms To\nView\nSee Also\nMeasuring a view\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta"
    },
    {
        "title": "lineLimit",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/linelimit",
        "html": "Discussion\n\nThe maximum number of lines is 1 if the value is less than 1. If the value is nil, the text uses as many lines as required. The default is nil.\n\nSee Also\nLimiting line count for multiline text\nfunc lineLimit(Int?) -> some View\nSets the maximum number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeFrom<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeThrough<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(ClosedRange<Int>) -> some View\nSets to a closed range the number of lines that text can occupy in this view.\nfunc lineLimit(Int, reservesSpace: Bool) -> some View\nSets a limit for the number of lines text can occupy in this view."
    },
    {
        "title": "menuOrder",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/menuorder",
        "html": "Discussion\n\nSet this value for a view hierarchy by calling the menuOrder(_:) view modifier.\n\nSee Also\nSetting a preferred order\nfunc menuOrder(MenuOrder) -> some View\nSets the preferred order of items for menus presented from this view.\nstruct MenuOrder\nThe order in which a menu presents its content."
    },
    {
        "title": "lineLimit(_:reservesSpace:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/linelimit(_:reservesspace:)",
        "html": "Parameters\nlimit\n\nThe line limit.\n\nreservesSpace\n\nWhether text reserves space so that it always occupies the height required to display the specified number of lines.\n\nDiscussion\n\nUse this modifier to specify a limit to the lines that a Text or a vertical TextField may occupy. If passed a value of true for the reservesSpace parameter, and the text of such views occupies less space than the provided limit, that view expands to occupy the minimum number of lines. When the text occupies more space than the provided limit, a Text view truncates its content while a TextField becomes scrollable.\n\nGroupBox {\n    Text(\"Title\")\n        .font(.headline)\n        .lineLimit(2, reservesSpace: true)\n    Text(\"Subtitle\")\n        .font(.subheadline)\n        .lineLimit(4, reservesSpace: true)\n}\n\nSee Also\nLimiting line count for multiline text\nfunc lineLimit(Int?) -> some View\nSets the maximum number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeFrom<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeThrough<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(ClosedRange<Int>) -> some View\nSets to a closed range the number of lines that text can occupy in this view.\nvar lineLimit: Int?\nThe maximum number of lines that text can occupy in a view."
    },
    {
        "title": "MenuButton",
        "url": "https://developer.apple.com/documentation/swiftui/menubutton",
        "html": "Deprecated\n\nUse Menu instead.\n\nTopics\nCreating a menu button\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu button with the specified localized title and content.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a menu button with the specified title and content.\nAvailable when Label is Text and Content conforms to View.\ninit(label: Label, content: () -> Content)\nCreates a menu button with the specified label and content.\nStyling a menu button\nfunc menuButtonStyle<S>(S) -> some View\nSets the style for menu buttons within this view.\nprotocol MenuButtonStyle\nA custom specification for the appearance and interaction of a menu button.\nRelationships\nConforms To\nView\nSee Also\nDeprecated types\ntypealias PullDownButton\nDeprecated\nstruct ContextMenu\nA container for views that you present as menu items in a context menu.\nDeprecated"
    },
    {
        "title": "menuIndicatorVisibility",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/menuindicatorvisibility",
        "html": "Discussion\n\nNote\n\nOn tvOS, the standard button styles do not include a menu indicator, so this modifier will have no effect when using a built-in button style. You can implement an indicator in your own ButtonStyle implementation by checking the value of this environment value.\n\nSee Also\nShowing a menu indicator\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view."
    },
    {
        "title": "ImportFromDevicesCommands",
        "url": "https://developer.apple.com/documentation/swiftui/importfromdevicescommands",
        "html": "Overview\n\nThis set of commands adds items based on nearby devices and capabilities, like taking photos or scanning documents. Views can receive imported content from these menu items by using the importsItemProviders(_:onImport:) modifier.\n\nThese commands are optional and you can explicitly request them by passing a value of this type to the commands(content:) modifier.\n\nTopics\nCreating the command group\ninit()\nCreates a new set of device import commands.\nRelationships\nConforms To\nCommands\nSee Also\nGetting built-in command groups\nstruct SidebarCommands\nA built-in set of commands for manipulating window sidebars.\nstruct TextEditingCommands\nA built-in group of commands for searching, editing, and transforming selections of text.\nstruct TextFormattingCommands\nA built-in set of commands for transforming the styles applied to selections of text.\nstruct ToolbarCommands\nA built-in set of commands for manipulating window toolbars.\nstruct InspectorCommands\nA built-in set of commands for manipulating inspectors.\nstruct EmptyCommands\nAn empty group of commands."
    },
    {
        "title": "overlay(alignment:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/overlay(alignment:content:)",
        "html": "Parameters\nalignment\n\nThe alignment that the modifier uses to position the implicit ZStack that groups the foreground views. The default is center.\n\ncontent\n\nA ViewBuilder that you use to declare the views to draw in front of this view, stacked in the order that you list them. The last view that you list appears at the front of the stack.\n\nReturn Value\n\nA view that uses the specified content as a foreground.\n\nDiscussion\n\nUse this modifier to place one or more views in front of another view. For example, you can place a group of stars on a RoundedRectangle:\n\nRoundedRectangle(cornerRadius: 8)\n    .frame(width: 200, height: 100)\n    .overlay(alignment: .topLeading) { Star(color: .red) }\n    .overlay(alignment: .topTrailing) { Star(color: .yellow) }\n    .overlay(alignment: .bottomLeading) { Star(color: .green) }\n    .overlay(alignment: .bottomTrailing) { Star(color: .blue) }\n\n\nThe example above assumes that you\u2019ve defined a Star view with a parameterized color:\n\nstruct Star: View {\n    var color = Color.yellow\n\n\n    var body: some View {\n        Image(systemName: \"star.fill\")\n            .foregroundStyle(color)\n    }\n}\n\n\nBy setting different alignment values for each modifier, you make the stars appear in different places on the rectangle:\n\nIf you specify more than one view in the content closure, the modifier collects all of the views in the closure into an implicit ZStack, taking them in order from back to front. For example, you can place a star and a Circle on a field of blue:\n\nColor.blue\n    .frame(width: 200, height: 200)\n    .overlay {\n        Circle()\n            .frame(width: 100, height: 100)\n        Star()\n    }\n\n\nBoth the overlay modifier and the implicit ZStack composed from the overlay content \u2014 the circle and the star \u2014 use a default center alignment. The star appears centered on the circle, and both appear as a composite view centered in front of the square:\n\nIf you specify an alignment for the overlay, it applies to the implicit stack rather than to the individual views in the closure. You can see this if you add the bottom alignment:\n\nColor.blue\n    .frame(width: 200, height: 200)\n    .overlay(alignment: .bottom) {\n        Circle()\n            .frame(width: 100, height: 100)\n        Star()\n    }\n\n\nThe circle and the star move down as a unit to align the stack\u2019s bottom edge with the bottom edge of the square, while the star remains centered on the circle:\n\nTo control the placement of individual items inside the content closure, either use a different overlay modifier for each item, as the earlier example of stars in the corners of a rectangle demonstrates, or add an explicit ZStack inside the content closure with its own alignment:\n\nColor.blue\n    .frame(width: 200, height: 200)\n    .overlay(alignment: .bottom) {\n        ZStack(alignment: .bottom) {\n            Circle()\n                .frame(width: 100, height: 100)\n            Star()\n        }\n    }\n\n\nThe stack alignment ensures that the star\u2019s bottom edge aligns with the circle\u2019s, while the overlay aligns the composite view with the square:\n\nYou can achieve layering without an overlay modifier by putting both the modified view and the overlay content into a ZStack. This can produce a simpler view hierarchy, but changes the layout priority that SwiftUI applies to the views. Use the overlay modifier when you want the modified view to dominate the layout.\n\nIf you want to specify a ShapeStyle like a Color or a Material as the overlay, use overlay(_:ignoresSafeAreaEdges:) instead. To specify a Shape, use overlay(_:in:fillStyle:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "InspectorCommands",
        "url": "https://developer.apple.com/documentation/swiftui/inspectorcommands",
        "html": "Overview\n\nInspectorCommands include a command for toggling the presented state of the inspector with a keyboard shortcut of \u2318\u2303I.\n\nThese commands are optional and can be explicitly requested by passing a value of this type to the commands(content:) modifier:\n\n@State var presented = true\nWindowGroup {\n    MainView()\n        .inspector(isPresented: $presented) {\n            InspectorView()\n        }\n}\n.commands {\n    InspectorCommands()\n}\n\nTopics\nCreating a command\ninit()\nA new value describing the built-in inspector-related commands.\nRelationships\nConforms To\nCommands\nSee Also\nGetting built-in command groups\nstruct SidebarCommands\nA built-in set of commands for manipulating window sidebars.\nstruct TextEditingCommands\nA built-in group of commands for searching, editing, and transforming selections of text.\nstruct TextFormattingCommands\nA built-in set of commands for transforming the styles applied to selections of text.\nstruct ToolbarCommands\nA built-in set of commands for manipulating window toolbars.\nstruct ImportFromDevicesCommands\nA built-in set of commands that enables importing content from nearby devices.\nstruct EmptyCommands\nAn empty group of commands."
    },
    {
        "title": "ZStack",
        "url": "https://developer.apple.com/documentation/swiftui/zstack",
        "html": "Overview\n\nThe ZStack assigns each successive subview a higher z-axis value than the one before it, meaning later subviews appear \u201con top\u201d of earlier ones.\n\nThe following example creates a ZStack of 100 x 100 point Rectangle views filled with one of six colors, offsetting each successive subview by 10 points so they don\u2019t completely overlap:\n\nlet colors: [Color] =\n    [.red, .orange, .yellow, .green, .blue, .purple]\n\n\nvar body: some View {\n    ZStack {\n        ForEach(0..<colors.count) {\n            Rectangle()\n                .fill(colors[$0])\n                .frame(width: 100, height: 100)\n                .offset(x: CGFloat($0) * 10.0,\n                        y: CGFloat($0) * 10.0)\n        }\n    }\n}\n\n\nThe ZStack uses an Alignment to set the x- and y-axis coordinates of each subview, defaulting to a center alignment. In the following example, the ZStack uses a bottomLeading alignment to lay out two subviews, a red 100 x 50 point rectangle below, and a blue 50 x 100 point rectangle on top. Because of the alignment value, both rectangles share a bottom-left corner with the ZStack (in locales where left is the leading side).\n\nvar body: some View {\n    ZStack(alignment: .bottomLeading) {\n        Rectangle()\n            .fill(Color.red)\n            .frame(width: 100, height: 50)\n        Rectangle()\n            .fill(Color.blue)\n            .frame(width:50, height: 100)\n    }\n    .border(Color.green, width: 1)\n}\n\n\nNote\n\nIf you need a version of this stack that conforms to the Layout protocol, like when you want to create a conditional layout using AnyLayout, use ZStackLayout instead.\n\nTopics\nCreating a stack\ninit(alignment: Alignment, content: () -> Content)\nCreates an instance with the given alignment.\nRelationships\nConforms To\nView\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "Adding a background to your view",
        "url": "https://developer.apple.com/documentation/swiftui/adding-a-background-to-your-view",
        "html": "Overview\n\nYou can add a view as a background with the background(_:alignment:) view modifier. To add a background under multiple views, or to have a background larger than an existing view, you can layer the views by placing them within a ZStack, and place the view you want to be in the background at the bottom of the view stack. You can specify that a background view should ignore the safe area insets to extend the background to some or all edges.\n\nAdd a background\n\nIf your design calls for a background, you can use the background(_:alignment:) modifier to add it underneath an existing view. The following example adds a gradient to the vertical stack using the background(_:alignment:) view modifier:\n\nlet backgroundGradient = LinearGradient(\n    colors: [Color.red, Color.blue],\n    startPoint: .top, endPoint: .bottom)\n\n\nstruct SignInView: View {\n    @State private var name: String = \"\"\n\n\n    var body: some View {\n        VStack {\n            Text(\"Welcome\")\n                .font(.title)\n            HStack {\n                TextField(\"Your name?\", text: $name)\n                    .textFieldStyle(.roundedBorder)\n                Button(action: {}, label: {\n                    Image(systemName: \"arrow.right.square\")\n                        .font(.title)\n                })\n            }\n            .padding()\n        }\n        .background(backgroundGradient)\n    }\n}\n\n\nThe background(_:alignment:) view modifier constrains the size of the background view to be the same size as the view to which it\u2019s attached:\n\nExpand the background underneath your view\n\nTo create a background that\u2019s larger than the vertical stack, use a different technique. You could add Spacer views above and below the content in the VStack to expand it, but that would also expand the size of the stack, possibly changing it\u2019s layout. To add in a larger background without changing the size of the stack, nest the views within a ZStack to layer the VStack over the background view:\n\nstruct SignInView: View {\n    @State private var name: String = \"\"\n\n\n    var body: some View {\n        ZStack {\n            backgroundGradient\n            VStack {\n                Text(\"Welcome\")\n                    .font(.title)\n                HStack {\n                    TextField(\"Your name?\", text: $name)\n                        .textFieldStyle(.roundedBorder)\n                    Button(action: {}, label: {\n                        Image(systemName: \"arrow.right.square\")\n                            .font(.title)\n                    })\n                }\n                .padding()\n            }\n        }\n    }\n}\n\n\nView sizes within a depth stack are independent, unlike when using the background view modifier. The view from Gradient expands to fill the space available to the stack, but avoids the safe area insets by default:\n\nFor more information on usings stacks to combine views, see Building layouts with stack views.\n\nExtend the background into the safe areas\n\nBy default, SwiftUI sizes and positions views to avoid system defined safe areas to ensure that system content or the edges of the device won\u2019t obstruct your views. If your design calls for the background to extend to the screen edges, use the ignoresSafeArea(_:edges:) modifier to override the default.\n\nstruct SignInView: View {\n    @State private var name: String = \"\"\n    var body: some View {\n        ZStack {\n            backgroundGradient\n            VStack {\n                Text(\"Welcome\")\n                    .font(.title)\n                HStack {\n                    TextField(\"Your name?\", text: $name)\n                        .textFieldStyle(.roundedBorder)\n                    Button(action: {}, label: {\n                        Image(systemName: \"arrow.right.square\")\n                            .font(.title)\n                    })\n                }\n                .padding()\n            }\n        }\n        .ignoresSafeArea()\n    }\n}\n\n\nThe background gradient fills the display area of the device and ignores the safe area insets.\n\nAdjust views when displaying the keyboard\n\nYou can ignore the keyboard\u2019s safe area by adding the ignoresSafeArea(_:edges:) modifier. When you activate the keyboard, the content of the vertical stack remains fixed, ignoring the space used by the keyboard:\n\nTo get the contents of the vertical stack to respect the safe areas and adjust to the keyboard, move the modifier to only apply to the background view.\n\nstruct SignInView: View {\n    @State private var name: String = \"\"\n    var body: some View {\n        ZStack {\n            backgroundGradient\n                .ignoresSafeArea()\n            VStack {\n                Text(\"Welcome\")\n                    .font(.title)\n                HStack {\n                    TextField(\"Your name?\", text: $name)\n                        .textFieldStyle(.roundedBorder)\n                    Button(action: {}, label: {\n                        Image(systemName: \"arrow.right.square\")\n                            .font(.title)\n                    })\n                }\n                .padding()\n            }\n        }\n    }\n}\n\n\nTo accommodate the keyboard, SwiftUI resizes and positions your view. Because the background view has the ignoresSafeArea(_:edges:) modifier, it remains unchanged.\n\nSee Also\nLayering views\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "zIndex(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/zindex(_:)",
        "html": "Parameters\nvalue\n\nA relative front-to-back ordering for this view; the default is 0.\n\nDiscussion\n\nUse zIndex(_:) when you want to control the front-to-back ordering of views.\n\nIn this example there are two overlapping rotated rectangles. The frontmost is represented by the larger index value.\n\nVStack {\n    Rectangle()\n        .fill(Color.yellow)\n        .frame(width: 100, height: 100, alignment: .center)\n        .zIndex(1) // Top layer.\n\n\n    Rectangle()\n        .fill(Color.red)\n        .frame(width: 100, height: 100, alignment: .center)\n        .rotationEffect(.degrees(45))\n        // Here a zIndex of 0 is the default making\n        // this the bottom layer.\n}\n\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "CommandsBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/commandsbuilder",
        "html": "Topics\nBuilding content\nstatic func buildBlock() -> EmptyCommands\nBuilds an empty command set from a block containing no statements.\nstatic func buildBlock<C>(C) -> C\nPasses a single command group written as a child group through modified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Commands\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Commands\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Commands\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Commands\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Commands\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Commands\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Commands\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Commands\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Commands\nBuilding conditionally\nstatic func buildEither<T, F>(first: T) -> _ConditionalContent<T, F>\nProduces content for a conditional statement in a multi-statement closure when the condition is true.\nstatic func buildEither<T, F>(second: F) -> _ConditionalContent<T, F>\nProduces content for a conditional statement in a multi-statement closure when the condition is false.\nstatic func buildIf<C>(C?) -> C?\nProduces an optional widget for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true.\nstatic func buildLimitedAvailability<C>(C) -> some Commands\nProcesses commands for a conditional compiler-control statement that performs an availability check.\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nSee Also\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to."
    },
    {
        "title": "LazyVGrid",
        "url": "https://developer.apple.com/documentation/swiftui/lazyvgrid",
        "html": "Overview\n\nUse a lazy vertical grid when you want to display a large, vertically scrollable collection of views arranged in a two dimensional layout. The first view that you provide to the grid\u2019s content closure appears in the top row of the column that\u2019s on the grid\u2019s leading edge. Additional views occupy successive cells in the grid, filling the first row from leading to trailing edges, then the second row, and so on. The number of rows can grow unbounded, but you specify the number of columns by providing a corresponding number of GridItem instances to the grid\u2019s initializer.\n\nThe grid in the following example defines two columns and uses a ForEach structure to repeatedly generate a pair of Text views for the columns in each row:\n\nstruct VerticalSmileys: View {\n    let columns = [GridItem(.flexible()), GridItem(.flexible())]\n\n\n    var body: some View {\n         ScrollView {\n             LazyVGrid(columns: columns) {\n                 ForEach(0x1f600...0x1f679, id: \\.self) { value in\n                     Text(String(format: \"%x\", value))\n                     Text(emoji(value))\n                         .font(.largeTitle)\n                 }\n             }\n         }\n    }\n\n\n    private func emoji(_ value: Int) -> String {\n        guard let scalar = UnicodeScalar(value) else { return \"?\" }\n        return String(Character(scalar))\n    }\n}\n\n\nFor each row in the grid, the first column shows a Unicode code point from the \u201cSmileys\u201d group, and the second shows its corresponding emoji:\n\nYou can achieve a similar layout using a Grid container. Unlike a lazy grid, which creates child views only when SwiftUI needs to display them, a regular grid creates all of its child views right away. This enables the grid to provide better support for cell spacing and alignment. Only use a lazy grid if profiling your app shows that a Grid view performs poorly because it tries to load too many views at once.\n\nTopics\nCreating a vertical grid\ninit(columns: [GridItem], alignment: HorizontalAlignment, spacing: CGFloat?, pinnedViews: PinnedScrollableViews, content: () -> Content)\nCreates a grid that grows vertically.\nRelationships\nConforms To\nView\nSee Also\nDynamically arranging views in two dimensions\nstruct LazyHGrid\nA container view that arranges its child views in a grid that grows horizontally, creating items only as needed.\nstruct GridItem\nA description of a row or a column in a lazy grid."
    },
    {
        "title": "gridCellColumns(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/gridcellcolumns(_:)",
        "html": "Parameters\ncount\n\nThe number of columns that the view should consume when placed in a grid row.\n\nReturn Value\n\nA view that occupies the specified number of columns in a grid row.\n\nDiscussion\n\nBy default, each view that you put into the content closure of a GridRow corresponds to exactly one column of the grid. Apply the gridCellColumns(_:) modifier to a view that you want to span more than one column, as in the following example of a typical macOS configuration view:\n\nGrid(alignment: .leadingFirstTextBaseline) {\n    GridRow {\n        Text(\"Regular font:\")\n            .gridColumnAlignment(.trailing)\n        Text(\"Helvetica 12\")\n        Button(\"Select...\") { }\n    }\n    GridRow {\n        Text(\"Fixed-width font:\")\n        Text(\"Menlo Regular 11\")\n        Button(\"Select...\") { }\n    }\n    GridRow {\n        Color.clear\n            .gridCellUnsizedAxes([.vertical, .horizontal])\n        Toggle(\"Use fixed-width font for new documents\", isOn: $isOn)\n            .gridCellColumns(2) // Span two columns.\n    }\n}\n\n\nThe Toggle in the example above spans the column that contains the font names and the column that contains the buttons:\n\nImportant\n\nWhen you tell a cell to span multiple columns, the grid changes the merged cell to use anchor alignment, rather than the usual alignment guides. For information about the behavior of anchor alignment, see gridCellAnchor(_:).\n\nAs a convenience you can cause a view to span all of the Grid columns by placing the view directly in the content closure of the Grid, outside of a GridRow, and omitting the modifier. To do the opposite and include more than one view in a cell, group the views using an appropriate layout container, like an HStack, so that they act as a single view.\n\nSee Also\nStatically arranging views in two dimensions\nstruct Grid\nA container view that arranges other views in a two dimensional layout.\nstruct GridRow\nA horizontal row in a two dimensional grid container.\nfunc gridCellAnchor(UnitPoint) -> some View\nSpecifies a custom alignment anchor for a view that acts as a grid cell.\nfunc gridCellUnsizedAxes(Axis.Set) -> some View\nAsks grid layouts not to offer the view extra size in the specified axes.\nfunc gridColumnAlignment(HorizontalAlignment) -> some View\nOverrides the default horizontal alignment of the grid column that the view appears in."
    },
    {
        "title": "gridCellAnchor(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/gridcellanchor(_:)",
        "html": "Parameters\nanchor\n\nThe unit point that defines how to align the view within the bounds of its grid cell.\n\nReturn Value\n\nA view that uses the specified anchor point to align its content.\n\nDiscussion\n\nGrids, like stacks and other layout containers, perform most alignment operations using alignment guides. The grid moves the contents of each cell in a row in the y direction until the specified VerticalAlignment guide of each view in the row aligns with the same guide of all the other views in the row. Similarly, the grid aligns the HorizontalAlignment guides of views in a column by adjusting views in the x direction. See the guide types for more information about typical SwiftUI alignment operations.\n\nWhen you use the gridCellAnchor(_:) modifier on a view in a grid, the grid changes to an anchor-based alignment strategy for the associated cell. With anchor alignment, the grid projects a UnitPoint that you specify onto both the view and the cell, and aligns the two projections. For example, consider the following grid:\n\nGrid(horizontalSpacing: 1, verticalSpacing: 1) {\n    GridRow {\n        Color.red.frame(width: 60, height: 60)\n        Color.red.frame(width: 60, height: 60)\n    }\n    GridRow {\n        Color.red.frame(width: 60, height: 60)\n        Color.blue.frame(width: 10, height: 10)\n            .gridCellAnchor(UnitPoint(x: 0.25, y: 0.75))\n    }\n}\n\n\nThe grid creates red reference squares in the first row and column to establish row and column sizes. Without the anchor modifier, the blue marker in the remaining cell would appear at the center of its cell, because of the grid\u2019s default center alignment. With the anchor modifier shown in the code above, the grid aligns the one quarter point of the marker with the one quarter point of its cell in the x direction, as measured from the origin at the top left of the cell. The grid also aligns the three quarters point of the marker with the three quarters point of the cell in the y direction:\n\nUnitPoint defines many convenience points that correspond to the typical alignment guides, which you can use as well. For example, you can use topTrailing to align the top and trailing edges of a view in a cell with the top and trailing edges of the cell:\n\nColor.blue.frame(width: 10, height: 10)\n    .gridCellAnchor(.topTrailing)\n\n\nApplying the anchor-based alignment strategy to a single cell doesn\u2019t affect the alignment strategy that the grid uses on other cells.\n\nAnchor alignment for merged cells\n\nIf you use the gridCellColumns(_:) modifier to cause a cell to span more than one column, or if you place a view in a grid outside of a row so that the view spans the entire grid, the grid automatically converts its vertical and horizontal alignment guides to the unit point equivalent for the merged cell, and uses an anchor-based approach for that cell. For example, the following grid places the marker at the center of the merged cell by converting the grid\u2019s default center alignment guide to a center anchor for the blue marker in the merged cell:\n\nGrid(alignment: .center, horizontalSpacing: 1, verticalSpacing: 1) {\n    GridRow {\n        Color.red.frame(width: 60, height: 60)\n        Color.red.frame(width: 60, height: 60)\n        Color.red.frame(width: 60, height: 60)\n    }\n    GridRow {\n        Color.red.frame(width: 60, height: 60)\n        Color.blue.frame(width: 10, height: 10)\n            .gridCellColumns(2)\n    }\n}\n\n\nThe grid makes this conversion in part to avoid ambiguity. Each column has its own horizontal guide, and it isn\u2019t clear which of these a cell that spans multiple columns should align with. Further, in the example above, neither of the center alignment guides for the second or third column would provide the expected behavior, which is to center the marker in the merged cell. Anchor alignment provides this behavior:\n\nSee Also\nStatically arranging views in two dimensions\nstruct Grid\nA container view that arranges other views in a two dimensional layout.\nstruct GridRow\nA horizontal row in a two dimensional grid container.\nfunc gridCellColumns(Int) -> some View\nTells a view that acts as a cell in a grid to span the specified number of columns.\nfunc gridCellUnsizedAxes(Axis.Set) -> some View\nAsks grid layouts not to offer the view extra size in the specified axes.\nfunc gridColumnAlignment(HorizontalAlignment) -> some View\nOverrides the default horizontal alignment of the grid column that the view appears in."
    },
    {
        "title": "GridRow",
        "url": "https://developer.apple.com/documentation/swiftui/gridrow",
        "html": "Overview\n\nUse one or more GridRow instances to define the rows of a Grid container. The child views inside the row define successive grid cells. You can add rows to the grid explicitly, or use the ForEach structure to generate multiple rows. Similarly, you can add cells to the row explicitly or you can use ForEach to generate multiple cells inside the row. The following example mixes these strategies:\n\nGrid {\n    GridRow {\n        Color.clear\n            .gridCellUnsizedAxes([.horizontal, .vertical])\n        ForEach(1..<4) { column in\n            Text(\"C\\(column)\")\n        }\n    }\n    ForEach(1..<4) { row in\n        GridRow {\n            Text(\"R\\(row)\")\n            ForEach(1..<4) { _ in\n                Circle().foregroundStyle(.mint)\n            }\n        }\n    }\n}\n\n\nThe grid in the example above has an explicit first row and three generated rows. Similarly, each row has an explicit first cell and three generated cells:\n\nTo create an empty cell, use something invisible, like the clear color that appears in the first column of the first row in the example above. However, if you use a flexible view like a Color or a Spacer, you might also need to add the gridCellUnsizedAxes(_:) modifier to prevent the view from taking up more space than the other cells in the row or column need.\n\nImportant\n\nYou can\u2019t use EmptyView to create a blank cell because that resolves to the absence of a view and doesn\u2019t generate a cell.\n\nBy default, the cells in the row use the Alignment that you define when you initialize the Grid. However, you can override the vertical alignment for the cells in a row by providing a VerticalAlignment value to the row\u2019s init(alignment:content:) initializer.\n\nIf you apply a view modifier to a row, the row applies the modifier to all of the cells, similar to how a Group behaves. For example, if you apply the border(_:width:) modifier to a row, SwiftUI draws a border on each cell in the row rather than around the row.\n\nTopics\nCreating a grid row\ninit(alignment: VerticalAlignment?, content: () -> Content)\nCreates a horizontal row of child views in a grid.\nRelationships\nConforms To\nView\nConforms when Content conforms to View.\nSee Also\nStatically arranging views in two dimensions\nstruct Grid\nA container view that arranges other views in a two dimensional layout.\nfunc gridCellColumns(Int) -> some View\nTells a view that acts as a cell in a grid to span the specified number of columns.\nfunc gridCellAnchor(UnitPoint) -> some View\nSpecifies a custom alignment anchor for a view that acts as a grid cell.\nfunc gridCellUnsizedAxes(Axis.Set) -> some View\nAsks grid layouts not to offer the view extra size in the specified axes.\nfunc gridColumnAlignment(HorizontalAlignment) -> some View\nOverrides the default horizontal alignment of the grid column that the view appears in."
    },
    {
        "title": "gridColumnAlignment(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/gridcolumnalignment(_:)",
        "html": "Parameters\nguide\n\nThe HorizontalAlignment guide to use for the grid column that the view appears in.\n\nReturn Value\n\nA view that uses the specified horizontal alignment, and that causes all cells in the same column of a grid to use the same alignment.\n\nDiscussion\n\nYou set a default alignment for the cells in a grid in both vertical and horizontal dimensions when you create the grid with the init(alignment:horizontalSpacing:verticalSpacing:content:) initializer. However, you can use the gridColumnAlignment(_:) modifier to override the horizontal alignment of a column within the grid. The following example sets a grid\u2019s alignment to leadingFirstTextBaseline, and then sets the first column to use trailing alignment:\n\nGrid(alignment: .leadingFirstTextBaseline) {\n    GridRow {\n        Text(\"Regular font:\")\n            .gridColumnAlignment(.trailing) // Align the entire first column.\n        Text(\"Helvetica 12\")\n        Button(\"Select...\") { }\n    }\n    GridRow {\n        Text(\"Fixed-width font:\")\n        Text(\"Menlo Regular 11\")\n        Button(\"Select...\") { }\n    }\n    GridRow {\n        Color.clear\n            .gridCellUnsizedAxes([.vertical, .horizontal])\n        Toggle(\"Use fixed-width font for new documents\", isOn: $isOn)\n            .gridCellColumns(2)\n    }\n}\n\n\nThis creates the layout of a typical macOS configuration view, with the trailing edge of the first column flush with the leading edge of the second column:\n\nAdd the modifier to only one cell in a column. The grid automatically aligns all cells in that column the same way. You get undefined behavior if you apply different alignments to different cells in the same column.\n\nTo override row alignment, see init(alignment:content:). To override alignment for a single cell, see gridCellAnchor(_:).\n\nSee Also\nStatically arranging views in two dimensions\nstruct Grid\nA container view that arranges other views in a two dimensional layout.\nstruct GridRow\nA horizontal row in a two dimensional grid container.\nfunc gridCellColumns(Int) -> some View\nTells a view that acts as a cell in a grid to span the specified number of columns.\nfunc gridCellAnchor(UnitPoint) -> some View\nSpecifies a custom alignment anchor for a view that acts as a grid cell.\nfunc gridCellUnsizedAxes(Axis.Set) -> some View\nAsks grid layouts not to offer the view extra size in the specified axes."
    },
    {
        "title": "LazyHGrid",
        "url": "https://developer.apple.com/documentation/swiftui/lazyhgrid",
        "html": "Overview\n\nUse a lazy horizontal grid when you want to display a large, horizontally scrollable collection of views arranged in a two dimensional layout. The first view that you provide to the grid\u2019s content closure appears in the top row of the column that\u2019s on the grid\u2019s leading edge. Additional views occupy successive cells in the grid, filling the first column from top to bottom, then the second column, and so on. The number of columns can grow unbounded, but you specify the number of rows by providing a corresponding number of GridItem instances to the grid\u2019s initializer.\n\nThe grid in the following example defines two rows and uses a ForEach structure to repeatedly generate a pair of Text views for the rows in each column:\n\nstruct HorizontalSmileys: View {\n    let rows = [GridItem(.fixed(30)), GridItem(.fixed(30))]\n\n\n    var body: some View {\n        ScrollView(.horizontal) {\n            LazyHGrid(rows: rows) {\n                ForEach(0x1f600...0x1f679, id: \\.self) { value in\n                    Text(String(format: \"%x\", value))\n                    Text(emoji(value))\n                        .font(.largeTitle)\n                }\n            }\n        }\n    }\n\n\n    private func emoji(_ value: Int) -> String {\n        guard let scalar = UnicodeScalar(value) else { return \"?\" }\n        return String(Character(scalar))\n    }\n}\n\n\nFor each column in the grid, the top row shows a Unicode code point from the \u201cSmileys\u201d group, and the bottom shows its corresponding emoji:\n\nYou can achieve a similar layout using a Grid container. Unlike a lazy grid, which creates child views only when SwiftUI needs to display them, a regular grid creates all of its child views right away. This enables the grid to provide better support for cell spacing and alignment. Only use a lazy grid if profiling your app shows that a Grid view performs poorly because it tries to load too many views at once.\n\nTopics\nCreating a horizontal grid\ninit(rows: [GridItem], alignment: VerticalAlignment, spacing: CGFloat?, pinnedViews: PinnedScrollableViews, content: () -> Content)\nCreates a grid that grows horizontally.\nRelationships\nConforms To\nView\nSee Also\nDynamically arranging views in two dimensions\nstruct LazyVGrid\nA container view that arranges its child views in a grid that grows vertically, creating items only as needed.\nstruct GridItem\nA description of a row or a column in a lazy grid."
    },
    {
        "title": "GridItem",
        "url": "https://developer.apple.com/documentation/swiftui/griditem",
        "html": "Overview\n\nUse an array of GridItem instances to configure the layout of items in a lazy grid. Each grid item in the array specifies layout properties like size and spacing for the rows of a LazyHGrid or the columns of a LazyVGrid. The following example defines four rows for a horizontal grid, each with different characteristics:\n\nstruct GridItemDemo: View {\n    let rows = [\n        GridItem(.fixed(30), spacing: 1),\n        GridItem(.fixed(60), spacing: 10),\n        GridItem(.fixed(90), spacing: 20),\n        GridItem(.fixed(10), spacing: 50)\n    ]\n\n\n    var body: some View {\n        ScrollView(.horizontal) {\n            LazyHGrid(rows: rows, spacing: 5) {\n                ForEach(0...300, id: \\.self) { _ in\n                    Color.red.frame(width: 30)\n                    Color.green.frame(width: 30)\n                    Color.blue.frame(width: 30)\n                    Color.yellow.frame(width: 30)\n                }\n            }\n        }\n    }\n}\n\n\nA lazy horizontal grid sets the width of each column based on the widest cell in the column. It can do this because it has access to all of the views in a given column at once. In the example above, the Color views always have the same fixed width, resulting in a uniform column width across the whole grid.\n\nHowever, a lazy horizontal grid doesn\u2019t generally have access to all the views in a row, because it generates new cells as people scroll through information in your app. Instead, it relies on a grid item for information about each row. The example above indicates a different fixed height for each row, and sets a different amount of spacing to appear after each row:\n\nTopics\nCreating a grid item\ninit(GridItem.Size, spacing: CGFloat?, alignment: Alignment?)\nCreates a grid item with the specified size, spacing, and alignment.\nInspecting grid item properties\nvar alignment: Alignment?\nThe alignment to use when placing each view.\nvar spacing: CGFloat?\nThe spacing to the next item.\nvar size: GridItem.Size\nThe size of the item, which is the width of a column item or the height of a row item.\nenum Size\nThe size in the minor axis of one or more rows or columns in a grid layout.\nRelationships\nConforms To\nSendable\nSee Also\nDynamically arranging views in two dimensions\nstruct LazyHGrid\nA container view that arranges its child views in a grid that grows horizontally, creating items only as needed.\nstruct LazyVGrid\nA container view that arranges its child views in a grid that grows vertically, creating items only as needed."
    },
    {
        "title": "gridCellUnsizedAxes(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/gridcellunsizedaxes(_:)",
        "html": "Parameters\naxes\n\nThe dimensions in which the grid shouldn\u2019t offer the view a share of any available space. This prevents a flexible view like a Spacer, Divider, or Color from defining the size of a row or column.\n\nReturn Value\n\nA view that doesn\u2019t ask an enclosing grid for extra size in one or more axes.\n\nDiscussion\n\nUse this modifier to prevent a flexible view from taking more space on the specified axes than the other cells in a row or column require. For example, consider the following Grid that places a Divider between two rows of content:\n\nGrid {\n    GridRow {\n        Text(\"Hello\")\n        Image(systemName: \"globe\")\n    }\n    Divider()\n    GridRow {\n        Image(systemName: \"hand.wave\")\n        Text(\"World\")\n    }\n}\n\n\nThe text and images all have ideal widths for their content. However, because a divider takes as much space as its parent offers, the grid fills the width of the display, expanding all the other cells to match:\n\nYou can prevent the grid from giving the divider more width than the other cells require by adding the modifier with the Axis.horizontal parameter:\n\nDivider()\n    .gridCellUnsizedAxes(.horizontal)\n\n\nThis restores the grid to the width that it would have without the divider:\n\nSee Also\nStatically arranging views in two dimensions\nstruct Grid\nA container view that arranges other views in a two dimensional layout.\nstruct GridRow\nA horizontal row in a two dimensional grid container.\nfunc gridCellColumns(Int) -> some View\nTells a view that acts as a cell in a grid to span the specified number of columns.\nfunc gridCellAnchor(UnitPoint) -> some View\nSpecifies a custom alignment anchor for a view that acts as a grid cell.\nfunc gridColumnAlignment(HorizontalAlignment) -> some View\nOverrides the default horizontal alignment of the grid column that the view appears in."
    },
    {
        "title": "Divider",
        "url": "https://developer.apple.com/documentation/swiftui/divider",
        "html": "Overview\n\nWhen contained in a stack, the divider extends across the minor axis of the stack, or horizontally when not in a stack.\n\nTopics\nCreating a divider\ninit()\nRelationships\nConforms To\nView\nSee Also\nSeparators\nstruct Spacer\nA flexible space that expands along the major axis of its containing stack layout, or on both axes if not contained in a stack."
    },
    {
        "title": "LazyHStack",
        "url": "https://developer.apple.com/documentation/swiftui/lazyhstack",
        "html": "Overview\n\nThe stack is \u201clazy,\u201d in that the stack view doesn\u2019t create items until it needs to render them onscreen.\n\nIn the following example, a ScrollView contains a LazyHStack that consists of a horizontal row of text views. The stack aligns to the top of the scroll view and uses 10-point spacing between each text view.\n\nScrollView(.horizontal) {\n    LazyHStack(alignment: .top, spacing: 10) {\n        ForEach(1...100, id: \\.self) {\n            Text(\"Column \\($0)\")\n        }\n    }\n}\n\nTopics\nCreating a lazy-loading horizontal stack\ninit(alignment: VerticalAlignment, spacing: CGFloat?, pinnedViews: PinnedScrollableViews, content: () -> Content)\nCreates a lazy horizontal stack view with the given spacing, vertical alignment, pinning behavior, and content.\nRelationships\nConforms To\nView\nSee Also\nDynamically arranging views in one dimension\nGrouping data with lazy stack views\nSplit content into logical sections inside lazy stack views.\nCreating performant scrollable stacks\nDisplay large numbers of repeated views efficiently with scroll views, stack views, and lazy stacks.\nstruct LazyVStack\nA view that arranges its children in a line that grows vertically, creating items only as needed.\nstruct PinnedScrollableViews\nA set of view types that may be pinned to the bounds of a scroll view."
    },
    {
        "title": "ToolbarCommands",
        "url": "https://developer.apple.com/documentation/swiftui/toolbarcommands",
        "html": "Overview\n\nThese commands are optional and can be explicitly requested by passing a value of this type to the commands(content:) modifier.\n\nTopics\nCreating the command group\ninit()\nA new value describing the built-in toolbar-related commands.\nRelationships\nConforms To\nCommands\nSee Also\nGetting built-in command groups\nstruct SidebarCommands\nA built-in set of commands for manipulating window sidebars.\nstruct TextEditingCommands\nA built-in group of commands for searching, editing, and transforming selections of text.\nstruct TextFormattingCommands\nA built-in set of commands for transforming the styles applied to selections of text.\nstruct ImportFromDevicesCommands\nA built-in set of commands that enables importing content from nearby devices.\nstruct InspectorCommands\nA built-in set of commands for manipulating inspectors.\nstruct EmptyCommands\nAn empty group of commands."
    },
    {
        "title": "Commands",
        "url": "https://developer.apple.com/documentation/swiftui/commands",
        "html": "Topics\nImplementing commands\nvar body: Self.Body\nThe contents of the command hierarchy.\n\nRequired\n\nassociatedtype Body : Commands\nThe type of commands that represents the body of this command hierarchy.\n\nRequired\n\nRelationships\nConforming Types\nCommandGroup\nCommandMenu\nEmptyCommands\nGroup\nConforms when Content conforms to Commands.\nImportFromDevicesCommands\nInspectorCommands\nSidebarCommands\nTextEditingCommands\nTextFormattingCommands\nToolbarCommands\nSee Also\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to."
    },
    {
        "title": "TextFormattingCommands",
        "url": "https://developer.apple.com/documentation/swiftui/textformattingcommands",
        "html": "Overview\n\nThese commands are optional and can be explicitly requested by passing a value of this type to the Scene.commands(_:) modifier.\n\nTopics\nCreating the command group\ninit()\nA new value describing the built-in text-formatting commands.\nRelationships\nConforms To\nCommands\nSee Also\nGetting built-in command groups\nstruct SidebarCommands\nA built-in set of commands for manipulating window sidebars.\nstruct TextEditingCommands\nA built-in group of commands for searching, editing, and transforming selections of text.\nstruct ToolbarCommands\nA built-in set of commands for manipulating window toolbars.\nstruct ImportFromDevicesCommands\nA built-in set of commands that enables importing content from nearby devices.\nstruct InspectorCommands\nA built-in set of commands for manipulating inspectors.\nstruct EmptyCommands\nAn empty group of commands."
    },
    {
        "title": "CommandGroupPlacement",
        "url": "https://developer.apple.com/documentation/swiftui/commandgroupplacement",
        "html": "Overview\n\nThe names of these placements aren\u2019t visible in the user interface, but the discussion for each placement lists the items that it includes.\n\nTopics\nApp interactions\nstatic let appInfo: CommandGroupPlacement\nPlacement for commands that provide information about the app, the terms of the user\u2019s license agreement, and so on.\nstatic let appSettings: CommandGroupPlacement\nPlacement for commands that expose app settings and preferences.\nstatic let appTermination: CommandGroupPlacement\nPlacement for commands that result in app termination.\nstatic let appVisibility: CommandGroupPlacement\nPlacement for commands that control the visibility of running apps.\nstatic let systemServices: CommandGroupPlacement\nPlacement for commands that expose services other apps provide.\nFile manipulation\nstatic let importExport: CommandGroupPlacement\nPlacement for commands that relate to importing and exporting data using formats that the app doesn\u2019t natively support.\nstatic let newItem: CommandGroupPlacement\nPlacement for commands that create and open different kinds of documents.\nstatic let printItem: CommandGroupPlacement\nPlacement for commands related to printing app content.\nstatic let saveItem: CommandGroupPlacement\nPlacement for commands that save open documents and close windows.\nContent updates\nstatic let pasteboard: CommandGroupPlacement\nPlacement for commands that interact with the Clipboard and manipulate content that is currently selected in the app\u2019s view hierarchy.\nstatic let textEditing: CommandGroupPlacement\nPlacement for commands that manipulate and transform text selections.\nstatic let textFormatting: CommandGroupPlacement\nPlacement for commands that manipulate and transform the styles applied to text selections.\nstatic let undoRedo: CommandGroupPlacement\nPlacement for commands that control the Undo Manager.\nBars\nstatic let sidebar: CommandGroupPlacement\nPlacement for commands that control the app\u2019s sidebar and full-screen modes.\nstatic let toolbar: CommandGroupPlacement\nPlacement for commands that manipulate the toolbar.\nWindows\nstatic let singleWindowList: CommandGroupPlacement\nPlacement for commands that describe and reveal any windows that the app defines.\nstatic let windowArrangement: CommandGroupPlacement\nPlacement for commands that arrange all of an app\u2019s windows.\nstatic let windowList: CommandGroupPlacement\nPlacement for commands that describe and reveal the app\u2019s open windows.\nstatic let windowSize: CommandGroupPlacement\nPlacement for commands that control the size of the window.\nHelp\nstatic let help: CommandGroupPlacement\nPlacement for commands that present documentation and helpful information to people.\nSee Also\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body."
    },
    {
        "title": "TextEditingCommands",
        "url": "https://developer.apple.com/documentation/swiftui/texteditingcommands",
        "html": "Overview\n\nThese commands are optional and can be explicitly requested by passing a value of this type to the Scene.commands(_:) modifier.\n\nTopics\nCreating the command group\ninit()\nA new value describing the built-in text-editing commands.\nRelationships\nConforms To\nCommands\nSee Also\nGetting built-in command groups\nstruct SidebarCommands\nA built-in set of commands for manipulating window sidebars.\nstruct TextFormattingCommands\nA built-in set of commands for transforming the styles applied to selections of text.\nstruct ToolbarCommands\nA built-in set of commands for manipulating window toolbars.\nstruct ImportFromDevicesCommands\nA built-in set of commands that enables importing content from nearby devices.\nstruct InspectorCommands\nA built-in set of commands for manipulating inspectors.\nstruct EmptyCommands\nAn empty group of commands."
    },
    {
        "title": "Creating performant scrollable stacks",
        "url": "https://developer.apple.com/documentation/swiftui/creating-performant-scrollable-stacks",
        "html": "Overview\n\nYour apps often need to display more data within a container view than there is space for on a device\u2019s screen. Horizontal and vertical stacks are a good solution for repeating views or groups of views, but they don\u2019t have a built-in mechanism for scrolling. You can add scrolling by wrapping stacks inside a ScrollView, and switch to lazy stacks as performance issues arise.\n\nDisplay groups of views in a scrollable container\n\nImplementing repeating views or groups of views can be as simple as wrapping them in an HStack or VStack inside a ScrollView.\n\nScrollView(.horizontal) {\n    HStack {\n        ProfileView()\n        ProfileView()\n        ProfileView()\n        ProfileView()\n        ProfileView()\n    }\n}\n.frame(maxWidth: 500)\n\n\nIf the ProfileView in the example code above has an intrinsic content size of 200 x 200 points, the maximum width of 500 points that the frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:) view modifier applies to the ScrollView causes the stack to scroll inside it.\n\nFor an introduction to using stacks to group views together, see Building layouts with stack views.\n\nRepeat views for your data\n\nUse ForEach to repeat views for the data in your app. From a list of profile data in a profiles array, use ForEach to create one ProfileView per element in the array inside an HStack.\n\nScrollView(.horizontal) {\n    HStack {\n        ForEach(profiles) { profile in\n            ProfileView(profile: profile)\n        }\n    }\n}\n.frame(maxWidth: 500)\n\n\nNote\n\nWhen you use ForEach, each element you iterate over must be uniquely identifiable. Either conform elements to the Identifiable protocol, or pass a key path to a unique identifier as the id parameter of init(_:id:content:).\n\nConsider lazy stacks for large numbers of views\n\nThe three standard stack views, HStack, VStack, and ZStack, all load their contained view hierarchy when they display, and loading large numbers of views all at once can result in slow runtime performance.\n\nIn the above example, ProfileView is a compound view that consists of nested stack views, text labels, and an image view. Loading a large number of profiles all at once causes a noticeable slowdown.\n\nAs the number of views inside a stack grows, consider using a LazyHStack and LazyVStack instead of HStack and VStack. Lazy stacks load and render their subviews on-demand, providing significant performance gains when loading large numbers of subviews.\n\nStack views and lazy stacks have similar functionality, and they may feel interchangeable, but they each have strengths in different situations. Stack views load their child views all at once, making layout fast and reliable, because the system knows the size and shape of every subview as it loads them. Lazy stacks trade some degree of layout correctness for performance, because the system only calculates the geometry for subviews as they become visible.\n\nWhen choosing the type of stack view to use, always start with a standard stack view and only switch to a lazy stack if profiling your code shows a worthwhile performance improvement.\n\nProfile to find performance problems\n\nWhen considering which type of stack to use, use the Instruments tool to profile your application to identify the areas of your user interface code where large numbers of views are loading inside a stack.\n\nTo profile SwiftUI view loading, open the Instruments tool by selecting Profile from the Xcode Product menu and choosing the SwiftUI profiling template. This template loads four instruments: View Body, View Properties, Core Animation Commits, and Time Profiler. The combination of these instruments provides a good starting point to find opportunities to speed up your app.\n\nNote\n\nNever profile your code using the iOS simulator. Always use real devices for performance testing.\n\nWhen profiling the above code, the View Body instrument shows that 1,000 ProfileView instances load into memory at the same time as the HStack. You can also see the same number of Image views load as the system loads each profile.\n\nIn this case, the solution is to replace the HStack with a LazyHStack as the following code shows:\n\nScrollView(.horizontal) {\n    LazyHStack {\n        ForEach(profiles) { profile in\n            ProfileView(profile: profile)\n        }\n    }\n}\n.frame(maxWidth: 500)\n\n\nRunning another trace shows a drastic reduction in the number of initially loaded views as only four ProfileView instances start as visible. You can also see a corresponding decrease in the Total Duration column.\n\nFor more information about using the Instruments tool, see Improving Your App's Performance.\n\nSee Also\nDynamically arranging views in one dimension\nGrouping data with lazy stack views\nSplit content into logical sections inside lazy stack views.\nstruct LazyHStack\nA view that arranges its children in a line that grows horizontally, creating items only as needed.\nstruct LazyVStack\nA view that arranges its children in a line that grows vertically, creating items only as needed.\nstruct PinnedScrollableViews\nA set of view types that may be pinned to the bounds of a scroll view."
    },
    {
        "title": "CommandGroup",
        "url": "https://developer.apple.com/documentation/swiftui/commandgroup",
        "html": "Overview\n\nIn macOS, SwiftUI realizes command groups as collections of menu items in a menu bar menu. In iOS, iPadOS, and tvOS, SwiftUI creates key commands for each of a group\u2019s commands that has a keyboard shortcut.\n\nTopics\nCreating a command group\ninit(after: CommandGroupPlacement, addition: () -> Content)\nA value describing the addition of the given views to the end of the indicated group.\ninit(before: CommandGroupPlacement, addition: () -> Content)\nA value describing the addition of the given views to the beginning of the indicated group.\ninit(replacing: CommandGroupPlacement, addition: () -> Content)\nA value describing the complete replacement of the contents of the indicated group with the given views.\nRelationships\nConforms To\nCommands\nSee Also\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to."
    },
    {
        "title": "commandsRemoved()",
        "url": "https://developer.apple.com/documentation/swiftui/scene/commandsremoved()",
        "html": "Return Value\n\nA scene that excludes any commands defined by its children.\n\nDiscussion\n\nWindowGroup, Window, and other scene types all have an associated set of commands that they include by default. Apply this modifier to a scene to exclude those commands.\n\nFor example, the following code adds a scene for presenting the details of an individual data model in a separate window. To ensure that the window can only appear programmatically, we remove the scene\u2019s commands, including File > New Note Window.\n\n@main\nstruct Example: App {\n    var body: some Scene {\n        ...\n\n\n        WindowGroup(\"Note\", id: \"note\", for: Note.ID.self) {\n            NoteDetailView(id: $0)\n        }\n        .commandsRemoved()\n    }\n}\n\nSee Also\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to."
    },
    {
        "title": "PinnedScrollableViews",
        "url": "https://developer.apple.com/documentation/swiftui/pinnedscrollableviews",
        "html": "Topics\nGetting scrollable view types\nstatic let sectionHeaders: PinnedScrollableViews\nThe header view of each Section will be pinned.\nstatic let sectionFooters: PinnedScrollableViews\nThe footer view of each Section will be pinned.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nDynamically arranging views in one dimension\nGrouping data with lazy stack views\nSplit content into logical sections inside lazy stack views.\nCreating performant scrollable stacks\nDisplay large numbers of repeated views efficiently with scroll views, stack views, and lazy stacks.\nstruct LazyHStack\nA view that arranges its children in a line that grows horizontally, creating items only as needed.\nstruct LazyVStack\nA view that arranges its children in a line that grows vertically, creating items only as needed."
    },
    {
        "title": "rotation3DEffect(_:anchor:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/rotation3deffect(_:anchor:)",
        "html": "Parameters\nrotation\n\nA rotation to apply to the view\u2019s content.\n\nanchor\n\nThe unit point within the view about which to perform the rotation. The default value is center.\n\nReturn Value\n\nA view with rotated content.\n\nDiscussion\n\nThis modifier rotates the view\u2019s content without changing the view\u2019s frame. The following code displays a 3D model with a rotation of 45\u00b0 about the y-axis using the default anchor point at the center of the view:\n\nModel3D(named: \"robot\")\n    .rotation3DEffect(Rotation3D(angle: .degrees(45), axis: .y))\n\nSee Also\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space."
    },
    {
        "title": "LazyVStack",
        "url": "https://developer.apple.com/documentation/swiftui/lazyvstack",
        "html": "Overview\n\nThe stack is \u201clazy,\u201d in that the stack view doesn\u2019t create items until it needs to render them onscreen.\n\nIn the following example, a ScrollView contains a LazyVStack that consists of a vertical row of text views. The stack aligns to the leading edge of the scroll view, and uses default spacing between the text views.\n\nScrollView {\n    LazyVStack(alignment: .leading) {\n        ForEach(1...100, id: \\.self) {\n            Text(\"Row \\($0)\")\n        }\n    }\n}\n\nTopics\nCreating a lazy-loading vertical stack\ninit(alignment: HorizontalAlignment, spacing: CGFloat?, pinnedViews: PinnedScrollableViews, content: () -> Content)\nCreates a lazy vertical stack view with the given spacing, vertical alignment, pinning behavior, and content.\nRelationships\nConforms To\nView\nSee Also\nDynamically arranging views in one dimension\nGrouping data with lazy stack views\nSplit content into logical sections inside lazy stack views.\nCreating performant scrollable stacks\nDisplay large numbers of repeated views efficiently with scroll views, stack views, and lazy stacks.\nstruct LazyHStack\nA view that arranges its children in a line that grows horizontally, creating items only as needed.\nstruct PinnedScrollableViews\nA set of view types that may be pinned to the bounds of a scroll view."
    },
    {
        "title": "ShapeStyle",
        "url": "https://developer.apple.com/documentation/swiftui/shapestyle",
        "html": "Overview\n\nYou create custom shape styles by declaring a type that conforms to the ShapeStyle protocol and implementing the required resolve function to return a shape style that represents the desired appearance based on the current environment.\n\nFor example this shape style reads the current color scheme from the environment to choose the blend mode its color will be composited with:\n\nstruct MyShapeStyle: ShapeStyle {\n    func resolve(in environment: EnvironmentValues) -> some ShapeStyle {\n        if environment.colorScheme == .light {\n            return Color.red.blendMode(.lighten)\n        } else {\n            return Color.red.blendMode(.darken)\n        }\n    }\n}\n\n\nIn addition to creating a custom shape style, you can also use one of the concrete styles that SwiftUI defines. To indicate a specific color or pattern, you can use Color or the style returned by image(_:sourceRect:scale:), or one of the gradient types, like the one returned by radialGradient(_:center:startRadius:endRadius:). To set a color that\u2019s appropriate for a given context on a given platform, use one of the semantic styles, like background or primary.\n\nYou can use a shape style by:\n\nFilling a shape with a style with the fill(_:style:) modifier:\n\nPath { path in\n    path.move(to: .zero)\n    path.addLine(to: CGPoint(x: 50, y: 0))\n    path.addArc(\n        center: .zero,\n        radius: 50,\n        startAngle: .zero,\n        endAngle: .degrees(90),\n        clockwise: false)\n}\n.fill(.radial(\n    Gradient(colors: [.yellow, .red]),\n    center: .topLeading,\n    startRadius: 15,\n    endRadius: 80))\n\n\nTracing the outline of a shape with a style with either the stroke(_:lineWidth:) or the stroke(_:style:) modifier:\n\nRoundedRectangle(cornerRadius: 10)\n    .stroke(.mint, lineWidth: 10)\n    .frame(width: 200, height: 50)\n\n\nStyling the foreground elements in a view with the foregroundStyle(_:) modifier:\n\nVStack(alignment: .leading) {\n    Text(\"Primary\")\n        .font(.title)\n    Text(\"Secondary\")\n        .font(.caption)\n        .foregroundStyle(.secondary)\n}\n\n\nTopics\nSystem colors\nstatic var black: Color\nA black color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var blue: Color\nA context-dependent blue color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var brown: Color\nA context-dependent brown color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var clear: Color\nA clear color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var cyan: Color\nA context-dependent cyan color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var gray: Color\nA context-dependent gray color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var green: Color\nA context-dependent green color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var indigo: Color\nA context-dependent indigo color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var mint: Color\nA context-dependent mint color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var orange: Color\nA context-dependent orange color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var pink: Color\nA context-dependent pink color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var purple: Color\nA context-dependent purple color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var red: Color\nA context-dependent red color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var teal: Color\nA context-dependent teal color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var white: Color\nA white color suitable for use in UI elements.\nAvailable when Self is Color.\nstatic var yellow: Color\nA context-dependent yellow color suitable for use in UI elements.\nAvailable when Self is Color.\nAngular gradients\nstatic func angularGradient(Gradient, center: UnitPoint, startAngle: Angle, endAngle: Angle) -> AngularGradient\nAn angular gradient, which applies the color function as the angle changes between the start and end angles, and anchored to a relative center point within the filled shape.\nAvailable when Self is AngularGradient.\nstatic func angularGradient(AnyGradient, center: UnitPoint, startAngle: Angle, endAngle: Angle) -> some ShapeStyle\nAn angular gradient, which applies the color function as the angle changes between the start and end angles, and anchored to a relative center point within the filled shape.\nAvailable when Self is AngularGradient.\nstatic func angularGradient(colors: [Color], center: UnitPoint, startAngle: Angle, endAngle: Angle) -> AngularGradient\nAn angular gradient defined by a collection of colors.\nAvailable when Self is AngularGradient.\nstatic func angularGradient(stops: [Gradient.Stop], center: UnitPoint, startAngle: Angle, endAngle: Angle) -> AngularGradient\nAn angular gradient defined by a collection of color stops.\nAvailable when Self is AngularGradient.\nConic gradients\nstatic func conicGradient(Gradient, center: UnitPoint, angle: Angle) -> AngularGradient\nA conic gradient that completes a full turn, optionally starting from a given angle and anchored to a relative center point within the filled shape.\nAvailable when Self is AngularGradient.\nstatic func conicGradient(AnyGradient, center: UnitPoint, angle: Angle) -> some ShapeStyle\nA conic gradient that completes a full turn, optionally starting from a given angle and anchored to a relative center point within the filled shape.\nAvailable when Self is AngularGradient.\nstatic func conicGradient(colors: [Color], center: UnitPoint, angle: Angle) -> AngularGradient\nA conic gradient defined by a collection of colors that completes a full turn.\nAvailable when Self is AngularGradient.\nstatic func conicGradient(stops: [Gradient.Stop], center: UnitPoint, angle: Angle) -> AngularGradient\nA conic gradient defined by a collection of color stops that completes a full turn.\nAvailable when Self is AngularGradient.\nElliptical gradients\nstatic func ellipticalGradient(Gradient, center: UnitPoint, startRadiusFraction: CGFloat, endRadiusFraction: CGFloat) -> EllipticalGradient\nA radial gradient that draws an ellipse.\nAvailable when Self is EllipticalGradient.\nstatic func ellipticalGradient(AnyGradient, center: UnitPoint, startRadiusFraction: CGFloat, endRadiusFraction: CGFloat) -> some ShapeStyle\nA radial gradient that draws an ellipse.\nAvailable when Self is EllipticalGradient.\nstatic func ellipticalGradient(colors: [Color], center: UnitPoint, startRadiusFraction: CGFloat, endRadiusFraction: CGFloat) -> EllipticalGradient\nA radial gradient that draws an ellipse defined by a collection of colors.\nAvailable when Self is EllipticalGradient.\nstatic func ellipticalGradient(stops: [Gradient.Stop], center: UnitPoint, startRadiusFraction: CGFloat, endRadiusFraction: CGFloat) -> EllipticalGradient\nA radial gradient that draws an ellipse defined by a collection of color stops.\nAvailable when Self is EllipticalGradient.\nLinear gradients\nstatic func linearGradient(Gradient, startPoint: UnitPoint, endPoint: UnitPoint) -> LinearGradient\nA linear gradient.\nAvailable when Self is LinearGradient.\nstatic func linearGradient(AnyGradient, startPoint: UnitPoint, endPoint: UnitPoint) -> some ShapeStyle\nA linear gradient.\nAvailable when Self is LinearGradient.\nstatic func linearGradient(colors: [Color], startPoint: UnitPoint, endPoint: UnitPoint) -> LinearGradient\nA linear gradient defined by a collection of colors.\nAvailable when Self is LinearGradient.\nstatic func linearGradient(stops: [Gradient.Stop], startPoint: UnitPoint, endPoint: UnitPoint) -> LinearGradient\nA linear gradient defined by a collection of color stops.\nAvailable when Self is LinearGradient.\nRadial gradients\nstatic func radialGradient(Gradient, center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat) -> RadialGradient\nA radial gradient.\nAvailable when Self is RadialGradient.\nstatic func radialGradient(AnyGradient, center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat) -> some ShapeStyle\nA radial gradient.\nAvailable when Self is RadialGradient.\nstatic func radialGradient(colors: [Color], center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat) -> RadialGradient\nA radial gradient defined by a collection of colors.\nAvailable when Self is RadialGradient.\nstatic func radialGradient(stops: [Gradient.Stop], center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat) -> RadialGradient\nA radial gradient defined by a collection of color stops.\nAvailable when Self is RadialGradient.\nMaterials\nstatic var ultraThinMaterial: Material\nA mostly translucent material.\nAvailable when Self is Material.\nstatic var thinMaterial: Material\nA material that\u2019s more translucent than opaque.\nAvailable when Self is Material.\nstatic var regularMaterial: Material\nA material that\u2019s somewhat translucent.\nAvailable when Self is Material.\nstatic var thickMaterial: Material\nA material that\u2019s more opaque than translucent.\nAvailable when Self is Material.\nstatic var ultraThickMaterial: Material\nA mostly opaque material.\nAvailable when Self is Material.\nstatic var bar: Material\nA material matching the style of system toolbars.\nAvailable when Self is Material.\nImage paint styles\nstatic func image(Image, sourceRect: CGRect, scale: CGFloat) -> ImagePaint\nA shape style that fills a shape by repeating a region of an image.\nAvailable when Self is ImagePaint.\nHierarchical styles\nvar secondary: some ShapeStyle\nReturns the second level of this shape style.\nvar tertiary: some ShapeStyle\nReturns the third level of this shape style.\nvar quaternary: some ShapeStyle\nReturns the fourth level of this shape style.\nvar quinary: some ShapeStyle\nReturns the fifth level of this shape style.\nstatic var primary: HierarchicalShapeStyle\nA shape style that maps to the first level of the current content style.\nAvailable when Self is HierarchicalShapeStyle.\nstatic var secondary: HierarchicalShapeStyle\nA shape style that maps to the second level of the current content style.\nAvailable when Self is HierarchicalShapeStyle.\nstatic var tertiary: HierarchicalShapeStyle\nA shape style that maps to the third level of the current content style.\nAvailable when Self is HierarchicalShapeStyle.\nstatic var quaternary: HierarchicalShapeStyle\nA shape style that maps to the fourth level of the current content style.\nAvailable when Self is HierarchicalShapeStyle.\nstatic var quinary: HierarchicalShapeStyle\nA shape style that maps to the fifth level of the current content style.\nAvailable when Self is HierarchicalShapeStyle.\nSemantic styles\nstatic var foreground: ForegroundStyle\nThe foreground style in the current context.\nAvailable when Self is ForegroundStyle.\nstatic var background: BackgroundStyle\nThe background style in the current context.\nAvailable when Self is BackgroundStyle.\nstatic var selection: SelectionShapeStyle\nA style used to visually indicate selection following platform conventional colors and behaviors.\nAvailable when Self is SelectionShapeStyle.\nstatic var separator: SeparatorShapeStyle\nA style appropriate for foreground separator or border lines.\nAvailable when Self is SeparatorShapeStyle.\nstatic var tint: TintShapeStyle\nA style that reflects the current tint color.\nAvailable when Self is TintShapeStyle.\nstatic var placeholder: PlaceholderTextShapeStyle\nA style appropriate for placeholder text.\nAvailable when Self is PlaceholderTextShapeStyle.\nstatic var link: LinkShapeStyle\nA style appropriate for links.\nAvailable when Self is LinkShapeStyle.\nstatic var fill: FillShapeStyle\nAn overlay fill style for filling shapes.\nAvailable when Self is FillShapeStyle.\nstatic var windowBackground: WindowBackgroundShapeStyle\nA style appropriate for elements that should match the background of their containing window.\nAvailable when Self is WindowBackgroundShapeStyle.\nModifying a shape style\nfunc blendMode(BlendMode) -> some ShapeStyle\nReturns a new style based on self that applies the specified blend mode when drawing.\nfunc opacity(Double) -> some ShapeStyle\nReturns a new style based on self that multiplies by the specified opacity when drawing.\nfunc shadow(ShadowStyle) -> some ShapeStyle\nApplies the specified shadow effect to the shape style.\nConfiguring the default shape style\nstatic func blendMode(BlendMode) -> some ShapeStyle\nReturns a new style based on the current style that uses mode as its blend mode when drawing.\nAvailable when Self is AnyShapeStyle.\nstatic func opacity(Double) -> some ShapeStyle\nReturns a new style based on the current style that multiplies by opacity when drawing.\nAvailable when Self is AnyShapeStyle.\nstatic func shadow(ShadowStyle) -> some ShapeStyle\nReturns a shape style that applies the specified shadow style to the current style.\nAvailable when Self is AnyShapeStyle.\nMapping to absolute coordinates\nfunc `in`(CGRect) -> some ShapeStyle\nMaps a shape style\u2019s unit-space coordinates to the absolute coordinates of a given rectangle.\nResolving a shape style in an environment\nfunc resolve(in: EnvironmentValues) -> Self.Resolved\nEvaluate to a resolved shape style given the current environment.\n\nRequired Default implementation provided.\n\nassociatedtype Resolved : ShapeStyle = Never\nThe type of shape style this will resolve to.\n\nRequired\n\nUsing a shape style as a view\nvar body: _ShapeView<Rectangle, Self>\nA rectangular view that\u2019s filled with the shape style.\nAvailable when Self conforms to View and Body is _ShapeView<Rectangle, Self>.\nSupporting types\nConstruct instances of these styles using the properties and methods of the shape style protocol.\nstruct AngularGradient\nAn angular gradient.\nstruct EllipticalGradient\nA radial gradient that draws an ellipse.\nstruct LinearGradient\nA linear gradient.\nstruct RadialGradient\nA radial gradient.\nstruct Material\nA background material type.\nstruct ImagePaint\nA shape style that fills a shape by repeating a region of an image.\nstruct HierarchicalShapeStyle\nA shape style that maps to one of the numbered content styles.\nstruct HierarchicalShapeStyleModifier\nStyles that you can apply to hierarchical shapes.\nstruct ForegroundStyle\nThe foreground style in the current context.\nstruct BackgroundStyle\nThe background style in the current context.\nstruct SelectionShapeStyle\nA style used to visually indicate selection following platform conventional colors and behaviors.\nstruct SeparatorShapeStyle\nA style appropriate for foreground separator or border lines.\nstruct TintShapeStyle\nA style that reflects the current tint color.\nstruct FillShapeStyle\nA shape style that displays one of the overlay fills.\nstruct LinkShapeStyle\nA style appropriate for links.\nstruct PlaceholderTextShapeStyle\nA style appropriate for placeholder text.\nstruct WindowBackgroundShapeStyle\nA style appropriate for elements that should match the background of their containing window.\nRelationships\nInherits From\nSendable\nConforming Types\nAngularGradient\nAnyGradient\nAnyShapeStyle\nBackgroundStyle\nColor\nColor.Resolved\nEllipticalGradient\nFillShapeStyle\nForegroundStyle\nGradient\nHierarchicalShapeStyle\nHierarchicalShapeStyleModifier\nImagePaint\nLinearGradient\nLinkShapeStyle\nMaterial\nPlaceholderTextShapeStyle\nRadialGradient\nSelectionShapeStyle\nSeparatorShapeStyle\nShader\nTintShapeStyle\nWindowBackgroundShapeStyle\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "ShadowStyle",
        "url": "https://developer.apple.com/documentation/swiftui/shadowstyle",
        "html": "Topics\nGetting shadow styles\nstatic func drop(color: Color, radius: CGFloat, x: CGFloat, y: CGFloat) -> ShadowStyle\nCreates a custom drop shadow style.\nstatic func inner(color: Color, radius: CGFloat, x: CGFloat, y: CGFloat) -> ShadowStyle\nCreates a custom inner shadow style.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient."
    },
    {
        "title": "AnyGradient",
        "url": "https://developer.apple.com/documentation/swiftui/anygradient",
        "html": "Overview\n\nWhen used as a ShapeStyle, this type draws a linear gradient with start-point [0.5, 0] and end-point [0.5, 1].\n\nTopics\nCreating a gradient\ninit(Gradient)\nCreates a new instance from the specified gradient.\nWorking with color spaces\nfunc colorSpace(Gradient.ColorSpace) -> AnyGradient\nReturns a version of the gradient that will use a specified color space for interpolating between its colors.\nRelationships\nConforms To\nEquatable\nHashable\nScaleRange\nSendable\nShapeStyle\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "brightness(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/brightness(_:)",
        "html": "Parameters\namount\n\nA value between 0 (no effect) and 1 (full white brightening) that represents the intensity of the brightness effect.\n\nReturn Value\n\nA view that brightens this view by the specified amount.\n\nDiscussion\n\nUse brightness(_:) to brighten the intensity of the colors in a view. The example below shows a series of red squares, with their brightness increasing from 0 (fully red) to 100% (white) in 20% increments.\n\nstruct Brightness: View {\n    var body: some View {\n        HStack {\n            ForEach(0..<6) {\n                Color.red.frame(width: 60, height: 60, alignment: .center)\n                    .brightness(Double($0) * 0.2)\n                    .overlay(Text(\"\\(Double($0) * 0.2 * 100, specifier: \"%.0f\")%\"),\n                             alignment: .bottom)\n                    .border(Color.gray)\n            }\n        }\n    }\n}\n\n\nSee Also\nTransforming colors\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view."
    },
    {
        "title": "luminanceToAlpha()",
        "url": "https://developer.apple.com/documentation/swiftui/view/luminancetoalpha()",
        "html": "Return Value\n\nA view with the luminance to alpha effect applied.\n\nDiscussion\n\nUse this modifier to create a semitransparent mask, with the opacity of each part of the modified view controlled by the luminance of the corresponding part of the original view. Regions of lower luminance become more transparent, while higher luminance yields greater opacity.\n\nIn particular, the modifier maps the red, green, and blue components of each input pixel\u2019s color to a grayscale value, and that value becomes the alpha component of a black pixel in the output. This modifier produces an effect that\u2019s equivalent to using the feColorMatrix filter primitive with the luminanceToAlpha type attribute, as defined by the Scalable Vector Graphics (SVG) 2 specification.\n\nThe example below defines a Palette view as a series of rectangles, each composed as a Color with a particular white value, and then displays two versions of the palette over a blue background:\n\nstruct Palette: View {\n    var body: some View {\n        HStack(spacing: 0) {\n            ForEach(0..<10) { index in\n                Color(white: Double(index) / Double(9))\n                    .frame(width: 20, height: 40)\n            }\n        }\n    }\n}\n\n\nstruct LuminanceToAlphaExample: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            Palette()\n\n\n            Palette()\n                .luminanceToAlpha()\n        }\n        .padding()\n        .background(.blue)\n    }\n}\n\n\nThe unmodified version of the palette contains rectangles that range from solid black to solid white, thus with increasing luminance. The second version of the palette, which has the luminanceToAlpha() modifier applied, allows the background to show through in an amount that corresponds inversely to the luminance of the input.\n\nSee Also\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view."
    },
    {
        "title": "contrast(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contrast(_:)",
        "html": "Parameters\namount\n\nThe intensity of color contrast to apply. negative values invert colors in addition to applying contrast.\n\nReturn Value\n\nA view that applies color contrast to this view.\n\nDiscussion\n\nApply contrast to a view to increase or decrease the separation between similar colors in the view.\n\nIn the example below, the contrast(_:) modifier is applied to a set of red squares each containing a contrasting green inner circle. At each step in the loop, the contrast(_:) modifier changes the contrast of the circle/square view in 20% increments. This ranges from -20% contrast (yielding inverted colors \u2014 turning the red square to pale-green and the green circle to mauve), to neutral-gray at 0%, to 100% contrast (bright-red square / bright-green circle). Applying negative contrast values, as shown in the -20% square, will apply contrast in addition to inverting colors.\n\nstruct CircleView: View {\n    var body: some View {\n        Circle()\n            .fill(Color.green)\n            .frame(width: 25, height: 25, alignment: .center)\n    }\n}\n\n\nstruct Contrast: View {\n    var body: some View {\n        HStack {\n            ForEach(-1..<6) {\n                Color.red.frame(width: 50, height: 50, alignment: .center)\n                    .overlay(CircleView(), alignment: .center)\n                    .contrast(Double($0) * 0.2)\n                    .overlay(Text(\"\\(Double($0) * 0.2 * 100, specifier: \"%.0f\")%\")\n                                 .font(.callout),\n                             alignment: .bottom)\n                    .border(Color.gray)\n            }\n        }\n    }\n}\n\n\nSee Also\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view."
    },
    {
        "title": "grayscale(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/grayscale(_:)",
        "html": "Parameters\namount\n\nThe intensity of grayscale to apply from 0.0 to less than 1.0. Values closer to 0.0 are more colorful, and values closer to 1.0 are less colorful.\n\nReturn Value\n\nA view that adds a grayscale effect to this view.\n\nDiscussion\n\nA grayscale effect reduces the intensity of colors in this view.\n\nThe example below shows a series of red squares with their grayscale effect increasing from 0 (reddest) to 99% (fully desaturated) in approximate 20% increments:\n\nstruct Saturation: View {\n    var body: some View {\n        HStack {\n            ForEach(0..<6) {\n                Color.red.frame(width: 60, height: 60, alignment: .center)\n                    .grayscale(Double($0) * 0.1999)\n                    .overlay(Text(\"\\(Double($0) * 0.1999 * 100, specifier: \"%.4f\")%\"),\n                             alignment: .bottom)\n                    .border(Color.gray)\n            }\n        }\n    }\n}\n\n\nSee Also\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view."
    },
    {
        "title": "colorInvert()",
        "url": "https://developer.apple.com/documentation/swiftui/view/colorinvert()",
        "html": "Return Value\n\nA view that inverts its colors.\n\nDiscussion\n\nThe colorInvert() modifier inverts all of the colors in a view so that each color displays as its complementary color. For example, blue converts to yellow, and white converts to black.\n\nIn the example below, two red squares each have an interior green circle. The inverted square shows the effect of the square\u2019s colors: complimentary colors for red and green \u2014 teal and purple.\n\nstruct InnerCircleView: View {\n    var body: some View {\n        Circle()\n            .fill(Color.green)\n            .frame(width: 40, height: 40, alignment: .center)\n    }\n}\n\n\nstruct ColorInvert: View {\n    var body: some View {\n        HStack {\n            Color.red.frame(width: 100, height: 100, alignment: .center)\n                .overlay(InnerCircleView(), alignment: .center)\n                .overlay(Text(\"Normal\")\n                             .font(.callout),\n                         alignment: .bottom)\n                .border(Color.gray)\n\n\n            Spacer()\n\n\n            Color.red.frame(width: 100, height: 100, alignment: .center)\n                .overlay(InnerCircleView(), alignment: .center)\n                .colorInvert()\n                .overlay(Text(\"Inverted\")\n                             .font(.callout),\n                         alignment: .bottom)\n                .border(Color.gray)\n        }\n        .padding(50)\n    }\n}\n\n\nSee Also\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view."
    },
    {
        "title": "backgroundStyle",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/backgroundstyle",
        "html": "See Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "Gradient",
        "url": "https://developer.apple.com/documentation/swiftui/gradient",
        "html": "Topics\nCreating a gradient from colors\ninit(colors: [Color])\nCreates a gradient from an array of colors.\nCreating a gradient from stops\ninit(stops: [Gradient.Stop])\nCreates a gradient from an array of color stops.\nvar stops: [Gradient.Stop]\nThe array of color stops.\nstruct Stop\nOne color stop in the gradient.\nWorking with color spaces\nfunc colorSpace(Gradient.ColorSpace) -> AnyGradient\nReturns a version of the gradient that will use a specified color space for interpolating between its colors.\nstruct ColorSpace\nA method of interpolating between the colors in a gradient.\nRelationships\nConforms To\nEquatable\nHashable\nScaleRange\nSendable\nShapeStyle\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "hueRotation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/huerotation(_:)",
        "html": "Parameters\nangle\n\nThe hue rotation angle to apply to the colors in this view.\n\nReturn Value\n\nA view that applies a hue rotation effect to this view.\n\nDiscussion\n\nUse hue rotation effect to shift all of the colors in a view according to the angle you specify.\n\nThe example below shows a series of squares filled with a linear gradient. Each square shows the effect of a 36\u02da hueRotation (a total of 180\u02da across the 5 squares) on the gradient:\n\nstruct HueRotation: View {\n    var body: some View {\n        HStack {\n            ForEach(0..<6) {\n                Rectangle()\n                    .fill(.linearGradient(\n                        colors: [.blue, .red, .green],\n                        startPoint: .top, endPoint: .bottom))\n                    .hueRotation((.degrees(Double($0 * 36))))\n                    .frame(width: 60, height: 60, alignment: .center)\n            }\n        }\n    }\n}\n\n\nSee Also\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view."
    },
    {
        "title": "colorMultiply(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/colormultiply(_:)",
        "html": "Parameters\ncolor\n\nThe color to bias this view toward.\n\nReturn Value\n\nA view with a color multiplication effect.\n\nDiscussion\n\nThe following example shows two versions of the same image side by side; at left is the original, and at right is a duplicate with the colorMultiply(_:) modifier applied with purple.\n\nstruct InnerCircleView: View {\n    var body: some View {\n        Circle()\n            .fill(Color.green)\n            .frame(width: 40, height: 40, alignment: .center)\n    }\n}\n\n\nstruct ColorMultiply: View {\n    var body: some View {\n        HStack {\n            Color.red.frame(width: 100, height: 100, alignment: .center)\n                .overlay(InnerCircleView(), alignment: .center)\n                .overlay(Text(\"Normal\")\n                             .font(.callout),\n                         alignment: .bottom)\n                .border(Color.gray)\n\n\n            Spacer()\n\n\n            Color.red.frame(width: 100, height: 100, alignment: .center)\n                .overlay(InnerCircleView(), alignment: .center)\n                .colorMultiply(Color.purple)\n                .overlay(Text(\"Multiply\")\n                            .font(.callout),\n                         alignment: .bottom)\n                .border(Color.gray)\n        }\n        .padding(50)\n    }\n}\n\n\nSee Also\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view."
    },
    {
        "title": "AnyShapeStyle",
        "url": "https://developer.apple.com/documentation/swiftui/anyshapestyle",
        "html": "Topics\nCreating a shape style\ninit<S>(S)\nCreate an instance from style.\nRelationships\nConforms To\nSendable\nShapeStyle\nSee Also\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows."
    },
    {
        "title": "ContentSizeCategory",
        "url": "https://developer.apple.com/documentation/swiftui/contentsizecategory",
        "html": "Deprecated\n\nUse DynamicTypeSize instead.\n\nTopics\nContent size categories\ncase accessibilityExtraExtraExtraLarge\ncase accessibilityExtraExtraLarge\ncase accessibilityExtraLarge\ncase accessibilityLarge\ncase accessibilityMedium\ncase extraExtraExtraLarge\ncase extraExtraLarge\ncase extraLarge\ncase extraSmall\ncase large\ncase medium\ncase small\nCreating a size category\ninit?(UIContentSizeCategory)\nCreate a size category from its UIContentSizeCategory equivalent.\nComparing content size categories\nvar isAccessibilityCategory: Bool\nA Boolean value indicating whether the content size category is one that is associated with accessibility.\nOperators\nstatic func < (ContentSizeCategory, ContentSizeCategory) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than that of the second argument.\nstatic func > (ContentSizeCategory, ContentSizeCategory) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func <= (ContentSizeCategory, ContentSizeCategory) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func >= (ContentSizeCategory, ContentSizeCategory) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable"
    },
    {
        "title": "strokeBorder(_:lineWidth:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview/strokeborder(_:linewidth:antialiased:)",
        "html": "Discussion\n\nThis is equivalent to insetting self by lineWidth / 2 and stroking the resulting shape with lineWidth as the line-width.\n\nSee Also\nModify the shape\nfunc fill<S>(S, style: FillStyle) -> FillShapeView<Self.Content, S, Self>\nFills this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc strokeBorder<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of insetting this view by half of its style\u2019s line width.\nAvailable when Content conforms to InsettableShape."
    },
    {
        "title": "textContentType(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textcontenttype(_:)-6fic1",
        "html": "Parameters\ntextContentType\n\nOne of the content types available in the NSTextContentType structure that identify the semantic meaning expected for a text-entry area.\n\nDiscussion\n\nUse this method to set the content type for input text. For example, you can configure a TextField for the entry of a username:\n\nTextField(\"Enter your username\", text: $username)\n    .textContentType(.username)\n\nSee Also\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input."
    },
    {
        "title": "typeSelectEquivalent(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/typeselectequivalent(_:)-36h0i",
        "html": "Parameters\ntext\n\nThe explicit text value to use as a type select equivalent for a view in a collection.\n\nDiscussion\n\nBy default, a type select equivalent is automatically derived from any Text or TextField content in a list or table. In the below example, type select can be used to select a person, even though no explicit value has been set.\n\nList(people, selection: $selectedPersonID) { person in\n    Label {\n        Text(person.name)\n    } icon: {\n        person.avatar\n    }\n}\n\n\nAn explicit type select value should be set when there is no textual content or when a different value is desired compared to what\u2019s displayed in the view. Explicit values also provide a more performant for complex view types. In the below example, type select is explicitly set to allow selection of views that otherwise only display an image.\n\nList(people, selection: $selectedPersonID) { person in\n    person.avatar\n        .accessibilityLabel(person.name)\n        .typeSelectEquivalent(person.name)\n}\n\n\nSetting an empty string value disables text selection for the view, and a value of nil results in the view using its default value.\n\nSee Also\nSpecifying text equivalents\nfunc typeSelectEquivalent(LocalizedStringKey) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nfunc typeSelectEquivalent<S>(S) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table."
    },
    {
        "title": "typesettingLanguage(_:isEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/typesettinglanguage(_:isenabled:)-4ldzm",
        "html": "Parameters\nlanguage\n\nThe explicit language to use for typesetting.\n\nisEnabled\n\nA Boolean value that indicates whether text langauge is added\n\nReturn Value\n\nA view with the typesetting language set to the value you supply.\n\nDiscussion\n\nIn some cases Text may contain text of a particular language which doesn\u2019t match the device UI language. In that case it\u2019s useful to specify a language so line height, line breaking and spacing will respect the script used for that language. For example:\n\nText(verbatim: \"\u0e41\u0e2d\u0e1b\u0e40\u0e1b\u0e34\u0e25\")\n    .typesettingLanguage(.init(languageCode: .thai))\n\n\nNote: this language does not affect text localization.\n\nSee Also\nLocalizing text\nPreparing views for localization\nSpecify hints and add strings to localize your SwiftUI views.\nstruct LocalizedStringKey\nThe key used to look up an entry in a strings file or strings dictionary file.\nvar locale: Locale\nThe current locale that views should use.\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nstruct TypesettingLanguage\nDefines how typesetting language is determined for text."
    },
    {
        "title": "lineSpacing(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/linespacing(_:)",
        "html": "Parameters\nlineSpacing\n\nThe amount of space between the bottom of one line and the top of the next line in points.\n\nDiscussion\n\nUse lineSpacing(_:) to set the amount of spacing from the bottom of one line to the top of the next for text elements in the view.\n\nIn the Text view in the example below, 10 points separate the bottom of one line to the top of the next as the text field wraps inside this view. Applying lineSpacing(_:) to a view hierarchy applies the line spacing to all text elements contained in the view.\n\nText(\"This is a string in a TextField with 10 point spacing applied between the bottom of one line and the top of the next.\")\n    .frame(width: 200, height: 200, alignment: .leading)\n    .lineSpacing(10)\n\n\nSee Also\nFormatting multiline text\nvar lineSpacing: CGFloat\nThe distance in points between the bottom of one line fragment and the top of the next.\nfunc multilineTextAlignment(TextAlignment) -> some View\nSets the alignment of a text view that contains multiple lines of text.\nvar multilineTextAlignment: TextAlignment\nAn environment value that indicates how a text view aligns its lines when the content wraps or contains newlines."
    },
    {
        "title": "TextInputDictationBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/textinputdictationbehavior",
        "html": "Topics\nGetting behavior values\nstatic let automatic: TextInputDictationBehavior\nA platform-appropriate default text input dictation behavior.\nstatic func inline(activation: TextInputDictationActivation) -> TextInputDictationBehavior\nAdds a dictation microphone in the search bar.\nstatic let preventDictation: TextInputDictationBehavior\nPrevents the search bar from having a dictation microphone.\nBeta\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nDictating text\nfunc searchDictationBehavior(TextInputDictationBehavior) -> some View\nstruct TextInputDictationActivation"
    },
    {
        "title": "textInputAutocapitalization(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textinputautocapitalization(_:)",
        "html": "Parameters\nautocapitalization\n\nOne of the capitalizing behaviors defined in the TextInputAutocapitalization struct or nil.\n\nDiscussion\n\nUse textInputAutocapitalization(_:) when you need to automatically capitalize words, sentences, or other text like proper nouns.\n\nIn example below, as the user enters text the shift key is automatically enabled before every word:\n\nTextField(\"Last, First\", text: $fullName)\n    .textInputAutocapitalization(.words)\n\n\nThe TextInputAutocapitalization struct defines the available autocapitalizing behavior. Providing nil to this view modifier does not change the autocapitalization behavior. The default is TextInputAutocapitalization.sentences.\n\nSee Also\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input."
    },
    {
        "title": "autocorrectionDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/autocorrectiondisabled(_:)",
        "html": "Parameters\ndisable\n\nA Boolean value that indicates whether autocorrection is disabled for this view. The default value is true.\n\nDiscussion\n\nUse this method when the effect of autocorrection would make it more difficult for the user to input information. The entry of proper names and street addresses are examples where autocorrection can negatively affect the user\u2019s ability complete a data entry task.\n\nThe example below configures a TextField with the default keyboard. Disabling autocorrection allows the user to enter arbitrary text without the autocorrection system offering suggestions or attempting to override their input.\n\nTextField(\"1234 Main St.\", text: $address)\n    .keyboardType(.default)\n    .autocorrectionDisabled(true)\n\nSee Also\nManaging text entry\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input."
    },
    {
        "title": "TextInputDictationActivation",
        "url": "https://developer.apple.com/documentation/swiftui/textinputdictationactivation",
        "html": "Topics\nGetting activation values\nstatic let onLook: TextInputDictationActivation\nA configuration that activates dictation when someone selects the microphone or looks at the entry field.\nstatic let onSelect: TextInputDictationActivation\nA configuration that activates dictation when someone selects the microphone.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nDictating text\nfunc searchDictationBehavior(TextInputDictationBehavior) -> some View\nstruct TextInputDictationBehavior"
    },
    {
        "title": "scrollDismissesKeyboard(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/scrolldismisseskeyboard(_:)",
        "html": "Parameters\nmode\n\nThe keyboard dismissal mode that scrollable content uses.\n\nReturn Value\n\nA view that uses the specified keyboard dismissal mode.\n\nDiscussion\n\nYou use this modifier to customize how scrollable content interacts with the software keyboard. For example, you can specify a value of immediately to indicate that you would like scrollable content to immediately dismiss the keyboard if present when a scroll drag gesture begins.\n\n@State private var text = \"\"\n\n\nScrollView {\n    TextField(\"Prompt\", text: $text)\n    ForEach(0 ..< 50) { index in\n        Text(\"\\(index)\")\n            .padding()\n    }\n}\n.scrollDismissesKeyboard(.immediately)\n\n\nYou can also use this modifier to customize the keyboard dismissal behavior for other kinds of scrollable views, like a List or a TextEditor.\n\nBy default, a TextEditor is interactive while other kinds of scrollable content always dismiss the keyboard on a scroll when linked against iOS 16 or later. Pass a value of never to indicate that scrollable content should never automatically dismiss the keyboard.\n\nSee Also\nInteracting with a software keyboard\nvar scrollDismissesKeyboardMode: ScrollDismissesKeyboardMode\nThe way that scrollable content interacts with the software keyboard.\nstruct ScrollDismissesKeyboardMode\nThe ways that scrollable content can interact with the software keyboard."
    },
    {
        "title": "autocorrectionDisabled",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/autocorrectiondisabled",
        "html": "Discussion\n\nThe default value is false.\n\nSee Also\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input."
    },
    {
        "title": "multilineTextAlignment(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/multilinetextalignment(_:)",
        "html": "Parameters\nalignment\n\nA value that you use to align multiple lines of text within a view.\n\nReturn Value\n\nA view that aligns the lines of multiline Text instances it contains.\n\nDiscussion\n\nUse this modifier to set an alignment for a multiline block of text. For example, the modifier centers the contents of the following Text view:\n\nText(\"This is a block of text that shows up in a text element as multiple lines.\\(\"\\n\") Here we have chosen to center this text.\")\n    .frame(width: 200)\n    .multilineTextAlignment(.center)\n\n\nThe text in the above example spans more than one line because:\n\nThe newline character introduces a line break.\n\nThe frame modifier limits the space available to the text view, and by default a text view wraps lines that don\u2019t fit in the available width. As a result, the text before the explicit line break wraps to three lines, and the text after uses two lines.\n\nThe modifier applies the alignment to the all the lines of text in the view, regardless of why wrapping occurs:\n\nThe modifier has no effect on a Text view that contains only one line of text, because a text view has a width that exactly matches the width of its widest line. If you want to align an entire text view rather than its contents, set the aligment of its container, like a VStack or a frame that you create with the frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:) modifier.\n\nNote\n\nYou can use this modifier to control the alignment of a Text view that you create with the init(_:style:) initializer to display localized dates and times, including when the view uses only a single line, but only when that view appears in a widget.\n\nThe modifier also affects the content alignment of other text container types, like TextEditor and TextField. In those cases, the modifier sets the alignment even when the view contains only a single line because view\u2019s width isn\u2019t dictated by the width of the text it contains.\n\nThe modifier operates by setting the multilineTextAlignment value in the environment, so it affects all the text containers in the modified view hierarchy. For example, you can apply the modifier to a VStack to configure all the text views inside the stack.\n\nSee Also\nFormatting multiline text\nfunc lineSpacing(CGFloat) -> some View\nSets the amount of space between lines of text in this view.\nvar lineSpacing: CGFloat\nThe distance in points between the bottom of one line fragment and the top of the next.\nvar multilineTextAlignment: TextAlignment\nAn environment value that indicates how a text view aligns its lines when the content wraps or contains newlines."
    },
    {
        "title": "tracking(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tracking(_:)",
        "html": "Parameters\ntracking\n\nThe amount of additional space, in points, that the view should add to each character cluster after layout. Value of 0 sets the tracking to the system default value.\n\nReturn Value\n\nA view where text has the specified amount of tracking.\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "multilineTextAlignment",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/multilinetextalignment",
        "html": "Discussion\n\nSet this value for a view hierarchy by applying the multilineTextAlignment(_:) view modifier. Views in the hierarchy that display text, like Text or TextEditor, read the value from the environment and adjust their text alignment accordingly.\n\nThis value has no effect on a Text view that contains only one line of text, because a text view has a width that exactly matches the width of its widest line. If you want to align an entire text view rather than its contents, set the aligment of its container, like a VStack or a frame that you create with the frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:) modifier.\n\nNote\n\nYou can use this value to control the alignment of a Text view that you create with the init(_:style:) initializer to display localized dates and times, including when the view uses only a single line, but only when that view appears in a widget.\n\nSee Also\nFormatting multiline text\nfunc lineSpacing(CGFloat) -> some View\nSets the amount of space between lines of text in this view.\nvar lineSpacing: CGFloat\nThe distance in points between the bottom of one line fragment and the top of the next.\nfunc multilineTextAlignment(TextAlignment) -> some View\nSets the alignment of a text view that contains multiple lines of text."
    },
    {
        "title": "flipsForRightToLeftLayoutDirection(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/flipsforrighttoleftlayoutdirection(_:)",
        "html": "Parameters\nenabled\n\nA Boolean value that indicates whether this view should have its content flipped horizontally when the layout direction is right-to-left. By default, views will adjust their layouts automatically in a right-to-left context and do not need to be mirrored.\n\nReturn Value\n\nA view that conditionally mirrors its contents horizontally when the layout direction is right-to-left.\n\nDiscussion\n\nUse flipsForRightToLeftLayoutDirection(_:) when you need the system to horizontally mirror the contents of the view when presented in a right-to-left layout.\n\nTo override the layout direction for a specific view, use the environment(_:_:) view modifier to explicitly override the layoutDirection environment value for the view.\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "TextAlignment",
        "url": "https://developer.apple.com/documentation/swiftui/textalignment",
        "html": "Topics\nGetting text alignments\ncase center\ncase leading\ncase trailing\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left."
    },
    {
        "title": "lineLimit(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/linelimit(_:)-7ufty",
        "html": "Parameters\nlimit\n\nThe line limit.\n\nDiscussion\n\nUse this modifier to specify a partial range of lines that a Text view or a vertical TextField can occupy. When the text of such views occupies more space than the provided limit, a Text view truncates its content while a TextField becomes scrollable.\n\nForm {\n    TextField(\"Title\", text: $model.title)\n    TextField(\"Notes\", text: $model.notes, axis: .vertical)\n        .lineLimit(...3)\n}\n\n\nNote\n\nThis modifier is equivalent to the lineLimit(_:) modifier taking just an integer.\n\nSee Also\nLimiting line count for multiline text\nfunc lineLimit(Int?) -> some View\nSets the maximum number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeFrom<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(ClosedRange<Int>) -> some View\nSets to a closed range the number of lines that text can occupy in this view.\nfunc lineLimit(Int, reservesSpace: Bool) -> some View\nSets a limit for the number of lines text can occupy in this view.\nvar lineLimit: Int?\nThe maximum number of lines that text can occupy in a view."
    },
    {
        "title": "lineLimit(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/linelimit(_:)-251ko",
        "html": "Parameters\nlimit\n\nThe line limit.\n\nDiscussion\n\nUse this modifier to specify a partial range of lines that a Text view or a vertical TextField can occupy. When the text of such views occupies less space than the provided limit, that view expands to occupy the minimum number of lines.\n\nForm {\n    TextField(\"Title\", text: $model.title)\n    TextField(\"Notes\", text: $model.notes, axis: .vertical)\n        .lineLimit(3...)\n}\n\nSee Also\nLimiting line count for multiline text\nfunc lineLimit(Int?) -> some View\nSets the maximum number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeThrough<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(ClosedRange<Int>) -> some View\nSets to a closed range the number of lines that text can occupy in this view.\nfunc lineLimit(Int, reservesSpace: Bool) -> some View\nSets a limit for the number of lines text can occupy in this view.\nvar lineLimit: Int?\nThe maximum number of lines that text can occupy in a view."
    },
    {
        "title": "Building layouts with stack views",
        "url": "https://developer.apple.com/documentation/swiftui/building-layouts-with-stack-views",
        "html": "Overview\n\nIndividually, HStack, VStack, and ZStack are simple views. HStack positions views in a horizontal line, VStack positions them in a vertical line, and ZStack overlays views on top of one another.\n\nWhen you initialize them with default parameters, stack views center align their content and insert a small amount of spacing between each contained view. But, when you combine and customize stacks with view modifiers, Spacer, and Divider views, you can create highly flexible and complex layouts.\n\nPlan your layout hierarchy\n\nThink about a layout in terms of how you might create it using the various types of stack views as you start to translate your design into code. Break down complex designs into smaller, simpler pieces you can build with stack views.\n\nFor example, you might build this profile view using three stack views:\n\nA ZStack contains an Image view that displays a profile picture with a semi-transparent HStack overlaid on top. The HStack contains a VStack with a pair of Text views inside it, and a Spacer view pushes the VStack to the leading side.\n\nTo create this stack view:\n\nstruct ProfileView: View {\n    var body: some View {\n        ZStack(alignment: .bottom) {\n            Image(\"ProfilePicture\")\n                .resizable()\n                .aspectRatio(contentMode: .fit)\n            HStack {\n                VStack(alignment: .leading) {\n                    Text(\"Rachael Chiseck\")\n                        .font(.headline)\n                    Text(\"Chief Executive Officer\")\n                        .font(.subheadline)\n                }\n                Spacer()\n            }\n            .padding()\n            .foregroundColor(.primary)\n            .background(Color.primary\n                            .colorInvert()\n                            .opacity(0.75))\n        }\n    }\n}\n\nPosition views with alignment and spacer views\n\nAlign any contained views inside a stack view by using a combination of the alignment property, Spacer, and Divider views.\n\nIn the previous example layout, the VStack that contains the two Text views uses the leading alignment:\n\nThe alignment property doesn\u2019t position the VStack inside its container; instead, it positions the views inside the VStack.\n\nThe alignment property of a VStack only applies to the horizontal alignment of the contained controls using HorizontalAlignment. Similarly, the alignment property for an HStack only controls the vertical alignment using VerticalAlignment. Finally, you can align views inside a ZStack along both axes with Alignment.\n\nUse Spacer views to align views along the primary axis of an HStack or VStack. Spacers expand to fill any available space and push content apart from other views or the edges of the stack.\n\nDivider views also add space in between a stack\u2019s subviews, but only insert enough space to draw a line across the stack\u2019s minor axis. They don\u2019t expand to fill available space.\n\nCreate adaptive layouts instead of explicit layouts\n\nWherever possible, define structure and hierarchy rather than explicitly positioning view frames. Instead of using explicit heights and widths for views, let them expand to fill available space. Adaptive layouts that you build adapt more easily to different device sizes and platforms.\n\nIt is possible to create this article\u2019s example layout with two stack views rather than three, by manipulating the Text view frames explicitly. While the output might look the same, the code to implement it is more brittle, and might not scale as well across devices of different size classes.\n\nYou may need to make adjustments to a layout that uses explicit adjustments by using view modifiers such as frame(width:height:alignment:) or position(x:y:), but only consider this when you can\u2019t achieve your desired layout in an adaptive, flexible way. For more information on making fine adjustments to view layout, see Making fine adjustments to a view\u2019s position.\n\nAdd depth in alternative ways\n\nIn some situations it may make sense to add depth to your layout by using the overlay(_:alignment:) and background(_:alignment:) view modifiers instead of a ZStack. The background view modifier places another view behind the view you\u2019re modifying, and overlay places a view on top of it.\n\nChoose between a stack-based approach and the view modifier approach based on how you want to determine the size of the final layout. If your layout has one dominant view that defines the size of the layout, use the overlay(_:alignment:) or background(_:alignment:) view modifier on that view. If you want the final view size to come from an aggregation of all the contained views, use a ZStack.\n\nFor example, this code overlays a ProfileDetail view on top of the Image view:\n\nstruct ProfileViewWithOverlay: View {\n    var body: some View {\n        VStack {\n            Image(\"ProfilePicture\")\n                .resizable()\n                .aspectRatio(contentMode: .fit)\n                .overlay(ProfileDetail(), alignment: .bottom)\n        }\n    }\n}\n\n\nstruct ProfileDetail: View {\n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(\"Rachael Chiseck\")\n                    .font(.headline)\n                Text(\"Chief Executive Officer\")\n                    .font(.subheadline)\n            }\n            Spacer()\n        }\n        .padding()\n        .foregroundColor(.primary)\n        .background(Color.primary\n                        .colorInvert()\n                        .opacity(0.75))\n    }\n}\n\nSee Also\nStatically arranging views in one dimension\nstruct HStack\nA view that arranges its subviews in a horizontal line.\nstruct VStack\nA view that arranges its subviews in a vertical line."
    },
    {
        "title": "VStack",
        "url": "https://developer.apple.com/documentation/swiftui/vstack",
        "html": "Overview\n\nUnlike LazyVStack, which only renders the views when your app needs to display them, a VStack renders the views all at once, regardless of whether they are on- or offscreen. Use the regular VStack when you have a small number of subviews or don\u2019t want the delayed rendering behavior of the \u201clazy\u201d version.\n\nThe following example shows a simple vertical stack of 10 text views:\n\nvar body: some View {\n    VStack(\n        alignment: .leading,\n        spacing: 10\n    ) {\n        ForEach(\n            1...10,\n            id: \\.self\n        ) {\n            Text(\"Item \\($0)\")\n        }\n    }\n}\n\n\nNote\n\nIf you need a vertical stack that conforms to the Layout protocol, like when you want to create a conditional layout using AnyLayout, use VStackLayout instead.\n\nTopics\nCreating a stack\ninit(alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> Content)\nCreates an instance with the given spacing and horizontal alignment.\nRelationships\nConforms To\nView\nSee Also\nStatically arranging views in one dimension\nBuilding layouts with stack views\nCompose complex layouts from primitive container views.\nstruct HStack\nA view that arranges its subviews in a horizontal line."
    },
    {
        "title": "Picking container views for your content",
        "url": "https://developer.apple.com/documentation/swiftui/picking-container-views-for-your-content",
        "html": "Overview\n\nSwiftUI provides a range of container views that group and repeat views. Use some containers purely for structure and layout, like stack views, lazy stack views, and grid views. Use others, like lists and forms, to also adopt system-standard visuals and interactivity.\n\nChoosing the most appropriate container views for each part of your app\u2019s user interface is an important skill to learn; it helps you with everything from positioning two views next to each other, to creating complex layouts with hundreds of elements.\n\nGroup collections of views\n\nStack views are the most primitive layout container available in SwiftUI. Use stacks to group collections of views into horizontal or vertical lines, or to stack them on top of one another.\n\nUse HStack to lay out views in a horizontal line, VStack to position views in a vertical line, and ZStack to layer views on top of one another. Then, combine stack views to compose more complex layouts. These three kinds of stacks, along with their alignment and spacing properties, view modifiers, and Spacer views combine to allow extensive layout flexibility.\n\nYou often use stack views as building blocks inside other container views. For example, a List typically contains stack views, with which you lay out views inside each row.\n\nFor more information on using stack views to lay out views, see Building layouts with stack views.\n\nRepeat views or groups of views\n\nYou can also use HStack, VStack, LazyHStack, and LazyVStack to repeat views or groups of views. Place a stack view inside a ScrollView so your content can expand beyond the bounds of its container. Users can simultaneously scroll horizontally, vertically, or in both directions.\n\nStack views and lazy stacks have similar functionality, and they may feel interchangeable, but they each have strengths in different situations. Stack views load their child views all at once, making layout fast and reliable, because the system knows the size and shape of every subview as it loads them. Lazy stacks trade some degree of layout correctness for performance, because the system only calculates the geometry for subviews as they become visible.\n\nWhen choosing the type of stack view to use, always start with a standard stack view and only switch to a lazy stack if profiling your code shows a worthwhile performance improvement. For more information on lazy stack views and how to measure your app\u2019s view loading performance, see Creating performant scrollable stacks.\n\nPosition views in a two-dimensional layout\n\nTo lay out views horizontally and vertically at the same time, use a LazyVGrid or LazyHGrid. Grids are a good container choice to lay out content that naturally displays in square containers, like an image gallery. Grids are also a good choice to scale user interface layouts up for display on larger devices. For example, a directory of contact information might suit a list or vertical stack on an iPhone, but might fit more naturally in a grid layout when scaled up to a larger device like the iPad or Mac.\n\nLike stack views, SwiftUI grid views don\u2019t inherently include a scrolling viewport; place them inside a ScrollView if the content might be larger than the available space.\n\nDisplay and interact with collections of data\n\nList views in SwiftUI are conceptually similar to the combination of a LazyVStack and ScrollView, but by default will include platform-appropriate visual styling around and between their contained items. For example, when running on iOS, the default configuration of a List adds separator lines between rows, and draws disclosure indicators for items which have navigation, and where the list is contained in a NavigationView.\n\nList views also support platform-appropriate interactivity for common tasks such as inserting, reordering, and removing items. For example, adding the onDelete(perform:) modifier to a ForEach inside a List will enable system-standard swipe-to-delete interactivity.\n\nLike LazyHStack and LazyVStack, rows inside a SwiftUI List also load lazily, and there is no non-lazy equivalent. Lists inherently scroll when necessary, and you don\u2019t need to wrap them in a ScrollView.\n\nGroup views and controls for data entry\n\nUse Form to build data-entry interfaces, settings, or preference screens that use system-standard controls.\n\nLike all SwiftUI views, forms display their content in a platform-appropriate way. Be aware that the layout of controls inside a Form may differ significantly based on the platform. For example, a Picker control in a Form on iOS adds navigation, showing the picker\u2019s choices on a separate screen, while the same Picker on macOS displays a pop-up button or set of radio buttons."
    },
    {
        "title": "HStack",
        "url": "https://developer.apple.com/documentation/swiftui/hstack",
        "html": "Overview\n\nUnlike LazyHStack, which only renders the views when your app needs to display them onscreen, an HStack renders the views all at once, regardless of whether they are on- or offscreen. Use the regular HStack when you have a small number of subviews or don\u2019t want the delayed rendering behavior of the \u201clazy\u201d version.\n\nThe following example shows a simple horizontal stack of five text views:\n\nvar body: some View {\n    HStack(\n        alignment: .top,\n        spacing: 10\n    ) {\n        ForEach(\n            1...5,\n            id: \\.self\n        ) {\n            Text(\"Item \\($0)\")\n        }\n    }\n}\n\n\nNote\n\nIf you need a horizontal stack that conforms to the Layout protocol, like when you want to create a conditional layout using AnyLayout, use HStackLayout instead.\n\nTopics\nCreating a stack\ninit(alignment: VerticalAlignment, spacing: CGFloat?, content: () -> Content)\nCreates a horizontal stack with the given spacing and vertical alignment.\nRelationships\nConforms To\nView\nSee Also\nStatically arranging views in one dimension\nBuilding layouts with stack views\nCompose complex layouts from primitive container views.\nstruct VStack\nA view that arranges its subviews in a vertical line."
    },
    {
        "title": "ContextMenu",
        "url": "https://developer.apple.com/documentation/swiftui/contextmenu",
        "html": "Deprecated\n\nUse contextMenu(menuItems:) instead.\n\nOverview\n\nA context menu view allows you to present a situationally specific menu that enables taking actions relevant to the current task.\n\nYou can create a context menu by first defining a ContextMenu container with the controls that represent the actions people can take, and then using the contextMenu(_:) view modifier to apply the menu to a view.\n\nThe example below creates and applies a two item context menu container to a Text view. The Boolean value shouldShowMenu, which defaults to true, controls the availability of context menu:\n\nprivate let menuItems = ContextMenu {\n    Button {\n        // Add this item to a list of favorites.\n    } label: {\n        Label(\"Add to Favorites\", systemImage: \"heart\")\n    }\n    Button {\n        // Open Maps and center it on this item.\n    } label: {\n        Label(\"Show in Maps\", systemImage: \"mappin\")\n    }\n}\n\n\nprivate struct ContextMenuMenuItems: View {\n    @State private var shouldShowMenu = true\n\n\n    var body: some View {\n        Text(\"Turtle Rock\")\n            .contextMenu(shouldShowMenu ? menuItems : nil)\n    }\n}\n\n\nTopics\nCreating a context menu\ninit(menuItems: () -> MenuItems)\nCreates a context menu.\nSee Also\nDeprecated types\nstruct MenuButton\nA button that displays a menu containing a list of choices when pressed.\nDeprecated\ntypealias PullDownButton\nDeprecated"
    },
    {
        "title": "PullDownButton",
        "url": "https://developer.apple.com/documentation/swiftui/pulldownbutton",
        "html": "Deprecated\n\nUse Menu instead.\n\nSee Also\nDeprecated types\nstruct MenuButton\nA button that displays a menu containing a list of choices when pressed.\nDeprecated\nstruct ContextMenu\nA container for views that you present as menu items in a context menu.\nDeprecated"
    },
    {
        "title": "menuActionDismissBehavior(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/menuactiondismissbehavior(_:)",
        "html": "Parameters\ndismissal\n\nThe menu action dismissal behavior to apply.\n\nReturn Value\n\nA view that has the specified menu dismissal behavior.\n\nDiscussion\n\nUse this modifier to control the dismissal behavior of a menu. In the example below, the menu doesn\u2019t dismiss after someone chooses either the increase or decrease action:\n\nMenu(\"Font size\") {\n    Button(action: increase) {\n        Label(\"Increase\", systemImage: \"plus.magnifyingglass\")\n    }\n    .menuActionDismissBehavior(.disabled)\n\n\n    Button(\"Reset\", action: reset)\n\n\n    Button(action: decrease) {\n        Label(\"Decrease\", systemImage: \"minus.magnifyingglass\")\n    }\n    .menuActionDismissBehavior(.disabled)\n}\n\n\nYou can use this modifier on any controls that present a menu, like a Picker that uses the menu style or a ControlGroup. For example, the code below creates a picker that disables dismissal when someone selects one of the options:\n\nPicker(\"Flavor\", selection: $selectedFlavor) {\n    ForEach(Flavor.allCases) { flavor in\n        Text(flavor.rawValue.capitalized)\n            .tag(flavor)\n    }\n}\n.pickerStyle(.menu)\n.menuActionDismissBehavior(.disabled)\n\n\nYou can also use this modifier on context menus. The example below creates a context menu that stays presented after someone selects an action to run:\n\nText(\"Favorite Card Suit\")\n    .padding()\n    .contextMenu {\n        Button(\"\u2665\ufe0f - Hearts\", action: increaseHeartsCount)\n        Button(\"\u2663\ufe0f - Clubs\", action: increaseClubsCount)\n        Button(\"\u2660\ufe0f - Spades\", action: increaseSpadesCount)\n        Button(\"\u2666\ufe0f - Diamonds\", action: increaseDiamondsCount)\n    }\n    .menuActionDismissBehavior(.disabled)\n\nSee Also\nConfiguring menu dismissal\nstruct MenuActionDismissBehavior\nThe set of menu dismissal behavior options."
    },
    {
        "title": "MenuOrder",
        "url": "https://developer.apple.com/documentation/swiftui/menuorder",
        "html": "Overview\n\nYou can configure the preferred menu order using the menuOrder(_:) view modifier.\n\nTopics\nGetting menu orders\nstatic let automatic: MenuOrder\nThe ordering of the menu chosen by the system for the current context.\nstatic let fixed: MenuOrder\nOrder items from top to bottom.\nstatic let priority: MenuOrder\nKeep the first items closest to user\u2019s interaction point.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nSetting a preferred order\nfunc menuOrder(MenuOrder) -> some View\nSets the preferred order of items for menus presented from this view.\nvar menuOrder: MenuOrder\nThe preferred order of items for menus presented from this view."
    },
    {
        "title": "Grouping data with lazy stack views",
        "url": "https://developer.apple.com/documentation/swiftui/grouping-data-with-lazy-stack-views",
        "html": "Overview\n\nLazyHStack and LazyVStack views are both able to display groups of views organized into logical sections, arranging their children in lines that grow horizontally and vertically, respectively. These stacks are \u201clazy\u201d in that the stack views don\u2019t create items until they need to be rendered onscreen. Like stack views, lazy stacks don\u2019t include any inherent support for scrolling, and you should wrap lazy stack views in ScrollView containers.\n\nTo group content or data inside a lazy stack view, use Section instances as containers for collections of grouped views. Section views don\u2019t have any visual representation themselves but can contain header and footer views that can either scroll with the stack\u2019s content or that you can pin to the top or bottom of the ScrollView.\n\nNote\n\nUse Section views to get platform-appropriate grouping inside stack views or lazy stacks, lazy grids, List, CommandMenu, Form, and several other container types.\n\nThe code samples in this article build a user interface for visualizing shades of primary colors. Each section in the stack represents a primary color, containing five subviews, each showing a different variation of the color.\n\nPrepare your data\n\nAs with views contained within a stack, each Section must be uniquely identifiable when iterated by ForEach. In this example, ColorData instances represent the sections, and ShadeData instances represent the shades of each color inside a section. Both ColorData and ShadeData conform to the Identifiable protocol.\n\nstruct ColorData: Identifiable {\n    let id = UUID()\n    let name: String\n    let color: Color\n    let variations: [ShadeData]\n\n\n    struct ShadeData: Identifiable {\n        let id = UUID()\n        var brightness: Double\n    }\n\n\n    init(color: Color, name: String) {\n        self.name = name\n        self.color = color\n        self.variations = stride(from: 0.0, to: 0.5, by: 0.1)\n            .map { ShadeData(brightness: $0) }\n    }\n}\n\nDisplay sections with headers and footers\n\nThe ColorSelectionView below sets up an array containing ColorData instances for each primary color. The LazyVStack iterates over the array of color data to create sections, then iterates over the variations to create views from the shades.\n\nstruct ColorSelectionView: View {\n    let sections = [\n        ColorData(color: .red, name: \"Reds\"),\n        ColorData(color: .green, name: \"Greens\"),\n        ColorData(color: .blue, name: \"Blues\")\n    ]\n\n\n    var body: some View {\n        ScrollView {\n            LazyVStack(spacing: 1) {\n                ForEach(sections) { section in\n                    Section(header: SectionHeaderView(colorData: section)) {\n                        ForEach(section.variations) { variation in\n                            section.color\n                                .brightness(variation.brightness)\n                                .frame(height: 20)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nGroup data with Section views and pass in a header or footer view with the header and footer properties. This example implements a SectionHeaderView as a header view, containing a semi-transparent stack view and the name of the section\u2019s color in a Text label.\n\nstruct SectionHeaderView: View {\n    var colorData: ColorData\n\n\n    var body: some View {\n        HStack {\n            Text(colorData.name)\n                .font(.headline)\n                .foregroundColor(colorData.color)\n            Spacer()\n        }\n        .padding()\n        .background(Color.primary\n                        .colorInvert()\n                        .opacity(0.75))\n    }\n}\n\n\nFor more information on using ForEach to repeat views inside a stack, see Creating performant scrollable stacks.\n\nKeep important information visible\n\nBy default, section header and footer views will scroll in sync with section content. If you want header and footer views to always remain visible, regardless of whether the top or bottom of the section is visible, then specify a set of PinnedScrollableViews for the pinnedViews property of the lazy stack view.\n\nLazyVStack(spacing: 1, pinnedViews: [.sectionHeaders]) {\n    // ...\n}\n\n\nIn LazyVStack containers, headers attach to the top and footers to the bottom. In LazyHStack containers, headers attach to the leading edge and footers to the trailing edge.\n\nWith this change, section headers are pinned to the top of the view as the user begins to scroll.\n\nSee Also\nDynamically arranging views in one dimension\nCreating performant scrollable stacks\nDisplay large numbers of repeated views efficiently with scroll views, stack views, and lazy stacks.\nstruct LazyHStack\nA view that arranges its children in a line that grows horizontally, creating items only as needed.\nstruct LazyVStack\nA view that arranges its children in a line that grows vertically, creating items only as needed.\nstruct PinnedScrollableViews\nA set of view types that may be pinned to the bounds of a scroll view."
    },
    {
        "title": "CommandMenu",
        "url": "https://developer.apple.com/documentation/swiftui/commandmenu",
        "html": "Overview\n\nCommand menus are realized as menu bar menus on macOS, inserted between the built-in View and Window menus in order of declaration. On iOS, iPadOS, and tvOS, SwiftUI creates key commands for each of a menu\u2019s commands that has a keyboard shortcut.\n\nTopics\nCreating a command menu\ninit(LocalizedStringKey, content: () -> Content)\nCreates a new menu with a localized name for a collection of app- specific commands, inserted in the standard location for app menus (after the View menu, in order with other menus declared without an explicit location).\ninit(Text, content: () -> Content)\nCreates a new menu for a collection of app-specific commands, inserted in the standard location for app menus (after the View menu, in order with other menus declared without an explicit location).\ninit<S>(S, content: () -> Content)\nCreates a new menu for a collection of app-specific commands, inserted in the standard location for app menus (after the View menu, in order with other menus declared without an explicit location).\nRelationships\nConforms To\nCommands\nSee Also\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to."
    },
    {
        "title": "commandsReplaced(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/commandsreplaced(content:)",
        "html": "Parameters\ncontent\n\nA Commands builder whose output will be used to replace the commands normally provided by the modified scene.\n\nReturn Value\n\nA scene that replaces any commands defined by its children with alternative content.\n\nDiscussion\n\nWindowGroup, Window, and other scene types all have an associated set of commands that they include by default. Apply this modifier to a scene to replace those commands with the output from the given builder.\n\nFor example, the following code adds a scene for showing the contents of the pasteboard in a dedicated window. We replace the scene\u2019s default Window > Clipboard menu command with a custom Edit > Show Clipboard command that we place next to the other pasteboard commands.\n\n@main\nstruct Example: App {\n    @Environment(\\.openWindow) var openWindow\n\n\n    var body: some Scene {\n        ...\n\n\n        Window(\"Clipboard\", id: \"clipboard\") {\n            ClipboardContentView()\n        }\n        .commandsReplaced {\n            CommandGroup(after: .pasteboard) {\n                Section {\n                    Button(\"Show Clipboard\") {\n                        openWindow(id: \"clipboard\")\n                    }\n                }\n            }\n        }\n    }\n}\n\nSee Also\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to."
    },
    {
        "title": "containerBackground(for:alignment:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/containerbackground(for:alignment:content:)",
        "html": "Parameters\nalignment\n\nThe alignment that the modifier uses to position the implicit ZStack that groups the background views. The default is center.\n\ncontainer\n\nThe container that will use the background.\n\ncontent\n\nThe view to use as the background of the container.\n\nDiscussion\n\nThe following example uses a custom View as a background:\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationStack {\n            List {\n                NavigationLink(\"Image\") {\n                    Text(\"Image\")\n                    .containerBackground(for: .navigation) {\n                        Image(name: \"ImageAsset\")\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nThe .containerBackground(for:alignment:content:) modifier differs from the background(_:ignoresSafeAreaEdges:) modifier by automatically filling an entire parent container. ContainerBackgroundPlacement describes the available containers.\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "overlay(_:in:fillStyle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/overlay(_:in:fillstyle:)",
        "html": "Parameters\nstyle\n\nA ShapeStyle that SwiftUI uses to the fill the shape that you specify.\n\nshape\n\nAn instance of a type that conforms to Shape that SwiftUI draws in front of the view.\n\nfillStyle\n\nThe FillStyle to use when drawing the shape. The default style uses the nonzero winding number rule and antialiasing.\n\nReturn Value\n\nA view with the specified shape drawn in front of it.\n\nDiscussion\n\nUse this modifier to layer a type that conforms to the Shape protocol \u2014 like a Rectangle, Circle, or Capsule \u2014 in front of a view. Specify a ShapeStyle that\u2019s used to fill the shape. For example, you can overlay the outline of one rectangle in front of another:\n\nRectangle()\n    .frame(width: 200, height: 100)\n    .overlay(.teal, in: Rectangle().inset(by: 10).stroke(lineWidth: 5))\n\n\nThe example above uses the inset(by:) method to slightly reduce the size of the overlaid rectangle, and the stroke(lineWidth:) method to fill only the shape\u2019s outline. This creates an inset border:\n\nThis modifier is a convenience method for layering a shape over a view. To handle the more general case of overlaying a View \u2014 or a stack of views \u2014 with control over the position, use overlay(alignment:content:) instead. To cover a view with a ShapeStyle, use overlay(_:ignoresSafeAreaEdges:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "overlay(_:ignoresSafeAreaEdges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/overlay(_:ignoressafeareaedges:)",
        "html": "Parameters\nstyle\n\nAn instance of a type that conforms to ShapeStyle that SwiftUI layers in front of the modified view.\n\nedges\n\nThe set of edges for which to ignore safe area insets when adding the overlay. The default value is all. Specify an empty set to respect safe area insets on all edges.\n\nReturn Value\n\nA view with the specified style drawn in front of it.\n\nDiscussion\n\nUse this modifier to layer a type that conforms to the ShapeStyle protocol, like a Color, Material, or HierarchicalShapeStyle, in front of a view. For example, you can overlay the ultraThinMaterial over a Circle:\n\nstruct CoveredCircle: View {\n    var body: some View {\n        Circle()\n            .frame(width: 300, height: 200)\n            .overlay(.ultraThinMaterial)\n    }\n}\n\n\nSwiftUI anchors the style to the view\u2019s bounds. For the example above, the overlay fills the entirety of the circle\u2019s frame (which happens to be wider than the circle is tall):\n\nSwiftUI also limits the style\u2019s extent to the view\u2019s container-relative shape. You can see this effect if you constrain the CoveredCircle view with a containerShape(_:) modifier:\n\nCoveredCircle()\n    .containerShape(RoundedRectangle(cornerRadius: 30))\n\n\nThe overlay takes on the specified container shape:\n\nBy default, the overlay ignores safe area insets on all edges, but you can provide a specific set of edges to ignore, or an empty set to respect safe area insets on all edges:\n\nRectangle()\n    .overlay(\n        .secondary,\n        ignoresSafeAreaEdges: []) // Ignore no safe area insets.\n\n\nIf you want to specify a View or a stack of views as the overlay rather than a style, use overlay(alignment:content:) instead. If you want to specify a Shape, use overlay(_:in:fillStyle:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "ContainerBackgroundPlacement",
        "url": "https://developer.apple.com/documentation/swiftui/containerbackgroundplacement",
        "html": "Overview\n\nThis method controls where to place a background that you specify with the containerBackground(_:for:) or containerBackground(for:alignment:content:) modifier.\n\nTopics\nGetting placements\nstatic let navigation: ContainerBackgroundPlacement\nA background placement inside a NavigationStack or NavigationSplitView\nstatic let tabView: ContainerBackgroundPlacement\nA background placement inside a TabView.\nstatic let widget: ContainerBackgroundPlacement\nThe container background placement for a widget.\nGetting StoreKit placements\nstatic var subscriptionStore: ContainerBackgroundPlacement\nA background placement inside a SubscriptionStoreView.\nstatic var subscriptionStoreFullHeight: ContainerBackgroundPlacement\nA background placement that spans the full height of a SubscriptionStoreView.\nstatic var subscriptionStoreHeader: ContainerBackgroundPlacement\nA background placement inside the marketing content of a SubscriptionStoreView\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view."
    },
    {
        "title": "containerBackground(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/containerbackground(_:for:)",
        "html": "Discussion\n\nThe following example uses a LinearGradient as a background:\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationStack {\n            List {\n                NavigationLink(\"Blue\") {\n                    Text(\"Blue\")\n                    .containerBackground(.blue.gradient, for: .navigation)\n                }\n                NavigationLink(\"Red\") {\n                    Text(\"Red\")\n                    .containerBackground(.red.gradient, for: .navigation)\n                }\n            }\n        }\n    }\n}\n\n\nThe .containerBackground(_:for:) modifier differs from the background(_:ignoresSafeAreaEdges:) modifier by automatically filling an entire parent container. ContainerBackgroundPlacement describes the available containers.\n\nParameters\n\nstyle: The shape style to use as the container background.\n\ncontainer: The container that will use the background.\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "backgroundMaterial",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/backgroundmaterial",
        "html": "Discussion\n\nThis value is nil if the current background isn\u2019t one of the standard materials. If you set a material, the standard content styles enable their vibrant rendering modes.\n\nYou set this value by calling one of the background modifiers that takes a ShapeStyle, like background(_:ignoresSafeAreaEdges:) or background(_:in:fillStyle:), and passing in a Material. You can also set the value manually, using nil to disable vibrant rendering, or a Material instance to enable the vibrancy style associated with the specified material.\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "Menu",
        "url": "https://developer.apple.com/documentation/swiftui/menu",
        "html": "Overview\n\nThe following example presents a menu of three buttons and a submenu, which contains three buttons of its own.\n\nMenu(\"Actions\") {\n    Button(\"Duplicate\", action: duplicate)\n    Button(\"Rename\", action: rename)\n    Button(\"Delete\u2026\", action: delete)\n    Menu(\"Copy\") {\n        Button(\"Copy\", action: copy)\n        Button(\"Copy Formatted\", action: copyFormatted)\n        Button(\"Copy Library Path\", action: copyPath)\n    }\n}\n\n\nYou can create the menu\u2019s title with a LocalizedStringKey, as seen in the previous example, or with a view builder that creates multiple views, such as an image and a text view:\n\nMenu {\n    Button(\"Open in Preview\", action: openInPreview)\n    Button(\"Save as PDF\", action: saveAsPDF)\n} label: {\n    Label(\"PDF\", systemImage: \"doc.fill\")\n}\n\nPrimary action\n\nMenus can be created with a custom primary action. The primary action will be performed when the user taps or clicks on the body of the control, and the menu presentation will happen on a secondary gesture, such as on long press or on click of the menu indicator. The following example creates a menu that adds bookmarks, with advanced options that are presented in a menu.\n\nMenu {\n    Button(action: addCurrentTabToReadingList) {\n        Label(\"Add to Reading List\", systemImage: \"eyeglasses\")\n    }\n    Button(action: bookmarkAll) {\n        Label(\"Add Bookmarks for All Tabs\", systemImage: \"book\")\n    }\n    Button(action: show) {\n        Label(\"Show All Bookmarks\", systemImage: \"books.vertical\")\n    }\n} label: {\n    Label(\"Add Bookmark\", systemImage: \"book\")\n} primaryAction: {\n    addBookmark()\n}\n\nStyling menus\n\nUse the menuStyle(_:) modifier to change the style of all menus in a view. The following example shows how to apply a custom style:\n\nMenu(\"Editing\") {\n    Button(\"Set In Point\", action: setInPoint)\n    Button(\"Set Out Point\", action: setOutPoint)\n}\n.menuStyle(EditingControlsMenuStyle())\n\nTopics\nCreating a menu from content\ninit(content: () -> Content, label: () -> Label)\nCreates a menu with a custom label.\nAvailable when Label conforms to View and Content conforms to View.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu that generates its label from a localized string key.\nAvailable when Label conforms to View and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a menu that generates its label from a string.\nAvailable when Label conforms to View and Content conforms to View.\nCreating a menu with a primary action\ninit(content: () -> Content, label: () -> Label, primaryAction: () -> Void)\nCreates a menu with a custom primary action and custom label.\nAvailable when Label conforms to View and Content conforms to View.\ninit(LocalizedStringKey, content: () -> Content, primaryAction: () -> Void)\nCreates a menu with a custom primary action that generates its label from a localized string key.\nAvailable when Label conforms to View and Content conforms to View.\ninit<S>(S, content: () -> Content, primaryAction: () -> Void)\nCreates a menu with a custom primary action that generates its label from a string.\nAvailable when Label conforms to View and Content conforms to View.\nCreating a menu with an image label\ninit<S>(S, image: ImageResource, content: () -> Content)\nCreates a menu that generates its label from a string and image resource.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: ImageResource, content: () -> Content)\nCreates a menu that generates its label from a localized string key and image resource.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: ImageResource, content: () -> Content, primaryAction: () -> Void)\nCreates a menu with a custom primary action that generates its label from a localized string key.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, content: () -> Content)\nCreates a menu that generates its label from a string and system image.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, systemImage: String, content: () -> Content)\nCreates a menu that generates its label from a localized string key and system image.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, systemImage: String, content: () -> Content, primaryAction: () -> Void)\nCreates a menu with a custom primary action that generates its label from a localized string key and system image.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\nCreating a menu from a configuration\ninit(MenuStyleConfiguration)\nCreates a menu based on a style configuration.\nAvailable when Label is MenuStyleConfiguration.Label and Content is MenuStyleConfiguration.Content.\nRelationships\nConforms To\nView\nSee Also\nCreating a menu\nfunc menuStyle<S>(S) -> some View\nSets the style for menus within this view."
    },
    {
        "title": "background(in:fillStyle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/background(in:fillstyle:)-96bda",
        "html": "Parameters\nshape\n\nAn instance of a type that conforms to Shape that SwiftUI draws behind the view using the background shape style.\n\nfillStyle\n\nThe FillStyle to use when drawing the shape. The default style uses the nonzero winding number rule and antialiasing.\n\nReturn Value\n\nA view with the specified shape drawn behind it.\n\nDiscussion\n\nThis modifier behaves like background(_:in:fillStyle:), except that it always uses the background shape style to fill the specified shape. For example, you can create a Path that outlines a trapezoid:\n\nlet trapezoid = Path { path in\n    path.move(to: .zero)\n    path.addLine(to: CGPoint(x: 90, y: 0))\n    path.addLine(to: CGPoint(x: 80, y: 50))\n    path.addLine(to: CGPoint(x: 10, y: 50))\n}\n\n\nThen you can use that shape as a background for a Label:\n\nZStack {\n    Color.teal\n    Label(\"Flag\", systemImage: \"flag.fill\")\n        .padding()\n        .background(in: trapezoid)\n}\n\n\nWithout the background modifier, the fill color shows through the label. With the modifier, the label\u2019s text and icon appear backed by a shape filled with a color that\u2019s appropriate for light or dark appearance:\n\nTo create a background with other View types \u2014 or with a stack of views \u2014 use background(alignment:content:) instead. To add a ShapeStyle as a background, use background(_:ignoresSafeAreaEdges:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "ViewThatFits",
        "url": "https://developer.apple.com/documentation/swiftui/viewthatfits",
        "html": "Overview\n\nViewThatFits evaluates its child views in the order you provide them to the initializer. It selects the first child whose ideal size on the constrained axes fits within the proposed size. This means that you provide views in order of preference. Usually this order is largest to smallest, but since a view might fit along one constrained axis but not the other, this isn\u2019t always the case. By default, ViewThatFits constrains in both the horizontal and vertical axes.\n\nThe following example shows an UploadProgressView that uses ViewThatFits to display the upload progress in one of three ways. In order, it attempts to display:\n\nAn HStack that contains a Text view and a ProgressView.\n\nOnly the ProgressView.\n\nOnly the Text view.\n\nThe progress views are fixed to a 100-point width.\n\nstruct UploadProgressView: View {\n    var uploadProgress: Double\n\n\n    var body: some View {\n        ViewThatFits(in: .horizontal) {\n            HStack {\n                Text(\"\\(uploadProgress.formatted(.percent))\")\n                ProgressView(value: uploadProgress)\n                    .frame(width: 100)\n            }\n            ProgressView(value: uploadProgress)\n                .frame(width: 100)\n            Text(\"\\(uploadProgress.formatted(.percent))\")\n        }\n    }\n}\n\n\nThis use of ViewThatFits evaluates sizes only on the horizontal axis. The following code fits the UploadProgressView to several fixed widths:\n\nVStack {\n    UploadProgressView(uploadProgress: 0.75)\n        .frame(maxWidth: 200)\n    UploadProgressView(uploadProgress: 0.75)\n        .frame(maxWidth: 100)\n    UploadProgressView(uploadProgress: 0.75)\n        .frame(maxWidth: 50)\n}\n\n\nTopics\nCreating a view that fits\ninit(in: Axis.Set, content: () -> Content)\nProduces a view constrained in the given axes from one of several alternatives provided by a view builder.\nRelationships\nConforms To\nView"
    },
    {
        "title": "background(in:fillStyle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/background(in:fillstyle:)-61m9r",
        "html": "Parameters\nshape\n\nAn instance of a type that conforms to InsettableShape that SwiftUI draws behind the view using the background shape style.\n\nfillStyle\n\nThe FillStyle to use when drawing the shape. The default style uses the nonzero winding number rule and antialiasing.\n\nReturn Value\n\nA view with the specified insettable shape drawn behind it.\n\nDiscussion\n\nThis modifier behaves like background(_:in:fillStyle:), except that it always uses the background shape style to fill the specified insettable shape. For example, you can use a RoundedRectangle as a background on a Label:\n\nZStack {\n    Color.teal\n    Label(\"Flag\", systemImage: \"flag.fill\")\n        .padding()\n        .background(in: RoundedRectangle(cornerRadius: 8))\n}\n\n\nWithout the background modifier, the fill color shows through the label. With the modifier, the label\u2019s text and icon appear backed by a shape filled with a color that\u2019s appropriate for light or dark appearance:\n\nTo create a background with other View types \u2014 or with a stack of views \u2014 use background(alignment:content:) instead. To add a ShapeStyle as a background, use background(_:ignoresSafeAreaEdges:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "background(_:in:fillStyle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/background(_:in:fillstyle:)-89n7j",
        "html": "Parameters\nstyle\n\nA ShapeStyle that SwiftUI uses to the fill the shape that you specify.\n\nshape\n\nAn instance of a type that conforms to Shape that SwiftUI draws behind the view.\n\nfillStyle\n\nThe FillStyle to use when drawing the shape. The default style uses the nonzero winding number rule and antialiasing.\n\nReturn Value\n\nA view with the specified shape drawn behind it.\n\nDiscussion\n\nUse this modifier to layer a type that conforms to the Shape protocol behind a view. Specify the ShapeStyle that\u2019s used to fill the shape. For example, you can create a Path that outlines a trapezoid:\n\nlet trapezoid = Path { path in\n    path.move(to: .zero)\n    path.addLine(to: CGPoint(x: 90, y: 0))\n    path.addLine(to: CGPoint(x: 80, y: 50))\n    path.addLine(to: CGPoint(x: 10, y: 50))\n}\n\n\nThen you can use that shape as a background for a Label:\n\nLabel(\"Flag\", systemImage: \"flag.fill\")\n    .padding()\n    .background(.teal, in: trapezoid)\n\n\nThe teal color fills the shape:\n\nThis modifier and background(_:in:fillStyle:) are convenience methods for placing a single shape behind a view. To create a background with other View types \u2014 or with a stack of views \u2014 use background(alignment:content:) instead. To add a ShapeStyle as a background, use background(_:ignoresSafeAreaEdges:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "background(_:in:fillStyle:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/background(_:in:fillstyle:)-20tq5",
        "html": "Parameters\nstyle\n\nA ShapeStyle that SwiftUI uses to the fill the shape that you specify.\n\nshape\n\nAn instance of a type that conforms to InsettableShape that SwiftUI draws behind the view.\n\nfillStyle\n\nThe FillStyle to use when drawing the shape. The default style uses the nonzero winding number rule and antialiasing.\n\nReturn Value\n\nA view with the specified insettable shape drawn behind it.\n\nDiscussion\n\nUse this modifier to layer a type that conforms to the InsettableShape protocol \u2014 like a Rectangle, Circle, or Capsule \u2014 behind a view. Specify the ShapeStyle that\u2019s used to fill the shape. For example, you can place a RoundedRectangle behind a Label:\n\nLabel(\"Flag\", systemImage: \"flag.fill\")\n    .padding()\n    .background(.teal, in: RoundedRectangle(cornerRadius: 8))\n\n\nThe teal color fills the shape:\n\nThis modifier and background(_:in:fillStyle:) are convenience methods for placing a single shape behind a view. To create a background with other View types \u2014 or with a stack of views \u2014 use background(alignment:content:) instead. To add a ShapeStyle as a background, use background(_:ignoresSafeAreaEdges:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "background(ignoresSafeAreaEdges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/background(ignoressafeareaedges:)",
        "html": "Parameters\nedges\n\nThe set of edges for which to ignore safe area insets when adding the background. The default value is all. Specify an empty set to respect safe area insets on all edges.\n\nReturn Value\n\nA view with the background shape style drawn behind it.\n\nDiscussion\n\nThis modifier behaves like background(_:ignoresSafeAreaEdges:), except that it always uses the background shape style. For example, you can add a background to a Label:\n\nZStack {\n    Color.teal\n    Label(\"Flag\", systemImage: \"flag.fill\")\n        .padding()\n        .background()\n}\n\n\nWithout the background modifier, the teal color behind the label shows through the label. With the modifier, the label\u2019s text and icon appear backed by a region filled with a color that\u2019s appropriate for light or dark appearance:\n\nIf you want to specify a View or a stack of views as the background, use background(alignment:content:) instead. To specify a Shape or InsettableShape, use background(_:in:fillStyle:) or background(_:in:fillStyle:), respectively. To configure the background of a presentation, like a sheet, use presentationBackground(_:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "contextMenu(menuItems:preview:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contextmenu(menuitems:preview:)",
        "html": "Parameters\nmenuItems\n\nA closure that produces the menu\u2019s contents. You can deactivate the context menu by returning nothing from the closure.\n\npreview\n\nA view that the system displays along with the menu.\n\nReturn Value\n\nA view that can display a context menu with a preview.\n\nDiscussion\n\nWhen you use this modifer to add a context menu to a view in your app\u2019s user interface, the system shows a preview beside the menu. Compose the menu by returning controls like Button, Toggle, and Picker from the menuItems closure. You can also use Menu to define submenus or Section to group items.\n\nDefine the preview by returning a view from the preview closure. The system sizes the preview to match the size of its content. For example, you can add a two button context menu to a Text view, and include an Image as a preview:\n\nText(\"Turtle Rock\")\n    .padding()\n    .contextMenu {\n        Button {\n            // Add this item to a list of favorites.\n        } label: {\n            Label(\"Add to Favorites\", systemImage: \"heart\")\n        }\n        Button {\n            // Open Maps and center it on this item.\n        } label: {\n            Label(\"Show in Maps\", systemImage: \"mappin\")\n        }\n    } preview: {\n        Image(\"turtlerock\") // Loads the image from an asset catalog.\n    }\n\n\nWhen someone activates the context menu with an action like touch and hold in iOS or iPadOS, the system displays the image and the menu:\n\nNote\n\nThis view modifier produces a context menu on macOS, but that platform doesn\u2019t display the preview.\n\nIf you don\u2019t need a preview, use contextMenu(menuItems:) instead. If you want to add a context menu to a container that supports selection, like a List or a Table, and you want to distinguish between menu activation on a selection and activation in an empty area of the container, use contextMenu(forSelectionType:menu:primaryAction:).\n\nSee Also\nCreating context menus\nfunc contextMenu<MenuItems>(menuItems: () -> MenuItems) -> some View\nAdds a context menu to a view.\nfunc contextMenu<I, M>(forSelectionType: I.Type, menu: (Set<I>) -> M, primaryAction: ((Set<I>) -> Void)?) -> some View\nAdds an item-based context menu to a view."
    },
    {
        "title": "contextMenu(forSelectionType:menu:primaryAction:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contextmenu(forselectiontype:menu:primaryaction:)",
        "html": "Parameters\nitemType\n\nThe identifier type of the items. Ensure that this matches the container\u2019s selection type.\n\nmenu\n\nA closure that produces the menu. A single parameter to the closure contains the set of items to act on. An empty set indicates menu activation over the empty area of the selectable container, while a non-empty set indicates menu activation over selected items. Use controls like Button, Picker, and Toggle to define the menu items. You can also create submenus using Menu, or group items with Section. You can deactivate the context menu by returning nothing from the closure.\n\nprimaryAction\n\nA closure that defines the action to perform in response to the primary interaction. A single parameter to the closure contains the set of items to act on.\n\nReturn Value\n\nA view that can display an item-based context menu.\n\nDiscussion\n\nYou can add an item-based context menu to a container that supports selection, like a List or a Table. In the closure that you use to define the menu, you receive a collection of items that depends on the selection state of the container and the location where the person clicks or taps to activate the menu. The collection contains:\n\nThe selected item or items, when people initiate the context menu from any selected item.\n\nNothing, if people tap or click to activate the context menu from an empty part of the container. This is true even when one or more items is currently selected.\n\nYou can vary the menu contents according to the number of selected items. For example, the following code has a list that defines an empty area menu, a single item menu, and a multi-item menu:\n\nstruct ContextMenuItemExample: View {\n    var items: [Item]\n    @State private var selection = Set<Item.ID>()\n\n\n    var body: some View {\n        List(selection: $selection) {\n            ForEach(items) { item in\n                Text(item.name)\n            }\n        }\n        .contextMenu(forSelectionType: Item.ID.self) { items in\n            if items.isEmpty { // Empty area menu.\n                Button(\"New Item\") { }\n\n\n            } else if items.count == 1 { // Single item menu.\n                Button(\"Copy\") { }\n                Button(\"Delete\", role: .destructive) { }\n\n\n            } else { // Multi-item menu.\n                Button(\"Copy\") { }\n                Button(\"New Folder With Selection\") { }\n                Button(\"Delete Selected\", role: .destructive) { }\n            }\n        }\n    }\n}\n\n\nThe above example assumes that the Item type conforms to the Identifiable protocol, and relies on the associated ID type for both selection and context menu presentation.\n\nIf you add the modifier to a view hierarchy that doesn\u2019t have a container that supports selection, the context menu never activates. To add a context menu that doesn\u2019t depend on selection behavior, use contextMenu(menuItems:). To add a context menu to a specific row in a table, use contextMenu(menuItems:).\n\nAdd a primary action\n\nOptionally, you can add a custom primary action to the context menu. In macOS, a single click on a row in a selectable container selects that row, and a double click performs the primary action. In iOS and iPadOS, tapping on the row activates the primary action. To select a row without performing an action, either enter edit mode or hold shift or command on a keyboard while tapping the row.\n\nFor example, you can modify the context menu from the previous example so that double clicking the row on macOS opens a new window for selected items. Get the OpenWindowAction from the environment:\n\n@Environment(\\.openWindow) private var openWindow\n\n\nThen call openWindow from inside the primaryAction closure for each item:\n\n.contextMenu(forSelectionType: Item.ID.self) { items in\n    // ...\n} primaryAction: { items in\n    for item in items {\n        openWindow(value: item)\n    }\n}\n\n\nThe open window action depends on the declaration of a WindowGroup scene in your App that responds to the Item type:\n\nWindowGroup(\"Item Detail\", for: Item.self) { $item in\n    // ...\n}\n\nSee Also\nCreating context menus\nfunc contextMenu<MenuItems>(menuItems: () -> MenuItems) -> some View\nAdds a context menu to a view.\nfunc contextMenu<M, P>(menuItems: () -> M, preview: () -> P) -> some View\nAdds a context menu with a preview to a view."
    },
    {
        "title": "background(_:ignoresSafeAreaEdges:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/background(_:ignoressafeareaedges:)",
        "html": "Parameters\nstyle\n\nAn instance of a type that conforms to ShapeStyle that SwiftUI draws behind the modified view.\n\nedges\n\nThe set of edges for which to ignore safe area insets when adding the background. The default value is all. Specify an empty set to respect safe area insets on all edges.\n\nReturn Value\n\nA view with the specified style drawn behind it.\n\nDiscussion\n\nUse this modifier to place a type that conforms to the ShapeStyle protocol \u2014 like a Color, Material, or HierarchicalShapeStyle \u2014 behind a view. For example, you can add the regularMaterial behind a Label:\n\nstruct FlagLabel: View {\n    var body: some View {\n        Label(\"Flag\", systemImage: \"flag.fill\")\n            .padding()\n            .background(.regularMaterial)\n    }\n}\n\n\nSwiftUI anchors the style to the view\u2019s bounds. For the example above, the background fills the entirety of the label\u2019s frame, which includes the padding:\n\nSwiftUI limits the background style\u2019s extent to the modified view\u2019s container-relative shape. You can see this effect if you constrain the FlagLabel view with a containerShape(_:) modifier:\n\nFlagLabel()\n    .containerShape(RoundedRectangle(cornerRadius: 16))\n\n\nThe background takes on the specified container shape:\n\nBy default, the background ignores safe area insets on all edges, but you can provide a specific set of edges to ignore, or an empty set to respect safe area insets on all edges:\n\nRectangle()\n    .background(\n        .regularMaterial,\n        ignoresSafeAreaEdges: []) // Ignore no safe area insets.\n\n\nIf you want to specify a View or a stack of views as the background, use background(alignment:content:) instead. To specify a Shape or InsettableShape, use background(_:in:fillStyle:) or background(_:in:fillStyle:), respectively. To configure the background of a presentation, like a sheet, use presentationBackground(_:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "background(alignment:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/background(alignment:content:)",
        "html": "Parameters\nalignment\n\nThe alignment that the modifier uses to position the implicit ZStack that groups the background views. The default is center.\n\ncontent\n\nA ViewBuilder that you use to declare the views to draw behind this view, stacked in a cascading order from bottom to top. The last view that you list appears at the front of the stack.\n\nReturn Value\n\nA view that uses the specified content as a background.\n\nDiscussion\n\nUse this modifier to place one or more views behind another view. For example, you can place a collection of stars beind a Text view:\n\nText(\"ABCDEF\")\n    .background(alignment: .leading) { Star(color: .red) }\n    .background(alignment: .center) { Star(color: .green) }\n    .background(alignment: .trailing) { Star(color: .blue) }\n\n\nThe example above assumes that you\u2019ve defined a Star view with a parameterized color:\n\nstruct Star: View {\n    var color: Color\n\n\n    var body: some View {\n        Image(systemName: \"star.fill\")\n            .foregroundStyle(color)\n    }\n}\n\n\nBy setting different alignment values for each modifier, you make the stars appear in different places behind the text:\n\nIf you specify more than one view in the content closure, the modifier collects all of the views in the closure into an implicit ZStack, taking them in order from back to front. For example, you can layer a vertical bar behind a circle, with both of those behind a horizontal bar:\n\nColor.blue\n    .frame(width: 200, height: 10) // Creates a horizontal bar.\n    .background {\n        Color.green\n            .frame(width: 10, height: 100) // Creates a vertical bar.\n        Circle()\n            .frame(width: 50, height: 50)\n    }\n\n\nBoth the background modifier and the implicit ZStack composed from the background content \u2014 the circle and the vertical bar \u2014 use a default center alignment. The vertical bar appears centered behind the circle, and both appear as a composite view centered behind the horizontal bar:\n\nIf you specify an alignment for the background, it applies to the implicit stack rather than to the individual views in the closure. You can see this if you add the leading alignment:\n\nColor.blue\n    .frame(width: 200, height: 10)\n    .background(alignment: .leading) {\n        Color.green\n            .frame(width: 10, height: 100)\n        Circle()\n            .frame(width: 50, height: 50)\n    }\n\n\nThe vertical bar and the circle move as a unit to align the stack with the leading edge of the horizontal bar, while the vertical bar remains centered on the circle:\n\nTo control the placement of individual items inside the content closure, either use a different background modifier for each item, as the earlier example of stars under text demonstrates, or add an explicit ZStack inside the content closure with its own alignment:\n\nColor.blue\n    .frame(width: 200, height: 10)\n    .background(alignment: .leading) {\n        ZStack(alignment: .leading) {\n            Color.green\n                .frame(width: 10, height: 100)\n            Circle()\n                .frame(width: 50, height: 50)\n        }\n    }\n\n\nThe stack alignment ensures that the circle\u2019s leading edge aligns with the vertical bar\u2019s, while the background modifier aligns the composite view with the horizontal bar:\n\nYou can achieve layering without a background modifier by putting both the modified view and the background content into a ZStack. This produces a simpler view hierarchy, but it changes the layout priority that SwiftUI applies to the views. Use the background modifier when you want the modified view to dominate the layout.\n\nIf you want to specify a ShapeStyle like a HierarchicalShapeStyle or a Material as the background, use background(_:ignoresSafeAreaEdges:) instead. To specify a Shape or InsettableShape, use background(_:in:fillStyle:) or background(_:in:fillStyle:), respectively. To configure the background of a presentation, like a sheet, use presentationBackground(alignment:content:).\n\nSee Also\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background."
    },
    {
        "title": "contextMenu(menuItems:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contextmenu(menuitems:)",
        "html": "Parameters\nmenuItems\n\nA closure that produces the menu\u2019s contents. You can deactivate the context menu by returning nothing from the closure.\n\nReturn Value\n\nA view that can display a context menu.\n\nDiscussion\n\nUse this modifier to add a context menu to a view in your app\u2019s user interface. Compose the menu by returning controls like Button, Toggle, and Picker from the menuItems closure. You can also use Menu to define submenus or Section to group items.\n\nThe following example creates a Text view that has a context menu with two buttons:\n\nText(\"Turtle Rock\")\n    .padding()\n    .contextMenu {\n        Button {\n            // Add this item to a list of favorites.\n        } label: {\n            Label(\"Add to Favorites\", systemImage: \"heart\")\n        }\n        Button {\n            // Open Maps and center it on this item.\n        } label: {\n            Label(\"Show in Maps\", systemImage: \"mappin\")\n        }\n    }\n\n\nPeople can activate the menu with an action like Control-clicking, or by using the touch and hold gesture in iOS and iPadOS:\n\nThe system dismisses the menu if someone makes a selection, or taps or clicks outside the menu.\n\nIf you want to show a preview beside the menu, use contextMenu(menuItems:preview:). To add a context menu to a container that supports selection, like a List or a Table, and to distinguish between menu activation on a selection and activation in an empty area of the container, use contextMenu(forSelectionType:menu:primaryAction:).\n\nSee Also\nCreating context menus\nfunc contextMenu<M, P>(menuItems: () -> M, preview: () -> P) -> some View\nAdds a context menu with a preview to a view.\nfunc contextMenu<I, M>(forSelectionType: I.Type, menu: (Set<I>) -> M, primaryAction: ((Set<I>) -> Void)?) -> some View\nAdds an item-based context menu to a view."
    },
    {
        "title": "textCase",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/textcase",
        "html": "Discussion\n\nThe default value is nil, displaying the Text without any case changes.\n\nSee Also\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced."
    },
    {
        "title": "textContentType(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textcontenttype(_:)-ufdv",
        "html": "Parameters\ntextContentType\n\nOne of the content types available in the UITextContentType structure that identify the semantic meaning expected for a text-entry area. These include support for email addresses, location names, URLs, and telephone numbers, to name just a few.\n\nDiscussion\n\nUse this method to set the content type for input text. For example, you can configure a TextField for the entry of email addresses:\n\nTextField(\"Enter your email\", text: $emailAddress)\n    .textContentType(.emailAddress)\n\nSee Also\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input."
    },
    {
        "title": "lineSpacing",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/linespacing",
        "html": "Discussion\n\nThis value is always nonnegative.\n\nSee Also\nFormatting multiline text\nfunc lineSpacing(CGFloat) -> some View\nSets the amount of space between lines of text in this view.\nfunc multilineTextAlignment(TextAlignment) -> some View\nSets the alignment of a text view that contains multiple lines of text.\nvar multilineTextAlignment: TextAlignment\nAn environment value that indicates how a text view aligns its lines when the content wraps or contains newlines."
    },
    {
        "title": "typeSelectEquivalent(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/typeselectequivalent(_:)-6lmlh",
        "html": "Parameters\nstringKey\n\nThe localized string key to use as a type select equivalent for a view in a collection.\n\nDiscussion\n\nBy default, a type select equivalent is automatically derived from any Text or TextField content in a list or table. In the below example, type select can be used to select a person, even though no explicit value has been set.\n\nList(people, selection: $selectedPersonID) { person in\n    Label {\n        Text(person.name)\n    } icon: {\n        person.avatar\n    }\n}\n\n\nAn explicit type select value should be set when there is no textual content or when a different value is desired compared to what\u2019s displayed in the view. Explicit values also provide a more performant for complex view types. In the below example, type select is explicitly set to allow selection of views that otherwise only display an image.\n\nList(people, selection: $selectedPersonID) { person in\n    person.avatar\n        .accessibilityLabel(person.name)\n        .typeSelectEquivalent(person.name)\n}\n\n\nSetting an empty string value disables text selection for the view, and a value of nil results in the view using its default value.\n\nSee Also\nSpecifying text equivalents\nfunc typeSelectEquivalent(Text?) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nfunc typeSelectEquivalent<S>(S) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table."
    },
    {
        "title": "Font",
        "url": "https://developer.apple.com/documentation/swiftui/font",
        "html": "Overview\n\nThe system resolves a font\u2019s value at the time it uses the font in a given environment because Font is a late-binding token.\n\nTopics\nGetting standard fonts\nstatic let extraLargeTitle2: Font\nCreate a font with the second level extra large title text style.\nBeta\nstatic let extraLargeTitle: Font\nCreate a font with the extra large title text style.\nBeta\nstatic let largeTitle: Font\nA font with the large title text style.\nstatic let title: Font\nA font with the title text style.\nstatic let title2: Font\nCreate a font for second level hierarchical headings.\nstatic let title3: Font\nCreate a font for third level hierarchical headings.\nstatic let headline: Font\nA font with the headline text style.\nstatic let subheadline: Font\nA font with the subheadline text style.\nstatic let body: Font\nA font with the body text style.\nstatic let callout: Font\nA font with the callout text style.\nstatic let caption: Font\nA font with the caption text style.\nstatic let caption2: Font\nCreate a font with the alternate caption text style.\nstatic let footnote: Font\nA font with the footnote text style.\nGetting system fonts\nstatic func system(Font.TextStyle, design: Font.Design?, weight: Font.Weight?) -> Font\nGets a system font that uses the specified style, design, and weight.\nstatic func system(size: CGFloat, weight: Font.Weight?, design: Font.Design?) -> Font\nSpecifies a system font to use, along with the style, weight, and any design parameters you want applied to the text.\nenum Design\nA design to use for fonts.\nenum TextStyle\nA dynamic text style to use for fonts.\nstruct Weight\nA weight to use for fonts.\nCreating custom fonts\nstatic func custom(String, fixedSize: CGFloat) -> Font\nCreate a custom font with the given name and a fixed size that does not scale with Dynamic Type.\nstatic func custom(String, size: CGFloat, relativeTo: Font.TextStyle) -> Font\nCreate a custom font with the given name and size that scales relative to the given textStyle.\nstatic func custom(String, size: CGFloat) -> Font\nCreate a custom font with the given name and size that scales with the body text style.\nGetting a font from another font\ninit(CTFont)\nCreates a custom font from a platform font instance.\nStyling a font\nfunc bold() -> Font\nAdds bold styling to the font.\nfunc italic() -> Font\nAdds italics to the font.\nfunc monospaced() -> Font\nReturns a fixed-width font from the same family as the base font.\nfunc monospacedDigit() -> Font\nReturns a modified font that uses fixed-width digits, while leaving other characters proportionally spaced.\nfunc smallCaps() -> Font\nAdjusts the font to enable all small capitals.\nfunc lowercaseSmallCaps() -> Font\nAdjusts the font to enable lowercase small capitals.\nfunc uppercaseSmallCaps() -> Font\nAdjusts the font to enable uppercase small capitals.\nfunc weight(Font.Weight) -> Font\nSets the weight of the font.\nfunc width(Font.Width) -> Font\nSets the width of the font.\nstruct Width\nA width to use for fonts that have multiple widths.\nfunc leading(Font.Leading) -> Font\nAdjusts the line spacing of a font.\nenum Leading\nA line spacing adjustment that you can apply to a font.\nDeprecated symbols\nstatic func system(Font.TextStyle, design: Font.Design) -> Font\nGets a system font with the given text style and design.\nDeprecated\nstatic func system(size: CGFloat, weight: Font.Weight, design: Font.Design) -> Font\nSpecifies a system font to use, along with the style, weight, and any design parameters you want applied to the text.\nDeprecated\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nSetting a font\nApplying custom fonts to text\nAdd and use a font in your app that scales with Dynamic Type.\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nvar font: Font?\nThe default font of this environment."
    },
    {
        "title": "stroke(_:lineWidth:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview/stroke(_:linewidth:antialiased:)",
        "html": "Parameters\ncontent\n\nThe color or gradient with which to stroke this shape.\n\nlineWidth\n\nThe width of the stroke that outlines this shape.\n\nReturn Value\n\nA stroked shape.\n\nDiscussion\n\nThe following example draws a circle with a purple stroke:\n\nCircle().stroke(Color.purple, lineWidth: 5)\n\nSee Also\nModify the shape\nfunc fill<S>(S, style: FillStyle) -> FillShapeView<Self.Content, S, Self>\nFills this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc strokeBorder<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of insetting this view by half of its style\u2019s line width.\nAvailable when Content conforms to InsettableShape.\nfunc strokeBorder<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of filling an inner stroke of this view with the content you supply.\nAvailable when Content conforms to InsettableShape."
    },
    {
        "title": "ShapeRole.stroke",
        "url": "https://developer.apple.com/documentation/swiftui/shaperole/stroke",
        "html": "See Also\nGetting shape roles\ncase fill\nIndicates to the shape\u2019s style that SwiftUI fills the shape.\ncase separator\nIndicates to the shape\u2019s style that SwiftUI uses the shape as a separator."
    },
    {
        "title": "init()",
        "url": "https://developer.apple.com/documentation/swiftui/app/init()",
        "html": "Required\n\nDiscussion\n\nSwift synthesizes a default initializer for structures that don\u2019t provide one. You typically rely on the default initializer for your app.\n\nSee Also\nRunning an app\nstatic func main()\nInitializes and runs the app."
    },
    {
        "title": "typesettingLanguage(_:isEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/typesettinglanguage(_:isenabled:)-39brr",
        "html": "Parameters\nlanguage\n\nThe language to use for typesetting.\n\nisEnabled\n\nA Boolean value that indicates whether text language is added\n\nReturn Value\n\nA view with the typesetting language set to the value you supply.\n\nDiscussion\n\nIn some cases Text may contain text of a particular language which doesn\u2019t match the device UI language. In that case it\u2019s useful to specify a language so line height, line breaking and spacing will respect the script used for that language. For example:\n\nText(verbatim: \"\u0e41\u0e2d\u0e1b\u0e40\u0e1b\u0e34\u0e25\").typesettingLanguage(\n    .explicit(.init(languageCode: .thai)))\n\n\nNote: this language does not affect text localized localization.\n\nSee Also\nLocalizing text\nPreparing views for localization\nSpecify hints and add strings to localize your SwiftUI views.\nstruct LocalizedStringKey\nThe key used to look up an entry in a strings file or strings dictionary file.\nvar locale: Locale\nThe current locale that views should use.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nstruct TypesettingLanguage\nDefines how typesetting language is determined for text."
    },
    {
        "title": "TypesettingLanguage",
        "url": "https://developer.apple.com/documentation/swiftui/typesettinglanguage",
        "html": "Overview\n\nUse a modifier like typesettingLanguage(_:isEnabled:) to specify the typesetting language.\n\nTopics\nGetting language behavior\nstatic let automatic: TypesettingLanguage\nAutomatic language behavior.\nstatic func explicit(Locale.Language) -> TypesettingLanguage\nUse explicit language.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nLocalizing text\nPreparing views for localization\nSpecify hints and add strings to localize your SwiftUI views.\nstruct LocalizedStringKey\nThe key used to look up an entry in a strings file or strings dictionary file.\nvar locale: Locale\nThe current locale that views should use.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> some View\nSpecifies the language for typesetting."
    },
    {
        "title": "keyboardType(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/keyboardtype(_:)",
        "html": "Parameters\ntype\n\nOne of the keyboard types defined in the UIKeyboardType enumeration.\n\nDiscussion\n\nUse keyboardType(_:) to specify the keyboard type to use for text entry. A number of different keyboard types are available to meet specialized input needs, such as entering email addresses or phone numbers.\n\nThe example below presents a TextField to input an email address. Setting the text field\u2019s keyboard type to .emailAddress ensures the user can only enter correctly formatted email addresses.\n\nTextField(\"someone@example.com\", text: $emailAddress)\n    .keyboardType(.emailAddress)\n\n\nThere are several different kinds of specialized keyboard types available though the UIKeyboardType enumeration. To specify the default system keyboard type, use .default.\n\nSee Also\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input."
    },
    {
        "title": "Preparing views for localization",
        "url": "https://developer.apple.com/documentation/swiftui/preparing-views-for-localization",
        "html": "Overview\n\nLocalize SwiftUI views so users experience your app in their own native language, region, and culture. Xcode parses SwiftUI views for strings to localize when exporting a localization catalog. You can add hints so that Xcode generates correct, hinted strings to localize for your app.\n\nFor information about string catalogs, see Localizing and varying text with a string catalog.\n\nAdd comments to text views\n\nTo ease the translation process, provide hints to translators that share how and where your app displays the strings of a Text view. To add a hint, use the optional comment parameter to the text view initializer init(_:tableName:bundle:comment:). When you localize your app with Xcode, it includes the comment string along with the string. For example, the following text view includes a comment:\n\nText(\"Explore\",\n     comment: \"The title of the tab bar item that navigates to the Explore screen.\")\n\n\nXcode creates the following entry in your string catalog file for this view:\n\nProvide additional information with text views\n\nYou can localize many SwiftUI views that have a string label by providing a string that SwiftUI interprets as a LocalizedStringKey. The system uses the key to retrieve a localized value from your string catalog at runtime, or uses the string directly if it can\u2019t find the key in the catalog. For example, SwiftUI uses the string input to the following Label initializer as a localized string key:\n\nLabel(\"Message\", image: \"msgSymbol\")\n\n\nIf you additionally want to provide a comment for localization, you can use an explicit Text view instead:\n\nLabel {\n    Text(\"Message\",\n         comment: \"A label that displays 'Message' and a corresponding image.\")\n} icon: {\n    Image(\"msgSymbol\")\n}\n\n\nMany SwiftUI controls have view builder initializers that enable you to follow this pattern. For more information on how to make your app\u2019s text translatable, see Preparing your app\u2019s text for translation.\n\nSee Also\nLocalizing text\nstruct LocalizedStringKey\nThe key used to look up an entry in a strings file or strings dictionary file.\nvar locale: Locale\nThe current locale that views should use.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nstruct TypesettingLanguage\nDefines how typesetting language is determined for text."
    },
    {
        "title": "TextInputAutocapitalization",
        "url": "https://developer.apple.com/documentation/swiftui/textinputautocapitalization",
        "html": "Overview\n\nPass an instance of TextInputAutocapitalization to the textInputAutocapitalization(_:) view modifier.\n\nTopics\nGetting autocapitalization options\nstatic var characters: TextInputAutocapitalization\nDefines an autocapitalizing behavior that will capitalize every letter.\nstatic var sentences: TextInputAutocapitalization\nDefines an autocapitalizing behavior that will capitalize the first letter in every sentence.\nstatic var words: TextInputAutocapitalization\nDefines an autocapitalizing behavior that will capitalize the first letter of every word.\nstatic var never: TextInputAutocapitalization\nDefines an autocapitalizing behavior that will not capitalize anything.\nCreating an autocapitalization type\ninit?(UITextAutocapitalizationType)\nCreates a new TextInputAutocapitalization struct from a UITextAutocapitalizationType enum.\nRelationships\nConforms To\nSendable\nSee Also\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled."
    },
    {
        "title": "LocalizedStringKey",
        "url": "https://developer.apple.com/documentation/swiftui/localizedstringkey",
        "html": "Overview\n\nInitializers for several SwiftUI types \u2013 such as Text, Toggle, Picker and others \u2013 implicitly look up a localized string when you provide a string literal. When you use the initializer Text(\"Hello\"), SwiftUI creates a LocalizedStringKey for you and uses that to look up a localization of the Hello string. This works because LocalizedStringKey conforms to ExpressibleByStringLiteral.\n\nTypes whose initializers take a LocalizedStringKey usually have a corresponding initializer that accepts a parameter that conforms to StringProtocol. Passing a String variable to these initializers avoids localization, which is usually appropriate when the variable contains a user-provided value.\n\nAs a general rule, use a string literal argument when you want localization, and a string variable argument when you don\u2019t. In the case where you want to localize the value of a string variable, use the string to create a new LocalizedStringKey instance.\n\nThe following example shows how to create Text instances both with and without localization. The title parameter provided to the Section is a literal string, so SwiftUI creates a LocalizedStringKey for it. However, the string entries in the messageStore.today array are String variables, so the Text views in the list use the string values verbatim.\n\nList {\n    Section(header: Text(\"Today\")) {\n        ForEach(messageStore.today) { message in\n            Text(message.title)\n        }\n    }\n}\n\n\nIf the app is localized into Japanese with the following translation of its Localizable.strings file:\n\n\"Today\" = \"\u4eca\u65e5\";\n\n\nWhen run in Japanese, the example produces a list like the following, localizing \u201cToday\u201d for the section header, but not the list items.\n\nTopics\nCreating a key from a literal value\ninit(String)\nCreates a localized string key from the given string value.\ninit(stringLiteral: String)\nCreates a localized string key from the given string literal.\nCreating a key from an interpolation\ninit(stringInterpolation: LocalizedStringKey.StringInterpolation)\nCreates a localized string key from the given string interpolation.\nstruct StringInterpolation\nRepresents the contents of a string literal with interpolations while it\u2019s being built, for use in creating a localized string key.\nRelationships\nConforms To\nEquatable\nExpressibleByExtendedGraphemeClusterLiteral\nExpressibleByStringInterpolation\nExpressibleByStringLiteral\nExpressibleByUnicodeScalarLiteral\nSee Also\nLocalizing text\nPreparing views for localization\nSpecify hints and add strings to localize your SwiftUI views.\nvar locale: Locale\nThe current locale that views should use.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nstruct TypesettingLanguage\nDefines how typesetting language is determined for text."
    },
    {
        "title": "typeSelectEquivalent(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/typeselectequivalent(_:)-86bom",
        "html": "Parameters\nstring\n\nThe string to use as a type select equivalent for a view in a collection.\n\nDiscussion\n\nBy default, a type select equivalent is automatically derived from any Text or TextField content in a list or table. In the below example, type select can be used to select a person, even though no explicit value has been set.\n\nList(people, selection: $selectedPersonID) { person in\n    Label {\n        Text(person.name)\n    } icon: {\n        person.avatar\n    }\n}\n\n\nAn explicit type select value should be set when there is no textual content or when a different value is desired compared to what\u2019s displayed in the view. Explicit values also provide a more performant for complex view types. In the below example, type select is explicitly set to allow selection of views that otherwise only display an image.\n\nList(people, selection: $selectedPersonID) { person in\n    person.avatar\n        .accessibilityLabel(person.name)\n        .typeSelectEquivalent(person.name)\n}\n\n\nSetting an empty string value disables text selection for the view, and a value of nil results in the view using its default value.\n\nSee Also\nSpecifying text equivalents\nfunc typeSelectEquivalent(Text?) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nfunc typeSelectEquivalent(LocalizedStringKey) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table."
    },
    {
        "title": "textContentType(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textcontenttype(_:)-4dqqb",
        "html": "Parameters\ntextContentType\n\nOne of the content types available in the WKTextContentType structure that identify the semantic meaning expected for a text-entry area. These include support for email addresses, location names, URLs, and telephone numbers, to name just a few.\n\nDiscussion\n\nUse this method to set the content type for input text. For example, you can configure a TextField for the entry of email addresses:\n\nTextField(\"Enter your email\", text: $emailAddress)\n    .textContentType(.emailAddress)\n\nSee Also\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input."
    },
    {
        "title": "locale",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/locale",
        "html": "See Also\nLocalizing text\nPreparing views for localization\nSpecify hints and add strings to localize your SwiftUI views.\nstruct LocalizedStringKey\nThe key used to look up an entry in a strings file or strings dictionary file.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nstruct TypesettingLanguage\nDefines how typesetting language is determined for text."
    },
    {
        "title": "searchDictationBehavior(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchdictationbehavior(_:)",
        "html": "See Also\nDictating text\nstruct TextInputDictationActivation\nstruct TextInputDictationBehavior"
    },
    {
        "title": "lineLimit(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/linelimit(_:)-513mb",
        "html": "Parameters\nnumber\n\nThe line limit. If nil, no line limit applies.\n\nReturn Value\n\nA view that limits the number of lines that Text instances display.\n\nDiscussion\n\nUse this modifier to cap the number of lines that an individual text element can display.\n\nThe line limit applies to all Text instances within a hierarchy. For example, an HStack with multiple pieces of text longer than three lines caps each piece of text to three lines rather than capping the total number of lines across the HStack.\n\nIn the example below, the modifier limits the very long line in the Text element to the 2 lines that fit within the view\u2019s bounds:\n\nText(\"This is a long string that demonstrates the effect of SwiftUI's lineLimit(:_) operator.\")\n    .frame(width: 200, height: 200, alignment: .leading)\n    .lineLimit(2)\n\n\nSee Also\nLimiting line count for multiline text\nfunc lineLimit(PartialRangeFrom<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeThrough<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(ClosedRange<Int>) -> some View\nSets to a closed range the number of lines that text can occupy in this view.\nfunc lineLimit(Int, reservesSpace: Bool) -> some View\nSets a limit for the number of lines text can occupy in this view.\nvar lineLimit: Int?\nThe maximum number of lines that text can occupy in a view."
    },
    {
        "title": "kerning(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/kerning(_:)",
        "html": "Parameters\nkerning\n\nThe spacing to use between individual characters in text. Value of 0 sets the kerning to the system default value.\n\nReturn Value\n\nA view where text has the specified amount of kerning.\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "baselineOffset(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/baselineoffset(_:)",
        "html": "Parameters\nbaselineOffset\n\nThe amount to shift the text vertically (up or down) relative to its baseline.\n\nReturn Value\n\nA view where text is above or below its baseline.\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "minimumScaleFactor",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/minimumscalefactor",
        "html": "Discussion\n\nIn the example below, a label with a minimumScaleFactor of 0.5 draws its text in a font size as small as half of the actual font if needed to fit into the space next to the text input field:\n\nHStack {\n    Text(\"This is a very long label:\")\n        .lineLimit(1)\n        .minimumScaleFactor(0.5)\n    TextField(\"My Long Text Field\", text: $myTextField)\n        .frame(width: 250, height: 50, alignment: .center)\n}\n\n\nYou can set the minimum scale factor to any value greater than 0 and less than or equal to 1. The default value is 1.\n\nSwiftUI uses this value to shrink text that doesn\u2019t fit in a view when it\u2019s okay to shrink the text. For example, a label with a minimumScaleFactor of 0.5 draws its text in a font size as small as half the actual font if needed.\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "ContentTransition",
        "url": "https://developer.apple.com/documentation/swiftui/contenttransition",
        "html": "Overview\n\nSet the behavior of content transitions within a view with the contentTransition(_:) modifier, passing in one of the defined transitions, such as opacity or interpolate as the parameter.\n\nTip\n\nContent transitions only take effect within transactions that apply an Animation to the views inside the contentTransition(_:) modifier.\n\nContent transitions only take effect within the context of an Animation block.\n\nTopics\nGetting content transitions\nstatic let identity: ContentTransition\nThe identity content transition, which indicates that content changes shouldn\u2019t animate.\nstatic let interpolate: ContentTransition\nA content transition that indicates the views attempt to interpolate their contents during transitions, where appropriate.\nstatic func numericText(countsDown: Bool) -> ContentTransition\nCreates a content transition intended to be used with Text views displaying numeric text. In certain environments changes to the text will enable a nonstandard transition tailored to numeric characters that count up or down.\nstatic func numericText(value: Double) -> ContentTransition\nCreates a content transition intended to be used with Text views displaying numbers.\nstatic let opacity: ContentTransition\nA content transition that indicates content fades from transparent to opaque on insertion, and from opaque to transparent on removal.\nstatic var symbolEffect: ContentTransition\nA content transition that applies the default symbol effect transition to symbol images within the inserted or removed view hierarchy. Other views are unaffected by this transition.\nstatic func symbolEffect<T>(T, options: SymbolEffectOptions) -> ContentTransition\nCreates a content transition that applies the symbol Replace animation to symbol images that it is applied to.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "transaction(_:body:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transaction(_:body:)",
        "html": "Discussion\n\nAny modifiers applied to the content of body will be applied to this view, and the changes to the transaction performed in the transform will only affect the modifiers defined in the body.\n\nThe following code animates the opacity changing with a faster animation, while the contents of MyView are animated with the implicit transaction:\n\nMyView(isActive: isActive)\n    .transaction { transaction in\n        transaction.animation = transaction.animation?.speed(2)\n    } body: { content in\n        content.opacity(isActive ? 1.0 : 0.0)\n    }\n\n\nSee Also: Transaction.disablesAnimations\n\nSee Also\nMoving an animation to another view\nfunc withTransaction<Result>(Transaction, () throws -> Result) rethrows -> Result\nExecutes a closure with the specified transaction and returns the result.\nfunc withTransaction<R, V>(WritableKeyPath<Transaction, V>, V, () throws -> R) rethrows -> R\nExecutes a closure with the specified transaction key path and value and returns the result.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nstruct Transaction\nThe context of the current state-processing update.\nprotocol TransactionKey\nA key for accessing values in a transaction."
    },
    {
        "title": "symbolRenderingMode(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/symbolrenderingmode(_:)",
        "html": "Parameters\nmode\n\nThe symbol rendering mode to use.\n\nReturn Value\n\nA view that uses the rendering mode you supply.\n\nSee Also\nSetting symbol rendering modes\nvar symbolRenderingMode: SymbolRenderingMode?\nThe current symbol rendering mode, or nil denoting that the mode is picked automatically using the current image and foreground style as parameters.\nstruct SymbolRenderingMode\nA symbol rendering mode."
    },
    {
        "title": "withTransaction(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/withtransaction(_:_:)",
        "html": "Parameters\ntransaction\n\nAn instance of a transaction, set as the thread\u2019s current transaction.\n\nbody\n\nA closure to execute.\n\nReturn Value\n\nThe result of executing the closure with the specified transaction.\n\nSee Also\nMoving an animation to another view\nfunc withTransaction<R, V>(WritableKeyPath<Transaction, V>, V, () throws -> R) rethrows -> R\nExecutes a closure with the specified transaction key path and value and returns the result.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nstruct Transaction\nThe context of the current state-processing update.\nprotocol TransactionKey\nA key for accessing values in a transaction."
    },
    {
        "title": "Spring",
        "url": "https://developer.apple.com/documentation/swiftui/spring",
        "html": "Overview\n\nUse this type to convert between different representations of spring parameters:\n\nlet spring = Spring(duration: 0.5, bounce: 0.3)\nlet (mass, stiffness, damping) = (spring.mass, spring.stiffness, spring.damping)\n// (1.0, 157.9, 17.6)\n\n\nlet spring2 = Spring(mass: 1, stiffness: 100, damping: 10)\nlet (duration, bounce) = (spring2.duration, spring2.bounce)\n// (0.63, 0.5)\n\n\nYou can also use it to query for a spring\u2019s position and its other properties for a given set of inputs:\n\nfunc unitPosition(time: TimeInterval) -> Double {\n    let spring = Spring(duration: 0.5, bounce: 0.3)\n    return spring.position(target: 1.0, time: time)\n}\n\nTopics\nCreating a spring\ninit(duration: TimeInterval, bounce: Double)\nCreates a spring with the specified duration and bounce.\ninit(mass: Double, stiffness: Double, damping: Double, allowOverDamping: Bool)\nCreates a spring with the specified mass, stiffness, and damping.\ninit(response: Double, dampingRatio: Double)\nCreates a spring with the specified response and damping ratio.\ninit(settlingDuration: TimeInterval, dampingRatio: Double, epsilon: Double)\nCreates a spring with the specified duration and damping ratio.\nGetting built-in springs\nstatic var bouncy: Spring\nA spring with a predefined duration and higher amount of bounce.\nstatic func bouncy(duration: TimeInterval, extraBounce: Double) -> Spring\nA spring with a predefined duration and higher amount of bounce that can be tuned.\nstatic var smooth: Spring\nA smooth spring with a predefined duration and no bounce.\nstatic func smooth(duration: TimeInterval, extraBounce: Double) -> Spring\nA smooth spring with a predefined duration and no bounce that can be tuned.\nstatic var snappy: Spring\nA spring with a predefined duration and small amount of bounce that feels more snappy.\nstatic func snappy(duration: TimeInterval, extraBounce: Double) -> Spring\nA spring with a predefined duration and small amount of bounce that feels more snappy and can be tuned.\nGetting spring characteristics\nvar bounce: Double\nHow bouncy the spring is.\nvar damping: Double\nDefines how the spring\u2019s motion should be damped due to the forces of friction.\nvar dampingRatio: Double\nThe amount of drag applied, as a fraction of the amount needed to produce critical damping.\nvar duration: TimeInterval\nThe perceptual duration, which defines the pace of the spring.\nvar mass: Double\nThe mass of the object attached to the end of the spring.\nvar response: Double\nThe stiffness of the spring, defined as an approximate duration in seconds.\nvar settlingDuration: TimeInterval\nThe estimated duration required for the spring system to be considered at rest.\nvar stiffness: Double\nThe spring stiffness coefficient.\nGetting spring state\nfunc value<V>(target: V, initialVelocity: V, time: TimeInterval) -> V\nCalculates the value of the spring at a given time given a target amount of change.\nfunc value<V>(fromValue: V, toValue: V, initialVelocity: V, time: TimeInterval) -> V\nCalculates the value of the spring at a given time for a starting and ending value for the spring to travel.\nfunc velocity<V>(target: V, initialVelocity: V, time: TimeInterval) -> V\nCalculates the velocity of the spring at a given time given a target amount of change.\nfunc velocity<V>(fromValue: V, toValue: V, initialVelocity: V, time: TimeInterval) -> V\nCalculates the velocity of the spring at a given time given a starting and ending value for the spring to travel.\nSetting spring state\nfunc update<V>(value: inout V, velocity: inout V, target: V, deltaTime: TimeInterval)\nUpdates the current value and velocity of a spring.\nCalculating forces and durations\nfunc force<V>(target: V, position: V, velocity: V) -> V\nCalculates the force upon the spring given a current position, target, and velocity amount of change.\nfunc force<V>(fromValue: V, toValue: V, position: V, velocity: V) -> V\nCalculates the force upon the spring given a current position, velocity, and divisor from the starting and end values for the spring to travel.\nfunc settlingDuration<V>(target: V, initialVelocity: V, epsilon: Double) -> TimeInterval\nThe estimated duration required for the spring system to be considered at rest.\nfunc settlingDuration<V>(fromValue: V, toValue: V, initialVelocity: V, epsilon: Double) -> TimeInterval\nThe estimated duration required for the spring system to be considered at rest.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCreating custom animations\nprotocol CustomAnimation\nA type that defines how an animatable value changes over time.\nstruct AnimationContext\nContextual values that a custom animation can use to manage state and access a view\u2019s environment.\nstruct AnimationState\nA container that stores the state for a custom animation.\nprotocol AnimationStateKey\nA key for accessing animation state values.\nstruct UnitCurve\nA function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed."
    },
    {
        "title": "withTransaction(_:_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/withtransaction(_:_:_:)",
        "html": "Parameters\nkeyPath\n\nA key path that indicates the property of the Transaction structure to update.\n\nvalue\n\nThe new value to set for the item specified by keyPath.\n\nbody\n\nA closure to execute.\n\nReturn Value\n\nThe result of executing the closure with the specified transaction value.\n\nSee Also\nMoving an animation to another view\nfunc withTransaction<Result>(Transaction, () throws -> Result) rethrows -> Result\nExecutes a closure with the specified transaction and returns the result.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nstruct Transaction\nThe context of the current state-processing update.\nprotocol TransactionKey\nA key for accessing values in a transaction."
    },
    {
        "title": "UnitCurve",
        "url": "https://developer.apple.com/documentation/swiftui/unitcurve",
        "html": "Overview\n\nThe horizontal (x) axis defines the input progress: a single input progress value in the range [0,1] must be provided when evaluating a curve.\n\nThe vertical (y) axis maps to the output progress: when a curve is evaluated, the y component of the point that intersects the input progress is returned.\n\nTopics\nGetting a linear curve\nstatic let linear: UnitCurve\nA linear curve.\nGetting easing curves\nstatic let easeIn: UnitCurve\nA bezier curve that starts out slowly, then speeds up as it finishes.\nstatic let easeOut: UnitCurve\nA bezier curve that starts out quickly, then slows down as it approaches the end.\nstatic let easeInOut: UnitCurve\nA bezier curve that starts out slowly, speeds up over the middle, then slows down again as it approaches the end.\nstatic let circularEaseIn: UnitCurve\nA curve that starts out slowly, then speeds up as it finishes.\nstatic let circularEaseOut: UnitCurve\nA circular curve that starts out quickly, then slows down as it approaches the end.\nstatic let circularEaseInOut: UnitCurve\nA circular curve that starts out slowly, speeds up over the middle, then slows down again as it approaches the end.\nCreating a general Bezier curve\nstatic func bezier(startControlPoint: UnitPoint, endControlPoint: UnitPoint) -> UnitCurve\nCreates a new curve using bezier control points.\nInverting a curve\nvar inverse: UnitCurve\nReturns a copy of the curve with its x and y components swapped.\nGetting curve characteristics\nfunc value(at: Double) -> Double\nReturns the output value (y component) of the curve at the given time.\nfunc velocity(at: Double) -> Double\nReturns the rate of change (first derivative) of the output value of the curve at the given time.\nDeprecated symbols\nstatic let easeInEaseOut: UnitCurve\nA bezier curve that starts out slowly, speeds up over the middle, then slows down again as it approaches the end.\nDeprecated\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCreating custom animations\nprotocol CustomAnimation\nA type that defines how an animatable value changes over time.\nstruct AnimationContext\nContextual values that a custom animation can use to manage state and access a view\u2019s environment.\nstruct AnimationState\nA container that stores the state for a custom animation.\nprotocol AnimationStateKey\nA key for accessing animation state values.\nstruct Spring\nA representation of a spring\u2019s motion."
    },
    {
        "title": "AnimationState",
        "url": "https://developer.apple.com/documentation/swiftui/animationstate",
        "html": "Overview\n\nAn AnimationContext uses this type to store state for a CustomAnimation. To retrieve the stored state of a context, you can use the state property. However, a more convenient way to access the animation state is to define an AnimationStateKey and extend AnimationContext with a computed property that gets and sets the animation state, as shown in the following code:\n\nprivate struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    static var defaultValue: Self { .init() }\n}\n\n\nextension AnimationContext {\n    fileprivate var pausableState: PausableState<Value> {\n        get { state[PausableState<Value>.self] }\n        set { state[PausableState<Value>.self] = newValue }\n    }\n}\n\n\nWhen creating an AnimationStateKey, it\u2019s convenient to define the state values that your custom animation needs. For example, the following code adds the properties paused and pauseTime to the PausableState animation state key:\n\nprivate struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    var paused = false\n    var pauseTime: TimeInterval = 0.0\n\n\n    static var defaultValue: Self { .init() }\n}\n\n\nTo access the pausable state in a PausableAnimation, the follow code calls pausableState instead of using the context\u2019s state property. And because the animation state key PausableState defines properties for state values, the custom animation can read and write those values.\n\nstruct PausableAnimation: CustomAnimation {\n    let base: Animation\n\n\n    func animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V? where V : VectorArithmetic {\n        let paused = context.environment.animationPaused\n\n\n        let pausableState = context.pausableState\n        var pauseTime = pausableState.pauseTime\n        if pausableState.paused != paused {\n            pauseTime = time - pauseTime\n            context.pausableState = PausableState(paused: paused, pauseTime: pauseTime)\n        }\n\n\n        let effectiveTime = paused ? pauseTime : time - pauseTime\n        let result = base.animate(value: value, time: effectiveTime, context: &context)\n        return result\n    }\n}\n\nStoring state for secondary animations\n\nA custom animation can also use AnimationState to store the state of a secondary animation. For example, the following code creates an AnimationStateKey that includes the property secondaryState, which a custom animation can use to store other state:\n\nprivate struct TargetState<Value: VectorArithmetic>: AnimationStateKey {\n    var timeDelta = 0.0\n    var valueDelta = Value.zero\n    var secondaryState: AnimationState<Value>? = .init()\n\n\n    static var defaultValue: Self { .init() }\n}\n\n\nextension AnimationContext {\n    fileprivate var targetState: TargetState<Value> {\n        get { state[TargetState<Value>.self] }\n        set { state[TargetState<Value>.self] = newValue }\n    }\n}\n\n\nThe custom animation TargetAnimation uses TargetState to store state data in secondaryState for another animation that runs as part of the target animation.\n\nstruct TargetAnimation: CustomAnimation {\n    var base: Animation\n    var secondary: Animation\n\n\n    func animate<V: VectorArithmetic>(value: V, time: Double, context: inout AnimationContext<V>) -> V? {\n        var targetValue = value\n        if let secondaryState = context.targetState.secondaryState {\n            var secondaryContext = context\n            secondaryContext.state = secondaryState\n            let secondaryValue = value - context.targetState.valueDelta\n            let result = secondary.animate(\n                value: secondaryValue, time: time - context.targetState.timeDelta,\n                context: &secondaryContext)\n            if let result = result {\n                context.targetState.secondaryState = secondaryContext.state\n                targetValue = result + context.targetState.valueDelta\n            } else {\n                context.targetState.secondaryState = nil\n            }\n        }\n        let result = base.animate(value: targetValue, time: time, context: &context)\n        if let result = result {\n            targetValue = result\n        } else if context.targetState.secondaryState == nil {\n            return nil\n        }\n        return targetValue\n}\n\n\n    func shouldMerge<V: VectorArithmetic>(previous: Animation, value: V, time: Double, context: inout AnimationContext<V>) -> Bool {\n        guard let previous = previous.base as? Self else { return false }\n        var secondaryContext = context\n        if let secondaryState = context.targetState.secondaryState {\n            secondaryContext.state = secondaryState\n            context.targetState.valueDelta = secondary.animate(\n                value: value, time: time - context.targetState.timeDelta,\n                context: &secondaryContext) ?? value\n        } else {\n            context.targetState.valueDelta = value\n        }\n        // Reset the target each time a merge occurs.\n        context.targetState.secondaryState = .init()\n        context.targetState.timeDelta = time\n        return base.shouldMerge(\n            previous: previous.base, value: value, time: time,\n            context: &context)\n    }\n}\n\nTopics\nCreating animation state\ninit()\nCreate an empty state container.\nAccessing custom keys\nsubscript<K>(K.Type) -> K.Value\nAccesses the state for a custom key.\nSee Also\nCreating custom animations\nprotocol CustomAnimation\nA type that defines how an animatable value changes over time.\nstruct AnimationContext\nContextual values that a custom animation can use to manage state and access a view\u2019s environment.\nprotocol AnimationStateKey\nA key for accessing animation state values.\nstruct UnitCurve\nA function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed.\nstruct Spring\nA representation of a spring\u2019s motion."
    },
    {
        "title": "monospaced(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/monospaced(_:)",
        "html": "Return Value\n\nA view whose child views\u2019 fonts use fixed-width characters, while leaving other characters proportionally spaced.\n\nDiscussion\n\nIf a child view\u2019s base font doesn\u2019t support fixed-width, the font remains unchanged.\n\nSee Also\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced."
    },
    {
        "title": "AnimationStateKey",
        "url": "https://developer.apple.com/documentation/swiftui/animationstatekey",
        "html": "Overview\n\nTo access animation state from an AnimationContext in a custom animation, create an AnimationStateKey. For example, the following code creates an animation state key named PausableState and sets the value for the required defaultValue property. The code also defines properties for state values that the custom animation needs when calculating animation values. Keeping the state values in the animation state key makes it more convenient to read and write those values in the implementation of a CustomAnimation.\n\nprivate struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    var paused = false\n    var pauseTime: TimeInterval = 0.0\n\n\n    static var defaultValue: Self { .init() }\n}\n\n\nTo make accessing the value of the animation state key more convenient, define a property for it by extending AnimationContext:\n\nextension AnimationContext {\n    fileprivate var pausableState: PausableState<Value> {\n        get { state[PausableState<Value>.self] }\n        set { state[PausableState<Value>.self] = newValue }\n    }\n}\n\n\nThen, you can read and write your state in an instance of CustomAnimation using the AnimationContext:\n\nstruct PausableAnimation: CustomAnimation {\n    let base: Animation\n\n\n    func animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V? where V : VectorArithmetic {\n        let paused = context.environment.animationPaused\n\n\n        let pausableState = context.pausableState\n        var pauseTime = pausableState.pauseTime\n        if pausableState.paused != paused {\n            pauseTime = time - pauseTime\n            context.pausableState = PausableState(paused: paused, pauseTime: pauseTime)\n        }\n\n\n        let effectiveTime = paused ? pauseTime : time - pauseTime\n        let result = base.animate(value: value, time: effectiveTime, context: &context)\n        return result\n    }\n}\n\nTopics\nSetting the default value\nstatic var defaultValue: Self.Value\nThe default value for the animation state key.\n\nRequired\n\nassociatedtype Value\nThe associated type representing the type of the animation state key\u2019s value.\n\nRequired\n\nSee Also\nCreating custom animations\nprotocol CustomAnimation\nA type that defines how an animatable value changes over time.\nstruct AnimationContext\nContextual values that a custom animation can use to manage state and access a view\u2019s environment.\nstruct AnimationState\nA container that stores the state for a custom animation.\nstruct UnitCurve\nA function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed.\nstruct Spring\nA representation of a spring\u2019s motion."
    },
    {
        "title": "textCase(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textcase(_:)",
        "html": "Parameters\ntextCase\n\nOne of the Text.Case enumerations; the default is nil.\n\nReturn Value\n\nA view that transforms the case of the text.\n\nDiscussion\n\nThe default value is nil, displaying the text without any case changes.\n\nSee Also\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced."
    },
    {
        "title": "strikethrough(_:pattern:color:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/strikethrough(_:pattern:color:)",
        "html": "Parameters\nisActive\n\nA Boolean value that indicates whether strikethrough is added. The default value is true.\n\npattern\n\nThe pattern of the line. The default value is solid.\n\ncolor\n\nThe color of the strikethrough. If color is nil, the strikethrough uses the default foreground color.\n\nReturn Value\n\nA view where text has a line through its center.\n\nSee Also\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced."
    },
    {
        "title": "Transaction",
        "url": "https://developer.apple.com/documentation/swiftui/transaction",
        "html": "Overview\n\nUse a transaction to pass an animation between views in a view hierarchy.\n\nThe root transaction for a state change comes from the binding that changed, plus any global values set by calling withTransaction(_:_:) or withAnimation(_:_:).\n\nTopics\nCreating a transaction\ninit()\nCreates a transaction.\ninit(animation: Animation?)\nCreates a transaction and assigns its animation property.\nManaging animations\nvar animation: Animation?\nThe animation, if any, associated with the current state change.\nvar disablesAnimations: Bool\nA Boolean value that indicates whether views should disable animations.\nfunc addAnimationCompletion(criteria: AnimationCompletionCriteria, () -> Void)\nAdds a completion to run when the animations created with this transaction are all complete.\nManaging window dismissal\nvar dismissBehavior: DismissBehavior\nThe behavior for how windows will dismiss programmatically when used in conjunction with DismissWindowAction.\nGetting information about a transaction\nvar isContinuous: Bool\nA Boolean value that indicates whether the transaction originated from an action that produces a sequence of values.\nvar scrollTargetAnchor: UnitPoint?\nThe preferred alignment of the view within a scroll view\u2019s visible region when scrolling to a view.\nvar tracksVelocity: Bool\nWhether this transaction will track the velocity of any animatable properties that change.\nsubscript<K>(K.Type) -> K.Value\nAccesses the transaction value associated with a custom key.\nSee Also\nMoving an animation to another view\nfunc withTransaction<Result>(Transaction, () throws -> Result) rethrows -> Result\nExecutes a closure with the specified transaction and returns the result.\nfunc withTransaction<R, V>(WritableKeyPath<Transaction, V>, V, () throws -> R) rethrows -> R\nExecutes a closure with the specified transaction key path and value and returns the result.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nprotocol TransactionKey\nA key for accessing values in a transaction."
    },
    {
        "title": "underline(_:pattern:color:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/underline(_:pattern:color:)",
        "html": "Parameters\nisActive\n\nA Boolean value that indicates whether underline is added. The default value is true.\n\npattern\n\nThe pattern of the line. The default value is solid.\n\ncolor\n\nThe color of the underline. If color is nil, the underline uses the default foreground color.\n\nReturn Value\n\nA view where text has a line running along its baseline.\n\nSee Also\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced."
    },
    {
        "title": "SecureField",
        "url": "https://developer.apple.com/documentation/swiftui/securefield",
        "html": "Overview\n\nUse a SecureField when you want behavior similar to a TextField, but you don\u2019t want the user\u2019s text to be visible. Typically, you use this for entering passwords and other sensitive information.\n\nA SecureField uses a binding to a string value, and a closure that executes when the user commits their edits, such as by pressing the Return key. The field updates the bound string on every keystroke or other edit, so you can read its value at any time from another control, such as a Done button.\n\nThe following example shows a SecureField bound to the string password. If the user commits their edit in the secure field, the onCommit closure sends the password string to a handleLogin() method.\n\n@State private var username: String = \"\"\n@State private var password: String = \"\"\n\n\nvar body: some View {\n    TextField(\n        \"User name (email address)\",\n        text: $username)\n        .autocapitalization(.none)\n        .disableAutocorrection(true)\n        .border(Color(UIColor.separator))\n    SecureField(\n        \"Password\",\n        text: $password\n    ) {\n        handleLogin(username: username, password: password)\n    }\n    .border(Color(UIColor.separator))\n}\n\n\nSecureField prompts\n\nA secure field may be provided an explicit prompt to guide users on what text they should provide. The context in which a secure field appears determines where and when a prompt and label may be used. For example, a form on macOS will always place the label alongside the leading edge of the field and will use a prompt, when available, as placeholder text within the field itself. In the same context on iOS, the prompt or label will be used as placeholder text depending on whether a prompt is provided.\n\nForm {\n    TextField(text: $username, prompt: Text(\"Required\")) {\n        Text(\"Username\")\n    }\n    SecureField(text: $username, prompt: Text(\"Required\")) {\n        Text(\"Password\")\n   }\n}\n\nTopics\nCreating a secure text field\ninit(LocalizedStringKey, text: Binding<String>, prompt: Text?)\nCreates a secure field with a prompt generated from a Text.\nAvailable when Label is Text.\ninit<S>(S, text: Binding<String>, prompt: Text?)\nCreates a secure field with a prompt generated from a Text.\nAvailable when Label is Text.\ninit(text: Binding<String>, prompt: Text?, label: () -> Label)\nCreates a secure field with a prompt generated from a Text.\nAvailable when Label conforms to View.\ninit(LocalizedStringKey, text: Binding<String>)\nCreates a secure field with a prompt generated from a Text.\nAvailable when Label is Text.\ninit<S>(S, text: Binding<String>)\nCreates a secure field with a prompt generated from a Text.\nAvailable when Label is Text.\nDeprecated initializers\ninit(LocalizedStringKey, text: Binding<String>, onCommit: () -> Void)\nCreates an instance.\nAvailable when Label is Text.\nDeprecated\ninit<S>(S, text: Binding<String>, onCommit: () -> Void)\nCreates an instance.\nAvailable when Label is Text.\nDeprecated\nRelationships\nConforms To\nView\nSee Also\nGetting text input\nstruct TextField\nA control that displays an editable text interface.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nstruct TextEditor\nA view that can display and edit long-form text."
    },
    {
        "title": "TextField",
        "url": "https://developer.apple.com/documentation/swiftui/textfield",
        "html": "Overview\n\nYou create a text field with a label and a binding to a value. If the value is a string, the text field updates this value continuously as the user types or otherwise edits the text in the field. For non-string types, it updates the value when the user commits their edits, such as by pressing the Return key.\n\nThe following example shows a text field to accept a username, and a Text view below it that shadows the continuously updated value of username. The Text view changes color as the user begins and ends editing. When the user submits their completed entry to the text field, the onSubmit(of:_:) modifer calls an internal validate(name:) method.\n\n@State private var username: String = \"\"\n@FocusState private var emailFieldIsFocused: Bool = false\n\n\nvar body: some View {\n    TextField(\n        \"User name (email address)\",\n        text: $username\n    )\n    .focused($emailFieldIsFocused)\n    .onSubmit {\n        validate(name: username)\n    }\n    .textInputAutocapitalization(.never)\n    .disableAutocorrection(true)\n    .border(.secondary)\n\n\n    Text(username)\n        .foregroundColor(emailFieldIsFocused ? .red : .blue)\n}\n\n\nThe bound value doesn\u2019t have to be a string. By using a FormatStyle, you can bind the text field to a nonstring type, using the format style to convert the typed text into an instance of the bound type. The following example uses a PersonNameComponents.FormatStyle to convert the name typed in the text field to a PersonNameComponents instance. A Text view below the text field shows the debug description string of this instance.\n\n@State private var nameComponents = PersonNameComponents()\n\n\nvar body: some View {\n    TextField(\n        \"Proper name\",\n        value: $nameComponents,\n        format: .name(style: .medium)\n    )\n    .onSubmit {\n        validate(components: nameComponents)\n    }\n    .disableAutocorrection(true)\n    .border(.secondary)\n    Text(nameComponents.debugDescription)\n}\n\n\nText field prompts\n\nYou can set an explicit prompt on the text field to guide users on what text they should provide. Each text field style determines where and when the text field uses a prompt and label. For example, a form on macOS always places the label at the leading edge of the field and uses a prompt, when available, as placeholder text within the field itself. In the same context on iOS, the text field uses either the prompt or label as placeholder text, depending on whether the initializer provided a prompt.\n\nThe following example shows a Form with two text fields, each of which provides a prompt to indicate that the field is required, and a view builder to provide a label:\n\nForm {\n    TextField(text: $username, prompt: Text(\"Required\")) {\n        Text(\"Username\")\n    }\n    SecureField(text: $password, prompt: Text(\"Required\")) {\n        Text(\"Password\")\n    }\n}\n\n\nStyling text fields\n\nSwiftUI provides a default text field style that reflects an appearance and behavior appropriate to the platform. The default style also takes the current context into consideration, like whether the text field is in a container that presents text fields with a special style. Beyond this, you can customize the appearance and interaction of text fields using the textFieldStyle(_:) modifier, passing in an instance of TextFieldStyle. The following example applies the roundedBorder style to both text fields within a VStack.\n\n@State private var givenName: String = \"\"\n@State private var familyName: String = \"\"\n\n\nvar body: some View {\n    VStack {\n        TextField(\n            \"Given Name\",\n            text: $givenName\n        )\n        .disableAutocorrection(true)\n        TextField(\n            \"Family Name\",\n            text: $familyName\n        )\n        .disableAutocorrection(true)\n    }\n    .textFieldStyle(.roundedBorder)\n}\n\n\nTopics\nCreating a text field with a string\ninit(LocalizedStringKey, text: Binding<String>)\nCreates a text field with a text label generated from a localized title string.\nAvailable when Label is Text.\ninit<S>(S, text: Binding<String>)\nCreates a text field with a text label generated from a title string.\nAvailable when Label is Text.\ninit(LocalizedStringKey, text: Binding<String>, prompt: Text?)\nCreates a text field with a text label generated from a localized title string.\nAvailable when Label is Text.\ninit<S>(S, text: Binding<String>, prompt: Text?)\nCreates a text field with a text label generated from a title string.\nAvailable when Label is Text.\ninit(text: Binding<String>, prompt: Text?, label: () -> Label)\nCreates a text field with a prompt generated from a Text.\nAvailable when Label conforms to View.\nCreating a scrollable text field\ninit(LocalizedStringKey, text: Binding<String>, axis: Axis)\nCreates a text field with a preferred axis and a text label generated from a localized title string.\nAvailable when Label is Text.\ninit<S>(S, text: Binding<String>, axis: Axis)\nCreates a text field with a preferred axis and a text label generated from a title string.\nAvailable when Label is Text.\ninit(LocalizedStringKey, text: Binding<String>, prompt: Text?, axis: Axis)\nCreates a text field with a preferred axis and a text label generated from a localized title string.\nAvailable when Label is Text.\ninit<S>(S, text: Binding<String>, prompt: Text?, axis: Axis)\nCreates a text field with a text label generated from a title string.\nAvailable when Label is Text.\ninit(text: Binding<String>, prompt: Text?, axis: Axis, label: () -> Label)\nCreates a text field with a preferred axis and a prompt generated from a Text.\nAvailable when Label conforms to View.\nCreating a text field with a value\nUse these initializers to create a text field that binds to a value of an arbitrary type.\ninit<F>(LocalizedStringKey, value: Binding<F.FormatInput>, format: F, prompt: Text?)\nCreates a text field that applies a format style to a bound value, with a label generated from a localized title string.\nAvailable when Label is Text.\ninit<S, F>(S, value: Binding<F.FormatInput>, format: F, prompt: Text?)\nCreates a text field that applies a format style to a bound value, with a label generated from a title string.\nAvailable when Label is Text.\ninit<F>(value: Binding<F.FormatInput>, format: F, prompt: Text?, label: () -> Label)\nCreates a text field that applies a format style to a bound value, with a label generated from a view builder.\nAvailable when Label conforms to View.\ninit<S, V>(S, value: Binding<V>, formatter: Formatter)\nCreate an instance which binds over an arbitrary type, V.\nAvailable when Label is Text.\ninit<V>(LocalizedStringKey, value: Binding<V>, formatter: Formatter)\nCreate an instance which binds over an arbitrary type, V.\nAvailable when Label is Text.\ninit<V>(LocalizedStringKey, value: Binding<V>, formatter: Formatter, prompt: Text?)\nCreates a text field that applies a formatter to a bound value, with a label generated from a localized title string.\nAvailable when Label is Text.\ninit<S, V>(S, value: Binding<V>, formatter: Formatter, prompt: Text?)\nCreates a text field that applies a formatter to a bound value, with a label generated from a title string.\nAvailable when Label is Text.\ninit<V>(value: Binding<V>, formatter: Formatter, prompt: Text?, label: () -> Label)\nCreates a text field that applies a formatter to a bound optional value, with a label generated from a view builder.\nAvailable when Label conforms to View.\nCreating a text field with an optional\nUse these initializers to create a text field binds to an optional value of an arbitrary type.\ninit<F>(LocalizedStringKey, value: Binding<F.FormatInput?>, format: F, prompt: Text?)\nCreates a text field that applies a format style to a bound optional value, with a label generated from a localized title string.\nAvailable when Label is Text.\ninit<S, F>(S, value: Binding<F.FormatInput?>, format: F, prompt: Text?)\nCreates a text field that applies a format style to a bound optional value, with a label generated from a title string.\nAvailable when Label is Text.\ninit<F>(value: Binding<F.FormatInput?>, format: F, prompt: Text?, label: () -> Label)\nCreates a text field that applies a format style to a bound optional value, with a label generated from a view builder.\nAvailable when Label conforms to View.\nDeprecated initializers\nDeprecated initializers\nReview deprecated text field initializers.\nRelationships\nConforms To\nView\nSee Also\nGetting text input\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nstruct SecureField\nA control into which the user securely enters private text.\nstruct TextEditor\nA view that can display and edit long-form text."
    },
    {
        "title": "fill(_:style:)",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview/fill(_:style:)",
        "html": "Parameters\ncontent\n\nThe color or gradient to use when filling this shape.\n\nstyle\n\nThe style options that determine how the fill renders.\n\nReturn Value\n\nA shape filled with the color or gradient you supply.\n\nSee Also\nModify the shape\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc strokeBorder<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of insetting this view by half of its style\u2019s line width.\nAvailable when Content conforms to InsettableShape.\nfunc strokeBorder<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of filling an inner stroke of this view with the content you supply.\nAvailable when Content conforms to InsettableShape."
    },
    {
        "title": "Text",
        "url": "https://developer.apple.com/documentation/swiftui/text",
        "html": "Overview\n\nA text view draws a string in your app\u2019s user interface using a body font that\u2019s appropriate for the current platform. You can choose a different standard font, like title or caption, using the font(_:) view modifier.\n\nText(\"Hamlet\")\n    .font(.title)\n\n\nIf you need finer control over the styling of the text, you can use the same modifier to configure a system font or choose a custom font. You can also apply view modifiers like bold() or italic() to further adjust the formatting.\n\nText(\"by William Shakespeare\")\n    .font(.system(size: 12, weight: .light, design: .serif))\n    .italic()\n\n\nTo apply styling within specific portions of the text, you can create the text view from an AttributedString, which in turn allows you to use Markdown to style runs of text. You can mix string attributes and SwiftUI modifiers, with the string attributes taking priority.\n\nlet attributedString = try! AttributedString(\n    markdown: \"_Hamlet_ by William Shakespeare\")\n\n\nvar body: some View {\n    Text(attributedString)\n        .font(.system(size: 12, weight: .light, design: .serif))\n}\n\n\nA text view always uses exactly the amount of space it needs to display its rendered contents, but you can affect the view\u2019s layout. For example, you can use the frame(width:height:alignment:) modifier to propose specific dimensions to the view. If the view accepts the proposal but the text doesn\u2019t fit into the available space, the view uses a combination of wrapping, tightening, scaling, and truncation to make it fit. With a width of 100 points but no constraint on the height, a text view might wrap a long string:\n\nText(\"To be, or not to be, that is the question:\")\n    .frame(width: 100)\n\n\nUse modifiers like lineLimit(_:), allowsTightening(_:), minimumScaleFactor(_:), and truncationMode(_:) to configure how the view handles space constraints. For example, combining a fixed width and a line limit of 1 results in truncation for text that doesn\u2019t fit in that space:\n\nText(\"Brevity is the soul of wit.\")\n    .frame(width: 100)\n    .lineLimit(1)\n\n\nLocalizing strings\n\nIf you initialize a text view with a string literal, the view uses the init(_:tableName:bundle:comment:) initializer, which interprets the string as a localization key and searches for the key in the table you specify, or in the default table if you don\u2019t specify one.\n\nText(\"pencil\") // Searches the default table in the main bundle.\n\n\nFor an app localized in both English and Spanish, the above view displays \u201cpencil\u201d and \u201cl\u00e1piz\u201d for English and Spanish users, respectively. If the view can\u2019t perform localization, it displays the key instead. For example, if the same app lacks Danish localization, the view displays \u201cpencil\u201d for users in that locale. Similarly, an app that lacks any localization information displays \u201cpencil\u201d in any locale.\n\nTo explicitly bypass localization for a string literal, use the init(verbatim:) initializer.\n\nText(verbatim: \"pencil\") // Displays the string \"pencil\" in any locale.\n\n\nIf you intialize a text view with a variable value, the view uses the init(_:) initializer, which doesn\u2019t localize the string. However, you can request localization by creating a LocalizedStringKey instance first, which triggers the init(_:tableName:bundle:comment:) initializer instead:\n\n// Don't localize a string variable...\nText(writingImplement)\n\n\n// ...unless you explicitly convert it to a localized string key.\nText(LocalizedStringKey(writingImplement))\n\n\nWhen localizing a string variable, you can use the default table by omitting the optional initialization parameters \u2014 as in the above example \u2014 just like you might for a string literal.\n\nTopics\nCreating a text view from a string\ninit(LocalizedStringKey, tableName: String?, bundle: Bundle?, comment: StaticString?)\nCreates a text view that displays localized content identified by a key.\ninit(LocalizedStringResource)\nCreates a text view that displays a localized string resource.\ninit<S>(S)\nCreates a text view that displays a stored string without localization.\ninit(verbatim: String)\nCreates a text view that displays a string literal without localization.\nCreating a text view from an attributed string\ninit(AttributedString)\nCreates a text view that displays styled attributed content.\nCreating a text view for a date\ninit(ClosedRange<Date>)\nCreates an instance that displays a localized range between two dates.\ninit(DateInterval)\nCreates an instance that displays a localized time interval.\ninit(Date, style: Text.DateStyle)\nCreates an instance that displays localized dates and times using a specific style.\nCreating a text view with formatting\ninit<F>(F.FormatInput, format: F)\nCreates a text view that displays the formatted representation of a nonstring type supported by a corresponding format style.\ninit<Subject>(Subject, formatter: Formatter)\nCreates a text view that displays the formatted representation of a reference-convertible value.\ninit<Subject>(Subject, formatter: Formatter)\nCreates a text view that displays the formatted representation of a Foundation object.\nCreating a text view from an image\ninit(Image)\nCreates an instance that wraps an Image, suitable for concatenating with other Text\nCreating a text view with a timer\ninit(timerInterval: ClosedRange<Date>, pauseTime: Date?, countsDown: Bool, showsHours: Bool)\nCreates an instance that displays a timer counting within the provided interval.\nChoosing a font\nfunc font(Font?) -> Text\nSets the default font for text in the view.\nfunc fontWeight(Font.Weight?) -> Text\nSets the font weight of the text.\nfunc fontDesign(Font.Design?) -> Text\nSets the font design of the text.\nfunc fontWidth(Font.Width?) -> Text\nSets the font width of the text.\nStyling the view\u2019s text\nfunc foregroundStyle<S>(S) -> Text\nSets the style of the text displayed by this view.\nfunc bold() -> Text\nApplies a bold font weight to the text.\nfunc bold(Bool) -> Text\nApplies a bold font weight to the text.\nfunc italic() -> Text\nApplies italics to the text.\nfunc italic(Bool) -> Text\nApplies italics to the text.\nfunc strikethrough(Bool, color: Color?) -> Text\nApplies a strikethrough to the text.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> Text\nApplies a strikethrough to the text.\nfunc underline(Bool, color: Color?) -> Text\nApplies an underline to the text.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> Text\nApplies an underline to the text.\nfunc monospaced(Bool) -> Text\nModifies the font of the text to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> Text\nModifies the text view\u2019s font to use fixed-width digits, while leaving other characters proportionally spaced.\nfunc kerning(CGFloat) -> Text\nSets the spacing, or kerning, between characters.\nfunc tracking(CGFloat) -> Text\nSets the tracking for the text.\nfunc baselineOffset(CGFloat) -> Text\nSets the vertical offset for the text relative to its baseline.\nenum Case\nA scheme for transforming the capitalization of characters within text.\nstruct DateStyle\nA predefined style used to display a Date.\nstruct LineStyle\nDescription of the style used to draw the line for StrikethroughStyleAttribute and UnderlineStyleAttribute.\nFitting text into available space\nfunc textScale(Text.Scale, isEnabled: Bool) -> Text\nApplies a text scale to the text.\nstruct Scale\nDefines text scales\nenum TruncationMode\nThe type of truncation to apply to a line of text when it\u2019s too long to fit in the available space.\nLocalizing text\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> Text\nSpecifies the language for typesetting.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> Text\nSpecifies the language for typesetting.\nConfiguring voiceover\nfunc speechAdjustedPitch(Double) -> Text\nRaises or lowers the pitch of spoken text.\nfunc speechAlwaysIncludesPunctuation(Bool) -> Text\nSets whether VoiceOver should always speak all punctuation in the text view.\nfunc speechAnnouncementsQueued(Bool) -> Text\nControls whether to queue pending announcements behind existing speech rather than interrupting speech in progress.\nfunc speechSpellsOutCharacters(Bool) -> Text\nSets whether VoiceOver should speak the contents of the text view character by character.\nProviding accessibility information\nfunc accessibilityHeading(AccessibilityHeadingLevel) -> Text\nSets the accessibility level of this heading.\nfunc accessibilityLabel<S>(S) -> Text\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> Text\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> Text\nAdds a label to the view that describes its contents.\nfunc accessibilityTextContentType(AccessibilityTextContentType) -> Text\nSets an accessibility text content type.\nCombining text views\nstatic func + (Text, Text) -> Text\nConcatenates the text in two text views in a new text view.\nDeprecated symbols\nfunc foregroundColor(Color?) -> Text\nSets the color of the text displayed by this view.\nDeprecated\nRelationships\nConforms To\nEquatable\nSendable\nView\nSee Also\nDisplaying text\nstruct Label\nA standard label for user interface items, consisting of an icon with a title.\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view."
    },
    {
        "title": "strokeBorder(_:style:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview/strokeborder(_:style:antialiased:)",
        "html": "Discussion\n\nThis method strokes the resulting shape with style and fills it with content.\n\nSee Also\nModify the shape\nfunc fill<S>(S, style: FillStyle) -> FillShapeView<Self.Content, S, Self>\nFills this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc strokeBorder<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of filling an inner stroke of this view with the content you supply.\nAvailable when Content conforms to InsettableShape."
    },
    {
        "title": "font",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/font",
        "html": "See Also\nSetting a font\nApplying custom fonts to text\nAdd and use a font in your app that scales with Dynamic Type.\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nstruct Font\nAn environment-dependent font."
    },
    {
        "title": "fontWeight(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fontweight(_:)",
        "html": "Parameters\nweight\n\nOne of the available font weights. Providing nil removes the effect of any font weight modifier applied higher in the view hierarchy.\n\nReturn Value\n\nA view that uses the font weight you specify.\n\nSee Also\nSetting a font\nApplying custom fonts to text\nAdd and use a font in your app that scales with Dynamic Type.\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nvar font: Font?\nThe default font of this environment.\nstruct Font\nAn environment-dependent font."
    },
    {
        "title": "ScaledMetric",
        "url": "https://developer.apple.com/documentation/swiftui/scaledmetric",
        "html": "Topics\nCreating the metric\ninit(wrappedValue: Value)\nCreates the scaled metric with an unscaled value using the default scaling.\ninit(wrappedValue: Value, relativeTo: Font.TextStyle)\nCreates the scaled metric with an unscaled value and a text style to scale relative to.\nGetting the metric\nvar wrappedValue: Value\nThe value scaled based on the current environment.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nAdjusting text size\nfunc textScale(Text.Scale, isEnabled: Bool) -> some View\nApplies a text scale to text in the view.\nfunc dynamicTypeSize<T>(T) -> some View\nLimits the Dynamic Type size within the view to the given range.\nfunc dynamicTypeSize(DynamicTypeSize) -> some View\nSets the Dynamic Type size within the view to the given value.\nvar dynamicTypeSize: DynamicTypeSize\nThe current Dynamic Type size.\nenum DynamicTypeSize\nA Dynamic Type size, which specifies how large scalable content should be."
    },
    {
        "title": "ShapeRole.separator",
        "url": "https://developer.apple.com/documentation/swiftui/shaperole/separator",
        "html": "See Also\nGetting shape roles\ncase fill\nIndicates to the shape\u2019s style that SwiftUI fills the shape.\ncase stroke\nIndicates to the shape\u2019s style that SwiftUI applies a stroke to the shape\u2019s path."
    },
    {
        "title": "dynamicTypeSize",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/dynamictypesize",
        "html": "Discussion\n\nThis value changes as the user\u2019s chosen Dynamic Type size changes. The default value is device-dependent.\n\nWhen limiting the Dynamic Type size, consider if adding a large content view with accessibilityShowsLargeContentViewer() would be appropriate.\n\nOn macOS, this value cannot be changed by users and does not affect the text size.\n\nSee Also\nAdjusting text size\nfunc textScale(Text.Scale, isEnabled: Bool) -> some View\nApplies a text scale to text in the view.\nfunc dynamicTypeSize<T>(T) -> some View\nLimits the Dynamic Type size within the view to the given range.\nfunc dynamicTypeSize(DynamicTypeSize) -> some View\nSets the Dynamic Type size within the view to the given value.\nenum DynamicTypeSize\nA Dynamic Type size, which specifies how large scalable content should be.\nstruct ScaledMetric\nA dynamic property that scales a numeric value."
    },
    {
        "title": "TransactionKey",
        "url": "https://developer.apple.com/documentation/swiftui/transactionkey",
        "html": "Overview\n\nYou can create custom transaction values by extending the Transaction structure with new properties. First declare a new transaction key type and specify a value for the required defaultValue property:\n\nprivate struct MyTransactionKey: TransactionKey {\n    static let defaultValue = false\n}\n\n\nThe Swift compiler automatically infers the associated Value type as the type you specify for the default value. Then use the key to define a new transaction value property:\n\nextension Transaction {\n    var myCustomValue: Bool {\n        get { self[MyTransactionKey.self] }\n        set { self[MyTransactionKey.self] = newValue }\n    }\n}\n\n\nClients of your transaction value never use the key directly. Instead, they use the key path of your custom transaction value property. To set the transaction value for a change, wrap that change in a call to withTransaction:\n\nwithTransaction(\\.myCustomValue, true) {\n    isActive.toggle()\n}\n\n\nTo set it for a view and all its subviews, add the transaction(value:_:) view modifier to that view:\n\nMyView()\n    .transaction(\\.myCustomValue, true)\n\n\nTo use the value from inside MyView or one of its descendants, use the transaction(_:) view modifier:\n\nMyView()\n    .transaction { transaction in\n        if transaction.myCustomValue {\n            transaction.animation = .default.repeatCount(3)\n        }\n    }\n\nTopics\nSetting a default value\nstatic var defaultValue: Self.Value\nThe default value for the transaction key.\n\nRequired\n\nassociatedtype Value\nThe associated type representing the type of the transaction key\u2019s value.\n\nRequired\n\nSee Also\nMoving an animation to another view\nfunc withTransaction<Result>(Transaction, () throws -> Result) rethrows -> Result\nExecutes a closure with the specified transaction and returns the result.\nfunc withTransaction<R, V>(WritableKeyPath<Transaction, V>, V, () throws -> R) rethrows -> R\nExecutes a closure with the specified transaction key path and value and returns the result.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nstruct Transaction\nThe context of the current state-processing update."
    },
    {
        "title": "fontWidth(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fontwidth(_:)",
        "html": "Parameters\nwidth\n\nOne of the available font widths. Providing nil removes the effect of any font width modifier applied higher in the view hierarchy.\n\nReturn Value\n\nA view that uses the font width you specify.\n\nSee Also\nSetting a font\nApplying custom fonts to text\nAdd and use a font in your app that scales with Dynamic Type.\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nvar font: Font?\nThe default font of this environment.\nstruct Font\nAn environment-dependent font."
    },
    {
        "title": "shape",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview/shape",
        "html": "Required\n\nSee Also\nGetting the shape\nassociatedtype Content : Shape\nThe type of shape this can provide.\n\nRequired"
    },
    {
        "title": "stroke(_:style:antialiased:)",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview/stroke(_:style:antialiased:)",
        "html": "Parameters\ncontent\n\nThe color or gradient with which to stroke this shape.\n\nstyle\n\nThe stroke characteristics \u2014 such as the line\u2019s width and whether the stroke is dashed \u2014 that determine how to render this shape.\n\nReturn Value\n\nA stroked shape.\n\nDiscussion\n\nThe following example adds a dashed purple stroke to a Capsule:\n\nCapsule()\n.stroke(\n    Color.purple,\n    style: StrokeStyle(\n        lineWidth: 5,\n        lineCap: .round,\n        lineJoin: .miter,\n        miterLimit: 0,\n        dash: [5, 10],\n        dashPhase: 0\n    )\n)\n\nSee Also\nModify the shape\nfunc fill<S>(S, style: FillStyle) -> FillShapeView<Self.Content, S, Self>\nFills this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc strokeBorder<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of insetting this view by half of its style\u2019s line width.\nAvailable when Content conforms to InsettableShape.\nfunc strokeBorder<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of filling an inner stroke of this view with the content you supply.\nAvailable when Content conforms to InsettableShape."
    },
    {
        "title": "ShapeRole.fill",
        "url": "https://developer.apple.com/documentation/swiftui/shaperole/fill",
        "html": "See Also\nGetting shape roles\ncase stroke\nIndicates to the shape\u2019s style that SwiftUI applies a stroke to the shape\u2019s path.\ncase separator\nIndicates to the shape\u2019s style that SwiftUI uses the shape as a separator."
    },
    {
        "title": "textScale(_:isEnabled:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textscale(_:isenabled:)",
        "html": "Parameters\nscale\n\nThe text scale to apply.\n\nisEnabled\n\nIf true the text scale is applied; otherwise text scale is unchanged.\n\nReturn Value\n\nA view with the specified text scale applied.\n\nSee Also\nAdjusting text size\nfunc dynamicTypeSize<T>(T) -> some View\nLimits the Dynamic Type size within the view to the given range.\nfunc dynamicTypeSize(DynamicTypeSize) -> some View\nSets the Dynamic Type size within the view to the given value.\nvar dynamicTypeSize: DynamicTypeSize\nThe current Dynamic Type size.\nenum DynamicTypeSize\nA Dynamic Type size, which specifies how large scalable content should be.\nstruct ScaledMetric\nA dynamic property that scales a numeric value."
    },
    {
        "title": "animation(_:value:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/animation(_:value:)",
        "html": "Parameters\nanimation\n\nThe animation to apply. If animation is nil, the view doesn\u2019t animate.\n\nvalue\n\nA value to monitor for changes.\n\nReturn Value\n\nA view that applies animation to this view whenever value changes.\n\nSee Also\nAdding state-based animation to a view\nfunc animation(Animation?) -> some View\nApplies the given animation to this view when this view changes.\nAvailable when Self conforms to Equatable.\nfunc animation<V>(Animation?, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given animation to all animatable values within the body closure."
    },
    {
        "title": "body",
        "url": "https://developer.apple.com/documentation/swiftui/app/body-swift.property",
        "html": "Required\n\nDiscussion\n\nFor any app that you create, provide a computed body property that defines your app\u2019s scenes, which are instances that conform to the Scene protocol. For example, you can create a simple app with a single scene containing a single view:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            Text(\"Hello, world!\")\n        }\n    }\n}\n\n\nSwift infers the app\u2019s Body associated type based on the scene provided by the body property.\n\nSee Also\nImplementing an app\nassociatedtype Body : Scene\nThe type of scene representing the content of the app.\n\nRequired"
    },
    {
        "title": "main()",
        "url": "https://developer.apple.com/documentation/swiftui/app/main()",
        "html": "Discussion\n\nIf you precede your App conformer\u2019s declaration with the @main attribute, the system calls the conformer\u2019s main() method to launch the app. SwiftUI provides a default implementation of the method that manages the launch process in a platform-appropriate way.\n\nSee Also\nRunning an app\ninit()\nCreates an instance of the app using the body that you define for its content.\n\nRequired"
    },
    {
        "title": "Body",
        "url": "https://developer.apple.com/documentation/swiftui/app/body-swift.associatedtype",
        "html": "Required\n\nDiscussion\n\nWhen you create a custom app, Swift infers this type from your implementation of the required body property.\n\nSee Also\nImplementing an app\nvar body: Self.Body\nThe content and behavior of the app.\n\nRequired"
    },
    {
        "title": "menuStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/menustyle(_:)",
        "html": "Discussion\n\nTo set a specific style for all menu instances within a view, use the menuStyle(_:) modifier:\n\nMenu(\"PDF\") {\n    Button(\"Open in Preview\", action: openInPreview)\n    Button(\"Save as PDF\", action: saveAsPDF)\n}\n.menuStyle(ButtonMenuStyle())\n\nSee Also\nCreating a menu\nstruct Menu\nA control for presenting a menu of actions."
    },
    {
        "title": "Content",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview/content",
        "html": "Required\n\nSee Also\nGetting the shape\nvar shape: Self.Content\nThe shape that this type draws and provides for other drawing operations.\n\nRequired"
    },
    {
        "title": "DatePickerStyle",
        "url": "https://developer.apple.com/documentation/swiftui/datepickerstyle",
        "html": "Overview\n\nTo configure the current date picker style for a view hierarchy, use the datePickerStyle(_:) modifier.\n\nTopics\nGetting built-in date picker styles\nstatic var automatic: DefaultDatePickerStyle\nThe default style for date pickers.\nAvailable when Self is DefaultDatePickerStyle.\nstatic var compact: CompactDatePickerStyle\nA date picker style that displays the components in a compact, textual format.\nAvailable when Self is CompactDatePickerStyle.\nstatic var field: FieldDatePickerStyle\nA date picker style that displays the components in an editable field.\nAvailable when Self is FieldDatePickerStyle.\nstatic var graphical: GraphicalDatePickerStyle\nA date picker style that displays an interactive calendar or clock.\nAvailable when Self is GraphicalDatePickerStyle.\nstatic var stepperField: StepperFieldDatePickerStyle\nA system style that displays the components in an editable field, with adjoining stepper that can increment/decrement the selected component.\nAvailable when Self is StepperFieldDatePickerStyle.\nstatic var wheel: WheelDatePickerStyle\nA date picker style that displays each component as columns in a scrollable wheel.\nAvailable when Self is WheelDatePickerStyle.\nCreating custom date picker styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nReturns the appearance and interaction content for a DatePicker.\n\nRequired\n\nstruct DatePickerStyleConfiguration\nThe properties of a DatePicker.\ntypealias Configuration\nA type alias for the properties of a DatePicker.\nassociatedtype Body : View\nA view representing the appearance and interaction of a DatePicker.\n\nRequired\n\nSuporting types\nstruct DefaultDatePickerStyle\nThe default style for date pickers.\nstruct CompactDatePickerStyle\nA date picker style that displays the components in a compact, textual format.\nstruct FieldDatePickerStyle\nA date picker style that displays the components in an editable field.\nstruct GraphicalDatePickerStyle\nA date picker style that displays an interactive calendar or clock.\nstruct StepperFieldDatePickerStyle\nA system style that displays the components in an editable field, with adjoining stepper that can increment/decrement the selected component.\nstruct WheelDatePickerStyle\nA date picker style that displays each component as columns in a scrollable wheel.\nRelationships\nConforming Types\nCompactDatePickerStyle\nDefaultDatePickerStyle\nFieldDatePickerStyle\nGraphicalDatePickerStyle\nStepperFieldDatePickerStyle\nWheelDatePickerStyle\nSee Also\nStyling pickers\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nprotocol PickerStyle\nA type that specifies the appearance and interaction of all pickers within a view hierarchy.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view."
    },
    {
        "title": "keyframeAnimator(initialValue:trigger:content:keyframes:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/keyframeanimator(initialvalue:trigger:content:keyframes:)",
        "html": "Parameters\ninitialValue\n\nThe initial value that the keyframes will animate from.\n\ntrigger\n\nA value to observe for changes.\n\ncontent\n\nA view builder closure that takes two parameters. The first parameter is a proxy value representing the modified view. The second parameter is the interpolated value generated by the keyframes.\n\nkeyframes\n\nKeyframes defining how the value changes over time. The current value of the animator is the single argument, which is equal to initialValue when the view first appears, then is equal to the end value of the previous keyframe animation on subsequent calls.\n\nDiscussion\n\nNote that the content closure will be updated on every frame while animating, so avoid performing any expensive operations directly within content.\n\nIf the trigger value changes while animating, the keyframes closure will be called with the current interpolated value, and the keyframes that you return define a new animation that replaces the old one. The previous velocity will be preserved, so cubic or spring keyframes will maintain continuity from the previous animation if they do not specify a custom initial velocity.\n\nWhen a keyframe animation finishes, the animator will remain at the end value, which becomes the initial value for the next animation.\n\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "phaseAnimator(_:content:animation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/phaseanimator(_:content:animation:)",
        "html": "Parameters\nphases\n\nThe sequence of phases to cycle through. Ensure that the sequence isn\u2019t empty. If it is, SwiftUI logs a runtime warning and also returns a visual warning as the output view.\n\ncontent\n\nA view builder closure that takes two parameters: a proxy value representing the modified view and the current phase. You can apply effects to the proxy based on the current phase.\n\nanimation\n\nA closure that takes the current phase as input. Return the animation to use when transitioning to the next phase. If you return nil, the transition doesn\u2019t animate. If you don\u2019t set this parameter, SwiftUI uses a default animation.\n\nDiscussion\n\nWhen the modified view first appears, this modifier renders its content closure using the first phase as input to the closure, along with a proxy for the modified view. Apply effects to the proxy \u2014 and thus to the modified view \u2014 in a way that\u2019s appropriate for the first phase value.\n\nRight away, the modifier provides its content closure with the value of the second phase. Update the effects that you apply to the proxy view accordingly, and the modifier animates the change for you. As soon as the animation completes, the procedure repeats using successive phases until reaching the last phase, at which point the modifier loops back to the first phase.\n\nSee Also\nCreating phase-based animation\nControlling the timing and movements of your animations\nBuild sophisticated animations that you control using phase and keyframe animators.\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change based on a trigger.\nstruct PhaseAnimator\nA container that animates its content by automatically cycling through a collection of phases that you provide, each defining a discrete step within an animation."
    },
    {
        "title": "keyframeAnimator(initialValue:repeating:content:keyframes:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/keyframeanimator(initialvalue:repeating:content:keyframes:)",
        "html": "Parameters\ninitialValue\n\nThe initial value that the keyframes will animate from.\n\nrepeating\n\nWhether the keyframes are currently repeating. If false, the value at the beginning of the keyframe timeline will be provided to the content closure.\n\ncontent\n\nA view builder closure that takes two parameters. The first parameter is a proxy value representing the modified view. The second parameter is the interpolated value generated by the keyframes.\n\nkeyframes\n\nKeyframes defining how the value changes over time. The current value of the animator is the single argument, which is equal to initialValue when the view first appears, then is equal to the end value of the previous keyframe animation on subsequent calls.\n\nDiscussion\n\nNote that the content closure will be updated on every frame while animating, so avoid performing any expensive operations directly within content.\n\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "KeyframesBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/keyframesbuilder",
        "html": "Topics\nBuilding keyframes\nstatic func buildArray([some KeyframeTrackContent<Value>]) -> some KeyframeTrackContent<Value>\nstatic func buildBlock() -> some Keyframes<Value>\nstatic func buildBlock() -> some KeyframeTrackContent<Value>\nstatic func buildEither<First, Second>(first: First) -> KeyframeTrackContentBuilder<Value>.Conditional<Value, First, Second>\nstatic func buildEither<First, Second>(second: Second) -> KeyframeTrackContentBuilder<Value>.Conditional<Value, First, Second>\nstatic func buildExpression<K>(K) -> K\nstatic func buildExpression<Content>(Content) -> Content\nKeyframes\nstatic func buildFinalResult<Content>(Content) -> KeyframeTrack<Value, Value, Content>\nstatic func buildFinalResult<Content>(Content) -> Content\nstatic func buildPartialBlock(accumulated: some KeyframeTrackContent<Value>, next: some KeyframeTrackContent<Value>) -> some KeyframeTrackContent<Value>\nstatic func buildPartialBlock(accumulated: some Keyframes<Value>, next: some Keyframes<Value>) -> some Keyframes<Value>\nstatic func buildPartialBlock<Content>(first: Content) -> Content\nstatic func buildPartialBlock<K>(first: K) -> K\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "KeyframeAnimator",
        "url": "https://developer.apple.com/documentation/swiftui/keyframeanimator",
        "html": "Overview\n\nThe content closure updates every frame while animating, so avoid performing any expensive operations directly within content.\n\nTopics\nCreating a phase animator\ninit(initialValue: Value, repeating: Bool, content: (Value) -> Content, keyframes: (Value) -> KeyframePath)\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\ninit(initialValue: Value, trigger: some Equatable, content: (Value) -> Content, keyframes: (Value) -> KeyframePath)\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nRelationships\nConforms To\nView\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "phaseAnimator(_:trigger:content:animation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/phaseanimator(_:trigger:content:animation:)",
        "html": "Parameters\nphases\n\nThe sequence of phases to cycle through. Ensure that the sequence isn\u2019t empty. If it is, SwiftUI logs a runtime warning and also returns a visual warning as the output view.\n\ntrigger\n\nA value whose changes cause the animator to use the next phase.\n\ncontent\n\nA view builder closure that takes two parameters: a proxy value representing the modified view and the current phase. You can apply effects to the proxy based on the current phase.\n\nanimation\n\nA closure that takes the current phase as input. Return the animation to use when transitioning to the next phase. If you return nil, the transition doesn\u2019t animate. If you don\u2019t set this parameter, SwiftUI uses a default animation.\n\nDiscussion\n\nWhen the modified view first appears, this modifier renders its content closure using the first phase as input to the closure, along with a proxy for the modified view. Apply effects to the proxy \u2014 and thus to the modified view \u2014 in a way that\u2019s appropriate for the first phase value.\n\nLater, when the value of the trigger input changes, the modifier provides its content closure with the value of the second phase. Update the effects that you apply to the proxy view accordingly, and the modifier animates the change for you. The next time the trigger input changes, this procedure repeats using successive phases until reaching the last phase, at which point the modifier loops back to the first phase.\n\nSee Also\nCreating phase-based animation\nControlling the timing and movements of your animations\nBuild sophisticated animations that you control using phase and keyframe animators.\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change continuously.\nstruct PhaseAnimator\nA container that animates its content by automatically cycling through a collection of phases that you provide, each defining a discrete step within an animation."
    },
    {
        "title": "symbolEffect(_:options:value:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/symboleffect(_:options:value:)",
        "html": "Parameters\neffect\n\nA symbol effect to add to the view. Existing effects added by ancestors of the view are preserved, but may be overridden by the new effect. Added effects will be applied to the ``SwiftUI/Image` views contained by the child view.\n\nvalue\n\nthe value to monitor for changes, the animation is triggered each time the value changes.\n\nReturn Value\n\na copy of the view with a symbol effect added.\n\nDiscussion\n\nThe following example adds a bounce effect to two symbol images, the animation will play each time counter changes:\n\nVStack {\n    Image(systemName: \"bolt.slash.fill\")\n    Image(systemName: \"folder.fill.badge.person.crop\")\n}\n.symbolEffect(.bounce, value: counter)\n\nSee Also\nManaging symbol effects\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffectsRemoved(Bool) -> some View\nReturns a new view with its inherited symbol image effects either removed or left unchanged.\nstruct SymbolEffectTransition\nCreates a transition that applies the Appear or Disappear symbol animation to symbol images within the inserted or removed view hierarchy."
    },
    {
        "title": "KeyframeTimeline",
        "url": "https://developer.apple.com/documentation/swiftui/keyframetimeline",
        "html": "Overview\n\nUnlike other animations in SwiftUI (using Animation), keyframes don\u2019t interpolate between from and to values that SwiftUI provides as state changes. Instead, keyframes fully define the path that a value takes over time using the tracks that make up their body.\n\nKeyframes values are roughly analogous to video clips; they have a set duration, and you can scrub and evaluate them for any time within the duration.\n\nThe Keyframes structure also allows you to compute an interpolated value at a specific time, which you can use when integrating keyframes into custom use cases.\n\nFor example, you can use a Keyframes instance to define animations for a type conforming to Animatable:\n\nlet keyframes = KeyframeTimeline(initialValue: CGPoint.zero) {\n    CubcKeyframe(.init(x: 0, y: 100), duration: 0.3)\n    CubicKeyframe(.init(x: 0, y: 0), duration: 0.7)\n}\n\n\nlet value = keyframes.value(time: 0.45\n\n\nFor animations that involve multiple coordinated changes, you can include multiple nested tracks:\n\nstruct Values {\n    var rotation = Angle.zero\n    var scale = 1.0\n}\n\n\nlet keyframes = KeyframeTimeline(initialValue: Values()) {\n    KeyframeTrack(\\.rotation) {\n        CubicKeyframe(.zero, duration: 0.2)\n        CubicKeyframe(.degrees(45), duration: 0.3)\n    }\n    KeyframeTrack(\\.scale) {\n        CubicKeyframe(value: 1.2, duration: 0.5)\n        CubicKeyframe(value: 0.9, duration: 0.2)\n        CubicKeyframe(value: 1.0, duration: 0.3)\n    }\n}\n\n\nMultiple nested tracks update the initial value in the order that they are declared. This means that if multiple nested plans change the same property of the root value, the value from the last competing track will be used.\n\nTopics\nCreating a keyframe timeline\ninit(initialValue: Value, content: () -> some Keyframes<Value>)\nCreates a new instance using the initial value and content that you provide.\nGetting the duration\nvar duration: TimeInterval\nThe duration of the content in seconds.\nGetting an interpolated value\nfunc value(time: Double) -> Value\nReturns the interpolated value at the given time.\nfunc value(progress: Double) -> Value\nReturns the interpolated value at the given progress in the range zero to one.\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "KeyframeTrack",
        "url": "https://developer.apple.com/documentation/swiftui/keyframetrack",
        "html": "Topics\nCreating a keyframe track\ninit(content: () -> Content)\nCreates an instance that animates the entire value from the root of the key path.\ninit(WritableKeyPath<Root, Value>, content: () -> Content)\nCreates an instance that animates the property of the root value at the given key path.\nRelationships\nConforms To\nKeyframes\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "Keyframes",
        "url": "https://developer.apple.com/documentation/swiftui/keyframes",
        "html": "Topics\nCreating a keyframe\nvar body: Self.Body\nThe composition of content that comprise the keyframes.\n\nRequired\n\nassociatedtype Body : Keyframes\nThe type of keyframes representing the body of this type.\n\nRequired\n\nassociatedtype Value = Self.Body.Value\nThe type of value animated by this keyframes type\n\nRequired\n\nRelationships\nConforming Types\nKeyframeTrack\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "CubicKeyframe",
        "url": "https://developer.apple.com/documentation/swiftui/cubickeyframe",
        "html": "Overview\n\nIf you don\u2019t specify a start or end velocity, SwiftUI automatically computes a curve that maintains smooth motion between keyframes.\n\nAdjacent cubic keyframes result in a Catmull-Rom spline.\n\nIf a cubic keyframe follows a different type of keyframe, such as a linear keyframe, the end velocity of the segment defined by the previous keyframe will be used as the starting velocity.\n\nLikewise, if a cubic keyframe is followed by a different type of keyframe, the initial velocity of the next segment is used as the end velocity of the segment defined by this keyframe.\n\nTopics\nCreating the keyframe\ninit(Value, duration: TimeInterval, startVelocity: Value?, endVelocity: Value?)\nCreates a new keyframe using the given value and timestamp.\nRelationships\nConforms To\nKeyframeTrackContent\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "PhaseAnimator",
        "url": "https://developer.apple.com/documentation/swiftui/phaseanimator",
        "html": "Overview\n\nUse one of the phase animator view modifiers like phaseAnimator(_:content:animation:) to create a phased animation in your app.\n\nTopics\nCreating a phase animator\ninit(some Sequence<Phase>, content: (Phase) -> Content, animation: (Phase) -> Animation?)\nCycles through a sequence of phases continuously, animating updates to a view on each phase change.\ninit(some Sequence<Phase>, trigger: some Equatable, content: (Phase) -> Content, animation: (Phase) -> Animation?)\nCycles through a sequence of phases in response to changes in a specified value, animating updates to a view on each phase change.\nRelationships\nConforms To\nView\nSee Also\nCreating phase-based animation\nControlling the timing and movements of your animations\nBuild sophisticated animations that you control using phase and keyframe animators.\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change continuously.\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change based on a trigger."
    },
    {
        "title": "LinearKeyframe",
        "url": "https://developer.apple.com/documentation/swiftui/linearkeyframe",
        "html": "Topics\nCreating the keyframe\ninit(Value, duration: TimeInterval, timingCurve: UnitCurve)\nCreates a new keyframe using the given value and timestamp.\nRelationships\nConforms To\nKeyframeTrackContent\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "SpringKeyframe",
        "url": "https://developer.apple.com/documentation/swiftui/springkeyframe",
        "html": "Topics\nCreating the keyframe\ninit(Value, duration: TimeInterval?, spring: Spring, startVelocity: Value?)\nCreates a new keyframe using the given value and timestamp.\nRelationships\nConforms To\nKeyframeTrackContent\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating."
    },
    {
        "title": "Image",
        "url": "https://developer.apple.com/documentation/swiftui/image",
        "html": "Overview\n\nUse an Image instance when you want to add images to your SwiftUI app. You can create images from many sources:\n\nImage files in your app\u2019s asset library or bundle. Supported types include PNG, JPEG, HEIC, and more.\n\nInstances of platform-specific image types, like UIImage and NSImage.\n\nA bitmap stored in a Core Graphics CGImage instance.\n\nSystem graphics from the SF Symbols set.\n\nThe following example shows how to load an image from the app\u2019s asset library or bundle and scale it to fit within its container:\n\nImage(\"Landscape_4\")\n    .resizable()\n    .aspectRatio(contentMode: .fit)\nText(\"Water wheel\")\n\n\nYou can use methods on the Image type as well as standard view modifiers to adjust the size of the image to fit your app\u2019s interface. Here, the Image type\u2019s resizable(capInsets:resizingMode:) method scales the image to fit the current view. Then, the aspectRatio(_:contentMode:) view modifier adjusts this resizing behavior to maintain the image\u2019s original aspect ratio, rather than scaling the x- and y-axes independently to fill all four sides of the view. The article Fitting images into available space shows how to apply scaling, clipping, and tiling to Image instances of different sizes.\n\nAn Image is a late-binding token; the system resolves its actual value only when it\u2019s about to use the image in an environment.\n\nMaking images accessible\n\nTo use an image as a control, use one of the initializers that takes a label parameter. This allows the system\u2019s accessibility frameworks to use the label as the name of the control for users who use features like VoiceOver. For images that are only present for aesthetic reasons, use an initializer with the decorative parameter; the accessibility systems ignore these images.\n\nTopics\nCreating an image\ninit(String, bundle: Bundle?)\nCreates a labeled image that you can use as content for controls.\ninit(String, variableValue: Double?, bundle: Bundle?)\nCreates a labeled image that you can use as content for controls, with a variable value.\ninit(ImageResource)\nInitialize an Image with an image resource.\nCreating an image for use as a control\ninit(String, bundle: Bundle?, label: Text)\nCreates a labeled image that you can use as content for controls, with the specified label.\ninit(String, variableValue: Double?, bundle: Bundle?, label: Text)\nCreates a labeled image that you can use as content for controls, with the specified label and variable value.\ninit(CGImage, scale: CGFloat, orientation: Image.Orientation, label: Text)\nCreates a labeled image based on a Core Graphics image instance, usable as content for controls.\nCreating an image for decorative use\ninit(decorative: String, bundle: Bundle?)\nCreates an unlabeled, decorative image.\ninit(decorative: String, variableValue: Double?, bundle: Bundle?)\nCreates an unlabeled, decorative image, with a variable value.\ninit(decorative: CGImage, scale: CGFloat, orientation: Image.Orientation)\nCreates an unlabeled, decorative image based on a Core Graphics image instance.\nCreating a system symbol image\ninit(systemName: String)\nCreates a system symbol image.\ninit(systemName: String, variableValue: Double?)\nCreates a system symbol image with a variable value.\nCreating an image from another image\ninit(uiImage: UIImage)\nCreates a SwiftUI image from a UIKit image instance.\ninit(nsImage: NSImage)\nCreates a SwiftUI image from an AppKit image instance.\nCreating an image from drawing instructions\ninit(size: CGSize, label: Text?, opaque: Bool, colorMode: ColorRenderingMode, renderer: (inout GraphicsContext) -> Void)\nInitializes an image of the given size, with contents provided by a custom rendering closure.\nResizing images\nfunc resizable(capInsets: EdgeInsets, resizingMode: Image.ResizingMode) -> Image\nSets the mode by which SwiftUI resizes an image to fit its space.\nSpecifying rendering behavior\nfunc antialiased(Bool) -> Image\nSpecifies whether SwiftUI applies antialiasing when rendering the image.\nfunc symbolRenderingMode(SymbolRenderingMode?) -> Image\nSets the rendering mode for symbol images within this view.\nfunc renderingMode(Image.TemplateRenderingMode?) -> Image\nIndicates whether SwiftUI renders an image as-is, or by using a different mode.\nfunc interpolation(Image.Interpolation) -> Image\nSpecifies the current level of quality for rendering an image that requires interpolation.\nenum TemplateRenderingMode\nA type that indicates how SwiftUI renders images.\nenum Interpolation\nThe level of quality for rendering an image that requires interpolation, such as a scaled image.\nSpecifying dynamic range\nfunc allowedDynamicRange(Image.DynamicRange?) -> Image\nReturns a new image configured with the specified allowed dynamic range.\nvar allowedDynamicRange: Image.DynamicRange?\nThe allowed dynamic range for the view, or nil.\nstruct DynamicRange\nRelationships\nConforms To\nEquatable\nSendable\nTransferable\nView"
    },
    {
        "title": "SymbolEffectTransition",
        "url": "https://developer.apple.com/documentation/swiftui/symboleffecttransition",
        "html": "Overview\n\nOther views are unaffected by this transition.\n\nTopics\nCreating a transition\ninit<T>(effect: T, options: SymbolEffectOptions)\nRelationships\nConforms To\nTransition\nSee Also\nManaging symbol effects\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffectsRemoved(Bool) -> some View\nReturns a new view with its inherited symbol image effects either removed or left unchanged."
    },
    {
        "title": "symbolRenderingMode",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/symbolrenderingmode",
        "html": "See Also\nSetting symbol rendering modes\nfunc symbolRenderingMode(SymbolRenderingMode?) -> some View\nSets the rendering mode for symbol images within this view.\nstruct SymbolRenderingMode\nA symbol rendering mode."
    },
    {
        "title": "Fitting images into available space",
        "url": "https://developer.apple.com/documentation/swiftui/fitting-images-into-available-space",
        "html": "Overview\n\nImage sizes vary widely, from single-pixel PNG files to digital photography images with millions of pixels. Because device sizes also vary, apps commonly need to make runtime adjustments to image sizes so they fit within the visible user interface. SwiftUI provides modifiers to scale, clip, and transform images to fit your interface perfectly.\n\nScale a large image to fit its container using resizing\n\nConsider the image Landscape_4.jpg, a photograph with the dimensions 4032 x 3024, showing a water wheel, the surrounding building, and the sky above.\n\nThe following example loads the image directly into an Image view, and then places it in a 300 x 400 point frame, with a blue border:\n\n    Image(\"Landscape_4\")\n        .frame(width: 300, height: 400, alignment: .topLeading)\n        .border(.blue)\n\n\nAs seen in the following screenshot, the image data loads at full size into the view, so only the clouds from the upper left of the original image are visible. Because the image renders at full size, and the blue frame is smaller than the original image, the image displays beyond the area bounded by the frame.\n\nTo fix this, you need to apply two modifiers to the Image:\n\nresizable(capInsets:resizingMode:) tells the image view to adjust the image representation to match the size of the view. By default, this modifier scales the image by reducing the size of larger images and enlarges images smaller than the view. By itself, this modifier scales each axis of the image independently.\n\naspectRatio(_:contentMode:) corrects the behavior where the image scaling is different for each axis. This preserves the image\u2019s original aspect ratio, using one of two strategies defined by the ContentMode enumeration. ContentMode.fit scales the image to fit the view size along one axis, possibly leaving empty space along the other axis. ContentMode.fill scales the image to fill the entire view.\n\n  Image(\"Landscape_4\")\n      .resizable()\n      .aspectRatio(contentMode: .fit)\n      .frame(width: 300, height: 400, alignment: .topLeading)\n      .border(.blue)\n\n\nKeep image data inside the view\u2019s bounds using clipping\n\nIf you use ContentMode.fill when scaling an image, a portion of an image may extend beyond the view\u2019s bounds, unless the view matches the image\u2019s aspect ratio exactly. The following example illustrates this problem:\n\n    Image(\"Landscape_4\")\n        .resizable()\n        .aspectRatio(contentMode: .fill)\n        .frame(width: 300, height: 400, alignment: .topLeading)\n        .border(.blue)\n\n\nTo prevent this problem, add the clipped(antialiased:) modifier. This modifier simply cuts off excess image rendering at the bounding frame of the view. Optionally, you can add an antialiasing behavior to apply smoothing to the edges of the clipping rectangle; this parameter defaults to false. The following example shows the effect of adding clipping to the previous fill-mode example:\n\n    Image(\"Landscape_4\")\n        .resizable()\n        .aspectRatio(contentMode: .fill)\n        .frame(width: 300, height: 400, alignment: .topLeading)\n        .border(.blue)\n        .clipped()\n\n\nUse interpolation flags to adjust rendered image quality\n\nRendering an image at anything other than its original size requires interpolation: using the existing image data to approximate a representation at a different size. Different approaches to performing interpolation have different trade-offs between computational complexity and visual quality of the rendered image. You can use the interpolation(_:) modifier to provide a hint for SwiftUI rendering behavior.\n\nIt\u2019s easier to see the effect of interpolation when scaling a smaller image into a larger space, because the rendered image requires more image data than is available. Consider the following example, which renders a 34 x 34 image named dot_green into the same 300 x 400 container frame as before:\n\n    Image(\"dot_green\")\n        .resizable()\n        .interpolation(.none)\n        .aspectRatio(contentMode: .fit)\n        .frame(width: 300, height: 400, alignment: .topLeading)\n        .border(.blue)\n\n\nPassing the Image.Interpolation.none value to interpolation(_:) produces a highly pixelated image when rendered.\n\nIf you change the interpolation value to Image.Interpolation.medium, SwiftUI smoothes out the pixel data to produce an image that isn\u2019t as pixelated:\n\nTip\n\nYou can also specify interpolation behavior when scaling images down, to ensure the highest quality image possible, fastest rendering time, or a behavior in between.\n\nFill a space with a repeating image using tiling\n\nWhen you have an image that\u2019s much smaller than the space you want to render it into, another option to fill the space is tiling: repeating the same image over and over again. To tile an image, pass the Image.ResizingMode.tile parameter to the resizable(capInsets:resizingMode:) modifier:\n\n    Image(\"dot_green\")\n        .resizable(resizingMode: .tile)\n        .frame(width: 300, height: 400, alignment: .topLeading)\n        .border(.blue)\n\n\nTiling can be particuarly useful when using an image that, when placed end-to-end with copies of itself, creates a larger pattern with no visual discontinuities.\n\nSee Also\nConfiguring an image\nfunc imageScale(Image.Scale) -> some View\nScales images within the view according to one of the relative sizes available including small, medium, and large images sizes.\nvar imageScale: Image.Scale\nThe image scale for this environment.\nenum Scale\nA scale to apply to vector images relative to text.\nenum Orientation\nThe orientation of an image.\nenum ResizingMode\nThe modes that SwiftUI uses to resize an image to fit within its containing view."
    },
    {
        "title": "SymbolRenderingMode",
        "url": "https://developer.apple.com/documentation/swiftui/symbolrenderingmode",
        "html": "Topics\nGetting symbol rendering modes\nstatic let hierarchical: SymbolRenderingMode\nA mode that renders symbols as multiple layers, with different opacities applied to the foreground style.\nstatic let monochrome: SymbolRenderingMode\nA mode that renders symbols as a single layer filled with the foreground style.\nstatic let multicolor: SymbolRenderingMode\nA mode that renders symbols as multiple layers with their inherit styles.\nstatic let palette: SymbolRenderingMode\nA mode that renders symbols as multiple layers, with different styles applied to the layers.\nRelationships\nConforms To\nSendable\nSee Also\nSetting symbol rendering modes\nfunc symbolRenderingMode(SymbolRenderingMode?) -> some View\nSets the rendering mode for symbol images within this view.\nvar symbolRenderingMode: SymbolRenderingMode?\nThe current symbol rendering mode, or nil denoting that the mode is picked automatically using the current image and foreground style as parameters."
    },
    {
        "title": "transaction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transaction(_:)",
        "html": "Parameters\ntransform\n\nThe transformation to apply to transactions within this view.\n\nReturn Value\n\nA view that wraps this view and applies a transformation to all transactions used within the view.\n\nDiscussion\n\nUse this modifier to change or replace the animation used in a view. Consider three identical animations controlled by a button that executes all three animations simultaneously:\n\nThe first animation rotates the \u201cRotation\u201d Text view by 360 degrees.\n\nThe second uses the transaction(_:) modifier to change the animation by adding a delay to the start of the animation by two seconds and then increases the rotational speed of the \u201cRotation\\nModified\u201d Text view animation by a factor of 2.\n\nThe third animation uses the transaction(_:) modifier to replace the rotation animation affecting the \u201cAnimation\\nReplaced\u201d Text view with a spring animation.\n\nThe following code implements these animations:\n\nstruct TransactionExample: View {\n    @State private var flag = false\n\n\n    var body: some View {\n        VStack(spacing: 50) {\n            HStack(spacing: 30) {\n                Text(\"Rotation\")\n                    .rotationEffect(Angle(degrees:\n                                            self.flag ? 360 : 0))\n\n\n                Text(\"Rotation\\nModified\")\n                    .rotationEffect(Angle(degrees:\n                                            self.flag ? 360 : 0))\n                    .transaction { view in\n                        view.animation =\n                            view.animation?.delay(2.0).speed(2)\n                    }\n\n\n                Text(\"Animation\\nReplaced\")\n                    .rotationEffect(Angle(degrees:\n                                            self.flag ? 360 : 0))\n                    .transaction { view in\n                        view.animation = .interactiveSpring(\n                            response: 0.60,\n                            dampingFraction: 0.20,\n                            blendDuration: 0.25)\n                    }\n            }\n\n\n            Button(\"Animate\") {\n                withAnimation(.easeIn(duration: 2.0)) {\n                    self.flag.toggle()\n                }\n            }\n        }\n    }\n}\n\n\nUse this modifier on leaf views such as Image or Button rather than container views such as VStack or HStack. The transformation applies to all child views within this view; calling transaction(_:) on a container view can lead to unbounded scope of execution depending on the depth of the view hierarchy.\n\nSee Also\nMoving an animation to another view\nfunc withTransaction<Result>(Transaction, () throws -> Result) rethrows -> Result\nExecutes a closure with the specified transaction and returns the result.\nfunc withTransaction<R, V>(WritableKeyPath<Transaction, V>, V, () throws -> R) rethrows -> R\nExecutes a closure with the specified transaction key path and value and returns the result.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nstruct Transaction\nThe context of the current state-processing update.\nprotocol TransactionKey\nA key for accessing values in a transaction."
    },
    {
        "title": "KeyframeTrackContent",
        "url": "https://developer.apple.com/documentation/swiftui/keyframetrackcontent",
        "html": "Topics\nCreating a keyframe\nvar body: Self.Body\nThe composition of content that comprise the keyframe track.\n\nRequired\n\nassociatedtype Body : KeyframeTrackContent\n\nRequired\n\nassociatedtype Value : Animatable = Self.Body.Value\n\nRequired\n\nRelationships\nConforming Types\nCubicKeyframe\nKeyframeTrackContentBuilder.Conditional\nConforms when Value conforms to Animatable.\nLinearKeyframe\nMoveKeyframe\nSpringKeyframe\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "isSceneCaptured",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/isscenecaptured",
        "html": "Discussion\n\nUse this value to determine whether the scene is actively being cloned to another destination (like during AirPlay) or is being mirrored or recorded.\n\nYour app can respond to changes in this value to take appropriate action, like obscuring content.\n\nSee Also\nRedacting private content\nfunc privacySensitive(Bool) -> some View\nMarks the view as containing sensitive, private user data.\nfunc redacted(reason: RedactionReasons) -> some View\nAdds a reason to apply a redaction to this view hierarchy.\nfunc unredacted() -> some View\nRemoves any reason to apply a redaction to this view hierarchy.\nvar redactionReasons: RedactionReasons\nThe current redaction reasons applied to the view hierarchy.\nstruct RedactionReasons\nThe reasons to apply a redaction to data displayed on screen."
    },
    {
        "title": "contentTransitionAddsDrawingGroup",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/contenttransitionaddsdrawinggroup",
        "html": "Discussion\n\nSetting this value to true causes SwiftUI to wrap content transitions with a drawingGroup(opaque:colorMode:) modifier.\n\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "contentTransition",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/contenttransition",
        "html": "See Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "contentTransition(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/contenttransition(_:)",
        "html": "Parameters\ntransition\n\nThe transition to apply when animating the content change.\n\nDiscussion\n\nThis modifier allows you to perform a transition that animates a change within a single view. The provided ContentTransition can present an opacity animation for content changes, an interpolated animation of the content\u2019s paths as they change, or perform no animation at all.\n\nTip\n\nThe contentTransition(_:) modifier only has an effect within the context of an Animation.\n\nIn the following example, a Button changes the color and font size of a Text view. Since both of these properties apply to the paths of the text, the interpolate transition can animate a gradual change to these properties through the entire transition. By contrast, the opacity transition would simply fade between the start and end states.\n\nprivate static let font1 = Font.system(size: 20)\nprivate static let font2 = Font.system(size: 45)\n\n\n@State private var color = Color.red\n@State private var currentFont = font1\n\n\nvar body: some View {\n    VStack {\n        Text(\"Content transition\")\n            .foregroundColor(color)\n            .font(currentFont)\n            .contentTransition(.interpolate)\n        Spacer()\n        Button(\"Change\") {\n            withAnimation(Animation.easeInOut(duration: 5.0)) {\n                color = (color == .red) ? .green : .red\n                currentFont = (currentFont == font1) ? font2 : font1\n            }\n        }\n    }\n}\n\n\nThis example uses an ease-in\u2013ease-out animation with a five-second duration to make it easier to see the effect of the interpolation. The figure below shows the Text at the beginning of the animation, halfway through, and at the end.\n\nTime\n\n\t\n\nDisplay\n\n\n\n\nStart\n\n\t\n\n\n\n\nMiddle\n\n\t\n\n\n\n\nEnd\n\n\t\n\nTo control whether content transitions use GPU-accelerated rendering, set the value of the contentTransitionAddsDrawingGroup environment variable.\n\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "TransitionPhase",
        "url": "https://developer.apple.com/documentation/swiftui/transitionphase",
        "html": "Overview\n\nWhen a view is appearing with a transition, the transition will first be shown with the willAppear phase, then will be immediately moved to the identity phase. When a view is being removed, its transition is changed from the identity phase to the didDisappear phase. If a view is removed while it is still transitioning in, then its phase will change to didDisappear. If a view is re-added while it is transitioning out, its phase will change back to identity.\n\nIn the identity phase, transitions should generally not make any visual change to the view they are applied to, since the transition\u2019s view modifications in the identity phase will be applied to the view as long as it is visible. In the willAppear and didDisappear phases, transitions should apply a change that will be animated to create the transition. If no animatable change is applied, then the transition will be a no-op.\n\nSee Also: Transition\n\nSee Also: AnyTransition\n\nTopics\nGetting the phase\ncase identity\nThe transition is being applied to a view that is in the view hierarchy.\ncase willAppear\nThe transition is being applied to a view that is about to be inserted into the view hierarchy.\ncase didDisappear\nThe transition is being applied to a view that has been requested to be removed from the view hierarchy.\nGetting phase characteristics\nvar isIdentity: Bool\nA Boolean that indicates whether the transition should have an identity effect, i.e. not change the appearance of its view.\nvar value: Double\nA value that can be used to multiply effects that are applied differently depending on the phase.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "TimelineViewDefaultContext",
        "url": "https://developer.apple.com/documentation/swiftui/timelineviewdefaultcontext",
        "html": "Discussion\n\nThe context includes both the date from the schedule that triggered the callback, and a cadence that you can use to customize the appearance of your view. For example, you might choose to display the second hand of an analog clock only when the cadence is TimelineView.Context.Cadence.seconds or faster.\n\nNote\n\nThis type alias uses a specific concrete instance of TimelineView.Context that all timeline views can use. It does this to prevent introducing an unnecessary generic parameter dependency on the context type.\n\nSee Also\nUpdating a view on a schedule\nstruct TimelineView\nA view that updates according to a schedule that you provide.\nprotocol TimelineSchedule\nA type that provides a sequence of dates for use as a schedule."
    },
    {
        "title": "TimelineSchedule",
        "url": "https://developer.apple.com/documentation/swiftui/timelineschedule",
        "html": "Overview\n\nTypes that conform to this protocol implement a particular kind of schedule by defining an entries(from:mode:) method that returns a sequence of dates. Use a timeline schedule type when you initialize a TimelineView. For example, you can create a timeline view that updates every second, starting from some startDate, using a periodic schedule returned by periodic(from:by:):\n\nTimelineView(.periodic(from: startDate, by: 1.0)) { context in\n    // View content goes here.\n}\n\n\nYou can also create custom timeline schedules. The timeline view updates its content according to the sequence of dates produced by the schedule.\n\nTopics\nGetting built-in schedules\nstatic var animation: AnimationTimelineSchedule\nA pausable schedule of dates updating at a frequency no more quickly than the provided interval.\nAvailable when Self is AnimationTimelineSchedule.\nstatic func animation(minimumInterval: Double?, paused: Bool) -> AnimationTimelineSchedule\nA pausable schedule of dates updating at a frequency no more quickly than the provided interval.\nAvailable when Self is AnimationTimelineSchedule.\nstatic var everyMinute: EveryMinuteTimelineSchedule\nA schedule for updating a timeline view at the start of every minute.\nAvailable when Self is EveryMinuteTimelineSchedule.\nstatic func explicit<S>(S) -> ExplicitTimelineSchedule<S>\nA schedule for updating a timeline view at explicit points in time.\nstatic func periodic(from: Date, by: TimeInterval) -> PeriodicTimelineSchedule\nA schedule for updating a timeline view at regular intervals.\nAvailable when Self is PeriodicTimelineSchedule.\nGetting a sequence of dates\nfunc entries(from: Date, mode: Self.Mode) -> Self.Entries\nProvides a sequence of dates starting around a given date.\n\nRequired\n\nassociatedtype Entries : Sequence\nThe sequence of dates within a schedule.\n\nRequired\n\nSpecifying a mode\ntypealias Mode\nAn alias for the timeline schedule update mode.\nenum TimelineScheduleMode\nA mode of operation for timeline schedule updates.\nSupporting types\nstruct AnimationTimelineSchedule\nA pausable schedule of dates updating at a frequency no more quickly than the provided interval.\nstruct EveryMinuteTimelineSchedule\nA schedule for updating a timeline view at the start of every minute.\nstruct ExplicitTimelineSchedule\nA schedule for updating a timeline view at explicit points in time.\nstruct PeriodicTimelineSchedule\nA schedule for updating a timeline view at regular intervals.\nRelationships\nConforming Types\nAnimationTimelineSchedule\nEveryMinuteTimelineSchedule\nExplicitTimelineSchedule\nPeriodicTimelineSchedule\nSee Also\nUpdating a view on a schedule\nstruct TimelineView\nA view that updates according to a schedule that you provide.\ntypealias TimelineViewDefaultContext\nInformation passed to a timeline view\u2019s content callback."
    },
    {
        "title": "TimelineView",
        "url": "https://developer.apple.com/documentation/swiftui/timelineview",
        "html": "Overview\n\nA timeline view acts as a container with no appearance of its own. Instead, it redraws the content it contains at scheduled points in time. For example, you can update the face of an analog timer once per second:\n\nTimelineView(.periodic(from: startDate, by: 1)) { context in\n    AnalogTimerView(date: context.date)\n}\n\n\nThe closure that creates the content receives an input of type TimelineView.Context that you can use to customize the content\u2019s appearance. The context includes the date that triggered the update. In the example above, the timeline view sends that date to an analog timer that you create so the timer view knows how to draw the hands on its face.\n\nThe context also includes a cadence property that you can use to hide unnecessary detail. For example, you can use the cadence to decide when it\u2019s appropriate to display the timer\u2019s second hand:\n\nTimelineView(.periodic(from: startDate, by: 1.0)) { context in\n    AnalogTimerView(\n        date: context.date,\n        showSeconds: context.cadence <= .seconds)\n}\n\n\nThe system might use a cadence that\u2019s slower than the schedule\u2019s update rate. For example, a view on watchOS might remain visible when the user lowers their wrist, but update less frequently, and thus require less detail.\n\nYou can define a custom schedule by creating a type that conforms to the TimelineSchedule protocol, or use one of the built-in schedule types:\n\nUse an everyMinute schedule to update at the beginning of each minute.\n\nUse a periodic(from:by:) schedule to update periodically with a custom start time and interval between updates.\n\nUse an explicit(_:) schedule when you need a finite number, or irregular set of updates.\n\nFor a schedule containing only dates in the past, the timeline view shows the last date in the schedule. For a schedule containing only dates in the future, the timeline draws its content using the current date until the first scheduled date arrives.\n\nTopics\nCreating a timeline\ninit(Schedule, content: (TimelineViewDefaultContext) -> Content)\nCreates a new timeline view that uses the given schedule.\nAvailable when Schedule conforms to TimelineSchedule and Content conforms to View.\nstruct Context\nInformation passed to a timeline view\u2019s content callback.\nDeprecated symbols\ninit(Schedule, content: (TimelineView<Schedule, Content>.Context) -> Content)\nCreates a new timeline view that uses the given schedule.\nAvailable when Schedule conforms to TimelineSchedule and Content conforms to View.\nDeprecated\nRelationships\nConforms To\nView\nConforms when Schedule conforms to TimelineSchedule and Content conforms to View.\nSee Also\nUpdating a view on a schedule\nprotocol TimelineSchedule\nA type that provides a sequence of dates for use as a schedule.\ntypealias TimelineViewDefaultContext\nInformation passed to a timeline view\u2019s content callback."
    },
    {
        "title": "AnimatablePair",
        "url": "https://developer.apple.com/documentation/swiftui/animatablepair",
        "html": "Topics\nCreating an animatable pair\ninit(First, Second)\nCreates an animated pair with the provided values.\nGetting the constituent animations\nvar first: First\nThe first value.\nvar second: Second\nThe second value.\nManipulating values\nvar magnitudeSquared: Double\nThe dot-product of this animated pair with itself.\nRelationships\nConforms To\nAdditiveArithmetic\nEquatable\nSendable\nVectorArithmetic\nSee Also\nMaking data animatable\nprotocol Animatable\nA type that describes how to animate a property of a view.\nprotocol VectorArithmetic\nA type that can serve as the animatable data of an animatable type.\nstruct EmptyAnimatableData\nAn empty type for animatable data."
    },
    {
        "title": "EmptyAnimatableData",
        "url": "https://developer.apple.com/documentation/swiftui/emptyanimatabledata",
        "html": "Overview\n\nThis type is suitable for use as the animatableData property of types that do not have any animatable properties.\n\nTopics\nCreating the data\ninit()\nManipulating the data\nvar magnitudeSquared: Double\nThe dot-product of this animatable data instance with itself.\nRelationships\nConforms To\nAdditiveArithmetic\nEquatable\nSendable\nVectorArithmetic\nSee Also\nMaking data animatable\nprotocol Animatable\nA type that describes how to animate a property of a view.\nstruct AnimatablePair\nA pair of animatable values, which is itself animatable.\nprotocol VectorArithmetic\nA type that can serve as the animatable data of an animatable type."
    },
    {
        "title": "VectorArithmetic",
        "url": "https://developer.apple.com/documentation/swiftui/vectorarithmetic",
        "html": "Overview\n\nVectorArithmetic extends the AdditiveArithmetic protocol with scalar multiplication and a way to query the vector magnitude of the value. Use this type as the animatableData associated type of a type that conforms to the Animatable protocol.\n\nTopics\nManipulating values\nvar magnitudeSquared: Double\nReturns the dot-product of this vector arithmetic instance with itself.\n\nRequired\n\nfunc scale(by: Double)\nMultiplies each component of this value by the given value.\n\nRequired Default implementation provided.\n\nfunc scaled(by: Double) -> Self\nReturns a value with each component of this value multiplied by the given value.\nfunc interpolate(towards: Self, amount: Double)\nInterpolates this value with other by the specified amount.\nfunc interpolated(towards: Self, amount: Double) -> Self\nReturns this value interpolated with other by the specified amount.\nRelationships\nInherits From\nAdditiveArithmetic\nEquatable\nConforming Types\nAnimatablePair\nEmptyAnimatableData\nSee Also\nMaking data animatable\nprotocol Animatable\nA type that describes how to animate a property of a view.\nstruct AnimatablePair\nA pair of animatable values, which is itself animatable.\nstruct EmptyAnimatableData\nAn empty type for animatable data."
    },
    {
        "title": "DisclosureGroupStyle",
        "url": "https://developer.apple.com/documentation/swiftui/disclosuregroupstyle",
        "html": "Overview\n\nTo configure the disclosure group style for a view hierarchy, use the disclosureGroupStyle(_:) modifier.\n\nTo create a custom disclosure group style, declare a type that conforms to DisclosureGroupStyle. Implement the makeBody(configuration:) method to return a view that composes the elements of the configuration that SwiftUI provides to your method.\n\nstruct MyDisclosureStyle: DisclosureGroupStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        VStack {\n            Button {\n                withAnimation {\n                    configuration.isExpanded.toggle()\n                }\n            } label: {\n                HStack(alignment: .firstTextBaseline) {\n                    configuration.label\n                    Spacer()\n                    Text(configuration.isExpanded ? \"hide\" : \"show\")\n                        .foregroundColor(.accentColor)\n                        .font(.caption.lowercaseSmallCaps())\n                        .animation(nil, value: configuration.isExpanded)\n                }\n                .contentShape(Rectangle())\n            }\n            .buttonStyle(.plain)\n            if configuration.isExpanded {\n                configuration.content\n            }\n        }\n    }\n}\n\nTopics\nGetting the styles\nstatic var automatic: AutomaticDisclosureGroupStyle\nA disclosure group style that resolves its appearance automatically based on the current context.\nAvailable when Self is AutomaticDisclosureGroupStyle.\nCreating custom disclosure group styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a disclosure group.\n\nRequired\n\nstruct DisclosureGroupStyleConfiguration\nThe properties of a disclosure group instance.\ntypealias Configuration\nThe properties of a disclosure group instance.\nassociatedtype Body : View\nA view that represents the body of a disclosure group.\n\nRequired\n\nSupporting types\nstruct AutomaticDisclosureGroupStyle\nA disclosure group style that resolves its appearance automatically based on the current context.\nRelationships\nConforming Types\nAutomaticDisclosureGroupStyle\nSee Also\nStyling collection views\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nprotocol ListStyle\nA protocol that describes the behavior and appearance of a list.\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view.\nprotocol TableStyle\nA type that applies a custom appearance to all tables within a view.\nstruct TableStyleConfiguration\nThe properties of a table.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view."
    },
    {
        "title": "truncationMode(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/truncationmode(_:)",
        "html": "Parameters\nmode\n\nThe truncation mode that specifies where to truncate the text within the text view, if needed. You can truncate at the beginning, middle, or end of the text view.\n\nReturn Value\n\nA view that truncates text at different points in a line depending on the mode you select.\n\nDiscussion\n\nUse the truncationMode(_:) modifier to determine whether text in a long line is truncated at the beginning, middle, or end. Truncation is indicated by adding an ellipsis (\u2026) to the line when removing text to indicate to readers that text is missing.\n\nIn the example below, the bounds of text view constrains the amount of text that the view displays and the truncationMode(_:) specifies from which direction and where to display the truncation indicator:\n\nText(\"This is a block of text that will show up in a text element as multiple lines. The text will fill the available space, and then, eventually, be truncated.\")\n    .frame(width: 150, height: 150)\n    .truncationMode(.tail)\n\n\nSee Also\nManaging text layout\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "minimumScaleFactor(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/minimumscalefactor(_:)",
        "html": "Parameters\nfactor\n\nA fraction between 0 and 1 (inclusive) you use to specify the minimum amount of text scaling that this view permits.\n\nReturn Value\n\nA view that limits the amount of text downscaling.\n\nDiscussion\n\nUse the minimumScaleFactor(_:) modifier if the text you place in a view doesn\u2019t fit and it\u2019s okay if the text shrinks to accommodate. For example, a label with a minimum scale factor of 0.5 draws its text in a font size as small as half of the actual font if needed.\n\nIn the example below, the HStack contains a Text label with a line limit of 1, that is next to a TextField. To allow the label to fit into the available space, the minimumScaleFactor(_:) modifier shrinks the text as needed to fit into the available space.\n\nHStack {\n    Text(\"This is a long label that will be scaled to fit:\")\n        .lineLimit(1)\n        .minimumScaleFactor(0.5)\n    TextField(\"My Long Text Field\", text: $myTextField)\n}\n\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "tabViewStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tabviewstyle(_:)",
        "html": "Parameters\nstyle\n\nThe style to apply to this tab view.\n\nSee Also\nPresenting views in tabs\nstruct TabView\nA view that switches between multiple child views using interactive user interface elements.\nfunc tabItem<V>(() -> V) -> some View\nSets the tab bar item associated with this view."
    },
    {
        "title": "allowsTightening",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/allowstightening",
        "html": "Discussion\n\nThe default value is false.\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "allowsTightening(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/allowstightening(_:)",
        "html": "Parameters\nflag\n\nA Boolean value that indicates whether the space between characters compresses when necessary.\n\nReturn Value\n\nA view that can compress the space between characters when necessary to fit text in a line.\n\nDiscussion\n\nUse allowsTightening(_:) to enable the compression of inter-character spacing of text in a view to try to fit the text in the view\u2019s bounds.\n\nIn the example below, two identically configured text views show the effects of allowsTightening(_:) on the compression of the spacing between characters:\n\nVStack {\n    Text(\"This is a wide text element\")\n        .font(.body)\n        .frame(width: 200, height: 50, alignment: .leading)\n        .lineLimit(1)\n        .allowsTightening(true)\n\n\n    Text(\"This is a wide text element\")\n        .font(.body)\n        .frame(width: 200, height: 50, alignment: .leading)\n        .lineLimit(1)\n        .allowsTightening(false)\n}\n\n\nSee Also\nControlling hit testing\nfunc contentShape<S>(S, eoFill: Bool) -> some View\nDefines the content shape for hit testing.\nfunc contentShape<S>(ContentShapeKinds, S, eoFill: Bool) -> some View\nSets the content shape for this view.\nstruct ContentShapeKinds\nA kind for the content shape of a view."
    },
    {
        "title": "truncationMode",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/truncationmode",
        "html": "Discussion\n\nThe default value is Text.TruncationMode.tail. Some controls, however, might have a different default if appropriate.\n\nSee Also\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis."
    },
    {
        "title": "disclosureGroupStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/disclosuregroupstyle(_:)",
        "html": "See Also\nDisclosing information progressively\nstruct OutlineGroup\nA structure that computes views and disclosure groups on demand from an underlying collection of tree-structured, identified data.\nstruct DisclosureGroup\nA view that shows or hides another content view, based on the state of a disclosure control."
    },
    {
        "title": "monospacedDigit()",
        "url": "https://developer.apple.com/documentation/swiftui/view/monospaceddigit()",
        "html": "Return Value\n\nA view whose child views\u2019 fonts use fixed-width numeric characters, while leaving other characters proportionally spaced.\n\nDiscussion\n\nUsing fixed-width digits allows you to easily align numbers of the same size in a table-like arrangement. This feature is also known as \u201ctabular figures\u201d or \u201ctabular numbers.\u201d\n\nThis modifier only affects numeric characters, and leaves all other characters unchanged.\n\nThe following example shows the effect of monospacedDigit() on multiple child views. The example consists of two VStack views inside an HStack. Each VStack contains two Button views, with the second VStack applying the monospacedDigit() modifier to its contents. As a result, the digits in the buttons in the trailing VStack are the same width, which in turn gives the buttons equal widths.\n\nvar body: some View {\n    HStack(alignment: .top) {\n        VStack(alignment: .leading) {\n            Button(\"Delete 111 messages\") {}\n            Button(\"Delete 222 messages\") {}\n        }\n        VStack(alignment: .leading) {\n            Button(\"Delete 111 messages\") {}\n            Button(\"Delete 222 messages\") {}\n        }\n        .monospacedDigit()\n    }\n    .padding()\n    .navigationTitle(\"monospacedDigit() Child Views\")\n}\n\n\nIf a child view\u2019s base font doesn\u2019t support fixed-width digits, the font remains unchanged.\n\nSee Also\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible."
    },
    {
        "title": "controlGroupStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/controlgroupstyle(_:)",
        "html": "Parameters\nstyle\n\nThe style to apply to controls within this view.\n\nSee Also\nPresenting a group of controls\nstruct ControlGroup\nA container view that displays semantically-related controls in a visually-appropriate manner for the context"
    },
    {
        "title": "dynamicTypeSize(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dynamictypesize(_:)-26aj0",
        "html": "Parameters\nrange\n\nThe range of sizes that are allowed in this view.\n\nReturn Value\n\nA view that constrains the Dynamic Type size of this view within the specified range.\n\nDiscussion\n\nAs an example, you can constrain the maximum Dynamic Type size in ContentView to be no larger than DynamicTypeSize.large:\n\nContentView()\n    .dynamicTypeSize(...DynamicTypeSize.large)\n\n\nIf the Dynamic Type size is limited to multiple ranges, the result is their intersection:\n\nContentView() // Dynamic Type sizes are from .small to .large\n    .dynamicTypeSize(.small...)\n    .dynamicTypeSize(...DynamicTypeSize.large)\n\n\nA specific Dynamic Type size can still be set after a range is applied:\n\nContentView() // Dynamic Type size is .xLarge\n    .dynamicTypeSize(.xLarge)\n    .dynamicTypeSize(...DynamicTypeSize.large)\n\n\nWhen limiting the Dynamic Type size, consider if adding a large content view with accessibilityShowsLargeContentViewer() would be appropriate.\n\nSee Also\nAdjusting text size\nfunc textScale(Text.Scale, isEnabled: Bool) -> some View\nApplies a text scale to text in the view.\nfunc dynamicTypeSize(DynamicTypeSize) -> some View\nSets the Dynamic Type size within the view to the given value.\nvar dynamicTypeSize: DynamicTypeSize\nThe current Dynamic Type size.\nenum DynamicTypeSize\nA Dynamic Type size, which specifies how large scalable content should be.\nstruct ScaledMetric\nA dynamic property that scales a numeric value."
    },
    {
        "title": "TextEditor",
        "url": "https://developer.apple.com/documentation/swiftui/texteditor",
        "html": "Overview\n\nA text editor view allows you to display and edit multiline, scrollable text in your app\u2019s user interface. By default, the text editor view styles the text using characteristics inherited from the environment, like font(_:), foregroundColor(_:), and multilineTextAlignment(_:).\n\nYou create a text editor by adding a TextEditor instance to the body of your view, and initialize it by passing in a Binding to a string variable in your app:\n\nstruct TextEditingView: View {\n    @State private var fullText: String = \"This is some editable text...\"\n\n\n    var body: some View {\n        TextEditor(text: $fullText)\n    }\n}\n\n\nTo style the text, use the standard view modifiers to configure a system font, set a custom font, or change the color of the view\u2019s text.\n\nIn this example, the view renders the editor\u2019s text in gray with a custom font:\n\nstruct TextEditingView: View {\n    @State private var fullText: String = \"This is some editable text...\"\n\n\n    var body: some View {\n        TextEditor(text: $fullText)\n            .foregroundColor(Color.gray)\n            .font(.custom(\"HelveticaNeue\", size: 13))\n    }\n}\n\n\nIf you want to change the spacing or font scaling aspects of the text, you can use modifiers like lineLimit(_:), lineSpacing(_:), and minimumScaleFactor(_:) to configure how the view displays text depending on the space constraints. For example, here the lineSpacing(_:) modifier sets the spacing between lines to 5 points:\n\nstruct TextEditingView: View {\n    @State private var fullText: String = \"This is some editable text...\"\n\n\n    var body: some View {\n        TextEditor(text: $fullText)\n            .foregroundColor(Color.gray)\n            .font(.custom(\"HelveticaNeue\", size: 13))\n            .lineSpacing(5)\n    }\n}\n\nTopics\nCreating a text editor\ninit(text: Binding<String>)\nCreates a plain text editor.\nRelationships\nConforms To\nView\nSee Also\nGetting text input\nstruct TextField\nA control that displays an editable text interface.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nstruct SecureField\nA control into which the user securely enters private text."
    },
    {
        "title": "Applying custom fonts to text",
        "url": "https://developer.apple.com/documentation/swiftui/applying-custom-fonts-to-text",
        "html": "Overview\n\nSwiftUI supports styling text views using the built-in fonts, and uses a system font by default. Rather than using a system-provided font, you can use custom fonts by including the font files in your Xcode project. To use a custom font, add the font file that contains your licensed font to your app, and then apply the font to a text view or set it as a default font within a container view. SwiftUI\u2019s adaptive text display scales the font automtically using Dynamic Type.\n\nDynamic Type allows users to choose the size of textual content displayed onscreen. It helps users who need larger text for better readability and accommodates those who can read smaller text, allowing more information to appear onscreen.\n\nAdd the font files to the project\n\nTo add the font files to your Xcode project:\n\nIn Xcode, select the Project navigator.\n\nDrag your fonts from a Finder window into your project. This copies the fonts to your project.\n\nSelect the font or folder with the fonts, and verify that the files show their target membership checked for your app\u2019s targets.\n\nIdentify the font files to include in the app bundle\n\nFor iOS, watchOS, tvOS, or Mac Catalyst targets, add the UIAppFonts key to your app\u2019s Info.plist file. For the key\u2019s value, provide an array of strings containing the relative paths to any added font files. For a macOS app target, use the ATSApplicationFontsPath key in your target\u2019s Info.plist file, and provide the name of the folder that holds the fonts as the value for that key.\n\nIn the following example, the font file is inside the project_fonts directory, so you use project_fonts/MyFont.ttf as the string value in the Info.plist file.\n\nApply a font supporting dynamic sizing\n\nUse the custom(_:size:) method to retrieve an instance of your font and apply it to a text view with the font(_:) modifier. When retrieving the font with custom(_:size:), match the name of the font with the font\u2019s PostScript name. You can find the postscript name of a font by opening it with the Font Book app and selecting the Font Info tab. If SwiftUI can\u2019t retrieve and apply your font, it renders the text view with the default system font instead.\n\nThe following example applies the font MyFont to a text view:\n\nText(\"Hello, world!\")\n    .font(Font.custom(\"MyFont\", size: 18))\n\n\nThe font scales adaptively from the size provided to align with the default text style of body. Use the relativeTo parameter to specify a text style to scale with other than the default of body. For example, to set the font size to 32 points and adaptively scale relative to the text style of title:\n\nText(\"Hello, world!\")\n    .font(Font.custom(\"MyFont\", size: 32, relativeTo: .title))\n\n\nSwiftUI doesn\u2019t synthesize bold or italic styling for fonts. If the font supports weighted or italic variants, you can customize the typography of the text view by styling the font using the weight(_:) or italic() modifiers.\n\nFor design guidance on choosing fonts to enhance your app on your target platform, see the Human Interface Guidelines > Typography for iOS, macOS, watchOS, or tvOS.\n\nScale padding using scaled metric\n\nThe ScaledMetric property wrapper on a view property provides a scaled value that changes automatically with accessibility settings. When working with adpatively sized fonts, you can scale the spacing between or around the text to improve the visual design with this property wrapper.\n\nThe following example uses @ScaledMetric to scale the padding value surrounding a text view relative to the body text style, with a blue border added to identify the spacing that padding adds:\n\nstruct ContentView: View {\n    @ScaledMetric(relativeTo: .body) var scaledPadding: CGFloat = 10\n\n\n    var body: some View {\n        Text(\"The quick brown fox jumps over the lazy dog.\")\n            .font(Font.custom(\"MyFont\", size: 18))\n            .padding(scaledPadding)\n            .border(Color.blue)\n    }\n}\n\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n\n\nThe preview shows the following image without any accessibility settings turned on:\n\nUse the environment(_:_:) modifier to set the accessibility size category on the preview to ContentSizeCategory.accessibilityLarge:\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n            .environment(\\.sizeCategory, .accessibilityLarge)\n    }\n}\n\n\nThe preview then shows the following image that reflects the increased accessibility size and the scaled padding:\n\nSee Also\nSetting a font\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nvar font: Font?\nThe default font of this environment.\nstruct Font\nAn environment-dependent font."
    },
    {
        "title": "font(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/font(_:)",
        "html": "Parameters\nfont\n\nThe default font to use in this view.\n\nReturn Value\n\nA view with the default font set to the value you supply.\n\nDiscussion\n\nUse font(_:) to apply a specific font to all of the text in a view.\n\nThe example below shows the effects of applying fonts to individual views and to view hierarchies. Font information flows down the view hierarchy as part of the environment, and remains in effect unless overridden at the level of an individual view or view container.\n\nHere, the outermost VStack applies a 16-point system font as a default font to views contained in that VStack. Inside that stack, the example applies a largeTitle font to just the first text view; this explicitly overrides the default. The remaining stack and the views contained with it continue to use the 16-point system font set by their containing view:\n\nVStack {\n    Text(\"Font applied to a text view.\")\n        .font(.largeTitle)\n\n\n    VStack {\n        Text(\"These 2 text views have the same font\")\n        Text(\"applied to their parent hierarchy\")\n    }\n}\n.font(.system(size: 16, weight: .light, design: .default))\n\n\nSee Also\nSetting a font\nApplying custom fonts to text\nAdd and use a font in your app that scales with Dynamic Type.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nvar font: Font?\nThe default font of this environment.\nstruct Font\nAn environment-dependent font."
    },
    {
        "title": "TextSelectability",
        "url": "https://developer.apple.com/documentation/swiftui/textselectability",
        "html": "Overview\n\nTo configure whether people can select text in your app, use the textSelection(_:) modifier, passing in a text selectability value like enabled or disabled.\n\nTopics\nGetting selectability options\nstatic var enabled: EnabledTextSelectability\nA selectability value that enables text selection by a person using your app.\nAvailable when Self is EnabledTextSelectability.\nstatic var disabled: DisabledTextSelectability\nA selectability value that disables text selection by the person using your app.\nAvailable when Self is DisabledTextSelectability.\nSpecifying selectability\nstatic var allowsSelection: Bool\nA Boolean value that indicates whether the selectability type allows selection.\n\nRequired\n\nSupporting types\nstruct EnabledTextSelectability\nA selectability type that enables text selection by the person using your app.\nstruct DisabledTextSelectability\nA selectability type that disables text selection by the person using your app.\nRelationships\nConforming Types\nDisabledTextSelectability\nEnabledTextSelectability\nSee Also\nSelecting text\nfunc textSelection<S>(S) -> some View\nControls whether people can select text within this view."
    },
    {
        "title": "fontDesign(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fontdesign(_:)",
        "html": "Parameters\ndesign\n\nOne of the available font designs. Providing nil removes the effect of any font design modifier applied higher in the view hierarchy.\n\nReturn Value\n\nA view that uses the font design you specify.\n\nSee Also\nSetting a font\nApplying custom fonts to text\nAdd and use a font in your app that scales with Dynamic Type.\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nvar font: Font?\nThe default font of this environment.\nstruct Font\nAn environment-dependent font."
    },
    {
        "title": "textSelection(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textselection(_:)",
        "html": "Discussion\n\nPeople sometimes need to copy useful information from Text views \u2014 including error messages, serial numbers, or IP addresses \u2014 so they can then paste the text into another context. Enable text selection to let people select text in a platform-appropriate way.\n\nYou can apply this method to an individual text view, or to a container to make each contained text view selectable. In the following example, the person using the app can select text that shows the date of an event or the name or email of any of the event participants:\n\nvar body: some View {\n    VStack {\n        Text(\"Event Invite\")\n            .font(.title)\n        Text(invite.date.formatted(date: .long, time: .shortened))\n            .textSelection(.enabled)\n\n\n        List(invite.recipients) { recipient in\n            VStack (alignment: .leading) {\n                Text(recipient.name)\n                Text(recipient.email)\n                    .foregroundStyle(.secondary)\n            }\n        }\n        .textSelection(.enabled)\n    }\n    .navigationTitle(\"New Invitation\")\n}\n\n\nOn macOS, people use the mouse or trackpad to select a range of text, which they can quickly copy by choosing Edit > Copy, or with the standard keyboard shortcut.\n\nOn iOS, the person using the app touches and holds on a selectable Text view, which brings up a system menu with menu items appropriate for the current context. These menu items operate on the entire contents of the Text view; the person can\u2019t select a range of text like they can on macOS.\n\nNote\n\nButton views don\u2019t support text selection.\n\nSee Also\nSelecting text\nprotocol TextSelectability\nA type that describes the ability to select text."
    },
    {
        "title": "DynamicTypeSize",
        "url": "https://developer.apple.com/documentation/swiftui/dynamictypesize",
        "html": "Overview\n\nFor more information about Dynamic Type sizes in iOS, see iOS Human Interface Guidelines > Dynamic Type Sizes. For more information about Dynamic Type sizes in watchOS, see watchOS Human Interface Guidelines > Dynamic Type Sizes.\n\nTopics\nGetting type sizes\ncase xSmall\nAn extra small size.\ncase small\nA small size.\ncase medium\nA medium size.\ncase large\nA large size.\ncase xLarge\nAn extra large size.\ncase xxLarge\nAn extra extra large size.\ncase xxxLarge\nAn extra extra extra large size.\nGetting accessibility type sizes\ncase accessibility1\nThe first accessibility size.\ncase accessibility2\nThe second accessibility size.\ncase accessibility3\nThe third accessibility size.\ncase accessibility4\nThe fourth accessibility size.\ncase accessibility5\nThe fifth accessibility size.\nvar isAccessibilitySize: Bool\nA Boolean value indicating whether the size is one that is associated with accessibility.\nCreating a type size\ninit?(UIContentSizeCategory)\nCreate a Dynamic Type size from its UIContentSizeCategory equivalent.\nRelationships\nConforms To\nCaseIterable\nComparable\nEquatable\nHashable\nSendable\nSee Also\nAdjusting text size\nfunc textScale(Text.Scale, isEnabled: Bool) -> some View\nApplies a text scale to text in the view.\nfunc dynamicTypeSize<T>(T) -> some View\nLimits the Dynamic Type size within the view to the given range.\nfunc dynamicTypeSize(DynamicTypeSize) -> some View\nSets the Dynamic Type size within the view to the given value.\nvar dynamicTypeSize: DynamicTypeSize\nThe current Dynamic Type size.\nstruct ScaledMetric\nA dynamic property that scales a numeric value."
    },
    {
        "title": "italic(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/italic(_:)",
        "html": "Parameters\nisActive\n\nA Boolean value that indicates whether italic styling is added. The default value is true.\n\nReturn Value\n\nA View with italic text.\n\nSee Also\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced."
    },
    {
        "title": "dynamicTypeSize(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dynamictypesize(_:)-1m2tf",
        "html": "Parameters\nsize\n\nThe size to set for this view.\n\nReturn Value\n\nA view that sets the Dynamic Type size to the specified size.\n\nDiscussion\n\nAs an example, you can set a Dynamic Type size in ContentView to be DynamicTypeSize.xLarge (this can be useful in previews to see your content at a different size) like this:\n\nContentView()\n    .dynamicTypeSize(.xLarge)\n\n\nIf a Dynamic Type size range is applied after setting a value, the value is limited by that range:\n\nContentView() // Dynamic Type size will be .large\n    .dynamicTypeSize(...DynamicTypeSize.large)\n    .dynamicTypeSize(.xLarge)\n\n\nWhen limiting the Dynamic Type size, consider if adding a large content view with accessibilityShowsLargeContentViewer() would be appropriate.\n\nSee Also\nAdjusting text size\nfunc textScale(Text.Scale, isEnabled: Bool) -> some View\nApplies a text scale to text in the view.\nfunc dynamicTypeSize<T>(T) -> some View\nLimits the Dynamic Type size within the view to the given range.\nvar dynamicTypeSize: DynamicTypeSize\nThe current Dynamic Type size.\nenum DynamicTypeSize\nA Dynamic Type size, which specifies how large scalable content should be.\nstruct ScaledMetric\nA dynamic property that scales a numeric value."
    },
    {
        "title": "bold(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/bold(_:)",
        "html": "Parameters\nisActive\n\nA Boolean value that indicates whether bold font styling is added. The default value is true.\n\nReturn Value\n\nA view with bold text.\n\nSee Also\nControlling text style\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced."
    },
    {
        "title": "AnimatableModifier",
        "url": "https://developer.apple.com/documentation/swiftui/animatablemodifier",
        "html": "Deprecated\n\nUse Animatable instead.\n\nRelationships\nInherits From\nAnimatable\nViewModifier"
    },
    {
        "title": "Animatable",
        "url": "https://developer.apple.com/documentation/swiftui/animatable",
        "html": "Topics\nAnimating data\nvar animatableData: Self.AnimatableData\nThe data to animate.\n\nRequired Default implementations provided.\n\nassociatedtype AnimatableData : VectorArithmetic\nThe type defining the data to animate.\n\nRequired\n\nRelationships\nInherited By\nAnimatableModifier\nGeometryEffect\nInsettableShape\nLayout\nShape\nVisualEffect\nConforming Types\nAngle\nAnyLayout\nAnyShape\nButtonBorderShape\nCapsule\nCircle\nColor.Resolved\nContainerRelativeShape\nEdgeInsets\nEdgeInsets3D\nEllipse\nEmptyVisualEffect\nGridLayout\nHStackLayout\nOffsetShape\nConforms when Content conforms to InsettableShape.\nPath\nRectangle\nRectangleCornerRadii\nRotatedShape\nConforms when Content conforms to InsettableShape.\nRoundedRectangle\nScaledShape\nStrokeStyle\nTransformedShape\nUnevenRoundedRectangle\nUnitPoint\nUnitPoint3D\nVStackLayout\nZStackLayout\nSee Also\nMaking data animatable\nstruct AnimatablePair\nA pair of animatable values, which is itself animatable.\nprotocol VectorArithmetic\nA type that can serve as the animatable data of an animatable type.\nstruct EmptyAnimatableData\nAn empty type for animatable data."
    },
    {
        "title": "AnyTransition",
        "url": "https://developer.apple.com/documentation/swiftui/anytransition",
        "html": "Overview\n\nSee Also: Transition\n\nTopics\nGetting built-in transitions\nstatic let identity: AnyTransition\nA transition that returns the input view, unmodified, as the output view.\nstatic func move(edge: Edge) -> AnyTransition\nReturns a transition that moves the view away, towards the specified edge of the view.\nstatic func offset(CGSize) -> AnyTransition\nstatic func offset(x: CGFloat, y: CGFloat) -> AnyTransition\nstatic let opacity: AnyTransition\nA transition from transparent to opaque on insertion, and from opaque to transparent on removal.\nstatic func push(from: Edge) -> AnyTransition\nCreates a transition that when added to a view will animate the view\u2019s insertion by moving it in from the specified edge while fading it in, and animate its removal by moving it out towards the opposite edge and fading it out.\nstatic var scale: AnyTransition\nReturns a transition that scales the view.\nstatic func scale(scale: CGFloat, anchor: UnitPoint) -> AnyTransition\nReturns a transition that scales the view by the specified amount.\nstatic var slide: AnyTransition\nA transition that inserts by moving in from the leading edge, and removes by moving out towards the trailing edge.\nCombining and configuring transitions\nfunc animation(Animation?) -> AnyTransition\nAttaches an animation to this transition.\nstatic func asymmetric(insertion: AnyTransition, removal: AnyTransition) -> AnyTransition\nProvides a composite transition that uses a different transition for insertion versus removal.\nfunc combined(with: AnyTransition) -> AnyTransition\nCombines this transition with another, returning a new transition that is the result of both transitions being applied.\nCreating a custom transition\ninit<T>(T)\nCreate an instance that type-erases transition.\nstatic func modifier<E>(active: E, identity: E) -> AnyTransition\nReturns a transition defined between an active modifier and an identity modifier.\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "scale",
        "url": "https://developer.apple.com/documentation/swiftui/anytransition/scale",
        "html": "See Also\nGetting built-in transitions\nstatic let identity: AnyTransition\nA transition that returns the input view, unmodified, as the output view.\nstatic func move(edge: Edge) -> AnyTransition\nReturns a transition that moves the view away, towards the specified edge of the view.\nstatic func offset(CGSize) -> AnyTransition\nstatic func offset(x: CGFloat, y: CGFloat) -> AnyTransition\nstatic let opacity: AnyTransition\nA transition from transparent to opaque on insertion, and from opaque to transparent on removal.\nstatic func push(from: Edge) -> AnyTransition\nCreates a transition that when added to a view will animate the view\u2019s insertion by moving it in from the specified edge while fading it in, and animate its removal by moving it out towards the opposite edge and fading it out.\nstatic func scale(scale: CGFloat, anchor: UnitPoint) -> AnyTransition\nReturns a transition that scales the view by the specified amount.\nstatic var slide: AnyTransition\nA transition that inserts by moving in from the leading edge, and removes by moving out towards the trailing edge."
    },
    {
        "title": "slide",
        "url": "https://developer.apple.com/documentation/swiftui/anytransition/slide",
        "html": "Discussion\n\nSee Also\n\nAnyTransition.move(edge:)\n\nSee Also\nGetting built-in transitions\nstatic let identity: AnyTransition\nA transition that returns the input view, unmodified, as the output view.\nstatic func move(edge: Edge) -> AnyTransition\nReturns a transition that moves the view away, towards the specified edge of the view.\nstatic func offset(CGSize) -> AnyTransition\nstatic func offset(x: CGFloat, y: CGFloat) -> AnyTransition\nstatic let opacity: AnyTransition\nA transition from transparent to opaque on insertion, and from opaque to transparent on removal.\nstatic func push(from: Edge) -> AnyTransition\nCreates a transition that when added to a view will animate the view\u2019s insertion by moving it in from the specified edge while fading it in, and animate its removal by moving it out towards the opposite edge and fading it out.\nstatic var scale: AnyTransition\nReturns a transition that scales the view.\nstatic func scale(scale: CGFloat, anchor: UnitPoint) -> AnyTransition\nReturns a transition that scales the view by the specified amount."
    },
    {
        "title": "AnimationContext",
        "url": "https://developer.apple.com/documentation/swiftui/animationcontext",
        "html": "Overview\n\nThe system provides an AnimationContext to a CustomAnimation instance so that the animation can store and retrieve values in an instance of AnimationState. To access these values, use the context\u2019s state property.\n\nFor more convenient access to state, create an AnimationStateKey and extend AnimationContext to include a computed property that gets and sets the AnimationState value. Then use this property instead of state to retrieve the state of a custom animation. For example, the following code creates an animation state key named PausableState. Then the code extends AnimationContext to include the pausableState property:\n\nprivate struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    var paused = false\n    var pauseTime: TimeInterval = 0.0\n\n\n    static var defaultValue: Self { .init() }\n}\n\n\nextension AnimationContext {\n    fileprivate var pausableState: PausableState<Value> {\n        get { state[PausableState<Value>.self] }\n        set { state[PausableState<Value>.self] = newValue }\n    }\n}\n\n\nTo access the pausable state, the custom animation PausableAnimation uses the pausableState property instead of the state property:\n\nstruct PausableAnimation: CustomAnimation {\n    let base: Animation\n\n\n    func animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V? where V : VectorArithmetic {\n        let paused = context.environment.animationPaused\n\n\n        let pausableState = context.pausableState\n        var pauseTime = pausableState.pauseTime\n        if pausableState.paused != paused {\n            pauseTime = time - pauseTime\n            context.pausableState = PausableState(paused: paused, pauseTime: pauseTime)\n        }\n\n\n        let effectiveTime = paused ? pauseTime : time - pauseTime\n        let result = base.animate(value: value, time: effectiveTime, context: &context)\n        return result\n    }\n}\n\n\nThe animation can also retrieve environment values of the view that created the animation. To retrieve a view\u2019s environment value, use the context\u2019s environment property. For instance, the following code creates a custom EnvironmentKey named AnimationPausedKey, and the view PausableAnimationView uses the key to store the paused state:\n\nstruct AnimationPausedKey: EnvironmentKey {\n    static let defaultValue = false\n}\n\n\nextension EnvironmentValues {\n    var animationPaused: Bool {\n        get { self[AnimationPausedKey.self] }\n        set { self[AnimationPausedKey.self] = newValue }\n    }\n}\n\n\nstruct PausableAnimationView: View {\n    @State private var paused = false\n\n\n    var body: some View {\n        VStack {\n            ...\n        }\n        .environment(\\.animationPaused, paused)\n    }\n}\n\n\nThen the custom animation PausableAnimation retrieves the paused state from the view\u2019s environment using the environment property:\n\nstruct PausableAnimation: CustomAnimation {\n    func animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V? where V : VectorArithmetic {\n        let paused = context.environment.animationPaused\n        ...\n    }\n}\n\nTopics\nManaging state\nvar state: AnimationState<Value>\nThe current state of a custom animation.\nRetrieving view environment values\nvar environment: EnvironmentValues\nThe current environment of the view that created the custom animation.\nCreating context\nfunc withState<T>(AnimationState<T>) -> AnimationContext<T>\nCreates a new context from another one with a state that you provide.\nInstance Properties\nvar isLogicallyComplete: Bool\nSet this to true to indicate that an animation is logically complete.\nSee Also\nCreating custom animations\nprotocol CustomAnimation\nA type that defines how an animatable value changes over time.\nstruct AnimationState\nA container that stores the state for a custom animation.\nprotocol AnimationStateKey\nA key for accessing animation state values.\nstruct UnitCurve\nA function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed.\nstruct Spring\nA representation of a spring\u2019s motion."
    },
    {
        "title": "MenuStyle",
        "url": "https://developer.apple.com/documentation/swiftui/menustyle",
        "html": "Overview\n\nTo configure the current menu style for a view hierarchy, use the menuStyle(_:) modifier.\n\nTopics\nGetting built-in menu styles\nstatic var automatic: DefaultMenuStyle\nThe default menu style, based on the menu\u2019s context.\nAvailable when Self is DefaultMenuStyle.\nstatic var button: ButtonMenuStyle\nA menu style that displays a button that toggles the display of the menu\u2019s contents when pressed.\nAvailable when Self is ButtonMenuStyle.\nstatic var borderedButton: BorderedButtonMenuStyle\nA menu style that displays a bordered button that toggles the display of the menu\u2019s contents when pressed.\nAvailable when Self is BorderedButtonMenuStyle.\nDeprecated\nstatic var borderlessButton: BorderlessButtonMenuStyle\nA menu style that displays a borderless button that toggles the display of the menu\u2019s contents when pressed.\nAvailable when Self is BorderlessButtonMenuStyle.\nDeprecated\nCreating custom menu styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a menu.\n\nRequired\n\ntypealias Configuration\nThe properties of a menu.\nassociatedtype Body : View\nA view that represents the body of a menu.\n\nRequired\n\nSupporting types\nstruct DefaultMenuStyle\nThe default menu style, based on the menu\u2019s context.\nstruct ButtonMenuStyle\nA menu style that displays a button that toggles the display of the menu\u2019s contents when pressed.\nstruct BorderlessButtonMenuStyle\nA menu style that displays a borderless button that toggles the display of the menu\u2019s contents when pressed.\nDeprecated\nstruct BorderedButtonMenuStyle\nA menu style that displays a bordered button that toggles the display of the menu\u2019s contents when pressed.\nDeprecated\nRelationships\nConforming Types\nBorderedButtonMenuStyle\nBorderlessButtonMenuStyle\nButtonMenuStyle\nDefaultMenuStyle\nSee Also\nStyling menus\nfunc menuStyle<S>(S) -> some View\nSets the style for menus within this view.\nstruct MenuStyleConfiguration\nA configuration of a menu."
    },
    {
        "title": "Animation",
        "url": "https://developer.apple.com/documentation/swiftui/animation",
        "html": "Overview\n\nAn Animation provides a visual transition of a view when a state value changes from one value to another. The characteristics of this transition vary according to the animation type. For instance, a linear animation provides a mechanical feel to the animation because its speed is consistent from start to finish. In contrast, an animation that uses easing, like easeOut, offers a more natural feel by varying the acceleration of the animation.\n\nTo apply an animation to a view, add the animation(_:value:) modifier, and specify both an animation type and the value to animate. For instance, the Circle view in the following code performs an easeIn animation each time the state variable scale changes:\n\nstruct ContentView: View {\n    @State private var scale = 0.5\n\n\n    var body: some View {\n        VStack {\n            Circle()\n                .scaleEffect(scale)\n                .animation(.easeIn, value: scale)\n            HStack {\n                Button(\"+\") { scale += 0.1 }\n                Button(\"-\") { scale -= 0.1 }\n            }\n        }\n        .padding()\n    }\n\nPlay\n\nWhen the value of scale changes, the modifier scaleEffect(_:anchor:) resizes Circle according to the new value. SwiftUI can animate the transition between sizes because Circle conforms to the Shape protocol. Shapes in SwiftUI conform to the Animatable protocol, which describes how to animate a property of a view.\n\nIn addition to adding an animation to a view, you can also configure the animation by applying animation modifiers to the animation type. For example, you can:\n\nDelay the start of the animation by using the delay(_:) modifier.\n\nRepeat the animation by using the repeatCount(_:autoreverses:) or repeatForever(autoreverses:) modifiers.\n\nChange the speed of the animation by using the speed(_:) modifier.\n\nFor example, the Circle view in the following code repeats the easeIn animation three times by using the repeatCount(_:autoreverses:) modifier:\n\nstruct ContentView: View {\n    @State private var scale = 0.5\n\n\n    var body: some View {\n        VStack {\n            Circle()\n                .scaleEffect(scale)\n                .animation(.easeIn.repeatCount(3), value: scale)\n            HStack {\n                Button(\"+\") { scale += 0.1 }\n                Button(\"-\") { scale -= 0.1 }\n            }\n        }\n        .padding()\n    }\n}\n\nPlay\n\nA view can also perform an animation when a binding value changes. To specify the animation type on a binding, call its animation(_:) method. For example, the view in the following code performs a linear animation, moving the box truck between the leading and trailing edges of the view. The truck moves each time a person clicks the Toggle control, which changes the value of the $isTrailing binding.\n\nstruct ContentView: View {\n    @State private var isTrailing = false\n\n\n    var body: some View {\n       VStack(alignment: isTrailing ? .trailing : .leading) {\n            Image(systemName: \"box.truck\")\n                .font(.system(size: 64))\n\n\n            Toggle(\"Move to trailing edge\",\n                   isOn: $isTrailing.animation(.linear))\n        }\n    }\n}\n\nPlay\nTopics\nGetting the default animation\nstatic let `default`: Animation\nA default animation instance.\nGetting linear animations\nstatic var linear: Animation\nAn animation that moves at a constant speed.\nstatic func linear(duration: TimeInterval) -> Animation\nAn animation that moves at a constant speed during a specified duration.\nGetting eased animations\nstatic var easeIn: Animation\nAn animation that starts slowly and then increases speed towards the end of the movement.\nstatic func easeIn(duration: TimeInterval) -> Animation\nAn animation with a specified duration that starts slowly and then increases speed towards the end of the movement.\nstatic var easeOut: Animation\nAn animation that starts quickly and then slows towards the end of the movement.\nstatic func easeOut(duration: TimeInterval) -> Animation\nAn animation with a specified duration that starts quickly and then slows towards the end of the movement.\nstatic var easeInOut: Animation\nAn animation that combines the behaviors of in and out easing animations.\nstatic func easeInOut(duration: TimeInterval) -> Animation\nAn animation with a specified duration that combines the behaviors of in and out easing animations.\nGetting built-in spring animations\nstatic var bouncy: Animation\nA spring animation with a predefined duration and higher amount of bounce.\nstatic func bouncy(duration: TimeInterval, extraBounce: Double) -> Animation\nA spring animation with a predefined duration and higher amount of bounce that can be tuned.\nstatic var smooth: Animation\nA smooth spring animation with a predefined duration and no bounce.\nstatic func smooth(duration: TimeInterval, extraBounce: Double) -> Animation\nA smooth spring animation with a predefined duration and no bounce that can be tuned.\nstatic var snappy: Animation\nA spring animation with a predefined duration and small amount of bounce that feels more snappy.\nstatic func snappy(duration: TimeInterval, extraBounce: Double) -> Animation\nA spring animation with a predefined duration and small amount of bounce that feels more snappy and can be tuned.\nCustomizing spring animations\nstatic var spring: Animation\nA persistent spring animation. When mixed with other spring() or interactiveSpring() animations on the same property, each animation will be replaced by their successor, preserving velocity from one animation to the next. Optionally blends the response values between springs over a time period.\nstatic func spring(Spring, blendDuration: TimeInterval) -> Animation\nA persistent spring animation.\nstatic func spring(duration: TimeInterval, bounce: Double, blendDuration: Double) -> Animation\nA persistent spring animation. When mixed with other spring() or interactiveSpring() animations on the same property, each animation will be replaced by their successor, preserving velocity from one animation to the next. Optionally blends the duration values between springs over a time period.\nstatic func spring(response: Double, dampingFraction: Double, blendDuration: TimeInterval) -> Animation\nA persistent spring animation. When mixed with other spring() or interactiveSpring() animations on the same property, each animation will be replaced by their successor, preserving velocity from one animation to the next. Optionally blends the response values between springs over a time period.\nstatic var interactiveSpring: Animation\nA convenience for a spring animation with a lower duration value, intended for driving interactive animations.\nstatic func interactiveSpring(response: Double, dampingFraction: Double, blendDuration: TimeInterval) -> Animation\nA convenience for a spring animation with a lower response value, intended for driving interactive animations.\nstatic var interpolatingSpring: Animation\nAn interpolating spring animation that uses a damped spring model to produce values in the range [0, 1] that are then used to interpolate within the [from, to] range of the animated property. Preserves velocity across overlapping animations by adding the effects of each animation.\nstatic func interpolatingSpring(Spring, initialVelocity: Double) -> Animation\nAn interpolating spring animation that uses a damped spring model to produce values in the range of one to zero.\nstatic func interpolatingSpring(duration: TimeInterval, bounce: Double, initialVelocity: Double) -> Animation\nAn interpolating spring animation that uses a damped spring model to produce values in the range [0, 1] that are then used to interpolate within the [from, to] range of the animated property. Preserves velocity across overlapping animations by adding the effects of each animation.\nstatic func interpolatingSpring(mass: Double, stiffness: Double, damping: Double, initialVelocity: Double) -> Animation\nAn interpolating spring animation that uses a damped spring model to produce values in the range [0, 1] that are then used to interpolate within the [from, to] range of the animated property. Preserves velocity across overlapping animations by adding the effects of each animation.\nCreating custom animations\ninit<A>(A)\nCreate an Animation that contains the specified custom animation.\nstatic func timingCurve(UnitCurve, duration: TimeInterval) -> Animation\nCreates a new animation with speed controlled by the given curve.\nstatic func timingCurve(Double, Double, Double, Double, duration: TimeInterval) -> Animation\nAn animation created from a cubic B\u00e9zier timing curve.\nConfiguring an animation\nfunc delay(TimeInterval) -> Animation\nDelays the start of the animation by the specified number of seconds.\nfunc repeatCount(Int, autoreverses: Bool) -> Animation\nRepeats the animation for a specific number of times.\nfunc repeatForever(autoreverses: Bool) -> Animation\nRepeats the animation for the lifespan of the view containing the animation.\nfunc speed(Double) -> Animation\nChanges the duration of an animation by adjusting its speed.\nInstance Properties\nvar base: CustomAnimation\nInstance Methods\nfunc animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V?\nCalculates the current value of the animation.\nfunc logicallyComplete(after: TimeInterval) -> Animation\nCauses the animation to report logical completion after the specified duration, if it has not already logically completed.\nfunc shouldMerge<V>(previous: Animation, value: V, time: TimeInterval, context: inout AnimationContext<V>) -> Bool\nReturns a Boolean value that indicates whether the current animation should merge with a previous animation.\nfunc velocity<V>(value: V, time: TimeInterval, context: AnimationContext<V>) -> V?\nCalculates the current velocity of the animation.\nType Methods\nstatic func interactiveSpring(duration: TimeInterval, extraBounce: Double, blendDuration: TimeInterval) -> Animation\nA convenience for a spring animation with a lower response value, intended for driving interactive animations.\nRelationships\nConforms To\nCustomDebugStringConvertible\nCustomReflectable\nCustomStringConvertible\nEquatable\nHashable\nSendable\nSee Also\nAdding state-based animation to an action\nfunc withAnimation<Result>(Animation?, () throws -> Result) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation.\nfunc withAnimation<Result>(Animation?, completionCriteria: AnimationCompletionCriteria, () throws -> Result, completion: () -> Void) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation, and runs the completion when all animations are complete.\nstruct AnimationCompletionCriteria\nThe criteria that determines when an animation is considered finished."
    },
    {
        "title": "withAnimation(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/withanimation(_:_:)",
        "html": "Discussion\n\nThis function sets the given Animation as the animation property of the thread\u2019s current Transaction.\n\nSee Also\nAdding state-based animation to an action\nfunc withAnimation<Result>(Animation?, completionCriteria: AnimationCompletionCriteria, () throws -> Result, completion: () -> Void) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation, and runs the completion when all animations are complete.\nstruct AnimationCompletionCriteria\nThe criteria that determines when an animation is considered finished.\nstruct Animation\nThe way a view changes over time to create a smooth visual transition from one state to another."
    },
    {
        "title": "Controlling the timing and movements of your animations",
        "url": "https://developer.apple.com/documentation/swiftui/controlling-the-timing-and-movements-of-your-animations",
        "html": "Overview\n\nSwiftUI provides a collection of useful animations that you can use in your app. These animations help enhance the user experience of your app by providing visual transitions of views and user interface elements. While these standard animations provide a great way to enhancement the user interaction of your app, there are times when you need to have more control over the timing and movement of a visual element. PhaseAnimator and KeyframeAnimator help give you that control.\n\nA phase animator allows you to define an animation as a collection of discrete steps called phases. The animator cycles through these phases to create a visual transition. With keyframe animator, you create keyframes that define animation values at specific times during the visual transition.\n\nCreate a simple bounce animation\n\nTo better understand how to create animations using a PhaseAnimator or KeyframeAnimator, start with a simple example that uses standard SwiftUI animations. The following code moves an emoji upwards by setting its offset to -40.0. To provide a smooth transition of the movement, the code uses the withAnimation(_:_:) function to apply a bouncy animation after someone taps the emoji.\n\nstruct SimpleAnimationView: View {\n    var emoji: String\n    @State private var offset = 0.0\n\n\n    var body: some View {\n        EmojiView(emoji: emoji)\n            .offset(y: offset)\n            .onTapGesture {\n                withAnimation(.bouncy) {\n                    offset = -40.0\n                }\n            }\n    }\n}\n\n\nThis animation has a single, discrete step: move the emoji upward. However, an animation can have multiple steps, such as moving an emoji upwards then back to its original position. For example, the following code sets the offset to -40.0 to move the emoji upward, and then sets the offset (0.0) to return the emoji back to its original position:\n\nstruct SimpleAnimationView: View {\n    var emoji: String\n    @State private var offset = 0.0\n\n\n    var body: some View {\n        EmojiView(emoji: emoji)\n            .offset(y: offset)\n            .onTapGesture {\n                withAnimation(.bouncy) {\n                    offset = -40.0\n                } completion: {\n                    withAnimation {\n                        offset = 0.0\n                    }\n                }\n            }\n    }\n}\n\n\nThis code uses the withAnimation(_:completionCriteria:_:completion:) function to animate the two steps of the visual transition. The first step occurs in the body closure of the function, setting the offset to -40.0. The second step occurs in the completion closure, setting the offset to 0.0.\n\nPlay\n\nHowever, EmojiView actually goes through three steps. The first step happens when the view appears for the first time. The offset of the EmojiView view is 0.0. When someone taps the view, the offset changes to -40.0; this is the second step. When that animation completes, the third step changes the offset back to 0.0. However, there are only two discrete steps, based on the offset values (0.0 and -40.0).\n\nWhile this implementation certainly works as expected, using a PhaseAnimator is a more convenient way to define discrete steps as phases of an animation.\n\nBounce with a phase animator\n\nA PhaseAnimator automatically advances through a set of given phases to create an animated transition. Use the phaseAnimator(_:content:animation:) modifier to provide the animator the phases for changing the animation value. For example, the emoji bounce animation shown earlier has two phases: move up and move back. You can represent these phases using the Boolean values, true and false. When the phase is true, the emoji moves up to -40.0. When the phase is false, the emoji moves back to the original position by setting the offset to 0.0.\n\nstruct TwoPhaseAnimationView: View {\n    var emoji: String\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true]) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            }\n    }\n}\n\n\nThe phase animator cycles through the list of phases in the order that you provide to the phaseAnimator(_:content:animation:) modifier. When the view first appears, the phase animator invokes the content closure passing in the first phase. Then the animator calls the closure with the value of the second phase. The animator continues to call the content closure for each additional phase. After reaching the last phase, the animator calls content one more time with the value of the first phase.\n\nThis means that in the previous code, the phase animator calls content with the phase value of false when the view first appears. This sets the emoji\u2019s offset to 0.0. The phase animator then calls content with the true phase. This phase sets the offset to -40.0, causing the emoji to move upwards. After reaching that offset position, the animator calls content with the phase of false. This causes the emoji to move back to its original position by setting its offset to 0.0.\n\nThis animation starts when the view appears. To start the animation based on an event, use the phaseAnimator(_:trigger:content:animation:) modifier and provide a trigger value that animator observes for changes. The animator starts the animation when the value changes. For example, the following code increments the state variable likeCount each time a person taps the emoji. The code uses likeCount as the value that the phase animator observes for changes. Now whenever someone taps the emoji, it moves up and returns to its original position.\n\nstruct TwoPhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true], trigger: likeCount) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\nPlay\n\nSo far, the phase animator uses the default animation to move the emoji. You can change that behavior by providing the phaseAnimator modifier an animation closure. In this closure, specify the type of animation to apply for each phase. For instance, the following code applies a bouncy animation when the phase is true; otherwise, it applies the default animation:\n\nstruct TwoPhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true], trigger: likeCount) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            } animation: { phase in\n                phase ? .bouncy : .default\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\nPlay\nAdd more phases to the animation\n\nWhile this bounce effect is nice, you can add more pizzazz to it. For instance, you could make the emoji increase in size as it moves upward, and then shrink back to normal size. To do this, you\u2019ll add a third phase to the animation: scale.\n\nTo define the phases, create a custom type that lists the possible phases; for example:\n\nprivate enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n}\n\n\nNext, to help simplify logic and reduce complexity, define computed properties that return the values to animate. For instance, to set the vertical offset to move the emoji, create a computed property that returns the offset based on the current phase:\n\nprivate enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n    \n    var verticalOffset: Double {\n        switch self {\n        case .initial: 0\n        case .move, .scale: -64\n        }\n    }\n}\n\n\nWhen at the initial phase, the offset is 0, which is the original screen location for the emoji. But when the phase is move or scale, the offset is -64.\n\nYou can use the same approach (creating a computed property) for the scale effect to change the size of the emoji. Initially, the emoji appears at its original size, but increases in size during the move and scale phase, as shown here:\n\nprivate enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n    \n    var verticalOffset: Double {\n        switch self {\n        case .initial: 0\n        case .move, .scale: -64\n        }\n    }\n    \n    var scaleEffect: Double {\n        switch self {\n        case .initial: 1\n        case .move, .scale: 1.5\n        }\n    }\n}\n\n\nTo animate an emoji, apply the phaseAnimator(_:trigger:content:animation:) modifier to the EmojiView. Provide the animator all cases from the custom AnimationPhase type. Then change the content based on the phase by applying the scaleEffect(_:anchor:) and offset(x:y:) modifiers. The values passed into these modifiers come from the computed properties, which helps keep the view code more readable.\n\nstruct ThreePhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator(AnimationPhase.allCases, trigger: likeCount) { content, phase in\n                content\n                    .scaleEffect(phase.scaleEffect)\n                    .offset(y: phase.verticalOffset)\n            } animation: { phase in\n                switch phase {\n                case .initial: .smooth\n                case .move: .easeInOut(duration: 0.3)\n                case .scale: .spring(duration: 0.3, bounce: 0.7)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\n\nThe code also applies different animation types based on the phase in the animation closure to give the full animation that pizzazz you were looking for.\n\nPlay\n\nNote\n\nUse the canvas preview in Xcode to help determine the animation types and values to apply for the phase animations. Make changes to the code and see those changes reflected in the canvas preview.\n\nA PhaseAnimator gives you control of an animation based on discrete phases, which helps you add extra polish to an animation. But if you find that you need even more control over the timing and movement of an animation, use a KeyframeAnimator.\n\nGain more control with a keyframe animator\n\nYou can define complex, coordinated animations with complete control over timing and movement using a KeyframeAnimator. This animator allows you to create keyframes that define values at specific times during an animation. The animator use these values to generate interpolated values in between each frame of the animation.\n\nUnlike a phase animator, in which you model separate, discrete states, a keyframe animator generates interpolated values of the type that you specify. While an animation is in progress, the animator provides you with a value of this type on every frame so you can update the animating view by applying modifiers to it.\n\nYou define the type as a structure that contains the properties that you want to independently animate. For example, the following code defines four properties that determine the scale, stretch, position, and angle of an emoji:\n\nprivate struct AnimationValues {\n    var scale = 1.0\n    var verticalStretch = 1.0\n    var verticalOffset = 0.0\n    var angle = Angle.zero\n}\n\n\nNote\n\nKeyframeAnimator can animate any value that conforms to the Animatable protocol.\n\nTo create a animation using a keyframe animator, apply either the keyframeAnimator(initialValue:repeating:content:keyframes:) or keyframeAnimator(initialValue:trigger:content:keyframes:) modifier to the view that you want to animate. For instance, the following code applies the second modifier to EmojiView. The initial value for the animation is a new instance of AnimationValues, and the state variable likeCount is the value that the animator observes for changes as it did in the previous phase animation example.\n\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                // ...\n            } keyframes: { _ in\n                // ...\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\n\nTo apply modifiers to a view during the animation, provide a content closure to the keyframe animator. This closure includes two parameters:\n\ncontent\n\nThe view that\u2019s animating.\n\nvalue\n\nThe current interpolated values.\n\nUse these parameters to apply modifiers to the view that SwiftUI is animating. For example, the following code uses these parameters to rotate, scale, stretch, and move an emoji:\n\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                // ...\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\n\nImportant\n\nSwiftUI calls the keyframe animator\u2019s content closure on every frame of the animation, so avoid performing any expensive operations directly within it.\n\nNext, define the keyframes. Keyframes let you build sophisticated animations with different keyframe for different properties. To make this possible, you organize the keyframes into tracks. Each track controls a different property of the type that you are animating. You associate a property to a track by providing the key path to the property when creating the track. For example, the following code adds a KeyframeTrack for the scale property:\n\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    // ...\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\n\nWhen creating a track, you use the declarative syntax in SwiftUI to add keyframes to the track. There are different kinds of keyframes, such as CubicKeyframe, LinearKeyframe, and SpringKeyframe. You can mix and match the different kinds of keyframes within a track. For example, the following code adds a track for the scale property that performs a combination of linear and spring animations:\n\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    LinearKeyframe(1.0, duration: 0.36)\n                    SpringKeyframe(1.5, duration: 0.8,\n                        spring: .bouncy)\n                    SpringKeyframe(1.0, spring: .bouncy)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\n\nEach keyframe type receives a value. The animator uses this value to generate interpolated values between frames and sets the property specified in the track\u2019s key path before calling the animator\u2019s content closure. For instance, in the previous code listing, the scale value is 1.0 during the linear keyframes, which keeps the emoji at its original size. Then the scale changes to 1.5 during the first spring keyframe. This causes the emoji to grow in size. The final spring keyframe sets the scale to 1.0, which returns the emoji back to its original size.\n\nNote\n\nSwiftUI preserves the velocity (that is, the speed of the animation) across multiple keyframes for continuous motion within a track.\n\nWhen implementing a keyframe animation, include a track for each property that you want to animate. For instance, AnimationValues has four properties:\n\nscale\n\nverticalStretch\n\nverticalOffset\n\nangle\n\nTo animate all four, the animator needs four keyframe tracks as shown in the following code:\n\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    LinearKeyframe(1.0, duration: 0.36)\n                    SpringKeyframe(1.5, duration: 0.8, spring: .bouncy)\n                    SpringKeyframe(1.0, spring: .bouncy)\n                }\n                \n                KeyframeTrack(\\.verticalOffset) {\n                    LinearKeyframe(0.0, duration: 0.1)\n                    SpringKeyframe(20.0, duration: 0.15, spring: .bouncy)\n                    SpringKeyframe(-60.0, duration: 1.0, spring: .bouncy)\n                    SpringKeyframe(0.0, spring: .bouncy)\n                }\n\n\n                KeyframeTrack(\\.verticalStretch) {\n                    CubicKeyframe(1.0, duration: 0.1)\n                    CubicKeyframe(0.6, duration: 0.15)\n                    CubicKeyframe(1.5, duration: 0.1)\n                    CubicKeyframe(1.05, duration: 0.15)\n                    CubicKeyframe(1.0, duration: 0.88)\n                    CubicKeyframe(0.8, duration: 0.1)\n                    CubicKeyframe(1.04, duration: 0.4)\n                    CubicKeyframe(1.0, duration: 0.22)\n                }\n\n\n                KeyframeTrack(\\.angle) {\n                    CubicKeyframe(.zero, duration: 0.58)\n                    CubicKeyframe(.degrees(16), duration: 0.125)\n                    CubicKeyframe(.degrees(-16), duration: 0.125)\n                    CubicKeyframe(.degrees(16), duration: 0.125)\n                    CubicKeyframe(.zero, duration: 0.125)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n\n\nThe combination of these keyframe tracks creates an animation that squishes and stretches the emoji, before bouncing it upwards. As the emoji moves towards its peak, it grows larger. When the emoji reaches its peak, it gives a little wiggle. Then the emoji returns to its original location with a slight bounce as it settles back into its original position.\n\nPlay\n\nNote\n\nAs with phase animations, use the canvas preview in Xcode to help determine the animation types and values to apply for the keyframe animations. Make changes to the code and see those changes reflected in the canvas preview.\n\nSee Also\nCreating phase-based animation\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change continuously.\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change based on a trigger.\nstruct PhaseAnimator\nA container that animates its content by automatically cycling through a collection of phases that you provide, each defining a discrete step within an animation."
    },
    {
        "title": "withAnimation(_:completionCriteria:_:completion:)",
        "url": "https://developer.apple.com/documentation/swiftui/withanimation(_:completioncriteria:_:completion:)",
        "html": "Discussion\n\nThis function sets the given Animation as the animation property of the thread\u2019s current Transaction as well as calling Transaction/addAnimationCompletion with the specified completion.\n\nThe completion callback will always be fired exactly one time. If no animations are created by the changes in body, then the callback will be called immediately after body.\n\nSee Also\nAdding state-based animation to an action\nfunc withAnimation<Result>(Animation?, () throws -> Result) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation.\nstruct AnimationCompletionCriteria\nThe criteria that determines when an animation is considered finished.\nstruct Animation\nThe way a view changes over time to create a smooth visual transition from one state to another."
    },
    {
        "title": "animation(_:body:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/animation(_:body:)",
        "html": "Discussion\n\nAny modifiers applied to the content of body will be applied to this view, and the animation will only be used on the modifiers defined in the body.\n\nThe following code animates the opacity changing with an easeInOut animation, while the contents of MyView are animated with the implicit transaction\u2019s animation:\n\nMyView(isActive: isActive)\n    .animation(.easeInOut) { content in\n        content.opacity(isActive ? 1.0 : 0.0)\n    }\n\nSee Also\nAdding state-based animation to a view\nfunc animation(Animation?) -> some View\nApplies the given animation to this view when this view changes.\nAvailable when Self conforms to Equatable.\nfunc animation<V>(Animation?, value: V) -> some View\nApplies the given animation to this view when the specified value changes."
    },
    {
        "title": "animation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/binding/animation(_:)",
        "html": "Parameters\nanimation\n\nAn animation sequence performed when the binding value changes.\n\nReturn Value\n\nA new binding.\n\nSee Also\nManaging changes\nvar id: Value.ID\nThe stable identity of the entity associated with this instance, corresponding to the id of the binding\u2019s wrapped value.\nAvailable when Value conforms to Identifiable.\nfunc transaction(Transaction) -> Binding<Value>\nSpecifies a transaction for the binding.\nvar transaction: Transaction\nThe binding\u2019s transaction."
    },
    {
        "title": "animation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/animation(_:)-7mq1i",
        "html": "Parameters\nanimation\n\nThe animation to apply. If animation is nil, the view doesn\u2019t animate.\n\nReturn Value\n\nA view that applies animation to this view whenever it changes.\n\nSee Also\nAdding state-based animation to a view\nfunc animation<V>(Animation?, value: V) -> some View\nApplies the given animation to this view when the specified value changes.\nfunc animation<V>(Animation?, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given animation to all animatable values within the body closure."
    },
    {
        "title": "AnimationCompletionCriteria",
        "url": "https://developer.apple.com/documentation/swiftui/animationcompletioncriteria",
        "html": "Topics\nGetting the completion criteria\nstatic let logicallyComplete: AnimationCompletionCriteria\nThe animation has logically completed, but may still be in its long tail.\nstatic let removed: AnimationCompletionCriteria\nThe entire animation is finished and will now be removed.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nAdding state-based animation to an action\nfunc withAnimation<Result>(Animation?, () throws -> Result) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation.\nfunc withAnimation<Result>(Animation?, completionCriteria: AnimationCompletionCriteria, () throws -> Result, completion: () -> Void) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation, and runs the completion when all animations are complete.\nstruct Animation\nThe way a view changes over time to create a smooth visual transition from one state to another."
    },
    {
        "title": "CustomAnimation",
        "url": "https://developer.apple.com/documentation/swiftui/customanimation",
        "html": "Overview\n\nUse this protocol to create a type that changes an animatable value over time, which produces a custom visual transition of a view. For example, the follow code changes an animatable value using an elastic ease-in ease-out function:\n\nstruct ElasticEaseInEaseOutAnimation: CustomAnimation {\n    let duration: TimeInterval\n\n\n    func animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V? where V : VectorArithmetic {\n        if time > duration { return nil } // The animation has finished.\n\n\n        let p = time / duration\n        let s = sin((20 * p - 11.125) * ((2 * Double.pi) / 4.5))\n        if p < 0.5 {\n            return value.scaled(by: -(pow(2, 20 * p - 10) * s) / 2)\n        } else {\n            return value.scaled(by: (pow(2, -20 * p + 10) * s) / 2 + 1)\n        }\n    }\n}\n\n\nNote\n\nTo maintain state during the life span of a custom animation, use the state property available on the context parameter value. You can also use context\u2019s environment property to retrieve environment values from the view that created the custom animation. For more information, see AnimationContext.\n\nTo create an Animation instance of a custom animation, use the init(_:) initializer, passing in an instance of a custom animation; for example:\n\nAnimation(ElasticEaseInEaseOutAnimation(duration: 5.0))\n\n\nTo help make view code more readable, extend Animation and add a static property and function that returns an Animation instance of a custom animation. For example, the following code adds the static property elasticEaseInEaseOut that returns the elastic ease-in ease-out animation with a default duration of 0.35 seconds. Next, the code adds a method that returns the animation with a specified duration.\n\nextension Animation {\n    static var elasticEaseInEaseOut: Animation { elasticEaseInEaseOut(duration: 0.35) }\n    static func elasticEaseInEaseOut(duration: TimeInterval) -> Animation {\n        Animation(ElasticEaseInEaseOutAnimation(duration: duration))\n    }\n}\n\n\nTo animate a view with the elastic ease-in ease-out animation, a view calls either .elasticEaseInEaseOut or .elasticEaseInEaseOut(duration:). For example, the follow code includes an Animate button that, when clicked, animates a circle as it moves from one edge of the view to the other, using the elastic ease-in ease-out animation with a duration of 5 seconds:\n\nstruct ElasticEaseInEaseOutView: View {\n    @State private var isActive = false\n\n\n    var body: some View {\n        VStack(alignment: isActive ? .trailing : .leading) {\n            Circle()\n                .frame(width: 100.0)\n                .foregroundColor(.accentColor)\n\n\n            Button(\"Animate\") {\n                withAnimation(.elasticEaseInEaseOut(duration: 5.0)) {\n                    isActive.toggle()\n                }\n            }\n            .frame(maxWidth: .infinity)\n        }\n        .padding()\n    }\n}\n\nPlay\nTopics\nAnimating a value\nfunc animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V?\nCalculates the value of the animation at the specified time.\n\nRequired\n\nGetting the velocity\nfunc velocity<V>(value: V, time: TimeInterval, context: AnimationContext<V>) -> V?\nCalculates the velocity of the animation at a specified time.\n\nRequired Default implementation provided.\n\nDetermining whether to merge\nfunc shouldMerge<V>(previous: Animation, value: V, time: TimeInterval, context: inout AnimationContext<V>) -> Bool\nDetermines whether an instance of the animation can merge with other instance of the same type.\n\nRequired Default implementation provided.\n\nRelationships\nInherits From\nEquatable\nHashable\nSee Also\nCreating custom animations\nstruct AnimationContext\nContextual values that a custom animation can use to manage state and access a view\u2019s environment.\nstruct AnimationState\nA container that stores the state for a custom animation.\nprotocol AnimationStateKey\nA key for accessing animation state values.\nstruct UnitCurve\nA function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed.\nstruct Spring\nA representation of a spring\u2019s motion."
    },
    {
        "title": "MoveKeyframe",
        "url": "https://developer.apple.com/documentation/swiftui/movekeyframe",
        "html": "Topics\nCreating the keyframe\ninit(Value)\nCreates a new keyframe using the given value.\nRelationships\nConforms To\nKeyframeTrackContent\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "SymbolVariants",
        "url": "https://developer.apple.com/documentation/swiftui/symbolvariants",
        "html": "Overview\n\nMany of the SF Symbols that you can add to your app using an Image or a Label instance have common variants, like a filled version or a version that\u2019s contained within a circle. The symbol\u2019s name indicates the variant:\n\nVStack(alignment: .leading) {\n    Label(\"Default\", systemImage: \"heart\")\n    Label(\"Fill\", systemImage: \"heart.fill\")\n    Label(\"Circle\", systemImage: \"heart.circle\")\n    Label(\"Circle Fill\", systemImage: \"heart.circle.fill\")\n}\n\n\nYou can configure a part of your view hierarchy to use a particular variant for all symbols in that view and its child views using SymbolVariants. Add the symbolVariant(_:) modifier to a view to set a variant for that view\u2019s environment. For example, you can use the modifier to create the same set of labels as in the example above, using only the base name of the symbol in the label declarations:\n\nVStack(alignment: .leading) {\n    Label(\"Default\", systemImage: \"heart\")\n    Label(\"Fill\", systemImage: \"heart\")\n        .symbolVariant(.fill)\n    Label(\"Circle\", systemImage: \"heart\")\n        .symbolVariant(.circle)\n    Label(\"Circle Fill\", systemImage: \"heart\")\n        .symbolVariant(.circle.fill)\n}\n\n\nAlternatively, you can set the variant in the environment directly by passing the symbolVariants environment value to the environment(_:_:) modifier:\n\nLabel(\"Fill\", systemImage: \"heart\")\n    .environment(\\.symbolVariants, .fill)\n\n\nSwiftUI sets a variant for you in some environments. For example, SwiftUI automatically applies the fill symbol variant for items that appear in the content closure of the swipeActions(edge:allowsFullSwipe:content:) method, or as the tab bar items of a TabView.\n\nTopics\nGetting symbol variants\nstatic let none: SymbolVariants\nNo variant for a symbol.\nstatic let circle: SymbolVariants\nA variant that encapsulates the symbol in a circle.\nstatic let square: SymbolVariants\nA variant that encapsulates the symbol in a square.\nstatic let rectangle: SymbolVariants\nA variant that encapsulates the symbol in a rectangle.\nstatic let fill: SymbolVariants\nA variant that fills the symbol.\nstatic let slash: SymbolVariants\nA variant that draws a slash through the symbol.\nModifying a variant\nvar circle: SymbolVariants\nA version of the variant that\u2019s encapsulated in a circle.\nvar square: SymbolVariants\nA version of the variant that\u2019s encapsulated in a square.\nvar rectangle: SymbolVariants\nA version of the variant that\u2019s encapsulated in a rectangle.\nvar fill: SymbolVariants\nA filled version of the variant.\nvar slash: SymbolVariants\nA slashed version of the variant.\nComparing variants\nfunc contains(SymbolVariants) -> Bool\nReturns a Boolean value that indicates whether the current variant contains the specified variant.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nSetting a symbol variant\nfunc symbolVariant(SymbolVariants) -> some View\nMakes symbols within the view show a particular variant.\nvar symbolVariants: SymbolVariants\nThe symbol variant to use in this environment."
    },
    {
        "title": "Image.Orientation",
        "url": "https://developer.apple.com/documentation/swiftui/image/orientation",
        "html": "Overview\n\nMany image formats such as JPEG include orientation metadata in the image data. In other cases, you can specify image orientation in code. Properly specifying orientation is often important both for displaying the image and for certain kinds of image processing.\n\nIn SwiftUI, you provide an orientation value when initializing an Image from an existing CGImage.\n\nTopics\nGetting image orientations\ncase up\nA value that indicates the original pixel data matches the image\u2019s intended display orientation.\ncase down\nA value that indicates a 180\u00b0 rotation of the image from the orientation of its original pixel data.\ncase left\nA value that indicates a 90\u00b0 counterclockwise rotation from the orientation of its original pixel data.\ncase right\nA value that indicates a 90\u00b0 clockwise rotation of the image from the orientation of its original pixel data.\nGetting mirrored image orientation\ncase upMirrored\nA value that indicates a horizontal flip of the image from the orientation of its original pixel data.\ncase downMirrored\nA value that indicates a vertical flip of the image from the orientation of its original pixel data.\ncase leftMirrored\nA value that indicates a 90\u00b0 clockwise rotation and horizontal flip of the image from the orientation of its original pixel data.\ncase rightMirrored\nA value that indicates a 90\u00b0 counterclockwise rotation and horizontal flip from the orientation of its original pixel data.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nConfiguring an image\nFitting images into available space\nAdjust the size and shape of images in your app\u2019s user interface by applying view modifiers.\nfunc imageScale(Image.Scale) -> some View\nScales images within the view according to one of the relative sizes available including small, medium, and large images sizes.\nvar imageScale: Image.Scale\nThe image scale for this environment.\nenum Scale\nA scale to apply to vector images relative to text.\nenum ResizingMode\nThe modes that SwiftUI uses to resize an image to fit within its containing view."
    },
    {
        "title": "symbolVariant(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/symbolvariant(_:)",
        "html": "Parameters\nvariant\n\nThe variant to use for symbols. Use the values in SymbolVariants.\n\nReturn Value\n\nA view that applies the specified symbol variant or variants to itself and its child views.\n\nDiscussion\n\nWhen you want all the SF Symbols in a part of your app\u2019s user interface to use the same variant, use the symbolVariant(_:) modifier with a SymbolVariants value, like fill:\n\nVStack(spacing: 20) {\n    HStack(spacing: 20) {\n        Image(systemName: \"person\")\n        Image(systemName: \"folder\")\n        Image(systemName: \"gearshape\")\n        Image(systemName: \"list.bullet\")\n    }\n\n\n    HStack(spacing: 20) {\n        Image(systemName: \"person\")\n        Image(systemName: \"folder\")\n        Image(systemName: \"gearshape\")\n        Image(systemName: \"list.bullet\")\n    }\n    .symbolVariant(.fill) // Shows filled variants, when available.\n}\n\n\nA symbol that doesn\u2019t have the specified variant remains unaffected. In the example above, the list.bullet symbol doesn\u2019t have a filled variant, so the symbolVariant(_:) modifer has no effect.\n\nIf you apply the modifier more than once, its effects accumulate. Alternatively, you can apply multiple variants in one call:\n\nLabel(\"Airplane\", systemImage: \"airplane.circle.fill\")\n\n\nLabel(\"Airplane\", systemImage: \"airplane\")\n    .symbolVariant(.circle)\n    .symbolVariant(.fill)\n\n\nLabel(\"Airplane\", systemImage: \"airplane\")\n    .symbolVariant(.circle.fill)\n\n\nAll of the labels in the code above produce the same output:\n\nYou can apply all these variants in any order, but if you apply more than one shape variant, the one closest to the symbol takes precedence. For example, the following image uses the square shape:\n\nImage(systemName: \"arrow.left\")\n    .symbolVariant(.square) // This shape takes precedence.\n    .symbolVariant(.circle)\n    .symbolVariant(.fill)\n\n\nTo cause a symbol to ignore the variants currently in the environment, directly set the symbolVariants environment value to none using the environment(_:_:) modifer.\n\nSee Also\nSetting a symbol variant\nvar symbolVariants: SymbolVariants\nThe symbol variant to use in this environment.\nstruct SymbolVariants\nA variant of a symbol."
    },
    {
        "title": "symbolVariants",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/symbolvariants",
        "html": "Discussion\n\nYou set this environment value indirectly by using the symbolVariant(_:) view modifier. However, you access the environment variable directly using the environment(_:_:) modifier. Do this when you want to use the none variant to ignore the value that\u2019s already in the environment:\n\nHStack {\n    Image(systemName: \"heart\")\n    Image(systemName: \"heart\")\n        .environment(\\.symbolVariants, .none)\n}\n.symbolVariant(.fill)\n\n\nSee Also\nSetting a symbol variant\nfunc symbolVariant(SymbolVariants) -> some View\nMakes symbols within the view show a particular variant.\nstruct SymbolVariants\nA variant of a symbol."
    },
    {
        "title": "imageScale",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/imagescale",
        "html": "See Also\nConfiguring an image\nFitting images into available space\nAdjust the size and shape of images in your app\u2019s user interface by applying view modifiers.\nfunc imageScale(Image.Scale) -> some View\nScales images within the view according to one of the relative sizes available including small, medium, and large images sizes.\nenum Scale\nA scale to apply to vector images relative to text.\nenum Orientation\nThe orientation of an image.\nenum ResizingMode\nThe modes that SwiftUI uses to resize an image to fit within its containing view."
    },
    {
        "title": "imageScale(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/imagescale(_:)",
        "html": "Parameters\nscale\n\nOne of the relative sizes provided by the image scale enumeration.\n\nDiscussion\n\nThe example below shows the relative scaling effect. The system renders the image at a relative size based on the available space and configuration options of the image it is scaling.\n\nVStack {\n    HStack {\n        Image(systemName: \"heart.fill\")\n            .imageScale(.small)\n        Text(\"Small\")\n    }\n    HStack {\n        Image(systemName: \"heart.fill\")\n            .imageScale(.medium)\n        Text(\"Medium\")\n    }\n\n\n    HStack {\n        Image(systemName: \"heart.fill\")\n            .imageScale(.large)\n        Text(\"Large\")\n    }\n}\n\n\nSee Also\nConfiguring an image\nFitting images into available space\nAdjust the size and shape of images in your app\u2019s user interface by applying view modifiers.\nvar imageScale: Image.Scale\nThe image scale for this environment.\nenum Scale\nA scale to apply to vector images relative to text.\nenum Orientation\nThe orientation of an image.\nenum ResizingMode\nThe modes that SwiftUI uses to resize an image to fit within its containing view."
    },
    {
        "title": "AsyncImage",
        "url": "https://developer.apple.com/documentation/swiftui/asyncimage",
        "html": "Overview\n\nThis view uses the shared URLSession instance to load an image from the specified URL, and then display it. For example, you can display an icon that\u2019s stored on a server:\n\nAsyncImage(url: URL(string: \"https://example.com/icon.png\"))\n    .frame(width: 200, height: 200)\n\n\nUntil the image loads, the view displays a standard placeholder that fills the available space. After the load completes successfully, the view updates to display the image. In the example above, the icon is smaller than the frame, and so appears smaller than the placeholder.\n\nYou can specify a custom placeholder using init(url:scale:content:placeholder:). With this initializer, you can also use the content parameter to manipulate the loaded image. For example, you can add a modifier to make the loaded image resizable:\n\nAsyncImage(url: URL(string: \"https://example.com/icon.png\")) { image in\n    image.resizable()\n} placeholder: {\n    ProgressView()\n}\n.frame(width: 50, height: 50)\n\n\nFor this example, SwiftUI shows a ProgressView first, and then the image scaled to fit in the specified frame:\n\nImportant\n\nYou can\u2019t apply image-specific modifiers, like resizable(capInsets:resizingMode:), directly to an AsyncImage. Instead, apply them to the Image instance that your content closure gets when defining the view\u2019s appearance.\n\nTo gain more control over the loading process, use the init(url:scale:transaction:content:) initializer, which takes a content closure that receives an AsyncImagePhase to indicate the state of the loading operation. Return a view that\u2019s appropriate for the current phase:\n\nAsyncImage(url: URL(string: \"https://example.com/icon.png\")) { phase in\n    if let image = phase.image {\n        image // Displays the loaded image.\n    } else if phase.error != nil {\n        Color.red // Indicates an error.\n    } else {\n        Color.blue // Acts as a placeholder.\n    }\n}\n\nTopics\nLoading an image\ninit(url: URL?, scale: CGFloat)\nLoads and displays an image from the specified URL.\ninit<I, P>(url: URL?, scale: CGFloat, content: (Image) -> I, placeholder: () -> P)\nLoads and displays a modifiable image from the specified URL using a custom placeholder until the image loads.\nLoading an image in phases\ninit(url: URL?, scale: CGFloat, transaction: Transaction, content: (AsyncImagePhase) -> Content)\nLoads and displays a modifiable image from the specified URL in phases.\nRelationships\nConforms To\nView\nSee Also\nLoading images asynchronously\nenum AsyncImagePhase\nThe current phase of the asynchronous image loading operation."
    },
    {
        "title": "AsyncImagePhase",
        "url": "https://developer.apple.com/documentation/swiftui/asyncimagephase",
        "html": "Overview\n\nWhen you create an AsyncImage instance with the init(url:scale:transaction:content:) initializer, you define the appearance of the view using a content closure. SwiftUI calls the closure with a phase value at different points during the load operation to indicate the current state. Use the phase to decide what to draw. For example, you can draw the loaded image if it exists, a view that indicates an error, or a placeholder:\n\nAsyncImage(url: URL(string: \"https://example.com/icon.png\")) { phase in\n    if let image = phase.image {\n        image // Displays the loaded image.\n    } else if phase.error != nil {\n        Color.red // Indicates an error.\n    } else {\n        Color.blue // Acts as a placeholder.\n    }\n}\n\nTopics\nGetting load phases\ncase empty\nNo image is loaded.\ncase success(Image)\nAn image succesfully loaded.\ncase failure(Error)\nAn image failed to load with an error.\nGetting the image\nvar image: Image?\nThe loaded image, if any.\nGetting the error\nvar error: (Error)?\nThe error that occurred when attempting to load an image, if any.\nRelationships\nConforms To\nSendable\nSee Also\nLoading images asynchronously\nstruct AsyncImage\nA view that asynchronously loads and displays an image."
    },
    {
        "title": "Image.Scale",
        "url": "https://developer.apple.com/documentation/swiftui/image/scale",
        "html": "Overview\n\nUse this type with the imageScale(_:) modifier, or the imageScale environment key, to set the image scale.\n\nThe following example shows the three Scale values as applied to a system symbol image, each set against a text view:\n\nHStack { Image(systemName: \"swift\").imageScale(.small); Text(\"Small\") }\nHStack { Image(systemName: \"swift\").imageScale(.medium); Text(\"Medium\") }\nHStack { Image(systemName: \"swift\").imageScale(.large); Text(\"Large\") }\n\n\nTopics\nGetting image scales\ncase small\nA scale that produces small images.\ncase medium\nA scale that produces medium-sized images.\ncase large\nA scale that produces large images.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nConfiguring an image\nFitting images into available space\nAdjust the size and shape of images in your app\u2019s user interface by applying view modifiers.\nfunc imageScale(Image.Scale) -> some View\nScales images within the view according to one of the relative sizes available including small, medium, and large images sizes.\nvar imageScale: Image.Scale\nThe image scale for this environment.\nenum Orientation\nThe orientation of an image.\nenum ResizingMode\nThe modes that SwiftUI uses to resize an image to fit within its containing view."
    },
    {
        "title": "Image.ResizingMode",
        "url": "https://developer.apple.com/documentation/swiftui/image/resizingmode",
        "html": "Topics\nGetting resizing modes\ncase stretch\nA mode to enlarge or reduce the size of an image so that it fills the available space.\ncase tile\nA mode to repeat the image at its original size, as many times as necessary to fill the available space.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nConfiguring an image\nFitting images into available space\nAdjust the size and shape of images in your app\u2019s user interface by applying view modifiers.\nfunc imageScale(Image.Scale) -> some View\nScales images within the view according to one of the relative sizes available including small, medium, and large images sizes.\nvar imageScale: Image.Scale\nThe image scale for this environment.\nenum Scale\nA scale to apply to vector images relative to text.\nenum Orientation\nThe orientation of an image."
    },
    {
        "title": "transaction(value:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transaction(value:_:)",
        "html": "Parameters\nvalue\n\nA value to monitor for changes.\n\ntransform\n\nThe transformation to apply to transactions within this view.\n\nReturn Value\n\nA view that wraps this view and applies a transformation to all transactions used within the view whenever value changes.\n\nDiscussion\n\nUse this modifier to change or replace the animation used in a view. Consider three identical views controlled by a button that changes all three simultaneously:\n\nThe first view animates rotating the \u201cRotation\u201d Text view by 360 degrees.\n\nThe second uses the transaction(_:) modifier to change the animation by adding a delay to the start of the animation by two seconds and then increases the rotational speed of the \u201cRotation\\nModified\u201d Text view animation by a factor of 2.\n\nThe third uses the transaction(_:) modifier to disable animations affecting the \u201cAnimation\\nReplaced\u201d Text view.\n\nThe following code implements these animations:\n\nstruct TransactionExample: View {\n    @State var flag = false\n\n\n    var body: some View {\n        VStack(spacing: 50) {\n            HStack(spacing: 30) {\n                Text(\"Rotation\")\n                    .rotationEffect(Angle(degrees: flag ? 360 : 0))\n\n\n                Text(\"Rotation\\nModified\")\n                    .rotationEffect(Angle(degrees: flag ? 360 : 0))\n                    .transaction(value: flag) { t in\n                        t.animation =\n                            t.animation?.delay(2.0).speed(2)\n                    }\n\n\n                Text(\"Animation\\nReplaced\")\n                    .rotationEffect(Angle(degrees: flag ? 360 : 0))\n                    .transaction(value: flag) { t in\n                        t.disableAnimations = true\n                    }\n            }\n\n\n            Button(\"Animate\") {\n                withAnimation(.easeIn(duration: 2.0)) {\n                    flag.toggle()\n                }\n            }\n        }\n    }\n}\n\nSee Also\nMoving an animation to another view\nfunc withTransaction<Result>(Transaction, () throws -> Result) rethrows -> Result\nExecutes a closure with the specified transaction and returns the result.\nfunc withTransaction<R, V>(WritableKeyPath<Transaction, V>, V, () throws -> R) rethrows -> R\nExecutes a closure with the specified transaction key path and value and returns the result.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nstruct Transaction\nThe context of the current state-processing update.\nprotocol TransactionKey\nA key for accessing values in a transaction."
    },
    {
        "title": "PlaceholderContentView",
        "url": "https://developer.apple.com/documentation/swiftui/placeholdercontentview",
        "html": "Overview\n\nYou don\u2019t use this type directly. Instead SwiftUI creates this type on your behalf.\n\nRelationships\nConforms To\nView\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view."
    },
    {
        "title": "Transition",
        "url": "https://developer.apple.com/documentation/swiftui/transition",
        "html": "Overview\n\nA transition should generally be made by applying one or more modifiers to the content. For symmetric transitions, the isIdentity property on phase can be used to change the properties of modifiers. For asymmetric transitions, the phase itself can be used to change those properties. Transitions should not use any identity-affecting changes like .id, if, and switch on the content, since doing so would reset the state of the view they\u2019re applied to, causing wasted work and potentially surprising behavior when it appears and disappears.\n\nThe following code defines a transition that can be used to change the opacity and rotation when a view appears and disappears.\n\nstruct RotatingFadeTransition: Transition {\n    func body(content: Content, phase: TransitionPhase) -> some View {\n        content\n          .opacity(phase.isIdentity ? 1.0 : 0.0)\n          .rotationEffect(phase.rotation)\n    }\n}\nextension TransitionPhase {\n    fileprivate var rotation: Angle {\n        switch self {\n        case .willAppear: return .degrees(30)\n        case .identity: return .zero\n        case .didDisappear: return .degrees(-30)\n        }\n    }\n}\n\n\nSee Also: TransitionPhase\n\nSee Also: AnyTransition\n\nTopics\nGetting built-in transitions\nstatic var identity: IdentityTransition\nA transition that returns the input view, unmodified, as the output view.\nAvailable when Self is IdentityTransition.\nstatic func move(edge: Edge) -> Self\nReturns a transition that moves the view away, towards the specified edge of the view.\nAvailable when Self is MoveTransition.\nstatic func offset(CGSize) -> Self\nReturns a transition that offset the view by the specified amount.\nAvailable when Self is OffsetTransition.\nstatic func offset(x: CGFloat, y: CGFloat) -> Self\nReturns a transition that offset the view by the specified x and y values.\nAvailable when Self is OffsetTransition.\nstatic var opacity: OpacityTransition\nA transition from transparent to opaque on insertion, and from opaque to transparent on removal.\nAvailable when Self is OpacityTransition.\nstatic func push(from: Edge) -> Self\nCreates a transition that when added to a view will animate the view\u2019s insertion by moving it in from the specified edge while fading it in, and animate its removal by moving it out towards the opposite edge and fading it out.\nAvailable when Self is PushTransition.\nstatic var scale: ScaleTransition\nReturns a transition that scales the view.\nAvailable when Self is ScaleTransition.\nstatic func scale(Double, anchor: UnitPoint) -> Self\nReturns a transition that scales the view by the specified amount.\nAvailable when Self is ScaleTransition.\nstatic var slide: SlideTransition\nA transition that inserts by moving in from the leading edge, and removes by moving out towards the trailing edge.\nAvailable when Self is SlideTransition.\nstatic var symbolEffect: SymbolEffectTransition\nA transition that applies the default symbol effect transition to symbol images within the inserted or removed view hierarchy. Other views are unaffected by this transition.\nAvailable when Self is SymbolEffectTransition.\nstatic func symbolEffect<T>(T, options: SymbolEffectOptions) -> SymbolEffectTransition\nCreates a transition that applies the provided effect to symbol images within the inserted or removed view hierarchy. Other views are unaffected by this transition.\nAvailable when Self is SymbolEffectTransition.\nConfiguring a transition\nfunc animation(Animation?) -> some Transition\nAttaches an animation to this transition.\nstatic var properties: TransitionProperties\nReturns the properties this transition type has.\n\nRequired Default implementation provided.\n\nUsing a transition\nfunc apply<V>(content: V, phase: TransitionPhase) -> some View\nfunc combined<T>(with: T) -> some Transition\nCreating a custom transition\nfunc body(content: Self.Content, phase: TransitionPhase) -> Self.Body\nGets the current body of the caller.\n\nRequired\n\nassociatedtype Body : View\nThe type of view representing the body.\n\nRequired\n\ntypealias Content\nThe content view type passed to body().\nSupporting types\nstruct IdentityTransition\nA transition that returns the input view, unmodified, as the output view.\nstruct MoveTransition\nReturns a transition that moves the view away, towards the specified edge of the view.\nstruct OffsetTransition\nReturns a transition that offset the view by the specified amount.\nstruct OpacityTransition\nA transition from transparent to opaque on insertion, and from opaque to transparent on removal.\nstruct PushTransition\nA transition that when added to a view will animate the view\u2019s insertion by moving it in from the specified edge while fading it in, and animate its removal by moving it out towards the opposite edge and fading it out.\nstruct ScaleTransition\nReturns a transition that scales the view.\nstruct SlideTransition\nA transition that inserts by moving in from the leading edge, and removes by moving out towards the trailing edge.\nType Properties\nstatic var blurReplace: BlurReplaceTransition\nA transition that animates the insertion or removal of a view by combining blurring and scaling effects.\nAvailable when Self is BlurReplaceTransition.\nType Methods\nstatic func blurReplace(BlurReplaceTransition.Configuration) -> Self\nA transition that animates the insertion or removal of a view by combining blurring and scaling effects.\nAvailable when Self is BlurReplaceTransition.\nRelationships\nConforming Types\nAsymmetricTransition\nBlurReplaceTransition\nIdentityTransition\nMoveTransition\nOffsetTransition\nOpacityTransition\nPushTransition\nScaleTransition\nSlideTransition\nSymbolEffectTransition\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "AsymmetricTransition",
        "url": "https://developer.apple.com/documentation/swiftui/asymmetrictransition",
        "html": "Topics\nCreating the transition\ninit(insertion: Insertion, removal: Removal)\nCreates a composite Transition that uses a different transition for insertion versus removal.\nGetting transition properties\nvar insertion: Insertion\nThe Transition defining the insertion phase of self.\nvar removal: Removal\nThe Transition defining the removal phase of self.\nRelationships\nConforms To\nTransition\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "matchedGeometryEffect(id:in:properties:anchor:isSource:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/matchedgeometryeffect(id:in:properties:anchor:issource:)",
        "html": "Parameters\nid\n\nThe identifier, often derived from the identifier of the data being displayed by the view.\n\nnamespace\n\nThe namespace in which defines the id. New namespaces are created by adding an @Namespace variable to a View type and reading its value in the view\u2019s body method.\n\nproperties\n\nThe properties to copy from the source view.\n\nanchor\n\nThe relative location in the view used to produce its shared position value.\n\nisSource\n\nTrue if the view should be used as the source of geometry for other views in the group.\n\nReturn Value\n\nA new view that defines an entry in the global database of views synchronizing their geometry.\n\nDiscussion\n\nThis method sets the geometry of each view in the group from the inserted view with isSource = true (known as the \u201csource\u201d view), updating the values marked by properties.\n\nIf inserting a view in the same transaction that another view with the same key is removed, the system will interpolate their frame rectangles in window space to make it appear that there is a single view moving from its old position to its new position. The usual transition mechanisms define how each of the two views is rendered during the transition (e.g. fade in/out, scale, etc), the matchedGeometryEffect() modifier only arranges for the geometry of the views to be linked, not their rendering.\n\nIf the number of currently-inserted views in the group with isSource = true is not exactly one results are undefined, due to it not being clear which is the source view.\n\nSee Also\nSynchronizing geometries\nstruct MatchedGeometryProperties\nA set of view properties that may be synchronized between views using the View.matchedGeometryEffect() function.\nprotocol GeometryEffect\nAn effect that changes the visual appearance of a view, largely without changing its ancestors or descendants.\nstruct Namespace\nA dynamic property type that allows access to a namespace defined by the persistent identity of the object containing the property (e.g. a view).\nfunc geometryGroup() -> some View\nIsolates the geometry (e.g. position and size) of the view from its parent view."
    },
    {
        "title": "MatchedGeometryProperties",
        "url": "https://developer.apple.com/documentation/swiftui/matchedgeometryproperties",
        "html": "Topics\nMatching properties\nstatic let frame: MatchedGeometryProperties\nBoth the position and size properties.\nstatic let position: MatchedGeometryProperties\nThe view\u2019s position, in window coordinates.\nstatic let size: MatchedGeometryProperties\nThe view\u2019s size, in local coordinates.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nSynchronizing geometries\nfunc matchedGeometryEffect<ID>(id: ID, in: Namespace.ID, properties: MatchedGeometryProperties, anchor: UnitPoint, isSource: Bool) -> some View\nDefines a group of views with synchronized geometry using an identifier and namespace that you provide.\nprotocol GeometryEffect\nAn effect that changes the visual appearance of a view, largely without changing its ancestors or descendants.\nstruct Namespace\nA dynamic property type that allows access to a namespace defined by the persistent identity of the object containing the property (e.g. a view).\nfunc geometryGroup() -> some View\nIsolates the geometry (e.g. position and size) of the view from its parent view."
    },
    {
        "title": "GeometryEffect",
        "url": "https://developer.apple.com/documentation/swiftui/geometryeffect",
        "html": "Overview\n\nThe only change the effect makes to the view\u2019s ancestors and descendants is to change the coordinate transform to and from them.\n\nTopics\nApplying effects\nfunc effectValue(size: CGSize) -> ProjectionTransform\nReturns the current value of the effect.\n\nRequired\n\nfunc ignoredByLayout() -> _IgnoredByLayoutEffect<Self>\nReturns an effect that produces the same geometry transform as this effect, but only applies the transform while rendering its view.\nRelationships\nInherits From\nAnimatable\nViewModifier\nSee Also\nSynchronizing geometries\nfunc matchedGeometryEffect<ID>(id: ID, in: Namespace.ID, properties: MatchedGeometryProperties, anchor: UnitPoint, isSource: Bool) -> some View\nDefines a group of views with synchronized geometry using an identifier and namespace that you provide.\nstruct MatchedGeometryProperties\nA set of view properties that may be synchronized between views using the View.matchedGeometryEffect() function.\nstruct Namespace\nA dynamic property type that allows access to a namespace defined by the persistent identity of the object containing the property (e.g. a view).\nfunc geometryGroup() -> some View\nIsolates the geometry (e.g. position and size) of the view from its parent view."
    },
    {
        "title": "transition(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transition(_:)-2vjb8",
        "html": "Discussion\n\nWhen this view appears or disappears, the transition will be applied to it, allowing for animating it in and out.\n\nThe following code will conditionally show MyView, and when it appears or disappears, will use a custom RotatingFadeTransition transition to show it.\n\nif isActive {\n    MyView()\n        .transition(RotatingFadeTransition())\n}\nButton(\"Toggle\") {\n    withAnimation {\n        isActive.toggle()\n    }\n}\n\nSee Also\nDefining transitions\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "geometryGroup()",
        "url": "https://developer.apple.com/documentation/swiftui/view/geometrygroup()",
        "html": "Discussion\n\nBy default SwiftUI views push position and size changes down through the view hierarchy, so that only views that draw something (known as leaf views) apply the current animation to their frame rectangle. However in some cases this coalescing behavior can give undesirable results; inserting a geometry group can correct that. A group acts as a barrier between the parent view and its subviews, forcing the position and size values to be resolved and animated by the parent, before being passed down to each subview.\n\nThe example below shows one use of this function: ensuring that the member views of each row in the stack apply (and animate as) a single geometric transform from their ancestor view, rather than letting the effects of the ancestor views be applied separately to each leaf view. If the members of ItemView may be added and removed at different times the group ensures that they stay locked together as animations are applied.\n\nVStack {\n    ForEach(items) { item in\n        ItemView(item: item)\n            .geometryGroup()\n    }\n}\n\n\nReturns: a new view whose geometry is isolated from that of its parent view.\n\nSee Also\nSynchronizing geometries\nfunc matchedGeometryEffect<ID>(id: ID, in: Namespace.ID, properties: MatchedGeometryProperties, anchor: UnitPoint, isSource: Bool) -> some View\nDefines a group of views with synchronized geometry using an identifier and namespace that you provide.\nstruct MatchedGeometryProperties\nA set of view properties that may be synchronized between views using the View.matchedGeometryEffect() function.\nprotocol GeometryEffect\nAn effect that changes the visual appearance of a view, largely without changing its ancestors or descendants.\nstruct Namespace\nA dynamic property type that allows access to a namespace defined by the persistent identity of the object containing the property (e.g. a view)."
    },
    {
        "title": "TransitionProperties",
        "url": "https://developer.apple.com/documentation/swiftui/transitionproperties",
        "html": "Overview\n\nA transition can have properties that specify high level information about it. This can determine how a transition interacts with other features like Accessibility settings.\n\nSee Also: Transition\n\nTopics\nCreating the transition properties\ninit(hasMotion: Bool)\nvar hasMotion: Bool\nWhether the transition includes motion.\nRelationships\nConforms To\nSendable\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "Namespace",
        "url": "https://developer.apple.com/documentation/swiftui/namespace",
        "html": "Topics\nCreating a namespace\ninit()\nGetting the namespace\nvar wrappedValue: Namespace.ID\nstruct ID\nA namespace defined by the persistent identity of an @Namespace dynamic property.\nRelationships\nConforms To\nDynamicProperty\nSendable\nSee Also\nSynchronizing geometries\nfunc matchedGeometryEffect<ID>(id: ID, in: Namespace.ID, properties: MatchedGeometryProperties, anchor: UnitPoint, isSource: Bool) -> some View\nDefines a group of views with synchronized geometry using an identifier and namespace that you provide.\nstruct MatchedGeometryProperties\nA set of view properties that may be synchronized between views using the View.matchedGeometryEffect() function.\nprotocol GeometryEffect\nAn effect that changes the visual appearance of a view, largely without changing its ancestors or descendants.\nfunc geometryGroup() -> some View\nIsolates the geometry (e.g. position and size) of the view from its parent view."
    },
    {
        "title": "transition(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transition(_:)-5h5h0",
        "html": "Discussion\n\nWhen this view appears or disappears, the transition will be applied to it, allowing for animating it in and out.\n\nThe following code will conditionally show MyView, and when it appears or disappears, will use a slide transition to show it.\n\nif isActive {\n    MyView()\n        .transition(.slide)\n}\nButton(\"Toggle\") {\n    withAnimation {\n        isActive.toggle()\n    }\n}\n\nSee Also\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type."
    },
    {
        "title": "LabeledContentStyle",
        "url": "https://developer.apple.com/documentation/swiftui/labeledcontentstyle",
        "html": "Overview\n\nUse labeledContentStyle(_:) to set a style on a view.\n\nTopics\nGetting built-in labeled content styles\nstatic var automatic: AutomaticLabeledContentStyle\nA labeled content style that resolves its appearance automatically based on the current context.\nAvailable when Self is AutomaticLabeledContentStyle.\nCreating custom labeled content styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of labeled content.\n\nRequired\n\ntypealias Configuration\nThe properties of a labeled content instance.\nassociatedtype Body : View\nA view that represents the appearance and behavior of labeled content.\n\nRequired\n\nSupporting types\nstruct AutomaticLabeledContentStyle\nThe default labeled content style.\nRelationships\nConforming Types\nAutomaticLabeledContentStyle\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "ImageRenderer",
        "url": "https://developer.apple.com/documentation/swiftui/imagerenderer",
        "html": "Overview\n\nUse ImageRenderer to export bitmap image data from a SwiftUI view. You initialize the renderer with a view, then render images on demand, either by calling the render(rasterizationScale:renderer:) method, or by using the renderer\u2019s properties to create a CGImage, NSImage, or UIImage.\n\nBy drawing to a Canvas and exporting with an ImageRenderer, you can generate images from any progammatically-rendered content, like paths, shapes, gradients, and more. You can also render standard SwiftUI views like Text views, or containers of multiple view types.\n\nThe following example uses a private createAwardView(forUser:date:) method to create a game app\u2019s view of a trophy symbol with a user name and date. This view combines a Canvas that applies a shadow filter with two Text views into a VStack. A Button allows the person to save this view. The button\u2019s action uses an ImageRenderer to rasterize a CGImage and then calls a private uploadAchievementImage(_:) method to encode and upload the image.\n\nvar body: some View {\n    let trophyAndDate = createAwardView(forUser: playerName,\n                                         date: achievementDate)\n    VStack {\n        trophyAndDate\n        Button(\"Save Achievement\") {\n            let renderer = ImageRenderer(content: trophyAndDate)\n            if let image = renderer.cgImage {\n                uploadAchievementImage(image)\n            }\n        }\n    }\n}\n\n\nprivate func createAwardView(forUser: String, date: Date) -> some View {\n    VStack {\n        Image(systemName: \"trophy\")\n            .resizable()\n            .frame(width: 200, height: 200)\n            .frame(maxWidth: .infinity, maxHeight: .infinity)\n            .shadow(color: .mint, radius: 5)\n        Text(playerName)\n            .font(.largeTitle)\n        Text(achievementDate.formatted())\n    }\n    .multilineTextAlignment(.center)\n    .frame(width: 200, height: 290)\n}\n\n\nBecause ImageRenderer conforms to ObservableObject, you can use it to produce a stream of images as its properties change. Subscribe to the renderer\u2019s objectWillChange publisher, then use the renderer to rasterize a new image each time the subscriber receives an update.\n\nImportant\n\nImageRenderer output only includes views that SwiftUI renders, such as text, images, shapes, and composite views of these types. It does not render views provided by native platform frameworks (AppKit and UIKit) such as web views, media players, and some controls. For these views, ImageRenderer displays a placeholder image, similar to the behavior of drawingGroup(opaque:colorMode:).\n\nRendering to a PDF context\n\nThe render(rasterizationScale:renderer:) method renders the specified view to any CGContext. That means you aren\u2019t limited to creating a rasterized CGImage. For example, you can generate PDF data by rendering to a PDF context. The resulting PDF maintains resolution-independence for supported members of the view hierarchy, such as text, symbol images, lines, shapes, and fills.\n\nThe following example uses the createAwardView(forUser:date:) method from the previous example, and exports its contents as an 800-by-600 point PDF to the file URL renderURL. It uses the size parameter sent to the rendering closure to center the trophyAndDate view vertically and horizontally on the page.\n\nvar body: some View {\n    let trophyAndDate = createAwardView(forUser: playerName,\n                                        date: achievementDate)\n    VStack {\n        trophyAndDate\n        Button(\"Save Achievement\") {\n            let renderer = ImageRenderer(content: trophyAndDate)\n            renderer.render { size, renderer in\n                var mediaBox = CGRect(origin: .zero,\n                                      size: CGSize(width: 800, height: 600))\n                guard let consumer = CGDataConsumer(url: renderURL as CFURL),\n                      let pdfContext =  CGContext(consumer: consumer,\n                                                  mediaBox: &mediaBox, nil)\n                else {\n                    return\n                }\n                pdfContext.beginPDFPage(nil)\n                pdfContext.translateBy(x: mediaBox.size.width / 2 - size.width / 2,\n                                       y: mediaBox.size.height / 2 - size.height / 2)\n                renderer(pdfContext)\n                pdfContext.endPDFPage()\n                pdfContext.closePDF()\n            }\n        }\n    }\n}\n\nCreating an image from drawing instructions\n\nImageRenderer makes it possible to create a custom image by drawing into a Canvas, rendering a CGImage from it, and using that to initialize an Image. To simplify this process, use the Image initializer init(size:label:opaque:colorMode:renderer:), which takes a closure whose argument is a GraphicsContext that you can directly draw into.\n\nTopics\nCreating an image renderer\ninit(content: Content)\nCreates a renderer object with a source content view.\nProviding the source view\nvar content: Content\nThe root view rendered by this image renderer.\nAccessing renderer properties\nvar proposedSize: ProposedViewSize\nThe size proposed to the root view.\nvar scale: CGFloat\nThe scale at which to render the image.\nvar isOpaque: Bool\nA Boolean value that indicates whether the alpha channel of the image is fully opaque.\nvar colorMode: ColorRenderingMode\nThe working color space and storage format of the image.\nRendering images\nfunc render(rasterizationScale: CGFloat, renderer: (CGSize, (CGContext) -> Void) -> Void)\nDraws the renderer\u2019s current contents to an arbitrary Core Graphics context.\nvar cgImage: CGImage?\nThe current contents of the view, rasterized as a Core Graphics image.\nvar nsImage: NSImage?\nThe current contents of the view, rasterized as an AppKit image.\nvar uiImage: UIImage?\nThe current contents of the view, rasterized as a UIKit image.\nProducing a stream of images\nlet objectWillChange: PassthroughSubject<Void, Never>\nA publisher that informs subscribers of changes to the image.\nRelationships\nConforms To\nObservable\nObservableObject"
    },
    {
        "title": "LabeledContentStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/labeledcontentstyleconfiguration",
        "html": "Topics\nConfiguring the label\nlet label: LabeledContentStyleConfiguration.Label\nThe label of the labeled content instance.\nstruct Label\nA type-erased label of a labeled content instance.\nConfiguring the content\nlet content: LabeledContentStyleConfiguration.Content\nThe content of the labeled content instance.\nstruct Content\nA type-erased content of a labeled content instance.\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance.."
    },
    {
        "title": "glassBackgroundEffect(displayMode:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/glassbackgroundeffect(displaymode:)",
        "html": "Parameters\ndisplayMode\n\nWhen to display the glass background. The default is GlassBackgroundDisplayMode.always.\n\nReturn Value\n\nA view with a glass background.\n\nDiscussion\n\nUse this modifier to add a 3D glass background material that includes thickness, specularity, glass blur, shadows, and other effects. Because of its physical depth, the glass background influences z-axis layout.\n\nTo ensure that the effect renders properly when you add it to a collection of views in a ZStack, add the modifier to the stack rather to one of the views in the stack. This includes when you create an implicit stack with view modifiers like overlay(alignment:content:) or background(alignment:content:). In those cases, you might need to create an explicit ZStack inside the content closure to have a place to add the glass background modifier.\n\nSee Also\nAdding a glass background\nfunc glassBackgroundEffect<S>(in: S, displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material using a shape that you specify.\nBeta\nenum GlassBackgroundDisplayMode\nThe display mode of a glass background.\nBeta"
    },
    {
        "title": "TabViewStyle",
        "url": "https://developer.apple.com/documentation/swiftui/tabviewstyle",
        "html": "Topics\nGetting built-in tab view styles\nstatic var automatic: DefaultTabViewStyle\nThe default TabView style.\nAvailable when Self is DefaultTabViewStyle.\nstatic var carousel: CarouselTabViewStyle\nA style that implements the carousel interaction and appearance.\nAvailable when Self is CarouselTabViewStyle.\nDeprecated\nstatic var page: PageTabViewStyle\nA TabViewStyle that implements a paged scrolling TabView.\nAvailable when Self is PageTabViewStyle.\nstatic func page(indexDisplayMode: PageTabViewStyle.IndexDisplayMode) -> PageTabViewStyle\nA TabViewStyle that implements a paged scrolling TabView with an index display mode.\nAvailable when Self is PageTabViewStyle.\nstatic var verticalPage: VerticalPageTabViewStyle\nA TabViewStyle that implements the vertical page TabView interaction and appearance.\nAvailable when Self is VerticalPageTabViewStyle.\nstatic func verticalPage(transitionStyle: VerticalPageTabViewStyle.TransitionStyle) -> VerticalPageTabViewStyle\nA TabViewStyle that implements the vertical page TabView interaction and appearance, and performs the specified transition.\nAvailable when Self is VerticalPageTabViewStyle.\nSupporting types\nstruct DefaultTabViewStyle\nThe default TabView style.\nstruct CarouselTabViewStyle\nA style that implements the carousel interaction and appearance.\nDeprecated\nstruct PageTabViewStyle\nA TabViewStyle that implements a paged scrolling TabView.\nstruct VerticalPageTabViewStyle\nA TabViewStyle that implements the vertical TabView interaction and appearance.\nRelationships\nConforming Types\nCarouselTabViewStyle\nDefaultTabViewStyle\nPageTabViewStyle\nVerticalPageTabViewStyle\nSee Also\nStyling navigation views\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nprotocol NavigationSplitViewStyle\nA type that specifies the appearance and interaction of navigation split views within a view hierarchy.\nfunc tabViewStyle<S>(S) -> some View\nSets the style for the tab view within the current environment."
    },
    {
        "title": "presentedWindowToolbarStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentedwindowtoolbarstyle(_:)",
        "html": "See Also\nStyling windows from a view inside the window\nfunc presentedWindowStyle<S>(S) -> some View\nSets the style for windows created by interacting with this view."
    },
    {
        "title": "NavigationSplitViewStyle",
        "url": "https://developer.apple.com/documentation/swiftui/navigationsplitviewstyle",
        "html": "Overview\n\nTo configure the navigation split view style for a view hierarchy, use the navigationSplitViewStyle(_:) modifier.\n\nTopics\nCreating built-in styles\nstatic var automatic: AutomaticNavigationSplitViewStyle\nA navigation split style that resolves its appearance automatically based on the current context.\nAvailable when Self is AutomaticNavigationSplitViewStyle.\nstatic var balanced: BalancedNavigationSplitViewStyle\nA navigation split style that reduces the size of the detail content to make room when showing the leading column or columns.\nAvailable when Self is BalancedNavigationSplitViewStyle.\nstatic var prominentDetail: ProminentDetailNavigationSplitViewStyle\nA navigation split style that attempts to maintain the size of the detail content when hiding or showing the leading columns.\nAvailable when Self is ProminentDetailNavigationSplitViewStyle.\nCreating custom styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a navigation split view.\n\nRequired\n\ntypealias Configuration\nThe properties of a navigation split view instance.\nassociatedtype Body : View\nA view that represents the body of a navigation split view.\n\nRequired\n\nSupporting types\nstruct AutomaticNavigationSplitViewStyle\nA navigation split style that resolves its appearance automatically based on the current context.\nstruct BalancedNavigationSplitViewStyle\nA navigation split style that reduces the size of the detail content to make room when showing the leading column or columns.\nstruct ProminentDetailNavigationSplitViewStyle\nA navigation split style that attempts to maintain the size of the detail content when hiding or showing the leading columns.\nstruct NavigationSplitViewStyleConfiguration\nThe properties of a navigation split view instance.\nRelationships\nConforming Types\nAutomaticNavigationSplitViewStyle\nBalancedNavigationSplitViewStyle\nProminentDetailNavigationSplitViewStyle\nSee Also\nStyling navigation views\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc tabViewStyle<S>(S) -> some View\nSets the style for the tab view within the current environment.\nprotocol TabViewStyle\nA specification for the appearance and interaction of a TabView."
    },
    {
        "title": "TableStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/tablestyleconfiguration",
        "html": "See Also\nStyling collection views\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nprotocol ListStyle\nA protocol that describes the behavior and appearance of a list.\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view.\nprotocol TableStyle\nA type that applies a custom appearance to all tables within a view.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view.\nprotocol DisclosureGroupStyle\nA type that specifies the appearance and interaction of disclosure groups within a view hierarchy."
    },
    {
        "title": "listStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/liststyle(_:)",
        "html": "See Also\nCreating a list\nDisplaying data in lists\nVisualize collections of data with platform-appropriate appearance.\nstruct List\nA container that presents rows of data arranged in a single column, optionally providing the ability to select one or more members.\nstruct Section\nA container view that you can use to add hierarchy within certain views."
    },
    {
        "title": "navigationSplitViewStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationsplitviewstyle(_:)",
        "html": "Parameters\nstyle\n\nThe style to set.\n\nReturn Value\n\nA view that uses the specified navigation split view style.\n\nSee Also\nPresenting views in columns\nMigrating to new navigation types\nImprove navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.\nstruct NavigationSplitView\nA view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nstruct NavigationSplitViewVisibility\nThe visibility of the leading columns in a navigation split view.\nstruct NavigationLink\nA view that controls a navigation presentation."
    },
    {
        "title": "datePickerStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/datepickerstyle(_:)",
        "html": "See Also\nChoosing dates\nstruct DatePicker\nA control for selecting an absolute date.\nstruct MultiDatePicker\nA control for picking multiple dates.\nvar calendar: Calendar\nThe current calendar that views should use when handling dates.\nvar timeZone: TimeZone\nThe current time zone that views should use when handling dates."
    },
    {
        "title": "ListStyle",
        "url": "https://developer.apple.com/documentation/swiftui/liststyle",
        "html": "Topics\nGetting built-in list styles\nstatic var automatic: DefaultListStyle\nThe list style that describes a platform\u2019s default behavior and appearance for a list.\nAvailable when Self is DefaultListStyle.\nstatic var bordered: BorderedListStyle\nThe list style that describes the behavior and appearance of a list with standard border.\nAvailable when Self is BorderedListStyle.\nstatic var carousel: CarouselListStyle\nThe carousel list style.\nAvailable when Self is CarouselListStyle.\nstatic var elliptical: EllipticalListStyle\nThe list style that describes the behavior and appearance of an elliptical list.\nAvailable when Self is EllipticalListStyle.\nstatic var grouped: GroupedListStyle\nThe list style that describes the behavior and appearance of a grouped list.\nAvailable when Self is GroupedListStyle.\nstatic var inset: InsetListStyle\nThe list style that describes the behavior and appearance of an inset list.\nAvailable when Self is InsetListStyle.\nstatic var insetGrouped: InsetGroupedListStyle\nThe list style that describes the behavior and appearance of an inset grouped list.\nAvailable when Self is InsetGroupedListStyle.\nstatic var plain: PlainListStyle\nThe list style that describes the behavior and appearance of a plain list.\nAvailable when Self is PlainListStyle.\nstatic var sidebar: SidebarListStyle\nThe list style that describes the behavior and appearance of a sidebar list.\nAvailable when Self is SidebarListStyle.\nDeprecated styles\nstatic func bordered(alternatesRowBackgrounds: Bool) -> BorderedListStyle\nThe list style that describes the behavior and appearance of a list with standard border.\nAvailable when Self is BorderedListStyle.\nDeprecated\nstatic func inset(alternatesRowBackgrounds: Bool) -> InsetListStyle\nThe list style that describes the behavior and appearance of an inset list with optional alternating row backgrounds.\nAvailable when Self is InsetListStyle.\nDeprecated\nSupporting types\nstruct DefaultListStyle\nThe list style that describes a platform\u2019s default behavior and appearance for a list.\nstruct BorderedListStyle\nThe list style that describes the behavior and appearance of a list with standard border.\nstruct CarouselListStyle\nThe carousel list style.\nstruct EllipticalListStyle\nThe list style that describes the behavior and appearance of an elliptical list.\nstruct GroupedListStyle\nThe list style that describes the behavior and appearance of a grouped list.\nstruct InsetListStyle\nThe list style that describes the behavior and appearance of an inset list.\nstruct InsetGroupedListStyle\nThe list style that describes the behavior and appearance of an inset grouped list.\nstruct PlainListStyle\nThe list style that describes the behavior and appearance of a plain list.\nstruct SidebarListStyle\nThe list style that describes the behavior and appearance of a sidebar list.\nRelationships\nConforming Types\nBorderedListStyle\nCarouselListStyle\nDefaultListStyle\nEllipticalListStyle\nGroupedListStyle\nInsetGroupedListStyle\nInsetListStyle\nPlainListStyle\nSidebarListStyle\nSee Also\nStyling collection views\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view.\nprotocol TableStyle\nA type that applies a custom appearance to all tables within a view.\nstruct TableStyleConfiguration\nThe properties of a table.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view.\nprotocol DisclosureGroupStyle\nA type that specifies the appearance and interaction of disclosure groups within a view hierarchy."
    },
    {
        "title": "TableStyle",
        "url": "https://developer.apple.com/documentation/swiftui/tablestyle",
        "html": "Overview\n\nTo configure the current table style for a view hierarchy, use the tableStyle(_:) modifier.\n\nTopics\nGetting built-in table styles\nstatic var automatic: AutomaticTableStyle\nThe default table style in the current context.\nAvailable when Self is AutomaticTableStyle.\nstatic var inset: InsetTableStyle\nThe table style that describes the behavior and appearance of a table with its content and selection inset from the table edges.\nAvailable when Self is InsetTableStyle.\nstatic var bordered: BorderedTableStyle\nThe table style that describes the behavior and appearance of a table with standard border.\nAvailable when Self is BorderedTableStyle.\nCreating custom table styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a table.\n\nRequired\n\ntypealias Configuration\nThe properties of a table.\nassociatedtype Body : View\nA view that represents the body of a table.\n\nRequired\n\nDeprecated styles\nstatic func inset(alternatesRowBackgrounds: Bool) -> InsetTableStyle\nThe table style that describes the behavior and appearance of a table with its content and selection inset from the table edges.\nAvailable when Self is InsetTableStyle.\nDeprecated\nstatic func bordered(alternatesRowBackgrounds: Bool) -> BorderedTableStyle\nThe table style that describes the behavior and appearance of a table with standard border.\nAvailable when Self is BorderedTableStyle.\nDeprecated\nSupporting types\nstruct AutomaticTableStyle\nThe default table style in the current context.\nstruct InsetTableStyle\nThe table style that describes the behavior and appearance of a table with its content and selection inset from the table edges.\nstruct BorderedTableStyle\nThe table style that describes the behavior and appearance of a table with standard border.\nRelationships\nConforming Types\nAutomaticTableStyle\nBorderedTableStyle\nInsetTableStyle\nSee Also\nStyling collection views\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nprotocol ListStyle\nA protocol that describes the behavior and appearance of a list.\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view.\nstruct TableStyleConfiguration\nThe properties of a table.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view.\nprotocol DisclosureGroupStyle\nA type that specifies the appearance and interaction of disclosure groups within a view hierarchy."
    },
    {
        "title": "PickerStyle",
        "url": "https://developer.apple.com/documentation/swiftui/pickerstyle",
        "html": "Topics\nGetting built-in picker styles\nstatic var automatic: DefaultPickerStyle\nThe default picker style, based on the picker\u2019s context.\nAvailable when Self is DefaultPickerStyle.\nstatic var inline: InlinePickerStyle\nA PickerStyle where each option is displayed inline with other views in the current container.\nAvailable when Self is InlinePickerStyle.\nstatic var menu: MenuPickerStyle\nA picker style that presents the options as a menu when the user presses a button, or as a submenu when nested within a larger menu.\nAvailable when Self is MenuPickerStyle.\nstatic var navigationLink: NavigationLinkPickerStyle\nA picker style represented by a navigation link that presents the options by pushing a List-style picker view.\nAvailable when Self is NavigationLinkPickerStyle.\nstatic var palette: PalettePickerStyle\nA picker style that presents the options as a row of compact elements.\nAvailable when Self is PalettePickerStyle.\nstatic var radioGroup: RadioGroupPickerStyle\nA picker style that presents the options as a group of radio buttons.\nAvailable when Self is RadioGroupPickerStyle.\nstatic var segmented: SegmentedPickerStyle\nA picker style that presents the options in a segmented control.\nAvailable when Self is SegmentedPickerStyle.\nstatic var wheel: WheelPickerStyle\nA picker style that presents the options in a scrollable wheel that shows the selected option and a few neighboring options.\nAvailable when Self is WheelPickerStyle.\nSupporting types\nstruct DefaultPickerStyle\nThe default picker style, based on the picker\u2019s context.\nstruct InlinePickerStyle\nA PickerStyle where each option is displayed inline with other views in the current container.\nstruct MenuPickerStyle\nA picker style that presents the options as a menu when the user presses a button, or as a submenu when nested within a larger menu.\nstruct NavigationLinkPickerStyle\nA picker style represented by a navigation link that presents the options by pushing a List-style picker view.\nstruct PalettePickerStyle\nA picker style that presents the options as a row of compact elements.\nstruct RadioGroupPickerStyle\nA picker style that presents the options as a group of radio buttons.\nstruct SegmentedPickerStyle\nA picker style that presents the options in a segmented control.\nstruct WheelPickerStyle\nA picker style that presents the options in a scrollable wheel that shows the selected option and a few neighboring options.\nDeprecated styles\nstruct PopUpButtonPickerStyle\nA picker style that presents the options as a menu when the user presses a button.\nDeprecated\nRelationships\nConforming Types\nDefaultPickerStyle\nInlinePickerStyle\nMenuPickerStyle\nNavigationLinkPickerStyle\nPalettePickerStyle\nPopUpButtonPickerStyle\nRadioGroupPickerStyle\nSegmentedPickerStyle\nWheelPickerStyle\nSee Also\nStyling pickers\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nprotocol DatePickerStyle\nA type that specifies the appearance and interaction of all date pickers within a view hierarchy."
    },
    {
        "title": "PrimitiveButtonStyle",
        "url": "https://developer.apple.com/documentation/swiftui/primitivebuttonstyle",
        "html": "Overview\n\nTo configure the current button style for a view hierarchy, use the buttonStyle(_:) modifier. Specify a style that conforms to PrimitiveButtonStyle to create a button with custom interaction behavior. To create a button with the standard button interaction behavior defined for each platform, use ButtonStyle instead.\n\nTopics\nGetting built-in button styles\nstatic var automatic: DefaultButtonStyle\nThe default button style, based on the button\u2019s context.\nAvailable when Self is DefaultButtonStyle.\nstatic var accessoryBar: AccessoryBarButtonStyle\nA button style that is typically used in the context of an accessory toolbar (sometimes refererred to as a \u201cscope bar\u201d), for buttons that narrow the focus of a search or other operation.\nAvailable when Self is AccessoryBarButtonStyle.\nstatic var accessoryBarAction: AccessoryBarActionButtonStyle\nA button style that you use for extra actions in an accessory toolbar.\nAvailable when Self is AccessoryBarActionButtonStyle.\nstatic var bordered: BorderedButtonStyle\nA button style that applies standard border artwork based on the button\u2019s context.\nAvailable when Self is BorderedButtonStyle.\nstatic var borderedProminent: BorderedProminentButtonStyle\nA button style that applies standard border prominent artwork based on the button\u2019s context.\nAvailable when Self is BorderedProminentButtonStyle.\nstatic var borderless: BorderlessButtonStyle\nA button style that doesn\u2019t apply a border.\nAvailable when Self is BorderlessButtonStyle.\nstatic var card: CardButtonStyle\nA button style that doesn\u2019t pad the content, and applies a motion effect when a button has focus.\nAvailable when Self is CardButtonStyle.\nstatic var link: LinkButtonStyle\nA button style for buttons that emulate links.\nAvailable when Self is LinkButtonStyle.\nstatic var plain: PlainButtonStyle\nA button style that doesn\u2019t style or decorate its content while idle, but may apply a visual effect to indicate the pressed, focused, or enabled state of the button.\nAvailable when Self is PlainButtonStyle.\nCreating custom button styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a button.\n\nRequired\n\ntypealias Configuration\nThe properties of a button.\nassociatedtype Body : View\nA view that represents the body of a button.\n\nRequired\n\nSupporting types\nstruct DefaultButtonStyle\nThe default button style, based on the button\u2019s context.\nstruct AccessoryBarButtonStyle\nA button style that you use for actions in an accessory toolbar that narrow the focus of a search or other operation.\nstruct AccessoryBarActionButtonStyle\nA button style that you use for extra actions in an accessory toolbar.\nstruct BorderedButtonStyle\nA button style that applies standard border artwork based on the button\u2019s context.\nstruct BorderedProminentButtonStyle\nA button style that applies standard border prominent artwork based on the button\u2019s context.\nstruct BorderlessButtonStyle\nA button style that doesn\u2019t apply a border.\nstruct CardButtonStyle\nA button style that doesn\u2019t pad the content, and applies a motion effect when a button has focus.\nstruct LinkButtonStyle\nA button style for buttons that emulate links.\nstruct PlainButtonStyle\nA button style that doesn\u2019t style or decorate its content while idle, but may apply a visual effect to indicate the pressed, focused, or enabled state of the button.\nRelationships\nConforming Types\nAccessoryBarActionButtonStyle\nAccessoryBarButtonStyle\nBorderedButtonStyle\nBorderedProminentButtonStyle\nBorderlessButtonStyle\nCardButtonStyle\nDefaultButtonStyle\nLinkButtonStyle\nPlainButtonStyle\nSee Also\nStyling buttons\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nprotocol ButtonStyle\nA type that applies standard interaction behavior and a custom appearance to all buttons within a view hierarchy.\nstruct ButtonStyleConfiguration\nThe properties of a button.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nstruct PrimitiveButtonStyleConfiguration\nThe properties of a button.\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style)."
    },
    {
        "title": "pickerStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/pickerstyle(_:)",
        "html": "See Also\nChoosing from a set of options\nstruct Picker\nA control for selecting from a set of mutually exclusive values.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item.\nstruct PaletteSelectionEffect\nThe selection effect to apply to a palette item."
    },
    {
        "title": "signInWithAppleButtonStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/signinwithapplebuttonstyle(_:)",
        "html": "Parameters\nstyle\n\nThe sign in style to apply to this button.\n\nSee Also\nAuthorizing and authenticating\nvar authorizationController: AuthorizationController\nA value provided in the SwiftUI environment that views can use to perform authorization requests.\nvar webAuthenticationSession: WebAuthenticationSession\nA value provided in the SwiftUI environment that views can use to authenticate a user through a web service."
    },
    {
        "title": "buttonStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/buttonstyle(_:)-66fbx",
        "html": "Discussion\n\nUse this modifier to set a specific style for button instances within a view:\n\nHStack {\n    Button(\"Sign In\", action: signIn)\n    Button(\"Register\", action: register)\n}\n.buttonStyle(.bordered)\n\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "ButtonStyle",
        "url": "https://developer.apple.com/documentation/swiftui/buttonstyle",
        "html": "Overview\n\nTo configure the current button style for a view hierarchy, use the buttonStyle(_:) modifier. Specify a style that conforms to ButtonStyle when creating a button that uses the standard button interaction behavior defined for each platform. To create a button with custom interaction behavior, use PrimitiveButtonStyle instead.\n\nTopics\nCustom button styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a button.\n\nRequired\n\ntypealias Configuration\nThe properties of a button.\nassociatedtype Body : View\nA view that represents the body of a button.\n\nRequired\n\nSee Also\nStyling buttons\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nstruct ButtonStyleConfiguration\nThe properties of a button.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nprotocol PrimitiveButtonStyle\nA type that applies custom interaction behavior and a custom appearance to all buttons within a view hierarchy.\nstruct PrimitiveButtonStyleConfiguration\nThe properties of a button.\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style)."
    },
    {
        "title": "ButtonStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/buttonstyleconfiguration",
        "html": "Topics\nConfiguring a button\u2019s label\nlet label: ButtonStyleConfiguration.Label\nA view that describes the effect of pressing the button.\nstruct Label\nA type-erased label of a button.\nConfiguring a button\u2019s interaction state\nlet isPressed: Bool\nA Boolean that indicates whether the user is currently pressing the button.\nDefining the button\u2019s purpose\nlet role: ButtonRole?\nAn optional semantic role that describes the button\u2019s purpose.\nSee Also\nStyling buttons\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nprotocol ButtonStyle\nA type that applies standard interaction behavior and a custom appearance to all buttons within a view hierarchy.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nprotocol PrimitiveButtonStyle\nA type that applies custom interaction behavior and a custom appearance to all buttons within a view hierarchy.\nstruct PrimitiveButtonStyleConfiguration\nThe properties of a button.\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style)."
    },
    {
        "title": "buttonStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/buttonstyle(_:)-7qx1",
        "html": "Discussion\n\nUse this modifier to set a specific style for all button instances within a view:\n\nHStack {\n    Button(\"Sign In\", action: signIn)\n    Button(\"Register\", action: register)\n}\n.buttonStyle(.bordered)\n\n\nYou can also use this modifier to set the style for controls with a button style through composition:\n\nVStack {\n    Menu(\"Terms and Conditions\") {\n        Button(\"Open in Preview\", action: openInPreview)\n        Button(\"Save as PDF\", action: saveAsPDF)\n    }\n    Toggle(\"Remember Password\", isOn: $isToggleOn)\n    Toggle(\"Flag\", isOn: $flagged)\n    Button(\"Sign In\", action: signIn)\n}\n.menuStyle(.button)\n.toggleStyle(.button)\n.buttonStyle(.bordered)\n\n\nIn this example, .menuStyle(.button) says that the Terms and Conditions menu renders as a button, while .toggleStyle(.button) says that the two toggles also render as buttons. Finally, .buttonStyle(.bordered) says that the menu, both toggles, and the Sign In button all render with the bordered button style.```\n\nSee Also\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions."
    },
    {
        "title": "PrimitiveButtonStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/primitivebuttonstyleconfiguration",
        "html": "Topics\nConfiguring a button\u2019s label\nlet label: PrimitiveButtonStyleConfiguration.Label\nA view that describes the effect of calling the button\u2019s action.\nstruct Label\nA type-erased label of a button.\nInitiating a button\u2019s action\nfunc trigger()\nPerforms the button\u2019s action.\nDefining the button\u2019s purpose\nlet role: ButtonRole?\nAn optional semantic role describing the button\u2019s purpose.\nSee Also\nStyling buttons\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nprotocol ButtonStyle\nA type that applies standard interaction behavior and a custom appearance to all buttons within a view hierarchy.\nstruct ButtonStyleConfiguration\nThe properties of a button.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nprotocol PrimitiveButtonStyle\nA type that applies custom interaction behavior and a custom appearance to all buttons within a view hierarchy.\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style)."
    },
    {
        "title": "KeyframeTrackContentBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/keyframetrackcontentbuilder",
        "html": "Topics\nBuilding keyframe track content\nstatic func buildArray([some KeyframeTrackContent<Value>]) -> some KeyframeTrackContent<Value>\nstatic func buildBlock() -> some KeyframeTrackContent<Value>\nstatic func buildEither<First, Second>(first: First) -> KeyframeTrackContentBuilder<Value>.Conditional<Value, First, Second>\nstatic func buildEither<First, Second>(second: Second) -> KeyframeTrackContentBuilder<Value>.Conditional<Value, First, Second>\nstatic func buildExpression<K>(K) -> K\nstatic func buildPartialBlock(accumulated: some KeyframeTrackContent<Value>, next: some KeyframeTrackContent<Value>) -> some KeyframeTrackContent<Value>\nstatic func buildPartialBlock<K>(first: K) -> K\nstruct Conditional\nA conditional result from the result builder.\nAvailable when Value conforms to Animatable.\nSee Also\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value."
    },
    {
        "title": "equatable()",
        "url": "https://developer.apple.com/documentation/swiftui/view/equatable()",
        "html": "See Also\nManaging the view hierarchy\nfunc id<ID>(ID) -> some View\nBinds a view\u2019s identity to the given proxy value.\nfunc tag<V>(V) -> some View\nSets the unique tag value of this view."
    },
    {
        "title": "symbolEffect(_:options:isActive:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/symboleffect(_:options:isactive:)",
        "html": "Parameters\neffect\n\nA symbol effect to add to the view. Existing effects added by ancestors of the view are preserved, but may be overridden by the new effect. Added effects will be applied to the ``SwiftUI/Image` views contained by the child view.\n\nisActive\n\nwhether the effect is active or inactive.\n\nReturn Value\n\na copy of the view with a symbol effect added.\n\nDiscussion\n\nThe following example adds a repeating pulse effect to two symbol images:\n\nVStack {\n    Image(systemName: \"bolt.slash.fill\")\n    Image(systemName: \"folder.fill.badge.person.crop\")\n}\n.symbolEffect(.pulse)\n\nSee Also\nManaging symbol effects\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffectsRemoved(Bool) -> some View\nReturns a new view with its inherited symbol image effects either removed or left unchanged.\nstruct SymbolEffectTransition\nCreates a transition that applies the Appear or Disappear symbol animation to symbol images within the inserted or removed view hierarchy."
    },
    {
        "title": "symbolEffectsRemoved(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/symboleffectsremoved(_:)",
        "html": "Parameters\nisEnabled\n\nWhether to remove inherited symbol effects or not.\n\nReturn Value\n\na copy of the view with its symbol effects either removed or left unchanged.\n\nDiscussion\n\nThe following example adds a repeating pulse effect to two symbol images, but then disables the effect on one of them:\n\nVStack {\n    Image(systemName: \"bolt.slash.fill\") // does not pulse\n        .symbolEffectsRemoved()\n    Image(systemName: \"folder.fill.badge.person.crop\") // pulses\n}\n.symbolEffect(.pulse)\n\nSee Also\nManaging symbol effects\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> some View\nReturns a new view with a symbol effect added to it.\nstruct SymbolEffectTransition\nCreates a transition that applies the Appear or Disappear symbol animation to symbol images within the inserted or removed view hierarchy."
    },
    {
        "title": "EquatableView",
        "url": "https://developer.apple.com/documentation/swiftui/equatableview",
        "html": "Topics\nCreating an equatable view\ninit(content: Content)\nvar content: Content\nRelationships\nConforms To\nView\nSee Also\nSupporting view types\nstruct AnyView\nA type-erased view.\nstruct EmptyView\nA view that doesn\u2019t contain any content.\nstruct SubscriptionView\nA view that subscribes to a publisher with an action.\nstruct TupleView\nA View created from a swift tuple of View values."
    },
    {
        "title": "TupleView",
        "url": "https://developer.apple.com/documentation/swiftui/tupleview",
        "html": "Topics\nCreating a tuple view\ninit(T)\nvar value: T\nRelationships\nConforms To\nView\nSee Also\nSupporting view types\nstruct AnyView\nA type-erased view.\nstruct EmptyView\nA view that doesn\u2019t contain any content.\nstruct EquatableView\nA view type that compares itself against its previous value and prevents its child updating if its new value is the same as its old value.\nstruct SubscriptionView\nA view that subscribes to a publisher with an action."
    },
    {
        "title": "toggleStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/togglestyle(_:)",
        "html": "Parameters\nstyle\n\nThe toggle style to set. Use one of the built-in values, like switch or button, or a custom style that you define by creating a type that conforms to the ToggleStyle protocol.\n\nReturn Value\n\nA view that uses the specified toggle style for itself and its child views.\n\nDiscussion\n\nUse this modifier on a Toggle instance to set a style that defines the control\u2019s appearance and behavior. For example, you can choose the switch style:\n\nToggle(\"Vibrate on Ring\", isOn: $vibrateOnRing)\n    .toggleStyle(.switch)\n\n\nBuilt-in styles typically have a similar appearance across platforms, tailored to the platform\u2019s overall style:\n\nPlatform\n\n\t\n\nAppearance\n\n\n\n\niOS, iPadOS\n\n\t\n\n\n\n\nmacOS\n\n\t\n\nStyling toggles in a hierarchy\n\nYou can set a style for all toggle instances within a view hierarchy by applying the style modifier to a container view. For example, you can apply the button style to an HStack:\n\nHStack {\n    Toggle(isOn: $isFlagged) {\n        Label(\"Flag\", systemImage: \"flag.fill\")\n    }\n    Toggle(isOn: $isMuted) {\n        Label(\"Mute\", systemImage: \"speaker.slash.fill\")\n    }\n}\n.toggleStyle(.button)\n\n\nThe example above has the following appearance when isFlagged is true and isMuted is false:\n\nPlatform\n\n\t\n\nAppearance\n\n\n\n\niOS, iPadOS\n\n\t\n\n\n\n\nmacOS\n\n\t\n\nAutomatic styling\n\nIf you don\u2019t set a style, SwiftUI assumes a value of automatic, which corresponds to a context-specific default. Specify the automatic style explicitly to override a container\u2019s style and revert to the default:\n\nHStack {\n    Toggle(isOn: $isShuffling) {\n        Label(\"Shuffle\", systemImage: \"shuffle\")\n    }\n    Toggle(isOn: $isRepeating) {\n        Label(\"Repeat\", systemImage: \"repeat\")\n    }\n\n\n    Divider()\n\n\n    Toggle(\"Enhance Sound\", isOn: $isEnhanced)\n        .toggleStyle(.automatic) // Revert to the default style.\n}\n.toggleStyle(.button) // Use button style for toggles in the stack.\n.labelStyle(.iconOnly) // Omit the title from any labels.\n\n\nThe style that SwiftUI uses as the default depends on both the platform and the context. In macOS, the default in most contexts is a checkbox, while in iOS, the default toggle style is a switch:\n\nPlatform\n\n\t\n\nAppearance\n\n\n\n\niOS, iPadOS\n\n\t\n\n\n\n\nmacOS\n\n\t\n\nNote\n\nLike toggle style does for toggles, the labelStyle(_:) modifier sets the style for Label instances in the hierarchy. The example above demostrates the compact iconOnly style, which is useful for button toggles in space-constrained contexts. Always include a descriptive title for better accessibility.\n\nFor more information about how SwiftUI chooses a default toggle style, see the automatic style.\n\nSee Also\nGetting numeric inputs\nstruct Slider\nA control for selecting a value from a bounded linear range of values.\nstruct Stepper\nA control that performs increment and decrement actions.\nstruct Toggle\nA control that toggles between on and off states."
    },
    {
        "title": "unredacted()",
        "url": "https://developer.apple.com/documentation/swiftui/view/unredacted()",
        "html": "See Also\nRedacting private content\nfunc privacySensitive(Bool) -> some View\nMarks the view as containing sensitive, private user data.\nfunc redacted(reason: RedactionReasons) -> some View\nAdds a reason to apply a redaction to this view hierarchy.\nvar redactionReasons: RedactionReasons\nThe current redaction reasons applied to the view hierarchy.\nvar isSceneCaptured: Bool\nThe current capture state.\nstruct RedactionReasons\nThe reasons to apply a redaction to data displayed on screen."
    },
    {
        "title": "redactionReasons",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/redactionreasons",
        "html": "See Also\nRedacting private content\nfunc privacySensitive(Bool) -> some View\nMarks the view as containing sensitive, private user data.\nfunc redacted(reason: RedactionReasons) -> some View\nAdds a reason to apply a redaction to this view hierarchy.\nfunc unredacted() -> some View\nRemoves any reason to apply a redaction to this view hierarchy.\nvar isSceneCaptured: Bool\nThe current capture state.\nstruct RedactionReasons\nThe reasons to apply a redaction to data displayed on screen."
    },
    {
        "title": "preferredSurroundingsEffect(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/preferredsurroundingseffect(_:)",
        "html": "Discussion\n\nUse nil to indicate no preference. Note that the system might not be able to honor a specified preference.\n\nSee Also\nConfiguring passthrough\nstruct SurroundingsEffect\nBeta"
    },
    {
        "title": "FetchRequest",
        "url": "https://developer.apple.com/documentation/swiftui/fetchrequest",
        "html": "Overview\n\nUse a FetchRequest property wrapper to declare a FetchedResults property that provides a collection of Core Data managed objects to a SwiftUI view. The request infers the entity type from the Result placeholder type that you specify. Condition the request with an optional predicate and sort descriptors. For example, you can create a request to list all Quake managed objects that the Loading and Displaying a Large Data Feed sample code project defines to store earthquake data, sorted by their time property:\n\n@FetchRequest(sortDescriptors: [SortDescriptor(\\.time, order: .reverse)])\nprivate var quakes: FetchedResults<Quake> // Define Quake in your model.\n\n\nAlternatively, when you need more flexibility, you can initialize the request with a configured NSFetchRequest instance:\n\n@FetchRequest(fetchRequest: request)\nprivate var quakes: FetchedResults<Quake>\n\n\nAlways declare properties that have a fetch request wrapper as private. This lets the compiler help you avoid accidentally setting the property from the memberwise initializer of the enclosing view.\n\nThe fetch request and its results use the managed object context stored in the environment, which you can access using the managedObjectContext environment value. To support user interface activity, you typically rely on the viewContext property of a shared NSPersistentContainer instance. For example, you can set a context on your top level content view using a shared container that you define as part of your model:\n\nContentView()\n    .environment(\n        \\.managedObjectContext,\n        QuakesProvider.shared.container.viewContext)\n\n\nWhen you need to dynamically change the predicate or sort descriptors, access the request\u2019s FetchRequest.Configuration structure. To create a request that groups the fetched results according to a characteristic that they share, use SectionedFetchRequest instead.\n\nTopics\nCreating a fetch request\ninit(sortDescriptors: [SortDescriptor<Result>], predicate: NSPredicate?, animation: Animation?)\nCreates a fetch request based on a predicate and value type sort parameters.\nAvailable when Result inherits NSManagedObject.\ninit(sortDescriptors: [NSSortDescriptor], predicate: NSPredicate?, animation: Animation?)\nCreates a fetch request based on a predicate and reference type sort parameters.\nAvailable when Result inherits NSManagedObject.\ninit(entity: NSEntityDescription, sortDescriptors: [NSSortDescriptor], predicate: NSPredicate?, animation: Animation?)\nCreates a fetch request for a specified entity description, based on a predicate and sort parameters.\nAvailable when Result conforms to NSFetchRequestResult.\nCreating a fully configured fetch request\ninit(fetchRequest: NSFetchRequest<Result>, animation: Animation?)\nCreates a fully configured fetch request that uses the specified animation when updating results.\nAvailable when Result conforms to NSFetchRequestResult.\ninit(fetchRequest: NSFetchRequest<Result>, transaction: Transaction)\nCreates a fully configured fetch request that uses the specified transaction when updating results.\nAvailable when Result conforms to NSFetchRequestResult.\nConfiguring a request dynamically\nstruct Configuration\nThe request\u2019s configurable properties.\nvar projectedValue: Binding<FetchRequest<Result>.Configuration>\nA binding to the request\u2019s mutable configuration properties.\nGetting the fetched results\nfunc update()\nUpdates the fetched results.\nAvailable when Result conforms to NSFetchRequestResult.\nvar wrappedValue: FetchedResults<Result>\nThe fetched results of the fetch request.\nDefault Implementations\nDynamicProperty Implementations\nRelationships\nConforms To\nDynamicProperty\nConforms when Result conforms to NSFetchRequestResult.\nSee Also\nAccessing Core Data\nvar managedObjectContext: NSManagedObjectContext\nstruct FetchedResults\nA collection of results retrieved from a Core Data store.\nstruct SectionedFetchRequest\nA property wrapper type that retrieves entities, grouped into sections, from a Core Data persistent store.\nstruct SectionedFetchResults\nA collection of results retrieved from a Core Data persistent store, grouped into sections."
    },
    {
        "title": "overlayPreferenceValue(_:alignment:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/overlaypreferencevalue(_:alignment:_:)",
        "html": "Parameters\nkey\n\nThe preference key type whose value is to be read.\n\nalignment\n\nAn optional alignment to use when positioning the overlay view relative to the original view.\n\ntransform\n\nA function that produces the overlay view from the preference value read from the original view.\n\nReturn Value\n\nA view that layers a second view in front of the view.\n\nDiscussion\n\nThe values of the preference key from both views are combined and made visible to the parent view.\n\nSee Also\nGenerating backgrounds and overlays from preferences\nfunc backgroundPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc backgroundPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc overlayPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view."
    },
    {
        "title": "anchorPreference(key:value:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/anchorpreference(key:value:transform:)",
        "html": "Parameters\nkey\n\nthe preference key type.\n\nvalue\n\nthe geometry value in the current coordinate space.\n\ntransform\n\nthe function to produce the preference value.\n\nReturn Value\n\na new version of the view that writes the preference.\n\nSee Also\nSetting preferences based on geometry\nfunc transformAnchorPreference<A, K>(key: K.Type, value: Anchor<A>.Source, transform: (inout K.Value, Anchor<A>) -> Void) -> some View\nSets a value for the specified preference key, the value is a function of the key\u2019s current value and a geometry value tied to the current coordinate space, allowing readers of the value to convert the geometry to their local coordinates."
    },
    {
        "title": "hidden()",
        "url": "https://developer.apple.com/documentation/swiftui/view/hidden()",
        "html": "Return Value\n\nA hidden view.\n\nDiscussion\n\nHidden views are invisible and can\u2019t receive or respond to interactions. However, they do remain in the view hierarchy and affect layout. Use this modifier if you want to include a view for layout purposes, but don\u2019t want it to display.\n\nHStack {\n    Image(systemName: \"a.circle.fill\")\n    Image(systemName: \"b.circle.fill\")\n    Image(systemName: \"c.circle.fill\")\n        .hidden()\n    Image(systemName: \"d.circle.fill\")\n}\n\n\nThe third circle takes up space, because it\u2019s still present, but SwiftUI doesn\u2019t draw it onscreen.\n\nIf you want to conditionally include a view in the view hierarchy, use an if statement instead:\n\nVStack {\n    HStack {\n        Image(systemName: \"a.circle.fill\")\n        Image(systemName: \"b.circle.fill\")\n        if !isHidden {\n            Image(systemName: \"c.circle.fill\")\n        }\n        Image(systemName: \"d.circle.fill\")\n    }\n    Toggle(\"Hide\", isOn: $isHidden)\n}\n\n\nDepending on the current value of the isHidden state variable in the example above, controlled by the Toggle instance, SwiftUI draws the circle or completely omits it from the layout.\n\nSee Also\nHiding views\nfunc opacity(Double) -> some View\nSets the transparency of this view."
    },
    {
        "title": "labelsHidden()",
        "url": "https://developer.apple.com/documentation/swiftui/view/labelshidden()",
        "html": "Discussion\n\nUse this modifier when you want to omit a label from one or more controls in your user interface. For example, the first Toggle in the following example hides its label:\n\nVStack {\n    Toggle(isOn: $toggle1) {\n        Text(\"Toggle 1\")\n    }\n    .labelsHidden()\n\n\n    Toggle(isOn: $toggle2) {\n        Text(\"Toggle 2\")\n    }\n}\n\n\nThe VStack in the example above centers the first toggle\u2019s control element in the available space, while it centers the second toggle\u2019s combined label and control element:\n\nAlways provide a label for controls, even when you hide the label, because SwiftUI uses labels for other purposes, including accessibility.\n\nNote\n\nThis modifier doesn\u2019t work for all labels. It applies to labels that are separate from the rest of the control\u2019s interface, like they are for Toggle, but not to controls like a bordered button where the label is inside the button\u2019s border.\n\nSee Also\nHiding system elements\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view.\nfunc statusBarHidden(Bool) -> some View\nSets the visibility of the status bar.\nfunc persistentSystemOverlays(Visibility) -> some View\nSets the preferred visibility of the non-transient system views overlaying the app.\nenum Visibility\nThe visibility of a UI element, chosen automatically based on the platform, current context, and other factors."
    },
    {
        "title": "menuIndicator(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/menuindicator(_:)",
        "html": "Parameters\nvisibility\n\nThe menu indicator visibility to apply.\n\nDiscussion\n\nUse this modifier to override the default menu indicator visibility for controls in this view. For example, the code below creates a menu without an indicator:\n\nMenu {\n    ForEach(history , id: \\.self) { historyItem in\n        Button(historyItem.title) {\n            self.openURL(historyItem.url)\n        }\n    }\n} label: {\n    Label(\"Back\", systemImage: \"chevron.backward\")\n        .labelStyle(.iconOnly)\n} primaryAction: {\n    if let last = history.last {\n        self.openURL(last.url)\n    }\n}\n.menuIndicator(.hidden)\n\n\nNote\n\nOn tvOS, the standard button styles do not include a menu indicator, so this modifier will have no effect when using a built-in button style. You can implement an indicator in your own ButtonStyle implementation by checking the value of the menuIndicatorVisibility environment value.\n\nSee Also\nShowing a menu indicator\nvar menuIndicatorVisibility: Visibility\nThe menu indicator visibility to apply to controls within a view."
    },
    {
        "title": "help(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/help(_:)-4y7cy",
        "html": "Parameters\ntextKey\n\nThe key for the localized text to use as help.\n\nDiscussion\n\nAdding help to a view configures the view\u2019s accessibility hint and its tooltip (\u201chelp tag\u201d) on macOS. For more information on using help tags, see Help in the macOS Human Interface Guidelines.\n\nButton(action: composeMessage) {\n    Image(systemName: \"square.and.pencil\")\n}\n.help(\"Compose a new message\")\n\nSee Also\nProviding contextual help\nfunc help<S>(S) -> some View\nAdds help text to a view using a string that you provide.\nfunc help(Text) -> some View\nAdds help text to a view using a text view that you provide."
    },
    {
        "title": "help(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/help(_:)-6oiyb",
        "html": "Parameters\ntext\n\nThe text to use as help.\n\nDiscussion\n\nAdding help to a view configures the view\u2019s accessibility hint and its tooltip (\u201chelp tag\u201d) on macOS. For more information on using help tags, see Help in the macOS Human Interface Guidelines.\n\nImage(systemName: \"pin.circle\")\n    .foregroundColor(pointOfInterest.tintColor)\n    .help(pointOfInterest.name)\n\nSee Also\nProviding contextual help\nfunc help(LocalizedStringKey) -> some View\nAdds help text to a view using a localized string that you provide.\nfunc help(Text) -> some View\nAdds help text to a view using a text view that you provide."
    },
    {
        "title": "ColorScheme",
        "url": "https://developer.apple.com/documentation/swiftui/colorscheme",
        "html": "Overview\n\nYou receive a color scheme value when you read the colorScheme environment value. The value tells you if a light or dark appearance currently applies to the view. SwiftUI updates the value whenever the appearance changes, and redraws views that depend on the value. For example, the following Text view automatically updates when the user enables Dark Mode:\n\n@Environment(\\.colorScheme) private var colorScheme\n\n\nvar body: some View {\n    Text(colorScheme == .dark ? \"Dark\" : \"Light\")\n}\n\n\nSet a preferred appearance for a particular view hierarchy to override the user\u2019s Dark Mode setting using the preferredColorScheme(_:) view modifier.\n\nTopics\nGetting color schemes\ncase light\nThe color scheme that corresponds to a light appearance.\ncase dark\nThe color scheme that corresponds to a dark appearance.\nCreating a color scheme\ninit?(UIUserInterfaceStyle)\nCreates a color scheme from its user interface style equivalent.\nSupporting types\nstruct PreferredColorSchemeKey\nA key for specifying the preferred color scheme.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nDetecting and requesting the light or dark appearance\nfunc preferredColorScheme(ColorScheme?) -> some View\nSets the preferred color scheme for this presentation.\nvar colorScheme: ColorScheme\nThe color scheme of this environment."
    },
    {
        "title": "help(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/help(_:)-9lm7l",
        "html": "Parameters\ntext\n\nThe Text view to use as help.\n\nDiscussion\n\nAdding help to a view configures the view\u2019s accessibility hint and its help tag (also called a tooltip) in macOS or visionOS. For more information on using help tags, see Offering help in the Human Interface Guidelines.\n\nSlider(\"Opacity\", value: $selectedShape.opacity)\n    .help(Text(\"Adjust the opacity of the selected \\(selectedShape.name)\"))\n\nSee Also\nProviding contextual help\nfunc help(LocalizedStringKey) -> some View\nAdds help text to a view using a localized string that you provide.\nfunc help<S>(S) -> some View\nAdds help text to a view using a string that you provide."
    },
    {
        "title": "colorScheme",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/colorscheme",
        "html": "Discussion\n\nRead this environment value from within a view to find out if SwiftUI is currently displaying the view using the ColorScheme.light or ColorScheme.dark appearance. The value that you receive depends on whether the user has enabled Dark Mode, possibly superseded by the configuration of the current presentation\u2019s view hierarchy.\n\n@Environment(\\.colorScheme) private var colorScheme\n\n\nvar body: some View {\n    Text(colorScheme == .dark ? \"Dark\" : \"Light\")\n}\n\n\nYou can set the colorScheme environment value directly, but that usually isn\u2019t what you want. Doing so changes the color scheme of the given view and its child views but not the views above it in the view hierarchy. Instead, set a color scheme using the preferredColorScheme(_:) modifier, which also propagates the value up through the view hierarchy to the enclosing presentation, like a sheet or a window.\n\nWhen adjusting your app\u2019s user interface to match the color scheme, consider also checking the colorSchemeContrast property, which reflects a system-wide contrast setting that the user controls. For information about using color and contrast in your app, see Color and Contrast.\n\nNote\n\nIf you only need to provide different colors or images for different color scheme and contrast settings, do that in your app\u2019s Asset Catalog. See Asset management.\n\nSee Also\nDetecting and requesting the light or dark appearance\nfunc preferredColorScheme(ColorScheme?) -> some View\nSets the preferred color scheme for this presentation.\nenum ColorScheme\nThe possible color schemes, corresponding to the light and dark appearances."
    },
    {
        "title": "persistentSystemOverlays(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/persistentsystemoverlays(_:)",
        "html": "Parameters\nvisibility\n\nA value that indicates the visibility of the non-transient system views overlaying the app.\n\nDiscussion\n\nUse this modifier if you would like to customise the immersive experience of your app by hiding or showing system overlays that may affect user experience. The following example hides every persistent system overlay.\n\nstruct ImmersiveView: View {\n    var body: some View {\n        Text(\"Maximum immersion\")\n            .persistentSystemOverlays(.hidden)\n    }\n}\n\n\nNote that this modifier only sets a preference and, ultimately the system will decide if it will honour it or not.\n\nThese non-transient system views include:\n\nThe Home indicator\n\nThe SharePlay indicator\n\nThe Multi-task indicator and Picture-in-picture on iPad\n\nSee Also\nHiding system elements\nfunc labelsHidden() -> some View\nHides the labels of any controls contained within this view.\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view.\nfunc statusBarHidden(Bool) -> some View\nSets the visibility of the status bar.\nenum Visibility\nThe visibility of a UI element, chosen automatically based on the platform, current context, and other factors."
    },
    {
        "title": "Visibility",
        "url": "https://developer.apple.com/documentation/swiftui/visibility",
        "html": "Overview\n\nFor example, the preferred visibility of list row separators can be configured using the listRowSeparator(_:edges:).\n\nTopics\nGetting visibility options\ncase automatic\nThe element may be visible or hidden depending on the policies of the component accepting the visibility configuration.\ncase visible\nThe element may be visible.\ncase hidden\nThe element may be hidden.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nHiding system elements\nfunc labelsHidden() -> some View\nHides the labels of any controls contained within this view.\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view.\nfunc statusBarHidden(Bool) -> some View\nSets the visibility of the status bar.\nfunc persistentSystemOverlays(Visibility) -> some View\nSets the preferred visibility of the non-transient system views overlaying the app."
    },
    {
        "title": "statusBarHidden(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/statusbarhidden(_:)",
        "html": "Parameters\nhidden\n\nA Boolean value that indicates whether to hide the status bar.\n\nSee Also\nHiding system elements\nfunc labelsHidden() -> some View\nHides the labels of any controls contained within this view.\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view.\nfunc persistentSystemOverlays(Visibility) -> some View\nSets the preferred visibility of the non-transient system views overlaying the app.\nenum Visibility\nThe visibility of a UI element, chosen automatically based on the platform, current context, and other factors."
    },
    {
        "title": "glassBackgroundEffect(in:displayMode:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/glassbackgroundeffect(in:displaymode:)",
        "html": "Parameters\nshape\n\nAn InsettableShape instance that SwiftUI draws behind the view. Unsupported shapes resolve to a rectangle.\n\ndisplayMode\n\nWhen to display the glass background. The default is GlassBackgroundDisplayMode.always.\n\nReturn Value\n\nA view with a glass background.\n\nDiscussion\n\nUse this modifier to add a 3D glass background material that includes thickness, specularity, glass blur, shadows, and other effects. Because of its physical depth, the glass background influences z-axis layout.\n\nTo ensure that the effect renders properly when you add it to a collection of views in a ZStack, add the modifier to the stack rather to one of the views in the stack. This includes when you create an implicit stack with view modifiers like overlay(alignment:content:) or background(alignment:content:). In those cases, you might need to create an explicit ZStack inside the content closure to have a place to add the glass background modifier.\n\nPrefer a shape for the background that has rounded corners. An unsupported shape style resolves to a rectangle.\n\nSee Also\nAdding a glass background\nfunc glassBackgroundEffect(displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material that\u2019s shaped as a container-relative rounded rectangle.\nBeta\nenum GlassBackgroundDisplayMode\nThe display mode of a glass background.\nBeta"
    },
    {
        "title": "preferredColorScheme(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/preferredcolorscheme(_:)",
        "html": "Parameters\ncolorScheme\n\nThe preferred color scheme for this view.\n\nReturn Value\n\nA view that sets the color scheme.\n\nDiscussion\n\nUse one of the values in ColorScheme with this modifier to set a preferred color scheme for the nearest enclosing presentation, like a popover, a sheet, or a window. The value that you set overrides the user\u2019s Dark Mode selection for that presentation. In the example below, the Toggle controls an isDarkMode state variable, which in turn controls the color scheme of the sheet that contains the toggle:\n\n@State private var isPresented = false\n@State private var isDarkMode = true\n\n\nvar body: some View {\n    Button(\"Show Sheet\") {\n        isPresented = true\n    }\n    .sheet(isPresented: $isPresented) {\n        List {\n            Toggle(\"Dark Mode\", isOn: $isDarkMode)\n        }\n        .preferredColorScheme(isDarkMode ? .dark : .light)\n    }\n}\n\n\nIf you apply the modifier to any of the views in the sheet \u2014 which in this case are a List and a Toggle \u2014 the value that you set propagates up through the view hierarchy to the enclosing presentation, or until another color scheme modifier higher in the hierarchy overrides it. The value you set also flows down to all child views of the enclosing presentation.\n\nA common use for this modifier is to create side-by-side previews of the same view with light and dark appearances:\n\nstruct MyView_Previews: PreviewProvider {\n    static var previews: some View {\n        MyView().preferredColorScheme(.light)\n        MyView().preferredColorScheme(.dark)\n    }\n}\n\n\nIf you need to detect the color scheme that currently applies to a view, read the colorScheme environment value:\n\n@Environment(\\.colorScheme) private var colorScheme\n\n\nvar body: some View {\n    Text(colorScheme == .dark ? \"Dark\" : \"Light\")\n}\n\nSee Also\nDetecting and requesting the light or dark appearance\nvar colorScheme: ColorScheme\nThe color scheme of this environment.\nenum ColorScheme\nThe possible color schemes, corresponding to the light and dark appearances."
    },
    {
        "title": "disabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/disabled(_:)",
        "html": "Parameters\ndisabled\n\nA Boolean value that determines whether users can interact with this view.\n\nReturn Value\n\nA view that controls whether users can interact with this view.\n\nDiscussion\n\nThe higher views in a view hierarchy can override the value you set on this view. In the following example, the button isn\u2019t interactive because the outer disabled(_:) modifier overrides the inner one:\n\nHStack {\n    Button(Text(\"Press\")) {}\n    .disabled(false)\n}\n.disabled(true)\n\nSee Also\nManaging view interaction\nvar isEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows user interaction.\nfunc interactionActivityTrackingTag(String) -> some View\nSets a tag that you use for tracking interactivity.\nfunc invalidatableContent(Bool) -> some View\nMark the receiver as their content might be invalidated."
    },
    {
        "title": "interactionActivityTrackingTag(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/interactionactivitytrackingtag(_:)",
        "html": "Parameters\ntag\n\nThe tag used to track user interactions hosted by this view as activities.\n\nReturn Value\n\nA view that uses a tracking tag.\n\nDiscussion\n\nThe following example tracks the scrolling activity of a List:\n\nList {\n    Section(\"Today\") {\n        ForEach(messageStore.today) { message in\n            Text(message.title)\n        }\n    }\n}\n.interactionActivityTrackingTag(\"MessagesList\")\n\n\nThe resolved activity tracking tag is additive, so using the modifier across the view hierarchy builds the tag from top to bottom. The example below shows a hierarchical usage of this modifier with the resulting tag Home-Feed:\n\nvar body: some View {\n    Home()\n        .interactionActivityTrackingTag(\"Home\")\n}\n\n\nstruct Home: View {\n    var body: some View {\n        List {\n            Text(\"A List Item\")\n            Text(\"A Second List Item\")\n            Text(\"A Third List Item\")\n        }\n        .interactionActivityTrackingTag(\"Feed\")\n    }\n}\n\nSee Also\nManaging view interaction\nfunc disabled(Bool) -> some View\nAdds a condition that controls whether users can interact with this view.\nvar isEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows user interaction.\nfunc invalidatableContent(Bool) -> some View\nMark the receiver as their content might be invalidated."
    },
    {
        "title": "isEnabled",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/isenabled",
        "html": "Discussion\n\nThe default value is true.\n\nSee Also\nManaging view interaction\nfunc disabled(Bool) -> some View\nAdds a condition that controls whether users can interact with this view.\nfunc interactionActivityTrackingTag(String) -> some View\nSets a tag that you use for tracking interactivity.\nfunc invalidatableContent(Bool) -> some View\nMark the receiver as their content might be invalidated."
    },
    {
        "title": "invalidatableContent(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/invalidatablecontent(_:)",
        "html": "Parameters\ninvalidatable\n\nWhether the receiver content might be invalidated.\n\nDiscussion\n\nUse this modifier to annotate views that display values that are derived from the current state of your data and might be invalidated in response of, for example, user interaction.\n\nThe view will change its appearance when RedactionReasons.invalidated is present in the environment.\n\nIn an interactive widget a view is invalidated from the moment the user interacts with a control on the widget to the moment when a new timeline update has been presented.\n\nSee Also\nManaging view interaction\nfunc disabled(Bool) -> some View\nAdds a condition that controls whether users can interact with this view.\nvar isEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows user interaction.\nfunc interactionActivityTrackingTag(String) -> some View\nSets a tag that you use for tracking interactivity."
    },
    {
        "title": "colorSchemeContrast",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/colorschemecontrast",
        "html": "Discussion\n\nRead this environment value from within a view to find out if SwiftUI is currently displaying the view using ColorSchemeContrast.standard or ColorSchemeContrast.increased contrast. The value that you read depends entirely on user settings, and you can\u2019t change it.\n\n@Environment(\\.colorSchemeContrast) private var colorSchemeContrast\n\n\nvar body: some View {\n    Text(colorSchemeContrast == .standard ? \"Standard\" : \"Increased\")\n}\n\n\nWhen adjusting your app\u2019s user interface to match the contrast, consider also checking the colorScheme property to find out if SwiftUI is displaying the view with a light or dark appearance. For information about using color and contrast in your app, see Color and Contrast.\n\nNote\n\nIf you only need to provide different colors or images for different color scheme and contrast settings, do that in your app\u2019s Asset Catalog. See Asset management.\n\nSee Also\nGetting the color scheme contrast\nenum ColorSchemeContrast\nThe contrast between the app\u2019s foreground and background colors."
    },
    {
        "title": "IndexViewStyle",
        "url": "https://developer.apple.com/documentation/swiftui/indexviewstyle",
        "html": "Overview\n\nTo configure the current IndexViewStyle for a view hierarchy, use the .indexViewStyle() modifier.\n\nTopics\nGetting built-in index view styles\nstatic var page: PageIndexViewStyle\nAn index view style that places a page index view over its content.\nAvailable when Self is PageIndexViewStyle.\nstatic func page(backgroundDisplayMode: PageIndexViewStyle.BackgroundDisplayMode) -> PageIndexViewStyle\nAn index view style that places a page index view over its content.\nAvailable when Self is PageIndexViewStyle.\nSupporting types\nstruct PageIndexViewStyle\nAn index view style that places a page index view over its content.\nRelationships\nConforming Types\nPageIndexViewStyle\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "ControlGroupStyle",
        "url": "https://developer.apple.com/documentation/swiftui/controlgroupstyle",
        "html": "Overview\n\nTo configure the current ControlGroupStyle for a view hierarchy, use the controlGroupStyle(_:) modifier.\n\nTopics\nGetting built-in control group styles\nstatic var automatic: AutomaticControlGroupStyle\nThe default control group style.\nAvailable when Self is AutomaticControlGroupStyle.\nstatic var compactMenu: CompactMenuControlGroupStyle\nA control group style that presents its content as a compact menu when the user presses the control, or as a submenu when nested within a larger menu.\nAvailable when Self is CompactMenuControlGroupStyle.\nstatic var menu: MenuControlGroupStyle\nA control group style that presents its content as a menu when the user presses the control, or as a submenu when nested within a larger menu.\nAvailable when Self is MenuControlGroupStyle.\nstatic var navigation: NavigationControlGroupStyle\nThe navigation control group style.\nAvailable when Self is NavigationControlGroupStyle.\nstatic var palette: PaletteControlGroupStyle\nA control group style that presents its content as a palette.\nAvailable when Self is PaletteControlGroupStyle.\nCreating custom control group styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view representing the body of a control group.\n\nRequired\n\ntypealias Configuration\nThe properties of a ControlGroup instance being created.\nassociatedtype Body : View\nA view representing the body of a control group.\n\nRequired\n\nSupporting types\nstruct AutomaticControlGroupStyle\nThe default control group style.\nstruct CompactMenuControlGroupStyle\nA control group style that presents its content as a compact menu when the user presses the control, or as a submenu when nested within a larger menu.\nstruct MenuControlGroupStyle\nA control group style that presents its content as a menu when the user presses the control, or as a submenu when nested within a larger menu.\nstruct NavigationControlGroupStyle\nThe navigation control group style.\nstruct PaletteControlGroupStyle\nA control group style that presents its content as a palette.\nRelationships\nConforming Types\nAutomaticControlGroupStyle\nCompactMenuControlGroupStyle\nMenuControlGroupStyle\nNavigationControlGroupStyle\nPaletteControlGroupStyle\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "GroupBoxStyle",
        "url": "https://developer.apple.com/documentation/swiftui/groupboxstyle",
        "html": "Overview\n\nTo configure the current GroupBoxStyle for a view hierarchy, use the groupBoxStyle(_:) modifier.\n\nTopics\nGetting built-in group box styles\nstatic var automatic: DefaultGroupBoxStyle\nThe default style for group box views.\nAvailable when Self is DefaultGroupBoxStyle.\nCreating custom group box styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view representing the body of a group box.\n\nRequired\n\ntypealias Configuration\nThe properties of a group box instance.\nassociatedtype Body : View\nA view that represents the body of a group box.\n\nRequired\n\nSupporting types\nstruct DefaultGroupBoxStyle\nThe default style for group box views.\nRelationships\nConforming Types\nDefaultGroupBoxStyle\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "FormStyle",
        "url": "https://developer.apple.com/documentation/swiftui/formstyle",
        "html": "Overview\n\nTo configure the style for a single Form or for all form instances in a view hierarchy, use the formStyle(_:) modifier.\n\nTopics\nGetting built-in form styles\nstatic var automatic: AutomaticFormStyle\nThe default form style.\nAvailable when Self is AutomaticFormStyle.\nstatic var columns: ColumnsFormStyle\nA non-scrolling form style with a trailing aligned column of labels next to a leading aligned column of values.\nAvailable when Self is ColumnsFormStyle.\nstatic var grouped: GroupedFormStyle\nA form style with grouped rows.\nAvailable when Self is GroupedFormStyle.\nCreating custom form styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a form.\n\nRequired\n\ntypealias Configuration\nThe properties of a form instance.\nassociatedtype Body : View\nA view that represents the appearance and interaction of a form.\n\nRequired\n\nSupporting types\nstruct AutomaticFormStyle\nThe default form style.\nstruct ColumnsFormStyle\nA non-scrolling form style with a trailing aligned column of labels next to a leading aligned column of values.\nstruct GroupedFormStyle\nA form style with grouped rows.\nRelationships\nConforming Types\nAutomaticFormStyle\nColumnsFormStyle\nGroupedFormStyle\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "FormStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/formstyleconfiguration",
        "html": "Topics\nGetting configuration content\nlet content: FormStyleConfiguration.Content\nA view that is the content of the form.\nstruct Content\nA type-erased content of a form.\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "indexViewStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/indexviewstyle(_:)",
        "html": "Parameters\nstyle\n\nThe style to apply to this view.\n\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "ControlGroupStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/controlgroupstyleconfiguration",
        "html": "Topics\nConfiguring the label\nlet label: ControlGroupStyleConfiguration.Label\nA view that provides the optional label of the ControlGroup.\nstruct Label\nA type-erased label of a ControlGroup.\nConfiguring the content\nlet content: ControlGroupStyleConfiguration.Content\nA view that represents the content of the ControlGroup.\nstruct Content\nA type-erased content of a ControlGroup.\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "ColorSchemeContrast",
        "url": "https://developer.apple.com/documentation/swiftui/colorschemecontrast",
        "html": "Overview\n\nYou receive a contrast value when you read the colorSchemeContrast environment value. The value tells you if a standard or increased contrast currently applies to the view. SwiftUI updates the value whenever the contrast changes, and redraws views that depend on the value. For example, the following Text view automatically updates when the user enables increased contrast:\n\n@Environment(\\.colorSchemeContrast) private var colorSchemeContrast\n\n\nvar body: some View {\n    Text(colorSchemeContrast == .standard ? \"Standard\" : \"Increased\")\n}\n\n\nThe user sets the contrast by selecting the Increase Contrast option in Accessibility > Display in System Preferences on macOS, or Accessibility > Display & Text Size in the Settings app on iOS. Your app can\u2019t override the user\u2019s choice. For information about using color and contrast in your app, see Color and Contrast.\n\nTopics\nGetting contrast options\ncase standard\nSwiftUI displays views with standard contrast between the app\u2019s foreground and background colors.\ncase increased\nSwiftUI displays views with increased contrast between the app\u2019s foreground and background colors.\nCreating a color scheme contrast\ninit?(UIAccessibilityContrast)\nCreates a contrast from its accessibility contrast equivalent.\nRelationships\nConforms To\nCaseIterable\nEquatable\nHashable\nSendable\nSee Also\nGetting the color scheme contrast\nvar colorSchemeContrast: ColorSchemeContrast\nThe contrast associated with the color scheme of this environment."
    },
    {
        "title": "GroupBoxStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/groupboxstyleconfiguration",
        "html": "Topics\nConfiguring the label\nlet label: GroupBoxStyleConfiguration.Label\nA view that provides the title of the group box.\nstruct Label\nA type-erased label of a group box.\nConfiguring the content\nlet content: GroupBoxStyleConfiguration.Content\nA view that represents the content of the group box.\nstruct Content\nA type-erased content of a group box.\nSee Also\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance."
    },
    {
        "title": "Declaring a custom view",
        "url": "https://developer.apple.com/documentation/swiftui/declaring-a-custom-view",
        "html": "Overview\n\nSwiftUI offers a declarative approach to user interface design. With a traditional imperative approach, the burden is on your controller code not only to instantiate, lay out, and configure views, but also to continually make updates as conditions change. In contrast, with a declarative approach, you create a lightweight description of your user interface by declaring views in a hierarchy that mirrors the desired layout of your interface. SwiftUI then manages drawing and updating these views in response to events like user input or state changes.\n\nSwiftUI provides tools for defining and configuring the views in your user interface. You compose custom views out of built-in views that SwiftUI provides, plus other composite views that you\u2019ve already defined. You configure these views with view modifiers and connect them to your data model. You then place your custom views within your app\u2019s view hierarchy.\n\nConform to the view protocol\n\nDeclare a custom view type by defining a structure that conforms to the View protocol:\n\nstruct MyView: View {\n}\n\n\nLike other Swift protocols, the View protocol provides a blueprint for functionality \u2014 in this case, the behavior of an element that SwiftUI draws onscreen. Conformance to the protocol comes with both requirements that a view must fulfill, and functionality that the protocol provides. After you fulfill the requirements, you can insert your custom view into a view hierarchy so that it becomes part of your app\u2019s user interface.\n\nDeclare a body\n\nThe View protocol\u2019s main requirement is that conforming types must define a body computed property:\n\nstruct MyView: View {\n    var body: some View {\n    }\n}\n\n\nSwiftUI reads the value of this property any time it needs to update the view, which can happen repeatedly during the life of the view, typically in response to user input or system events. The value that the view returns is an element that SwiftUI draws onscreen.\n\nThe View protocol\u2019s secondary requirement is that conforming types must indicate an associated type for the body property. However, you don\u2019t make an explicit declaration. Instead, you declare the body property as an opaque type, using the some View syntax, to indicate only that the body\u2019s type conforms to View. The exact type depends on the body\u2019s content, which varies as you edit the body during development. Swift infers the exact type automatically.\n\nAssemble the view\u2019s content\n\nDescribe your view\u2019s appearance by adding content to the view\u2019s body property. You can compose the body from built-in views that SwiftUI provides, as well as custom views that you\u2019ve defined elsewhere. For example, you can create a body that draws the string \u201cHello, World!\u201d using a built-in Text view:\n\nstruct MyView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n    }\n}\n\n\nIn addition to views for specific kinds of content, controls, and indicators, like Text, Toggle, and ProgressView, SwiftUI also provides built-in views that you can use to arrange other views. For example, you can vertically stack two Text views using a VStack:\n\nstruct MyView: View {\n    var body: some View {\n        VStack {\n            Text(\"Hello, World!\")\n            Text(\"Glad to meet you.\")\n        }\n    }\n}\n\n\nViews that take multiple input child views, like the stack in the example above, typically do so using a closure marked with the ViewBuilder attribute. This enables a multiple-statement closure that doesn\u2019t require additional syntax at the call site. You only need to list the input views in succession.\n\nFor examples of views that contain other views, see Layout fundamentals.\n\nConfigure views with modifiers\n\nTo configure the views in your view\u2019s body, you apply view modifiers. A modifier is nothing more than a method called on a particular view. The method returns a new, altered view that effectively takes the place of the original in the view hierarchy.\n\nSwiftUI extends the View protocol with a large set of methods for this purpose. All View protocol conformers \u2014 both built-in and custom views \u2014 have access to these methods that alter the behavior of a view in some way. For example, you can change the font of a text view by applying the font(_:) modifier:\n\nstruct MyView: View {\n    var body: some View {\n        VStack {\n            Text(\"Hello, World!\")\n                .font(.title)\n            Text(\"Glad to meet you.\")\n        }\n    }\n}\n\n\nFor more information about how view modifiers work, and how to use them on your views, see Configuring views.\n\nManage data\n\nTo supply inputs to your views, add properties. For example, you can make the font of the \u201cHello, World!\u201d string configurable:\n\nstruct MyView: View {\n    let helloFont: Font\n    \n    var body: some View {\n        VStack {\n            Text(\"Hello, World!\")\n                .font(helloFont)\n            Text(\"Glad to meet you.\")\n        }\n    }\n}\n\n\nIf an input value changes, SwiftUI notices the change and redraws only the affected parts of your interface. This might involve reinitializing your entire view, but SwiftUI manages that for you.\n\nBecause the system may reinitialize a view at any time, it\u2019s important to avoid doing any significant work in your view\u2019s initialization code. It\u2019s often best to omit an explicit initializer, as in the example above, allowing Swift to synthesize a member-wise initializer instead.\n\nSwiftUI provides many tools to help you manage your app\u2019s data under these constraints, as described in Model data. For information about Swift initializers, see Initialization in The Swift Programming Language.\n\nAdd your view to the view hierarchy\n\nAfter you define a view, you can incorporate it in other views, just like you do with built-in views. You add your view by declaring it at the point in the hierarchy at which you want it to appear. For example, you could put MyView in your app\u2019s ContentView, which Xcode creates automatically as the root view of a new app:\n\nstruct ContentView: View {\n    var body: some View {\n        MyView(helloFont: .title)\n    }\n}\n\n\nAlternatively, you could add your view as the root view of a new scene in your app, like the Settings scene that declares content for a macOS preferences window, or a WKNotificationScene scene that declares the content for a watchOS notification. For more information about defining your app structure with SwiftUI, see App organization.\n\nSee Also\nCreating a view\nprotocol View\nA type that represents part of your app\u2019s user interface and provides modifiers that you use to configure views.\nstruct ViewBuilder\nA custom parameter attribute that constructs views from closures."
    },
    {
        "title": "groupBoxStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/groupboxstyle(_:)",
        "html": "Parameters\nstyle\n\nThe style to apply to boxes within this view.\n\nSee Also\nGrouping views into a box\nstruct GroupBox\nA stylized view, with an optional label, that visually collects a logical grouping of content."
    },
    {
        "title": "labeledContentStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/labeledcontentstyle(_:)",
        "html": "See Also\nGrouping inputs\nstruct Form\nA container for grouping controls used for data entry, such as in settings or inspectors.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nstruct LabeledContent\nA container for attaching a label to a value-bearing view."
    },
    {
        "title": "body",
        "url": "https://developer.apple.com/documentation/swiftui/view/body-8kl5o",
        "html": "Required Default implementations provided.\n\nDiscussion\n\nWhen you implement a custom view, you must implement a computed body property to provide the content for your view. Return a view that\u2019s composed of built-in views that SwiftUI provides, plus other composite views that you\u2019ve already defined:\n\nstruct MyView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n    }\n}\n\n\nFor more information about composing views and a view hierarchy, see Declaring a custom view.\n\nDefault Implementations\nView Implementations\nvar body: Never\nDeclares the content and behavior of this view.\nvar body: Never\nDeclares the content and behavior of this view.\nvar body: _ShapeView<Self, ForegroundStyle>\nThe content and behavior of the view.\nvar body: Never\nDeclares the content and behavior of this view.\nvar body: Never\nDeclares the content and behavior of this view.\nvar body: Never\nDeclares the content and behavior of this view.\nSee Also\nImplementing a custom view\nassociatedtype Body : View\nThe type of view representing the body of this view.\n\nRequired\n\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nPreviews in Xcode\nGenerate dynamic, interactive previews of your custom views."
    },
    {
        "title": "formStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/formstyle(_:)",
        "html": "Parameters\nstyle\n\nThe form style to set.\n\nReturn Value\n\nA view that uses the specified form style for itself and its child views.\n\nSee Also\nGrouping inputs\nstruct Form\nA container for grouping controls used for data entry, such as in settings or inspectors.\nstruct LabeledContent\nA container for attaching a label to a value-bearing view.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content."
    },
    {
        "title": "ViewBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/viewbuilder",
        "html": "Overview\n\nYou typically use ViewBuilder as a parameter attribute for child view-producing closure parameters, allowing those closures to provide multiple child views. For example, the following contextMenu function accepts a closure that produces one or more views via the view builder.\n\nfunc contextMenu<MenuItems: View>(\n    @ViewBuilder menuItems: () -> MenuItems\n) -> some View\n\n\nClients of this function can use multiple-statement closures to provide several child views, as shown in the following example:\n\nmyView.contextMenu {\n    Text(\"Cut\")\n    Text(\"Copy\")\n    Text(\"Paste\")\n    if isSymbol {\n        Text(\"Jump to Definition\")\n    }\n}\n\nTopics\nBuilding content\nstatic func buildBlock() -> EmptyView\nBuilds an empty view from a block containing no statements.\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single view written as a child view through unmodified.\nstatic func buildBlock<each Content>(repeat each Content) -> TupleView<(repeat each Content)>\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nConditionally building content\nstatic func buildEither<TrueContent, FalseContent>(first: TrueContent) -> _ConditionalContent<TrueContent, FalseContent>\nProduces content for a conditional statement in a multi-statement closure when the condition is true.\nstatic func buildEither<TrueContent, FalseContent>(second: FalseContent) -> _ConditionalContent<TrueContent, FalseContent>\nProduces content for a conditional statement in a multi-statement closure when the condition is false.\nstatic func buildIf<Content>(Content?) -> Content?\nProduces an optional view for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true.\nstatic func buildLimitedAvailability<Content>(Content) -> AnyView\nProcesses view content for a conditional compiler-control statement that performs an availability check.\nSee Also\nCreating a view\nDeclaring a custom view\nDefine views and assemble them into a view hierarchy.\nprotocol View\nA type that represents part of your app\u2019s user interface and provides modifiers that you use to configure views."
    },
    {
        "title": "TextEditorStyle",
        "url": "https://developer.apple.com/documentation/swiftui/texteditorstyle",
        "html": "Topics\nGetting built-in styles\nstatic var automatic: AutomaticTextEditorStyle\nThe default text editor style, based on the text editor\u2019s context.\nAvailable when Self is AutomaticTextEditorStyle.\nstatic var plain: PlainTextEditorStyle\nA text editor style with no decoration.\nAvailable when Self is PlainTextEditorStyle.\nstatic var roundedBorder: RoundedBorderTextEditorStyle\nA text editor style with a system-defined rounded border.\nAvailable when Self is RoundedBorderTextEditorStyle.\nBeta\nCreating custom styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a text editor.\n\nRequired\n\ntypealias Configuration\nThe properties of a text editor.\nassociatedtype Body : View\nA view that represents the body of a text editor.\n\nRequired\n\nSupporting types\nstruct AutomaticTextEditorStyle\nThe default text editor style, based on the text editor\u2019s context.\nstruct PlainTextEditorStyle\nA text editor style with no decoration.\nstruct RoundedBorderTextEditorStyle\nA text editor style with a system-defined rounded border.\nBeta\nRelationships\nConforming Types\nAutomaticTextEditorStyle\nPlainTextEditorStyle\nRoundedBorderTextEditorStyle\nSee Also\nStyling views that display text\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nprotocol LabelStyle\nA type that applies a custom appearance to all labels within a view.\nstruct LabelStyleConfiguration\nThe properties of a label.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nprotocol TextFieldStyle\nA specification for the appearance and interaction of a text field.\nfunc textEditorStyle(some TextEditorStyle) -> some View\nSets the style for text editors within this view.\nstruct TextEditorStyleConfiguration\nThe properties of a text editor."
    },
    {
        "title": "textEditorStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/texteditorstyle(_:)",
        "html": "See Also\nStyling views that display text\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nprotocol LabelStyle\nA type that applies a custom appearance to all labels within a view.\nstruct LabelStyleConfiguration\nThe properties of a label.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nprotocol TextFieldStyle\nA specification for the appearance and interaction of a text field.\nprotocol TextEditorStyle\nA specification for the appearance and interaction of a text editor.\nstruct TextEditorStyleConfiguration\nThe properties of a text editor."
    },
    {
        "title": "tableStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tablestyle(_:)",
        "html": "See Also\nCreating a table\nstruct Table\nA container that presents rows of data arranged in one or more columns, optionally providing the ability to select one or more members."
    },
    {
        "title": "LabelStyle",
        "url": "https://developer.apple.com/documentation/swiftui/labelstyle",
        "html": "Overview\n\nTo configure the current label style for a view hierarchy, use the labelStyle(_:) modifier.\n\nTopics\nGetting built-in label styles\nstatic var automatic: DefaultLabelStyle\nA label style that resolves its appearance automatically based on the current context.\nAvailable when Self is DefaultLabelStyle.\nstatic var iconOnly: IconOnlyLabelStyle\nA label style that only displays the icon of the label.\nAvailable when Self is IconOnlyLabelStyle.\nstatic var titleAndIcon: TitleAndIconLabelStyle\nA label style that shows both the title and icon of the label using a system-standard layout.\nAvailable when Self is TitleAndIconLabelStyle.\nstatic var titleOnly: TitleOnlyLabelStyle\nA label style that only displays the title of the label.\nAvailable when Self is TitleOnlyLabelStyle.\nCreating custom label styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a label.\n\nRequired\n\ntypealias Configuration\nThe properties of a label.\nassociatedtype Body : View\nA view that represents the body of a label.\n\nRequired\n\nSupporting types\nstruct DefaultLabelStyle\nThe default label style in the current context.\nstruct IconOnlyLabelStyle\nA label style that only displays the icon of the label.\nstruct TitleAndIconLabelStyle\nA label style that shows both the title and icon of the label using a system-standard layout.\nstruct TitleOnlyLabelStyle\nA label style that only displays the title of the label.\nRelationships\nConforming Types\nDefaultLabelStyle\nIconOnlyLabelStyle\nTitleAndIconLabelStyle\nTitleOnlyLabelStyle\nSee Also\nStyling views that display text\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nstruct LabelStyleConfiguration\nThe properties of a label.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nprotocol TextFieldStyle\nA specification for the appearance and interaction of a text field.\nfunc textEditorStyle(some TextEditorStyle) -> some View\nSets the style for text editors within this view.\nprotocol TextEditorStyle\nA specification for the appearance and interaction of a text editor.\nstruct TextEditorStyleConfiguration\nThe properties of a text editor."
    },
    {
        "title": "TextEditorStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/texteditorstyleconfiguration",
        "html": "See Also\nStyling views that display text\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nprotocol LabelStyle\nA type that applies a custom appearance to all labels within a view.\nstruct LabelStyleConfiguration\nThe properties of a label.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nprotocol TextFieldStyle\nA specification for the appearance and interaction of a text field.\nfunc textEditorStyle(some TextEditorStyle) -> some View\nSets the style for text editors within this view.\nprotocol TextEditorStyle\nA specification for the appearance and interaction of a text editor."
    },
    {
        "title": "Label",
        "url": "https://developer.apple.com/documentation/swiftui/label",
        "html": "Overview\n\nOne of the most common and recognizable user interface components is the combination of an icon and a label. This idiom appears across many kinds of apps and shows up in collections, lists, menus of action items, and disclosable lists, just to name a few.\n\nYou create a label, in its simplest form, by providing a title and the name of an image, such as an icon from the SF Symbols collection:\n\nLabel(\"Lightning\", systemImage: \"bolt.fill\")\n\n\nYou can also apply styles to labels in several ways. In the case of dynamic changes to the view after device rotation or change to a window size you might want to show only the text portion of the label using the titleOnly label style:\n\nLabel(\"Lightning\", systemImage: \"bolt.fill\")\n    .labelStyle(.titleOnly)\n\n\nConversely, there\u2019s also an icon-only label style:\n\nLabel(\"Lightning\", systemImage: \"bolt.fill\")\n    .labelStyle(.iconOnly)\n\n\nSome containers might apply a different default label style, such as only showing icons within toolbars on macOS and iOS. To opt in to showing both the title and the icon, you can apply the titleAndIcon label style:\n\nLabel(\"Lightning\", systemImage: \"bolt.fill\")\n    .labelStyle(.titleAndIcon)\n\n\nYou can also create a customized label style by modifying an existing style; this example adds a red border to the default label style:\n\nstruct RedBorderedLabelStyle: LabelStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        Label(configuration)\n            .border(Color.red)\n    }\n}\n\n\nFor more extensive customization or to create a completely new label style, you\u2019ll need to adopt the LabelStyle protocol and implement a LabelStyleConfiguration for the new style.\n\nTo apply a common label style to a group of labels, apply the style to the view hierarchy that contains the labels:\n\nVStack {\n    Label(\"Rain\", systemImage: \"cloud.rain\")\n    Label(\"Snow\", systemImage: \"snow\")\n    Label(\"Sun\", systemImage: \"sun.max\")\n}\n.labelStyle(.iconOnly)\n\n\nIt\u2019s also possible to make labels using views to compose the label\u2019s icon programmatically, rather than using a pre-made image. In this example, the icon portion of the label uses a filled Circle overlaid with the user\u2019s initials:\n\nLabel {\n    Text(person.fullName)\n        .font(.body)\n        .foregroundColor(.primary)\n    Text(person.title)\n        .font(.subheadline)\n        .foregroundColor(.secondary)\n} icon: {\n    Circle()\n        .fill(person.profileColor)\n        .frame(width: 44, height: 44, alignment: .center)\n        .overlay(Text(person.initials))\n}\n\nTopics\nCreating a label from text and an image\ninit(LocalizedStringKey, image: String)\nCreates a label with an icon image and a title generated from a localized string.\nAvailable when Title is Text and Icon is Image.\ninit<S>(S, image: String)\nCreates a label with an icon image and a title generated from a string.\nAvailable when Title is Text and Icon is Image.\nCreating a label from text and an SF Symbol\ninit(LocalizedStringKey, systemImage: String)\nCreates a label with a system icon image and a title generated from a localized string.\nAvailable when Title is Text and Icon is Image.\ninit<S>(S, systemImage: String)\nCreates a label with a system icon image and a title generated from a string.\nAvailable when Title is Text and Icon is Image.\nCreating a label from a title and icon\ninit(title: () -> Title, icon: () -> Icon)\nCreates a label with a custom title and icon.\nCreating a label from a configuration\ninit(LabelStyleConfiguration)\nCreates a label representing the configuration of a style.\nAvailable when Title is LabelStyleConfiguration.Title and Icon is LabelStyleConfiguration.Icon.\nCreating a label from an image resource\ninit(LocalizedStringKey, image: ImageResource)\nCreates a label with an icon image and a title generated from a localized string.\nAvailable when Title is Text and Icon is Image.\ninit<S>(S, image: ImageResource)\nCreates a label with an icon image and a title generated from a string.\nAvailable when Title is Text and Icon is Image.\nCreating a family activity label\ninit(ApplicationToken)\nCreates a label representing a family activity application.\nAvailable when Title is FamilyActivityTitleView and Icon is FamilyActivityIconView.\ninit(WebDomainToken)\nCreates a label representing a family activity web domain.\nAvailable when Title is FamilyActivityTitleView and Icon is FamilyActivityIconView.\ninit(ActivityCategoryToken)\nCreates a label representing a family activity category.\nAvailable when Title is FamilyActivityTitleView and Icon is FamilyActivityIconView.\nRelationships\nConforms To\nView\nSee Also\nDisplaying text\nstruct Text\nA view that displays one or more lines of read-only text.\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view."
    },
    {
        "title": "TextFieldStyle",
        "url": "https://developer.apple.com/documentation/swiftui/textfieldstyle",
        "html": "Topics\nGetting built-in text field styles\nstatic var automatic: DefaultTextFieldStyle\nThe default text field style, based on the text field\u2019s context.\nAvailable when Self is DefaultTextFieldStyle.\nstatic var plain: PlainTextFieldStyle\nA text field style with no decoration.\nAvailable when Self is PlainTextFieldStyle.\nstatic var roundedBorder: RoundedBorderTextFieldStyle\nA text field style with a system-defined rounded border.\nAvailable when Self is RoundedBorderTextFieldStyle.\nstatic var squareBorder: SquareBorderTextFieldStyle\nA text field style with a system-defined square border.\nAvailable when Self is SquareBorderTextFieldStyle.\nSupporting types\nstruct DefaultTextFieldStyle\nThe default text field style, based on the text field\u2019s context.\nstruct PlainTextFieldStyle\nA text field style with no decoration.\nstruct RoundedBorderTextFieldStyle\nA text field style with a system-defined rounded border.\nstruct SquareBorderTextFieldStyle\nA text field style with a system-defined square border.\nRelationships\nConforming Types\nDefaultTextFieldStyle\nPlainTextFieldStyle\nRoundedBorderTextFieldStyle\nSquareBorderTextFieldStyle\nSee Also\nStyling views that display text\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nprotocol LabelStyle\nA type that applies a custom appearance to all labels within a view.\nstruct LabelStyleConfiguration\nThe properties of a label.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nfunc textEditorStyle(some TextEditorStyle) -> some View\nSets the style for text editors within this view.\nprotocol TextEditorStyle\nA specification for the appearance and interaction of a text editor.\nstruct TextEditorStyleConfiguration\nThe properties of a text editor."
    },
    {
        "title": "LabelStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/labelstyleconfiguration",
        "html": "Topics\nSetting the icon\nvar icon: LabelStyleConfiguration.Icon\nA symbolic representation of the labeled item.\nstruct Icon\nA type-erased icon view of a label.\nSetting the title\nvar title: LabelStyleConfiguration.Title\nA description of the labeled item.\nstruct Title\nA type-erased title view of a label.\nSee Also\nStyling views that display text\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nprotocol LabelStyle\nA type that applies a custom appearance to all labels within a view.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nprotocol TextFieldStyle\nA specification for the appearance and interaction of a text field.\nfunc textEditorStyle(some TextEditorStyle) -> some View\nSets the style for text editors within this view.\nprotocol TextEditorStyle\nA specification for the appearance and interaction of a text editor.\nstruct TextEditorStyleConfiguration\nThe properties of a text editor."
    },
    {
        "title": "textFieldStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/textfieldstyle(_:)",
        "html": "See Also\nGetting text input\nstruct TextField\nA control that displays an editable text interface.\nstruct SecureField\nA control into which the user securely enters private text.\nstruct TextEditor\nA view that can display and edit long-form text."
    },
    {
        "title": "fileMover(isPresented:file:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:file:oncompletion:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\nfile\n\nThe URL of the file to be moved.\n\nonCompletion\n\nA callback that will be invoked when the operation has has succeeded or failed. To access the received URLs, call startAccessingSecurityScopedResource. When the access is no longer required, call stopAccessingSecurityScopedResource.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nNote\n\nThis interface provides security-scoped URLs. Call the startAccessingSecurityScopedResource method to access or bookmark the URLs, and the stopAccessingSecurityScopedResource method to release the access.\n\nIn order for the interface to appear, both isPresented must be true and file must not be nil. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nSee Also\nMoving a file\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move a collection of existing files to a new location.\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move a collection of existing files to a new location."
    },
    {
        "title": "task(id:priority:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/task(id:priority:_:)",
        "html": "Parameters\nid\n\nThe value to observe for changes. The value must conform to the Equatable protocol.\n\npriority\n\nThe task priority to use when creating the asynchronous task. The default priority is userInitiated.\n\naction\n\nA closure that SwiftUI calls as an asynchronous task before the view appears. SwiftUI can automatically cancel the task after the view disappears before the action completes. If the id value changes, SwiftUI cancels and restarts the task.\n\nReturn Value\n\nA view that runs the specified action asynchronously before the view appears, or restarts the task when the id value changes.\n\nDiscussion\n\nThis method behaves like task(priority:_:), except that it also cancels and recreates the task when a specified value changes. To detect a change, the modifier tests whether a new value for the id parameter equals the previous value. For this to work, the value\u2019s type must conform to the Equatable protocol.\n\nFor example, if you define an equatable Server type that posts custom notifications whenever its state changes \u2014 for example, from signed out to signed in \u2014 you can use the task modifier to update the contents of a Text view to reflect the state of the currently selected server:\n\nText(status ?? \"Signed Out\")\n    .task(id: server) {\n        let sequence = NotificationCenter.default.notifications(\n            named: .didUpdateStatus,\n            object: server\n        ).compactMap {\n            $0.userInfo?[\"status\"] as? String\n        }\n        for await value in sequence {\n            status = value\n        }\n    }\n\n\nThis example uses the notifications(named:object:) method to create an asynchronous sequence of notifications, given by an AsyncSequence instance. The example then maps the notification sequence to a sequence of strings that correspond to values stored with each notification.\n\nElsewhere, the server defines a custom didUpdateStatus notification:\n\nextension NSNotification.Name {\n    static var didUpdateStatus: NSNotification.Name {\n        NSNotification.Name(\"didUpdateStatus\")\n    }\n}\n\n\nWhenever the server status changes, like after the user signs in, the server posts a notification of this custom type:\n\nlet notification = Notification(\n    name: .didUpdateStatus,\n    object: self,\n    userInfo: [\"status\": \"Signed In\"])\nNotificationCenter.default.post(notification)\n\n\nThe task attached to the Text view gets and displays the status value from the notification\u2019s user information dictionary. When the user chooses a different server, SwiftUI cancels the task and creates a new one, which then waits for notifications from the new server.\n\nSee Also\nResponding to view life cycle updates\nfunc onAppear(perform: (() -> Void)?) -> some View\nAdds an action to perform before this view appears.\nfunc onDisappear(perform: (() -> Void)?) -> some View\nAdds an action to perform after this view disappears.\nfunc task(priority: TaskPriority, () async -> Void) -> some View\nAdds an asynchronous task to perform before this view appears."
    },
    {
        "title": "EnvironmentalModifier",
        "url": "https://developer.apple.com/documentation/swiftui/environmentalmodifier",
        "html": "Topics\nResolving a modifier\nfunc resolve(in: EnvironmentValues) -> Self.ResolvedModifier\nResolve to a concrete modifier in the given environment.\n\nRequired\n\nassociatedtype ResolvedModifier : ViewModifier\nThe type of modifier to use after being resolved.\n\nRequired\n\nRelationships\nInherits From\nViewModifier\nSee Also\nModifying a view\nConfiguring views\nAdjust the characteristics of a view by applying view modifiers.\nReducing view modifier maintenance\nBundle view modifiers that you regularly reuse into a custom view modifier.\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nprotocol ViewModifier\nA modifier that you apply to a view or another view modifier, producing a different version of the original value.\nstruct EmptyModifier\nAn empty, or identity, modifier, used during development to switch modifiers at compile time.\nstruct ModifiedContent\nA value with a modifier applied to it."
    },
    {
        "title": "onDisappear(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ondisappear(perform:)",
        "html": "Parameters\naction\n\nThe action to perform. If action is nil, the call has no effect.\n\nReturn Value\n\nA view that triggers action after it disappears.\n\nDiscussion\n\nThe exact moment that SwiftUI calls this method depends on the specific view type that you apply it to, but the action closure doesn\u2019t execute until the view disappears from the interface.\n\nSee Also\nResponding to view life cycle updates\nfunc onAppear(perform: (() -> Void)?) -> some View\nAdds an action to perform before this view appears.\nfunc task(priority: TaskPriority, () async -> Void) -> some View\nAdds an asynchronous task to perform before this view appears.\nfunc task<T>(id: T, priority: TaskPriority, () async -> Void) -> some View\nAdds a task to perform before this view appears or when a specified value changes."
    },
    {
        "title": "onAppear(perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onappear(perform:)",
        "html": "Parameters\naction\n\nThe action to perform. If action is nil, the call has no effect.\n\nReturn Value\n\nA view that triggers action before it appears.\n\nDiscussion\n\nThe exact moment that SwiftUI calls this method depends on the specific view type that you apply it to, but the action closure completes before the first rendered frame appears.\n\nSee Also\nResponding to view life cycle updates\nfunc onDisappear(perform: (() -> Void)?) -> some View\nAdds an action to perform after this view disappears.\nfunc task(priority: TaskPriority, () async -> Void) -> some View\nAdds an asynchronous task to perform before this view appears.\nfunc task<T>(id: T, priority: TaskPriority, () async -> Void) -> some View\nAdds a task to perform before this view appears or when a specified value changes."
    },
    {
        "title": "task(priority:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/task(priority:_:)",
        "html": "Parameters\npriority\n\nThe task priority to use when creating the asynchronous task. The default priority is userInitiated.\n\naction\n\nA closure that SwiftUI calls as an asynchronous task before the view appears. SwiftUI will automatically cancel the task at some point after the view disappears before the action completes.\n\nReturn Value\n\nA view that runs the specified action asynchronously before the view appears.\n\nDiscussion\n\nUse this modifier to perform an asynchronous task with a lifetime that matches that of the modified view. If the task doesn\u2019t finish before SwiftUI removes the view or the view changes identity, SwiftUI cancels the task.\n\nUse the await keyword inside the task to wait for an asynchronous call to complete, or to wait on the values of an AsyncSequence instance. For example, you can modify a Text view to start a task that loads content from a remote resource:\n\nlet url = URL(string: \"https://example.com\")!\n@State private var message = \"Loading...\"\n\n\nvar body: some View {\n    Text(message)\n        .task {\n            do {\n                var receivedLines = [String]()\n                for try await line in url.lines {\n                    receivedLines.append(line)\n                    message = \"Received \\(receivedLines.count) lines\"\n                }\n            } catch {\n                message = \"Failed to load\"\n            }\n        }\n}\n\n\nThis example uses the lines method to get the content stored at the specified URL as an asynchronous sequence of strings. When each new line arrives, the body of the for-await-in loop stores the line in an array of strings and updates the content of the text view to report the latest line count.\n\nSee Also\nResponding to view life cycle updates\nfunc onAppear(perform: (() -> Void)?) -> some View\nAdds an action to perform before this view appears.\nfunc onDisappear(perform: (() -> Void)?) -> some View\nAdds an action to perform after this view disappears.\nfunc task<T>(id: T, priority: TaskPriority, () async -> Void) -> some View\nAdds a task to perform before this view appears or when a specified value changes."
    },
    {
        "title": "id(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/id(_:)",
        "html": "Discussion\n\nWhen the proxy value specified by the id parameter changes, the identity of the view \u2014 for example, its state \u2014 is reset.\n\nSee Also\nManaging the view hierarchy\nfunc tag<V>(V) -> some View\nSets the unique tag value of this view.\nfunc equatable() -> EquatableView<Self>\nPrevents the view from updating its child view when its new value is the same as its old value.\nAvailable when Self conforms to Equatable."
    },
    {
        "title": "tag(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/tag(_:)",
        "html": "Parameters\ntag\n\nA Hashable value to use as the view\u2019s tag.\n\nReturn Value\n\nA view with the specified tag set.\n\nDiscussion\n\nUse this modifier to differentiate among certain selectable views, like the possible values of a Picker or the tabs of a TabView. Tag values can be of any type that conforms to the Hashable protocol.\n\nIn the example below, the ForEach loop in the Picker view builder iterates over the Flavor enumeration. It extracts the string value of each enumeration element for use in constructing the row label, and uses the enumeration value, cast as an optional, as input to the tag(_:) modifier. The Picker requires the tags to have a type that exactly matches the selection type, which in this case is an optional Flavor.\n\nstruct FlavorPicker: View {\n    enum Flavor: String, CaseIterable, Identifiable {\n        case chocolate, vanilla, strawberry\n        var id: Self { self }\n    }\n\n\n    @State private var selectedFlavor: Flavor? = nil\n\n\n    var body: some View {\n        Picker(\"Flavor\", selection: $selectedFlavor) {\n            ForEach(Flavor.allCases) { flavor in\n                Text(flavor.rawValue).tag(Optional(flavor))\n            }\n        }\n    }\n}\n\n\nIf you change selectedFlavor to be non-optional, you need to remove the Optional cast from the tag input to match.\n\nA ForEach automatically applies a default tag to each enumerated view using the id parameter of the corresponding element. If the element\u2019s id parameter and the picker\u2019s selection input have exactly the same type, you can omit the explicit tag modifier. To see examples that don\u2019t require an explicit tag, see Picker.\n\nSee Also\nManaging the view hierarchy\nfunc id<ID>(ID) -> some View\nBinds a view\u2019s identity to the given proxy value.\nfunc equatable() -> EquatableView<Self>\nPrevents the view from updating its child view when its new value is the same as its old value.\nAvailable when Self conforms to Equatable."
    },
    {
        "title": "AnyView",
        "url": "https://developer.apple.com/documentation/swiftui/anyview",
        "html": "Overview\n\nAn AnyView allows changing the type of view used in a given view hierarchy. Whenever the type of view used with an AnyView changes, the old hierarchy is destroyed and a new hierarchy is created for the new type.\n\nTopics\nCreating a view\ninit<V>(V)\nCreate an instance that type-erases view.\ninit<V>(erasing: V)\nRelationships\nConforms To\nView\nSee Also\nSupporting view types\nstruct EmptyView\nA view that doesn\u2019t contain any content.\nstruct EquatableView\nA view type that compares itself against its previous value and prevents its child updating if its new value is the same as its old value.\nstruct SubscriptionView\nA view that subscribes to a publisher with an action.\nstruct TupleView\nA View created from a swift tuple of View values."
    },
    {
        "title": "EmptyView",
        "url": "https://developer.apple.com/documentation/swiftui/emptyview",
        "html": "Overview\n\nYou will rarely, if ever, need to create an EmptyView directly. Instead, EmptyView represents the absence of a view.\n\nSwiftUI uses EmptyView in situations where a SwiftUI view type defines one or more child views with generic parameters, and allows the child views to be absent. When absent, the child view\u2019s type in the generic type parameter is EmptyView.\n\nThe following example creates an indeterminate ProgressView without a label. The ProgressView type declares two generic parameters, Label and CurrentValueLabel, for the types used by its subviews. When both subviews are absent, like they are here, the resulting type is ProgressView<EmptyView, EmptyView>, as indicated by the example\u2019s output:\n\nlet progressView = ProgressView()\nprint(\"\\(type(of:progressView))\")\n// Prints: ProgressView<EmptyView, EmptyView>\n\nTopics\nCreating an empty view\ninit()\nCreates an empty view.\nRelationships\nConforms To\nSendable\nView\nSee Also\nSupporting view types\nstruct AnyView\nA type-erased view.\nstruct EquatableView\nA view type that compares itself against its previous value and prevents its child updating if its new value is the same as its old value.\nstruct SubscriptionView\nA view that subscribes to a publisher with an action.\nstruct TupleView\nA View created from a swift tuple of View values."
    },
    {
        "title": "SubscriptionView",
        "url": "https://developer.apple.com/documentation/swiftui/subscriptionview",
        "html": "Topics\nCreating a subscription view\ninit(content: Content, publisher: PublisherType, action: (PublisherType.Output) -> Void)\nManaging the subscription\nvar publisher: PublisherType\nThe Publisher that is being subscribed.\nvar action: (PublisherType.Output) -> Void\nThe Action executed when publisher emits an event.\nvar content: Content\nThe content view.\nRelationships\nConforms To\nView\nSee Also\nSupporting view types\nstruct AnyView\nA type-erased view.\nstruct EmptyView\nA view that doesn\u2019t contain any content.\nstruct EquatableView\nA view type that compares itself against its previous value and prevents its child updating if its new value is the same as its old value.\nstruct TupleView\nA View created from a swift tuple of View values."
    },
    {
        "title": "SectionedFetchResults",
        "url": "https://developer.apple.com/documentation/swiftui/sectionedfetchresults",
        "html": "Overview\n\nUse a SectionedFetchResults instance to show or edit Core Data managed objects, grouped into sections, in your app\u2019s user interface. If you don\u2019t need sectioning, use FetchedResults instead.\n\nYou request a particular set of results by annotating the fetched results property declaration with a SectionedFetchRequest property wrapper. Indicate the type of the fetched entities with a Results type, and the type of the identifier that distinguishes the sections with a SectionIdentifier type. For example, you can create a request to list all Quake managed objects that the Loading and Displaying a Large Data Feed sample code project defines to store earthquake data, sorted by their time property and grouped by a string that represents the days when earthquakes occurred:\n\n@SectionedFetchRequest<String, Quake>(\n    sectionIdentifier: \\.day,\n    sortDescriptors: [SortDescriptor(\\.time, order: .reverse)]\n)\nprivate var quakes: SectionedFetchResults<String, Quake>\n\n\nThe quakes property acts as a collection of SectionedFetchResults.Section instances, each containing a collection of Quake instances. The example above depends on the Quake model object declaring both time and day properties, either stored or computed. For best performance with large data sets, use stored properties.\n\nThe collection of sections, as well as the collection of managed objects in each section, conforms to the RandomAccessCollection protocol, so you can access them as you would any other collection. For example, you can create nested ForEach loops inside a List to iterate over the results:\n\nList {\n    ForEach(quakes) { section in\n        Section(header: Text(section.id)) {\n            ForEach(section) { quake in\n                QuakeRow(quake: quake) // Displays information about a quake.\n            }\n        }\n    }\n}\n\n\nDon\u2019t confuse the Section view that you use to create a hierarchical display with the SectionedFetchResults.Section instances that hold the fetched results.\n\nWhen you need to dynamically change the request\u2019s section identifier, predicate, or sort descriptors, set the result instance\u2019s sectionIdentifier, nsPredicate, and sortDescriptors or nsSortDescriptors properties, respectively. Be sure that the sorting and sectioning work together to avoid discontinguous sections.\n\nThe fetch request and its results use the managed object context stored in the environment, which you can access using the managedObjectContext environment value. To support user interface activity, you typically rely on the viewContext property of a shared NSPersistentContainer instance. For example, you can set a context on your top-level content view using a container that you define as part of your model:\n\nContentView()\n    .environment(\n        \\.managedObjectContext,\n        QuakesProvider.shared.container.viewContext)\n\nTopics\nConfiguring the associated sectioned fetch request\nvar nsPredicate: NSPredicate?\nThe request\u2019s predicate.\nvar sortDescriptors: [SortDescriptor<Result>]\nThe request\u2019s sort descriptors, accessed as value types.\nAvailable when SectionIdentifier conforms to Hashable and Result inherits NSManagedObject.\nvar nsSortDescriptors: [NSSortDescriptor]\nThe request\u2019s sort descriptors, accessed as reference types.\nvar sectionIdentifier: KeyPath<Result, SectionIdentifier>\nThe key path that the system uses to group fetched results into sections.\nstruct Section\nA collection of fetched results that share a specified identifier.\nGetting indices\nvar startIndex: Int\nThe index of the first section in the results collection.\nvar endIndex: Int\nThe index that\u2019s one greater than that of the last section.\nGetting results\nsubscript(Int) -> SectionedFetchResults<SectionIdentifier, Result>.Section\nGets the section at the specified index.\nRelationships\nConforms To\nBidirectionalCollection\nCollection\nRandomAccessCollection\nSequence\nSee Also\nAccessing Core Data\nvar managedObjectContext: NSManagedObjectContext\nstruct FetchRequest\nA property wrapper type that retrieves entities from a Core Data persistent store.\nstruct FetchedResults\nA collection of results retrieved from a Core Data store.\nstruct SectionedFetchRequest\nA property wrapper type that retrieves entities, grouped into sections, from a Core Data persistent store."
    },
    {
        "title": "FetchedResults",
        "url": "https://developer.apple.com/documentation/swiftui/fetchedresults",
        "html": "Overview\n\nUse a FetchedResults instance to show or edit Core Data managed objects in your app\u2019s user interface. You request a particular set of results by specifying a Result type as the entity type, and annotating the fetched results property declaration with a FetchRequest property wrapper. For example, you can create a request to list all Quake managed objects that the Loading and Displaying a Large Data Feed sample code project defines to store earthquake data, sorted by their time property:\n\n@FetchRequest(sortDescriptors: [SortDescriptor(\\.time, order: .reverse)])\nprivate var quakes: FetchedResults<Quake>\n\n\nThe results instance conforms to RandomAccessCollection, so you access it like any other collection. For example, you can create a List that iterates over all the results:\n\nList(quakes) { quake in\n    NavigationLink(destination: QuakeDetail(quake: quake)) {\n        QuakeRow(quake: quake)\n    }\n}\n\n\nWhen you need to dynamically change the request\u2019s predicate or sort descriptors, set the result instance\u2019s nsPredicate and sortDescriptors or nsSortDescriptors properties, respectively.\n\nThe fetch request and its results use the managed object context stored in the environment, which you can access using the managedObjectContext environment value. To support user interface activity, you typically rely on the viewContext property of a shared NSPersistentContainer instance. For example, you can set a context on your top level content view using a container that you define as part of your model:\n\nContentView()\n    .environment(\n        \\.managedObjectContext,\n        QuakesProvider.shared.container.viewContext)\n\nTopics\nConfiguring the associated fetch request\nvar nsPredicate: NSPredicate?\nThe request\u2019s predicate.\nvar sortDescriptors: [SortDescriptor<Result>]\nThe request\u2019s sort descriptors, accessed as value types.\nAvailable when Result inherits NSManagedObject.\nvar nsSortDescriptors: [NSSortDescriptor]\nThe request\u2019s sort descriptors, accessed as reference types.\nGetting indices\nvar startIndex: Int\nThe index of the first entity in the results collection.\nvar endIndex: Int\nThe index that\u2019s one greater than the last valid subscript argument.\nGetting results\nsubscript(Int) -> Result\nGets the entity at the specified index.\nRelationships\nConforms To\nBidirectionalCollection\nCollection\nRandomAccessCollection\nSequence\nSee Also\nAccessing Core Data\nvar managedObjectContext: NSManagedObjectContext\nstruct FetchRequest\nA property wrapper type that retrieves entities from a Core Data persistent store.\nstruct SectionedFetchRequest\nA property wrapper type that retrieves entities, grouped into sections, from a Core Data persistent store.\nstruct SectionedFetchResults\nA collection of results retrieved from a Core Data persistent store, grouped into sections."
    },
    {
        "title": "SectionedFetchRequest",
        "url": "https://developer.apple.com/documentation/swiftui/sectionedfetchrequest",
        "html": "Overview\n\nUse a SectionedFetchRequest property wrapper to declare a SectionedFetchResults property that provides a grouped collection of Core Data managed objects to a SwiftUI view. If you don\u2019t need sectioning, use FetchRequest instead.\n\nConfigure a sectioned fetch request with an optional predicate and sort descriptors, and include a sectionIdentifier parameter to indicate how to group the fetched results. Be sure that you choose sorting and sectioning that work together to avoid discontiguous sections. For example, you can request a list of earthquakes, composed of Quake managed objects that the Loading and Displaying a Large Data Feed sample code project defines to store earthquake data, sorted by time and grouped by date:\n\n@SectionedFetchRequest<String, Quake>(\n    sectionIdentifier: \\.day,\n    sortDescriptors: [SortDescriptor(\\.time, order: .reverse)]\n)\nprivate var quakes: SectionedFetchResults<String, Quake>\n\n\nAlways declare properties that have a sectioned fetch request wrapper as private. This lets the compiler help you avoid accidentally setting the property from the memberwise initializer of the enclosing view.\n\nThe request infers the entity type from the Result type that you specify, which is Quake in the example above. Indicate a SectionIdentifier type to declare the type found at the fetched object\u2019s sectionIdentifier key path. The section identifier type must conform to the Hashable protocol.\n\nThe example above depends on the Quake type having a day property that\u2019s either a stored or computed string. Be sure to mark any computed property with the @objc attribute for it to function as a section identifier. For best performance with large data sets, use stored properties.\n\nThe sectioned fetch request and its results use the managed object context stored in the environment, which you can access using the managedObjectContext environment value. To support user interface activity, you typically rely on the viewContext property of a shared NSPersistentContainer instance. For example, you can set a context on your top-level content view using a shared container that you define as part of your model:\n\nContentView()\n    .environment(\n        \\.managedObjectContext,\n        QuakesProvider.shared.container.viewContext)\n\n\nWhen you need to dynamically change the section identifier, predicate, or sort descriptors, access the request\u2019s SectionedFetchRequest.Configuration structure, either directly or with a binding.\n\nTopics\nCreating a fetch request\ninit(sectionIdentifier: KeyPath<Result, SectionIdentifier>, sortDescriptors: [SortDescriptor<Result>], predicate: NSPredicate?, animation: Animation?)\nCreates a sectioned fetch request based on a section identifier, a predicate, and value type sort parameters.\nAvailable when SectionIdentifier conforms to Hashable and Result inherits NSManagedObject.\ninit(sectionIdentifier: KeyPath<Result, SectionIdentifier>, sortDescriptors: [NSSortDescriptor], predicate: NSPredicate?, animation: Animation?)\nCreates a sectioned fetch request based on a section identifier, a predicate, and reference type sort parameters.\nAvailable when SectionIdentifier conforms to Hashable and Result inherits NSManagedObject.\ninit(entity: NSEntityDescription, sectionIdentifier: KeyPath<Result, SectionIdentifier>, sortDescriptors: [NSSortDescriptor], predicate: NSPredicate?, animation: Animation?)\nCreates a sectioned fetch request for a specified entity description, based on a section identifier, a predicate, and sort parameters.\nAvailable when SectionIdentifier conforms to Hashable and Result conforms to NSFetchRequestResult.\nCreating a fully configured fetch request\ninit(fetchRequest: NSFetchRequest<Result>, sectionIdentifier: KeyPath<Result, SectionIdentifier>, animation: Animation?)\nCreates a fully configured sectioned fetch request that uses the specified animation when updating results.\nAvailable when SectionIdentifier conforms to Hashable and Result conforms to NSFetchRequestResult.\ninit(fetchRequest: NSFetchRequest<Result>, sectionIdentifier: KeyPath<Result, SectionIdentifier>, transaction: Transaction)\nCreates a fully configured sectioned fetch request that uses the specified transaction when updating results.\nAvailable when SectionIdentifier conforms to Hashable and Result conforms to NSFetchRequestResult.\nConfiguring a request dynamically\nstruct Configuration\nThe request\u2019s configurable properties.\nvar projectedValue: Binding<SectionedFetchRequest<SectionIdentifier, Result>.Configuration>\nA binding to the request\u2019s mutable configuration properties.\nGetting the fetched results\nfunc update()\nUpdates the fetched results.\nAvailable when SectionIdentifier conforms to Hashable and Result conforms to NSFetchRequestResult.\nvar wrappedValue: SectionedFetchResults<SectionIdentifier, Result>\nThe fetched results of the fetch request.\nDefault Implementations\nDynamicProperty Implementations\nRelationships\nConforms To\nDynamicProperty\nConforms when SectionIdentifier conforms to Hashable and Result conforms to NSFetchRequestResult.\nSee Also\nAccessing Core Data\nvar managedObjectContext: NSManagedObjectContext\nstruct FetchRequest\nA property wrapper type that retrieves entities from a Core Data persistent store.\nstruct FetchedResults\nA collection of results retrieved from a Core Data store.\nstruct SectionedFetchResults\nA collection of results retrieved from a Core Data persistent store, grouped into sections."
    },
    {
        "title": "managedObjectContext",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/managedobjectcontext",
        "html": "See Also\nAccessing Core Data\nstruct FetchRequest\nA property wrapper type that retrieves entities from a Core Data persistent store.\nstruct FetchedResults\nA collection of results retrieved from a Core Data store.\nstruct SectionedFetchRequest\nA property wrapper type that retrieves entities, grouped into sections, from a Core Data persistent store.\nstruct SectionedFetchResults\nA collection of results retrieved from a Core Data persistent store, grouped into sections."
    },
    {
        "title": "SceneStorage",
        "url": "https://developer.apple.com/documentation/swiftui/scenestorage",
        "html": "Overview\n\nYou use SceneStorage when you need automatic state restoration of the value. SceneStorage works very similar to State, except its initial value is restored by the system if it was previously saved, and the value is shared with other SceneStorage variables in the same scene.\n\nThe system manages the saving and restoring of SceneStorage on your behalf. The underlying data that backs SceneStorage is not available to you, so you must access it via the SceneStorage property wrapper. The system makes no guarantees as to when and how often the data will be persisted.\n\nEach Scene has its own notion of SceneStorage, so data is not shared between scenes.\n\nEnsure that the data you use with SceneStorage is lightweight. Data of a large size, such as model data, should not be stored in SceneStorage, as poor performance may result.\n\nIf the Scene is explicitly destroyed (e.g. the switcher snapshot is destroyed on iPadOS or the window is closed on macOS), the data is also destroyed. Do not use SceneStorage with sensitive data.\n\nTopics\nStoring a value\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore a URL.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore an integer.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore a double.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore a string.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore a boolean.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore a string, transforming it to a RawRepresentable data type.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore data.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore an integer, transforming it to a RawRepresentable data type.\ninit<RowValue>(wrappedValue: Value, String)\nCreates a property that can save and restore table column state.\ninit(wrappedValue: Value, String)\nCreates a property that can save and restore a PersistentIdentifier.\nStoring an optional value\ninit(String)\nCreates a property that can save and restore an Optional string.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit<R>(String)\nCreates a property that can save and restore an Optional integer, transforming it to an Optional RawRepresentable data type.\ninit(String)\nCreates a property that can save and restore an Optional double.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String)\nCreates a property that can save and restore an Optional boolean.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String)\nCreates a property that can save and restore an Optional data.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String)\nCreates a property that can save and restore an Optional URL.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String)\nCreates a property that can save and restore an Optional integer.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit<R>(String)\nCreates a property that can save and restore an Optional string, transforming it to an Optional RawRepresentable data type.\ninit(String)\nCreates a property that can read and write an Optional data user default via PersistentIdentifier.\nGetting the value\nvar wrappedValue: Value\nThe underlying value referenced by the state variable.\nvar projectedValue: Binding<Value>\nA binding to the state value.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nSaving state across app launches\nfunc defaultAppStorage(UserDefaults) -> some View\nThe default store used by AppStorage contained within the view.\nstruct AppStorage\nA property wrapper type that reflects a value from UserDefaults and invalidates a view on a change in value in that user default."
    },
    {
        "title": "Loading and Displaying a Large Data Feed",
        "url": "https://developer.apple.com/documentation/swiftui/loading_and_displaying_a_large_data_feed",
        "html": "Overview\n\nThis sample creates an app that shows a list of earthquakes recorded in the United States in the past 30 days by consuming a U. S. Geological Survey (USGS) real-time data feed.\n\nTo load the USGS JSON feed, perform either of the following:\n\nOn iOS, pull to refresh the List.\n\nOn both iOS and macOS, press the refresh button (\u2318R).\n\nThe app will load the requested data on the default delegate queue of URLSession, which is an operation queue that runs in the background. After the feed is downloaded and the session data task completes, the app continues working on this queue to import the large number of feed elements to the store without blocking the main queue.\n\nNote\n\nThis sample code project is associated with WWDC21 session 10017: Bring Core Data Concurrency to Swift and SwiftUI.\n\nImport Data in the Background\n\nTo import data in the background, apps may use one or two managed object contexts. The sample uses two (NSManagedObjectContext) instances:\n\nA main queue context to provide data to the user interface.\n\nA private queue context to perform the import on a background queue.\n\nBoth contexts are connected to the same persistentStoreCoordinator. This configuration is more efficient than using a nested context.\n\nThe sample creates a main queue context by setting up a Core Data stack using NSPersistentContainer, which initializes a main queue context in its viewContext property.\n\nlet container = NSPersistentContainer(name: \"Earthquakes\")\n\n\nCreate a private queue context by calling the persistent container\u2019s newBackgroundContext() method.\n\nlet taskContext = container.newBackgroundContext()\n\n\nWhen the feed download finishes, the sample uses the task context to consume the feed in the background. In Core Data, every queue-based context has its own serial queue, and apps must serialize the tasks that manipulate the context with the queue by wrapping the code with a perform(_:) \u2014 with or without the await keyword \u2014 or performAndWait(_:) closure.\n\ntry await taskContext.perform {\n\n\nFor more information about working with concurrency, see NSManagedObjectContext.\n\nTo efficiently handle large data sets, the sample uses NSBatchInsertRequest which accesses the store directly \u2014 without interacting with the context, triggering any key value observation, or allocating managed objects. The closure-style initializer of NSBatchInsertRequest allows apps to provide one record at a time when Core Data calls the dictionaryHandler closure, which helps apps keep their memory footprint low because they do not need to prepare a buffer for all records.\n\nlet batchInsertRequest = self.newBatchInsertRequest(with: propertiesList)\nif let fetchResult = try? taskContext.execute(batchInsertRequest),\n   let batchInsertResult = fetchResult as? NSBatchInsertResult,\n   let success = batchInsertResult.result as? Bool, success {\n    return\n}\n\nMerge Changes and Update the User Interface\n\nBecause NSBatchInsertRequest bypasses the context and doesn\u2019t trigger a NSManagedObjectContextDidSave notification, apps that need to update the UI with the changes have two options:\n\nExtract the relevant changes by parsing the store\u2019s Persistent history, then merge them into the view context. For more information on persistent history tracking, see Consuming relevant store changes.\n\nRe-fetch the data from the store. However, if the view context is pinned to a query generation, the context will need to be reset before fetching data. For more information on query generations, see Accessing data when the store changes.\n\nThis sample uses persistent store remote change notifications and persistent history tracking to update the UI, because:\n\nThe data model contains a single entity, so all changes are relevant to the List and do not require parsing specific changes within the history.\n\nFetchRequest fetches and retrieves results directly from the store, and the List refreshes its contents automatically.\n\nSwiftUI is only concerned about the view context, so QuakesProvider observes the NSPersistentStoreRemoteChange notification to merge changes from the background context, performing the batch operations, into the view context.\n\nEnable remote change notifications for a persistent store by setting the NSPersistentStoreRemoteChangeNotificationPostOptionKey option on the store description to true.\n\ndescription.setOption(true as NSNumber,\n                      forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)\n\n\nEnable persistent history tracking for a persistent store by setting the NSPersistentHistoryTrackingKey option to true as well.\n\ndescription.setOption(true as NSNumber,\n                      forKey: NSPersistentHistoryTrackingKey)\n\n\nWhenever changes occur within a persistent store, including writes by other processes, the store posts a remote change notification. When the sample receives the notification, it fetches the persistent history transactions and changes occurring after a given token. After the persistent history change request retrieves the history, the sample merges each transaction\u2019s objectIDNotification() into the view context via mergeChanges(fromContextDidSave:).\n\nlet changeRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: self.lastToken)\nlet historyResult = try taskContext.execute(changeRequest) as? NSPersistentHistoryResult\nif let history = historyResult?.result as? [NSPersistentHistoryTransaction],\n   !history.isEmpty {\n    self.mergePersistentHistoryChanges(from: history)\n    return\n}\n\n\nAfter executing each NSBatchInsertRequest or NSBatchDeleteRequest, the sample dispatches any UI updates back to the main queue, to render them in SwiftUI.\n\nlet viewContext = container.viewContext\nviewContext.perform {\n    for transaction in history {\n        viewContext.mergeChanges(fromContextDidSave: transaction.objectIDNotification())\n        self.lastToken = transaction.token\n    }\n}\n\n\nAfter merging changes from the last transaction, the sample needs to store the token in memory or on disk, to use it in subsequent persistent history change requests.\n\nWork in Batches to Lower Memory Footprint\n\nWhen apps fetch or create objects in a context, Core Data caches the object to avoid a round trip to the store file when the app uses those objects again. However, that approach grows the memory footprint of an app as it processes more and more objects, and can eventually lead to low-memory warnings or app termination on iOS. NSBatchInsertRequest doesn\u2019t obviously increase an app\u2019s memory footprint because it doesn\u2019t load data into memory.\n\nNote\n\nApps targeted to run on a system earlier than iOS 13 or macOS 10.15 need to avoid memory footprint growing by processing the objects in batches and calling reset() to reset the context after each batch.\n\nThe sample sets the viewContext\u2019s automaticallyMergesChangesFromParent property to false to prevent Core Data from automatically merging changes every time the background context is saved.\n\ncontainer.viewContext.automaticallyMergesChangesFromParent = false\n\nPrevent Duplicate Data in the Store\n\nEvery time the sample app reloads the JSON feed, the parsed data contains all earthquake records for the past month, so it can have many duplicates of already imported data. To avoid creating duplicate records, the app constrains an attribute, or combination of attributes, to be unique across all instances.\n\nThe code attribute uniquely identifies an earthquake record, so constraining the Quake entity on code ensures that no two stored records have the same code value.\n\nSelect the Quake entity in the data model editor. In the data model inspector, add a new constraint by clicking the + button under the Constraints list. A constraint placeholder appears.\n\ncomma, separated, properties\n\n\nDouble-click the placeholder to edit it. Enter the name of the attribute, or comma-separated list of attributes, to serve as unique constraints on the entity.\n\ncode\n\n\nWhen saving a new record, the store now checks whether any record already exists with the same value for the constrained attribute. In the case of a conflict, an NSMergeByPropertyObjectTrumpMergePolicy policy comes into play, and the new record overwrites all fields in the existing record.\n\ncontainer.viewContext.automaticallyMergesChangesFromParent = false\n\nSee Also\nBackground tasks\nUsing Core Data in the background\nUse Core Data in both a single-threaded and multithreaded app.\nConflict resolution\nDetect and resolve conflicts that occur when data is changed on multiple threads.\nBatch processing\nUse batch processes to manage large data changes."
    },
    {
        "title": "AppStorage",
        "url": "https://developer.apple.com/documentation/swiftui/appstorage",
        "html": "Topics\nStoring a value\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to a string user default.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to an integer user default, transforming that to RawRepresentable data type.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to a user default as data.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to an integer user default.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to a string user default, transforming that to RawRepresentable data type.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to a url user default.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to a double user default.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to a boolean user default.\ninit<RowValue>(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can save and restore table column state.\ninit(wrappedValue: Value, String, store: UserDefaults?)\nCreates a property that can read and write to a user default as data via PersistentIdentifier.\nStoring an optional value\ninit(String, store: UserDefaults?)\nCreates a property that can read and write an Optional integer user default.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String, store: UserDefaults?)\nCreates a property that can read and write an Optional string user default.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String, store: UserDefaults?)\nCreates a property that can read and write an Optional double user default.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit<R>(String, store: UserDefaults?)\nCreates a property that can save and restore an Optional integer, transforming it to an Optional RawRepresentable data type.\ninit<R>(String, store: UserDefaults?)\nCreates a property that can save and restore an Optional string, transforming it to an Optional RawRepresentable data type.\ninit(String, store: UserDefaults?)\nCreates a property that can read and write an Optional data user default.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String, store: UserDefaults?)\nCreates a property that can read and write an Optional boolean user default.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String, store: UserDefaults?)\nCreates a property that can read and write an Optional URL user default.\nAvailable when Value conforms to ExpressibleByNilLiteral.\ninit(String, store: UserDefaults?)\nCreates a property that can read and write an Optional data user default via PersistentIdentifier.\nGetting the value\nvar wrappedValue: Value\nvar projectedValue: Binding<Value>\nRelationships\nConforms To\nDynamicProperty\nSee Also\nSaving state across app launches\nfunc defaultAppStorage(UserDefaults) -> some View\nThe default store used by AppStorage contained within the view.\nstruct SceneStorage\nA property wrapper type that reads and writes to persisted, per-scene storage."
    },
    {
        "title": "defaultAppStorage(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/defaultappstorage(_:)",
        "html": "Parameters\nstore\n\nThe user defaults to use as the default store for AppStorage.\n\nDiscussion\n\nIf unspecified, the default store for a view hierarchy is UserDefaults.standard, but can be set a to a custom one. For example, sharing defaults between an app and an extension can override the default store to one created with UserDefaults.init(suiteName:_).\n\nSee Also\nSaving state across app launches\nstruct AppStorage\nA property wrapper type that reflects a value from UserDefaults and invalidates a view on a change in value in that user default.\nstruct SceneStorage\nA property wrapper type that reads and writes to persisted, per-scene storage."
    },
    {
        "title": "Restoring Your App\u2019s State with SwiftUI",
        "url": "https://developer.apple.com/documentation/swiftui/restoring_your_app_s_state_with_swiftui",
        "html": "Overview\n\nThis SwiftUI sample project demonstrates how to preserve your app\u02bcs state information and restore the app to that previous state on subsequent launches. During a subsequent launch, restoring your interface to the previous interaction point provides continuity for the user, and lets them finish active tasks quickly.\n\nWhen using your app, the user performs actions that affect the user interface. For example, the user might view a specific page of information, and after the user leaves the app, the operating system might terminate it to free up the resources it holds. The user can return to where they left off \u2014 and UI state restoration is a core part of making that experience seamless.\n\nThis sample app demonstrates the use of state preservation and restoration for scenarios where the system interrupts the app. The sample project manages a set of products. Each product has a title, an image, and other metadata you can view and edit. The project shows how to preserve and restore a product in its DetailView.\n\nConfigure the Sample Code Project\n\nIn Xcode, select your development team on the iOS target\u2019s Signing and Capabilities tab.\n\nEnable State Preservation and Restoration\n\nThis sample code project uses SwiftUI\u2019s Scene to manage the app\u2019s user interface with its life cycle managed by the system. On iOS, state restoration is especially important at the window or scene level, because windows come and go frequently. It\u2019s necessary to save and restore state associated with each one. On the iPad, it\u2019s especially important because an app in the switcher is not necessarily running. Scene-level state restoration preserves the illusion they are running.\n\nTo support state preservation and restoration, this sample uses NSUserActivity objects. For each user activity, the app must supply an activity type defined in its Info.plist.\n\nUse Scene Storage\n\nSwiftUI has the concept of \u201cstoring scene data\u201d or SceneStorage. Operating similar to State, scene storage is a property wrapper type that consists of a key/value pair. The key makes it possible for the system to save and restore the value correctly. The value is required to be of a plist type, so the system can save and restore it correctly. iOS ingests this scene storage using the key/value and then reads and writes to persisted, per-scene storage. The OS manages saving and restoring scene storage on the user\u2019s behalf. The underlying data that backs scene storage is not directly available, so the app must access it via @SceneStorage property wrapper. The OS makes no guarantees as to when and how often the data will be persisted. The data in scene storage is not necessarily equivalent to an application\u2019s data model. Scene storage is intended to be used with the data model. Ultimately, consider scene storage a \u201cstate scoped to a scene\u201d. Don\u2019t use scene storage with sensitive data.\n\nEach view that needs its own state preservation implements a @SceneStorage property wrapper. For example ContentView uses one to restore the selected product:\n\n@SceneStorage(\"ContentView.selectedProduct\") private var selectedProduct: String?\n\n\nDetailView uses one to restore its current selected tab:\n\n@SceneStorage(\"DetailView.selectedTab\") private var selectedTab = Tabs.detail\n\n\nNote\n\nEach scene storage key must be unique, and properly scoped to the area or use within the app. Because this scene storage is local to the app, it\u2019s not necessary to prefix it with the app\u2019s bundle identifier. Use some disambiguating prefix where needed to ensure its uniqueness.\n\nRestore the App State with an Activity Object\n\nAn NSUserActivity object captures the app\u2019s state at the current moment in time. For example, include information about the data the app is currently displaying. The system saves the provided object and returns it to the app the next time it launches. The sample creates a new NSUserActivity object when the user closes the app or the app enters the background.\n\nEach SwiftUI view that wants to advertise an NSUserActivity for handoff, Spotlight, etc. must specify a userActivity(_:isActive:_:) view modifier to advertise the NSUserActivity. The activityType parameter is the user activity\u2019s type, the isActive parameter indicates whether a user activity of the specified type is advertised (this parameter defaults to true), and whether it uses the specified handler to fill in the user-activity contents. The scope of the user activity applies only to the scene or window in which the view is. Multiple views can advertise the same activity type, and the handlers can all contribute to the contents of the user activity. Note that handlers are only called for userActivity view modifiers where the isActive parameter is true. If none of the userActivity view modifiers specify isActive as true, the user activity will not be advertised by iOS.\n\nEach SwiftUI view that wants to handle incoming NSUserActivities must specify a onContinueUserActivity(_:perform:) view modifier. This takes the NSUserActivity type and a handler to invoke when the view receives the specified activity type for the scene or window in which the view is.\n\n.onContinueUserActivity(DetailView.productUserActivityType) { userActivity in\n    if let product = try? userActivity.typedPayload(Product.self) {\n        selectedProduct = product.id.uuidString\n    }\n}\n\nTest State Restoration\n\nThis sample restores the following user interface:\n\nDetail View Controller \u2014 Tap a product in the collection view to open its detail information. The app restores the selected product and selected tab.\n\nDetail View Controller\u2019s Edit State \u2014 In the detail view, tap Edit. The app restores the edit view and its content.\n\nSecondary Window \u2014 (iPad only) Drag a product from the collection view over to the left or right of the device screen to create a second scene window. The app restores that scene and its product.\n\nState restoration can be tested both on the device and Simulator. When debugging the sample project, the system automatically deletes its preserved state when the user force quits the app. Deleting the preserved state information is a safety precaution. In addition, the system also deletes the preserved state if this app crashes at launch time.\n\nTo test the sample app\u2019s ability to restore the sample\u2019s state, don\u2019t use the app switcher to force quit it during debugging. Instead, use Xcode to stop the app or stop the app programmatically. Another technique is to suspend the sample app using the Home button, and then stop the debugger in Xcode. Launch the sample app again using Xcode, and SwiftUI initiates the state restoration process.\n\nTo use Spotlight with Handoff, follow these steps:\n\nIn Xcode set a breakpoint in DetailView.swift at onContinueUserActivity closure.\n\nRun the sample project.\n\nTap a product (\u201cCherries\u201d) in the collection view to navigate to its detail information.\n\nPull down the system sheet from the top of the screen (to force Spotlight to update its index and request the activity). Note that the DetailView userActivity closure is called by iOS.\n\nGo back to the app, and go back to the collection view.\n\nTap a product other than Cherries (i.e. Mango).\n\nSuspend the app by tapping the Home button.\n\nAt the Home screen, swipe downwards to open the Spotlight window.\n\nIn the Spotlight search field, type \u201cCherries\u201d. The search results will show \u201cShow Cherries Product\u201d.\n\nTap it. Note that DetailView onContinueUserActivity closure is called. The DetailView will show the Cherries product.\n\nSee Also\nInterface restoration\nRestoring Your App\u2019s State\nProvide continuity for the user by preserving current activities.\nPreserving your app\u2019s UI across launches\nReturn your app to its previous state after the system terminates it.\nprotocol UIViewControllerRestoration\nThe methods that objects adopt so that they can act as a restoration class for view controllers during state restoration.\nprotocol UIObjectRestoration\nThe interface that restoration classes use to restore preserved objects.\nprotocol UIStateRestoring\nMethods for adding objects to your state restoration archives."
    },
    {
        "title": "backgroundPreferenceValue(_:alignment:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/backgroundpreferencevalue(_:alignment:_:)",
        "html": "Parameters\nkey\n\nThe preference key type whose value is to be read.\n\nalignment\n\nAn optional alignment to use when positioning the background view relative to the original view.\n\ntransform\n\nA function that produces the background view from the preference value read from the original view.\n\nReturn Value\n\nA view that layers a second view behind the view.\n\nDiscussion\n\nThe values of the preference key from both views are combined and made visible to the parent view.\n\nSee Also\nGenerating backgrounds and overlays from preferences\nfunc backgroundPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc overlayPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view.\nfunc overlayPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view."
    },
    {
        "title": "overlayPreferenceValue(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/overlaypreferencevalue(_:_:)",
        "html": "Parameters\nkey\n\nThe preference key type whose value is to be read.\n\ntransform\n\nA function that produces the overlay view from the preference value read from the original view.\n\nReturn Value\n\nA view that layers a second view in front of the view.\n\nSee Also\nGenerating backgrounds and overlays from preferences\nfunc backgroundPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc backgroundPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc overlayPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view."
    },
    {
        "title": "backgroundPreferenceValue(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/backgroundpreferencevalue(_:_:)",
        "html": "Parameters\nkey\n\nThe preference key type whose value is to be read.\n\ntransform\n\nA function that produces the background view from the preference value read from the original view.\n\nReturn Value\n\nA view that layers a second view behind the view.\n\nSee Also\nGenerating backgrounds and overlays from preferences\nfunc backgroundPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc overlayPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view.\nfunc overlayPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view."
    },
    {
        "title": "navigationTitle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)-avgj",
        "html": "Parameters\ntitle\n\nThe string to display.\n\nDiscussion\n\nA view\u2019s navigation title is used to visually display the current navigation state of an interface. On iOS and watchOS, when a view is navigated to inside of a navigation view, that view\u2019s title is displayed in the navigation bar. On iPadOS, the primary destination\u2019s navigation title is reflected as the window\u2019s title in the App Switcher. Similarly on macOS, the primary destination\u2019s title is used as the window title in the titlebar, Windows menu and Mission Control.\n\nRefer to the Configure your apps navigation titles article for more information on navigation title modifiers.\n\nSee Also\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation."
    },
    {
        "title": "transformAnchorPreference(key:value:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transformanchorpreference(key:value:transform:)",
        "html": "Parameters\nkey\n\nthe preference key type.\n\nvalue\n\nthe geometry value in the current coordinate space.\n\ntransform\n\nthe function to produce the preference value.\n\nReturn Value\n\na new version of the view that writes the preference.\n\nSee Also\nSetting preferences based on geometry\nfunc anchorPreference<A, K>(key: K.Type, value: Anchor<A>.Source, transform: (Anchor<A>) -> K.Value) -> some View\nSets a value for the specified preference key, the value is a function of a geometry value tied to the current coordinate space, allowing readers of the value to convert the geometry to their local coordinates."
    },
    {
        "title": "transformPreference(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transformpreference(_:_:)",
        "html": "See Also\nSetting preferences\nfunc preference<K>(key: K.Type, value: K.Value) -> some View\nSets a value for the given preference."
    },
    {
        "title": "onPreferenceChange(_:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onpreferencechange(_:perform:)",
        "html": "Parameters\nkey\n\nThe key to monitor for value changes.\n\naction\n\nThe action to perform when the value for key changes. The action closure passes the new value as its parameter.\n\nReturn Value\n\nA view that triggers action when the value for key changes."
    },
    {
        "title": "ActionSheet",
        "url": "https://developer.apple.com/documentation/swiftui/actionsheet",
        "html": "Deprecated\n\nUse a View modifier like confirmationDialog(_:isPresented:titleVisibility:presenting:actions:message:) instead.\n\nOverview\n\nUse an action sheet when you want the user to make a choice between two or more options, in response to their own action. If you want the user to act in response to the state of the app or the system, rather than a user action, use an Alert instead.\n\nYou show an action sheet by using the actionSheet(isPresented:content:) view modifier to create an action sheet, which then appears whenever the bound isPresented value is true. The content closure you provide to this modifier produces a customized instance of the ActionSheet type. To supply the options, create instances of ActionSheet.Button to distinguish between ordinary options, destructive options, and cancellation of the user\u2019s original action.\n\nThe action sheet handles its dismissal by setting the bound isPresented value back to false when the user taps a button in the action sheet.\n\nThe following example creates an action sheet with three options: a Cancel button, a destructive button, and a default button. The second and third of these call methods are named overwriteWorkout and appendWorkout, respectively.\n\n@State private var showActionSheet = false\nvar body: some View {\n    Button(\"Tap to show action sheet\") {\n        showActionSheet = true\n    }\n    .actionSheet(isPresented: $showActionSheet) {\n        ActionSheet(title: Text(\"Resume Workout Recording\"),\n                    message: Text(\"Choose a destination for workout data\"),\n                    buttons: [\n                        .cancel(),\n                        .destructive(\n                            Text(\"Overwrite Current Workout\"),\n                            action: overwriteWorkout\n                        ),\n                        .default(\n                            Text(\"Append to Current Workout\"),\n                            action: appendWorkout\n                        )\n                    ]\n        )\n    }\n}\n\n\nThe system may interpret the order of items as they appear in the buttons array to accommodate platform conventions. In this example, the Cancel button is the first member of the array, but the action sheet puts it in its standard position at the bottom of the sheet.\n\nTopics\nCreating an action sheet\ninit(title: Text, message: Text?, buttons: [ActionSheet.Button])\nCreates an action sheet with the provided buttons.\nSpecifying the button type\ntypealias Button\nA button representing an operation of an action sheet presentation.\nSee Also\nDeprecated modal presentations\nstruct Alert\nA representation of an alert presentation.\nDeprecated"
    },
    {
        "title": "preference(key:value:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/preference(key:value:)",
        "html": "See Also\nSetting preferences\nfunc transformPreference<K>(K.Type, (inout K.Value) -> Void) -> some View\nApplies a transformation to a preference value."
    },
    {
        "title": "Alert",
        "url": "https://developer.apple.com/documentation/swiftui/alert",
        "html": "Deprecated\n\nUse a View modifier like alert(_:isPresented:presenting:actions:message:) instead.\n\nOverview\n\nUse an alert when you want the user to act in response to the state of the app or system. If you want the user to make a choice in response to their action, use an ActionSheet instead.\n\nYou show an alert by using the alert(isPresented:content:) view modifier to create an alert, which then appears whenever the bound isPresented value is true. The content closure you provide to this modifer produces a customized instance of the Alert type.\n\nIn the following example, a button presents a simple alert when tapped, by updating a local showAlert property that binds to the alert.\n\n@State private var showAlert = false\nvar body: some View {\n    Button(\"Tap to show alert\") {\n        showAlert = true\n    }\n    .alert(isPresented: $showAlert) {\n        Alert(\n            title: Text(\"Current Location Not Available\"),\n            message: Text(\"Your current location can\u2019t be \" +\n                            \"determined at this time.\")\n        )\n    }\n}\n\n\nTo customize the alert, add instances of the Alert.Button type, which provides standardized buttons for common tasks like canceling and performing destructive actions. The following example uses two buttons: a default button labeled \u201cTry Again\u201d that calls a saveWorkoutData method, and a \u201cDelete\u201d button that calls a destructive deleteWorkoutData method.\n\n@State private var showAlert = false\nvar body: some View {\n    Button(\"Tap to show alert\") {\n        showAlert = true\n    }\n    .alert(isPresented: $showAlert) {\n        Alert(\n            title: Text(\"Unable to Save Workout Data\"),\n            message: Text(\"The connection to the server was lost.\"),\n            primaryButton: .default(\n                Text(\"Try Again\"),\n                action: saveWorkoutData\n            ),\n            secondaryButton: .destructive(\n                Text(\"Delete\"),\n                action: deleteWorkoutData\n            )\n        )\n    }\n}\n\n\nThe alert handles its own dismissal when the user taps one of the buttons in the alert, by setting the bound isPresented value back to false.\n\nTopics\nCreating an alert\ninit(title: Text, message: Text?, dismissButton: Alert.Button?)\nCreates an alert with one button.\ninit(title: Text, message: Text?, primaryButton: Alert.Button, secondaryButton: Alert.Button)\nCreates an alert with two buttons.\nstatic func sideBySideButtons(title: Text, message: Text?, primaryButton: Alert.Button, secondaryButton: Alert.Button) -> Alert\nCreates a side by side button alert.\nSpecifying the button type\nstruct Button\nA button that represents an operation of an alert presentation.\nSee Also\nDeprecated modal presentations\nstruct ActionSheet\nA representation of an action sheet presentation.\nDeprecated"
    },
    {
        "title": "GaugeStyle",
        "url": "https://developer.apple.com/documentation/swiftui/gaugestyle",
        "html": "Overview\n\nTo configure the style for all the Gauge instances in a view hierarchy, use the gaugeStyle(_:) modifier. For example, you can configure a gauge to use the circular style:\n\nGauge(value: batteryLevel, in: 0...100) {\n    Text(\"Battery Level\")\n}\n.gaugeStyle(.circular)\n\nTopics\nGetting the automatic style\nstatic var automatic: DefaultGaugeStyle\nThe default gauge view style in the current context of the view being styled.\nAvailable when Self is DefaultGaugeStyle.\nGetting circular gauge styles\nstatic var circular: CircularGaugeStyle\nA gauge style that displays an open ring with a marker that appears at a point along the ring to indicate the gauge\u2019s current value.\nAvailable when Self is CircularGaugeStyle.\nstatic var accessoryCircular: AccessoryCircularGaugeStyle\nA gauge style that displays an open ring with a marker that appears at a point along the ring to indicate the gauge\u2019s current value.\nAvailable when Self is AccessoryCircularGaugeStyle.\nstatic var accessoryCircularCapacity: AccessoryCircularCapacityGaugeStyle\nA gauge style that displays a closed ring that\u2019s partially filled in to indicate the gauge\u2019s current value.\nAvailable when Self is AccessoryCircularCapacityGaugeStyle.\nGetting linear gauge styles\nstatic var linear: LinearGaugeStyle\nA gauge style that displays a bar with a marker that appears at a point along the bar to indicate the gauge\u2019s current value.\nAvailable when Self is LinearGaugeStyle.\nstatic var linearCapacity: LinearCapacityGaugeStyle\nA gauge style that displays a bar that fills from leading to trailing edges as the gauge\u2019s current value increases.\nAvailable when Self is LinearCapacityGaugeStyle.\nstatic var accessoryLinear: AccessoryLinearGaugeStyle\nA gauge style that displays bar with a marker that appears at a point along the bar to indicate the gauge\u2019s current value.\nAvailable when Self is AccessoryLinearGaugeStyle.\nstatic var accessoryLinearCapacity: AccessoryLinearCapacityGaugeStyle\nA gauge style that displays bar that fills from leading to trailing edges as the gauge\u2019s current value increases.\nAvailable when Self is AccessoryLinearCapacityGaugeStyle.\nCreating custom gauge styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view representing the body of a gauge.\n\nRequired\n\ntypealias Configuration\nThe properties of a gauge instance.\nassociatedtype Body : View\nA view representing the body of a gauge.\n\nRequired\n\nSupporting types\nstruct DefaultGaugeStyle\nThe default gauge view style in the current context of the view being styled.\nstruct CircularGaugeStyle\nA gauge style that displays an open ring with a marker that appears at a point along the ring to indicate the gauge\u2019s current value.\nstruct AccessoryCircularGaugeStyle\nA gauge style that displays an open ring with a marker that appears at a point along the ring to indicate the gauge\u2019s current value.\nstruct AccessoryCircularCapacityGaugeStyle\nA gauge style that displays a closed ring that\u2019s partially filled in to indicate the gauge\u2019s current value.\nstruct LinearGaugeStyle\nA gauge style that displays a bar with a marker that appears at a point along the bar to indicate the gauge\u2019s current value.\nstruct LinearCapacityGaugeStyle\nA gauge style that displays bar that fills from leading to trailing edges as the gauge\u2019s current value increases.\nstruct AccessoryLinearGaugeStyle\nA gauge style that displays bar with a marker that appears at a point along the bar to indicate the gauge\u2019s current value.\nstruct AccessoryLinearCapacityGaugeStyle\nA gauge style that displays bar that fills from leading to trailing edges as the gauge\u2019s current value increases.\nRelationships\nConforming Types\nAccessoryCircularCapacityGaugeStyle\nAccessoryCircularGaugeStyle\nAccessoryLinearCapacityGaugeStyle\nAccessoryLinearGaugeStyle\nCircularGaugeStyle\nDefaultGaugeStyle\nLinearCapacityGaugeStyle\nLinearGaugeStyle\nSee Also\nStyling indicators\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nstruct GaugeStyleConfiguration\nThe properties of a gauge instance.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nprotocol ProgressViewStyle\nA type that applies standard interaction behavior to all progress views within a view hierarchy.\nstruct ProgressViewStyleConfiguration\nThe properties of a progress view instance."
    },
    {
        "title": "ToggleStyle",
        "url": "https://developer.apple.com/documentation/swiftui/togglestyle",
        "html": "Overview\n\nTo configure the style for a single Toggle or for all toggle instances in a view hierarchy, use the toggleStyle(_:) modifier. You can specify one of the built-in toggle styles, like switch or button:\n\nToggle(isOn: $isFlagged) {\n    Label(\"Flag\", systemImage: \"flag.fill\")\n}\n.toggleStyle(.button)\n\n\nAlternatively, you can create and apply a custom style.\n\nCustom styles\n\nTo create a custom style, declare a type that conforms to the ToggleStyle protocol and implement the required makeBody(configuration:) method. For example, you can define a checklist toggle style:\n\nstruct ChecklistToggleStyle: ToggleStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        // Return a view that has checklist appearance and behavior.\n    }\n}\n\n\nInside the method, use the configuration parameter, which is an instance of the ToggleStyleConfiguration structure, to get the label and a binding to the toggle state. To see examples of how to use these items to construct a view that has the appearance and behavior of a toggle, see makeBody(configuration:).\n\nTo provide easy access to the new style, declare a corresponding static variable in an extension to ToggleStyle:\n\nextension ToggleStyle where Self == ChecklistToggleStyle {\n    static var checklist: ChecklistToggleStyle { .init() }\n}\n\n\nYou can then use your custom style:\n\nToggle(activity.name, isOn: $activity.isComplete)\n    .toggleStyle(.checklist)\n\nTopics\nGetting built-in toggle styles\nstatic var automatic: DefaultToggleStyle\nThe default toggle style.\nAvailable when Self is DefaultToggleStyle.\nstatic var button: ButtonToggleStyle\nA toggle style that displays as a button with its label as the title.\nAvailable when Self is ButtonToggleStyle.\nstatic var checkbox: CheckboxToggleStyle\nA toggle style that displays a checkbox followed by its label.\nAvailable when Self is CheckboxToggleStyle.\nstatic var `switch`: SwitchToggleStyle\nA toggle style that displays a leading label and a trailing switch.\nAvailable when Self is SwitchToggleStyle.\nCreating custom toggle styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a toggle.\n\nRequired\n\nstruct ToggleStyleConfiguration\nThe properties of a toggle instance.\ntypealias Configuration\nThe properties of a toggle instance.\nassociatedtype Body : View\nA view that represents the appearance and interaction of a toggle.\n\nRequired\n\nSupporting types\nstruct DefaultToggleStyle\nThe default toggle style.\nstruct ButtonToggleStyle\nA toggle style that displays as a button with its label as the title.\nstruct CheckboxToggleStyle\nA toggle style that displays a checkbox followed by its label.\nstruct SwitchToggleStyle\nA toggle style that displays a leading label and a trailing switch.\nRelationships\nConforming Types\nButtonToggleStyle\nCheckboxToggleStyle\nDefaultToggleStyle\nSwitchToggleStyle\nSee Also\nStyling toggles\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy.\nstruct ToggleStyleConfiguration\nThe properties of a toggle instance."
    },
    {
        "title": "GaugeStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/gaugestyleconfiguration",
        "html": "Topics\nDescribing the purpose of the gauge\nvar label: GaugeStyleConfiguration.Label\nA view that describes the purpose of the gauge.\nstruct Label\nA type-erased label of a gauge, describing its purpose.\nReporting the range\nvar minimumValueLabel: GaugeStyleConfiguration.MinimumValueLabel?\nA view that describes the minimum of the range for the current value.\nstruct MinimumValueLabel\nA type-erased value label of a gauge describing the minimum value.\nvar maximumValueLabel: GaugeStyleConfiguration.MaximumValueLabel?\nA view that describes the maximum of the range for the current value.\nstruct MaximumValueLabel\nA type-erased value label of a gauge describing the maximum value.\nSetting the value\nvar value: Double\nThe current value of the gauge.\nvar currentValueLabel: GaugeStyleConfiguration.CurrentValueLabel?\nA view that describes the current value.\nstruct CurrentValueLabel\nA type-erased value label of a gauge that contains the current value.\nstruct MarkedValueLabel\nA type-erased label describing a specific value of a gauge.\nSee Also\nStyling indicators\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nprotocol GaugeStyle\nDefines the implementation of all gauge instances within a view hierarchy.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nprotocol ProgressViewStyle\nA type that applies standard interaction behavior to all progress views within a view hierarchy.\nstruct ProgressViewStyleConfiguration\nThe properties of a progress view instance."
    },
    {
        "title": "MenuStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/menustyleconfiguration",
        "html": "Overview\n\nUse the init(_:) initializer of Menu to create an instance using the current menu style, which you can modify to create a custom style.\n\nFor example, the following code creates a new, custom style that adds a red border to the current menu style:\n\nstruct RedBorderMenuStyle: MenuStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        Menu(configuration)\n            .border(Color.red)\n    }\n}\n\nTopics\nSetting the label and content\nstruct Label\nA type-erased label of a menu.\nstruct Content\nA type-erased content of a menu.\nSee Also\nStyling menus\nfunc menuStyle<S>(S) -> some View\nSets the style for menus within this view.\nprotocol MenuStyle\nA type that applies standard interaction behavior and a custom appearance to all menus within a view hierarchy."
    },
    {
        "title": "ToggleStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/togglestyleconfiguration",
        "html": "Overview\n\nWhen you define a custom toggle style by creating a type that conforms to the ToggleStyle protocol, you implement the makeBody(configuration:) method. That method takes a ToggleStyleConfiguration input that has the information you need to define the behavior and appearance of a Toggle.\n\nThe configuration structure\u2019s label reflects the toggle\u2019s content, which might be the value that you supply to the label parameter of the init(isOn:label:) initializer. Alternatively, it could be another view that SwiftUI builds from an initializer that takes a string input, like init(_:isOn:). In either case, incorporate the label into the toggle\u2019s view to help the user understand what the toggle does. For example, the built-in switch style horizontally stacks the label with the control element.\n\nThe structure\u2019s isOn property provides a Binding to the state of the toggle. Adjust the appearance of the toggle based on this value. For example, the built-in button style fills the button\u2019s background when the property is true, but leaves the background empty when the property is false. Change the value when the user performs an action that\u2019s meant to change the toggle, like the button does when tapped or clicked by the user.\n\nTopics\nGetting the label view\nlet label: ToggleStyleConfiguration.Label\nA view that describes the effect of switching the toggle between states.\nstruct Label\nA type-erased label of a toggle.\nManaging the toggle state\nvar isMixed: Bool\nWhether the Toggle is currently in a mixed state.\nvar isOn: Bool\nA binding to a state property that indicates whether the toggle is on.\nvar $isOn: Binding<Bool>\nSee Also\nStyling toggles\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy.\nprotocol ToggleStyle\nThe appearance and behavior of a toggle."
    },
    {
        "title": "ProgressViewStyleConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/progressviewstyleconfiguration",
        "html": "Topics\nConfiguring the label\nvar label: ProgressViewStyleConfiguration.Label?\nA view that describes the task represented by the progress view.\nstruct Label\nA type-erased label describing the task represented by the progress view.\nConfiguring the current value label\nvar currentValueLabel: ProgressViewStyleConfiguration.CurrentValueLabel?\nA view that describes the current value of a progress view.\nstruct CurrentValueLabel\nA type-erased label that describes the current value of a progress view.\nConfiguring progress completion\nlet fractionCompleted: Double?\nThe completed fraction of the task represented by the progress view, from 0.0 (not yet started) to 1.0 (fully complete), or nil if the progress is indeterminate or relative to a date interval.\nSee Also\nStyling indicators\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nprotocol GaugeStyle\nDefines the implementation of all gauge instances within a view hierarchy.\nstruct GaugeStyleConfiguration\nThe properties of a gauge instance.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nprotocol ProgressViewStyle\nA type that applies standard interaction behavior to all progress views within a view hierarchy."
    },
    {
        "title": "interactiveDismissDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/interactivedismissdisabled(_:)",
        "html": "Parameters\nisDisabled\n\nA Boolean value that indicates whether to prevent nonprogrammatic dismissal of the containing view hierarchy when presented in a sheet or popover.\n\nDiscussion\n\nUsers can dismiss certain kinds of presentations using built-in gestures. In particular, a user can dismiss a sheet by dragging it down, or a popover by clicking or tapping outside of the presented view. Use the interactiveDismissDisabled(_:) modifier to conditionally prevent this kind of dismissal. You typically do this to prevent the user from dismissing a presentation before providing needed data or completing a required action.\n\nFor instance, suppose you have a view that displays a licensing agreement that the user must acknowledge before continuing:\n\nstruct TermsOfService: View {\n    @Binding var areTermsAccepted: Bool\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Form {\n            Text(\"License Agreement\")\n                .font(.title)\n            Text(\"Terms and conditions go here.\")\n            Button(\"Accept\") {\n                areTermsAccepted = true\n                dismiss()\n            }\n        }\n    }\n}\n\n\nIf you present this view in a sheet, the user can dismiss it by either tapping the button \u2014 which calls dismiss from its action closure \u2014 or by dragging the sheet down. To ensure that the user accepts the terms by tapping the button, disable interactive dismissal, conditioned on the areTermsAccepted property:\n\nstruct ContentView: View {\n    @State private var isSheetPresented = false\n    @State private var areTermsAccepted = false\n\n\n    var body: some View {\n        Button(\"Use Service\") {\n            isSheetPresented = true\n        }\n        .sheet(isPresented: $isSheetPresented) {\n            TermsOfService()\n                .interactiveDismissDisabled(!areTermsAccepted)\n        }\n    }\n}\n\n\nYou can apply the modifier to any view in the sheet\u2019s view hierarchy, including to the sheet\u2019s top level view, as the example demonstrates, or to any child view, like the Form or the Accept Button.\n\nThe modifier has no effect on programmatic dismissal, which you can invoke by updating the Binding that controls the presentation, or by calling the environment\u2019s dismiss action. On macOS, disabling interactive dismissal in a popover makes the popover nontransient.\n\nSee Also\nDismissing a presentation\nvar isPresented: Bool\nA Boolean value that indicates whether the view associated with this environment is currently presented.\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nstruct DismissAction\nAn action that dismisses a presentation."
    },
    {
        "title": "gaugeStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/gaugestyle(_:)",
        "html": "See Also\nIndicating a value\nstruct Gauge\nA view that shows a value within a range.\nstruct ProgressView\nA view that shows the progress toward completion of a task.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nstruct DefaultDateProgressLabel\nThe default type of the current value label when used by a date-relative progress view."
    },
    {
        "title": "ProgressViewStyle",
        "url": "https://developer.apple.com/documentation/swiftui/progressviewstyle",
        "html": "Overview\n\nTo configure the current progress view style for a view hierarchy, use the progressViewStyle(_:) modifier.\n\nTopics\nGetting built-in progress view styles\nstatic var automatic: DefaultProgressViewStyle\nThe default progress view style in the current context of the view being styled.\nAvailable when Self is DefaultProgressViewStyle.\nstatic var circular: CircularProgressViewStyle\nThe style of a progress view that uses a circular gauge to indicate the partial completion of an activity.\nAvailable when Self is CircularProgressViewStyle.\nstatic var linear: LinearProgressViewStyle\nA progress view that visually indicates its progress using a horizontal bar.\nAvailable when Self is LinearProgressViewStyle.\nCreating custom progress view styles\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view representing the body of a progress view.\n\nRequired\n\ntypealias Configuration\nA type alias for the properties of a progress view instance.\nassociatedtype Body : View\nA view representing the body of a progress view.\n\nRequired\n\nSupporting types\nstruct DefaultProgressViewStyle\nThe default progress view style in the current context of the view being styled.\nstruct CircularProgressViewStyle\nA progress view that uses a circular gauge to indicate the partial completion of an activity.\nstruct LinearProgressViewStyle\nA progress view that visually indicates its progress using a horizontal bar.\nRelationships\nConforming Types\nCircularProgressViewStyle\nDefaultProgressViewStyle\nLinearProgressViewStyle\nSee Also\nStyling indicators\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nprotocol GaugeStyle\nDefines the implementation of all gauge instances within a view hierarchy.\nstruct GaugeStyleConfiguration\nThe properties of a gauge instance.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nstruct ProgressViewStyleConfiguration\nThe properties of a progress view instance."
    },
    {
        "title": "progressViewStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/progressviewstyle(_:)",
        "html": "Parameters\nstyle\n\nThe progress view style to use for this view.\n\nDiscussion\n\nFor example, the following code creates a progress view that uses the \u201ccircular\u201d style:\n\nProgressView()\n    .progressViewStyle(.circular)\n\nSee Also\nIndicating a value\nstruct Gauge\nA view that shows a value within a range.\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nstruct ProgressView\nA view that shows the progress toward completion of a task.\nstruct DefaultDateProgressLabel\nThe default type of the current value label when used by a date-relative progress view."
    },
    {
        "title": "labelStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/labelstyle(_:)",
        "html": "Discussion\n\nUse this modifier to set a specific style for all labels within a view:\n\nVStack {\n    Label(\"Fire\", systemImage: \"flame.fill\")\n    Label(\"Lightning\", systemImage: \"bolt.fill\")\n}\n.labelStyle(MyCustomLabelStyle())\n\nSee Also\nDisplaying text\nstruct Text\nA view that displays one or more lines of read-only text.\nstruct Label\nA standard label for user interface items, consisting of an icon with a title."
    },
    {
        "title": "redacted(reason:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/redacted(reason:)",
        "html": "Discussion\n\nAdding a redaction is an additive process: any redaction provided will be added to the reasons provided by the parent.\n\nSee Also\nRedacting private content\nfunc privacySensitive(Bool) -> some View\nMarks the view as containing sensitive, private user data.\nfunc unredacted() -> some View\nRemoves any reason to apply a redaction to this view hierarchy.\nvar redactionReasons: RedactionReasons\nThe current redaction reasons applied to the view hierarchy.\nvar isSceneCaptured: Bool\nThe current capture state.\nstruct RedactionReasons\nThe reasons to apply a redaction to data displayed on screen."
    },
    {
        "title": "opacity(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/opacity(_:)",
        "html": "Parameters\nopacity\n\nA value between 0 (fully transparent) and 1 (fully opaque).\n\nReturn Value\n\nA view that sets the transparency of this view.\n\nDiscussion\n\nApply opacity to reveal views that are behind another view or to de-emphasize a view.\n\nWhen applying the opacity(_:) modifier to a view that has already had its opacity transformed, the modifier multiplies the effect of the underlying opacity transformation.\n\nThe example below shows yellow and red rectangles configured to overlap. The top yellow rectangle has its opacity set to 50%, allowing the occluded portion of the bottom rectangle to be visible:\n\nstruct Opacity: View {\n    var body: some View {\n        VStack {\n            Color.yellow.frame(width: 100, height: 100, alignment: .center)\n                .zIndex(1)\n                .opacity(0.5)\n\n\n            Color.red.frame(width: 100, height: 100, alignment: .center)\n                .padding(-40)\n        }\n    }\n}\n\n\nSee Also\nHiding views\nfunc hidden() -> some View\nHides this view unconditionally."
    },
    {
        "title": "GlassBackgroundDisplayMode",
        "url": "https://developer.apple.com/documentation/swiftui/glassbackgrounddisplaymode",
        "html": "Overview\n\nUse a value of this type to indicate when to display a glass background that you add to a view using a view modifier like glassBackgroundEffect(displayMode:).\n\nTopics\nGetting the mode\ncase always\nAlways display the glass material.\ncase implicit\nDisplay the glass material only when the view isn\u2019t already contained in glass.\ncase never\nNever display the glass material.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nAdding a glass background\nfunc glassBackgroundEffect(displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material that\u2019s shaped as a container-relative rounded rectangle.\nBeta\nfunc glassBackgroundEffect<S>(in: S, displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material using a shape that you specify.\nBeta"
    },
    {
        "title": "presentationBackgroundInteraction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationbackgroundinteraction(_:)",
        "html": "Parameters\ninteraction\n\nA specification of how people can interact with the view behind a presentation.\n\nDiscussion\n\nOn many platforms, SwiftUI automatically disables the view behind a sheet that you present, so that people can\u2019t interact with the backing view until they dismiss the sheet. Use this modifier if you want to enable interaction.\n\nThe following example enables people to interact with the view behind the sheet when the sheet is at the smallest detent, but not at the other detents:\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationDetents(\n                    [.height(120), .medium, .large])\n                .presentationBackgroundInteraction(\n                    .enabled(upThrough: .height(120)))\n        }\n    }\n}\n\nSee Also\nStyling a sheet and its background\nfunc presentationCornerRadius(CGFloat?) -> some View\nRequests that the presentation have a specific corner radius.\nfunc presentationBackground<S>(S) -> some View\nSets the presentation background of the enclosing sheet using a shape style.\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> some View\nSets the presentation background of the enclosing sheet to a custom view.\nstruct PresentationBackgroundInteraction\nThe kinds of interaction available to views behind a presentation."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:message:)-2s7pz",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\nactions\n\nA view builder returning the dialog\u2019s actions.\n\nmessage\n\nA view builder returning the message for the dialog.\n\nDiscussion\n\nIn the example below, a button conditionally presents a confirmation dialog depending upon the value of a bound Boolean variable. When the Boolean value is set to true, the system displays a confirmation dialog with a cancel action and a destructive action.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n    var body: some View {\n        Button(\"Empty Trash\") {\n            isShowingDialog = true\n        }\n        .confirmationDialog(\n            \"Permanently erase the items in the Trash?\",\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Empty Trash\", role: .destructive) {\n                // Handle empty trash action.\n            }\n        } message: {\n            Text(\"You cannot undo this action.\")\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nSee Also\nShowing a confirmation dialog with a message\nfunc confirmationDialog<S, A, M>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a string variable for the title.\nfunc confirmationDialog<A, M>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A, M, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a text view for the message.\nfunc confirmationDialog<S, A, M, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a string variable for the title.\nfunc confirmationDialog<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a localized string key for the title."
    },
    {
        "title": "alert(isPresented:error:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(ispresented:error:actions:message:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nerror\n\nAn optional localized Error that is used to generate the alert\u2019s title. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nmessage\n\nA view builder returning the message for the alert given the current error.\n\nDiscussion\n\nIn the example below, a form conditionally presents an alert depending upon the value of an error. When the error value isn\u2019t nil, the system presents an alert with an \u201cOK\u201d action.\n\nThe title of the alert is inferred from the error\u2019s errorDescription.\n\nstruct TicketPurchase: View {\n    @State private var error: TicketPurchaseError? = nil\n    @State private var showAlert = false\n\n\n    var body: some View {\n        TicketForm(showAlert: $showAlert, error: $error)\n            .alert(isPresented: $showAlert, error: error) { _ in\n                Button(\"OK\") {\n                    // Handle acknowledgement.\n                }\n            } message: { error in\n                Text(error.recoverySuggestion ?? \"Try again later.\")\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nSee Also\nPresenting an alert with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:)-46zbb",
        "html": "Parameters\ntitle\n\nA text string used as the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\nactions\n\nA view builder returning the dialog\u2019s actions.\n\nDiscussion\n\nIn the example below, a button conditionally presents a confirmation dialog depending upon the value of a bound Boolean variable. When the Boolean value is set to true, the system displays a confirmation dialog with a cancel action and a destructive action.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n    var title: String\n    var body: some View {\n        Button(\"Empty Trash\") {\n            isShowingDialog = true\n        }\n        .confirmationDialog(\n            title,\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Empty Trash\", role: .destructive) {\n                // Handle empty trash action.\n            }\n            Button(\"Cancel\", role: .cancel) {\n                isShowingDialog = false\n            }\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nSee Also\nGetting confirmation for an action\nfunc confirmationDialog<A>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a text view for the title.\nfunc confirmationDialog<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a localized string key for the title.\nfunc confirmationDialog<S, A, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a string variable for the title."
    },
    {
        "title": "dialogSeverity(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dialogseverity(_:)",
        "html": "Parameters\nseverity\n\nThe severity to use for confirmation dialogs and alerts.\n\nSee Also\nConfiguring a dialog\nfunc dialogIcon(Image?) -> some View\nConfigures the icon used by dialogs within this view.\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a default suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms."
    },
    {
        "title": "alert(_:isPresented:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:message:)-3rabc",
        "html": "Parameters\ntitle\n\nA text string used as the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nmessage\n\nA ViewBuilder returning the message for the alert.\n\nDiscussion\n\nIn the example below, a login form conditionally presents an alert by setting the didFail state variable. When the form sets the value to to true, the system displays an alert with an \u201cOK\u201d action.\n\nstruct Login: View {\n    @State private var didFail = false\n    let alertTitle: String = \"Login failed.\"\n\n\n    var body: some View {\n        LoginForm(didFail: $didFail)\n            .alert(\n                alertTitle,\n                isPresented: $didFail\n            ) {\n                Button(\"OK\") {\n                    // Handle the acknowledgement.\n                }\n            } message: {\n                Text(\"Please check your credentials and try again.\")\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nOnly unstyled text is supported for the message.\n\nSee Also\nPresenting an alert with a message\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present."
    },
    {
        "title": "alert(_:isPresented:presenting:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:)-4rhk6",
        "html": "Parameters\ntitle\n\nthe title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\ndata\n\nAn optional source of truth for the alert. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions given the currently available data.\n\nDiscussion\n\nFor the alert to appear, both isPresented must be true and data must not be nil. The data should not change after the presentation occurs. Any changes that you make after the presentation occurs are ignored.\n\nUse this method when you need to populate the fields of an alert with content from a data source. The example below shows a custom data source, SaveDetails, that provides data to populate the alert:\n\nstruct SaveDetails: Identifiable {\n    let name: String\n    let error: String\n    let id = UUID()\n}\n\n\nstruct SaveButton: View {\n    @State private var didError = false\n    @State private var details: SaveDetails?\n    let alertTitle: String = \"Save failed.\"\n\n\n        var body: some View {\n        Button(\"Save\") {\n            details = model.save(didError: $didError)\n        }\n        .alert(\n            Text(alertTitle),\n            isPresented: $didError,\n            presenting: details\n        ) { details in\n            Button(role: .destructive) {\n                // Handle the deletion.\n            } label: {\n                Text(\"Delete \\(details.name)\")\n            }\n            Button(\"Retry\") {\n                // Handle the retry action.\n            }\n        }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nPresenting an alert\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present."
    },
    {
        "title": "alert(isPresented:error:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(ispresented:error:actions:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nerror\n\nAn optional localized Error that is used to generate the alert\u2019s title. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nDiscussion\n\nIn the example below, a form conditionally presents an alert depending upon the value of an error. When the error value isn\u2019t nil, the system presents an alert with an \u201cOK\u201d action.\n\nThe title of the alert is inferred from the error\u2019s errorDescription.\n\nstruct TicketPurchase: View {\n    @State private var error: TicketPurchaseError? = nil\n    @State private var showAlert = false\n\n\n    var body: some View {\n        TicketForm(showAlert: $showAlert, error: $error)\n            .alert(isPresented: $showAlert, error: error) {\n                Button(\"OK\") {\n                    // Handle acknowledgement.\n                }\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nSee Also\nPresenting an alert\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title."
    },
    {
        "title": "isPresented",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/ispresented",
        "html": "Discussion\n\nYou can read this value like any of the other EnvironmentValues by creating a property with the Environment property wrapper:\n\n@Environment(\\.isPresented) private var isPresented\n\n\nRead the value inside a view if you need to know when SwiftUI presents that view. For example, you can take an action when SwiftUI presents a view by using the onChange(of:perform:) modifier:\n\n.onChange(of: isPresented) { isPresented in\n    if isPresented {\n        // Do something when first presented.\n    }\n}\n\n\nThis behaves differently than onAppear(perform:), which SwiftUI can call more than once for a given presentation, like when you navigate back to a view that\u2019s already in the navigation hierarchy.\n\nTo dismiss the currently presented view, use dismiss.\n\nSee Also\nDismissing a presentation\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nstruct DismissAction\nAn action that dismisses a presentation.\nfunc interactiveDismissDisabled(Bool) -> some View\nConditionally prevents interactive dismissal of presentations like popovers, sheets, and inspectors."
    },
    {
        "title": "FileDialogBrowserOptions",
        "url": "https://developer.apple.com/documentation/swiftui/filedialogbrowseroptions",
        "html": "Overview\n\nApply the options using the fileDialogBrowserOptions(_:) modifier.\n\nTopics\nGetting browser options\nstatic let displayFileExtensions: FileDialogBrowserOptions\nOn iOS, configures the fileExporter, fileImporter, or fileMover to show or hide file extensions. Default behavior is to hide them. On macOS, this option has no effect.\nstatic let enumeratePackages: FileDialogBrowserOptions\nAllows enumerating packages contents in contrast to the default behavior when packages are represented flatly, similar to files.\nstatic let includeHiddenFiles: FileDialogBrowserOptions\nDisplays the files that are hidden by default.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs."
    },
    {
        "title": "inspector(isPresented:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/inspector(ispresented:content:)",
        "html": "Parameters\nisPresented\n\nA binding to Bool controlling the presented state.\n\ncontent\n\nThe inspector content.\n\nDiscussion\n\nApply this modifier to declare an inspector with a context-dependent presentation. For example, an inspector can present as a trailing column in a horizontally regular size class, but adapt to a sheet in a horizontally compact size class.\n\nstruct ShapeEditor: View {\n    @State var presented: Bool = false\n    var body: some View {\n        MyEditorView()\n            .inspector(isPresented: $presented) {\n                TextTraitsInspectorView()\n            }\n    }\n}\n\n\nNote\n\nTrailing column inspectors have their presentation state restored by the framework.\n\nSee Also\n\nInspectorCommands for including the default inspector commands and keyboard shortcuts.\n\nSee Also\nPresenting an inspector\nfunc inspectorColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the inspector containing this view when presented as a trailing column.\nfunc inspectorColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the inspector in a trailing-column presentation."
    },
    {
        "title": "inspectorColumnWidth(min:ideal:max:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/inspectorcolumnwidth(min:ideal:max:)",
        "html": "Parameters\nmin\n\nThe minimum allowed width for the trailing column inspector\n\nideal\n\nThe initial width of the inspector in the absence of state restoration. ideal influences the resulting width on macOS when a user double-clicks the divider on the leading edge of the inspector. clicks a divider to readjust\n\nmax\n\nThe maximum allowed width for the trailing column inspector\n\nDiscussion\n\nApply this modifier on the content of a inspector(isPresented:content:) to specify a preferred flexible width for the column. Use inspectorColumnWidth(_:) if you need to specify a fixed width.\n\nThe following example shows an editor interface with an inspector, which when presented as a trailing-column, has a preferred width of 225 points, maximum of 400, and a minimum of 150 at which point it will collapse, if allowed.\n\nMyEditorView()\n    .inspector {\n        TextTraitsInspectorView()\n            .inspectorColumnWidth(min: 150, ideal: 225, max: 400)\n    }\n\n\nOnly some platforms enable flexible inspector columns. If you specify a width that the current presentation environment doesn\u2019t support, SwiftUI may use a different width for your column.\n\nSee Also\nPresenting an inspector\nfunc inspector<V>(isPresented: Binding<Bool>, content: () -> V) -> some View\nInserts an inspector at the applied position in the view hierarchy.\nfunc inspectorColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the inspector containing this view when presented as a trailing column."
    },
    {
        "title": "fileDialogURLEnabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogurlenabled(_:)",
        "html": "Parameters\npredicate\n\nThe predicate that evaluates the URLs presented to the user to conditionally disable them. The implementation is expected to have constant complexity and should not access the files contents or metadata. A common use case is inspecting the path or the file name.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "inspectorColumnWidth(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/inspectorcolumnwidth(_:)",
        "html": "Parameters\nwidth\n\nThe preferred fixed width for the inspector if presented as a trailing column.\n\nDiscussion\n\nApply this modifier on the content of a inspector(isPresented:content:) to specify a fixed preferred width for the trailing column. Use navigationSplitViewColumnWidth(min:ideal:max:) if you need to specify a flexible width.\n\nThe following example shows an editor interface with an inspector, which when presented as a trailing-column, has a fixed width of 225 points. The example also uses interactiveDismissDisabled(_:) to prevent the inspector from being collapsed by user action like dragging a divider.\n\nMyEditorView()\n    .inspector {\n        TextTraitsInspectorView()\n            .inspectorColumnWidth(225)\n            .interactiveDismissDisabled()\n    }\n\n\nNote\n\nA fixed width does not prevent the user collapsing the inspector on macOS. See interactiveDismissDisabled(_:).\n\nSee Also\nPresenting an inspector\nfunc inspector<V>(isPresented: Binding<Bool>, content: () -> V) -> some View\nInserts an inspector at the applied position in the view hierarchy.\nfunc inspectorColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the inspector in a trailing-column presentation."
    },
    {
        "title": "PopoverAttachmentAnchor",
        "url": "https://developer.apple.com/documentation/swiftui/popoverattachmentanchor",
        "html": "Topics\nGetting attachment anchors\ncase point(UnitPoint)\nThe anchor point for the popover expressed as a unit point that describes possible alignments relative to a SwiftUI view.\ncase rect(Anchor<CGRect>.Source)\nThe anchor point for the popover relative to the source\u2019s frame.\nSee Also\nShowing a sheet, cover, or popover\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content."
    },
    {
        "title": "fileDialogMessage(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogmessage(_:)-241kc",
        "html": "Parameters\nmessage\n\nThe optional text to use as the file dialog message.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileDialogMessage(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogmessage(_:)-9t0fs",
        "html": "Parameters\nmessage\n\nThe string to use as the file dialog message.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileDialogCustomizationID(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogcustomizationid(_:)",
        "html": "Parameters\nid\n\nAn identifier of the configuration.\n\nDiscussion\n\nAmong other parameters, it stores the current directory, view style (e.g., Icons, List, Columns), recent places, and expanded window size. It enables a refined user experience; for example, when importing an image, the user might switch to the Icons view, but the List view could be more convenient in another context. The file dialog stores these settings and applies them every time before presenting the panel. If not provided, on every launch, the file dialog uses the default configuration.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileDialogConfirmationLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogconfirmationlabel(_:)-6he2o",
        "html": "Parameters\nlabelKey\n\nThe key to a localized string to display.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileDialogDefaultDirectory(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogdefaultdirectory(_:)",
        "html": "Parameters\ndefaultDirectory\n\nThe directory to show when the system file dialog launches. If the given file dialog has a fileDialogCustomizationID if stores the user-chosen directory and subsequently opens with it, ignoring the default value provided in this modifier.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileDialogImportsUnresolvedAliases(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogimportsunresolvedaliases(_:)",
        "html": "Parameters\nimports\n\nA Boolean value that indicates if the application receives unresolved or resolved URLs when a user chooses aliases.\n\nDiscussion\n\nBy default, file dialogs resolve aliases and provide the URL of the item referred to by the chosen alias. This modifier allows control of this behavior: pass true if the application doesn\u2019t want file dialog to resolve aliases.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileDialogConfirmationLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogconfirmationlabel(_:)-8nit5",
        "html": "Parameters\nlabel\n\nThe optional text to use as the label for the confirmation button.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileDialogConfirmationLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogconfirmationlabel(_:)-181fc",
        "html": "Parameters\nlabel\n\nThe string to use as the label for the confirmation button.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "fileExporterFilenameLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporterfilenamelabel(_:)-5yyjd",
        "html": "Parameters\nlabel\n\nThe optional text to use as the label for the file name field.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileExporter(isPresented:items:contentTypes:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:items:contenttypes:oncompletion:oncancellation:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\nitems\n\nCollection of values to be saved on disk.\n\ncontentTypes\n\nThe content types to use for the exported file. If empty, SwiftUI uses the content types from the transferRepresentation property provided for Transferable conformance.\n\nallowsOtherContentTypes\n\nA Boolean value that indicates if the users are allowed to save the files with a different file extension than specified by the contentType property.\n\nonCompletion\n\nA callback that will be invoked when the operation has has succeeded or failed.\n\nonCancellation\n\nA callback that will be invoked if the operation was cancelled.\n\nDiscussion\n\nIn order for the interface to appear isPresented must be set to true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileMover(isPresented:files:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:files:oncompletion:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\nfiles\n\nA collection of URLs for the files to be moved.\n\nonCompletion\n\nA callback that will be invoked when the operation has has succeeded or failed. To access the received URLs, call startAccessingSecurityScopedResource. When the access is no longer required, call stopAccessingSecurityScopedResource.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nNote\n\nThis interface provides security-scoped URLs. Call the startAccessingSecurityScopedResource method to access or bookmark the URLs, and the stopAccessingSecurityScopedResource method to release the access.\n\nIn order for the interface to appear, both isPresented must be true and files must not be empty. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nSee Also\nMoving a file\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move an existing file to a new location.\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move a collection of existing files to a new location."
    },
    {
        "title": "fileExporterFilenameLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporterfilenamelabel(_:)-55aqy",
        "html": "Parameters\nlabelKey\n\nThe key to a localized string to display.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileImporter(isPresented:allowedContentTypes:allowsMultipleSelection:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileimporter(ispresented:allowedcontenttypes:allowsmultipleselection:oncompletion:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\nallowedContentTypes\n\nThe list of supported content types which can be imported.\n\nallowsMultipleSelection\n\nWhether the importer allows the user to select more than one file to import.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. To access the received URLs, call startAccessingSecurityScopedResource. When the access is no longer required, call stopAccessingSecurityScopedResource.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nIn order for the interface to appear, isPresented must be true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nNote\n\nThis dialog provides security-scoped URLs. Call the startAccessingSecurityScopedResource method to access or bookmark the URLs, and the stopAccessingSecurityScopedResource method to release the access.\n\nFor example, a button that allows the user to choose multiple PDF files for the application to combine them later, might look like this:\n\n   struct PickPDFsButton: View {\n       @State private var showFileImporter = false\n       var handlePickedPDF: (URL) -> Void\n\n\n       var body: some View {\n           Button {\n               showFileImporter = true\n           } label: {\n               Label(\"Choose PDFs to combine\", systemImage: \"doc.circle\")\n           }\n           .fileImporter(\n               isPresented: $showFileImporter,\n               allowedContentTypes: [.pdf],\n               allowsMultipleSelection: true\n           ) { result in\n               switch result {\n               case .success(let files):\n                   files.forEach { file in\n                       // gain access to the directory\n                       let gotAccess = file.startAccessingSecurityScopedResource()\n                       if !gotAccess { return }\n                       // access the directory URL\n                       // (read templates in the directory, make a bookmark, etc.)\n                       handlePickedPDF(file)\n                       // release access\n                       file.stopAccessingSecurityScopedResource()\n                   }\n               case .failure(let error):\n                   // handle error\n                   print(error)\n               }\n           }\n       }\n   }\n\n\nNote\n\nChanging allowedContentTypes or allowsMultipleSelection while the file importer is presented will have no immediate effect, however will apply the next time it is presented.\n\nSee Also\nImporting from file\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import an existing file.\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to import multiple files."
    },
    {
        "title": "fileExporter(isPresented:item:contentTypes:defaultFilename:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:item:contenttypes:defaultfilename:oncompletion:oncancellation:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\nitem\n\nThe item to be saved on disk.\n\ncontentTypes\n\nThe optional content types to use for the exported file. If empty, SwiftUI uses the content types from the transferRepresentation property provided for Transferable conformance.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed.\n\nonCancellation\n\nA callback that will be invoked if the operation was cancelled.\n\nDiscussion\n\nIn order for the interface to appear isPresented must be set to true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileExporter(isPresented:document:contentTypes:defaultFilename:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:document:contenttypes:defaultfilename:oncompletion:oncancellation:)-34bd6",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\ndocument\n\nThe in-memory document to export.\n\ncontentTypes\n\nThe list of supported content types which can be exported. If not provided, FileDocument.writableContentTypes are used.\n\ndefaultFilename\n\nIf provided, the default name to use for the exported file, which will the user will have an opportunity to edit prior to the export.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. The result indicates whether the operation succeeded or failed.\n\nonCancellation\n\nA callback that will be invoked if the user cancels the operation.\n\nDiscussion\n\nIn order for the interface to appear, isPresented must be true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCancellation will be called.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileExporter(isPresented:documents:contentTypes:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:documents:contenttypes:oncompletion:oncancellation:)-7x5vd",
        "html": "Parameters\nisPresented\n\nA binding to whether the dialog should be shown.\n\ndocuments\n\nThe in-memory documents to export.\n\ncontentTypes\n\nThe list of supported content types which can be exported. If not provided, FileDocument.writableContentTypes are used.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. The result indicates whether the operation succeeded or failed.\n\nonCancellation\n\nA callback that will be invoked if the user cancels the operation.\n\nDiscussion\n\nIn order for the dialog to appear, isPresented must be true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCancellation will be called.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileExporter(isPresented:document:contentTypes:defaultFilename:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:document:contenttypes:defaultfilename:oncompletion:oncancellation:)-8l8pz",
        "html": "Parameters\nisPresented\n\nA binding to whether the dialog should be shown.\n\ndocument\n\nThe in-memory document to export.\n\ncontentTypes\n\nThe list of supported content types which can be exported. If not provided, ReferenceFileDocument.writableContentTypes are used.\n\ndefaultFilename\n\nIf provided, the default name to use for the exported file, which will the user will have an opportunity to edit prior to the export.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. The result indicates whether the operation succeeded or failed.\n\nonCancellation\n\nA callback that will be invoked if the user cancels the operation.\n\nDiscussion\n\nIn order for the dialog to appear, isPresented must be true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCancellation will be called.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileExporter(isPresented:documents:contentType:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:documents:contenttype:oncompletion:)-974w2",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\ndocuments\n\nThe collection of in-memory documents to export.\n\ncontentType\n\nThe content type to use for the exported file.\n\nonCompletion\n\nA callback that will be invoked when the operation has has succeeded or failed.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and documents must not be empty. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nThe contentType provided must be included within the document type\u2019s writableContentTypes, otherwise the first valid writable content type will be used instead.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "ModifiedContent",
        "url": "https://developer.apple.com/documentation/swiftui/modifiedcontent",
        "html": "Topics\nCreating a modified content view\ninit(content: Content, modifier: Modifier)\nA structure that the defines the content and modifier needed to produce a new view or view modifier.\nvar content: Content\nThe content that the modifier transforms into a new view or new view modifier.\nvar modifier: Modifier\nThe view modifier.\nInstance Methods\nfunc accessibility(activationPoint: CGPoint) -> ModifiedContent<Content, Modifier>\nSpecifies the point where activations occur in the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(activationPoint: UnitPoint) -> ModifiedContent<Content, Modifier>\nSpecifies the unit point where activations occur in the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(addTraits: AccessibilityTraits) -> ModifiedContent<Content, Modifier>\nAdds the given traits to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(hidden: Bool) -> ModifiedContent<Content, Modifier>\nSpecifies whether to hide this view from system accessibility features.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(hint: Text) -> ModifiedContent<Content, Modifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(identifier: String) -> ModifiedContent<Content, Modifier>\nUses the specified string to identify the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(inputLabels: [Text]) -> ModifiedContent<Content, Modifier>\nSets alternate input labels with which users identify a view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(label: Text) -> ModifiedContent<Content, Modifier>\nAdds a label to the view that describes its contents.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(removeTraits: AccessibilityTraits) -> ModifiedContent<Content, Modifier>\nRemoves the given traits from this view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(selectionIdentifier: AnyHashable) -> ModifiedContent<Content, Modifier>\nSets a selection identifier for this view\u2019s accessibility element.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(sortPriority: Double) -> ModifiedContent<Content, Modifier>\nSets the sort priority order for this view\u2019s accessibility element, relative to other elements at the same level.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibility(value: Text) -> ModifiedContent<Content, Modifier>\nAdds a textual description of the value that the view contains.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nDeprecated\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Content, Modifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Content, Modifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Content, Modifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Content, Modifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Content, Modifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Content, Modifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityAddTraits(AccessibilityTraits) -> ModifiedContent<Content, Modifier>\nAdds the given traits to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Content, Modifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Content, Modifier>\nAdd additional accessibility information to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Content, Modifier>\nAdd additional accessibility information to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Content, Modifier>\nAdd additional accessibility information to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Content, Modifier>\nAdd additional accessibility information to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Content, Modifier>\nAdd additional accessibility information to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Content, Modifier>\nAdd additional accessibility information to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Content, Modifier>\nAdd additional accessibility information to the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Content, Modifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityHeading(AccessibilityHeadingLevel) -> ModifiedContent<Content, Modifier>\nSet the level of this heading.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityHidden(Bool) -> ModifiedContent<Content, Modifier>\nSpecifies whether to hide this view from system accessibility features.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityHint(LocalizedStringKey) -> ModifiedContent<Content, Modifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityHint(Text) -> ModifiedContent<Content, Modifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityHint<S>(S) -> ModifiedContent<Content, Modifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityIdentifier(String) -> ModifiedContent<Content, Modifier>\nUses the string you specify to identify the view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Content, Modifier>\nSets alternate input labels with which users identify a view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Content, Modifier>\nSets alternate input labels with which users identify a view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Content, Modifier>\nSets alternate input labels with which users identify a view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Content, Modifier>\nAdds a label to the view that describes its contents.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityLabel(Text) -> ModifiedContent<Content, Modifier>\nAdds a label to the view that describes its contents.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Content, Modifier>\nAdds a label to the view that describes its contents.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityRemoveTraits(AccessibilityTraits) -> ModifiedContent<Content, Modifier>\nRemoves the given traits from this view.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityRespondsToUserInteraction(Bool) -> ModifiedContent<Content, Modifier>\nExplicitly set whether this Accessibility element responds to user interaction and would thus be interacted with by technologies such as Switch Control, Voice Control or Full Keyboard Access.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Content, Modifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilitySortPriority(Double) -> ModifiedContent<Content, Modifier>\nSets the sort priority order for this view\u2019s accessibility element, relative to other elements at the same level.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityTextContentType(AccessibilityTextContentType) -> ModifiedContent<Content, Modifier>\nSets an accessibility text content type.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityValue(Text) -> ModifiedContent<Content, Modifier>\nAdds a textual description of the value that the view contains.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityValue(LocalizedStringKey) -> ModifiedContent<Content, Modifier>\nAdds a textual description of the value that the view contains.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityValue<S>(S) -> ModifiedContent<Content, Modifier>\nAdds a textual description of the value that the view contains.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Content, Modifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nAvailable when Modifier is AccessibilityAttachmentModifier.\nRelationships\nConforms To\nDynamicTableRowContent\nConforms when Content conforms to DynamicTableRowContent and Modifier conforms to _TableRowContentModifier.\nDynamicViewContent\nConforms when Content conforms to DynamicViewContent and Modifier conforms to ViewModifier.\nEquatable\nScene\nConforms when Content conforms to Scene and Modifier conforms to _SceneModifier.\nTableRowContent\nConforms when Content conforms to TableRowContent and Modifier conforms to _TableRowContentModifier.\nView\nConforms when Content conforms to View and Modifier conforms to ViewModifier.\nViewModifier\nConforms when Content conforms to ViewModifier and Modifier conforms to ViewModifier.\nSee Also\nModifying a view\nConfiguring views\nAdjust the characteristics of a view by applying view modifiers.\nReducing view modifier maintenance\nBundle view modifiers that you regularly reuse into a custom view modifier.\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nprotocol ViewModifier\nA modifier that you apply to a view or another view modifier, producing a different version of the original value.\nAvailable when Content conforms to ViewModifier and Modifier conforms to ViewModifier.\nstruct EmptyModifier\nAn empty, or identity, modifier, used during development to switch modifiers at compile time.\nprotocol EnvironmentalModifier\nA modifier that must resolve to a concrete modifier in an environment before use."
    },
    {
        "title": "fileExporter(isPresented:document:contentType:defaultFilename:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:document:contenttype:defaultfilename:oncompletion:)-9tpsm",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\ndocument\n\nThe in-memory document to export.\n\ncontentType\n\nThe content type to use for the exported file.\n\ndefaultFilename\n\nIf provided, the default name to use for the exported file, which will the user will have an opportunity to edit prior to the export.\n\nonCompletion\n\nA callback that will be invoked when the operation has has succeeded or failed.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and document must not be nil. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nThe contentType provided must be included within the document type\u2019s writableContentTypes, otherwise the first valid writable content type will be used instead.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileExporter(isPresented:documents:contentType:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:documents:contenttype:oncompletion:)-6xyj7",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\ndocuments\n\nThe collection of in-memory documents to export.\n\ncontentType\n\nThe content type to use for the exported file.\n\nonCompletion\n\nA callback that will be invoked when the operation has has succeeded or failed.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and documents must not be empty. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nThe contentType provided must be included within the document type\u2019s writableContentTypes, otherwise the first valid writable content type will be used instead.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "fileExporter(isPresented:document:contentType:defaultFilename:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:document:contenttype:defaultfilename:oncompletion:)-32vwk",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\ndocument\n\nThe in-memory document to export.\n\ncontentType\n\nThe content type to use for the exported file.\n\ndefaultFilename\n\nIf provided, the default name to use for the exported file, which will the user will have an opportunity to edit prior to the export.\n\nonCompletion\n\nA callback that will be invoked when the operation has has succeeded or failed.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and document must not be nil. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nThe contentType provided must be included within the document type\u2019s writableContentTypes, otherwise the first valid writable content type will be used instead.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field."
    },
    {
        "title": "EnvironmentValues",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues",
        "html": "Overview\n\nSwiftUI exposes a collection of values to your app\u2019s views in an EnvironmentValues structure. To read a value from the structure, declare a property using the Environment property wrapper and specify the value\u2019s key path. For example, you can read the current locale:\n\n@Environment(\\.locale) var locale: Locale\n\n\nUse the property you declare to dynamically control a view\u2019s layout. SwiftUI automatically sets or updates many environment values, like pixelLength, scenePhase, or locale, based on device characteristics, system state, or user settings. For others, like lineLimit, SwiftUI provides a reasonable default value.\n\nYou can set or override some values using the environment(_:_:) view modifier:\n\nMyView()\n    .environment(\\.lineLimit, 2)\n\n\nThe value that you set affects the environment for the view that you modify \u2014 including its descendants in the view hierarchy \u2014 but only up to the point where you apply a different environment modifier.\n\nSwiftUI provides dedicated view modifiers for setting some values, which typically makes your code easier to read. For example, rather than setting the lineLimit value directly, as in the previous example, you should instead use the lineLimit(_:) modifier:\n\nMyView()\n    .lineLimit(2)\n\n\nIn some cases, using a dedicated view modifier provides additional functionality. For example, you must use the preferredColorScheme(_:) modifier rather than setting colorScheme directly to ensure that the new value propagates up to the presenting container when presenting a view like a popover:\n\nMyView()\n    .popover(isPresented: $isPopped) {\n        PopoverContent()\n            .preferredColorScheme(.dark)\n    }\n\n\nCreate custom environment values by defining a type that conforms to the EnvironmentKey protocol, and then extending the environment values structure with a new property. Use your key to get and set the value, and provide a dedicated modifier for clients to use when setting the value:\n\nprivate struct MyEnvironmentKey: EnvironmentKey {\n    static let defaultValue: String = \"Default value\"\n}\n\n\nextension EnvironmentValues {\n    var myCustomValue: String {\n        get { self[MyEnvironmentKey.self] }\n        set { self[MyEnvironmentKey.self] = newValue }\n    }\n}\n\n\nextension View {\n    func myCustomValue(_ myCustomValue: String) -> some View {\n        environment(\\.myCustomValue, myCustomValue)\n    }\n}\n\n\nClients of your value then access the value in the usual way, reading it with the Environment property wrapper, and setting it with the myCustomValue view modifier.\n\nTopics\nCreating and accessing values\ninit()\nCreates an environment values instance.\nsubscript<K>(K.Type) -> K.Value\nAccesses the environment value associated with a custom key.\nsubscript<T>(T.Type) -> T?\nReads an observable object of the specified type from the environment.\nsubscript<K>(K.Type) -> K.Value\nAccesses the environment value associated with a custom key.\nvar description: String\nA string that represents the contents of the environment values instance.\nAccessibility\nvar accessibilityDimFlashingLights: Bool\nWhether the setting to reduce flashing or strobing lights in video content is on. This setting can also be used to determine if UI in playback controls should be shown to indicate upcoming content that includes flashing or strobing lights.\nvar accessibilityDifferentiateWithoutColor: Bool\nWhether the system preference for Differentiate without Color is enabled.\nvar accessibilityEnabled: Bool\nA Boolean value that indicates whether the user has enabled an assistive technology.\nvar accessibilityInvertColors: Bool\nWhether the system preference for Invert Colors is enabled.\nvar accessibilityLargeContentViewerEnabled: Bool\nWhether the Large Content Viewer is enabled.\nvar accessibilityPlayAnimatedImages: Bool\nWhether the setting for playing animations in an animated image is on. When this value is false, any presented image that contains animation should not play automatically.\nvar accessibilityPrefersHeadAnchorAlternative: Bool\nWhether the system setting to prefer alternatives to head-anchored content is on.\nBeta\nvar accessibilityQuickActionsEnabled: Bool\nA Boolean that indicates whether the quick actions feature is enabled.\nvar accessibilityReduceMotion: Bool\nWhether the system preference for Reduce Motion is enabled.\nvar accessibilityReduceTransparency: Bool\nWhether the system preference for Reduce Transparency is enabled.\nvar accessibilityShowButtonShapes: Bool\nWhether the system preference for Show Button Shapes is enabled.\nvar accessibilitySwitchControlEnabled: Bool\nA Boolean value that indicates whether the Switch Control motor accessibility feature is in use.\nvar accessibilityVoiceOverEnabled: Bool\nA Boolean value that indicates whether the VoiceOver screen reader is in use.\nvar legibilityWeight: LegibilityWeight?\nThe font weight to apply to text.\nActions\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nvar dismissWindow: DismissWindowAction\nA window dismissal action stored in a view\u2019s environment.\nvar openImmersiveSpace: OpenImmersiveSpaceAction\nAn action that presents an immersive space.\nBeta\nvar dismissImmersiveSpace: DismissImmersiveSpaceAction\nAn immersive space dismissal action stored in a view\u2019s environment.\nBeta\nvar newDocument: NewDocumentAction\nAn action in the environment that presents a new document.\nvar openDocument: OpenDocumentAction\nAn action in the environment that presents an existing document.\nvar openURL: OpenURLAction\nAn action that opens a URL.\nvar openWindow: OpenWindowAction\nA window presentation action stored in a view\u2019s environment.\nvar purchase: PurchaseAction\nAn action that starts an in-app purchase.\nvar refresh: RefreshAction?\nA refresh action stored in a view\u2019s environment.\nvar rename: RenameAction?\nAn action that activates the standard rename interaction.\nvar resetFocus: ResetFocusAction\nAn action that requests the focus system to reevaluate default focus.\nAuthentication\nvar authorizationController: AuthorizationController\nA value provided in the SwiftUI environment that views can use to perform authorization requests.\nvar webAuthenticationSession: WebAuthenticationSession\nA value provided in the SwiftUI environment that views can use to authenticate a user through a web service.\nControls and input\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nvar controlSize: ControlSize\nThe size to apply to controls within a view.\nvar controlActiveState: ControlActiveState\nThe active state of controls in the view.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nvar menuIndicatorVisibility: Visibility\nThe menu indicator visibility to apply to controls within a view.\nvar menuOrder: MenuOrder\nThe preferred order of items for menus presented from this view.\nvar searchSuggestionsPlacement: SearchSuggestionsPlacement\nThe current placement of search suggestions.\nDisplay characteristics\nvar colorScheme: ColorScheme\nThe color scheme of this environment.\nvar colorSchemeContrast: ColorSchemeContrast\nThe contrast associated with the color scheme of this environment.\nvar displayScale: CGFloat\nThe display scale of this environment.\nvar horizontalSizeClass: UserInterfaceSizeClass?\nThe horizontal size class of this environment.\nvar imageScale: Image.Scale\nThe image scale for this environment.\nvar pixelLength: CGFloat\nThe size of a pixel on the screen.\nvar sidebarRowSize: SidebarRowSize\nThe current size of sidebar rows.\nvar verticalSizeClass: UserInterfaceSizeClass?\nThe vertical size class of this environment.\nGlobal objects\nvar calendar: Calendar\nThe current calendar that views should use when handling dates.\nvar documentConfiguration: DocumentConfiguration?\nThe configuration of a document in a DocumentGroup.\nvar locale: Locale\nThe current locale that views should use.\nvar managedObjectContext: NSManagedObjectContext\nvar modelContext: ModelContext\nThe SwiftData model context that will be used for queries and other model operations within this environment.\nvar timeZone: TimeZone\nThe current time zone that views should use when handling dates.\nvar undoManager: UndoManager?\nThe undo manager used to register a view\u2019s undo operations.\nScrolling\nvar isScrollEnabled: Bool\nA Boolean value that indicates whether any scroll views associated with this environment allow scrolling to occur.\nvar horizontalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visibility to apply to scroll indicators of any horizontally scrollable content.\nvar verticalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visiblity to apply to scroll indicators of any vertically scrollable content.\nvar scrollDismissesKeyboardMode: ScrollDismissesKeyboardMode\nThe way that scrollable content interacts with the software keyboard.\nvar horizontalScrollBounceBehavior: ScrollBounceBehavior\nThe scroll bounce mode for the horizontal axis of scrollable views.\nvar verticalScrollBounceBehavior: ScrollBounceBehavior\nThe scroll bounce mode for the vertical axis of scrollable views.\nState\nvar editMode: Binding<EditMode>?\nAn indication of whether the user can edit the contents of a view associated with this environment.\nvar isActivityFullscreen: Bool\nA Boolean value that indicates whether the Live Activity appears in a full-screen presentation.\nvar isEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows user interaction.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed.\nvar isLuminanceReduced: Bool\nA Boolean value that indicates whether the display or environment currently requires reduced luminance.\nvar isPresented: Bool\nA Boolean value that indicates whether the view associated with this environment is currently presented.\nvar isSceneCaptured: Bool\nThe current capture state.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar scenePhase: ScenePhase\nThe current phase of the scene.\nvar supportsMultipleWindows: Bool\nA Boolean value that indicates whether the current platform supports opening multiple windows.\nStoreKit configuration\nvar displayStoreKitMessage: DisplayMessageAction\nvar requestReview: RequestReviewAction\nText styles\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nvar dynamicTypeSize: DynamicTypeSize\nThe current Dynamic Type size.\nvar font: Font?\nThe default font of this environment.\nvar layoutDirection: LayoutDirection\nThe layout direction associated with the current environment.\nvar lineLimit: Int?\nThe maximum number of lines that text can occupy in a view.\nvar lineSpacing: CGFloat\nThe distance in points between the bottom of one line fragment and the top of the next.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nvar multilineTextAlignment: TextAlignment\nAn environment value that indicates how a text view aligns its lines when the content wraps or contains newlines.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nView attributes\nvar allowedDynamicRange: Image.DynamicRange?\nThe allowed dynamic range for the view, or nil.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nvar backgroundProminence: BackgroundProminence\nThe prominence of the background underneath views associated with this environment.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nvar badgeProminence: BadgeProminence\nThe prominence to apply to badges associated with this environment.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nvar defaultMinListHeaderHeight: CGFloat?\nThe default minimum height of a header in a list.\nvar defaultMinListRowHeight: CGFloat\nThe default minimum height of a row in a list.\nvar isFocusEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows focus effects to be displayed.\nvar headerProminence: Prominence\nThe prominence to apply to section headers within a view.\nvar physicalMetrics: PhysicalMetricsConverter\nThe physical metrics associated with a scene.\nBeta\nvar realityKitScene: Scene?\nBeta\nvar redactionReasons: RedactionReasons\nThe current redaction reasons applied to the view hierarchy.\nvar springLoadingBehavior: SpringLoadingBehavior\nThe behavior of spring loaded interactions for the views associated with this environment.\nvar symbolRenderingMode: SymbolRenderingMode?\nThe current symbol rendering mode, or nil denoting that the mode is picked automatically using the current image and foreground style as parameters.\nvar symbolVariants: SymbolVariants\nThe symbol variant to use in this environment.\nWidgets\nvar showsWidgetContainerBackground: Bool\nAn environment variable that indicates whether the background of a widget appears.\nvar showsWidgetLabel: Bool\nA Boolean value that indicates whether an accessory family widget can display an accessory label.\nvar widgetFamily: WidgetFamily\nThe template of the widget \u2014 small, medium, or large.\nvar widgetRenderingMode: WidgetRenderingMode\nThe widget\u2019s rendering mode, based on where the system is displaying it.\nvar widgetContentMargins: EdgeInsets\nA property that identifies the content margins of a widget.\nDeprecated environment values\nvar disableAutocorrection: Bool?\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nvar sizeCategory: ContentSizeCategory\nThe size of content.\nDeprecated\nvar presentationMode: Binding<PresentationMode>\nA binding to the current presentation mode of the view associated with this environment.\nDeprecated\nstruct PresentationMode\nAn indication whether a view is currently presented by another view.\nDeprecated\nInstance Properties\nvar devicePickerSupports: DevicePickerSupportedAction\nChecks for support to present a DevicePicker.\nRelationships\nConforms To\nCustomStringConvertible\nSee Also\nAccessing environment values\nstruct Environment\nA property wrapper that reads a value from a view\u2019s environment."
    },
    {
        "title": "ViewModifier",
        "url": "https://developer.apple.com/documentation/swiftui/viewmodifier",
        "html": "Overview\n\nAdopt the ViewModifier protocol when you want to create a reusable modifier that you can apply to any view. The example below combines several modifiers to create a new modifier that you can use to create blue caption text surrounded by a rounded rectangle:\n\nstruct BorderedCaption: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.caption2)\n            .padding(10)\n            .overlay(\n                RoundedRectangle(cornerRadius: 15)\n                    .stroke(lineWidth: 1)\n            )\n            .foregroundColor(Color.blue)\n    }\n}\n\n\nYou can apply modifier(_:) directly to a view, but a more common and idiomatic approach uses modifier(_:) to define an extension to View itself that incorporates the view modifier:\n\nextension View {\n    func borderedCaption() -> some View {\n        modifier(BorderedCaption())\n    }\n}\n\n\nYou can then apply the bordered caption to any view, similar to this:\n\nImage(systemName: \"bus\")\n    .resizable()\n    .frame(width:50, height:50)\nText(\"Downtown Bus\")\n    .borderedCaption()\n\n\nTopics\nCreating a view modifier\nfunc body(content: Self.Content) -> Self.Body\nGets the current body of the caller.\n\nRequired Default implementation provided.\n\nassociatedtype Body : View\nThe type of view representing the body.\n\nRequired\n\ntypealias Content\nThe content view type passed to body().\nAdding animations to a view\nfunc animation(Animation?) -> some ViewModifier\nReturns a new version of the modifier that will apply animation to all animatable values within the modifier.\nfunc concat<T>(T) -> ModifiedContent<Self, T>\nReturns a new modifier that is the result of concatenating self with modifier.\nHandling view taps and gestures\nfunc transaction((inout Transaction) -> Void) -> some ViewModifier\nReturns a new version of the modifier that will apply the transaction mutation function transform to all transactions within the modifier.\nRelationships\nInherited By\nAnimatableModifier\nEnvironmentalModifier\nGeometryEffect\nConforming Types\nAccessibilityAttachmentModifier\nEmptyModifier\nModifiedContent\nConforms when Content conforms to ViewModifier and Modifier conforms to ViewModifier.\nSee Also\nModifying a view\nConfiguring views\nAdjust the characteristics of a view by applying view modifiers.\nReducing view modifier maintenance\nBundle view modifiers that you regularly reuse into a custom view modifier.\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nstruct EmptyModifier\nAn empty, or identity, modifier, used during development to switch modifiers at compile time.\nstruct ModifiedContent\nA value with a modifier applied to it.\nAvailable when Content conforms to ViewModifier and Modifier conforms to ViewModifier.\nprotocol EnvironmentalModifier\nA modifier that must resolve to a concrete modifier in an environment before use."
    },
    {
        "title": "Configuring views",
        "url": "https://developer.apple.com/documentation/swiftui/configuring-views",
        "html": "Overview\n\nIn SwiftUI, you assemble views into a hierarchy that describes your app\u2019s user interface. To help you customize the appearance and behavior of your app\u2019s views, you use view modifiers. For example, you can use modifiers to:\n\nAdd accessibility features to a view.\n\nAdjust a view\u2019s styling, layout, and other appearance characteristics.\n\nRespond to events, like copy and paste.\n\nConditionally present modal views, like popovers.\n\nConfigure supporting views, like toolbars.\n\nBecause view modifiers are Swift methods with behavior provided by the View protocol, you can apply them to any type that conforms to the View protocol. That includes built-in views like Text, Image, and Button, as well as views that you define.\n\nConfigure a view with a modifier\n\nLike other Swift methods, a modifier operates on an instance \u2014 a view of some kind in this case \u2014 and can optionally take input parameters. For example, you can apply the foregroundColor(_:) modifier to set the color of a Text view:\n\nText(\"Hello, World!\")\n    .foregroundColor(.red) // Display red text.\n\n\nModifiers return a view that wraps the original view and replaces it in the view hierarchy. You can think of the two lines in the example above as resolving to a single view that displays red text.\n\nWhile the code above follows the rules of Swift, the code\u2019s structure might be unfamiliar for developers new to SwiftUI. SwiftUI uses a declarative approach, where you declare and configure a view at the point in your code that corresponds to the view\u2019s position in the view hierarchy. For more information, see Declaring a custom view.\n\nChain modifiers to achieve complex effects\n\nYou commonly chain modifiers, each wrapping the result of the previous one, by calling them one after the other. For example, you can wrap a text view in an invisible box with a given width using the frame(width:height:alignment:) modifier to influence its layout, and then use the border(_:width:) modifier to draw an outline around that:\n\nText(\"Title\")\n    .frame(width: 100)\n    .border(Color.gray)\n\n\nThe order in which you apply modifiers matters. For example, the border that results from the code above outlines the full width of the frame.\n\nBy specifying the frame modifier after the border modifier, SwiftUI applies the border only to the text view, which never takes more space than it needs to render its contents.\n\nText(\"Title\")\n    .border(Color.gray) // Apply the border first this time.\n    .frame(width: 100)\n\n\nWrapping that view in an invisible one with a fixed 100 point width affects the layout of the composite view, but has no effect on the border.\n\nConfigure child views\n\nYou can apply any view modifier defined by the View protocol to any concrete view, even when the modifier doesn\u2019t have an immediate effect on its target view. The effects of a modifier propagate to child views that don\u2019t explicitly override the modifier.\n\nFor example, a VStack instance on its own acts only to vertically stack other views \u2014 it doesn\u2019t have any text to display. Therefore, applying a font(_:) modifier to the stack has no effect on the stack. Yet the font modifier does apply to any of the stack\u2019s child views, some of which might display text. You can, however, locally override the stack\u2019s modifier by adding another to a specific child view:\n\nVStack {\n    Text(\"Title\")\n        .font(.title) // Override the font of this view.\n    Text(\"First body line.\")\n    Text(\"Second body line.\")\n}\n.font(.body) // Set a default font for text in the stack.\n\n\nUse view-specific modifiers\n\nWhile many view types rely on standard view modifiers for customization and control, some views do define modifiers that are specific to that view type. You can\u2019t use such a modifier on anything but the appropriate kind of view. For example, Text defines the bold() modifier as a convenience for adding a bold effect to the view\u2019s text. While you can use font(_:) on any view because it\u2019s part of the View protocol, you can use bold() only on Text views. As a result, you can\u2019t use it on a container view:\n\nVStack {\n    Text(\"Hello, world!\")\n}\n.bold() // Fails because 'VStack' doesn't have a 'bold' modifier.\n\n\nYou also can\u2019t use it on a Text view after applying another general modifier because general modifiers return an opaque type. For example, the return value from the padding modifier isn\u2019t Text, but rather an opaque result type that can\u2019t take a bold modifier:\n\nText(\"Hello, world!\")\n    .padding()\n    .bold() // Fails because 'some View' doesn't have a 'bold' modifier.\n\n\nInstead, apply the bold modifier directly to the Text view and then add the padding:\n\nText(\"Hello, world!\")\n    .bold() // Succeeds.\n    .padding()\n\nSee Also\nModifying a view\nReducing view modifier maintenance\nBundle view modifiers that you regularly reuse into a custom view modifier.\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nprotocol ViewModifier\nA modifier that you apply to a view or another view modifier, producing a different version of the original value.\nstruct EmptyModifier\nAn empty, or identity, modifier, used during development to switch modifiers at compile time.\nstruct ModifiedContent\nA value with a modifier applied to it.\nprotocol EnvironmentalModifier\nA modifier that must resolve to a concrete modifier in an environment before use."
    },
    {
        "title": "modifier(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/modifier(_:)",
        "html": "Parameters\nmodifier\n\nThe modifier to apply to this view.\n\nDiscussion\n\nUse this modifier to combine a View and a ViewModifier, to create a new view. For example, if you create a view modifier for a new kind of caption with blue text surrounded by a rounded rectangle:\n\nstruct BorderedCaption: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.caption2)\n            .padding(10)\n            .overlay(\n                RoundedRectangle(cornerRadius: 15)\n                    .stroke(lineWidth: 1)\n            )\n            .foregroundColor(Color.blue)\n    }\n}\n\n\nYou can use modifier(_:) to extend View to create new modifier for applying the BorderedCaption defined above:\n\nextension View {\n    func borderedCaption() -> some View {\n        modifier(BorderedCaption())\n    }\n}\n\n\nThen you can apply the bordered caption to any view:\n\nImage(systemName: \"bus\")\n    .resizable()\n    .frame(width:50, height:50)\nText(\"Downtown Bus\")\n    .borderedCaption()\n\n\nSee Also\nModifying a view\nConfiguring views\nAdjust the characteristics of a view by applying view modifiers.\nReducing view modifier maintenance\nBundle view modifiers that you regularly reuse into a custom view modifier.\nprotocol ViewModifier\nA modifier that you apply to a view or another view modifier, producing a different version of the original value.\nstruct EmptyModifier\nAn empty, or identity, modifier, used during development to switch modifiers at compile time.\nstruct ModifiedContent\nA value with a modifier applied to it.\nprotocol EnvironmentalModifier\nA modifier that must resolve to a concrete modifier in an environment before use."
    },
    {
        "title": "Reducing view modifier maintenance",
        "url": "https://developer.apple.com/documentation/swiftui/reducing-view-modifier-maintenance",
        "html": "Overview\n\nTo create consistent views, you might reuse the same view modifier or group of modifiers repeatedly across your views. For example, you might apply the same font and foreground color to many text instances throughout your app, so they all match. Unfortunately, this can lead to maintenance challenges, because even a small change in format, like a different font size, requires changes in many different parts of your code.\n\nTo avoid this overhead, collect a set of modifiers into a single location using an instance of the ViewModifier protocol. Then, extend the View protocol with a method that uses your modifier, making it easy to use and understand. Collecting the modifiers together provides a single location to update when you want to change them.\n\nCreate a custom view modifier\n\nWhen you create your custom modifier, name it to reflect the purpose of the collection. For example, if you repeatedly apply the caption font style and a secondary color scheme to views to represent a secondary styling, collect them together as CaptionTextFormat:\n\nstruct CaptionTextFormat: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.caption)\n            .foregroundColor(.secondary)\n    }\n}\n\n\nApply your modifier using the modifier(_:) method. The following code applies the above example to a Text instance:\n\nText(\"Some additional information...\")\n    .modifier(CaptionTextFormat())\n\nExtend the view protocol to provide fluent modifier access\n\nTo make your custom view modifier conveniently accessible, extend the View protocol with a function that applies your modifier:\n\nextension View {\n    func captionTextFormat() -> some View {\n        modifier(CaptionTextFormat())\n    }\n}\n\n\nApply the modifier to a text view by including this extension:\n\nText(\"Some additional information...\")\n    .captionTextFormat()\n\nSee Also\nModifying a view\nConfiguring views\nAdjust the characteristics of a view by applying view modifiers.\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nprotocol ViewModifier\nA modifier that you apply to a view or another view modifier, producing a different version of the original value.\nstruct EmptyModifier\nAn empty, or identity, modifier, used during development to switch modifiers at compile time.\nstruct ModifiedContent\nA value with a modifier applied to it.\nprotocol EnvironmentalModifier\nA modifier that must resolve to a concrete modifier in an environment before use."
    },
    {
        "title": "EmptyModifier",
        "url": "https://developer.apple.com/documentation/swiftui/emptymodifier",
        "html": "Overview\n\nUse the empty modifier to switch modifiers at compile time during development. In the example below, in a debug build the Text view inside ContentView has a yellow background and a red border. A non-debug build reflects the default system, or container supplied appearance.\n\nstruct EmphasizedLayout: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .background(Color.yellow)\n            .border(Color.red)\n    }\n}\n\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .modifier(modifier)\n    }\n\n\n    var modifier: some ViewModifier {\n        #if DEBUG\n            return EmphasizedLayout()\n        #else\n            return EmptyModifier()\n        #endif\n    }\n}\n\nTopics\nCreating an empty modifier\ninit()\nGetting the identity modifier\nstatic let identity: EmptyModifier\nRelationships\nConforms To\nSendable\nViewModifier\nSee Also\nModifying a view\nConfiguring views\nAdjust the characteristics of a view by applying view modifiers.\nReducing view modifier maintenance\nBundle view modifiers that you regularly reuse into a custom view modifier.\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nprotocol ViewModifier\nA modifier that you apply to a view or another view modifier, producing a different version of the original value.\nstruct ModifiedContent\nA value with a modifier applied to it.\nprotocol EnvironmentalModifier\nA modifier that must resolve to a concrete modifier in an environment before use."
    },
    {
        "title": "environment(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/environment(_:)",
        "html": "Parameters\nobject\n\nThe object to set for this object\u2019s type in the environment, or nil to clear an object of this type from the environment.\n\nReturn Value\n\nA view that has the specified object in its environment.\n\nDiscussion\n\nUse this modifier to place an object that you declare with the Observable() macro into a view\u2019s environment. For example, you can add an instance of a custom observable Profile class to the environment of a ContentView:\n\n@Observable class Profile { ... }\n\n\nstruct RootView: View {\n    @State private var currentProfile: Profile?\n\n\n    var body: some View {\n        ContentView()\n            .environment(currentProfile)\n    }\n}\n\n\nYou then read the object inside ContentView or one of its descendants using the Environment property wrapper:\n\nstruct ContentView: View {\n    @Environment(Profile.self) private var currentProfile: Profile\n\n\n    var body: some View { ... }\n}\n\n\nThis modifier affects the given view, as well as that view\u2019s descendant views. It has no effect outside the view hierarchy on which you call it. The environment of a given view hierarchy holds only one observable object of a given type.\n\nNote\n\nThis modifier takes an object that conforms to the Observable protocol. To add environment objects that conform to the ObservableObject protocol, use environmentObject(_:) instead.\n\nSee Also\nModifying the environment of a view\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some View\nSets the environment value of the specified key path to the given value.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some View\nTransforms the environment value of the specified key path with the given function."
    },
    {
        "title": "EnvironmentKey",
        "url": "https://developer.apple.com/documentation/swiftui/environmentkey",
        "html": "Overview\n\nYou can create custom environment values by extending the EnvironmentValues structure with new properties. First declare a new environment key type and specify a value for the required defaultValue property:\n\nprivate struct MyEnvironmentKey: EnvironmentKey {\n    static let defaultValue: String = \"Default value\"\n}\n\n\nThe Swift compiler automatically infers the associated Value type as the type you specify for the default value. Then use the key to define a new environment value property:\n\nextension EnvironmentValues {\n    var myCustomValue: String {\n        get { self[MyEnvironmentKey.self] }\n        set { self[MyEnvironmentKey.self] = newValue }\n    }\n}\n\n\nClients of your environment value never use the key directly. Instead, they use the key path of your custom environment value property. To set the environment value for a view and all its subviews, add the environment(_:_:) view modifier to that view:\n\nMyView()\n    .environment(\\.myCustomValue, \"Another string\")\n\n\nAs a convenience, you can also define a dedicated view modifier to apply this environment value:\n\nextension View {\n    func myCustomValue(_ myCustomValue: String) -> some View {\n        environment(\\.myCustomValue, myCustomValue)\n    }\n}\n\n\nThis improves clarity at the call site:\n\nMyView()\n    .myCustomValue(\"Another string\")\n\n\nTo read the value from inside MyView or one of its descendants, use the Environment property wrapper:\n\nstruct MyView: View {\n    @Environment(\\.myCustomValue) var customValue: String\n\n\n    var body: some View {\n        Text(customValue) // Displays \"Another string\".\n    }\n}\n\nTopics\nGetting the default value\nstatic var defaultValue: Self.Value\nThe default value for the environment key.\n\nRequired\n\nassociatedtype Value\nThe associated type representing the type of the environment key\u2019s value.\n\nRequired\n\nRelationships\nInherited By\nUITraitBridgedEnvironmentKey"
    },
    {
        "title": "searchable(text:placement:prompt:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:placement:prompt:)-18a8f",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "Adding a search interface to your app",
        "url": "https://developer.apple.com/documentation/swiftui/adding-a-search-interface-to-your-app",
        "html": "Overview\n\nAdd a search interface to your app by applying one of the searchable view modifiers \u2014 like searchable(text:placement:prompt:) \u2014 to a NavigationSplitView or NavigationStack, or to a view inside one of these. A search field then appears in the toolbar. The precise placement and appearance of the search field depends on the platform, where you put the modifier in code, and its configuration.\n\nThe searchable modifier that creates the field takes a Binding to a string that represents the search field\u2019s text. You provide the storage for the string \u2014 and optionally for an array of discrete search tokens \u2014 that you use to conduct the search. To learn about managing the search field\u2019s data, see Performing a search operation.\n\nPlace the search field automatically\n\nYou can automatically place the search field by adding the searchable(text:placement:prompt:) modifier to a navigation element like a navigation split view:\n\nstruct ContentView: View {\n    @State private var departmentId: Department.ID?\n    @State private var productId: Product.ID?\n    @State private var searchText: String = \"\"\n\n\n    var body: some View {\n        NavigationSplitView {\n            DepartmentList(departmentId: $departmentId)\n        } content: {\n            ProductList(departmentId: departmentId, productId: $productId)\n        } detail: {\n            ProductDetails(productId: productId)\n        }\n        .searchable(text: $searchText) // Adds a search field.\n    }\n}\n\n\nWith this configuration, the search field appears on the trailing edge of the toolbar in macOS. In iOS and iPadOS, the first or second column displays the search field in a double or triple column navigation view, respectively. The above three-column example puts the search field at the top of the middle column on iPad.\n\nmacOS\niOS\n\nControl the placement structurally\n\nTo add a search field to a specific column in iOS and iPadOS, add the searchable modifier to a view in that column. For example, to indicate that the search covers departments in the previous example, you could place the search field in the first column by adding the modifier to that column\u2019s DepartmentList view instead of to the navigation split view:\n\nNavigationSplitView {\n    DepartmentList(departmentId: $departmentId)\n        .searchable(text: $searchText)\n} content: {\n    ProductList(departmentId: departmentId, productId: $productId)\n} detail: {\n    ProductDetails(productId: productId)\n}\n\n\nControl the placement programmatically\n\nYou can alternatively use the placement input parameter to suggest a SearchFieldPlacement value for the search interface. For example, you can achieve the same results as the previous example in macOS using the sidebar placement:\n\nNavigationSplitView {\n    DepartmentList(departmentId: $departmentId)\n} content: {\n    ProductList(departmentId: departmentId, productId: $productId)\n} detail: {\n    ProductDetails(productId: productId)\n}\n.searchable(text: $searchText, placement: .sidebar)\n\n\nIf SwiftUI can\u2019t satisfy the placement request, like when you ask for sidebar placement in a searchable modifier that isn\u2019t applied to a navigation split view, SwiftUI relies instead on its automatic placement rules.\n\nSet a prompt for the search field\n\nBy default, the search field contains Search as the placeholder text, to prompt people on how to use the field. You can customize the prompt by setting either a string, a Text view, or a LocalizedStringKey for the searchable modifier\u2019s prompt input parameter. For example, you might use this to clarify that the search field in the Department column searches among both departments and the products in each department:\n\nDepartmentList(departmentId: $departmentId)\n    .searchable(text: $searchText, prompt: \"Departments and products\")\n\n\nSee Also\nSearching your app\u2019s data model\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "searchPresentationToolbarBehavior(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchpresentationtoolbarbehavior(_:)",
        "html": "Discussion\n\nBy default on iOS, a toolbar may hide parts of its content when presenting search to focus on searching. You can override this behavior by providing a value of avoidHidingContent to this modifer.\n\n@State private var searchText = \"\"\n\n\nList {\n    // ... content\n}\n.searchable(text: $searchText)\n.searchPresentationToolbarBehavior(.avoidHidingContent)\n\nSee Also\nDisplaying toolbar content during search\nstruct SearchPresentationToolbarBehavior\nA type that defines how the toolbar behaves when presenting search."
    },
    {
        "title": "SearchPresentationToolbarBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/searchpresentationtoolbarbehavior",
        "html": "Overview\n\nUse this type in combination with the searchPresentationToolbarBehavior(_:)\n\nTopics\nGetting toolbar behaviors\nstatic var automatic: SearchPresentationToolbarBehavior\nThe automatic behavior.\nstatic var avoidHidingContent: SearchPresentationToolbarBehavior\nThe avoid hiding content behavior.\nSee Also\nDisplaying toolbar content during search\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> some View\nConfigures the search toolbar presentation behavior for any searchable modifiers within this view."
    },
    {
        "title": "ornament(visibility:attachmentAnchor:contentAlignment:ornament:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/ornament(visibility:attachmentanchor:contentalignment:ornament:)",
        "html": "Parameters\nvisibility\n\nThe visibility of the ornament.\n\nattachmentAnchor\n\nThe positioning anchor that defines the attachment point of the ornament.\n\ncontentAlignment\n\nThe alignment of the ornament with its attachment anchor.\n\ncontent\n\nThe content of the ornament.\n\nDiscussion\n\nUse this method to show an ornament at the specified position. The example below displays an ornament below the window:\n\nText(\"A view with an ornament\")\n    .ornament(attachmentAnchor: .scene(.bottom)) {\n        OrnamentContent()\n    }\n\nSee Also\nCreating an ornament\nstruct OrnamentAttachmentAnchor\nBeta"
    },
    {
        "title": "searchable(text:tokens:suggestedTokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:suggestedtokens:placement:prompt:token:)-9m40k",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nsuggestedTokens\n\nA collection of tokens to display as suggestions.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "SearchSuggestionsPlacement",
        "url": "https://developer.apple.com/documentation/swiftui/searchsuggestionsplacement",
        "html": "Overview\n\nYou can influence which modes SwiftUI displays search suggestions for by using the searchSuggestions(_:for:) modifier:\n\nenum FruitSuggestion: String, Identifiable {\n    case apple, banana, orange\n    var id: Self { self }\n}\n\n\n@State private var text = \"\"\n@State private var suggestions: [FruitSuggestion] = []\n\n\nvar body: some View {\n    MainContent()\n        .searchable(text: $text) {\n            ForEach(suggestions) { suggestion in\n                Text(suggestion.rawValue)\n                    .searchCompletion(suggestion.rawValue)\n            }\n            .searchSuggestions(.hidden, for: .content)\n        }\n}\n\n\nIn the above example, SwiftUI only displays search suggestions in a suggestions menu. You might want to do this when you want to render search suggestions in a container, like inline with your own set of search results.\n\nYou can get the current search suggestion placement by querying the searchSuggestionsPlacement environment value in your search suggestions.\n\nTopics\nGetting placements\nstatic var automatic: SearchSuggestionsPlacement\nSearch suggestions render automatically based on the surrounding context.\nstatic var content: SearchSuggestionsPlacement\nSearch suggestions render in the main content of the app.\nstatic var menu: SearchSuggestionsPlacement\nSearch suggestions render inside of a menu attached to the search field.\nSupporting types\nstruct Set\nAn efficient set of search suggestion display modes.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:presenting:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:message:)-8y541",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\ndata\n\nAn optional source of truth for the confirmation dialog. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of a confirmation dialog that you create that the system displays to the user.\n\nactions\n\nA view builder returning the dialog\u2019s actions given the currently available data.\n\nmessage\n\nA view builder returning the message for the dialog given the currently available data.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and data must not be nil. data should not change after the presentation occurs. Any changes which occur after the presentation occurs will be ignored.\n\nUse this method when you need to populate the fields of a confirmation dialog with content from a data source. The example below shows a custom data source, FileDetails, that provides data to populate the dialog:\n\nstruct FileDetails: Identifiable {\n    var id: String { name }\n    let name: String\n    let fileType: UTType\n}\nstruct ConfirmFileImport: View {\n    @State private var isConfirming = false\n    @State private var dialogDetail: FileDetails?\n    var body: some View {\n        Button(\"Import File\") {\n            dialogDetail = FileDetails(\n                name: \"MyImageFile.png\", fileType: .png)\n            isConfirming = true\n        }\n        .confirmationDialog(\n            \"Are you sure you want to import this file?\",\n            isPresented: $isConfirming, presenting: dialogDetail\n        ) { detail in\n            Button {\n                // Handle import action.\n            } label: {\n                Text(\"Import \\(detail.name)\")\n            }\n            Button(\"Cancel\", role: .cancel) {\n                dialogDetail = nil\n            }\n        } message: { detail in\n            Text(\n                \"\"\"\n                This will add \\(detail.name).\\(detail.fileType) \\\n                to your library.\n                \"\"\")\n        }\n    }\n}\n\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nShowing a confirmation dialog with a message\nfunc confirmationDialog<S, A, M>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a string variable for the title.\nfunc confirmationDialog<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, M>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A, M, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a text view for the message.\nfunc confirmationDialog<S, A, M, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a string variable for the title."
    },
    {
        "title": "dialogSuppressionToggle(isSuppressed:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dialogsuppressiontoggle(issuppressed:)",
        "html": "Parameters\nisSuppressed\n\nWhether the suppression toggle is on or off in the dialog.\n\nDiscussion\n\nApplying dialog suppression adds a toggle to dialogs on macOS, which allows the user to request the alert not be displayed again. Typically whether a dialog is suppressed is stored in AppStorage and used to decide whether to present the dialog in the future.\n\nThe following example configures a confirmationDialog with a suppression toggle. The toggle\u2019s state is stored in AppStorage and used to determine whether or not to show the dialog when the \u201cDelete Items\u201d button is pressed.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n\n\n    @AppStorage(\"suppressEraseItemAlert\")\n    private var suppressAlert = false\n\n\n    var body: some View {\n        Button(\"Delete Items\") {\n            if !suppressAlert {\n                isShowingDialog = true\n            } else {\n                // Handle item deletion.\n            }\n        }\n        .confirmationDialog(\n            \"Are you sure you want to erase these items?\",\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Erase\", role: .destructive) {\n                // Handle item deletion.\n            }\n            Button(\"Cancel\", role: .cancel) {\n                isShowingDialog = false\n            }\n        }\n        .dialogSuppressionToggle(isSuppressed: $suppressAlert)\n    }\n}\n\nSee Also\nConfiguring a dialog\nfunc dialogIcon(Image?) -> some View\nConfigures the icon used by dialogs within this view.\nfunc dialogSeverity(DialogSeverity) -> some View\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:presenting:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:message:)-1iv4u",
        "html": "Parameters\ntitle\n\nthe title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\ndata\n\nAn optional source of truth for the confirmation dialog. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of a confirmation dialog that you create that the system displays to the user.\n\nactions\n\nA view builder returning the dialog\u2019s actions given the currently available data.\n\nmessage\n\nA view builder returning the message for the dialog given the currently available data.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and data must not be nil. data should not change after the presentation occurs. Any changes which occur after the presentation occurs will be ignored.\n\nUse this method when you need to populate the fields of a confirmation dialog with content from a data source. The example below shows a custom data source, FileDetails, that provides data to populate the dialog:\n\nstruct FileDetails: Identifiable {\n    var id: String { name }\n    let name: String\n    let fileType: UTType\n}\nstruct ConfirmFileImport: View {\n    @State private var isConfirming = false\n    @State private var dialogDetail: FileDetails?\n    var body: some View {\n        Button(\"Import File\") {\n            dialogDetail = FileDetails(\n                name: \"MyImageFile.png\", fileType: .png)\n            isConfirming = true\n        }\n        .confirmationDialog(\n            Text(\"Import New File?\"),\n            isPresented: $isConfirming, presenting: dialogDetail\n        ) { detail in\n            Button {\n                // Handle import action.\n            } label: {\n                Text(\"Import \\(detail.name)\")\n            }\n            Button(\"Cancel\", role: .cancel) {\n                dialogDetail = nil\n            }\n        } message: { detail in\n            Text(\n                \"\"\"\n                This will add \\(detail.name).\\(detail.fileType) \\\n                to your library.\n                \"\"\")\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nShowing a confirmation dialog with a message\nfunc confirmationDialog<S, A, M>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a string variable for the title.\nfunc confirmationDialog<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, M>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a text view for the title.\nfunc confirmationDialog<S, A, M, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a string variable for the title.\nfunc confirmationDialog<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a localized string key for the title."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:presenting:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:message:)-3s8wb",
        "html": "Parameters\ntitle\n\nA text string used as the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\ndata\n\nAn optional source of truth for the confirmation dialog. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of a confirmation dialog that you create that the system displays to the user.\n\nactions\n\nA view builder returning the dialog\u2019s actions given the currently available data.\n\nmessage\n\nA view builder returning the message for the dialog given the currently available data.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and data must not be nil. data should not change after the presentation occurs. Any changes which occur after the presentation occurs will be ignored.\n\nUse this method when you need to populate the fields of a confirmation dialog with content from a data source. The example below shows a custom data source, FileDetails, that provides data to populate the dialog:\n\nstruct FileDetails: Identifiable {\n    var id: String { name }\n    let name: String\n    let fileType: UTType\n}\nstruct ConfirmFileImport: View {\n    var title: String\n    @State private var isConfirming = false\n    @State private var dialogDetail: FileDetails?\n    var body: some View {\n        Button(\"Import File\") {\n            dialogDetail = FileDetails(\n                name: \"MyImageFile.png\", fileType: .png)\n            isConfirming = true\n        }\n        .confirmationDialog(\n            title, isPresented: $isConfirming,\n            presenting: dialogDetail\n        ) { detail in\n            Button {\n                // Handle import action.\n            } label: {\n                Text(\"Import \\(detail.name)\")\n            }\n            Button(\"Cancel\", role: .cancel) {\n                dialogDetail = nil\n            }\n        } message: { detail in\n            Text(\n                \"\"\"\n                This will add \\(detail.name).\\(detail.fileType) \\\n                to your library.\n                \"\"\")\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nShowing a confirmation dialog with a message\nfunc confirmationDialog<S, A, M>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a string variable for the title.\nfunc confirmationDialog<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, M>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A, M, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a text view for the message.\nfunc confirmationDialog<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a localized string key for the title."
    },
    {
        "title": "dialogIcon(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dialogicon(_:)",
        "html": "Parameters\nicon\n\nThe custom icon to use for confirmation dialogs and alerts. Passing nil will use the default app icon.\n\nDiscussion\n\nOn macOS, this icon replaces the default icon of the app.\n\nOn watchOS, this icon will be shown in any dialogs presented.\n\nThis modifier has no effect on other platforms.\n\nThe following example configures a confirmationDialog with a custom image.\n\nButton(\"Delete items\") {\n    isShowingDialog = true\n}\n.confirmationDialog(\n    \"Are you sure you want to erase these items?\",\n        isPresented: $isShowingDialog\n) {\n    Button(\"Erase\", role: .destructive) {\n        // Handle item deletion.\n    }\n    Button(\"Cancel\", role: .cancel) {\n        isShowingDialog = false\n    }\n}\n.dialogIcon(Image(...))\n\nSee Also\nConfiguring a dialog\nfunc dialogSeverity(DialogSeverity) -> some View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a default suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:message:)-2tbci",
        "html": "Parameters\ntitle\n\nthe title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\nactions\n\nA view builder returning the dialog\u2019s actions.\n\nmessage\n\nA view builder returning the message for the dialog.\n\nDiscussion\n\nIn the example below, a button conditionally presents a confirmation dialog depending upon the value of a bound Boolean variable. When the Boolean value is set to true, the system displays a confirmation dialog with a cancel action and a destructive action.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n    var body: some View {\n        Button(\"Empty Trash\") {\n            isShowingDialog = true\n        }\n        .confirmationDialog(\n            Text(\"Permanently erase the items in the trash?\"),\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Empty Trash\", role: .destructive) {\n                // Handle empty trash action.\n            }\n        } message: {\n            Text(\"You cannot undo this action.\")\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nSee Also\nShowing a confirmation dialog with a message\nfunc confirmationDialog<S, A, M>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a string variable for the title.\nfunc confirmationDialog<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, M, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a text view for the message.\nfunc confirmationDialog<S, A, M, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a string variable for the title.\nfunc confirmationDialog<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a localized string key for the title."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:message:)-1r2g1",
        "html": "Parameters\ntitle\n\nA text string used as the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\nactions\n\nA view builder returning the dialog\u2019s actions.\n\nmessage\n\nA view builder returning the message for the dialog.\n\nDiscussion\n\nIn the example below, a button conditionally presents a confirmation dialog depending upon the value of a bound Boolean variable. When the Boolean value is set to true, the system displays a confirmation dialog with a cancel action and a destructive action.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n    var title: String\n    var body: some View {\n        Button(\"Empty Trash\") {\n            isShowingDialog = true\n        }\n        .confirmationDialog(\n            title,\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Empty Trash\", role: .destructive) {\n                // Handle empty trash action.\n            }\n            Button(\"Cancel\", role: .cancel) {\n                isShowingDialog = false\n            }\n        } message: {\n            Text(\"You cannot undo this action.\")\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nSee Also\nShowing a confirmation dialog with a message\nfunc confirmationDialog<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, M>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A, M, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a text view for the message.\nfunc confirmationDialog<S, A, M, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a string variable for the title.\nfunc confirmationDialog<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a localized string key for the title."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:presenting:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:)-9quvm",
        "html": "Parameters\ntitle\n\nA text string used as the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\ndata\n\nAn optional source of truth for the confirmation dialog. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of a confirmation dialog that you create that the system displays to the user.\n\nactions\n\nA view builder returning the dialog\u2019s actions given the currently available data.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and data must not be nil. data should not change after the presentation occurs. Any changes which occur after the presentation occurs will be ignored.\n\nUse this method when you need to populate the fields of a confirmation dialog with content from a data source. The example below shows a custom data source, FileDetails, that provides data to populate the dialog:\n\nstruct FileDetails: Identifiable {\n    var id: String { name }\n    let name: String\n    let fileType: UTType\n}\nstruct ConfirmFileImport: View {\n    var title: String\n    @State private var isConfirming = false\n    @State private var dialogDetail: FileDetails?\n    var body: some View {\n        Button(\"Import File\") {\n            dialogDetail = FileDetails(\n                name: \"MyImageFile.png\", fileType: .png)\n            isConfirming = true\n        }\n        .confirmationDialog(\n            title, isPresented: $isConfirming,\n            presenting: dialogDetail\n        ) { detail in\n            Button {\n                // Handle import action.\n            } label: {\n                Text(\"\"\"\n                Import \\(detail.name)\n                File Type: \\(detail.fileType.description)\n                \"\"\")\n            }\n            Button(\"Cancel\", role: .cancel) {\n                dialogDetail = nil\n            }\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nGetting confirmation for an action\nfunc confirmationDialog<S, A>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a string variable as a title.\nfunc confirmationDialog<A>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a text view for the title.\nfunc confirmationDialog<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a localized string key for the title."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:)-55h6a",
        "html": "Parameters\ntitle\n\nthe title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\nactions\n\nA view builder returning the dialog\u2019s actions.\n\nDiscussion\n\nIn the example below, a button conditionally presents a confirmation dialog depending upon the value of a bound Boolean variable. When the Boolean value is set to true, the system displays a confirmation dialog with a cancel action and a destructive action.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n    var body: some View {\n        Button(\"Empty Trash\") {\n            isShowingDialog = true\n        }\n        .confirmationDialog(\n            Text(\"Permanently erase the items in the trash?\"),\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Empty Trash\", role: .destructive) {\n                // Handle empty trash action.\n            }\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nSee Also\nGetting confirmation for an action\nfunc confirmationDialog<S, A>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a string variable as a title.\nfunc confirmationDialog<A>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a text view for the title.\nfunc confirmationDialog<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a localized string key for the title.\nfunc confirmationDialog<S, A, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a string variable for the title."
    },
    {
        "title": "alert(_:isPresented:presenting:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:message:)-3md6l",
        "html": "Parameters\ntitle\n\nthe title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\ndata\n\nAn optional source of truth for the alert. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions given the currently available data.\n\nmessage\n\nA ViewBuilder returning the message for the alert given the currently available data.\n\nDiscussion\n\nFor the alert to appear, both isPresented must be true and data must not be nil. The data should not change after the presentation occurs. Any changes that you make after the presentation occurs are ignored.\n\nUse this method when you need to populate the fields of an alert with content from a data source. The example below shows a custom data source, SaveDetails, that provides data to populate the alert:\n\nstruct SaveDetails: Identifiable {\n    let name: String\n    let error: String\n    let id = UUID()\n}\n\n\nstruct SaveButton: View {\n    @State private var didError = false\n    @State private var details: SaveDetails?\n    let alertTitle: String = \"Save failed.\"\n\n\n    var body: some View {\n        Button(\"Save\") {\n            details = model.save(didError: $didError)\n        }\n        .alert(\n            Text(alertTitle),\n            isPresented: $didError,\n            presenting: details\n        ) { details in\n            Button(role: .destructive) {\n                // Handle the deletion.\n            } label: {\n                Text(\"Delete \\(details.name)\")\n            }\n            Button(\"Retry\") {\n                // Handle the retry action.\n            }\n        } message: { details in\n            Text(details.error)\n        }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nOnly unstyled text is supported for the message.\n\nSee Also\nPresenting an alert with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present."
    },
    {
        "title": "alert(_:isPresented:presenting:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:message:)-8584l",
        "html": "Parameters\ntitle\n\nA text string used as the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\ndata\n\nAn optional source of truth for the alert. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions given the currently available data.\n\nmessage\n\nA ViewBuilder returning the message for the alert given the currently available data.\n\nDiscussion\n\nFor the alert to appear, both isPresented must be true and data must not be nil. The data should not change after the presentation occurs. Any changes that you make after the presentation occurs are ignored.\n\nUse this method when you need to populate the fields of an alert with content from a data source. The example below shows a custom data source, SaveDetails, that provides data to populate the alert:\n\nstruct SaveDetails: Identifiable {\n    let name: String\n    let error: String\n    let id = UUID()\n}\n\n\nstruct SaveButton: View {\n    @State private var didError = false\n    @State private var details: SaveDetails?\n    let alertTitle: String = \"Save failed.\"\n\n\n    var body: some View {\n        Button(\"Save\") {\n            details = model.save(didError: $didError)\n        }\n        .alert(\n            alertTitle,\n            isPresented: $didError,\n            presenting: details\n        ) { details in\n            Button(role: .destructive) {\n                // Handle the deletion.\n            } label: {\n                Text(\"Delete \\(details.name)\")\n            }\n            Button(\"Retry\") {\n                // Handle the retry action.\n            }\n        } message: { details in\n            Text(details.error)\n        }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nOnly unstyled text is supported for the message.\n\nSee Also\nPresenting an alert with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present."
    },
    {
        "title": "alert(_:isPresented:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:message:)-6awwp",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nmessage\n\nA ViewBuilder returning the message for the alert.\n\nDiscussion\n\nIn the example below, a login form conditionally presents an alert by setting the didFail state variable. When the form sets the value to to true, the system displays an alert with an \u201cOK\u201d action.\n\nstruct Login: View {\n    @State private var didFail = false\n\n\n    var body: some View {\n        LoginForm(didFail: $didFail)\n            .alert(\n                \"Login failed.\",\n                isPresented: $didFail\n            ) {\n                Button(\"OK\") {\n                    // Handle the acknowledgement.\n                }\n            } message: {\n                Text(\"Please check your credentials and try again.\")\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nOnly unstyled text is supported for the message.\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nSee Also\nPresenting an alert with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present."
    },
    {
        "title": "alert(_:isPresented:presenting:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:message:)-29bp4",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\ndata\n\nAn optional source of truth for the alert. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions given the currently available data.\n\nmessage\n\nA ViewBuilder returning the message for the alert given the currently available data.\n\nDiscussion\n\nFor the alert to appear, both isPresented must be true and data must not be nil. The data should not change after the presentation occurs. Any changes that you make after the presentation occurs are ignored.\n\nUse this method when you need to populate the fields of an alert with content from a data source. The example below shows a custom data source, SaveDetails, that provides data to populate the alert:\n\nstruct SaveDetails: Identifiable {\n    let name: String\n    let error: String\n    let id = UUID()\n}\n\n\nstruct SaveButton: View {\n    @State private var didError = false\n    @State private var details: SaveDetails?\n\n\n    var body: some View {\n        Button(\"Save\") {\n            details = model.save(didError: $didError)\n        }\n        .alert(\n            \"Save failed.\",\n            isPresented: $didError,\n            presenting: details\n        ) { details in\n            Button(role: .destructive) {\n                // Handle the deletion.\n            } label: {\n                Text(\"Delete \\(details.name)\")\n            }\n            Button(\"Retry\") {\n                // Handle the retry action.\n            }\n        } message: { details in\n            Text(details.error)\n        }\n    }\n}\n\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nOnly unstyled text is supported for the message.\n\nSee Also\nPresenting an alert with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present."
    },
    {
        "title": "alert(_:isPresented:actions:message:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:message:)-8dvt8",
        "html": "Parameters\ntitle\n\nThe title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nmessage\n\nA ViewBuilder returning the message for the alert.\n\nDiscussion\n\nIn the example below, a login form conditionally presents an alert by setting the didFail state variable. When the form sets the value to to true, the system displays an alert with an \u201cOK\u201d action.\n\nstruct Login: View {\n    @State private var didFail = false\n    let alertTitle: String = \"Login failed.\"\n\n\n    var body: some View {\n        LoginForm(didFail: $didFail)\n            .alert(\n                Text(alertTitle),\n                isPresented: $didFail\n            ) {\n                Button(\"OK\") {\n                    // Handle the acknowledgement.\n                }\n            } message: {\n               Text(\"Please check your credentials and try again.\")\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nOnly unstyled text is supported for the message.\n\nSee Also\nPresenting an alert with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present."
    },
    {
        "title": "alert(_:isPresented:presenting:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:)-9h5um",
        "html": "Parameters\ntitle\n\nA text string used as the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\ndata\n\nAn optional source of truth for the alert. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions given the currently available data.\n\nDiscussion\n\nFor the alert to appear, both isPresented must be true and data must not be nil. The data should not change after the presentation occurs. Any changes that you make after the presentation occurs are ignored.\n\nUse this method when you need to populate the fields of an alert with content from a data source. The example below shows a custom data source, SaveDetails, that provides data to populate the alert:\n\nstruct SaveDetails: Identifiable {\n    let name: String\n    let error: String\n    let id = UUID()\n}\n\n\nstruct SaveButton: View {\n    @State private var didError = false\n    @State private var details: SaveDetails?\n    let alertTitle: String = \"Save failed.\"\n\n\n    var body: some View {\n        Button(\"Save\") {\n            details = model.save(didError: $didError)\n        }\n        .alert(\n            alertTitle,\n            isPresented: $didError,\n            presenting: details\n        ) { details in\n            Button(role: .destructive) {\n                // Handle the deletion.\n            } label: {\n                Text(\"Delete \\(details.name)\")\n            }\n            Button(\"Retry\") {\n                // Handle the retry action.\n            }\n        }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nPresenting an alert\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present."
    },
    {
        "title": "alert(_:isPresented:presenting:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:)-78spw",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\ndata\n\nAn optional source of truth for the alert. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of an alert that you create that the system displays to the user.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions given the currently available data.\n\nDiscussion\n\nFor the alert to appear, both isPresented must be true and data must not be nil. The data should not change after the presentation occurs. Any changes that you make after the presentation occurs are ignored.\n\nUse this method when you need to populate the fields of an alert with content from a data source. The example below shows a custom data source, SaveDetails, that provides data to populate the alert:\n\nstruct SaveDetails: Identifiable {\n    let name: String\n    let error: String\n    let id = UUID()\n}\n\n\nstruct SaveButton: View {\n    @State private var didError = false\n    @State private var details: SaveDetails?\n\n\n    var body: some View {\n        Button(\"Save\") {\n            details = model.save(didError: $didError)\n        }\n        .alert(\n            \"Save failed.\",\n            isPresented: $didError,\n            presenting: details\n        ) { details in\n            Button(role: .destructive) {\n                // Handle the deletion.\n            } label: {\n                Text(\"Delete \\(details.name)\")\n            }\n            Button(\"Retry\") {\n                // Handle the retry action.\n            }\n        }\n    }\n}\n\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nPresenting an alert\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present."
    },
    {
        "title": "alert(_:isPresented:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:)-1bkka",
        "html": "Parameters\ntitle\n\nA text string used as the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nDiscussion\n\nIn the example below, a login form conditionally presents an alert by setting the didFail state variable. When the form sets the value to to true, the system displays an alert with an \u201cOK\u201d action.\n\nstruct Login: View {\n    @State private var didFail = false\n    let alertTitle: String = \"Login failed.\"\n\n\n    var body: some View {\n        LoginForm(didFail: $didFail)\n            .alert(\n                alertTitle,\n                isPresented: $didFail\n            ) {\n                Button(\"OK\") {\n                    // Handle the acknowledgement.\n                }\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nPresenting an alert\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present."
    },
    {
        "title": "alert(_:isPresented:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:)-3200l",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nDiscussion\n\nIn the example below, a login form conditionally presents an alert by setting the didFail state variable. When the form sets the value to to true, the system displays an alert with an \u201cOK\u201d action.\n\nstruct Login: View {\n    @State private var didFail = false\n\n\n    var body: some View {\n        LoginForm(didFail: $didFail)\n            .alert(\n                \"Login failed.\",\n                isPresented: $didFail\n            ) {\n                Button(\"OK\") {\n                    // Handle the acknowledgement.\n                }\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nSee Also\nPresenting an alert\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present."
    },
    {
        "title": "alert(_:isPresented:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:)-2gsoj",
        "html": "Parameters\ntitle\n\nThe title of the alert.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the alert. When the user presses or taps one of the alert\u2019s actions, the system sets this value to false and dismisses.\n\nactions\n\nA ViewBuilder returning the alert\u2019s actions.\n\nDiscussion\n\nIn the example below, a login form conditionally presents an alert by setting the didFail state variable. When the form sets the value to to true, the system displays an alert with an \u201cOK\u201d action.\n\nstruct Login: View {\n    @State private var didFail = false\n    let alertTitle: String = \"Login failed.\"\n\n\n    var body: some View {\n        LoginForm(didFail: $didFail)\n            .alert(\n                Text(alertTitle),\n                isPresented: $didFail\n            ) {\n                Button(\"OK\") {\n                    // Handle the acknowledgement.\n                }\n            }\n    }\n}\n\n\nAll actions in an alert dismiss the alert after the action runs. The default button is shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nIf no actions are present, the system includes a standard \u201cOK\u201d action. No default cancel action is provided. If you want to show a cancel action, use a button with a role of cancel.\n\nOn iOS, tvOS, and watchOS, alerts only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nPresenting an alert\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present."
    },
    {
        "title": "PresentationBackgroundInteraction",
        "url": "https://developer.apple.com/documentation/swiftui/presentationbackgroundinteraction",
        "html": "Overview\n\nUse values of this type with the presentationBackgroundInteraction(_:) modifier.\n\nTopics\nGetting interaction types\nstatic var automatic: PresentationBackgroundInteraction\nThe default background interaction for the presentation.\nstatic var disabled: PresentationBackgroundInteraction\nPeople can\u2019t interact with the view behind a presentation.\nstatic var enabled: PresentationBackgroundInteraction\nPeople can interact with the view behind a presentation.\nstatic func enabled(upThrough: PresentationDetent) -> PresentationBackgroundInteraction\nPeople can interact with the view behind a presentation up through a specified detent.\nRelationships\nConforms To\nSendable\nSee Also\nStyling a sheet and its background\nfunc presentationCornerRadius(CGFloat?) -> some View\nRequests that the presentation have a specific corner radius.\nfunc presentationBackground<S>(S) -> some View\nSets the presentation background of the enclosing sheet using a shape style.\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> some View\nSets the presentation background of the enclosing sheet to a custom view.\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> some View\nControls whether people can interact with the view behind a presentation."
    },
    {
        "title": "PresentationContentInteraction",
        "url": "https://developer.apple.com/documentation/swiftui/presentationcontentinteraction",
        "html": "Overview\n\nUse values of this type with the presentationContentInteraction(_:) modifier.\n\nTopics\nGetting interaction behaviors\nstatic var automatic: PresentationContentInteraction\nThe default swipe behavior for the presentation.\nstatic var resizes: PresentationContentInteraction\nA behavior that prioritizes resizing a presentation when swiping, rather than scrolling the content of the presentation.\nstatic var scrolls: PresentationContentInteraction\nA behavior that prioritizes scrolling the content of a presentation when swiping, rather than resizing the presentation.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nstruct PresentationDetent\nA type that represents a height where a sheet naturally rests.\nprotocol CustomPresentationDetent\nThe definition of a custom detent with a calculated height."
    },
    {
        "title": "PresentationDetent",
        "url": "https://developer.apple.com/documentation/swiftui/presentationdetent",
        "html": "Topics\nGetting built-in detents\nstatic let large: PresentationDetent\nThe system detent for a sheet at full height.\nstatic let medium: PresentationDetent\nThe system detent for a sheet that\u2019s approximately half the height of the screen, and is inactive in compact height.\nCreating custom detents\nstatic func custom<D>(D.Type) -> PresentationDetent\nA custom detent with a calculated height.\nstatic func fraction(CGFloat) -> PresentationDetent\nA custom detent with the specified fractional height.\nstatic func height(CGFloat) -> PresentationDetent\nA custom detent with the specified height.\nstruct Context\nInformation that you use to calculate the presentation\u2019s height.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nprotocol CustomPresentationDetent\nThe definition of a custom detent with a calculated height.\nstruct PresentationContentInteraction\nA behavior that you can use to influence how a presentation responds to swipe gestures."
    },
    {
        "title": "presentationDragIndicator(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationdragindicator(_:)",
        "html": "Parameters\nvisibility\n\nThe preferred visibility of the drag indicator.\n\nDiscussion\n\nYou can show a drag indicator when it isn\u2019t apparent that a sheet can resize or when the sheet can\u2019t dismiss interactively.\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationDetents([.medium, .large])\n                .presentationDragIndicator(.visible)\n        }\n    }\n}\n\nSee Also\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nstruct PresentationDetent\nA type that represents a height where a sheet naturally rests.\nprotocol CustomPresentationDetent\nThe definition of a custom detent with a calculated height.\nstruct PresentationContentInteraction\nA behavior that you can use to influence how a presentation responds to swipe gestures."
    },
    {
        "title": "presentationDetents(_:selection:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationdetents(_:selection:)",
        "html": "Parameters\ndetents\n\nA set of supported detents for the sheet. If you provide more that one detent, people can drag the sheet to resize it.\n\nselection\n\nA Binding to the currently selected detent. Ensure that the value matches one of the detents that you provide for the detents parameter.\n\nDiscussion\n\nBy default, sheets support the large detent.\n\nstruct ContentView: View {\n    @State private var showSettings = false\n    @State private var settingsDetent = PresentationDetent.medium\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationDetents(\n                    [.medium, .large],\n                    selection: $settingsDetent\n                 )\n        }\n    }\n}\n\nSee Also\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nstruct PresentationDetent\nA type that represents a height where a sheet naturally rests.\nprotocol CustomPresentationDetent\nThe definition of a custom detent with a calculated height.\nstruct PresentationContentInteraction\nA behavior that you can use to influence how a presentation responds to swipe gestures."
    },
    {
        "title": "presentationContentInteraction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationcontentinteraction(_:)",
        "html": "Parameters\nbehavior\n\nThe requested behavior.\n\nDiscussion\n\nBy default, when a person swipes up on a scroll view in a resizable presentation, the presentation grows to the next detent. A scroll view embedded in the presentation only scrolls after the presentation reaches its largest size. Use this modifier to control which action takes precedence.\n\nFor example, you can request that swipe gestures scroll content first, resizing the sheet only after hitting the end of the scroll view, by passing the scrolls value to this modifier:\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationDetents([.medium, .large])\n                .presentationContentInteraction(.scrolls)\n        }\n    }\n}\n\n\nPeople can always resize your presentation using the drag indicator.\n\nSee Also\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nstruct PresentationDetent\nA type that represents a height where a sheet naturally rests.\nprotocol CustomPresentationDetent\nThe definition of a custom detent with a calculated height.\nstruct PresentationContentInteraction\nA behavior that you can use to influence how a presentation responds to swipe gestures."
    },
    {
        "title": "presentationDetents(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationdetents(_:)",
        "html": "Parameters\ndetents\n\nA set of supported detents for the sheet. If you provide more that one detent, people can drag the sheet to resize it.\n\nDiscussion\n\nBy default, sheets support the large detent.\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationDetents([.medium, .large])\n        }\n    }\n}\n\nSee Also\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nstruct PresentationDetent\nA type that represents a height where a sheet naturally rests.\nprotocol CustomPresentationDetent\nThe definition of a custom detent with a calculated height.\nstruct PresentationContentInteraction\nA behavior that you can use to influence how a presentation responds to swipe gestures."
    },
    {
        "title": "popover(item:attachmentAnchor:arrowEdge:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/popover(item:attachmentanchor:arrowedge:content:)",
        "html": "Parameters\nitem\n\nA binding to an optional source of truth for the popover. When item is non-nil, the system passes the contents to the modifier\u2019s closure. You use this content to populate the fields of a popover that you create that the system displays to the user. If item changes, the system dismisses the currently presented popover and replaces it with a new popover using the same process.\n\nattachmentAnchor\n\nThe positioning anchor that defines the attachment point of the popover. The default is bounds.\n\narrowEdge\n\nThe edge of the attachmentAnchor that defines the location of the popover\u2019s arrow in macOS. The default is Edge.top. iOS ignores this parameter.\n\ncontent\n\nA closure returning the content of the popover.\n\nDiscussion\n\nUse this method when you need to present a popover with content from a custom data source. The example below uses data in the PopoverModel structure to populate the view in the content closure that the popover displays to the user:\n\nstruct PopoverExample: View {\n    @State private var popover: PopoverModel?\n\n\n    var body: some View {\n        Button(\"Show Popover\") {\n            popover = PopoverModel(message: \"Custom Message\")\n        }\n        .popover(item: $popover) { detail in\n            Text(\"\\(detail.message)\")\n                .padding()\n        }\n    }\n}\n\n\nstruct PopoverModel: Identifiable {\n    var id: String { message }\n    let message: String\n}\n\n\nSee Also\nShowing a sheet, cover, or popover\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nenum PopoverAttachmentAnchor\nAn attachment anchor for a popover."
    },
    {
        "title": "sheet(item:onDismiss:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/sheet(item:ondismiss:content:)",
        "html": "Parameters\nitem\n\nA binding to an optional source of truth for the sheet. When item is non-nil, the system passes the item\u2019s content to the modifier\u2019s closure. You display this content in a sheet that you create that the system displays to the user. If item changes, the system dismisses the sheet and replaces it with a new one using the same process.\n\nonDismiss\n\nThe closure to execute when dismissing the sheet.\n\ncontent\n\nA closure returning the content of the sheet.\n\nDiscussion\n\nUse this method when you need to present a modal view with content from a custom data source. The example below shows a custom data source InventoryItem that the content closure uses to populate the display the action sheet shows to the user:\n\nstruct ShowPartDetail: View {\n    @State private var sheetDetail: InventoryItem?\n\n\n    var body: some View {\n        Button(\"Show Part Details\") {\n            sheetDetail = InventoryItem(\n                id: \"0123456789\",\n                partNumber: \"Z-1234A\",\n                quantity: 100,\n                name: \"Widget\")\n        }\n        .sheet(item: $sheetDetail,\n               onDismiss: didDismiss) { detail in\n            VStack(alignment: .leading, spacing: 20) {\n                Text(\"Part Number: \\(detail.partNumber)\")\n                Text(\"Name: \\(detail.name)\")\n                Text(\"Quantity On-Hand: \\(detail.quantity)\")\n            }\n            .onTapGesture {\n                sheetDetail = nil\n            }\n        }\n    }\n\n\n    func didDismiss() {\n        // Handle the dismissing action.\n    }\n}\n\n\nstruct InventoryItem: Identifiable {\n    var id: String\n    let partNumber: String\n    let quantity: Int\n    let name: String\n}\n\n\nIn vertically compact environments, such as iPhone in landscape orientation, a sheet presentation automatically adapts to appear as a full-screen cover. Use the presentationCompactAdaptation(_:) or presentationCompactAdaptation(horizontal:vertical:) modifier to override this behavior.\n\nSee Also\nShowing a sheet, cover, or popover\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content.\nenum PopoverAttachmentAnchor\nAn attachment anchor for a popover."
    },
    {
        "title": "popover(isPresented:attachmentAnchor:arrowEdge:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/popover(ispresented:attachmentanchor:arrowedge:content:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that determines whether to present the popover content that you return from the modifier\u2019s content closure.\n\nattachmentAnchor\n\nThe positioning anchor that defines the attachment point of the popover. The default is bounds.\n\narrowEdge\n\nThe edge of the attachmentAnchor that defines the location of the popover\u2019s arrow in macOS. The default is Edge.top. iOS ignores this parameter.\n\ncontent\n\nA closure returning the content of the popover.\n\nDiscussion\n\nUse this method to show a popover whose contents are a SwiftUI view that you provide when a bound Boolean variable is true. In the example below, a popover displays whenever the user toggles the isShowingPopover state variable by pressing the \u201cShow Popover\u201d button:\n\nstruct PopoverExample: View {\n    @State private var isShowingPopover = false\n\n\n    var body: some View {\n        Button(\"Show Popover\") {\n            self.isShowingPopover = true\n        }\n        .popover(isPresented: $isShowingPopover) {\n            Text(\"Popover Content\")\n                .padding()\n        }\n    }\n}\n\n\nSee Also\nShowing a sheet, cover, or popover\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content.\nenum PopoverAttachmentAnchor\nAn attachment anchor for a popover."
    },
    {
        "title": "fullScreenCover(isPresented:onDismiss:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fullscreencover(ispresented:ondismiss:content:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that determines whether to present the sheet.\n\nonDismiss\n\nThe closure to execute when dismissing the modal view.\n\ncontent\n\nA closure that returns the content of the modal view.\n\nDiscussion\n\nUse this method to show a modal view that covers as much of the screen as possible. The example below displays a custom view when the user toggles the value of the isPresenting binding:\n\nstruct FullScreenCoverPresentedOnDismiss: View {\n    @State private var isPresenting = false\n    var body: some View {\n        Button(\"Present Full-Screen Cover\") {\n            isPresenting.toggle()\n        }\n        .fullScreenCover(isPresented: $isPresenting,\n                         onDismiss: didDismiss) {\n            VStack {\n                Text(\"A full-screen modal view.\")\n                    .font(.title)\n                Text(\"Tap to Dismiss\")\n            }\n            .onTapGesture {\n                isPresenting.toggle()\n            }\n            .foregroundColor(.white)\n            .frame(maxWidth: .infinity,\n                   maxHeight: .infinity)\n            .background(Color.blue)\n            .ignoresSafeArea(edges: .all)\n        }\n    }\n\n\n    func didDismiss() {\n        // Handle the dismissing action.\n    }\n}\n\n\nSee Also\nShowing a sheet, cover, or popover\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content.\nenum PopoverAttachmentAnchor\nAn attachment anchor for a popover."
    },
    {
        "title": "fullScreenCover(item:onDismiss:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fullscreencover(item:ondismiss:content:)",
        "html": "Parameters\nitem\n\nA binding to an optional source of truth for the sheet. When item is non-nil, the system passes the contents to the modifier\u2019s closure. You display this content in a sheet that you create that the system displays to the user. If item changes, the system dismisses the currently displayed sheet and replaces it with a new one using the same process.\n\nonDismiss\n\nThe closure to execute when dismissing the modal view.\n\ncontent\n\nA closure returning the content of the modal view.\n\nDiscussion\n\nUse this method to display a modal view that covers as much of the screen as possible. In the example below a custom structure \u2014 CoverData \u2014 provides data for the full-screen view to display in the content closure when the user clicks or taps the \u201cPresent Full-Screen Cover With Data\u201d button:\n\nstruct FullScreenCoverItemOnDismissContent: View {\n    @State private var coverData: CoverData?\n\n\n    var body: some View {\n        Button(\"Present Full-Screen Cover With Data\") {\n            coverData = CoverData(body: \"Custom Data\")\n        }\n        .fullScreenCover(item: $coverData,\n                         onDismiss: didDismiss) { details in\n            VStack(spacing: 20) {\n                Text(\"\\(details.body)\")\n            }\n            .onTapGesture {\n                coverData = nil\n            }\n        }\n    }\n\n\n    func didDismiss() {\n        // Handle the dismissing action.\n    }\n\n\n}\n\n\nstruct CoverData: Identifiable {\n    var id: String {\n        return body\n    }\n    let body: String\n}\n\n\nSee Also\nShowing a sheet, cover, or popover\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content.\nenum PopoverAttachmentAnchor\nAn attachment anchor for a popover."
    },
    {
        "title": "presentationCompactAdaptation(horizontal:vertical:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationcompactadaptation(horizontal:vertical:)",
        "html": "Parameters\nhorizontalAdaptation\n\nThe adaptation to use in a horizontally compact size class.\n\nverticalAdaptation\n\nThe adaptation to use in a vertically compact size class. In a size class that is both horizontally and vertically compact, SwiftUI uses the verticalAdaptation value.\n\nDiscussion\n\nSome presentations adapt their appearance depending on the context. For example, a popover presentation over a horizontally-compact view uses a sheet appearance by default. Use this modifier to indicate a custom adaptation preference.\n\nstruct ContentView: View {\n    @State private var showInfo = false\n\n\n    var body: some View {\n        Button(\"View Info\") {\n            showInfo = true\n        }\n        .popover(isPresented: $showInfo) {\n            InfoView()\n                .presentationCompactAdaptation(\n                    horizontal: .popover,\n                    vertical: .sheet)\n        }\n    }\n}\n\n\nIf you want to specify the same adaptation for both dimensions, use the presentationCompactAdaptation(_:) method instead.\n\nSee Also\nAdapting a presentation to size classes\nfunc presentationCompactAdaptation(PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to compact size classes.\nstruct PresentationAdaptation\nStrategies for adapting a presentation to a different size class."
    },
    {
        "title": "PresentationAdaptation",
        "url": "https://developer.apple.com/documentation/swiftui/presentationadaptation",
        "html": "Overview\n\nUse values of this type with the presentationCompactAdaptation(_:) and presentationCompactAdaptation(horizontal:vertical:) modifiers.\n\nTopics\nGetting adaptation strategies\nstatic var automatic: PresentationAdaptation\nUse the default presentation adaptation.\nstatic var none: PresentationAdaptation\nDon\u2019t adapt for the size class, if possible.\nstatic var fullScreenCover: PresentationAdaptation\nPrefer a full-screen-cover appearance when adapting for size classes.\nstatic var popover: PresentationAdaptation\nPrefer a popover appearance when adapting for size classes.\nstatic var sheet: PresentationAdaptation\nPrefer a sheet appearance when adapting for size classes.\nRelationships\nConforms To\nSendable\nSee Also\nAdapting a presentation to size classes\nfunc presentationCompactAdaptation(horizontal: PresentationAdaptation, vertical: PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to horizontally and vertically compact size classes.\nfunc presentationCompactAdaptation(PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to compact size classes."
    },
    {
        "title": "toolbar(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbar(_:for:)",
        "html": "Parameters\nvisibility\n\nThe preferred visibility of the bar.\n\nbars\n\nThe bars to update the visibility of or automatic if empty.\n\nDiscussion\n\nThe preferred visibility flows up to the nearest container that renders a bar. This could be a NavigationView or TabView in iOS, or the root view of a WindowGroup in macOS.\n\nThis examples shows a view that hides the navigation bar.\n\nNavigationView {\n    ContentView()\n        .toolbar(.hidden)\n}\n\n\nYou can provide multiple ToolbarPlacement instances to hide multiple bars at once.\n\nTabView {\n    NavigationView {\n        ContentView()\n            .toolbar(\n                .hidden, for: .navigationBar, .tabBar)\n    }\n}\n\n\nNote\n\nIn macOS, if you provide ToolbarCommands to the scene of your app, this modifier disables the toolbar visibility command while the value of the modifier is not automatic.\n\nDepending on the specified bars, the requested visibility may not be able to be fullfilled.\n\nSee Also\nSetting toolbar visibility\nstruct ToolbarPlacement\nThe placement of a toolbar."
    },
    {
        "title": "presentationCompactAdaptation(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationcompactadaptation(_:)",
        "html": "Parameters\nadaptation\n\nThe adaptation to use in either a horizontally or vertically compact size class.\n\nDiscussion\n\nSome presentations adapt their appearance depending on the context. For example, a sheet presentation over a vertically-compact view uses a full-screen-cover appearance by default. Use this modifier to indicate a custom adaptation preference. For example, the following code uses a presentation adaptation value of none to request that the system not adapt the sheet in compact size classes:\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationDetents([.medium, .large])\n                .presentationCompactAdaptation(.none)\n        }\n    }\n}\n\n\nIf you want to specify different adaptations for each dimension, use the presentationCompactAdaptation(horizontal:vertical:) method instead.\n\nSee Also\nAdapting a presentation to size classes\nfunc presentationCompactAdaptation(horizontal: PresentationAdaptation, vertical: PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to horizontally and vertically compact size classes.\nstruct PresentationAdaptation\nStrategies for adapting a presentation to a different size class."
    },
    {
        "title": "fileImporter(isPresented:allowedContentTypes:allowsMultipleSelection:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileimporter(ispresented:allowedcontenttypes:allowsmultipleselection:oncompletion:oncancellation:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the dialog should be shown.\n\nallowedContentTypes\n\nThe list of supported content types which can be imported.\n\nallowsMultipleSelection\n\nWhether the importer allows the user to select more than one file to import.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. The result indicates whether the operation succeeded or failed. To access the received URLs, call startAccessingSecurityScopedResource. When the access is no longer required, call stopAccessingSecurityScopedResource.\n\nonCancellation\n\nA callback that will be invoked if the user cancels the operation.\n\nDiscussion\n\nIn order for the dialog to appear, isPresented must be true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nNote\n\nThis dialog provides security-scoped URLs. Call the startAccessingSecurityScopedResource method to access or bookmark the URLs, and the stopAccessingSecurityScopedResource method to release the access.\n\nFor example, a button that allows the user to choose multiple PDF files for the application to combine them later, might look like this:\n\n   struct PickPDFsButton: View {\n       @State private var showFileImporter = false\n       var handlePickedPDF: (URL) -> Void\n\n\n       var body: some View {\n           Button {\n               showFileImporter = true\n           } label: {\n               Label(\"Choose PDFs to combine\", systemImage: \"doc.circle\")\n           }\n           .fileImporter(\n               isPresented: $showFileImporter,\n               allowedContentTypes: [.pdf],\n               allowsMultipleSelection: true\n           ) { result in\n               switch result {\n               case .success(let files):\n                   files.forEach { file in\n                       // gain access to the directory\n                       let gotAccess = file.startAccessingSecurityScopedResource()\n                       if !gotAccess { return }\n                       // access the directory URL\n                       // (read templates in the directory, make a bookmark, etc.)\n                       handlePickedPDF(file)\n                       // release access\n                       file.stopAccessingSecurityScopedResource()\n                   }\n               case .failure(let error):\n                   // handle error\n                   print(error)\n               }\n           }\n       }\n   }\n\n\nNote\n\nChanging allowedContentTypes or allowsMultipleSelection while the file importer is presented will have no immediate effect, however will apply the next time it is presented.\n\nSee Also\nImporting from file\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import multiple files.\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import an existing file."
    },
    {
        "title": "fileExporterFilenameLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileexporterfilenamelabel(_:)-9bslp",
        "html": "Parameters\nlabel\n\nThe string to use as the label for the file name field.\n\nSee Also\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field."
    },
    {
        "title": "fileImporter(isPresented:allowedContentTypes:onCompletion:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/fileimporter(ispresented:allowedcontenttypes:oncompletion:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the interface should be shown.\n\nallowedContentTypes\n\nThe list of supported content types which can be imported.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. To access the received URLs, call startAccessingSecurityScopedResource. When the access is no longer required, call stopAccessingSecurityScopedResource.\n\nresult\n\nA Result indicating whether the operation succeeded or failed.\n\nDiscussion\n\nIn order for the interface to appear, isPresented must be true. When the operation is finished, isPresented will be set to false before onCompletion is called. If the user cancels the operation, isPresented will be set to false and onCompletion will not be called.\n\nNote\n\nThis dialog provides security-scoped URLs. Call the startAccessingSecurityScopedResource method to access or bookmark the URLs, and the stopAccessingSecurityScopedResource method to release the access.\n\nFor example, an application can have a button that allows the user to choose the default directory with document templates loaded on every launch. Such a button might look like this:\n\n struct PickTemplatesDirectoryButton: View {\n     @State private var showFileImporter = false\n     var onTemplatesDirectoryPicked: (URL) -> Void\n\n\n     var body: some View {\n         Button {\n             showFileImporter = true\n         } label: {\n             Label(\"Choose templates directory\", systemImage: \"folder.circle\")\n         }\n         .fileImporter(\n             isPresented: $showFileImporter,\n             allowedContentTypes: [.directory]\n         ) { result in\n              switch result {\n              case .success(let directory):\n                  // gain access to the directory\n                  let gotAccess = directory.startAccessingSecurityScopedResource()\n                  if !gotAccess { return }\n                  // access the directory URL\n                  // (read templates in the directory, make a bookmark, etc.)\n                  onTemplatesDirectoryPicked(directory)\n                  // release access\n                  directory.stopAccessingSecurityScopedResource()\n              case .failure(let error):\n                  // handle error\n                  print(error)\n              }\n         }\n     }\n }\n\n\nNote\n\nChanging allowedContentTypes while the file importer is presented will have no immediate effect, however will apply the next time it is presented.\n\nSee Also\nImporting from file\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import multiple files.\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to import multiple files."
    },
    {
        "title": "fileMover(isPresented:files:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:files:oncompletion:oncancellation:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the dialog should be shown.\n\nfiles\n\nA collection of URLs for the files to be moved.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. The result indicates whether the operation succeeded or failed. To access the received URLs, call startAccessingSecurityScopedResource. When the access is no longer required, call stopAccessingSecurityScopedResource.\n\nonCancellation\n\nA callback that will be invoked if the user cancels the operation.\n\nDiscussion\n\nNote\n\nThis dialog provides security-scoped URLs. Call the startAccessingSecurityScopedResource method to access or bookmark the URLs, and the stopAccessingSecurityScopedResource method to release the access.\n\nFor example, a button that allows the user to move files might look like this:\n\n  struct MoveFilesButton: View {\n      @Binding var files: [URL]\n      @State private var showFileMover = false\n      var onCompletion: (URL) -> Void\n      var onCancellation: (() -> Void)?\n\n\n      var body: some View {\n          Button {\n              showFileMover = true\n          } label: {\n              Label(\"Choose destination\", systemImage: \"folder.circle\")\n          }\n          .fileMover(isPresented: $showFileMover, files: files) { result in\n              switch result {\n              case .success(let urls):\n                  urls.forEach { url in\n                      guard url.startAccessingSecurityScopedResource() else {\n                          return\n                      }\n                      onCompletion(url)\n                      url.stopAccessingSecurityScopedResource()\n                  }\n              case .failure(let error):\n                  print(error)\n                  // handle error\n              }\n          } onCancellation: {\n              onCancellation?()\n          }\n      }\n  }\n\nSee Also\nMoving a file\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move a collection of existing files to a new location.\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move an existing file to a new location."
    },
    {
        "title": "fileMover(isPresented:file:onCompletion:onCancellation:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:file:oncompletion:oncancellation:)",
        "html": "Parameters\nisPresented\n\nA binding to whether the dialog should be shown.\n\nfile\n\nThe URL of the file to be moved.\n\nonCompletion\n\nA callback that will be invoked when the operation has succeeded or failed. The result indicates whether the operation succeeded or failed. To access the received URLs, call startAccessingSecurityScopedResource. When the access is no longer required, call stopAccessingSecurityScopedResource.\n\nonCancellation\n\nA callback that will be invoked if the user cancels the operation.\n\nDiscussion\n\nNote\n\nThis dialog provides security-scoped URLs. Call the startAccessingSecurityScopedResource method to access or bookmark the URLs, and the stopAccessingSecurityScopedResource method to release the access.\n\nFor example, a button that allows the user to move a file might look like this:\n\n  struct MoveFileButton: View {\n      @State private var showFileMover = false\n      var file: URL\n      var onCompletion: (URL) -> Void\n      var onCancellation: (() -> Void)?\n\n\n      var body: some View {\n          Button {\n              showFileMover = true\n          } label: {\n              Label(\"Choose destination\", systemImage: \"folder.circle\")\n          }\n          .fileMover(isPresented: $showFileMover, file: file) { result in\n              switch result {\n              case .success(let url):\n                  guard url.startAccessingSecurityScopedResource() else {\n                      return\n                  }\n                  onCompletion(url)\n                  url.stopAccessingSecurityScopedResource()\n              case .failure(let error):\n                  print(error)\n                  // handle error\n              }\n          } onCancellation: {\n              onCancellation?()\n          }\n      }\n  }\n\nSee Also\nMoving a file\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move a collection of existing files to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move a collection of existing files to a new location."
    },
    {
        "title": "fileDialogBrowserOptions(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/filedialogbrowseroptions(_:)",
        "html": "Parameters\noptions\n\nThe search options to apply to a given file dialog.\n\nSee Also\nConfiguring a file dialog\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system."
    },
    {
        "title": "SearchFieldPlacement",
        "url": "https://developer.apple.com/documentation/swiftui/searchfieldplacement",
        "html": "Overview\n\nYou can give a preferred placement to any of the searchable modifiers, like searchable(text:placement:prompt:):\n\nvar body: some View {\n    NavigationView {\n        PrimaryView()\n        SecondaryView()\n        Text(\"Select a primary and secondary item\")\n    }\n    .searchable(text: $text, placement: .sidebar)\n}\n\n\nDepending on the containing view hierachy, SwiftUI might not be able to fulfill your request.\n\nTopics\nGetting a search field placement\nstatic let automatic: SearchFieldPlacement\nSwiftUI places the search field automatically.\nstatic let navigationBarDrawer: SearchFieldPlacement\nThe search field appears in the navigation bar.\nstatic func navigationBarDrawer(displayMode: SearchFieldPlacement.NavigationBarDrawerDisplayMode) -> SearchFieldPlacement\nThe search field appears in the navigation bar using the specified display mode.\nstatic let sidebar: SearchFieldPlacement\nThe search field appears in the sidebar of a navigation view.\nstatic let toolbar: SearchFieldPlacement\nThe search field appears in the toolbar.\nSupporting types\nstruct NavigationBarDrawerDisplayMode\nA mode that determines when to display a search field that appears in a navigation bar.\nRelationships\nConforms To\nSendable\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field."
    },
    {
        "title": "dialogSuppressionToggle(_:isSuppressed:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dialogsuppressiontoggle(_:issuppressed:)-2r3q4",
        "html": "Parameters\ntitle\n\nThe title of the suppression toggle in the dialog. This parameter can be elided to use the default suppression title.\n\nisSuppressed\n\nWhether the suppression toggle is on or off in the dialog.\n\nDiscussion\n\nApplying dialog suppression adds a toggle to dialogs on macOS, which allows the user to request the alert not be displayed again. Typically whether a dialog is suppressed is stored in AppStorage and used to decide whether to present the dialog in the future.\n\nThe following example configures a confirmationDialog with a suppression toggle. The toggle\u2019s state is stored in AppStorage and used to determine whether or not to show the dialog when the \u201cDelete Items\u201d button is pressed.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n\n\n    @AppStorage(\"suppressEraseItemAlert\")\n    private var suppressAlert = false\n\n\n    var body: some View {\n        Button(\"Delete Items\") {\n            if !suppressAlert {\n                isShowingDialog = true\n            } else {\n                // Handle item deletion.\n            }\n        }\n        .confirmationDialog(\n            \"Are you sure you want to erase these items?\",\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Erase\", role: .destructive) {\n                // Handle item deletion.\n            }\n            Button(\"Cancel\", role: .cancel) {\n                isShowingDialog = false\n            }\n        }\n        .dialogSuppressionToggle(\n            \"Do not ask about erasing items again\",\n            isSuppressed: $suppressAlert)\n    }\n}\n\nSee Also\nConfiguring a dialog\nfunc dialogIcon(Image?) -> some View\nConfigures the icon used by dialogs within this view.\nfunc dialogSeverity(DialogSeverity) -> some View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a default suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms."
    },
    {
        "title": "dialogSuppressionToggle(_:isSuppressed:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dialogsuppressiontoggle(_:issuppressed:)-1smxd",
        "html": "Parameters\ntitleKey\n\nThe title of the suppression toggle in the dialog. This parameter can be elided to use the default suppression title.\n\nisSuppressed\n\nWhether the suppression toggle is on or off in the dialog.\n\nDiscussion\n\nApplying dialog suppression adds a toggle to dialogs on macOS, which allows the user to request the alert not be displayed again. Typically whether a dialog is suppressed is stored in AppStorage and used to decide whether to present the dialog in the future.\n\nThe following example configures a confirmationDialog with a suppression toggle. The toggle\u2019s state is stored in AppStorage and used to determine whether or not to show the dialog when the \u201cDelete Items\u201d button is pressed.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n\n\n    @AppStorage(\"suppressEraseItemAlert\")\n    private var suppressAlert = false\n\n\n    var body: some View {\n        Button(\"Delete Items\") {\n            if !suppressAlert {\n                isShowingDialog = true\n            } else {\n                // Handle item deletion.\n            }\n        }\n        .confirmationDialog(\n            \"Are you sure you want to erase these items?\",\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Erase\", role: .destructive) {\n                // Handle item deletion.\n            }\n            Button(\"Cancel\", role: .cancel) {\n                isShowingDialog = false\n            }\n        }\n        .dialogSuppressionToggle(\n            \"Do not ask about erasing items again\",\n            isSuppressed: $suppressAlert)\n    }\n}\n\nSee Also\nConfiguring a dialog\nfunc dialogIcon(Image?) -> some View\nConfigures the icon used by dialogs within this view.\nfunc dialogSeverity(DialogSeverity) -> some View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a default suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms."
    },
    {
        "title": "dialogSuppressionToggle(_:isSuppressed:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dialogsuppressiontoggle(_:issuppressed:)-39ebw",
        "html": "Parameters\nlabel\n\nThe label of the suppression toggle in the dialog. This parameter can be elided to use the default suppression title.\n\nisSuppressed\n\nWhether the suppression toggle is on or off in the dialog.\n\nDiscussion\n\nApplying dialog suppression adds a toggle to dialogs on macOS, which allows the user to request the alert not be displayed again. Typically whether a dialog is suppressed is stored in AppStorage and used to decide whether to present the dialog in the future.\n\nThe following example configures a confirmationDialog with a suppression toggle. The toggle\u2019s state is stored in AppStorage and used to determine whether or not to show the dialog when the \u201cDelete Items\u201d button is pressed.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n\n\n    @AppStorage(\"suppressEraseItemAlert\")\n    private var suppressAlert = false\n\n\n    var body: some View {\n        Button(\"Delete Items\") {\n            if !suppressAlert {\n                isShowingDialog = true\n            } else {\n                // Handle item deletion.\n            }\n        }\n        .confirmationDialog(\n            \"Are you sure you want to erase these items?\",\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Erase\", role: .destructive) {\n                // Handle item deletion.\n            }\n            Button(\"Cancel\", role: .cancel) {\n                isShowingDialog = false\n            }\n        }\n        .dialogSuppressionToggle(\n            Text(\"Do not ask about erasing items again\"),\n            isSuppressed: $suppressAlert)\n    }\n}\n\nSee Also\nConfiguring a dialog\nfunc dialogIcon(Image?) -> some View\nConfigures the icon used by dialogs within this view.\nfunc dialogSeverity(DialogSeverity) -> some View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a default suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms."
    },
    {
        "title": "searchable(text:editableTokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:editabletokens:placement:prompt:token:)-8y2px",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\neditableTokens\n\nA collection of tokens to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "searchable(text:editableTokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:editabletokens:placement:prompt:token:)-4ip1h",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\neditableTokens\n\nA collection of tokens to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "DynamicProperty",
        "url": "https://developer.apple.com/documentation/swiftui/dynamicproperty",
        "html": "Overview\n\nThe view gives values to these properties prior to recomputing the view\u2019s body.\n\nTopics\nUpdating the value\nfunc update()\nUpdates the underlying value of the stored value.\n\nRequired Default implementation provided.\n\nRelationships\nConforming Types\nAccessibilityFocusState\nAppStorage\nBinding\nEnvironment\nEnvironmentObject\nFetchRequest\nConforms when Result conforms to NSFetchRequestResult.\nFocusState\nFocusedBinding\nFocusedObject\nFocusedValue\nGestureState\nNSApplicationDelegateAdaptor\nNamespace\nObservedObject\nPhysicalMetric\nScaledMetric\nSceneStorage\nSectionedFetchRequest\nConforms when SectionIdentifier conforms to Hashable and Result conforms to NSFetchRequestResult.\nState\nStateObject\nUIApplicationDelegateAdaptor\nWKApplicationDelegateAdaptor\nWKExtensionDelegateAdaptor"
    },
    {
        "title": "searchable(text:placement:prompt:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:placement:prompt:)-co5e",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "onChange(of:initial:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onchange(of:initial:_:)-8wgw9",
        "html": "Parameters\nvalue\n\nThe value to check against when determining whether to run the closure.\n\ninitial\n\nWhether the action should be run when this view initially appears.\n\naction\n\nA closure to run when the value changes.\n\nReturn Value\n\nA view that fires an action when the specified value changes.\n\nDiscussion\n\nYou can use onChange to trigger a side effect as the result of a value changing, such as an Environment key or a Binding.\n\nThe system may call the action closure on the main actor, so avoid long-running tasks in the closure. If you need to perform such tasks, detach an asynchronous background task.\n\nWhen the value changes, the new version of the closure will be called, so any captured values will have their values from the time that the observed value has its new value. In the following code example, PlayerView calls into its model when playState changes model.\n\nstruct PlayerView: View {\n    var episode: Episode\n    @State private var playState: PlayState = .paused\n\n\n    var body: some View {\n        VStack {\n            Text(episode.title)\n            Text(episode.showTitle)\n            PlayButton(playState: $playState)\n        }\n        .onChange(of: playState) {\n            model.playStateDidChange(state: playState)\n        }\n    }\n}\n\nSee Also\nResponding to data changes\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes.\nfunc onReceive<P>(P, perform: (P.Output) -> Void) -> some View\nAdds an action to perform when this view detects data emitted by the given publisher."
    },
    {
        "title": "Managing model data in your app",
        "url": "https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app",
        "html": "Overview\n\nA SwiftUI app can display data that people can change using the app\u2019s user interface (UI). To manage that data, an app creates a data model, which is a custom type that represents the data. A data model provides separation between the data and the views that interact with the data. This separation promotes modularity, improves testability, and helps make it easier to reason about how the app works.\n\nKeeping the model data (that is, an instance of a data model) in sync with what appears on the screen can be challenging, especially when the data appears in multiple views of the UI at the same time.\n\nSwiftUI helps keep your app\u2019s UI up to date with changes made to the data thanks to Observation. With Observation, a view in SwiftUI can form dependencies on observable data models and update the UI when data changes.\n\nNote\n\nObservation support in SwiftUI is available starting with iOS 17, iPadOS 17, macOS 14, tvOS 17, and watchOS 10. For information about adopting Observation in existing apps, see Migrating from the Observable Object protocol to the Observable macro.\n\nMake model data observable\n\nTo make data changes visible to SwiftUI, apply the Observable() macro to your data model. This macro generates code that adds observation support to your data model at compile time, keeping your data model code focused on the properties that store data. For example, the following code defines a data model for books:\n\n@Observable class Book: Identifiable {\n    var title = \"Sample Book Title\"\n    var author = Author()\n    var isAvailable = true\n}\n\n\nImportant\n\nThe Observable() macro, in addition to adding observation functionality, also conforms your data model type to the Observable protocol, which serves as a signal to other APIs that your type supports observation. Don\u2019t apply the Observable protocol by itself to your data model type, since that alone doesn\u2019t add any observation functionality. Instead, always use the Observable macro when adding observation support to your type.\n\nObserve model data in a view\n\nIn SwiftUI, a view forms a dependency on an observable data model object, such as an instance of Book, when the view\u2019s body property reads a property of the object. If body doesn\u2019t read any properties of an observable data model object, the view doesn\u2019t track any dependencies.\n\nWhen a tracked property changes, SwiftUI updates the view. If other properties change that body doesn\u2019t read, the view is unaffected and avoids unnecessary updates. For example, the view in the following code updates only when a book\u2019s title changes but not when author or isAvailable changes:\n\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n\n\nSwiftUI establishes this dependency tracking even if the view doesn\u2019t store the observable type, such as when using a global property or singleton:\n\nvar globalBook: Book = Book()\n\n\nstruct BookView: View {\n    var body: some View {\n        Text(globalBook.title)\n    }\n}\n\n\nObservation also supports tracking of computed properties when the computed property makes use of an observable property. For instance, the view in the following code updates when the number of available books changes:\n\n@Observable class Library {\n    var books: [Book] = [Book(), Book(), Book()]\n    \n    var availableBooksCount: Int {\n        books.filter(\\.isAvailable).count\n    }\n}\n\n\nstruct LibraryView: View {\n    @Environment(Library.self) private var library\n    \n    var body: some View {\n        NavigationStack {\n            List(library.books) { book in\n                // ...\n            }\n            .navigationTitle(\"Books available: \\(library.availableBooksCount)\")\n        }\n    }\n}\n\n\nWhen a view forms a dependency on a collection of objects, of any collection type, the view tracks changes made to the collection itself. For instance, the view in the following code forms a dependency on books because body reads it. As changes occur to books, such as inserting, deleting, moving, or replacing items in the collection, SwiftUI updates the view.\n\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n\n    var body: some View {\n        List(books) { book in \n            Text(book.title)\n        }\n    }\n}\n\n\nHowever, LibraryView doesn\u2019t form a dependency on the property title because the view\u2019s body doesn\u2019t read it directly. The view stores the List content closure as an @escaping closure that SwiftUI calls when lazily creating list items before they appear on the screen. This means that instead of LibraryView depending on a book\u2019s title, each Text item of the list depends on title. Any changes to a title updates only the individual Text representing the book and not the others.\n\nNote\n\nObservation tracks changes to any observable property that appears in the execution scope of a view\u2019s body property.\n\nYou can also share an observable model data object with another view. The receiving view forms a dependency if it reads any properties of the object in the its body. For example, in the following code LibraryView shares an instance of Book with BookView, and BookView displays the book\u2019s title. If the book\u2019s title changes, SwiftUI updates only BookView, and not LibraryView, because only BookView reads the title property.\n\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n\n    var body: some View {\n        List(books) { book in \n            BookView(book: book)\n        }\n    }\n}\n\n\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n\n\nIf a view doesn\u2019t have any dependencies, SwiftUI doesn\u2019t update the view when data changes. This approach allows an observable model data object to pass through multiple layers of a view hierarchy without each intermediate view forming a dependency.\n\n// Will not update when any property of `book` changes.\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n    \n    var body: some View {\n        LibraryItemView(book: book)\n    }\n}\n\n\n// Will not update when any property of `book` changes.\nstruct LibraryItemView: View {\n    var book: Book\n    \n    var body: some View {\n        BookView(book: book)\n    }\n}\n\n\n// Will update when `book.title` changes.\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n\n\nHowever, a view that stores a reference to the observable object updates if the reference changes. This happens because the stored reference is part of the view\u2019s value and not because the object is observable. For example, if the reference to book in the follow code changes, SwiftUI updates the view:\n\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        // ...\n    }\n}\n\n\nA view can also form a dependency on an observable data model object accessed through another object. For example, the view in the following code updates when the author\u2019s name changes:\n\nstruct LibraryItemView: View {\n    var book: Book\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(book.title)\n            Text(\"Written by: \\(book.author.name)\")\n                .font(.caption)\n        }\n    }\n}\n\nCreate the source of truth for model data\n\nTo create and store the source of truth for model data, declare a private variable and initialize it with a instance of an observable data model type. Then wrap it with a State property wrapper. For example, the following code stores an instance of the data model type Book in the state variable book:\n\nstruct BookView: View {\n    @State private var book = Book()\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n\n\nBy wrapping the book with State, you\u2019re telling SwiftUI to manage the storage of the instance. Each time SwiftUI re-creates BookView, it connects the book variable to the managed instance, providing the view a single source of truth for the model data.\n\nYou can also create a state object in your top-level App instance or in one of your app\u2019s Scene instances. For example, the following code creates an instance of Library in the app\u2019s top-level structure:\n\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}\n\nShare model data throughout a view hierarchy\n\nIf you have a data model object, like Library, that you want to share throughout your app, you can either:\n\npass the data model object to each view in the view hierarchy; or\n\nadd the data model object to the view\u2019s environment\n\nPassing model data to each view is convenient when you have a shallow view hierarchy; for example, when a view doesn\u2019t share the object with its subviews. However, you usually don\u2019t know if a view needs to pass the object to subviews, and you may not know if a subview deep inside the layers of the hierarchy needs the model data.\n\nTo share model data throughout a view hierarchy without needing to pass it to each view, add the model data to the view\u2019s environment. You can add the data to the environment using either environment(_:_:) or the environment(_:) modifier, passing in the model data.\n\nBefore you can use the environment(_:_:) modifier, you need to create a custom EnvironmentKey. Then extend EnvironmentValues to include a custom environment property that gets and sets the value for the custom key. For instance, the following code creates an environment key and property for library:\n\nextension EnvironmentValues {\n    var library: Library {\n        get { self[LibraryKey.self] }\n        set { self[LibraryKey.self] = newValue }\n    }\n}\n\n\nprivate struct LibraryKey: EnvironmentKey {\n    static var defaultValue: Library = Library()\n}\n\n\nWith the custom environment key and property in place, a view can add model data to its environment. For example, LibraryView adds the source of truth for a Library instance to its environment using the environment(_:_:) modifier:\n\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(\\.library, library)\n        }\n    }\n}\n\n\nTo retrieve the Library instance from the environment, a view defines a local variable that stores a reference to the instance, and then wraps the variable with the Environment property wrapper, passing in the key path to the custom environment value.\n\nstruct LibraryView: View {\n    @Environment(\\.library) private var library\n\n\n    var body: some View {\n        // ...\n    }\n}\n\n\nYou can also store model data directly in the environment without defining a custom environment value by using the environment(_:) modifier. For instance, the following code adds a Library instance to the environment using this modifier:\n\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}\n\n\nTo retrieve the instance from the environment, another view defines a local variable to store the instance and wraps it with the Environment property wrapper. But instead of providing a key path to the environment value, you can provide the model data type, as shown in the following code:\n\nstruct LibraryView: View {\n    @Environment(Library.self) private var library\n    \n    var body: some View {\n        // ...\n    }\n}\n\n\nBy default, reading an object from the environment returns a non-optional object when using the object type as the key. This default behavior assumes that a view in the current hierarchy previously stored a non-optional instance of the type using the environment(_:) modifier. If a view attempts to retrieve an object using its type and that object isn\u2019t in the environment, SwiftUI throws exception.\n\nIn cases where there is no guarantee that an object is in the environment, retrieve an optional version of the object as shown in the following code. If the object isn\u2019t available the environment, SwiftUI returns nil instead of throwing an exception.\n\n@Environment(Library.self) private var library: Library?\n\nChange model data in a view\n\nIn most apps, people can change data that the app presents. When data changes, any views that display the data should update to reflect the changed data. With Observation in SwiftUI, a view can support data changes without using property wrappers or bindings. For example, the following toggles the isAvailable property of a book in the action closure of a button:\n\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        List {\n            Text(book.title)\n            HStack {\n                Text(book.isAvailable ? \"Available for checkout\" : \"Waiting for return\")\n                Spacer()\n                Button(book.isAvailable ? \"Check out\" : \"Return\") {\n                    book.isAvailable.toggle()\n                }\n            }\n        }\n    }\n}\n\n\nHowever, there may be times when a view expects a binding before it can change the value of a mutable property. To provide a binding, wrap the model data with the Bindable property wrapper. For example, the following code wraps the book variable with @Bindable. Then it uses a TextField to change the title property of a book, and a Toggle to change the isAvailable property, using the $ syntax to pass a binding to each property.\n\nstruct BookEditView: View {\n    @Bindable var book: Book\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        VStack() {\n            HStack {\n                Text(\"Title\")\n                TextField(\"Title\", text: $book.title)\n                    .textFieldStyle(.roundedBorder)\n                    .onSubmit {\n                        dismiss()\n                    }\n            }\n            \n            Toggle(isOn: $book.isAvailable) {\n                Text(\"Book is available\")\n            }\n            \n            Button(\"Close\") {\n                dismiss()\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}\n\n\nYou can use the Bindable property wrapper on properties and variables to an Observable object. This includes global variables, properties that exists outside of SwiftUI types, or even local variables. For example, you can create a @Bindable variable within a view\u2019s body:\n\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n\n    var body: some View {\n        List(books) { book in \n            @Bindable var book = book\n            TextField(\"Title\", text: $book.title)\n        }\n    }\n}\n\n\nThe @Bindable variable book provides a binding that connects TextField to the title property of a book so that a person can make changes directly to the model data.\n\nSee Also\nCreating model data\nMigrating from the Observable Object protocol to the Observable macro\nUpdate your existing app to leverage the benefits of Observation in Swift.\nMonitoring data changes in your app\nShow changes to data in your app\u2019s user interface by using observable objects.\nstruct StateObject\nA property wrapper type that instantiates an observable object.\nstruct ObservedObject\nA property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes."
    },
    {
        "title": "Migrating from the Observable Object protocol to the Observable macro",
        "url": "https://developer.apple.com/documentation/swiftui/migrating-from-the-observable-object-protocol-to-the-observable-macro",
        "html": "Overview\n\nStarting with iOS 17, iPadOS 17, macOS 14, tvOS 17, and watchOS 10, SwiftUI provides support for Observation, a Swift-specific implementation of the observer design pattern. Adopting Observation provides your app with the following benefits:\n\nTracking optionals and collections of objects, which isn\u2019t possible when using ObservableObject.\n\nUsing existing data flow primitives like State and Environment instead of object-based equivalents such as StateObject and EnvironmentObject.\n\nUpdating views based on changes to the observable properties that a view\u2019s body reads instead of any property changes that occur to an observable object, which can help improve your app\u2019s performance.\n\nTo take advantage of these benefits in your app, you\u2019ll discover how to replace existing source code that relies on ObservableObject with code that leverages the Observable() macro.\n\nNote\n\nDownload this sample to see the migrated version of the sample app. To see the premigrated version, download the sample available in Monitoring data changes in your app. You can also use the premigrated version to code along with this article.\n\nUse the Observable macro\n\nTo adopt Observation in an existing app, begin by replacing ObservableObject in your data model type with the Observable() macro. The Observable() macro generates source code at compile time that adds observation support to the type.\n\n// BEFORE\nimport SwiftUI\n\n\nclass Library: ObservableObject {\n    // ...\n}\n\n// AFTER\nimport SwiftUI\n\n\n@Observable class Library {\n    // ...\n}\n\n\nThen remove the Published property wrapper from observable properties. Observation doesn\u2019t require a property wrapper to make a property observable. Instead, the accessibility of the property in relationship to an observer, such as a view, determines whether a property is observable.\n\n// BEFORE\n@Observable class Library {\n    @Published var books: [Book] = [Book(), Book(), Book()]\n}\n\n// AFTER\n@Observable class Library {\n    var books: [Book] = [Book(), Book(), Book()]\n}\n\n\nIf you have properties that are accessible to an observer that you don\u2019t want to track, apply the ObservationIgnored() macro to the property.\n\nMigrate incrementally\n\nYou don\u2019t need to make a wholesale replacement of the ObservableObject protocol throughout your app. Instead, you can make changes incrementally. Start by changing one data model type to use the Observable() macro. Your app can mix data model types that use different observation systems. However, SwiftUI tracks changes differently based on the observation system that a data model type uses, Observable versus ObservableObject.\n\nYou may notice slight behavioral differences in your app based on the tracking method. For instance, when tracking as Observable(), SwiftUI updates a view only when an observable property changes and the view\u2019s body reads the property directly. The view doesn\u2019t update when observable properties not read by body changes. In contrast, a view updates when any published property of an ObservableObject instance changes, even if the view doesn\u2019t read the property that changes, when tracking as ObservableObject.\n\nNote\n\nTo learn more about when SwiftUI updates views when observable properties change, see Managing model data in your app.\n\nMigrate other source code\n\nThe only change made to the sample app so far is to apply the Observable() macro to Library and remove support for the ObservableObject protocol. The app still uses the ObservableObject data flow primitive like StateObject to manage an instance of Library. If you were to build and run the app, SwiftUI still updates the views as expected. That\u2019s because data flow property wrappers such as StateObject and EnvironmentObject support types that use the Observable() macro. SwiftUI provides this support so apps can make source code changes incrementally.\n\nHowever, to fully adopt Observation, replace the use of StateObject with State after updating your data model type. For example, in the following code the main app structure creates an instance of Library and stores it as a StateObject. It also adds the Library instance to the environment using the environmentObject(_:) modifier.\n\n// BEFORE\n@main\nstruct BookReaderApp: App {\n    @StateObject private var library = Library()\n\n\n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environmentObject(library)\n        }\n    }\n}\n\n\nNow that Library no longer conforms to ObservableObject, the code can change to use State instead of StateObject and to add library to the environment using the environment(_:) modifier.\n\n// AFTER\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n\n\n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}\n\n\nOne more change must happen before Library fully adopts Observation. Previously the view LibraryView retrieved a Library instance from the environment using the EnvironmentObject property wrapper. The new code, however, uses the Environment property wrapper instead.\n\n// BEFORE\nstruct LibraryView: View {\n    @EnvironmentObject var library: Library\n\n\n    var body: some View {\n        List(library.books) { book in\n            BookView(book: book)\n        }\n    }\n}\n\n// AFTER\nstruct LibraryView: View {\n    @Environment(Library.self) private var library\n    \n    var body: some View {\n        List(library.books) { book in\n            BookView(book: book)\n        }\n    }\n}\n\nRemove the ObservedObject property wrapper\n\nTo wrap up the migration of the sample app, change the data model type Book to support Observation by removing ObservableObject from the type declaration and apply the Observable() macro. Then remove the Published property wrapper from observable properties.\n\n// BEFORE\nclass Book: ObservableObject, Identifiable {\n    @Published var title = \"Sample Book Title\"\n    \n    let id = UUID() // A unique identifier that never changes.\n}\n\n// AFTER\n@Observable class Book: Identifiable {\n    var title = \"Sample Book Title\"\n    \n    let id = UUID() // A unique identifier that never changes.\n}\n\n\nNext, remove the ObservedObject property wrapper from the book variable in the BookView. This property wrapper isn\u2019t needed when adopting Observation. That\u2019s because SwiftUI automatically tracks any observable properties that a view\u2019s body reads directly. For example, SwiftUI updates BookView when book.title changes.\n\n// BEFORE\nstruct BookView: View {\n    @ObservedObject var book: Book\n    @State private var isEditorPresented = false\n    \n    var body: some View {\n        HStack {\n            Text(book.title)\n            Spacer()\n            Button(\"Edit\") {\n                isEditorPresented = true\n            }\n        }\n        .sheet(isPresented: $isEditorPresented) {\n            BookEditView(book: book)\n        }\n    }\n}\n\n// AFTER\nstruct BookView: View {\n    var book: Book\n    @State private var isEditorPresented = false\n    \n    var body: some View {\n        HStack {\n            Text(book.title)\n            Spacer()\n            Button(\"Edit\") {\n                isEditorPresented = true\n            }\n        }\n        .sheet(isPresented: $isEditorPresented) {\n            BookEditView(book: book)\n        }\n    }\n}\n\n\nHowever, if a view needs a binding to an observable type, replace ObservedObject with the Bindable property wrapper. This property wrapper provides binding support to an observable type so that views that expect a binding can change an observable property. For instance, in the following code TextField receives a binding to book.title:\n\n// BEFORE\nstruct BookEditView: View {\n    @ObservedObject var book: Book\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        VStack() {\n            TextField(\"Title\", text: $book.title)\n                .textFieldStyle(.roundedBorder)\n                .onSubmit {\n                    dismiss()\n                }\n                \n            Button(\"Close\") {\n                dismiss()\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}\n\n// AFTER\nstruct BookEditView: View {\n    @Bindable var book: Book\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        VStack() {\n            TextField(\"Title\", text: $book.title)\n                .textFieldStyle(.roundedBorder)\n                .onSubmit {\n                    dismiss()\n                }\n                \n            Button(\"Close\") {\n                dismiss()\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}\n\nSee Also\nCreating model data\nManaging model data in your app\nCreate connections between your app\u2019s data model and views.\nMonitoring data changes in your app\nShow changes to data in your app\u2019s user interface by using observable objects.\nstruct StateObject\nA property wrapper type that instantiates an observable object.\nstruct ObservedObject\nA property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes."
    },
    {
        "title": "findDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/finddisabled(_:)",
        "html": "Parameters\nisDisabled\n\nA Boolean value that indicates whether to disable the find and replace interface for a text editor.\n\nReturn Value\n\nA view that disables the find and replace interface.\n\nDiscussion\n\nAdd this modifier to ensure that people can\u2019t activate the find and replace interface for a TextEditor:\n\nTextEditor(text: $text)\n    .findDisabled()\n\n\nWhen you disable the find operation, you also implicitly disable the replace operation. If you want to only disable replace, use replaceDisabled(_:) instead.\n\nUsing this modifer also prevents programmatic find and replace interface presentation using the findNavigator(isPresented:) method. Be sure to place the disabling modifier closer to the text editor for this to work:\n\nTextEditor(text: $text)\n    .findDisabled(isDisabled)\n    .findNavigator(isPresented: $isPresented)\n\n\nIf you apply this modifer at multiple levels of a view hierarchy, the call closest to the text editor takes precedence. For example, people can activate find and replace for the first text editor in the following example, but not the second:\n\nVStack {\n    TextEditor(text: $text1)\n        .findDisabled(false)\n    TextEditor(text: $text2)\n}\n.findDisabled(true)\n\nSee Also\nSearching for text in a view with find and replace\nfunc findNavigator(isPresented: Binding<Bool>) -> some View\nProgrammatically presents the find and replace interface for text editor views.\nfunc replaceDisabled(Bool) -> some View\nPrevents replace operations in a text editor."
    },
    {
        "title": "findNavigator(isPresented:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/findnavigator(ispresented:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that controls the presentation of the find and replace interface.\n\nReturn Value\n\nA view that presents the find and replace interface when isPresented is true.\n\nDiscussion\n\nAdd this modifier to a TextEditor, or to a view hierarchy that contains at least one text editor, to control the presentation of the find and replace interface. When you set the isPresented binding to true, the system shows the interface, and when you set it to false, the system hides the interface. The following example shows and hides the interface based on the state of a toolbar button:\n\nTextEditor(text: $text)\n    .findNavigator(isPresented: $isPresented)\n    .toolbar {\n        Toggle(isOn: $isPresented) {\n            Label(\"Find\", systemImage: \"magnifyingglass\")\n        }\n    }\n\n\nThe find and replace interface allows people to search for instances of a specified string in the text editor, and optionally to replace instances of the search string with another string. They can also show and hide the interface using built-in controls, like menus and keyboard shortcuts. SwiftUI updates isPresented to reflect the users\u2019s actions.\n\nIf the text editor view isn\u2019t currently in focus, the system still presents the find and replace interface when you set isPresented to true. If the view hierarchy contains multiple editors, the one that shows the find and replace interface is nondeterministic.\n\nYou can disable the find and replace interface for a text editor by applying the findDisabled(_:) modifier to the editor. If you do that, setting this modifier\u2019s isPresented binding to true has no effect, but only if the disabling modifier appears closer to the text editor, like this:\n\nTextEditor(text: $text)\n    .findDisabled(isDisabled)\n    .findNavigator(isPresented: $isPresented)\n\nSee Also\nSearching for text in a view with find and replace\nfunc findDisabled(Bool) -> some View\nPrevents find and replace operations in a text editor.\nfunc replaceDisabled(Bool) -> some View\nPrevents replace operations in a text editor."
    },
    {
        "title": "searchable(text:tokens:suggestedTokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:suggestedtokens:ispresented:placement:prompt:token:)-9xxr1",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nsuggestedTokens\n\nA collection of tokens to display as suggestions.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "replaceDisabled(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/replacedisabled(_:)",
        "html": "Parameters\nisDisabled\n\nA Boolean value that indicates whether text replacement in the find and replace interface is disabled.\n\nReturn Value\n\nA view that disables the replace feature of a find and replace interface.\n\nDiscussion\n\nAdd this modifier to ensure that people can\u2019t activate the replace feature of a find and replace interface for a TextEditor:\n\nTextEditor(text: $text)\n    .replaceDisabled()\n\n\nIf you want to disable both find and replace, use the findDisabled(_:) modifier instead.\n\nUsing this modifer also disables the replace feature of a find and replace interface that you present programmatically using the findNavigator(isPresented:) method. Be sure to place the disabling modifier closer to the text editor for this to work:\n\nTextEditor(text: $text)\n    .replaceDisabled(isDisabled)\n    .findNavigator(isPresented: $isPresented)\n\n\nIf you apply this modifer at multiple levels of a view hierarchy, the call closest to the text editor takes precedence. For example, people can activate find and replace for the first text editor in the following example, but only find for the second:\n\nVStack {\n    TextEditor(text: $text1)\n        .replaceDisabled(false)\n    TextEditor(text: $text2)\n}\n.replaceDisabled(true)\n\nSee Also\nSearching for text in a view with find and replace\nfunc findNavigator(isPresented: Binding<Bool>) -> some View\nProgrammatically presents the find and replace interface for text editor views.\nfunc findDisabled(Bool) -> some View\nPrevents find and replace operations in a text editor."
    },
    {
        "title": "searchable(text:tokens:suggestedTokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:suggestedtokens:ispresented:placement:prompt:token:)-d4wj",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nsuggestedTokens\n\nA collection of tokens to display as suggestions.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "WidgetBundle",
        "url": "https://developer.apple.com/documentation/swiftui/widgetbundle",
        "html": "Overview\n\nTo support multiple types of widgets, add the @main attribute to a structure that conforms to WidgetBundle. For example, a game might have one widget to display summary information about the game and a second widget to display detailed information about individual characters.\n\n@main\nstruct GameWidgets: WidgetBundle {\n   var body: some Widget {\n       GameStatusWidget()\n       CharacterDetailWidget()\n   }\n}\n\nTopics\nImplementing a widget bundle\nvar body: Self.Body\nDeclares the group of widgets that an app supports.\n\nRequired\n\nassociatedtype Body : Widget\nThe type of widget that represents the content of the bundle.\n\nRequired\n\nstruct WidgetBundleBuilder\nA custom attribute that constructs a widget bundle\u2019s body.\nRunning a widget bundle\ninit()\nCreates a widget bundle using the bundle\u2019s body as its content.\n\nRequired\n\nstatic func main()\nInitializes and runs the widget bundle.\nSee Also\nCreating widgets\nprotocol Widget\nThe configuration and content of a widget to display on the Home screen or in Notification Center.\nstruct LimitedAvailabilityConfiguration\nA type-erased widget configuration.\nprotocol WidgetConfiguration\nA type that describes a widget\u2019s content.\nstruct EmptyWidgetConfiguration\nAn empty widget configuration."
    },
    {
        "title": "Widget",
        "url": "https://developer.apple.com/documentation/swiftui/widget",
        "html": "Overview\n\nWidgets show glanceable and relevant content from your app right on the iOS Home screen or in Notification Center on macOS. Users can add, configure, and arrange widgets to suit their individual needs. You can provide multiple types of widgets, each presenting a specific kind of information. When users want more information, like to read the full article for a headline or to see the details of a package delivery, the widget lets them get to the information in your app quickly.\n\nThere are three key components to a widget:\n\nA configuration that determines whether the widget is configurable, identifies the widget, and defines the SwiftUI views that show the widget\u2019s content.\n\nA timeline provider that drives the process of updating the widget\u2019s view over time.\n\nSwiftUI views used by WidgetKit to display the widget.\n\nFor information about adding a widget extension to your app, and keeping your widget up to date, see Creating a widget extension and Keeping a widget up to date, respectively.\n\nBy adding a custom SiriKit intent definition, you can let users customize their widgets to show the information that\u2019s most relevant to them. If you\u2019ve already added support for Siri or Shortcuts, you\u2019re well on your way to supporting customizable widgets. For more information, see Making a configurable widget.\n\nTopics\nImplementing a widget\nvar body: Self.Body\nThe content and behavior of the widget.\n\nRequired\n\nassociatedtype Body : WidgetConfiguration\nThe type of configuration representing the content of the widget.\n\nRequired\n\nRunning a widget\ninit()\nCreates a widget using body as its content.\n\nRequired\n\nstatic func main()\nInitializes and runs the widget.\nSee Also\nCreating widgets\nprotocol WidgetBundle\nA container used to expose multiple widgets from a single widget extension.\nstruct LimitedAvailabilityConfiguration\nA type-erased widget configuration.\nprotocol WidgetConfiguration\nA type that describes a widget\u2019s content.\nstruct EmptyWidgetConfiguration\nAn empty widget configuration."
    },
    {
        "title": "sheet(isPresented:onDismiss:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/sheet(ispresented:ondismiss:content:)",
        "html": "Parameters\nisPresented\n\nA binding to a Boolean value that determines whether to present the sheet that you create in the modifier\u2019s content closure.\n\nonDismiss\n\nThe closure to execute when dismissing the sheet.\n\ncontent\n\nA closure that returns the content of the sheet.\n\nDiscussion\n\nUse this method when you want to present a modal view to the user when a Boolean value you provide is true. The example below displays a modal view of the mockup for a software license agreement when the user toggles the isShowingSheet variable by clicking or tapping on the \u201cShow License Agreement\u201d button:\n\nstruct ShowLicenseAgreement: View {\n    @State private var isShowingSheet = false\n    var body: some View {\n        Button(action: {\n            isShowingSheet.toggle()\n        }) {\n            Text(\"Show License Agreement\")\n        }\n        .sheet(isPresented: $isShowingSheet,\n               onDismiss: didDismiss) {\n            VStack {\n                Text(\"License Agreement\")\n                    .font(.title)\n                    .padding(50)\n                Text(\"\"\"\n                        Terms and conditions go here.\n                    \"\"\")\n                    .padding(50)\n                Button(\"Dismiss\",\n                       action: { isShowingSheet.toggle() })\n            }\n        }\n    }\n\n\n    func didDismiss() {\n        // Handle the dismissing action.\n    }\n}\n\n\nIn vertically compact environments, such as iPhone in landscape orientation, a sheet presentation automatically adapts to appear as a full-screen cover. Use the presentationCompactAdaptation(_:) or presentationCompactAdaptation(horizontal:vertical:) modifier to override this behavior.\n\nSee Also\nShowing a sheet, cover, or popover\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content.\nenum PopoverAttachmentAnchor\nAn attachment anchor for a popover."
    },
    {
        "title": "DialogSeverity",
        "url": "https://developer.apple.com/documentation/swiftui/dialogseverity",
        "html": "Overview\n\nYou can use dialog severity to indicate that people need to take extra care when interacting with the dialog, like when an action taken from the dialog permanently deletes data.\n\nTopics\nGetting severities\nstatic let automatic: DialogSeverity\nThe default dialog severity. Alerts that present an error will use .critical and all others will use .standard.\nstatic let standard: DialogSeverity\nA severity that indicates the dialog is being displayed for the purpose of presenting information to the user.\nstatic let critical: DialogSeverity\nA severity that indicates extra attention should be given to the dialog, for example when unexpected data loss may occur as a result of the action taken.\nRelationships\nConforms To\nEquatable"
    },
    {
        "title": "searchable(text:editableTokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:editabletokens:ispresented:placement:prompt:token:)-68xwn",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\neditableTokens\n\nA collection of tokens to display and edit in the search field.\n\nisPresenting\n\nA Binding which controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchable(text:tokens:suggestedTokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:suggestedtokens:ispresented:placement:prompt:token:)-8qwnr",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nsuggestedTokens\n\nA collection of tokens to display as suggestions.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchable(text:editableTokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:editabletokens:ispresented:placement:prompt:token:)-2ilmg",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\neditableTokens\n\nA collection of tokens to display and edit in the search field.\n\nisPresenting\n\nA Binding which controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchable(text:tokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:ispresented:placement:prompt:token:)-1r77c",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchable(text:isPresented:placement:prompt:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:ispresented:placement:prompt:)-478q9",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchable(text:isPresented:placement:prompt:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:ispresented:placement:prompt:)-5hhxx",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchable(text:isPresented:placement:prompt:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:ispresented:placement:prompt:)-1hn4y",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "DismissSearchAction",
        "url": "https://developer.apple.com/documentation/swiftui/dismisssearchaction",
        "html": "Overview\n\nUse the dismissSearch environment value to get the instance of this structure for a given Environment. Then call the instance to dismiss the current search interaction. You call the instance directly because it defines a callAsFunction() method that Swift calls when you call the instance.\n\nWhen you dismiss search, SwiftUI:\n\nSets isSearching to false.\n\nClears any text from the search field.\n\nRemoves focus from the search field.\n\nNote\n\nCalling this instance has no effect if the user isn\u2019t interacting with a search field.\n\nUse this action to dismiss a search operation based on another user interaction. For example, consider a searchable view with a Button that presents more information about the first matching item from a collection:\n\nstruct ContentView: View {\n    @State private var searchText = \"\"\n\n\n    var body: some View {\n        NavigationStack {\n            SearchedView(searchText: searchText)\n                .searchable(text: $searchText)\n        }\n    }\n}\n\n\nstruct SearchedView: View {\n    var searchText: String\n\n\n    let items = [\"a\", \"b\", \"c\"]\n    var filteredItems: [String] { items.filter { $0 == searchText.lowercased() } }\n\n\n    @State private var isPresented = false\n    @Environment(\\.dismissSearch) private var dismissSearch\n\n\n    var body: some View {\n        if let item = filteredItems.first {\n            Button(\"Details about \\(item)\") {\n                isPresented = true\n            }\n            .sheet(isPresented: $isPresented) {\n                NavigationStack {\n                    DetailView(item: item, dismissSearch: dismissSearch)\n                }\n            }\n        }\n    }\n}\n\n\nThe button becomes visible only after the user enters search text that produces a match. When the user taps the button, SwiftUI shows a sheet that provides more information about the item, including an Add button for adding the item to a stored list of items:\n\nprivate struct DetailView: View {\n    var item: String\n    var dismissSearch: DismissSearchAction\n\n\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Text(\"Information about \\(item).\")\n            .toolbar {\n                Button(\"Add\") {\n                    // Store the item here...\n\n\n                    dismiss()\n                    dismissSearch()\n                }\n            }\n    }\n}\n\n\nPeople can dismiss the sheet by dragging it down, effectively canceling the operation, leaving the in-progress search interaction intact. Alternatively, people can tap the Add button to store the item. Because the person using your app is likely to be done with both the detail view and the search interaction at this point, the button\u2019s closure also uses the dismiss property to dismiss the sheet, and the dismissSearch property to reset the search field.\n\nImportant\n\nAccess the action from inside the searched view, as the example above demonstrates, rather than from the searched view\u2019s parent, or another hierarchy, like that of a sheet. SwiftUI sets the value in the environment of the view that you apply the searchable modifier to, and doesn\u2019t propagate the value up the view hierarchy.\n\nTopics\nCalling the action\nfunc callAsFunction()\nDismisses the current search operation, if any.\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "dismissSearch",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/dismisssearch",
        "html": "Discussion\n\nUse this environment value to get the DismissSearchAction instance for the current Environment. Then call the instance to dismiss the current search interaction. You call the instance directly because it defines a callAsFunction() method that Swift calls when you call the instance.\n\nWhen you dismiss search, SwiftUI:\n\nSets isSearching to false.\n\nClears any text from the search field.\n\nRemoves focus from the search field.\n\nNote\n\nCalling this instance has no effect if the user isn\u2019t interacting with a search field.\n\nUse this action to dismiss a search operation based on another user interaction. For example, consider a searchable view with a Button that presents more information about the first matching item from a collection:\n\nstruct ContentView: View {\n    @State private var searchText = \"\"\n\n\n    var body: some View {\n        NavigationStack {\n            SearchedView(searchText: searchText)\n                .searchable(text: $searchText)\n        }\n    }\n}\n\n\nprivate struct SearchedView: View {\n    let searchText: String\n\n\n    let items = [\"a\", \"b\", \"c\"]\n    var filteredItems: [String] { items.filter { $0 == searchText.lowercased() } }\n\n\n    @State private var isPresented = false\n    @Environment(\\.dismissSearch) private var dismissSearch\n\n\n    var body: some View {\n        if let item = filteredItems.first {\n            Button(\"Details about \\(item)\") {\n                isPresented = true\n            }\n            .sheet(isPresented: $isPresented) {\n                NavigationStack {\n                    DetailView(item: item, dismissSearch: dismissSearch)\n                }\n            }\n        }\n    }\n}\n\n\nThe button becomes visible only after the user enters search text that produces a match. When the user taps the button, SwiftUI shows a sheet that provides more information about the item, including an Add button for adding the item to a stored list of items:\n\nprivate struct DetailView: View {\n    var item: String\n    var dismissSearch: DismissSearchAction\n\n\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Text(\"Information about \\(item).\")\n            .toolbar {\n                Button(\"Add\") {\n                    // Store the item here...\n\n\n                    dismiss()\n                    dismissSearch()\n                }\n            }\n    }\n}\n\n\nPeople can dismiss the sheet by dragging it down, effectively canceling the operation, leaving the in-progress search interaction intact. Alternatively, people can tap the Add button to store the item. Because the person using your app is likely to be done with both the detail view and the search interaction at this point, the button\u2019s closure also uses the dismiss property to dismiss the sheet, and the dismissSearch property to reset the search field.\n\nImportant\n\nAccess the action from inside the searched view, as the example above demonstrates, rather than from the searched view\u2019s parent, or another hierarchy, like that of a sheet. SwiftUI sets the value in the environment of the view that you apply the searchable modifier to, and doesn\u2019t propagate the value up the view hierarchy.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "isSearching",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/issearching",
        "html": "Discussion\n\nYou can read this value like any of the other EnvironmentValues, by creating a property with the Environment property wrapper:\n\n@Environment(\\.isSearching) private var isSearching\n\n\nGet the value to find out when the user interacts with a search field that\u2019s produced by one of the searchable modifiers, like searchable(text:placement:prompt:):\n\nstruct SearchingExample: View {\n    @State private var searchText = \"\"\n\n\n    var body: some View {\n        NavigationStack {\n            SearchedView()\n                .searchable(text: $searchText)\n        }\n    }\n}\n\n\nstruct SearchedView: View {\n    @Environment(\\.isSearching) private var isSearching\n\n\n    var body: some View {\n        Text(isSearching ? \"Searching!\" : \"Not searching.\")\n    }\n}\n\n\nWhen the user first taps or clicks in a search field, the isSearching property becomes true. When the user cancels the search operation, the property becomes false. To programmatically set the value to false and dismiss the search operation, use dismissSearch.\n\nImportant\n\nAccess the value from inside the searched view, as the example above demonstrates, rather than from the searched view\u2019s parent. SwiftUI sets the value in the environment of the view that you apply the searchable modifier to, and doesn\u2019t propagate the value up the view hierarchy.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "Managing search interface activation",
        "url": "https://developer.apple.com/documentation/swiftui/managing-search-interface-activation",
        "html": "Overview\n\nPeople activate a search field in your app by tapping or clicking it, after which they can enter search terms. In many cases, your app only needs to react to the corresponding changes in the search text values, which the interface updates through the binding that you provide, as described in Performing a search operation.\n\nHowever, SwiftUI also provides controls that enable you to programmatically manage the search interface. In particular, you can:\n\nActivate or deactivate the interface using a binding that you provide to the searchable modifier.\n\nDetect whether the interface is active by reading an environment value.\n\nDismiss the interface by calling an action stored in the environment.\n\nWait for a search submission event before starting to search.\n\nControl activation through a binding\n\nYou can control search interface activation programmatically by providing the searchable modifier\u2019s isPresented parameter with a Binding to a Boolean value. For example, to present a sheet that appears with the search interface already active, create a binding that starts as true:\n\nstruct SheetView: View {\n    @State private var isPresented = true\n    @State private var text = \"\"\n  \n    var body: some View {\n        NavigationStack {\n            SheetContent()\n                .searchable(text: $text, isPresented: $isPresented)\n        }\n    }\n}   \n\n\nOn iOS and macOS, SwiftUI focuses the search field when presenting search and unfocuses the search field when dismissing search. The search field can also lose focus while the search interface remains presented. For example, if your search interface contains a list of text fields, someone might move focus to one of the text fields without dismissing the interface.\n\nDetect search activation\n\nIf you need to know when the search interface is active, you can query the environment\u2019s isSearching property using the Environment property wrapper. The following example shows a view that updates the text it displays based on the state of the property:\n\nstruct SearchingExample: View {\n    @State private var searchText = \"\"\n\n\n    var body: some View {\n        NavigationStack {\n            SearchedView()\n                .searchable(text: $searchText)\n        }\n    }\n}\n\n\nstruct SearchedView: View {\n    @Environment(\\.isSearching) private var isSearching\n\n\n    var body: some View {\n        Text(isSearching ? \"Searching\" : \"Not searching\")\n    }\n}\n\n\nWhen someone first taps or clicks in a search field, the isSearching property becomes true. When they cancel or submit the search operation, the property becomes false. It also becomes false if you programmatically dismiss the interface, as the next section describes.\n\nBe sure to read the property from inside a view that\u2019s wrapped, either directly or indirectly, by one of the searchable(text:placement:prompt:) view modifiers, like SearchedView in the above example. You won\u2019t detect any change in the property value if you read it from outside of that context, like if you put it in the SearchingExample view.\n\nDismiss the search interface\n\nYou can programmatically deactivate the interface using the environment\u2019s dismissSearch action. For example, consider a view with a Button that presents more information about the first matching item from a collection:\n\nstruct ContentView: View {\n    @State private var searchText = \"\"\n\n\n    var body: some View {\n        NavigationStack {\n            SearchedView(searchText: searchText)\n                .searchable(text: $searchText)\n        }\n    }\n}\n\n\nprivate struct SearchedView: View {\n    var searchText: String\n\n\n    let items = [\"a\", \"b\", \"c\"]\n    var filteredItems: [String] { items.filter { $0 == searchText.lowercased() } }\n\n\n    @State private var isPresented = false\n    @Environment(\\.dismissSearch) private var dismissSearch\n\n\n    var body: some View {\n        if let item = filteredItems.first {\n            Button(\"Details about \\(item)\") {\n                isPresented = true\n            }\n            .sheet(isPresented: $isPresented) {\n                NavigationStack {\n                    DetailView(item: item, dismissSearch: dismissSearch)\n                }\n            }\n        }\n    }\n}\n\n\nThe button becomes visible only after someone enters search text that produces a match. The button\u2019s action shows a sheet that provides more information about the item, including an Add button for adding the item to a stored list of items:\n\nprivate struct DetailView: View {\n    var item: String\n    var dismissSearch: DismissSearchAction\n\n\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Text(\"Information about \\(item).\")\n            .toolbar {\n                Button(\"Add\") {\n                    // Store the item here...\n\n\n                    dismiss()\n                    dismissSearch()\n                }\n            }\n    }\n}\n\n\nPeople can dismiss the sheet by dragging it down, effectively canceling the operation, leaving the in-progress search interaction intact. Alternatively, They can tap the Add button to store the item. Because people are likely done with both the detail view and the search interaction at this point, the button\u2019s closure uses the dismiss property to dismiss the sheet, and the dismissSearch property to reset the search field.\n\nAs with the isSearching property, be sure to only read dismissSearch from within the hierarchy of a searchable view modifier. Calling the action has no effect if you read it from the environment outside of that context. The above example reads the action from SearchedView, and passes that into the sheet, because the sheet has its own environment. The action also has no effect if the search interface isn\u2019t active.\n\nReact to search submission\n\nTo specify an action that SwiftUI invokes when someone submits the search query (by pressing the Return key), add the onSubmit(of:_:) modifier:\n\nSearchedView()\n    .searchable(text: $searchText)\n    .onSubmit(of: .search) {\n        submitCurrentSearchQuery()\n    }\n\n\nDepending your app\u2019s structure, you can use search submission in different ways. For example, you can take that opportunity to look for substrings among the search query string that you can convert into tokens. Alternatively, for a search operation that\u2019s very slow, perhaps because it requires a network access, you can wait for a submission event before performing a search.\n\nSee Also\nDetecting, activating, and dismissing search\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchScopes(_:activation:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchscopes(_:activation:_:)",
        "html": "Parameters\nscope\n\nThe active scope of the search field.\n\nactivation\n\nThe activation style of the search field\u2019s scopes.\n\nscopes\n\nA view builder that represents the scoping options SwiftUI uses to populate a Picker.\n\nDiscussion\n\nTo enable people to narrow the scope of their searches, you can create a type that represents the possible scopes, and then create a state variable to hold the current selection. For example, you can scope the product search to just fruits or just vegetables:\n\nenum ProductScope {\n    case fruit\n    case vegetable\n}\n\n\n@State private var scope: ProductScope = .fruit\n\n\nProvide a binding to the scope, as well as a view that represents each scope:\n\nProductList()\n    .searchable(text: $text, tokens: $tokens) { token in\n        switch token {\n        case .apple: Text(\"Apple\")\n        case .pear: Text(\"Pear\")\n        case .banana: Text(\"Banana\")\n        }\n    }\n    .searchScopes($scope) {\n        Text(\"Fruit\").tag(ProductScope.fruit)\n        Text(\"Vegetable\").tag(ProductScope.vegetable)\n    }\n\n\nSwiftUI uses this binding and view to add a Picker below the search field. In iOS, macOS, and tvOS, the picker appears below the search field when search is active. To ensure that the picker operates correctly, match the type of the scope binding with the type of each view\u2019s tag. Then condition your search on the current value of the scope state property.\n\nBy default, the appearance of scopes varies by platform:\n\nIn iOS and iPadOS, search scopes appear when someone enters text into the search field and disappear when someone cancels the search.\n\nIn macOS, search scopes appear when SwiftUI presents search and disappear when someone cancels the search.\n\nHowever, you can use the activation parameter with a value of onTextEntry or onSearchPresentation to configure this behavior:\n\n.searchScopes($scope, activation: .onSearchPresentation) {\n    Text(\"Fruit\").tag(ProductScope.fruit)\n    Text(\"Vegetable\").tag(ProductScope.vegetable)\n}\n\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nLimiting search scope\nScoping a search operation\nDivide the search space into a few broad categories.\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> some View\nConfigures the search scopes for this view.\nstruct SearchScopeActivation\nThe ways that searchable modifiers can show or hide search scopes."
    },
    {
        "title": "searchScopes(_:scopes:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchscopes(_:scopes:)",
        "html": "Parameters\nscope\n\nThe active scope of the search field.\n\nscopes\n\nA view builder that represents the scoping options SwiftUI uses to populate a Picker.\n\nDiscussion\n\nTo enable people to narrow the scope of their searches, you can create a type that represents the possible scopes, and then create a state variable to hold the current selection. For example, you can scope the product search to just fruits or just vegetables:\n\nenum ProductScope {\n    case fruit\n    case vegetable\n}\n\n\n@State private var scope: ProductScope = .fruit\n\n\nProvide a binding to the scope, as well as a view that represents each scope:\n\nProductList()\n    .searchable(text: $text, tokens: $tokens) { token in\n        switch token {\n        case .apple: Text(\"Apple\")\n        case .pear: Text(\"Pear\")\n        case .banana: Text(\"Banana\")\n        }\n    }\n    .searchScopes($scope) {\n        Text(\"Fruit\").tag(ProductScope.fruit)\n        Text(\"Vegetable\").tag(ProductScope.vegetable)\n    }\n\n\nSwiftUI uses this binding and view to add a Picker with the search field. In iOS, iPadOS, macOS, and tvOS, the picker appears below the search field when search is active. To ensure that the picker operates correctly, match the type of the scope binding with the type of each view\u2019s tag. Then modify your search to account for the current value of the scope state property.\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nLimiting search scope\nScoping a search operation\nDivide the search space into a few broad categories.\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> some View\nConfigures the search scopes for this view with the specified activation strategy.\nstruct SearchScopeActivation\nThe ways that searchable modifiers can show or hide search scopes."
    },
    {
        "title": "SearchScopeActivation",
        "url": "https://developer.apple.com/documentation/swiftui/searchscopeactivation",
        "html": "Topics\nGetting search scope activiation types\nstatic var automatic: SearchScopeActivation\nThe automatic activation of the scope bar.\nstatic var onSearchPresentation: SearchScopeActivation\nAn activation where the system shows search scopes after presenting search and hides search scopes after search cancellation.\nstatic var onTextEntry: SearchScopeActivation\nAn activation where the system shows search scopes when typing begins in the search field and hides search scopes after search cancellation.\nSee Also\nLimiting search scope\nScoping a search operation\nDivide the search space into a few broad categories.\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> some View\nConfigures the search scopes for this view.\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> some View\nConfigures the search scopes for this view with the specified activation strategy."
    },
    {
        "title": "Scoping a search operation",
        "url": "https://developer.apple.com/documentation/swiftui/scoping-a-search-operation",
        "html": "Overview\n\nIf the data you want to search falls into a few categories, you can define different scopes to help people narrow their search. When you define a scope, SwiftUI presents a picker that people can use to choose one of them. You then use the current scope selection as one of the inputs to the search operation.\n\nDefine the possible scopes\n\nStart by creating a type that conforms to the Hashable protocol to represent the possible scopes. For example, you can use an enumeration to scope a product search to just fruits or just vegetables:\n\nenum ProductScope {\n    case fruit\n    case vegetable\n}\n\n\nThen create a property to store the current scope, either as a state variable in a view, or a published property in your model:\n\n@Published var scope: ProductScope = .fruit\n\nApply the scope\n\nTo use the scope information, bind the current scope to the searchScopes(_:scopes:) modifier. You also indicate a set of views that correspond to the different scopes. Like the searchSuggestions(_:) modifier, the scopes modifier operates on the searchable modifier that\u2019s closer to the modified view, so it needs to follow the searchable modifier:\n\nProductList(departmentId: departmentId, productId: $productId)\n    .searchable(text: $model.searchText, tokens: $model.tokens) { token in\n        switch token {\n        case .apple: Text(\"Apple\")\n        case .pear: Text(\"Pear\")\n        case .banana: Text(\"Banana\")\n        }\n    }\n    .searchScopes($model.scope) {\n        Text(\"Fruit\").tag(ProductScope.fruit)\n        Text(\"Vegetable\").tag(ProductScope.vegetable)\n    }\n\n\nSwiftUI uses the binding and views to add a Picker to the search field. By default, the picker appears below the search field in macOS when search is active, or in iOS when someone starts entering text into the search field:\n\nmacOS\niOS\n\nYou can change when the picker appears by using the searchScopes(_:activation:_:) modifier instead, and supplying one of the SearchScopeActivation values, like onTextEntry or onSearchPresentation.\n\nTo ensure that the picker operates correctly, match the type of the scope binding with the type of each view\u2019s tag. In the above example, both the scope input and the tags for each view have the type ProductScope.\n\nUse the scope in your search\n\nModify your search to account for the current value of the scope property, if you offer it, along with the text and tokens in the query. For example, you might include the scope as one element of a predicate that you define for a Core Data fetch request. For more information about conducting a search, see Performing a search operation.\n\nSee Also\nLimiting search scope\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> some View\nConfigures the search scopes for this view.\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> some View\nConfigures the search scopes for this view with the specified activation strategy.\nstruct SearchScopeActivation\nThe ways that searchable modifiers can show or hide search scopes."
    },
    {
        "title": "searchable(text:tokens:suggestedTokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:suggestedtokens:placement:prompt:token:)-8xk6g",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nsuggestedTokens\n\nA collection of tokens to display as suggestions.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "searchable(text:tokens:suggestedTokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:suggestedtokens:placement:prompt:token:)-9q3oc",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nsuggestedTokens\n\nA collection of tokens to display as suggestions.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:)-87n66",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\nactions\n\nA view builder returning the dialog\u2019s actions.\n\nDiscussion\n\nIn the example below, a button conditionally presents a confirmation dialog depending upon the value of a bound Boolean variable. When the Boolean value is set to true, the system displays a confirmation dialog with a cancel action and a destructive action.\n\nstruct ConfirmEraseItems: View {\n    @State private var isShowingDialog = false\n    var body: some View {\n        Button(\"Empty Trash\") {\n            isShowingDialog = true\n        }\n        .confirmationDialog(\n            \"Permanently erase the items in the Trash?\",\n            isPresented: $isShowingDialog\n        ) {\n            Button(\"Empty Trash\", role: .destructive) {\n                // Handle empty trash action.\n            }\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nSee Also\nGetting confirmation for an action\nfunc confirmationDialog<S, A>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a string variable as a title.\nfunc confirmationDialog<A>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a text view for the title.\nfunc confirmationDialog<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a localized string key for the title.\nfunc confirmationDialog<S, A, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a string variable for the title."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:presenting:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:)-9ibgk",
        "html": "Parameters\ntitleKey\n\nThe key for the localized string that describes the title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\ndata\n\nAn optional source of truth for the confirmation dialog. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of a confirmation dialog that you create that the system displays to the user.\n\nactions\n\nA view builder returning the dialog\u2019s actions given the currently available data.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and data must not be nil. data should not change after the presentation occurs. Any changes which occur after the presentation occurs will be ignored.\n\nUse this method when you need to populate the fields of a confirmation dialog with content from a data source. The example below shows a custom data source, FileDetails, that provides data to populate the dialog:\n\nstruct FileDetails: Identifiable {\n    var id: String { name }\n    let name: String\n    let fileType: UTType\n}\nstruct ConfirmFileImport: View {\n    @State private var isConfirming = false\n    @State private var dialogDetail: FileDetails?\n    var body: some View {\n        Button(\"Import File\") {\n            dialogDetail = FileDetails(\n                name: \"MyImageFile.png\", fileType: .png)\n            isConfirming = true\n        }\n        .confirmationDialog(\n            \"Are you sure you want to import this file?\",\n            isPresented: $isConfirming, presenting: dialogDetail\n        ) { detail in\n            Button {\n                // Handle import action.\n            } label: {\n                Text(\"\"\"\n                Import \\(detail.name)\n                File Type: \\(detail.fileType.description)\n                \"\"\")\n            }\n            Button(\"Cancel\", role: .cancel) {\n                dialogDetail = nil\n            }\n        }\n    }\n}\n\n\nThis modifier creates a Text view for the title on your behalf, and treats the localized key similar to init(_:tableName:bundle:comment:). See Text for more information about localizing strings.\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nGetting confirmation for an action\nfunc confirmationDialog<S, A>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a string variable as a title.\nfunc confirmationDialog<A>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a text view for the title.\nfunc confirmationDialog<S, A, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a string variable for the title."
    },
    {
        "title": "confirmationDialog(_:isPresented:titleVisibility:presenting:actions:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:)-51pyu",
        "html": "Parameters\ntitle\n\nthe title of the dialog.\n\nisPresented\n\nA binding to a Boolean value that determines whether to present the dialog. When the user presses or taps the dialog\u2019s default action button, the system sets this value to false, dismissing the dialog.\n\ntitleVisibility\n\nThe visibility of the dialog\u2019s title. The default value is Visibility.automatic.\n\ndata\n\nAn optional source of truth for the confirmation dialog. The system passes the contents to the modifier\u2019s closures. You use this data to populate the fields of a confirmation dialog that you create that the system displays to the user.\n\nactions\n\nA view builder returning the dialog\u2019s actions given the currently available data.\n\nDiscussion\n\nIn order for the interface to appear, both isPresented must be true and data must not be nil. data should not change after the presentation occurs. Any changes which occur after the presentation occurs will be ignored.\n\nUse this method when you need to populate the fields of a confirmation dialog with content from a data source. The example below shows a custom data source, FileDetails, that provides data to populate the dialog:\n\nstruct FileDetails: Identifiable {\n    var id: String { name }\n    let name: String\n    let fileType: UTType\n}\nstruct ConfirmFileImport: View {\n    @State private var isConfirming = false\n    @State private var dialogDetail: FileDetails?\n    var body: some View {\n        Button(\"Import File\") {\n            dialogDetail = FileDetails(\n                name: \"MyImageFile.png\", fileType: .png)\n            isConfirming = true\n        }\n        .confirmationDialog(\n            Text(\"Import New File?\"),\n            isPresented: $isConfirming, presenting: dialogDetail\n        ) { detail in\n            Button {\n                // Handle import action.\n            } label: {\n                Text(\"\"\"\n                Import \\(detail.name)\n                File Type: \\(detail.fileType.description)\n                \"\"\")\n            }\n            Button(\"Cancel\", role: .cancel) {\n                dialogDetail = nil\n            }\n        }\n    }\n}\n\n\nAll actions in a confirmation dialog will dismiss the dialog after the action runs. The default button will be shown with greater prominence. You can influence the default button by assigning it the defaultAction keyboard shortcut.\n\nThe system may reorder the buttons based on their role and prominence.\n\nDialogs include a standard dismiss action by default. If you provide a button with a role of cancel, that button takes the place of the default dismiss action. You don\u2019t have to dismiss the presentation with the cancel button\u2019s action.\n\nNote\n\nIn regular size classes in iOS, the system renders confirmation dialogs as a popover that the user dismisses by tapping anywhere outside the popover, rather than displaying the standard dismiss action.\n\nOn iOS, tvOS, and watchOS, confirmation dialogs only support controls with labels that are Text. Passing any other type of view results in the content being omitted.\n\nSee Also\nGetting confirmation for an action\nfunc confirmationDialog<S, A>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a string variable as a title.\nfunc confirmationDialog<A>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a localized string key for the title.\nfunc confirmationDialog<S, A, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a string variable for the title."
    },
    {
        "title": "presentationBackground(alignment:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationbackground(alignment:content:)",
        "html": "Parameters\nalignment\n\nThe alignment that the modifier uses to position the implicit ZStack that groups the background views. The default is center.\n\ncontent\n\nThe view to use as the background of the presentation.\n\nDiscussion\n\nThe following example uses a yellow view as the sheet background:\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationBackground {\n                    Color.yellow\n                }\n        }\n    }\n}\n\n\nThe presentationBackground(alignment:content:) modifier differs from the background(alignment:content:) modifier in several key ways. A presentation background:\n\nAutomatically fills the entire presentation.\n\nAllows views behind the presentation to show through translucent areas of the content.\n\nSee Also\nStyling a sheet and its background\nfunc presentationCornerRadius(CGFloat?) -> some View\nRequests that the presentation have a specific corner radius.\nfunc presentationBackground<S>(S) -> some View\nSets the presentation background of the enclosing sheet using a shape style.\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> some View\nControls whether people can interact with the view behind a presentation.\nstruct PresentationBackgroundInteraction\nThe kinds of interaction available to views behind a presentation."
    },
    {
        "title": "presentationBackground(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationbackground(_:)",
        "html": "Parameters\nstyle\n\nThe shape style to use as the presentation background.\n\nDiscussion\n\nThe following example uses the thick material as the sheet background:\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationBackground(.thickMaterial)\n        }\n    }\n}\n\n\nThe presentationBackground(_:) modifier differs from the background(_:ignoresSafeAreaEdges:) modifier in several key ways. A presentation background:\n\nAutomatically fills the entire presentation.\n\nAllows views behind the presentation to show through translucent styles.\n\nSee Also\nStyling a sheet and its background\nfunc presentationCornerRadius(CGFloat?) -> some View\nRequests that the presentation have a specific corner radius.\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> some View\nSets the presentation background of the enclosing sheet to a custom view.\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> some View\nControls whether people can interact with the view behind a presentation.\nstruct PresentationBackgroundInteraction\nThe kinds of interaction available to views behind a presentation."
    },
    {
        "title": "CustomPresentationDetent",
        "url": "https://developer.apple.com/documentation/swiftui/custompresentationdetent",
        "html": "Overview\n\nYou can create and use a custom detent with built-in detents.\n\nextension PresentationDetent {\n    static let bar = Self.custom(BarDetent.self)\n    static let small = Self.height(100)\n    static let extraLarge = Self.fraction(0.75)\n}\n\n\nprivate struct BarDetent: CustomPresentationDetent {\n    static func height(in context: Context) -> CGFloat? {\n        max(44, context.maxDetentValue * 0.1)\n    }\n}\n\n\nstruct ContentView: View {\n    @State private var showSettings = false\n    @State private var selectedDetent = PresentationDetent.bar\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView(selectedDetent: $selectedDetent)\n                .presentationDetents(\n                    [.bar, .small, .medium, .large, .extraLarge],\n                    selection: $selectedDetent)\n        }\n    }\n}\n\nTopics\nGetting the height\nstatic func height(in: Self.Context) -> CGFloat?\nCalculates and returns a height based on the context.\n\nRequired\n\ntypealias Context\nInformation that you can use to calculate the height of a custom detent.\nSee Also\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nstruct PresentationDetent\nA type that represents a height where a sheet naturally rests.\nstruct PresentationContentInteraction\nA behavior that you can use to influence how a presentation responds to swipe gestures."
    },
    {
        "title": "presentationCornerRadius(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentationcornerradius(_:)",
        "html": "Parameters\ncornerRadius\n\nThe corner radius, or nil to use the system default.\n\nDiscussion\n\nUse this modifier to change the corner radius of a presentation.\n\nstruct ContentView: View {\n    @State private var showSettings = false\n\n\n    var body: some View {\n        Button(\"View Settings\") {\n            showSettings = true\n        }\n        .sheet(isPresented: $showSettings) {\n            SettingsView()\n                .presentationDetents([.medium, .large])\n                .presentationCornerRadius(21)\n        }\n    }\n}\n\nSee Also\nStyling a sheet and its background\nfunc presentationBackground<S>(S) -> some View\nSets the presentation background of the enclosing sheet using a shape style.\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> some View\nSets the presentation background of the enclosing sheet to a custom view.\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> some View\nControls whether people can interact with the view behind a presentation.\nstruct PresentationBackgroundInteraction\nThe kinds of interaction available to views behind a presentation."
    },
    {
        "title": "toolbarRole(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbarrole(_:)",
        "html": "Parameters\nrole\n\nThe role of the toolbar.\n\nDiscussion\n\nUse this modifier to configure the semantic role for content populating your app\u2019s toolbar. SwiftUI uses this role when rendering the content of your app\u2019s toolbar.\n\nContentView()\n    .navigationTitle(\"Browser\")\n    .toolbarRole(.browser)\n    .toolbar {\n        ToolbarItem(placement: .primaryAction) {\n            AddButton()\n        }\n     }\n\nSee Also\nSpecifying the role of toolbar content\nstruct ToolbarRole\nThe purpose of content that populates the toolbar."
    },
    {
        "title": "ToolbarCustomizationBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/toolbarcustomizationbehavior",
        "html": "Overview\n\nCustomizable toolbar content support different types of customization behaviors. For example, some customizable content may not be removed by the user. Some content may be placed in a toolbar that supports customization overall, but not for that particular content.\n\nUse this type in conjunction with the customizationBehavior(_:) modifier.\n\nTopics\nGetting customization behaviors\nstatic var `default`: ToolbarCustomizationBehavior\nThe default customization behavior.\nstatic var disabled: ToolbarCustomizationBehavior\nThe disabled customization behavior.\nstatic var reorderable: ToolbarCustomizationBehavior\nThe reorderable customization behavior.\nRelationships\nConforms To\nSendable\nSee Also\nPopulating a customizable toolbar\nfunc toolbar<Content>(id: String, content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items, allowing for user customization.\nprotocol CustomizableToolbarContent\nConforming types represent items that can be placed in various locations in a customizable toolbar.\nstruct ToolbarCustomizationOptions\nOptions that influence the default customization behavior of customizable toolbar content."
    },
    {
        "title": "ToolbarCustomizationOptions",
        "url": "https://developer.apple.com/documentation/swiftui/toolbarcustomizationoptions",
        "html": "Overview\n\nUse this type in conjunction with the defaultCustomization(_:options:) modifier.\n\nTopics\nGetting customization options\nstatic var alwaysAvailable: ToolbarCustomizationOptions\nConfigures default customizable toolbar content to always be present in the toolbar.\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nPopulating a customizable toolbar\nfunc toolbar<Content>(id: String, content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items, allowing for user customization.\nprotocol CustomizableToolbarContent\nConforming types represent items that can be placed in various locations in a customizable toolbar.\nstruct ToolbarCustomizationBehavior\nThe customization behavior of customizable toolbar content."
    },
    {
        "title": "ToolbarDefaultItemKind",
        "url": "https://developer.apple.com/documentation/swiftui/toolbardefaultitemkind",
        "html": "Overview\n\nViews can add toolbar items clients may wish to remove or customize. A default item kind can be passed to the toolbar(removing:) modifier to remove the item. Documentation on the View placing the default item should reference the ToolbarDefaultItemKind used to remove the item.\n\nTopics\nGetting the default item types\nstatic let sidebarToggle: ToolbarDefaultItemKind\nThe sidebar toggle toolbar item a NavigationSplitView adds by default.\nSee Also\nRemoving default items\nfunc toolbar(removing: ToolbarDefaultItemKind?) -> some View\nRemove a toolbar item present by default"
    },
    {
        "title": "CustomizableToolbarContent",
        "url": "https://developer.apple.com/documentation/swiftui/customizabletoolbarcontent",
        "html": "Topics\nUsing default options\nfunc defaultCustomization() -> some CustomizableToolbarContent\nConfigures customizable toolbar content with the default visibility and options.\nfunc defaultCustomization(Visibility, options: ToolbarCustomizationOptions) -> some CustomizableToolbarContent\nConfigures the way customizable toolbar items with the default behavior behave.\nCustomizing the behavior\nfunc customizationBehavior(ToolbarCustomizationBehavior) -> some CustomizableToolbarContent\nConfigures the customization behavior of customizable toolbar content.\nRelationships\nInherits From\nToolbarContent\nConforming Types\nGroup\nConforms when Content conforms to CustomizableToolbarContent.\nToolbarItem\nConforms when ID is String and Content conforms to View.\nToolbarTitleMenu\nSee Also\nPopulating a customizable toolbar\nfunc toolbar<Content>(id: String, content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items, allowing for user customization.\nstruct ToolbarCustomizationBehavior\nThe customization behavior of customizable toolbar content.\nstruct ToolbarCustomizationOptions\nOptions that influence the default customization behavior of customizable toolbar content."
    },
    {
        "title": "NewDocumentAction",
        "url": "https://developer.apple.com/documentation/swiftui/newdocumentaction",
        "html": "Overview\n\nUse the newDocument environment value to get the instance of this structure for a given Environment. Then call the instance to present a new document. You call the instance directly because it defines a callAsFunction(_:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that creates a new document from the selected text:\n\nstruct NewDocumentFromSelection: View {\n    @FocusedBinding(\\.selectedText) private var selectedText: String?\n    @Environment(\\.newDocument) private var newDocument\n\n\n    var body: some View {\n        Button(\"New Document With Selection\") {\n            newDocument(TextDocument(text: selectedText))\n        }\n        .disabled(selectedText?.isEmpty != false)\n    }\n}\n\n\nThe above example assumes that you define a TextDocument that conforms to the FileDocument or ReferenceFileDocument protocol, and a DocumentGroup that handles the associated file type.\n\nTopics\nCalling the action\nfunc callAsFunction<D>(() -> D)\nPresents a new reference type document window.\nfunc callAsFunction<D>(() -> D)\nPresents a new document window.\nfunc callAsFunction(contentType: UTType)\nPresents a new document window.\nfunc callAsFunction(contentType: UTType, prepareDocument: (ModelContext) -> Void)\nPresents a new document window with preset contents.\nSee Also\nOpening a document programmatically\nvar newDocument: NewDocumentAction\nAn action in the environment that presents a new document.\nvar openDocument: OpenDocumentAction\nAn action in the environment that presents an existing document.\nstruct OpenDocumentAction\nAn action that presents an existing document."
    },
    {
        "title": "FileDocumentWriteConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/filedocumentwriteconfiguration",
        "html": "Topics\nWriting the content\nlet contentType: UTType\nThe expected uniform type of the file contents.\nlet existingFile: FileWrapper?\nThe file wrapper containing the current document content. nil if the document is unsaved.\nSee Also\nReading and writing documents\nstruct FileDocumentReadConfiguration\nThe configuration for reading file contents."
    },
    {
        "title": "searchCompletion(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchcompletion(_:)-e0pr",
        "html": "Parameters\ntoken\n\nData to use as the view\u2019s completion.\n\nDiscussion\n\nUse this method to associate a search token with a view that is within a search suggestion list context. The system uses this value when the view is selected to replace the partial text being currently edited of the associated search field.\n\nenum FruitToken: Hashable, Identifiable, CaseIterable {\n    case apple\n    case pear\n    case banana\n\n\n    var id: Self { self }\n}\n\n\n@State private var text = \"\"\n@State private var tokens: [FruitToken] = []\n\n\nSearchPlaceholderView()\n    .searchable(text: $text, tokens: $tokens) { token in\n        switch token {\n        case .apple: Text(\"Apple\")\n        case .pear: Text(\"Pear\")\n        case .banana: Text(\"Banana\")\n        }\n    }\n    .searchSuggestions {\n        Text(\"\ud83c\udf4e\").searchCompletion(FruitToken.apple)\n        Text(\"\ud83c\udf50\").searchCompletion(FruitToken.pear)\n        Text(\"\ud83c\udf4c\").searchCompletion(FruitToken.banana)\n    }\n\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "searchSuggestions(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchsuggestions(_:)",
        "html": "Parameters\nsuggestions\n\nA view builder that produces content that populates a list of suggestions.\n\nDiscussion\n\nYou can suggest search terms during a search operation by providing a collection of view to this modifier. The interface presents the suggestion views as a list of choices when someone activates the search interface. Associate a string with each suggestion view by adding the searchCompletion(_:) modifier to the view. For example, you can suggest fruit types by displaying their emoji, and provide the corresponding search string as a search completion in each case:\n\nProductList()\n    .searchable(text: $text)\n    .searchSuggestions {\n        Text(\"\ud83c\udf4e\").searchCompletion(\"apple\")\n        Text(\"\ud83c\udf50\").searchCompletion(\"pear\")\n        Text(\"\ud83c\udf4c\").searchCompletion(\"banana\")\n    }\n\n\nWhen someone chooses a suggestion, SwiftUI replaces the text in the search field with the search completion string. If you omit the search completion modifier for a particular suggestion view, SwiftUI displays the suggestion, but the suggestion view doesn\u2019t react to taps or clicks.\n\nImportant\n\nIn tvOS, searchable modifiers only support suggestion views of type Text, like in the above example. Other platforms can use any view for the suggestions, including custom views.\n\nYou can update the suggestions that you provide as conditions change.\n\nFor example, you can specify an array of suggestions that you store in a model:\n\nProductList()\n    .searchable(text: $text)\n    .searchSuggestions {\n        ForEach(model.suggestedSearches) { suggestion in\n            Label(suggestion.title,  image: suggestion.image)\n                .searchCompletion(suggestion.text)\n        }\n    }\n\n\nIf the model\u2019s suggestedSearches begins as an empty array, the interface doesn\u2019t display any suggestions to start. You can then provide logic that updates the array based on some condition. For example, you might update the completions based on the current search text. Note that certain events or actions, like when someone moves a macOS window, might dismiss the suggestion view.\n\nFor more information about using search modifiers, see Adding a search interface to your app.\n\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "searchCompletion(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchcompletion(_:)-2uaf3",
        "html": "Parameters\ntext\n\nA string to use as the view\u2019s completion.\n\nDiscussion\n\nUse this method to associate a fully formed string with a view that is within a search suggestion list context. The system uses this value when the view is selected to replace the partial text being currently edited of the associated search field.\n\nOn tvOS, the string that you provide to the this modifier is used when displaying the associated suggestion and when replacing the partial text of the search field.\n\nSearchPlaceholderView()\n    .searchable(text: $text) {\n        Text(\"\ud83c\udf4e\").searchCompletion(\"apple\")\n        Text(\"\ud83c\udf50\").searchCompletion(\"pear\")\n        Text(\"\ud83c\udf4c\").searchCompletion(\"banana\")\n    }\n\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "newDocument",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/newdocument",
        "html": "Discussion\n\nUse the newDocument environment value to get the instance of the NewDocumentAction structure for a given Environment. Then call the instance to present a new document. You call the instance directly because it defines a callAsFunction(_:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that creates a new document from the selected text:\n\nstruct NewDocumentFromSelection: View {\n    @FocusedBinding(\\.selectedText) private var selectedText: String?\n    @Environment(\\.newDocument) private var newDocument\n\n\n    var body: some View {\n        Button(\"New Document With Selection\") {\n            newDocument(TextDocument(text: selectedText))\n        }\n        .disabled(selectedText?.isEmpty != false)\n    }\n}\n\n\nThe above example assumes that you define a TextDocument that conforms to the FileDocument or ReferenceFileDocument protocol, and a DocumentGroup that handles the associated file type.\n\nSee Also\nOpening a document programmatically\nstruct NewDocumentAction\nAn action that presents a new document.\nvar openDocument: OpenDocumentAction\nAn action in the environment that presents an existing document.\nstruct OpenDocumentAction\nAn action that presents an existing document."
    },
    {
        "title": "Suggesting search terms",
        "url": "https://developer.apple.com/documentation/swiftui/suggesting-search-terms",
        "html": "Overview\n\nYou can suggest query text during a search operation by providing a collection of search suggestion views. Because suggestion views are not limited to plain text, you must also provide the search string that each suggestion view represents. You can also provide suggestions for tokens, if your search interface includes them. SwiftUI presents the suggestions in a list below the search field.\n\nFor both text and tokens, you manage the list of suggestions, so you have complete flexibility to decide what to suggest. For example, you can:\n\nOffer a static list of suggestions.\n\nRemember previous searches and offer the most recent or most common ones.\n\nUpdate the list of suggestions in real time based on the current search text.\n\nEmploy some combination of these and other strategies, possibly changing over time.\n\nSuggest search text\n\nSuggest search text by providing a collection of views to the searchSuggestions(_:) view modifier. This modifier applies to the searchable(text:placement:prompt:) modifier that appears before it.\n\nWhen someone activates the search interface, it presents the suggestion views as a list of choices below the query string. Associate a string with each suggestion view by adding the searchCompletion(_:) modifier to the view inside the search suggestions closure. For example, you can include emoji with fruit types that you suggest as possible products to search for, and provide the corresponding search string as a search completion in each case:\n\nProductList(departmentId: departmentId, productId: $productId)\n    .searchable(text: $model.searchText)\n    .searchSuggestions {\n        Text(\"\ud83c\udf4e Apple\").searchCompletion(\"apple\")\n        Text(\"\ud83c\udf50 Pear\").searchCompletion(\"pear\")\n        Text(\"\ud83c\udf4c Banana\").searchCompletion(\"banana\")\n    }\n\n\nWhen someone chooses a suggestion, SwiftUI replaces the text in the search field with the search completion string. In the above example, choosing \u201c\ud83c\udf50 Pear\u201d puts the text \u201cpear\u201d in the search query.\n\nIf you omit the search completion modifier for a particular suggestion view, SwiftUI displays the view, but the view doesn\u2019t react to taps or clicks. However, you can group the views with Section containers that have headers, enabling you to distinguish different kinds of suggestions, like recent searches and common search terms.\n\nImportant\n\nIn tvOS, searchable modifiers only support suggestion views of type Text, like in the above example. Other platforms can use arbitrary views for the suggestions, including custom views.\n\nCertain events or actions, like when someone moves a macOS window, might dismiss the suggestion list.\n\nSuggest tokens\n\nYou can also suggest tokens for the search field. In this case, associate a suggestion view with a token using the version of the searchCompletion(_:) modifier that takes tokens as input:\n\nProductList(departmentId: departmentId, productId: $productId)\n    .searchable(text: $model.searchText, tokens: $model.tokens) { token in\n        switch token {\n        case .apple: Text(\"Apple\")\n        case .pear: Text(\"Pear\")\n        case .banana: Text(\"Banana\")\n        }\n    }\n    .searchSuggestions {\n        Text(\"Apple\").searchCompletion(FruitToken.apple)\n        Text(\"Pear\").searchCompletion(FruitToken.pear)\n        Text(\"Banana\").searchCompletion(FruitToken.banana)\n    }\n\n\nYou can use any type that conforms to the Identifiable protocol as a token. For more information about using tokens in the search query, see Performing a search operation.\n\nSimplify token suggestions\n\nAs a convenience when you have a collection of suggestions that exactly matches the list of tokens, you can create a collection of possible tokens to suggest. For example, you can add a published suggestions property to your model that contains all the possible tokens:\n\n@Published var suggestions: [FruitToken] = FruitToken.allCases\n\n\nThen you can provide this array to one of the searchable modifiers that takes a suggestedTokens input parameter, like searchable(text:tokens:suggestedTokens:placement:prompt:token:). SwiftUI uses this to generate the suggestions automatically:\n\nProductList(departmentId: departmentId, productId: $productId)\n    .searchable(\n        text: $model.searchText,\n        tokens: $model.tokens,\n        suggestedTokens: $model.suggestions\n    ) { token in\n        switch token {\n        case .apple: Text(\"Apple\")\n        case .pear: Text(\"Pear\")\n        case .banana: Text(\"Banana\")\n        }\n    }\n\n\nIn this version of the searchable modifier, SwiftUI uses one view builder to describe the appearance of the tokens in both the search field and the suggestions container.\n\nUpdate suggestions dynamically\n\nYou can update the suggestions that you provide as conditions change. For example, you can specify an array of suggestedSearches that you store in your app\u2019s model:\n\nProductList(departmentId: departmentId, productId: $productId)\n    .searchable(text: $model.searchText)\n    .searchSuggestions {\n        ForEach(model.suggestedSearches) { suggestion in\n            Label(suggestion.title,  image: suggestion.image)\n                .searchCompletion(suggestion.text)\n        }\n    }\n\n\nIf suggestedSearches begins as an empty array, the interface doesn\u2019t display any suggestions to start. You can then update the array as conditions change, like when you want to include previous searches.\n\nSee Also\nMaking search suggestions\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "searchable(text:tokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:placement:prompt:token:)-85ahx",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "searchable(text:tokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:placement:prompt:token:)-2c10v",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "searchable(text:placement:prompt:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:placement:prompt:)-1bjj3",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "searchable(text:tokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:placement:prompt:token:)-35t4f",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "Performing a search operation",
        "url": "https://developer.apple.com/documentation/swiftui/performing-a-search-operation",
        "html": "Overview\n\nTo conduct a search in your app\u2019s data model, create storage for the query text and present it with a searchable view modifier. Because you manage the storage, you can detect when it changes and update the search operation in response. By updating search results as people type, you ensure that your app\u2019s search interface is responsive.\n\nYou can also optionally provide storage for tokens, which are discrete search terms that your app recognizes. Tokens provide a way to combine multiple search terms, and make it easier for you to indicate that a search term is common or expected in your app.\n\nFor information on how to control the placement of the search field in your app\u2019s interface, see Adding a search interface to your app.\n\nProvide storage for a string\n\nThe searchable modifiers take a Binding to a string value for the text input. The string serves as the storage for the search query field that SwiftUI displays. You can create this storage inside a view using a State property, and initialize it to an empty string:\n\n@State private var searchText: String = \"\"\n\n\nTo make it easier to share the search query among different views, you can create a published value inside an observable object that\u2019s part of your app\u2019s model:\n\nclass Model: ObservableObject {\n    @Published var searchText: String = \"\"\n}\n\n\nIn either case, pass a Binding to this string into the searchable view modifier by adding the dollar sign ($) prefix to the value:\n\nstruct ContentView: View {\n    @EnvironmentObject private var model: Model\n    @State private var departmentId: Department.ID?\n    @State private var productId: Product.ID?\n\n\n    var body: some View {\n        NavigationSplitView {\n            DepartmentList(departmentId: $departmentId)\n        } content: {\n            ProductList(departmentId: departmentId, productId: $productId)\n                .searchable(text: $model.searchText)\n        } detail: {\n            ProductDetails(productId: productId)\n        }\n    }\n}\n\nProvide storage for tokens\n\nIn addition to a search string, the search field can also display tokens when you use one of the searchable modifiers that has a tokens parameter, like searchable(text:tokens:placement:prompt:token:).\n\nYou create tokens by defining a group of values that conform to the Identifiable protocol, then instantiate the collection of values. For example you can create an enumeration of fruit tokens:\n\nenum FruitToken: String, Identifiable, Hashable, CaseIterable {\n    case apple\n    case pear\n    case banana\n    var id: Self { self }\n}\n\n\nThen add a new published property to your model to store a collection of tokens:\n\n@Published var tokens: [FruitToken] = []\n\n\nTo display tokens, provide a Binding to the tokens array as the searchable modifier\u2019s tokens input parameter, and describe how to draw each token using the token closure. From the closure, return the View that represents the token given as an input. For example, you can use a Text view to represent each token:\n\nProductList(departmentId: departmentId, productId: $productId)\n    .searchable(text: $model.searchText, tokens: $model.tokens) { token in\n        switch token {\n        case .apple: Text(\"Apple\")\n        case .pear: Text(\"Pear\")\n        case .banana: Text(\"Banana\")\n        }\n    }\n\n\nYou can represent the token with a Text view, as the above example demonstrates. In iOS and iPadOS, you can use a Label instead. Ensure the view clearly represents the corresponding search query, and if you use a label, that the tokens fit the search query field\u2019s height. Tokens appear at the beginning of the search field before any plain text. The following shows how the search field looks when the tokens array contains the apple and banana tokens:\n\nSupport tokens that have a mutable component\n\nYou can enable people to mutate part of the data that represents a token by using a Picker in the token closure. For example, suppose you have fruit token data that contains both a kind and a hydration property:\n\nstruct FruitToken: String, Identifiable, Hashable, CaseIterable {\n    enum Kind {\n        case apple\n        case pear\n        case banana\n        var id: Self { self }\n    }\n\n\n    enum Hydration: String, Identifiable, Hashable, CaseIterable {\n        case hydrated\n        case dehydrated\n    }\n\n\n    var kind: Kind\n    var hydration: Hydration = .hydrated\n}\n\n\nWith your new model, specify a Binding to the token in the token closure by adding a dollar sign ($). Use the binding to create a picker for the hydration property and a label that uses the kind property:\n\nProductList(departmentId: departmentId, productId: $productId)\n    .searchable(text: $model.searchText, tokens: $model.tokens) { $token in\n        Picker(selection: $token.hydration) {\n            ForEach(FruitToken.Hydration.allCases) { hydration in\n                switch hydration {\n                case .hydrated: Text(\"Hydrated\")\n                case .dehydrated: Text(\"Dehydrated\")\n                }\n            }\n        } label: {\n            switch token.kind {\n            case .apple: Text(\"Apple\")\n            case .pear: Text(\"Pear\")\n            case .banana: Text(\"Banana\")\n            }\n        }\n    }\n\nAdd tokens to the search\n\nProvide a way for people to add tokens to the search field. You can do this in different ways. For example, you can:\n\nSuggest tokens to add to the array by using one of the searchable view modifiers that have a suggestedTokens input parameter, like searchable(text:tokens:suggestedTokens:placement:prompt:token:). People select suggestions from a list that appears below the search field. For more information about offering suggestions for tokens, as well as for search text, see Suggesting search terms.\n\nMonitor the search string as people edit it. When you detect a substring that matches one of the tokens, convert the text into a token by removing the relevant characters from the string and add the corresponding token to the tokens array.\n\nWait until you see a dividing character in the search string, like a comma or a space, and then attempt to tokenize the preceding characters.\n\nWait until someone submits the search, and then attempt to tokenize the entire search string. For more information about submitting a search, see Managing search interface activation.\n\nConduct the search\n\nWhen you detect changes in the search query, your app can begin a search. How you perform the search operation depends on how your app stores and presents data. One approach is to filter the elements that appear in a List based on whether a field in the list\u2019s items matches the search query. For example, you can create a method that returns only the items in an array of products with names that match the search text or one of the tokens currently in the search field:\n\nfunc filteredProducts(\n    products: [Product],\n    searchText: String,\n    tokens: [FruitToken]\n) -> [Product] {\n    guard !searchText.isEmpty || !tokens.isEmpty else { return products }\n    return products.filter { product in\n        product.name.lowercased().contains(searchText.lowercased()) ||\n        tokens.map({ $0.rawValue }).contains(product.name.lowercased())\n    }\n}\n\n\nConsider the complexity of the search and the cost of changing the search terms. If the cost is high, like when updates require network access, or for complex filter logic, consider prefetching and caching data or reducing the frequency of updates. Alternatively, you can wait until someone submits the query before conducting the search. For information about detecting query submission, see Managing search interface activation.\n\nIf the search space can be broken into broad categories, you can help people narrow the search more quickly by providing a scope. See Scoping a search operation.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "environment(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/environment(_:_:)",
        "html": "Parameters\nkeyPath\n\nA key path that indicates the property of the EnvironmentValues structure to update.\n\nvalue\n\nThe new value to set for the item specified by keyPath.\n\nReturn Value\n\nA view that has the given value set in its environment.\n\nDiscussion\n\nUse this modifier to set one of the writable properties of the EnvironmentValues structure, including custom values that you create. For example, you can create a custom environment key styleOverrides to set a value that represents style settings that for the entire app:\n\nWindowGroup {\n    ContentView()\n}\n.environment(\\.styleOverrides, StyleOverrides())\n\n\nYou then read the value inside ContentView or one of its descendants using the Environment property wrapper:\n\nstruct MyView: View {\n    @Environment(\\.styleOverrides) var styleOverrides: StyleOverrides\n\n\n    var body: some View { ... }\n}\n\n\nThis modifier affects the given scene, as well as that scene\u2019s descendant views. It has no effect outside the view hierarchy on which you call it.\n\nSee Also\nModifying the environment of a scene\nfunc environment<T>(T?) -> some Scene\nPlaces an observable object in the scene\u2019s environment.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some Scene\nTransforms the environment value of the specified key path with the given function."
    },
    {
        "title": "transformEnvironment(_:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/transformenvironment(_:transform:)",
        "html": "See Also\nModifying the environment of a scene\nfunc environment<T>(T?) -> some Scene\nPlaces an observable object in the scene\u2019s environment.\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some Scene\nSets the environment value of the specified key path to the given value."
    },
    {
        "title": "transformEnvironment(_:transform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/transformenvironment(_:transform:)",
        "html": "See Also\nModifying the environment of a view\nfunc environment<T>(T?) -> some View\nPlaces an observable object in the view\u2019s environment.\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some View\nSets the environment value of the specified key path to the given value."
    },
    {
        "title": "environment(_:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/environment(_:_:)",
        "html": "Parameters\nkeyPath\n\nA key path that indicates the property of the EnvironmentValues structure to update.\n\nvalue\n\nThe new value to set for the item specified by keyPath.\n\nReturn Value\n\nA view that has the given value set in its environment.\n\nDiscussion\n\nUse this modifier to set one of the writable properties of the EnvironmentValues structure, including custom values that you create. For example, you can set the value associated with the truncationMode key:\n\nMyView()\n    .environment(\\.truncationMode, .head)\n\n\nYou then read the value inside MyView or one of its descendants using the Environment property wrapper:\n\nstruct MyView: View {\n    @Environment(\\.truncationMode) var truncationMode: Text.TruncationMode\n\n\n    var body: some View { ... }\n}\n\n\nSwiftUI provides dedicated view modifiers for setting most environment values, like the truncationMode(_:) modifier which sets the truncationMode value:\n\nMyView()\n    .truncationMode(.head)\n\n\nPrefer the dedicated modifier when available, and offer your own when defining custom environment values, as described in EnvironmentKey.\n\nThis modifier affects the given view, as well as that view\u2019s descendant views. It has no effect outside the view hierarchy on which you call it.\n\nSee Also\nModifying the environment of a view\nfunc environment<T>(T?) -> some View\nPlaces an observable object in the view\u2019s environment.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some View\nTransforms the environment value of the specified key path with the given function."
    },
    {
        "title": "EnvironmentObject",
        "url": "https://developer.apple.com/documentation/swiftui/environmentobject",
        "html": "Overview\n\nAn environment object invalidates the current view whenever the observable object that conforms to ObservableObject changes. If you declare a property as an environment object, be sure to set a corresponding model object on an ancestor view by calling its environmentObject(_:) modifier.\n\nNote\n\nIf your observable object conforms to the Observable protocol, use Environment instead of EnvironmentObject and set the model object in an ancestor view by calling its environment(_:) or environment(_:_:) modifiers.\n\nTopics\nCreating an environment object\ninit()\nCreates an environment object.\nGetting the value\nvar wrappedValue: ObjectType\nThe underlying value referenced by the environment object.\nvar projectedValue: EnvironmentObject<ObjectType>.Wrapper\nA projection of the environment object that creates bindings to its properties using dynamic member lookup.\nstruct Wrapper\nA wrapper of the underlying environment object that can create bindings to its properties using dynamic member lookup.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nDistributing model data throughout your app\nfunc environmentObject<T>(T) -> some View\nSupplies an observable object to a view\u2019s hierarchy.\nfunc environmentObject<T>(T) -> some Scene\nSupplies an ObservableObject to a view subhierarchy."
    },
    {
        "title": "environmentObject(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/environmentobject(_:)",
        "html": "Parameters\nobject\n\nthe object to store and make available to the scene\u2019s subhierarchy.\n\nDiscussion\n\nThe object can be read by any child by using EnvironmentObject:\n\nfinal class Profile: ObservableObject { ... }\n\n\n@main\nstruct MyApp: App {\n    var body: some View {\n        WindowGroup {\n            ContentView()\n        }\n        .environment(ProfileService.currentProfile)\n    }\n}\n\n\nYou then read the object inside ContentView or one of its descendants using the EnvironmentObject property wrapper:\n\nstruct ContentView: View {\n    @EnvironmentObject private var currentAccount: Account\n\n\n    var body: some View { ... }\n}\n\nSee Also\nDistributing model data throughout your app\nfunc environmentObject<T>(T) -> some View\nSupplies an observable object to a view\u2019s hierarchy.\nstruct EnvironmentObject\nA property wrapper type for an observable object that a parent or ancestor view supplies."
    },
    {
        "title": "environmentObject(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/environmentobject(_:)",
        "html": "Parameters\nobject\n\nThe object to store and make available to the view\u2019s hierarchy.\n\nDiscussion\n\nUse this modifier to add an observable object to a view\u2019s environment. The object must conform to the ObservableObject protocol.\n\nAdding an object to a view\u2019s environment makes the object available to subviews in the view\u2019s hierarchy. To retrieve the object in a subview, use the EnvironmentObject property wrapper.\n\nNote\n\nIf the observable object conforms to the Observable protocol, use either environment(_:) or the environment(_:_:) modifier to add the object to the view\u2019s environment.\n\nSee Also\nDistributing model data throughout your app\nfunc environmentObject<T>(T) -> some Scene\nSupplies an ObservableObject to a view subhierarchy.\nstruct EnvironmentObject\nA property wrapper type for an observable object that a parent or ancestor view supplies."
    },
    {
        "title": "onReceive(_:perform:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onreceive(_:perform:)",
        "html": "Parameters\npublisher\n\nThe publisher to subscribe to.\n\naction\n\nThe action to perform when an event is emitted by publisher. The event emitted by publisher is passed as a parameter to action.\n\nReturn Value\n\nA view that triggers action when publisher emits an event.\n\nSee Also\nResponding to data changes\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes.\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes."
    },
    {
        "title": "onChange(of:initial:_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/onchange(of:initial:_:)-4psgg",
        "html": "Parameters\nvalue\n\nThe value to check against when determining whether to run the closure.\n\ninitial\n\nWhether the action should be run when this view initially appears.\n\naction\n\nA closure to run when the value changes.\n\noldValue\n\nThe old value that failed the comparison check (or the initial value when requested).\n\nnewValue\n\nThe new value that failed the comparison check.\n\nReturn Value\n\nA view that fires an action when the specified value changes.\n\nDiscussion\n\nYou can use onChange to trigger a side effect as the result of a value changing, such as an Environment key or a Binding.\n\nThe system may call the action closure on the main actor, so avoid long-running tasks in the closure. If you need to perform such tasks, detach an asynchronous background task.\n\nWhen the value changes, the new version of the closure will be called, so any captured values will have their values from the time that the observed value has its new value. The old and new observed values are passed into the closure. In the following code example, PlayerView passes both the old and new values to the model.\n\nstruct PlayerView: View {\n    var episode: Episode\n    @State private var playState: PlayState = .paused\n\n\n    var body: some View {\n        VStack {\n            Text(episode.title)\n            Text(episode.showTitle)\n            PlayButton(playState: $playState)\n        }\n        .onChange(of: playState) { oldState, newState in\n            model.playStateDidChange(from: oldState, to: newState)\n        }\n    }\n}\n\nSee Also\nResponding to data changes\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes.\nfunc onReceive<P>(P, perform: (P.Output) -> Void) -> some View\nAdds an action to perform when this view detects data emitted by the given publisher."
    },
    {
        "title": "searchable(text:tokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:ispresented:placement:prompt:token:)-e813",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nThe key for the localized prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "ObservedObject",
        "url": "https://developer.apple.com/documentation/swiftui/observedobject",
        "html": "Overview\n\nAdd the @ObservedObject attribute to a parameter of a SwiftUI View when the input is an ObservableObject and you want the view to update when the object\u2019s published properties change. You typically do this to pass a StateObject into a subview.\n\nThe following example defines a data model as an observable object, instantiates the model in a view as a state object, and then passes the instance to a subview as an observed object:\n\nclass DataModel: ObservableObject {\n    @Published var name = \"Some Name\"\n    @Published var isEnabled = false\n}\n\n\nstruct MyView: View {\n    @StateObject private var model = DataModel()\n\n\n    var body: some View {\n        Text(model.name)\n        MySubView(model: model)\n    }\n}\n\n\nstruct MySubView: View {\n    @ObservedObject var model: DataModel\n\n\n    var body: some View {\n        Toggle(\"Enabled\", isOn: $model.isEnabled)\n    }\n}\n\n\nWhen any published property of the observable object changes, SwiftUI updates any view that depends on the object. Subviews can also make updates to the model properties, like the Toggle in the above example, that propagate to other observers throughout the view hierarchy.\n\nDon\u2019t specify a default or initial value for the observed object. Use the attribute only for a property that acts as an input for a view, as in the above example.\n\nNote\n\nDon\u2019t wrap objects conforming to the Observable protocol with @ObservedObject. SwiftUI automatically tracks dependencies to Observable objects used within body and updates dependent views when their data changes. Attempting to wrap an Observable object with @ObservedObject may cause a compiler error, because it requires that its wrapped object to conform to the ObservableObject protocol.\n\nIf the view needs a binding to a property of an Observable object in its body, wrap the object with the Bindable property wrapper instead; for example, @Bindable var model: DataModel. For more information, see Managing model data in your app.\n\nTopics\nCreating an observed object\ninit(wrappedValue: ObjectType)\nCreates an observed object with an initial wrapped value.\ninit(initialValue: ObjectType)\nCreates an observed object with an initial value.\nGetting the value\nvar wrappedValue: ObjectType\nThe underlying value that the observed object references.\nvar projectedValue: ObservedObject<ObjectType>.Wrapper\nA projection of the observed object that creates bindings to its properties.\nstruct Wrapper\nA wrapper of the underlying observable object that can create bindings to its properties.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nCreating model data\nManaging model data in your app\nCreate connections between your app\u2019s data model and views.\nMigrating from the Observable Object protocol to the Observable macro\nUpdate your existing app to leverage the benefits of Observation in Swift.\nMonitoring data changes in your app\nShow changes to data in your app\u2019s user interface by using observable objects.\nstruct StateObject\nA property wrapper type that instantiates an observable object."
    },
    {
        "title": "StateObject",
        "url": "https://developer.apple.com/documentation/swiftui/stateobject",
        "html": "Overview\n\nUse a state object as the single source of truth for a reference type that you store in a view hierarchy. Create a state object in an App, Scene, or View by applying the @StateObject attribute to a property declaration and providing an initial value that conforms to the ObservableObject protocol. Declare state objects as private to prevent setting them from a memberwise initializer, which can conflict with the storage management that SwiftUI provides:\n\nclass DataModel: ObservableObject {\n    @Published var name = \"Some Name\"\n    @Published var isEnabled = false\n}\n\n\nstruct MyView: View {\n    @StateObject private var model = DataModel() // Create the state object.\n\n\n    var body: some View {\n        Text(model.name) // Updates when the data model changes.\n        MySubView()\n            .environmentObject(model)\n    }\n}\n\n\nSwiftUI creates a new instance of the model object only once during the lifetime of the container that declares the state object. For example, SwiftUI doesn\u2019t create a new instance if a view\u2019s inputs change, but does create a new instance if the identity of a view changes. When published properties of the observable object change, SwiftUI updates any view that depends on those properties, like the Text view in the above example.\n\nNote\n\nIf you need to store a value type, like a structure, string, or integer, use the State property wrapper instead. Also use State if you need to store a reference type that conforms to the Observable() protocol. To learn more about Observation in SwiftUI, see Managing model data in your app.\n\nShare state objects with subviews\n\nYou can pass a state object into a subview through a property that has the ObservedObject attribute. Alternatively, add the object to the environment of a view hierarchy by applying the environmentObject(_:) modifier to a view, like MySubView in the above code. You can then read the object inside MySubView or any of its descendants using the EnvironmentObject attribute:\n\nstruct MySubView: View {\n    @EnvironmentObject var model: DataModel\n\n\n    var body: some View {\n        Toggle(\"Enabled\", isOn: $model.isEnabled)\n    }\n}\n\n\nGet a Binding to the state object\u2019s properties using the dollar sign ($) operator. Use a binding when you want to create a two-way connection. In the above code, the Toggle controls the model\u2019s isEnabled value through a binding.\n\nInitialize state objects using external data\n\nWhen a state object\u2019s initial state depends on data that comes from outside its container, you can call the object\u2019s initializer explicitly from within its container\u2019s initializer. For example, suppose the data model from the previous example takes a name input during initialization and you want to use a value for that name that comes from outside the view. You can do this with a call to the state object\u2019s initializer inside an explicit initializer that you create for the view:\n\nstruct MyInitializableView: View {\n    @StateObject private var model: DataModel\n\n\n    init(name: String) {\n        // SwiftUI ensures that the following initialization uses the\n        // closure only once during the lifetime of the view, so\n        // later changes to the view's name input have no effect.\n        _model = StateObject(wrappedValue: DataModel(name: name))\n    }\n\n\n    var body: some View {\n        VStack {\n            Text(\"Name: \\(model.name)\")\n        }\n    }\n}\n\n\nUse caution when doing this. SwiftUI only initializes a state object the first time you call its initializer in a given view. This ensures that the object provides stable storage even as the view\u2019s inputs change. However, it might result in unexpected behavior or unwanted side effects if you explicitly initialize the state object.\n\nIn the above example, if the name input to MyInitializableView changes, SwiftUI reruns the view\u2019s initializer with the new value. However, SwiftUI runs the autoclosure that you provide to the state object\u2019s initializer only the first time you call the state object\u2019s initializer, so the model\u2019s stored name value doesn\u2019t change.\n\nExplicit state object initialization works well when the external data that the object depends on doesn\u2019t change for a given instance of the object\u2019s container. For example, you can create two views with different constant names:\n\nvar body: some View {\n    VStack {\n        MyInitializableView(name: \"Ravi\")\n        MyInitializableView(name: \"Maria\")\n    }\n}\n\n\nImportant\n\nEven for a configurable state object, you still declare it as private. This ensures that you can\u2019t accidentally set the parameter through a memberwise initializer of the view, because doing so can conflict with the framework\u2019s storage management and produce unexpected results.\n\nForce reinitialization by changing view identity\n\nIf you want SwiftUI to reinitialize a state object when a view input changes, make sure that the view\u2019s identity changes at the same time. One way to do this is to bind the view\u2019s identity to the value that changes using the id(_:) modifier. For example, you can ensure that the identity of an instance of MyInitializableView changes when its name input changes:\n\nMyInitializableView(name: name)\n    .id(name) // Binds the identity of the view to the name property.\n\n\nNote\n\nIf your view appears inside a ForEach, it implicitly receives an id(_:) modifier that uses the identifier of the corresponding data element.\n\nIf you need the view to reinitialize state based on changes in more than one value, you can combine the values into a single identifier using a Hasher. For example, if you want to update the data model in MyInitializableView when the values of either name or isEnabled change, you can combine both variables into a single hash:\n\nvar hash: Int {\n    var hasher = Hasher()\n    hasher.combine(name)\n    hasher.combine(isEnabled)\n    return hasher.finalize()\n}\n\n\nThen apply the combined hash to the view as an identifier:\n\nMyInitializableView(name: name, isEnabled: isEnabled)\n    .id(hash)\n\n\nBe mindful of the performance cost of reinitializing the state object every time the input changes. Also, changing view identity can have side effects. For example, SwiftUI doesn\u2019t automatically animate changes inside the view if the view\u2019s identity changes at the same time. Also, changing the identity resets all state held by the view, including values that you manage as State, FocusState, GestureState, and so on.\n\nTopics\nCreating a state object\ninit(wrappedValue: () -> ObjectType)\nCreates a new state object with an initial wrapped value.\nGetting the value\nvar wrappedValue: ObjectType\nThe underlying value referenced by the state object.\nvar projectedValue: ObservedObject<ObjectType>.Wrapper\nA projection of the state object that creates bindings to its properties.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nCreating model data\nManaging model data in your app\nCreate connections between your app\u2019s data model and views.\nMigrating from the Observable Object protocol to the Observable macro\nUpdate your existing app to leverage the benefits of Observation in Swift.\nMonitoring data changes in your app\nShow changes to data in your app\u2019s user interface by using observable objects.\nstruct ObservedObject\nA property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes."
    },
    {
        "title": "Monitoring data changes in your app",
        "url": "https://developer.apple.com/documentation/swiftui/monitoring-model-data-changes-in-your-app",
        "html": "Overview\n\nYou typically store and process data in your app using a data model that\u2019s separate from your app\u2019s user interface (UI) and other logic. The separation promotes modularity, improves testability, and makes it easier to reason about how your app works.\n\nTraditionally, you use a view controller to move data back and forth between the model and the UI, but SwiftUI handles most of this synchronization for you. To update views when data changes, you make your data model classes observable objects, publish their properties, and declare instances of them using property wrappers. To ensure user-driven data changes flow back into the model, you bind UI controls to model properties. Working together, these features help you to maintain a single source of truth for your data.\n\nImportant\n\nThis article explains how to observe model data changes in SwiftUI apps that have a minimum deployment target that is prior to iOS 17, iPadOS 17, macOS 14, tvOS 17, or watchOS 10. To prepare your app for a newer version of one of those operating systems, see Migrating from the Observable Object protocol to the Observable macro. If your app\u2019s minimum deployment target is iOS 17, iPadOS 17, macOS 14, tvOS 17, or watchOS 10 or later, use the observation approach described in Managing model data in your app.\n\nMake model data observable\n\nTo make the data changes in your model visible to SwiftUI, adopt the ObservableObject protocol for model classes. For example, you can create a Book class that\u2019s an observable object:\n\nclass Book: ObservableObject {\n}\n\n\nThe system automatically infers the ObjectWillChangePublisher associated type for the class and synthesizes the required objectWillChange method that emits the changed values of published properties. To publish a property, add the Published property wrapper to the property\u2019s declaration:\n\nclass Book: ObservableObject {\n    @Published var title = \"Sample Book Title\"\n}\n\n\nAvoid the overhead of a published property when you don\u2019t need it. Only publish properties that both can change and that matter to the UI. For example, the Book class might have an identifier property that never changes after initialization:\n\nclass Book: ObservableObject {\n    @Published var title = \"Sample Book Title\"\n\n\n    let identifier = UUID() // A unique identifier that never changes.\n}\n\n\nYou can still display the identifier in your user interface, but because it isn\u2019t published, SwiftUI doesn\u2019t watch that particular property for changes.\n\nMonitor changes in observable objects\n\nTo tell SwiftUI to monitor an observable object, add the ObservedObject property wrapper to the property\u2019s declaration:\n\nstruct BookView: View {\n    @ObservedObject var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n\n\nYou can pass individual properties of an observed object to child views, as shown above. When the data changes, like when you load new data from disk, SwiftUI updates all the affected views. You can also pass an entire observable object to a child view and share model objects across levels of a view hierarchy:\n\nstruct BookView: View {\n    @ObservedObject var book: Book\n    \n    var body: some View {\n        BookEditView(book: book)\n    }\n}\n\n\nstruct BookEditView: View {\n    @ObservedObject var book: Book\n\n\n    // ...\n}\n\nInstantiate a model object in a view\n\nSwiftUI might create or recreate a view at any time, so it\u2019s important that initializing a view with a given set of inputs always results in the same view. As a result, it\u2019s unsafe to create an observed object inside a view. Instead, SwiftUI provides the StateObject property wrapper, which creates a single source of truth for a reference type that you store in a view hierarchy. You can safely create a Book instance inside a view this way:\n\nstruct LibraryView: View {\n    @StateObject private var book = Book()\n    \n    var body: some View {\n        BookView(book: book)\n    }\n}\n\n\nA state object behaves like an observed object, except that SwiftUI creates and manages a single object instance for a given view instance, regardless of how many times it recreates the view. You can use the object locally, or pass the state object into another view\u2019s observed object property, as shown in the above example.\n\nWhile SwiftUI doesn\u2019t recreate the state object within a view, it does create a distinct object instance for each view instance. For example, each LibraryView in the following code gets a unique Book instance:\n\nVStack {\n    LibraryView()\n    LibraryView()\n}\n\n\nYou can also create a state object in your top level App instance, or in one of your app\u2019s Scene instances. For example, if you define an observable object called Library to hold a collection of books for a book reader app, you could create a single library instance in the app\u2019s top level structure:\n\n@main\nstruct BookReader: App {\n    @StateObject private var library = Library()\n\n\n    // ...\n}\n\nShare an object throughout your app\n\nIf you have a data model object that you want to use throughout your app, but don\u2019t want to pass it through many layers of hierarchy, you can use the environmentObject(_:) view modifier to put the object into the environment instead:\n\n@main\nstruct BookReader: App {\n    @StateObject private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environmentObject(library)\n        }\n    }\n}\n\n\nAny descendant view of the view to which you apply the modifier can then access the data model instance by declaring a property with the EnvironmentObject property wrapper:\n\nstruct LibraryView: View {\n    @EnvironmentObject var library: Library\n    \n    // ...\n}\n\n\nIf you use an environment object, you might add it to the view at the top of your app\u2019s hierarchy, as shown above. Alternatively, you might add it to the root view of a subtree in your view hierarchy. Either way, remember to also add it to the preview provider of any view that uses the object, or that has a descendant that uses the object:\n\nstruct LibraryView_Previews: PreviewProvider {\n    static var previews: some View {\n        LibraryView()\n            .environmentObject(Library())\n    }\n}\n\nCreate a two-way connection using bindings\n\nWhen you allow a person to change the data in the UI, use a binding to the corresponding property. This ensures that updates flow back into the data model automatically. You can get a binding to an observed object, state object, or environment object property by prefixing the name of the object with the dollar sign ($). For example, if you let someone edit the title of a book by adding a TextField to the BookEditView, give the text field a binding to the book\u2019s title property:\n\nstruct BookEditView: View {\n    @ObservedObject var book: Book\n    \n    var body: some View {\n        TextField(\"Title\", text: $book.title)\n    }\n}\n\n\nThe binding connects the view element to the underlying model so that a person makes changes directly to the model data.\n\nSee Also\nCreating model data\nManaging model data in your app\nCreate connections between your app\u2019s data model and views.\nMigrating from the Observable Object protocol to the Observable macro\nUpdate your existing app to leverage the benefits of Observation in Swift.\nstruct StateObject\nA property wrapper type that instantiates an observable object.\nstruct ObservedObject\nA property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes."
    },
    {
        "title": "Environment",
        "url": "https://developer.apple.com/documentation/swiftui/environment",
        "html": "Overview\n\nUse the Environment property wrapper to read a value stored in a view\u2019s environment. Indicate the value to read using an EnvironmentValues key path in the property declaration. For example, you can create a property that reads the color scheme of the current view using the key path of the colorScheme property:\n\n@Environment(\\.colorScheme) var colorScheme: ColorScheme\n\n\nYou can condition a view\u2019s content on the associated value, which you read from the declared property\u2019s wrappedValue. As with any property wrapper, you access the wrapped value by directly referring to the property:\n\nif colorScheme == .dark { // Checks the wrapped value.\n    DarkContent()\n} else {\n    LightContent()\n}\n\n\nIf the value changes, SwiftUI updates any parts of your view that depend on the value. For example, that might happen in the above example if the user changes the Appearance settings.\n\nYou can use this property wrapper to read \u2014 but not set \u2014 an environment value. SwiftUI updates some environment values automatically based on system settings and provides reasonable defaults for others. You can override some of these, as well as set custom environment values that you define, using the environment(_:_:) view modifier.\n\nFor the complete list of environment values provided by SwiftUI, see the properties of the EnvironmentValues structure. For information about creating custom environment values, see the EnvironmentKey protocol.\n\nGet an observable object\n\nYou can also use Environment to get an observable object from a view\u2019s environment. The observable object must conform to the Observable protocol, and your app must set the object in the environment using the the object itself or a key path.\n\nTo set the object in the environment using the object itself, use the environment(_:) modifier:\n\n@Observable\nclass Library {\n    var books: [Book] = [Book(), Book(), Book()]\n\n\n    var availableBooksCount: Int {\n        books.filter(\\.isAvailable).count\n    }\n}\n\n\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n\n\n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}\n\n\nTo get the observable object using its type, create a property and provide the Environment property wrapper the object\u2019s type:\n\nstruct LibraryView: View {\n    @Environment(Library.self) private var library\n\n\n    var body: some View {\n        // ...\n    }\n}\n\n\nBy default, reading an object from the environment returns a non-optional object when using the object type as the key. This default behavior assumes that a view in the current hierarchy previously stored a non-optional instance of the type using the environment(_:) modifier. If a view attempts to retrieve an object using its type and that object isn\u2019t in the environment, SwiftUI throws an exception.\n\nIn cases where there is no guarantee that an object is in the environment, retrieve an optional version of the object as shown in the following code. If the object isn\u2019t available the environment, SwiftUI returns nil instead of throwing an exception.\n\n@Environment(Library.self) private var library: Library?\n\nGet an observable object using a key path\n\nTo set the object with a key path, use the environment(_:_:) modifier:\n\n@Observable\nclass Library {\n    var books: [Book] = [Book(), Book(), Book()]\n\n\n    var availableBooksCount: Int {\n        books.filter(\\.isAvailable).count\n    }\n}\n\n\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n\n\n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(\\.library, library)\n        }\n    }\n}\n\n\nTo get the object, create a property and specify the key path:\n\nstruct LibraryView: View {\n    @Environment(\\.library) private var library\n\n\n    var body: some View {\n        // ...\n    }\n}\n\nTopics\nCreating an environment instance\ninit(KeyPath<EnvironmentValues, Value>)\nCreates an environment property to read the specified key path.\ninit(Value.Type)\nCreates an environment property to read an observable object from the environment.\ninit<T>(T.Type)\nCreates an environment property to read an observable object from the environment, returning nil if no corresponding object has been set in the current view\u2019s environment.\nGetting the value\nvar wrappedValue: Value\nThe current value of the environment property.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nAccessing environment values\nstruct EnvironmentValues\nA collection of environment values propagated through a view hierarchy."
    },
    {
        "title": "Binding",
        "url": "https://developer.apple.com/documentation/swiftui/binding",
        "html": "Overview\n\nUse a binding to create a two-way connection between a property that stores data, and a view that displays and changes the data. A binding connects a property to a source of truth stored elsewhere, instead of storing data directly. For example, a button that toggles between play and pause can create a binding to a property of its parent view using the Binding property wrapper.\n\nstruct PlayButton: View {\n    @Binding var isPlaying: Bool\n\n\n    var body: some View {\n        Button(isPlaying ? \"Pause\" : \"Play\") {\n            isPlaying.toggle()\n        }\n    }\n}\n\n\nThe parent view declares a property to hold the playing state, using the State property wrapper to indicate that this property is the value\u2019s source of truth.\n\nstruct PlayerView: View {\n    var episode: Episode\n    @State private var isPlaying: Bool = false\n\n\n    var body: some View {\n        VStack {\n            Text(episode.title)\n                .foregroundStyle(isPlaying ? .primary : .secondary)\n            PlayButton(isPlaying: $isPlaying) // Pass a binding.\n        }\n    }\n}\n\n\nWhen PlayerView initializes PlayButton, it passes a binding of its state property into the button\u2019s binding property. Applying the $ prefix to a property wrapped value returns its projectedValue, which for a state property wrapper returns a binding to the value.\n\nWhenever the user taps the PlayButton, the PlayerView updates its isPlaying state.\n\nNote\n\nTo create bindings to properties of a type that conforms to the Observable protocol, use the Bindable property wrapper. For more information, see Migrating from the Observable Object protocol to the Observable macro.\n\nTopics\nCreating a binding\ninit?(Binding<Value?>)\nCreates a binding by projecting the base value to an unwrapped value.\ninit<V>(Binding<V>)\nCreates a binding by projecting the base value to an optional value.\ninit<V>(Binding<V>)\nCreates a binding by projecting the base value to a hashable value.\ninit(projectedValue: Binding<Value>)\nCreates a binding from the value of another binding.\ninit(get: () -> Value, set: (Value, Transaction) -> Void)\nCreates a binding with a closure that reads from the binding value, and a closure that applies a transaction when writing to the binding value.\ninit(get: () -> Value, set: (Value) -> Void)\nCreates a binding with closures that read and write the binding value.\nstatic func constant(Value) -> Binding<Value>\nCreates a binding with an immutable value.\nGetting the value\nvar wrappedValue: Value\nThe underlying value referenced by the binding variable.\nvar projectedValue: Binding<Value>\nA projection of the binding value that returns a binding.\nsubscript<Subject>(dynamicMember _: WritableKeyPath<Value, Subject>) -> Binding<Subject>\nReturns a binding to the resulting value of a given key path.\nManaging changes\nvar id: Value.ID\nThe stable identity of the entity associated with this instance, corresponding to the id of the binding\u2019s wrapped value.\nAvailable when Value conforms to Identifiable.\nfunc animation(Animation?) -> Binding<Value>\nSpecifies an animation to perform when the binding value changes.\nfunc transaction(Transaction) -> Binding<Value>\nSpecifies a transaction for the binding.\nvar transaction: Transaction\nThe binding\u2019s transaction.\nDefault Implementations\nIdentifiable Implementations\nRelationships\nConforms To\nBidirectionalCollection\nCollection\nDynamicProperty\nIdentifiable\nRandomAccessCollection\nSequence\nSee Also\nCreating and sharing view state\nManaging user interface state\nEncapsulate view-specific data within your app\u2019s view hierarchy to make your views reusable.\nstruct State\nA property wrapper type that can read and write a value managed by SwiftUI.\nstruct Bindable\nA property wrapper type that supports creating bindings to the mutable properties of observable objects."
    },
    {
        "title": "dynamicIsland(verticalPlacement:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/dynamicisland(verticalplacement:)",
        "html": "Parameters\nverticalPlacement\n\nThe vertical placement for a view that\u2019s part of an expanded Live Activity in the Dynamic Island.\n\nReturn Value\n\nA view with the specified vertical placement."
    },
    {
        "title": "State",
        "url": "https://developer.apple.com/documentation/swiftui/state",
        "html": "Overview\n\nUse state as the single source of truth for a given value type that you store in a view hierarchy. Create a state value in an App, Scene, or View by applying the @State attribute to a property declaration and providing an initial value. Declare state as private to prevent setting it in a memberwise initializer, which can conflict with the storage management that SwiftUI provides:\n\nstruct PlayButton: View {\n    @State private var isPlaying: Bool = false // Create the state.\n\n\n    var body: some View {\n        Button(isPlaying ? \"Pause\" : \"Play\") { // Read the state.\n            isPlaying.toggle() // Write the state.\n        }\n    }\n}\n\n\nSwiftUI manages the property\u2019s storage. When the value changes, SwiftUI updates the parts of the view hierarchy that depend on the value. To access a state\u2019s underlying value, you use its wrappedValue property. However, as a shortcut Swift enables you to access the wrapped value by referring directly to the state instance. The above example reads and writes the isPlaying state property\u2019s wrapped value by referring to the property directly.\n\nDeclare state as private in the highest view in the view hierarchy that needs access to the value. Then share the state with any subviews that also need access, either directly for read-only access, or as a binding for read-write access. You can safely mutate state properties from any thread.\n\nShare state with subviews\n\nIf you pass a state property to a subview, SwiftUI updates the subview any time the value changes in the container view, but the subview can\u2019t modify the value. To enable the subview to modify the state\u2019s stored value, pass a Binding instead.\n\nFor example, you can remove the isPlaying state from the play button in the above example, and instead make the button take a binding:\n\nstruct PlayButton: View {\n    @Binding var isPlaying: Bool // Play button now receives a binding.\n\n\n    var body: some View {\n        Button(isPlaying ? \"Pause\" : \"Play\") {\n            isPlaying.toggle()\n        }\n    }\n}\n\n\nThen you can define a player view that declares the state and creates a binding to the state. Get the binding to the state value by accessing the state\u2019s projectedValue, which you get by prefixing the property name with a dollar sign ($):\n\nstruct PlayerView: View {\n    @State private var isPlaying: Bool = false // Create the state here now.\n\n\n    var body: some View {\n        VStack {\n            PlayButton(isPlaying: $isPlaying) // Pass a binding.\n\n\n            // ...\n        }\n    }\n}\n\n\nLike you do for a StateObject, declare State as private to prevent setting it in a memberwise initializer, which can conflict with the storage management that SwiftUI provides. Unlike a state object, always initialize state by providing a default value in the state\u2019s declaration, as in the above examples. Use state only for storage that\u2019s local to a view and its subviews.\n\nStore observable objects\n\nYou can also store observable objects that you create with the Observable() macro in State; for example:\n\n@Observable\nclass Library {\n    var name = \"My library of books\"\n    // ...\n}\n\n\nstruct ContentView: View {\n    @State private var library = Library()\n\n\n    var body: some View {\n        LibraryView(library: library)\n    }\n}\n\n\nA State property always instantiates its default value when SwiftUI instantiates the view. For this reason, avoid side effects and performance-intensive work when initializing the default value. For example, if a view updates frequently, allocating a new default object each time the view initializes can become expensive. Instead, you can defer the creation of the object using the task(priority:_:) modifier, which is called only once when the view first appears:\n\nstruct ContentView: View {\n    @State private var library: Library?\n\n\n    var body: some View {\n        LibraryView(library: library)\n            .task {\n                library = Library()\n            }\n    }\n}\n\n\nDelaying the creation of the observable state object ensures that unnecessary allocations of the object doesn\u2019t happen each time SwiftUI initializes the view. Using the task(priority:_:) modifier is also an effective way to defer any other kind of work required to create the initial state of the view, such as network calls or file access.\n\nNote\n\nIt\u2019s possible to store an object that conforms to the ObservableObject protocol in a State property. However the view will only update when the reference to the object changes, such as when setting the property with a reference to another object. The view will not update if any of the object\u2019s published properties change. To track changes to both the reference and the object\u2019s published properties, use StateObject instead of State when storing the object.\n\nShare observable state objects with subviews\n\nTo share an Observable object stored in State with a subview, pass the object reference to the subview. SwiftUI updates the subview anytime an observable property of the object changes, but only when the subview\u2019s body reads the property. For example, in the following code BookView updates each time title changes but not when isAvailable changes:\n\n@Observable\nclass Book {\n    var title = \"A sample book\"\n    var isAvailable = true\n}\n\n\nstruct ContentView: View {\n    @State private var book = Book()\n\n\n    var body: some View {\n        BookView(book: book)\n    }\n}\n\n\nstruct BookView: View {\n    var book: Book\n\n\n    var body: some View {\n        Text(book.title)\n    }\n}\n\n\nState properties provide bindings to their value. When storing an object, you can get a Binding to that object, specifically the reference to the object. This is useful when you need to change the reference stored in state in some other subview, such as setting the reference to nil:\n\nstruct ContentView: View {\n    @State private var book: Book?\n\n\n    var body: some View {\n        DeleteBookView(book: $book)\n            .task {\n                book = Book()\n            }\n    }\n}\n\n\nstruct DeleteBookView: View {\n    @Binding var book: Book?\n\n\n    var body: some View {\n        Button(\"Delete book\") {\n            book = nil\n        }\n    }\n}\n\n\nHowever, passing a Binding to an object stored in State isn\u2019t necessary when you need to change properties of that object. For example, you can set the properties of the object to new values in a subview by passing the object reference instead of a binding to the reference:\n\nstruct ContentView: View {\n    @State private var book = Book()\n\n\n    var body: some View {\n        BookCheckoutView(book: book)\n    }\n}\n\n\nstruct BookCheckoutView: View {\n    var book: Book\n\n\n    var body: some View {\n        Button(book.isAvailable ? \"Check out book\" : \"Return book\") {\n            book.isAvailable.toggle()\n        }\n    }\n}\n\n\nIf you need a binding to a specific property of the object, pass either the binding to the object and extract bindings to specific properties where needed, or pass the object reference and use the Bindable property wrapper to create bindings to specific properties. For example, in the following code BookEditorView wraps book with @Bindable. Then the view uses the $ syntax to pass to a TextField a binding to title:\n\nstruct ContentView: View {\n    @State private var book = Book()\n\n\n    var body: some View {\n        BookView(book: book)\n    }\n}\n\n\nstruct BookView: View {\n    let book: Book\n\n\n    var body: some View {\n        BookEditorView(book: book)\n    }\n}\n\n\nstruct BookEditorView: View {\n    @Bindable var book: Book\n\n\n    var body: some View {\n        TextField(\"Title\", text: $book.title)\n    }\n}\n\nTopics\nCreating a state\ninit(wrappedValue: Value)\nCreates a state property that stores an initial wrapped value.\ninit(initialValue: Value)\nCreates a state property that stores an initial value.\ninit()\nCreates a state property without an initial value.\nAvailable when Value conforms to ExpressibleByNilLiteral.\nGetting the value\nvar wrappedValue: Value\nThe underlying value referenced by the state variable.\nvar projectedValue: Binding<Value>\nA binding to the state value.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nCreating and sharing view state\nManaging user interface state\nEncapsulate view-specific data within your app\u2019s view hierarchy to make your views reusable.\nstruct Bindable\nA property wrapper type that supports creating bindings to the mutable properties of observable objects.\nstruct Binding\nA property wrapper type that can read and write a value owned by a source of truth."
    },
    {
        "title": "Bindable",
        "url": "https://developer.apple.com/documentation/swiftui/bindable",
        "html": "Overview\n\nUse this property wrapper to create bindings to mutable properties of a data model object that conforms to the Observable protocol. For example, the following code wraps the book input with @Bindable. Then it uses a TextField to change the title property of a book, and a Toggle to change the isAvailable property, using the $ syntax to pass a binding for each property to those controls.\n\n@Observable\nclass Book: Identifiable {\n    var title = \"Sample Book Title\"\n    var isAvailable = true\n}\n\n\nstruct BookEditView: View {\n    @Bindable var book: Book\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Form {\n            TextField(\"Title\", text: $book.title)\n\n\n            Toggle(\"Book is available\", isOn: $book.isAvailable)\n\n\n            Button(\"Close\") {\n                dismiss()\n            }\n        }\n    }\n}\n\n\nYou can use the Bindable property wrapper on properties and variables to an Observable object. This includes global variables, properties that exists outside of SwiftUI types, or even local variables. For example, you can create a @Bindable variable within a view\u2019s body:\n\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n\n    var body: some View {\n        List(books) { book in\n            @Bindable var book = book\n            TextField(\"Title\", text: $book.title)\n        }\n    }\n}\n\n\nThe @Bindable variable book provides a binding that connects TextField to the title property of a book so that a person can make changes directly to the model data.\n\nUse this same approach when you need a binding to a property of an observable object stored in a view\u2019s environment. For example, the following code uses the Environment property wrapper to retrieve an instance of the observable type Book. Then the code creates a @Bindable variable book and passes a binding for the title property to a TextField using the $ syntax.\n\nstruct TitleEditView: View {\n    @Environment(Book.self) private var book\n\n\n    var body: some View {\n        @Bindable var book = book\n        TextField(\"Title\", text: $book.title)\n    }\n}\n\nTopics\nCreating a bindable value\ninit(Value)\nCreates a bindable object from an observable object.\nAvailable when Value conforms to Observable.\ninit(wrappedValue: Value)\nCreates a bindable object from an observable object.\nAvailable when Value conforms to Observable.\ninit(projectedValue: Bindable<Value>)\nCreates a bindable from the value of another bindable.\nAvailable when Value conforms to Observable.\nGetting the value\nvar wrappedValue: Value\nThe wrapped object.\nvar projectedValue: Bindable<Value>\nThe bindable wrapper for the object that creates bindings to its properties using dynamic member lookup.\nsubscript<Subject>(dynamicMember _: ReferenceWritableKeyPath<Value, Subject>) -> Binding<Subject>\nReturns a binding to the value of a given key path.\nRelationships\nConforms To\nIdentifiable\nSendable\nSee Also\nCreating and sharing view state\nManaging user interface state\nEncapsulate view-specific data within your app\u2019s view hierarchy to make your views reusable.\nstruct State\nA property wrapper type that can read and write a value managed by SwiftUI.\nstruct Binding\nA property wrapper type that can read and write a value owned by a source of truth."
    },
    {
        "title": "Managing user interface state",
        "url": "https://developer.apple.com/documentation/swiftui/managing-user-interface-state",
        "html": "Overview\n\nStore data as state in the least common ancestor of the views that need the data to establish a single source of truth that\u2019s shared across views. Provide the data as read-only through a Swift property, or create a two-way connection to the state with a binding. SwiftUI watches for changes in the data, and updates any affected views as needed.\n\nDon\u2019t use state properties for persistent storage because the life cycle of state variables mirrors the view life cycle. Instead, use them to manage transient state that only affects the user interface, like the highlight state of a button, filter settings, or the currently selected list item. You might also find this kind of storage convenient while you prototype, before you\u2019re ready to make changes to your app\u2019s data model.\n\nManage mutable values as state\n\nIf a view needs to store data that it can modify, declare a variable with the State property wrapper. For example, you can create an isPlaying Boolean inside a podcast player view to keep track of when a podcast is running:\n\nstruct PlayerView: View {\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        // ...\n    }\n}\n\n\nMarking the property as state tells the framework to manage the underlying storage. Your view reads and writes the data, found in the state\u2019s wrappedValue property, by using the property name. When you change the value, SwiftUI updates the affected parts of the view. For example, you can add a button to the PlayerView that toggles the stored value when tapped, and that displays a different image depending on the stored value:\n\nButton(action: {\n    self.isPlaying.toggle()\n}) {\n    Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n}\n\n\nLimit the scope of state variables by declaring them as private. This ensures that the variables remain encapsulated in the view hierarchy that declares them.\n\nDeclare Swift properties to store immutable values\n\nTo provide a view with data that the view doesn\u2019t modify, declare a standard Swift property. For example, you can extend the podcast player to have an input structure that contains strings for the episode title and the show name:\n\nstruct PlayerView: View {\n    let episode: Episode // The queued episode.\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        VStack {\n            // Display information about the episode.\n            Text(episode.title)\n            Text(episode.showTitle)\n\n\n            Button(action: {\n                self.isPlaying.toggle()\n            }) {\n                Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n            }\n        }\n    }\n}\n\n\nWhile the value of the episode property is a constant for PlayerView, it doesn\u2019t need to be constant in this view\u2019s parent view. When the user selects a different episode in the parent, SwiftUI detects the state change and recreates the PlayerView with a new input.\n\nShare access to state with bindings\n\nIf a view needs to share control of state with a child view, declare a property in the child with the Binding property wrapper. A binding represents a reference to existing storage, preserving a single source of truth for the underlying data. For example, if you refactor the podcast player view\u2019s button into a child view called PlayButton, you can give it a binding to the isPlaying property:\n\nstruct PlayButton: View {\n    @Binding var isPlaying: Bool\n    \n    var body: some View {\n        Button(action: {\n            self.isPlaying.toggle()\n        }) {\n            Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n        }\n    }\n}\n\n\nAs shown above, you read and write the binding\u2019s wrapped value by referring directly to the property, just like state. But unlike a state property, the binding doesn\u2019t have its own storage. Instead, it references a state property stored somewhere else, and provides a two-way connection to that storage.\n\nWhen you instantiate PlayButton, provide a binding to the corresponding state variable declared in the parent view by prefixing it with the dollar sign ($):\n\nstruct PlayerView: View {\n    var episode: Episode\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        VStack {\n            Text(episode.title)\n            Text(episode.showTitle)\n            PlayButton(isPlaying: $isPlaying) // Pass a binding.\n        }\n    }\n}\n\n\nThe $ prefix asks a wrapped property for its projectedValue, which for state is a binding to the underlying storage. Similarly, you can get a binding from a binding using the $ prefix, allowing you to pass a binding through an arbitrary number of levels of view hierarchy.\n\nYou can also get a binding to a scoped value within a state variable. For example, if you declare episode as a state variable in the player\u2019s parent view, and the episode structure also contains an isFavorite Boolean that you want to control with a toggle, then you can refer to $episode.isFavorite to get a binding to the episode\u2019s favorite status:\n\nstruct Podcaster: View {\n    @State private var episode = Episode(title: \"Some Episode\",\n                                         showTitle: \"Great Show\",\n                                         isFavorite: false)\n    var body: some View {\n        VStack {\n            Toggle(\"Favorite\", isOn: $episode.isFavorite) // Bind to the Boolean.\n            PlayerView(episode: episode)\n        }\n    }\n}\n\nAnimate state transitions\n\nWhen the view state changes, SwiftUI updates affected views right away. If you want to smooth visual transitions, you can tell SwiftUI to animate them by wrapping the state change that triggers them in a call to the withAnimation(_:_:) function. For example, you can animate changes controlled by the isPlaying Boolean:\n\nwithAnimation(.easeInOut(duration: 1)) {\n    self.isPlaying.toggle()\n}\n\n\nBy changing isPlaying inside the animation function\u2019s trailing closure, you tell SwiftUI to animate anything that depends on the wrapped value, like a scale effect on the button\u2019s image:\n\nImage(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n    .scaleEffect(isPlaying ? 1 : 1.5)\n\n\nSwiftUI transitions the scale effect input over time between the given values of 1 and 1.5, using the curve and duration that you specify, or reasonable default values if you provide none. On the other hand, the image content isn\u2019t affected by the animation, even though the same Boolean dictates which system image to display. That\u2019s because SwiftUI can\u2019t incrementally transition in a meaningful way between the two strings pause.circle and play.circle.\n\nYou can add animation to a state property, or as in the above example, to a binding. Either way, SwiftUI animates any view changes that happen when the underlying stored value changes. For example, if you add a background color to the PlayerView \u2014\u00a0at a level of view hierarchy above the location of the animation block \u2014 SwiftUI animates that as well:\n\nVStack {\n    Text(episode.title)\n    Text(episode.showTitle)\n    PlayButton(isPlaying: $isPlaying)\n}\n.background(isPlaying ? Color.green : Color.red) // Transitions with animation.\n\n\nWhen you want to apply animations to specific views, rather than across all views triggered by a change in state, use the animation(_:value:) view modifier instead.\n\nSee Also\nCreating and sharing view state\nstruct State\nA property wrapper type that can read and write a value managed by SwiftUI.\nstruct Bindable\nA property wrapper type that supports creating bindings to the mutable properties of observable objects.\nstruct Binding\nA property wrapper type that can read and write a value owned by a source of truth."
    },
    {
        "title": "widgetAccentable(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/widgetaccentable(_:)",
        "html": "Parameters\naccentable\n\nA Boolean value that indicates whether to add the view and its subviews to the accented group.\n\nDiscussion\n\nWhen the system renders the widget using the WidgetKit/WidgetRenderingMode/accented mode, it divides the widget\u2019s view hierarchy into two groups: the accented group and the default group. It then applies a different color to each group.\n\nWhen applying the colors, the system treats the widget\u2019s views as if they were template images. It ignores the view\u2019s color \u2014 rendering the new colors based on the view\u2019s alpha channel.\n\nTo control your view\u2019s appearance, add the widgetAccentable(_:) modifier to part of your view\u2019s hierarchy. If the accentable parameter is true, the system adds that view and all of its subviews to the accent group. It puts all other views in the default group.\n\nvar body: some View {\n    VStack {\n        Text(\"MON\")\n            .font(.caption)\n            .widgetAccentable()\n        Text(\"6\")\n            .font(.title)\n        }\n    }\n}\n\n\nImportant\n\nAfter you call widgetAccentable(true) on a view moving it into the accented group, calling widgetAccentable(false) on its subviews doesn\u2019t move the subviews back into the default group."
    },
    {
        "title": "widgetLabel(label:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/widgetlabel(label:)",
        "html": "Parameters\nlabel\n\nA view that WidgetKit can display alongside the accessory family widget\u2019s main SwiftUI view. You can use a Image, Text, Gauge, ProgressView, or a container with multiple subviews.\n\nDiscussion\n\nThe system only displays labels on widget-based complications in watchOS. The system ignores any labels attached to widgets on the Lock Screen on iPhone. Therefore, you can use the same code to display an accessory family widget on both iPhone and Apple Watch.\n\nTo create the widget label, call widgetLabel(label:)on a complication\u2019s main SwiftUI view. Pass the desired content as the label parameter. The label can be a Gauge, ProgressView, Text, or Image. To provide multiple views, wrap your views in a container, such as a VStack. WidgetKit determines whether it can use any of the label\u2019s content. If it can\u2019t, it ignores the label.\n\n\n\n  struct Complication: View {\n      @Environment(\\.widgetFamily) var widgetFamily\n\n\n      var body: some View {\n          switch widgetFamily {\n          case .accessoryCorner:\n              Text(\"Hi\")\n                  .widgetLabel {\n                      Gauge(value: 0.8)\n                  }\n          case .accessoryCircular:\n              VStack {\n                  Image(systemName: \"emoji.globe\")\n                  Text(\"Hi\")\n              }\n              .widgetLabel(\"World!\")\n          case .accessoryInline:\n              Text(\"\\(Image(systemName: \"emoji.globe.face\")) World!\")\n      }\n  }\n\n\n\n\nWidgetKit configures the label so that the watch face presents a unified look. For example, it sets the size for an image, the font for text, and can even render text and gauges along a curve.\n\nThe following widget families support widget labels:\n\nWidgetKit/WidgetFamily/accessoryCorner\n\nIn watchOS, this widget-based complication can display a Gauge, a ProgressView, or a Text. Adding a label to an accessory corner causes the main SwiftUI view to shrink to make space for the label. If you pass a view containing multiple, valid subviews, the system picks which view to display as the widget label.\n\nWidgetKit/WidgetFamily/accessoryCircular\n\nIn watchOS, the widget-based complication can display either an Image or a Text. To pass both an image and text, wrap those views in a container.\n\nHowever, WidgetKit only renders the label along the bezel on the Infograph watch face (the top circular complication). On all other circular complications \u2014 including widgets on all other platforms \u2014 WidgetKit ignores the label.\n\nSee Also\nLabeling a widget\nfunc widgetLabel<S>(S) -> some View\nReturns a text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view.\nfunc widgetLabel(LocalizedStringKey) -> some View\nReturns a localized text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view."
    },
    {
        "title": "EmptyWidgetConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/emptywidgetconfiguration",
        "html": "Topics\nCreating a configuration\ninit()\nRelationships\nConforms To\nSendable\nWidgetConfiguration\nSee Also\nCreating widgets\nprotocol Widget\nThe configuration and content of a widget to display on the Home screen or in Notification Center.\nprotocol WidgetBundle\nA container used to expose multiple widgets from a single widget extension.\nstruct LimitedAvailabilityConfiguration\nA type-erased widget configuration.\nprotocol WidgetConfiguration\nA type that describes a widget\u2019s content."
    },
    {
        "title": "widgetLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/widgetlabel(_:)-8m5o1",
        "html": "Parameters\nlabelKey\n\nA label generated from a localized string.\n\nDiscussion\n\nTo add a text label to an accessory family widget, call this method on the widget\u2019s main SwiftUI view, and pass in a supported LocalizedStringKey. The system determines whether it can use the text label. If it can\u2019t, it ignores the label. The system also sets the label\u2019s size, placement, and style based on the clock face. For example, setting the font and rendering the text along a curve.\n\nThe following widget families support text accessory labels:\n\nThe WidgetFamily.accessoryCorner widget-based complication can display a curved text label on the inside edge of the corner. Adding a label to an accessory corner complication causes the main SwiftUI view to shrink to make space for the label.\n\nThe WidgetFamily.accessoryCircular widget can display a text label in watchOS; however, WidgetKit only renders the label along the bezel on the Infograph watch face (the top circular complication).\n\nSee Also\nLabeling a widget\nfunc widgetLabel<S>(S) -> some View\nReturns a text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view.\nfunc widgetLabel<Label>(label: () -> Label) -> some View\nCreates a label for displaying additional content outside an accessory family widget\u2019s main SwiftUI view."
    },
    {
        "title": "WidgetConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/widgetconfiguration",
        "html": "Topics\nImplementing a widget\nvar body: Self.Body\nThe content and behavior of this widget.\n\nRequired\n\nassociatedtype Body : WidgetConfiguration\nThe type of widget configuration representing the body of this configuration.\n\nRequired\n\nSetting a name\nfunc configurationDisplayName<S>(S) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the specified string.\nfunc configurationDisplayName(Text) -> some WidgetConfiguration\nSets the name shown for a widget when a user adds or edits it using the contents of a text view.\nfunc configurationDisplayName(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized name shown for a widget when a user adds or edits the widget.\nSetting a description\nfunc description(Text) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the contents of a text view.\nfunc description<S>(S) -> some WidgetConfiguration\nSets the description shown for a widget when a user adds or edits it using the specified string.\nfunc description(LocalizedStringKey) -> some WidgetConfiguration\nSets the localized description shown for a widget when a user adds or edits the widget.\nSetting the appearance\nfunc supportedFamilies([WidgetFamily]) -> some WidgetConfiguration\nSets the sizes that a widget supports.\nfunc contentMarginsDisabled() -> some WidgetConfiguration\nDisable default content margins.\nfunc disfavoredLocations([WidgetLocation], for: [WidgetFamily]) -> some WidgetConfiguration\nSets the disfavored locations for a widget.\nfunc containerBackgroundRemovable(Bool) -> some WidgetConfiguration\nA modifier that marks the background of a widget as removable.\nManaging background tasks\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some WidgetConfiguration\nRuns the given action when the system provides a background task.\nfunc onBackgroundURLSessionEvents(matching: ((String) -> Bool)?, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session identified by a closure are waiting to be processed.\nfunc onBackgroundURLSessionEvents(matching: String, (String, () -> Void) -> Void) -> some WidgetConfiguration\nAdds an action to perform when events related to a URL session with a matching identifier are waiting to be processed.\nRelationships\nConforming Types\nEmptyWidgetConfiguration\nLimitedAvailabilityConfiguration\nSee Also\nCreating widgets\nprotocol Widget\nThe configuration and content of a widget to display on the Home screen or in Notification Center.\nprotocol WidgetBundle\nA container used to expose multiple widgets from a single widget extension.\nstruct LimitedAvailabilityConfiguration\nA type-erased widget configuration.\nstruct EmptyWidgetConfiguration\nAn empty widget configuration."
    },
    {
        "title": "OrnamentAttachmentAnchor",
        "url": "https://developer.apple.com/documentation/swiftui/ornamentattachmentanchor",
        "html": "Topics\nGetting an anchor\nstatic func scene(UnitPoint) -> OrnamentAttachmentAnchor\nThe anchor point for the ornament expressed as a unit point relative to the scene.\nRelationships\nConforms To\nSendable\nSee Also\nCreating an ornament\nfunc ornament<Content>(visibility: Visibility, attachmentAnchor: OrnamentAttachmentAnchor, contentAlignment: Alignment, ornament: () -> Content) -> some View\nPresents an ornament.\nBeta"
    },
    {
        "title": "widgetLabel(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/widgetlabel(_:)-7wguh",
        "html": "Parameters\nlabel\n\nA string that contains the text which WidgetKit displays alongside the complication.\n\nDiscussion\n\nTo add a text label to an accessory family widget, call this method on the widget\u2019s main SwiftUI view, and pass in a supported LocalizedStringKey. The system determines whether it can use the text label. If it can\u2019t, it ignores the label. The system also sets the label\u2019s size, placement, and style. For example, setting the font and rendering the text along a curve.\n\nThe following widget families support text accessory labels:\n\nThe WidgetFamily.accessoryCorner widget-based complication can display a curved text label on the inside edge of the corner. Adding a label to an accessory corner complication causes the main SwiftUI view to shrink to make space for the label.\n\nThe WidgetFamily.accessoryCircular widget can display a text label in watchOS; however, WidgetKit only renders the label along the bezel on the Infograph watch face (the top circular complication).\n\nSee Also\nLabeling a widget\nfunc widgetLabel(LocalizedStringKey) -> some View\nReturns a localized text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view.\nfunc widgetLabel<Label>(label: () -> Label) -> some View\nCreates a label for displaying additional content outside an accessory family widget\u2019s main SwiftUI view."
    },
    {
        "title": "searchable(text:editableTokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:editabletokens:ispresented:placement:prompt:token:)-4r2b3",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\neditableTokens\n\nA collection of tokens to display and edit in the search field.\n\nisPresenting\n\nA Binding which controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "searchable(text:tokens:isPresented:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:tokens:ispresented:placement:prompt:token:)-2kr2g",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\ntokens\n\nA collection of tokens to display and edit in the search field.\n\nisPresenting\n\nA Binding that controls the presented state of search.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA string representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app. For information about presenting a search field programmatically, see Managing search interface activation.\n\nSee Also\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation."
    },
    {
        "title": "LimitedAvailabilityConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/limitedavailabilityconfiguration",
        "html": "Overview\n\nYou don\u2019t use this type directly. Instead SwiftUI creates this type on your behalf.\n\nRelationships\nConforms To\nWidgetConfiguration\nSee Also\nCreating widgets\nprotocol Widget\nThe configuration and content of a widget to display on the Home screen or in Notification Center.\nprotocol WidgetBundle\nA container used to expose multiple widgets from a single widget extension.\nprotocol WidgetConfiguration\nA type that describes a widget\u2019s content.\nstruct EmptyWidgetConfiguration\nAn empty widget configuration."
    },
    {
        "title": "InsettableShape",
        "url": "https://developer.apple.com/documentation/swiftui/insettableshape",
        "html": "Topics\nSetting the stroke border characteristics\nfunc strokeBorder<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeBorderShapeView<Self, S, EmptyView>\nReturns a view that is the result of filling the lineWidth-sized border (aka inner stroke) of self with content. This is equivalent to insetting self by lineWidth / 2 and stroking the resulting shape with lineWidth as the line-width.\nfunc strokeBorder<S>(S, lineWidth: CGFloat, antialiased: Bool) -> some View\nReturns a view that is the result of filling the lineWidth-sized border (aka inner stroke) of self with content. This is equivalent to insetting self by lineWidth / 2 and stroking the resulting shape with lineWidth as the line-width.\nfunc strokeBorder(lineWidth: CGFloat, antialiased: Bool) -> some View\nReturns a view that is the result of filling the lineWidth-sized border (aka inner stroke) of self with the foreground color. This is equivalent to insetting self by lineWidth / 2 and stroking the resulting shape with lineWidth as the line-width.\nfunc strokeBorder<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeBorderShapeView<Self, S, EmptyView>\nReturns a view that is the result of insetting self by style.lineWidth / 2, stroking the resulting shape with style, and then filling with content.\nfunc strokeBorder<S>(S, style: StrokeStyle, antialiased: Bool) -> some View\nReturns a view that is the result of insetting self by style.lineWidth / 2, stroking the resulting shape with style, and then filling with content.\nfunc strokeBorder(style: StrokeStyle, antialiased: Bool) -> some View\nReturns a view that is the result of insetting self by style.lineWidth / 2, stroking the resulting shape with style, and then filling with the foreground color.\nSetting the inset\nfunc inset(by: CGFloat) -> Self.InsetShape\nReturns self inset by amount.\n\nRequired\n\nassociatedtype InsetShape : InsettableShape\nThe type of the inset shape.\n\nRequired\n\nRelationships\nInherits From\nAnimatable\nSendable\nShape\nView\nConforming Types\nButtonBorderShape\nCapsule\nCircle\nContainerRelativeShape\nEllipse\nOffsetShape\nConforms when Content conforms to InsettableShape.\nRectangle\nRotatedShape\nConforms when Content conforms to InsettableShape.\nRoundedRectangle\nUnevenRoundedRectangle\nSee Also\nSetting a container shape\nfunc containerShape<T>(T) -> some View\nSets the container shape to use for any container relative shape within this view.\nstruct ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle."
    },
    {
        "title": "undoManager",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/undomanager",
        "html": "Discussion\n\nThis value is nil when the environment represents a context that doesn\u2019t support undo and redo operations. You can skip registration of an undo operation when this value is nil.\n\nSee Also\nStoring document data in a class instance\nprotocol ReferenceFileDocument\nA type that you use to serialize reference type documents to and from file.\nstruct ReferenceFileDocumentConfiguration\nThe properties of an open reference file document."
    },
    {
        "title": "ImmersiveSpace",
        "url": "https://developer.apple.com/documentation/swiftui/immersivespace",
        "html": "Overview\n\nUse an immersive space as a container for a view hierarchy that your app presents. The hierarchy that you declare as the immersive space\u2019s content serves as a template for it:\n\n@main\nstruct SolarSystemApp: App {\n    var body: some Scene {\n        ImmersiveSpace {\n            SolarSystem()\n        }\n    }\n}\n\n\nFor bounded scenes, use WindowGroup instead. For document-based apps, use a DocumentGroup instead. You can optionally define an immersive space to present data of a type that conforms to both Hashable and Codable.\n\nOpen an immersive space\n\nYou can initialize an immersive space with an identifier. For example, you can give the solar system view from the previous example an identifier:\n\nImmersiveSpace(id: \"solarSystem\") {\n    SolarSystem()\n}\n\n\nElsewhere in your code, you can use the openImmersiveSpace environment value to get the instance of this structure for a given Environment. You call the instance directly \u2014 for example, from a button\u2019s closure, like in the following code \u2014 because the action defines a callAsFunction(id:) method that Swift calls when you call the instance.\n\nstruct NewSolarSystemImmersiveSpace: View {\n    var solarSystem: SolarSystem\n    @Environment(\\.openImmersiveSpace) private var openImmersiveSpace\n\n\n    var body: some View {\n        Button(\"Present Solar System In New Immersive Space\") {\n            Task {\n                await openImmersiveSpace(id: \"solarSystem\")\n            }\n        }\n    }\n}\n\n\nWhen your app opens an immersive space, the system hides all other visible apps. SwiftUI only allows one immersive space to be open at a time. Be sure to close the open immersive space before opening another one.\n\nDismiss an immersive space\n\nYou can dismiss an immersive space by calling the dismissImmersiveSpace action. For example, you can define a button that dismisses an immersive space:\n\nstruct DismissImmersiveSpaceButton: View {\n    @Environment(\\.dismissImmersiveSpace)\n    private var dismissImmersiveSpace\n\n\n    var body: some View {\n        Button(\"Close Solar System Immersive Space\") {\n            Task {\n                await dismissImmersiveSpace()\n            }\n        }\n    }\n}\n\n\nYou don\u2019t need to specify an identifier when dismissing an immersive space because there can only be one immersive space open at a time.\n\nPresent an immersive space at launch\n\nWhen an app launches, it opens an instance of the first scene that\u2019s listed in the app\u2019s body. However, to open an immersive space at launch, you need to provide additional configuration information in your app\u2019s Info.plist file. In particular, set the UIApplicationPreferredDefaultSceneSessionRole key in the scene manifest to the value UISceneSessionRoleImmersiveSpaceApplication.\n\nTo configure the style of the immersive space that opens at launch, add a scene configuration to the scene session role. Use the UISceneInitialImmersionStyle key together with a value that indicates one of the mixed, full, or progressive styles. See the initial immersion style key for more information.\n\nTopics\nCreating a data-driven immersive space\ninit(for: Data.Type, content: (Binding<Data?>) -> Content)\nCreates the immersive space for a specified type of presented data.\ninit<V>(for: Data.Type, content: (Binding<Data?>) -> V)\nCreates the immersive space for a specified type of presented data using view-based content.\nAvailable when Content conforms to ImmersiveSpaceContent, Data conforms to Decodable, Data conforms to Encodable, and Data conforms to Hashable.\ninit(id: String, for: Data.Type, content: (Binding<Data?>) -> Content)\nCreates the immersive space associated with an identifier for a specified type of presented data.\ninit<V>(id: String, for: Data.Type, content: (Binding<Data?>) -> V)\nCreates the immersive space associated with an identifier for a specified type of presented data using view-based content.\nAvailable when Content conforms to ImmersiveSpaceContent, Data conforms to Decodable, Data conforms to Encodable, and Data conforms to Hashable.\nProviding default data to an immersive space\ninit(for: Data.Type, content: (Binding<Data>) -> Content, defaultValue: () -> Data)\nCreates an immersive space.\ninit<V>(for: Data.Type, content: (Binding<Data>) -> V, defaultValue: () -> Data)\nCreates an immersive space for a specified type of presented data and a default value if the data is not set.\nAvailable when Content conforms to ImmersiveSpaceContent, Data conforms to Decodable, Data conforms to Encodable, and Data conforms to Hashable.\ninit<V>(id: String, for: Data.Type, content: (Binding<Data>) -> V, defaultValue: () -> Data)\nCreates the immersive space associated with an identifier for a specified type of presented data and a default value if the data is not set.\nAvailable when Content conforms to ImmersiveSpaceContent, Data conforms to Decodable, Data conforms to Encodable, and Data conforms to Hashable.\ninit(id: String, for: Data.Type, content: (Binding<Data>) -> Content, defaultValue: () -> Data)\nCreates the immersive space associated with an identifier for a specified type of presented data, and a default value, if the data is not set.\nSupporting types\nstruct ImmersiveSpaceViewContent\nImmersive space content that uses a SwiftUI view hierarchy as the content.\nprotocol ImmersiveSpaceContent\nA type that you can use as the content of an immersive space.\nInitializers\ninit(content: () -> Content)\nCreates an immersive space.\ninit<V>(content: () -> V)\nCreates an immersive space using view-based content.\nAvailable when Content conforms to ImmersiveSpaceContent, Data conforms to Decodable, Data conforms to Encodable, and Data conforms to Hashable.\ninit<V>(id: String, content: () -> V)\nCreates the immersive space associated with the specified identifier using view-based content.\nAvailable when Content conforms to ImmersiveSpaceContent, Data conforms to Decodable, Data conforms to Encodable, and Data conforms to Hashable.\ninit(id: String, content: () -> Content)\nCreates the immersive space associated with the specified identifier.\nRelationships\nConforms To\nScene\nSee Also\nCreating an immersive space\nstruct ImmersiveSpaceContentBuilder\nA result builder for composing a collection of immersive space elements.\nBeta\nfunc immersionStyle(selection: Binding<ImmersionStyle>, in: ImmersionStyle...) -> some Scene\nSets the allowed styles for the immersive space.\nBeta\nprotocol ImmersionStyle\nThe styles that an immersive space can have.\nBeta"
    },
    {
        "title": "dismissWindow",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/dismisswindow",
        "html": "Discussion\n\nUse the dismissWindow environment value to get an DismissWindowAction instance for a given Environment. Then call the instance to dismiss a window. You call the instance directly because it defines a callAsFunction(id:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that dismisses an auxiliary window:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        #if os(macOS)\n        Window(\"Auxiliary\", id: \"auxiliary\") {\n            AuxiliaryContentView()\n        }\n        #endif\n    }\n}\n\n\nstruct DismissWindowButton: View {\n    @Environment(\\.dismissWindow) private var dismissWindow\n\n\n    var body: some View {\n        Button(\"Close Auxiliary Window\") {\n            dismissWindow(id: \"auxiliary\")\n        }\n    }\n}\n\nSee Also\nClosing windows\nstruct DismissWindowAction\nAn action that dismisses a window associated to a particular scene.\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nstruct DismissAction\nAn action that dismisses a presentation.\nstruct DismissBehavior\nProgrammatic window dismissal behaviors."
    },
    {
        "title": "supportsMultipleWindows",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/supportsmultiplewindows",
        "html": "Discussion\n\nRead this property from the environment to determine if your app can use the openWindow action to open new windows:\n\nstruct NewMailViewerButton: View {\n    @Environment(\\.supportsMultipleWindows) private var supportsMultipleWindows\n    @Environment(\\.openWindow) private var openWindow\n\n\n    var body: some View {\n        Button(\"Open New Window\") {\n            openWindow(id: \"mail-viewer\")\n        }\n        .disabled(!supportsMultipleWindows)\n    }\n}\n\n\nThe reported value depends on both the platform and how you configure your app:\n\nIn macOS, this property returns true for any app that uses the SwiftUI app lifecycle.\n\nIn iPadOS, this property returns true for any app that uses the SwiftUI app lifecycle and has the Information Property List key UIApplicationSupportsMultipleScenes set to true.\n\nFor all other platforms and configurations, the value returns false.\n\nIf the value is false and you try to open a window, SwiftUI ignores the action and logs a runtime error.\n\nSee Also\nOpening windows\nvar openWindow: OpenWindowAction\nA window presentation action stored in a view\u2019s environment.\nstruct OpenWindowAction\nAn action that presents a window."
    },
    {
        "title": "full",
        "url": "https://developer.apple.com/documentation/swiftui/immersionstyle/full",
        "html": "See Also\nGetting built-in styles\nstatic var automatic: AutomaticImmersionStyle\nThe default immersion style.\nAvailable when Self is AutomaticImmersionStyle.\nBeta\nstatic var mixed: MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nAvailable when Self is MixedImmersionStyle.\nBeta\nstatic var progressive: ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nAvailable when Self is ProgressiveImmersionStyle.\nBeta"
    },
    {
        "title": "immersionStyle(selection:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/immersionstyle(selection:in:)",
        "html": "Parameters\nselection\n\nA binding to the effective style used by the space.\n\nstyles\n\nThe list of styles that the immersive space allows.\n\nSee Also\nCreating an immersive space\nstruct ImmersiveSpace\nA scene that presents its content in an unbounded space.\nBeta\nstruct ImmersiveSpaceContentBuilder\nA result builder for composing a collection of immersive space elements.\nBeta\nprotocol ImmersionStyle\nThe styles that an immersive space can have.\nBeta"
    },
    {
        "title": "toolbarTitleMenu(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbartitlemenu(content:)",
        "html": "Parameters\ncontent\n\nThe content associated to the toolbar title menu.\n\nDiscussion\n\nA title menu represent common functionality that can be done on the content represented by your app\u2019s toolbar or navigation title. This menu may be populated from your app\u2019s commands like saveItem or printItem.\n\nContentView()\n    .toolbar {\n        ToolbarTitleMenu()\n    }\n\n\nYou can provide your own set of actions to override this behavior.\n\nContentView()\n    .toolbarTitleMenu {\n        DuplicateButton()\n        PrintButton()\n    }\n\n\nIn iOS and iPadOS, this will construct a menu that can be presented by tapping the navigation title in the app\u2019s navigation bar.\n\nSee Also\nSetting the toolbar title menu\nstruct ToolbarTitleMenu\nThe title menu of a toolbar."
    },
    {
        "title": "ToolbarTitleDisplayMode",
        "url": "https://developer.apple.com/documentation/swiftui/toolbartitledisplaymode",
        "html": "Overview\n\nUse the toolbarTitleDisplayMode(_:) modifier to configure the title display behavior of your toolbar:\n\nNavigationStack {\n    ContentView()\n        .toolbarTitleDisplayMode(.inlineLarge)\n}\n\nTopics\nGetting display modes\nstatic var automatic: ToolbarTitleDisplayMode\nThe automatic mode.\nstatic var inline: ToolbarTitleDisplayMode\nThe inline mode.\nstatic var inlineLarge: ToolbarTitleDisplayMode\nThe inline large mode.\nstatic var large: ToolbarTitleDisplayMode\nThe large mode.\nSee Also\nConfiguring the toolbar title display mode\nfunc toolbarTitleDisplayMode(ToolbarTitleDisplayMode) -> some View\nConfigures the toolbar title display mode for this view."
    },
    {
        "title": "ToolbarTitleMenu",
        "url": "https://developer.apple.com/documentation/swiftui/toolbartitlemenu",
        "html": "Overview\n\nA title menu represents common functionality that can be done on the content represented by your app\u2019s toolbar or navigation title. This menu may be populated from your app\u2019s commands like saveItem or printItem.\n\nContentView()\n    .toolbar {\n        ToolbarTitleMenu()\n    }\n\n\nYou can provide your own set of actions to override this behavior.\n\nContentView()\n    .toolbar {\n        ToolbarTitleMenu {\n            DuplicateButton()\n            PrintButton()\n        }\n    }\n\n\nIn iOS and iPadOS, this will construct a menu that can be presented by tapping the navigation title in the app\u2019s navigation bar.\n\nTopics\nCreating a toolbar title menu\ninit()\nCreates a toolbar title menu where actions are inferred from your apps commands.\ninit(content: () -> Content)\nCreates a toolbar title menu.\nRelationships\nConforms To\nCustomizableToolbarContent\nToolbarContent\nSee Also\nSetting the toolbar title menu\nfunc toolbarTitleMenu<C>(content: () -> C) -> some View\nConfigure the title menu of a toolbar."
    },
    {
        "title": "toolbarBackground(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbarbackground(_:for:)-7lv0f",
        "html": "Parameters\nvisibility\n\nThe preferred visibility of the background of the bar.\n\nbars\n\nThe bars to update the color scheme of or automatic if empty.\n\nDiscussion\n\nThe preferred visibility flows up to the nearest container that renders a bar. This could be a NavigationView or TabView in iOS, or the root view of a WindowGroup in macOS.\n\nIn iOS, a value of automatic makes the visibility of a tab bar or navigation bar background depend on where a List or ScrollView settles. For example, when aligned to the bottom edge of of a scroll view\u2019s content, the background of a tab bar becomes transparent.\n\nSpecify a value of Visibility.visible to ensure that the background of a bar remains visible regardless of where any scroll view or list stops scrolling.\n\nThis example shows a view that prefers to always have the tab bar visible when the middle tab is selected:\n\nTabView {\n    FirstTab()\n    MiddleTab()\n        .toolbarBackground(.visible, for: .tabBar)\n    LastTab()\n}\n\n\nYou can provide multiple placements to customize multiple bars at once, as in the following example:\n\nTabView {\n    NavigationView {\n        ContentView()\n            .toolbarBackground(\n                .visible, for: .navigationBar, .tabBar)\n    }\n}\n\nSee Also\nStyling a toolbar\nfunc toolbarBackground<S>(S, for: ToolbarPlacement...) -> some View\nSpecifies the preferred shape style of the background of a bar managed by SwiftUI.\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> some View\nSpecifies the preferred color scheme of a bar managed by SwiftUI.\nfunc windowToolbarStyle<S>(S) -> some Scene\nSets the style for the toolbar defined within this scene.\nprotocol WindowToolbarStyle\nA specification for the appearance and behavior of a window\u2019s toolbar."
    },
    {
        "title": "toolbarBackground(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbarbackground(_:for:)-5ybst",
        "html": "Parameters\nstyle\n\nThe style to display as the background of the bar.\n\nbars\n\nThe bars to use the style for or automatic if empty.\n\nDiscussion\n\nThe preferred style flows up to the nearest container that renders a bar. This could be a NavigationView or TabView in iOS, or the root view of a WindowGroup in macOS. This example shows a view that renders the navigation bar with a blue background and dark color scheme.\n\nNavigationView {\n    ContentView()\n        .toolbarBackground(.white)\n        .toolbarColorScheme(.dark)\n}\n\n\nYou can provide multiple ToolbarPlacement instances to customize multiple bars at once.\n\nTabView {\n    NavigationView {\n        ContentView()\n            .toolbarBackground(\n                .blue, for: .navigationBar, .tabBar)\n            .toolbarColorScheme(\n                .dark, for: .navigationBar, .tabBar)\n    }\n}\n\n\nWhen used within a TabView, the specified style will be preferred while the tab is currently active. You can use a Group to specify the same preferred background for every tab.\n\nTabView {\n    Group {\n        MainView()\n        SettingsView()\n    }\n    .toolbarBackground(.blue, for: .tabBar)\n}\n\n\nDepending on the specified bars, the requested style may not be able to be fullfilled.\n\nSee Also\nStyling a toolbar\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the preferred visibility of backgrounds on a bar managed by SwiftUI.\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> some View\nSpecifies the preferred color scheme of a bar managed by SwiftUI.\nfunc windowToolbarStyle<S>(S) -> some Scene\nSets the style for the toolbar defined within this scene.\nprotocol WindowToolbarStyle\nA specification for the appearance and behavior of a window\u2019s toolbar."
    },
    {
        "title": "toolbarTitleDisplayMode(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbartitledisplaymode(_:)",
        "html": "Discussion\n\nUse this modifier to override the default toolbar title display mode.\n\nNavigationStack {\n    ContentView()\n        .toolbarTitleDisplayMode(.inlineLarge)\n}\n\n\nSee ToolbarTitleDisplayMode for more information on the different kinds of display modes. This modifier has no effect on macOS.\n\nSee Also\nConfiguring the toolbar title display mode\nstruct ToolbarTitleDisplayMode\nA type that defines the behavior of title of a toolbar."
    },
    {
        "title": "toolbarColorScheme(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbarcolorscheme(_:for:)",
        "html": "Parameters\ncolorScheme\n\nThe preferred color scheme of the background of the bar.\n\nbars\n\nThe bars to update the color scheme of or automatic if empty.\n\nDiscussion\n\nThe preferred color scheme flows up to the nearest container that renders a bar. This could be a NavigationView or TabView in iOS, or the root view of a WindowGroup in macOS. Pass in a value of nil to match the current system\u2019s color scheme.\n\nThis examples shows a view that renders the navigation bar with a blue background and dark color scheme:\n\nTabView {\n    NavigationView {\n        ContentView()\n            .toolbarBackground(.blue)\n            .toolbarColorScheme(.dark)\n    }\n    // other tabs...\n}\n\n\nYou can provide multiple ToolbarPlacement instances to customize multiple bars at once.\n\nTabView {\n    NavigationView {\n        ContentView()\n            .toolbarBackground(\n                .blue, for: .navigationBar, .tabBar)\n            .toolbarColorScheme(\n                .dark, for: .navigationBar, .tabBar)\n    }\n}\n\n\nNote that the provided color scheme is only respected while a background is visible in the requested bar. As the background becomes visible, the bar transitions from the color scheme of the app to the requested color scheme. You can ensure that the color scheme is always respected by specifying that the background of the bar always be visible.\n\nNavigationView {\n    ContentView()\n        .toolbarBackground(.visible)\n        .toolbarColorScheme(.dark)\n}\n\n\nDepending on the specified bars, the requested color scheme may not be able to be fullfilled.\n\nSee Also\nStyling a toolbar\nfunc toolbarBackground<S>(S, for: ToolbarPlacement...) -> some View\nSpecifies the preferred shape style of the background of a bar managed by SwiftUI.\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the preferred visibility of backgrounds on a bar managed by SwiftUI.\nfunc windowToolbarStyle<S>(S) -> some Scene\nSets the style for the toolbar defined within this scene.\nprotocol WindowToolbarStyle\nA specification for the appearance and behavior of a window\u2019s toolbar."
    },
    {
        "title": "ToolbarRole",
        "url": "https://developer.apple.com/documentation/swiftui/toolbarrole",
        "html": "Overview\n\nA toolbar role provides a description of the purpose of content that populates the toolbar. The purpose of the content influences how a toolbar renders its content. For example, a browser will automatically leading align the title of a toolbar in iPadOS.\n\nProvide this type to the toolbarRole(_:) modifier:\n\nContentView()\n    .navigationTitle(\"Browser\")\n    .toolbarRole(.browser)\n    .toolbar {\n        ToolbarItem(placement: .primaryAction) {\n            AddButton()\n        }\n     }\n\nTopics\nBehavior-specific roles\nstatic var browser: ToolbarRole\nThe browser role.\nstatic var editor: ToolbarRole\nThe editor role.\nstatic var navigationStack: ToolbarRole\nThe navigationStack role.\nAutomatic roles\nstatic var automatic: ToolbarRole\nThe automatic role.\nRelationships\nConforms To\nSendable\nSee Also\nSpecifying the role of toolbar content\nfunc toolbarRole(ToolbarRole) -> some View\nConfigures the semantic role for the content populating the toolbar."
    },
    {
        "title": "ToolbarPlacement",
        "url": "https://developer.apple.com/documentation/swiftui/toolbarplacement",
        "html": "Overview\n\nUse this type in conjunction with modifiers like toolbarBackground(_:for:) and toolbar(_:for:) to customize the appearance of different bars managed by SwiftUI. Not all bars support all types of customizations.\n\nSee ToolbarItemPlacement to learn about the different regions of these toolbars that you can place your own controls into.\n\nTopics\nGetting placements\nstatic var automatic: ToolbarPlacement\nThe primary toolbar.\nstatic func accessoryBar<ID>(id: ID) -> ToolbarPlacement\nCreates a unique accessory bar placement.\nstatic var bottomBar: ToolbarPlacement\nThe bottom toolbar of an app.\nstatic var bottomOrnament: ToolbarPlacement\nThe bottom ornament of an app.\nBeta\nstatic var navigationBar: ToolbarPlacement\nThe navigation bar of an app.\nstatic var tabBar: ToolbarPlacement\nThe tab bar of an app.\nstatic var windowToolbar: ToolbarPlacement\nThe window toolbar of an app.\nDeprecated symbols\ninit<ID>(id: ID)\nCreates a custom accessory bar placement.\nDeprecated\nSee Also\nSetting toolbar visibility\nfunc toolbar(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the visibility of a bar managed by SwiftUI."
    },
    {
        "title": "toolbar(removing:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbar(removing:)",
        "html": "Parameters\ndefaultItemKind\n\nThe kind of default item to remove\n\nDiscussion\n\nUse this modifier to remove toolbar items other Views add by default. For example, to remove the sidebar toggle toolbar item provided by NavigationSplitView:\n\nNavigationSplitView {\n    SidebarView()\n        .toolbar(removing: .sidebarToggle)\n} detail: {\n    DetailView()\n}\n\nSee Also\nRemoving default items\nstruct ToolbarDefaultItemKind\nA kind of toolbar item a View adds by default."
    },
    {
        "title": "ToolbarContentBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/toolbarcontentbuilder",
        "html": "Topics\nBuilding toolbar content\nstatic func buildBlock<Content>(Content) -> some ToolbarContent\nstatic func buildBlock<C0, C1>(C0, C1) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some ToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some ToolbarContent\nBuilding customizable toolbar content\nstatic func buildBlock<Content>(Content) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1>(C0, C1) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some CustomizableToolbarContent\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some CustomizableToolbarContent\nBuilding conditional toolbar content\nstatic func buildIf<Content>(Content?) -> Content?\nstatic func buildIf<Content>(Content?) -> Content?\nstatic func buildEither<TrueContent, FalseContent>(first: TrueContent) -> _ConditionalContent<TrueContent, FalseContent>\nstatic func buildEither<TrueContent, FalseContent>(first: TrueContent) -> _ConditionalContent<TrueContent, FalseContent>\nstatic func buildEither<TrueContent, FalseContent>(second: FalseContent) -> _ConditionalContent<TrueContent, FalseContent>\nstatic func buildEither<TrueContent, FalseContent>(second: FalseContent) -> _ConditionalContent<TrueContent, FalseContent>\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability<Content>(Content) -> some ToolbarContent\nstatic func buildLimitedAvailability<Content>(Content) -> some CustomizableToolbarContent\nSee Also\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nstruct ToolbarItem\nA model that represents an item which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemGroup\nA model that represents a group of ToolbarItems which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemPlacement\nA structure that defines the placement of a toolbar item.\nprotocol ToolbarContent\nConforming types represent items that can be placed in various locations in a toolbar."
    },
    {
        "title": "ToolbarItemPlacement",
        "url": "https://developer.apple.com/documentation/swiftui/toolbaritemplacement",
        "html": "Overview\n\nThere are two types of placements:\n\nSemantic placements, such as principal and navigation, denote the intent of the item being added. SwiftUI determines the appropriate placement for the item based on this intent and its surrounding context, like the current platform.\n\nPositional placements, such as navigationBarLeading, denote a precise placement for the item, usually for a particular platform.\n\nIn iOS, iPadOS, and macOS, the system uses the space available to the toolbar when determining how many items to render in the toolbar. If not all items fit in the available space, an overflow menu may be created and remaining items placed in that menu.\n\nTopics\nGetting semantic placement\nstatic let automatic: ToolbarItemPlacement\nThe system places the item automatically, depending on many factors including the platform, size class, or presence of other items.\nstatic let principal: ToolbarItemPlacement\nThe system places the item in the principal item section.\nstatic let status: ToolbarItemPlacement\nThe item represents a change in status for the current context.\nGetting placement for specific actions\nstatic let primaryAction: ToolbarItemPlacement\nThe item represents a primary action.\nstatic let secondaryAction: ToolbarItemPlacement\nThe item represents a secondary action.\nstatic let confirmationAction: ToolbarItemPlacement\nThe item represents a confirmation action for a modal interface.\nstatic let cancellationAction: ToolbarItemPlacement\nThe item represents a cancellation action for a modal interface.\nstatic let destructiveAction: ToolbarItemPlacement\nThe item represents a destructive action for a modal interface.\nstatic let navigation: ToolbarItemPlacement\nThe item represents a navigation action.\nGetting explicit placement\nstatic var topBarLeading: ToolbarItemPlacement\nPlaces the item in the leading edge of the top bar.\nstatic var topBarTrailing: ToolbarItemPlacement\nPlaces the item in the trailing edge of the top bar.\nstatic let bottomBar: ToolbarItemPlacement\nPlaces the item in the bottom toolbar.\nstatic let bottomOrnament: ToolbarItemPlacement\nPlaces the item in an ornament under the window.\nBeta\nstatic let keyboard: ToolbarItemPlacement\nThe item is placed in the keyboard section.\nstatic func accessoryBar<ID>(id: ID) -> ToolbarItemPlacement\nCreates a unique accessory bar placement.\nDeprecated symbols\ninit<ID>(id: ID)\nCreates a custom accessory bar item placement.\nDeprecated\nstatic let navigationBarLeading: ToolbarItemPlacement\nPlaces the item in the leading edge of the navigation bar.\nDeprecated\nstatic let navigationBarTrailing: ToolbarItemPlacement\nPlaces the item in the trailing edge of the navigation bar.\nDeprecated\nSee Also\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nstruct ToolbarItem\nA model that represents an item which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemGroup\nA model that represents a group of ToolbarItems which can be placed in the toolbar or navigation bar.\nprotocol ToolbarContent\nConforming types represent items that can be placed in various locations in a toolbar.\nstruct ToolbarContentBuilder\nConstructs a toolbar item set from multi-expression closures."
    },
    {
        "title": "toolbar(id:content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbar(id:content:)",
        "html": "Parameters\nid\n\nA unique identifier for this toolbar.\n\ncontent\n\nThe content representing the content of the toolbar.\n\nDiscussion\n\nUse this modifier when you want to allow the user to customize the components and layout of elements in the toolbar. The toolbar modifier expects a collection of toolbar items which you can provide either by supplying a collection of views with each view wrapped in a ToolbarItem.\n\nNote\n\nCustomizable toolbars will be displayed on both macOS and iOS, but only apps running on iPadOS 16.0 and later will support user customization.\n\nThe example below creates a view that represents each ToolbarItem along with an ID that uniquely identifies the toolbar item to the customization editor:\n\nstruct ToolsEditorView: View {\n    @State private var text = \"\"\n    @State private var bold = false\n    @State private var italic = false\n    @State private var fontSize = 12.0\n\n\n    var displayFont: Font {\n        let font = Font.system(\n           size: CGFloat(fontSize),\n             weight: bold == true ? .bold : .regular)\n        return italic == true ? font.italic() : font\n    }\n\n\n    var body: some View {\n        TextEditor(text: $text)\n            .font(displayFont)\n            .toolbar(id: \"editingtools\") {\n                ToolbarItem(\n                    id: \"sizeSelector\", placement: .secondaryAction\n                ) {\n                    Slider(\n                        value: $fontSize,\n                        in: 8...120,\n                        minimumValueLabel:\n                            Text(\"A\").font(.system(size: 8)),\n                        maximumValueLabel:\n                            Text(\"A\").font(.system(size: 16))\n                    ) {\n                        Text(\"Font Size (\\(Int(fontSize)))\")\n                    }\n                    .frame(width: 150)\n                }\n                ToolbarItem(\n                    id: \"bold\", placement: .secondaryAction\n                ) {\n                    Toggle(isOn: $bold) {\n                        Image(systemName: \"bold\")\n                    }\n                }\n                ToolbarItem(\n                    id: \"italic\", placement: .secondaryAction\n                ) {\n                    Toggle(isOn: $italic) {\n                        Image(systemName: \"italic\")\n                    }\n                }\n            }\n            .navigationTitle(\"My Note\")\n    }\n}\n\n\nNote\n\nOnly secondaryAction items support customization in iPadOS. Other items follow the normal placement rules and can\u2019t be customized by the user.\n\nIn macOS you can enable menu support for toolbar customization by adding a ToolbarCommands instance to a scene using the commands(content:) scene modifier:\n\n@main\nstruct ToolbarContent_macOSApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ToolsEditorView()\n                .frame(maxWidth: .infinity, maxHeight: .infinity)\n        }\n        .commands {\n            ToolbarCommands()\n        }\n    }\n}\n\n\nWhen you add the toolbar commands, the system adds a menu item to your app\u2019s main menu to provide toolbar customization support. This is in addition to the ability to Control-click on the toolbar to open the toolbar customization editor.\n\nSee Also\nPopulating a customizable toolbar\nprotocol CustomizableToolbarContent\nConforming types represent items that can be placed in various locations in a customizable toolbar.\nstruct ToolbarCustomizationBehavior\nThe customization behavior of customizable toolbar content.\nstruct ToolbarCustomizationOptions\nOptions that influence the default customization behavior of customizable toolbar content."
    },
    {
        "title": "ToolbarContent",
        "url": "https://developer.apple.com/documentation/swiftui/toolbarcontent",
        "html": "Topics\nImplementing toolbar content\nvar body: Self.Body\nThe composition of content that comprise the toolbar content.\n\nRequired\n\nassociatedtype Body : ToolbarContent\nThe type of content representing the body of this toolbar content.\n\nRequired\n\nRelationships\nInherited By\nCustomizableToolbarContent\nConforming Types\nGroup\nConforms when Content conforms to CustomizableToolbarContent.\nToolbarItem\nConforms when ID is String and Content conforms to View.\nToolbarItemGroup\nToolbarTitleMenu\nSee Also\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nstruct ToolbarItem\nA model that represents an item which can be placed in the toolbar or navigation bar.\nAvailable when ID is String and Content conforms to View.\nstruct ToolbarItemGroup\nA model that represents a group of ToolbarItems which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemPlacement\nA structure that defines the placement of a toolbar item.\nstruct ToolbarContentBuilder\nConstructs a toolbar item set from multi-expression closures."
    },
    {
        "title": "RenameAction",
        "url": "https://developer.apple.com/documentation/swiftui/renameaction",
        "html": "Overview\n\nUse the renameAction(_:) modifier to configure the rename action in the environment.\n\nTopics\nCalling the action\nfunc callAsFunction()\nTriggers the standard rename action provided through the environment.\nSee Also\nRenaming a document\nstruct RenameButton\nA button that triggers a standard rename action.\nfunc renameAction(FocusState<Bool>.Binding) -> some View\nSets the rename action in the environment to update focus state.\nfunc renameAction(() -> Void) -> some View\nSets a closure to run for the rename action.\nvar rename: RenameAction?\nAn action that activates the standard rename interaction."
    },
    {
        "title": "ToolbarItem",
        "url": "https://developer.apple.com/documentation/swiftui/toolbaritem",
        "html": "Topics\nCreating a toolbar item\ninit(placement: ToolbarItemPlacement, content: () -> Content)\nCreates a toolbar item with the specified placement and content.\nAvailable when ID is () and Content conforms to View.\ninit(id: String, placement: ToolbarItemPlacement, content: () -> Content)\nCreates a toolbar item with the specified placement and content, which allows for user customization.\nAvailable when ID is String and Content conforms to View.\ninit(id: String, placement: ToolbarItemPlacement, showsByDefault: Bool, content: () -> Content)\nCreates a toolbar item with the specified placement and content, which allows for user customization.\nAvailable when ID is String and Content conforms to View.\nRelationships\nConforms To\nCustomizableToolbarContent\nConforms when ID is String and Content conforms to View.\nIdentifiable\nToolbarContent\nConforms when ID is String and Content conforms to View.\nSee Also\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nstruct ToolbarItemGroup\nA model that represents a group of ToolbarItems which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemPlacement\nA structure that defines the placement of a toolbar item.\nprotocol ToolbarContent\nConforming types represent items that can be placed in various locations in a toolbar.\nAvailable when ID is String and Content conforms to View.\nstruct ToolbarContentBuilder\nConstructs a toolbar item set from multi-expression closures."
    },
    {
        "title": "RenameButton",
        "url": "https://developer.apple.com/documentation/swiftui/renamebutton",
        "html": "Overview\n\nA rename button receives its action from the environment. Use the renameAction(_:) modifier to set the action. The system disables the button if you don\u2019t define an action.\n\nstruct RowView: View {\n    @State private var text = \"\"\n    @FocusState private var isFocused: Bool\n\n\n    var body: some View {\n        TextField(text: $item.name) {\n            Text(\"Prompt\")\n        }\n        .focused($isFocused)\n        .contextMenu {\n            RenameButton()\n            // ... your own custom actions\n        }\n        .renameAction { $isFocused = true }\n}\n\n\nWhen someone taps the rename button in the context menu, the rename action focuses the text field by setting the isFocused property to true.\n\nYou can use this button inside of a navigation title menu and the navigation title modifier automatically configures the environment with the appropriate rename action.\n\nContentView()\n    .navigationTitle($contentTitle) {\n        // ... your own custom actions\n        RenameButton()\n    }\n\nTopics\nCreating an rename button\ninit()\nCreates a rename button.\nRelationships\nConforms To\nView\nSee Also\nCreating special-purpose buttons\nstruct EditButton\nA button that toggles the edit mode environment value.\nstruct PasteButton\nA system button that reads items from the pasteboard and delivers it to a closure."
    },
    {
        "title": "toolbar(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbar(content:)-7vdkx",
        "html": "Parameters\ncontent\n\nThe views representing the content of the toolbar.\n\nDiscussion\n\nUse this modifier to add content to the toolbar. The toolbar modifier expects a collection of toolbar items that you can provide either by supplying a collection of views with each view wrapped in a ToolbarItem, or by providing a collection of views as a ToolbarItemGroup. The example below adds views to using a toolbar item group to support text editing features:\n\nstruct StructToolbarItemGroupView: View {\n    @State private var text = \"\"\n    @State private var bold = false\n    @State private var italic = false\n    @State private var fontSize = 12.0\n\n\n    var displayFont: Font {\n        let font = Font.system(size: CGFloat(fontSize),\n                               weight: bold == true ? .bold : .regular)\n        return italic == true ? font.italic() : font\n    }\n\n\n    var body: some View {\n        TextEditor(text: $text)\n            .font(displayFont)\n            .toolbar {\n                ToolbarItemGroup {\n                    Slider(\n                        value: $fontSize,\n                        in: 8...120,\n                        minimumValueLabel:\n                            Text(\"A\").font(.system(size: 8)),\n                        maximumValueLabel:\n                            Text(\"A\").font(.system(size: 16))\n                    ) {\n                        Text(\"Font Size (\\(Int(fontSize)))\")\n                    }\n                    .frame(width: 150)\n                    Toggle(isOn: $bold) {\n                        Image(systemName: \"bold\")\n                    }\n                    Toggle(isOn: $italic) {\n                        Image(systemName: \"italic\")\n                    }\n                }\n            }\n            .navigationTitle(\"My Note\")\n    }\n}\n\n\nSee Also\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nstruct ToolbarItem\nA model that represents an item which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemGroup\nA model that represents a group of ToolbarItems which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemPlacement\nA structure that defines the placement of a toolbar item.\nprotocol ToolbarContent\nConforming types represent items that can be placed in various locations in a toolbar.\nstruct ToolbarContentBuilder\nConstructs a toolbar item set from multi-expression closures."
    },
    {
        "title": "toolbar(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/toolbar(content:)-5w0tj",
        "html": "Parameters\ncontent\n\nThe items representing the content of the toolbar.\n\nDiscussion\n\nUse this method to populate a toolbar with a collection of views that you provide to a toolbar view builder.\n\nThe toolbar modifier expects a collection of toolbar items which you can provide either by supplying a collection of views with each view wrapped in a ToolbarItem, or by providing a collection of views as a ToolbarItemGroup. The example below uses a collection of ToolbarItem views to create a macOS toolbar that supports text editing features:\n\nstruct StructToolbarItemGroupView: View {\n    @State private var text = \"\"\n    @State private var bold = false\n    @State private var italic = false\n    @State private var fontSize = 12.0\n\n\n    var displayFont: Font {\n        let font = Font.system(size: CGFloat(fontSize),\n                               weight: bold == true ? .bold : .regular)\n        return italic == true ? font.italic() : font\n    }\n\n\n    var body: some View {\n        TextEditor(text: $text)\n            .font(displayFont)\n            .toolbar {\n                ToolbarItemGroup {\n                    Slider(\n                        value: $fontSize,\n                        in: 8...120,\n                        minimumValueLabel:\n                            Text(\"A\").font(.system(size: 8)),\n                        maximumValueLabel:\n                            Text(\"A\").font(.system(size: 16))\n                    ) {\n                        Text(\"Font Size (\\(Int(fontSize)))\")\n                    }\n                    .frame(width: 150)\n                    Toggle(isOn: $bold) {\n                        Image(systemName: \"bold\")\n                    }\n                    Toggle(isOn: $italic) {\n                        Image(systemName: \"italic\")\n                    }\n                }\n            }\n            .navigationTitle(\"My Note\")\n    }\n}\n\n\nAlthough it\u2019s not mandatory, wrapping a related group of toolbar items together in a ToolbarItemGroup provides a one-to-one mapping between controls and toolbar items which results in the correct layout and spacing on each platform. For design guidance on toolbars for macOS apps, see macOS Human Interface Guidelines > Toolbars. For design guidance on toolbars for iOS apps, see iOS Human Interface Guidelines > Toolbars.\n\nSee Also\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nstruct ToolbarItem\nA model that represents an item which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemGroup\nA model that represents a group of ToolbarItems which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemPlacement\nA structure that defines the placement of a toolbar item.\nprotocol ToolbarContent\nConforming types represent items that can be placed in various locations in a toolbar.\nstruct ToolbarContentBuilder\nConstructs a toolbar item set from multi-expression closures."
    },
    {
        "title": "renameAction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/renameaction(_:)-324yw",
        "html": "Parameters\nisFocused\n\nThe focus binding to update when activating the rename action.\n\nReturn Value\n\nA view that has the specified rename action.\n\nDiscussion\n\nUse this modifier in conjunction with the RenameButton to implement standard rename interactions. A rename button receives its action from the environment. Use this modifier to customize the action provided to the rename button.\n\nstruct RowView: View {\n    @State private var text = \"\"\n    @FocusState private var isFocused: Bool\n\n\n    var body: some View {\n        TextField(text: $item.name) {\n            Text(\"Prompt\")\n        }\n        .focused($isFocused)\n        .contextMenu {\n            RenameButton()\n            // ... your own custom actions\n        }\n        .renameAction($isFocused)\n}\n\n\nWhen someone taps the rename button in the context menu, the rename action focuses the text field by setting the isFocused property to true.\n\nSee Also\nRenaming a document\nstruct RenameButton\nA button that triggers a standard rename action.\nfunc renameAction(() -> Void) -> some View\nSets a closure to run for the rename action.\nvar rename: RenameAction?\nAn action that activates the standard rename interaction.\nstruct RenameAction\nAn action that activates a standard rename interaction."
    },
    {
        "title": "rename",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/rename",
        "html": "Discussion\n\nUse the renameAction(_:) modifier to configure the rename action in the environment.\n\nSee Also\nRenaming a document\nstruct RenameButton\nA button that triggers a standard rename action.\nfunc renameAction(FocusState<Bool>.Binding) -> some View\nSets the rename action in the environment to update focus state.\nfunc renameAction(() -> Void) -> some View\nSets a closure to run for the rename action.\nstruct RenameAction\nAn action that activates a standard rename interaction."
    },
    {
        "title": "OpenDocumentAction",
        "url": "https://developer.apple.com/documentation/swiftui/opendocumentaction",
        "html": "Overview\n\nUse the openDocument environment value to get the instance of this structure for a given Environment. Then call the instance to present an existing document. You call the instance directly because it defines a callAsFunction(at:) method that Swift calls when you call the instance.\n\nFor example, you can create a button that opens the document at the specified URL:\n\nstruct OpenDocumentButton: View {\n    var url: URL\n    @Environment(\\.openDocument) private var openDocument\n\n\n    var body: some View {\n        Button(url.deletingPathExtension().lastPathComponent) {\n            Task {\n                do {\n                    try await openDocument(at: url)\n                } catch {\n                    // Handle error\n                }\n            }\n        }\n    }\n}\n\n\nThe above example uses a do-catch statement to handle any errors that the open document action might throw. It also places the action inside a task and awaits the result because the action operates asynchronously.\n\nTo present an existing document, your app must define a DocumentGroup that handles the content type of the specified file. For a document that\u2019s already open, the system brings the existing window to the front. Otherwise, the system opens a new window.\n\nTopics\nCalling the action\nfunc callAsFunction(at: URL) async throws\nOpens the document at the specified file URL.\nSee Also\nOpening a document programmatically\nvar newDocument: NewDocumentAction\nAn action in the environment that presents a new document.\nstruct NewDocumentAction\nAn action that presents a new document.\nvar openDocument: OpenDocumentAction\nAn action in the environment that presents an existing document."
    },
    {
        "title": "FileDocumentReadConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/filedocumentreadconfiguration",
        "html": "Topics\nReading the content\nlet contentType: UTType\nThe expected uniform type of the file contents.\nlet file: FileWrapper\nThe file wrapper containing the document content.\nSee Also\nReading and writing documents\nstruct FileDocumentWriteConfiguration\nThe configuration for serializing file contents."
    },
    {
        "title": "documentConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/documentconfiguration",
        "html": "Discussion\n\nThe value is nil for views that are not enclosed in a DocumentGroup.\n\nFor example, if the app shows the document path in the footer of each document, it can get the URL from the environment:\n\nstruct ContentView: View {\n    @Binding var document: TextDocument\n    @Environment(\\.documentConfiguration) private var configuration: DocumentConfiguration?\n\n\n    var body: some View {\n        \u2026\n        Label(\n            configuration?.fileURL?.path ??\n                \"\", systemImage: \"folder.circle\"\n        )\n    }\n}\n\nSee Also\nAccessing document configuration\nstruct DocumentConfiguration"
    },
    {
        "title": "Fruta: Building a Feature-Rich App with SwiftUI",
        "url": "https://developer.apple.com/documentation/swiftui/fruta_building_a_feature-rich_app_with_swiftui",
        "html": "Overview\n\nNote\n\nThis sample project is associated with WWDC21 sessions 10107: Platforms State of the Union, 10012: What\u2019s New in App Clips, 10013: Build Light and Fast App Clips, 10220: Localize your SwiftUI App.\n\nIt\u2019s also associated with WWDC20 sessions 10637: Platforms State of the Union, 10146: Configure and Link Your App Clips, 10120: Streamline Your App Clip, 10118: Create App Clips for Other Businesses, 10096: Explore Packages and Projects with Xcode Playgrounds, and 10028: Meet WidgetKit.\n\nThe Fruta sample project builds an app for macOS, iOS, and iPadOS that implements SwiftUI platform features like widgets, App Clips, and localization. Users can order smoothies, save favorite drinks, collect rewards, and browse recipes. It contains two flavors of app targets:\n\nSimple iOS and macOS app targets that you build using Personal Team signing. This iOS app runs in Simulator, and only requires a standard Apple ID to install on a device. The simple app implements a rich, localized SwiftUI interface. Users can browse and order smoothies, and save favorite drinks.\n\nFull featured iOS All and macOS All app targets. The full iOS app runs in Simulator, and on devices with an Apple Developer membership. This app includes widget extensions that enable users to add a widget to their iOS Home Screen or the macOS Notification Center, and to view their rewards or a favorite smoothie. This app also embeds an App Clip. With the App Clip, users can discover and instantly launch some of the app\u2019s functionality on their iPhone or iPad without installing the app.\n\nThe Fruta sample app leverages Sign in with Apple and PassKit (Apple Pay and Wallet) to provide a streamlined user experience.\n\nConfigure the Sample Code Project\n\nTo build this project for iOS 15.4, use Xcode 13.3. The runtime requirement is iOS 15.4. To build this project for macOS 12.3, use Xcode 13.3.\n\nTo configure the iOS and macOS app targets without an Apple Developer account, follow these steps:\n\nIn the targets\u2019 Signing & Capabilities panes click Add Account, and log in with your Apple ID.\n\nChose the Your Name (Personal Team) from the team drop down menu.\n\nClick build-and-run.\n\nOn iOS and iPadOS devices you need to navigate to Settings > General > VPN & Device Management and trust your developer certificate.\n\nTo configure the iOS All and macOS All apps, follow these steps:\n\nTo run on your devices, including on macOS, set your team in the targets\u2019 Signing & Capabilities panes. Xcode manages the provisioning profiles for you.\n\nTo run on an iOS or iPadOS device, open the iOSClip.entitlements file and update the value of the Parent Application Identifiers Entitlement to match the iOS app\u2019s bundle identifier.\n\nMake a note of the App Group name on the iOS target\u2019s Signing & Capabilities tab in Project Settings. Substitute this value for group.example.fruta in the Model.swift file.\n\nTo enable the in-app-purchase flow, edit the Fruta iOS \u201cRun\u201d scheme, and select Configuration.storekit for StoreKit Configuration.\n\nCreate a Shared Codebase in SwiftUI\n\nTo create a single app definition that works for multiple platforms, the project defines a structure that conforms to the App protocol. Because the @main attribute precedes the structure definition, the system recognizes the structure as the entry point into the app. Its computed body property returns a WindowGroup scene that contains the view hierarchy displayed by the app to the user. SwiftUI manages the presentation of the scene and its contents in a platform-appropriate manner.\n\n@main\nstruct FrutaApp: App {\n    @StateObject private var model = Model()\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(model)\n        }\n        .commands {\n            SidebarCommands()\n            SmoothieCommands(model: model)\n        }\n    }\n}\n\n\nFor more information, see App structure and behavior.\n\nOffer an App Clip\n\nOn iOS and iPadOS, the Fruta app offers some of its functionality to users who don\u2019t have the full app installed as an App Clip. The app\u2019s Xcode project contains an App Clip target, and, instead of duplicating code, reuses code that\u2019s shared across all platforms to build the App Clip. In shared code, the project makes use of the Active Compilation Condition build setting to exclude code for targets that don\u2019t define the APPCLIP value. For example, only the App Clip target presents an App Store overlay to prompt the user to get the full app.\n\n\n\nVStack(spacing: 0) {\n    Spacer()\n    \n    orderStatusCard\n    \n    Spacer()\n    \n    #if EXTENDED_ALL\n    if presentingBottomBanner {\n        bottomBanner\n    }\n    #endif\n    \n    #if APPCLIP\n    Text(verbatim: \"App Store Overlay\")\n        .hidden()\n        .appStoreOverlay(isPresented: $presentingAppStoreOverlay) {\n            SKOverlay.AppClipConfiguration(position: .bottom)\n        }\n    #endif\n}\n.onChange(of: model.hasAccount) { _ in\n    #if APPCLIP\n    if model.hasAccount {\n        presentingAppStoreOverlay = true\n    }\n    #endif\n}\n\n\nFor more information, see Creating an App Clip with Xcode and Choosing the right functionality for your App Clip.\n\nCreate a Widget\n\nTo allow users to see some of the app\u2019s content as a widget on their iOS Home screen or in the macOS Notification Center, the Xcode project contains targets for widget extensions. Both use code that\u2019s shared across all targets.\n\nFor more information, see WidgetKit.\n\nSee Also\nCreation\nCreating an App Clip with Xcode\nAdd an App Clip target to your Xcode project and share code between the App Clip and its corresponding full app.\nParent Application Identifiers Entitlement\nA list of parent application identifiers for an App Clip with exactly one entry.\nKey: com.apple.developer.parent-application-identifiers\ncom.apple.developer.associated-appclip-app-identifiers\nA list of App Clip identifiers for an app with exactly one entry.\ncom.apple.developer.on-demand-install-capable\nA Boolean value that indicates whether a bundle represents an App Clip."
    },
    {
        "title": "WKApplicationDelegateAdaptor",
        "url": "https://developer.apple.com/documentation/swiftui/wkapplicationdelegateadaptor",
        "html": "Topics\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates an WKApplicationDelegateAdaptor using a WatchKit Application Delegate.\ninit(DelegateType.Type)\nCreates an WKApplicationDelegateAdaptor using a WatchKit Application Delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to WKApplicationDelegate.\ninit(DelegateType.Type)\nCreates an WKApplicationDelegateAdaptor using a WatchKit Application Delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to Observable, and DelegateType conforms to WKApplicationDelegate.\nGetting the delegate adaptor\nvar projectedValue: ObservedObject<DelegateType>.Wrapper\nA projection of the observed object that creates bindings to its properties using dynamic member lookup.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to WKApplicationDelegate.\nvar wrappedValue: DelegateType\nThe underlying delegate.\nRelationships\nConforms To\nDynamicProperty\nSendable\nSee Also\nTargeting watchOS\nstruct WKExtensionDelegateAdaptor\nA property wrapper type that you use to create a WatchKit extension delegate."
    },
    {
        "title": "Food Truck: Building a SwiftUI multiplatform app",
        "url": "https://developer.apple.com/documentation/swiftui/food_truck_building_a_swiftui_multiplatform_app",
        "html": "Overview\n\nUsing the Food Truck app, someone who operates a food truck can keep track of orders, discover the most-popular menu items, and check the weather at their destination. The sample implements the new NavigationSplitView to manage the app\u2019s views, Layout to show the main interface and pending orders, Charts to show trends, and WeatherService to get weather data. Food Truck also implements Live Activities to show the remaining order preparation time with ActivityKit on the lock screen, and with DynamicIsland on the home screen.\n\nYou can access the source code for this sample on GitHub.\n\nNote\n\nThis sample code project is associated with WWDC22 session 110492: State of the Union.\n\nThe Food Truck sample project contains two types of app targets:\n\nSimple app target you can build using personal team signing. This app runs in Simulator, and only requires a standard Apple ID to install on a device. It includes in-app purchase, and a widget extension that enable users to add a widget to their iOS Home Screen or the macOS Notification Center.\n\nFull-featured Food Truck All app target. The full app runs in Simulator, and on devices with an Apple Developer membership. It also allows you to create and sign in with passkeys.\n\nConfigure the sample code project\n\nTo configure the Food Truck app without an Apple Developer account, follow these steps:\n\nIn the Food Truck target\u2019s Signing & Capabilities panes click Add Account, and log in with your Apple ID.\n\nChose Your Name (Personal Team) from the team menu for the Food Truck and Widgets targets.\n\nBuild and run your app.\n\nOn iOS and iPadOS devices navigate to Settings > General > VPN & Device Management and trust your developer certificate.\n\nTo configure the Food Truck All app to run on your devices, follow these steps:\n\nOpen the sample with Xcode 14.3 or later.\n\nSelect the top-level Food Truck project.\n\nFor all targets, choose your team from the Team menu in the Signing & Capabilities pane, so Xcode can automatically manage your provisioning profile.\n\nAdd the Associated Domains capability, and specify your domain with the webcredentials service. For more information about the webcredentials service, see Associated Domains Entitlement.\n\nEnsure an apple-app-site-association (AASA) file is present on your domain, in the .well-known directory, and it contains an entry for this app\u2019s App ID for the webcredentials service. For more information about the apple-app-site-association file, see Supporting associated domains.\n\nIn the AccountManager.swift file, replace all occurrences of example.com with the name of your domain.\n\nNote\n\nTo use the weather forecast feature in the sample, you need to perform additional steps to configure WeatherKit, as described in the Configure the project for WeatherKit section below, or the sample will detect an error and use static data included in the project.\n\nCreate a multiplatform app\n\nFood Truck is a multiplatform app, and there are no separate targets to run on macOS or iOS. Instead, there is only one app target that builds for macOS, iPadOS, and iOS.\n\nDefine a default navigation destination\n\nThe sample\u2019s navigation interface consists of a NavigationSplitView with a Sidebar view, and a NavigationStack:\n\nNavigationSplitView {\n    Sidebar(selection: $selection)\n} detail: {\n    NavigationStack(path: $path) {\n        DetailColumn(selection: $selection, model: model)\n    }\n}\n\n\nAt app launch, the sample presents the TruckView as the default view. The Panel enum encodes the views the user can select in the sidebar, and hence appear in the detail view. The value corresponding to TruckView is .truck, and the app sets this to be the default selection.\n\n@State private var selection: Panel? = Panel.truck\n\nConstruct a dynamic layout\n\nIn the Truck view, the New Orders panel shows the five most-recent orders, and each order shows a DonutStackView, which is a diagonal stack of donut thumbnails. The Layout protocol allows the app to define a DiagonalDonutStackLayout that arranges the donut thumbnails into the diagonal layout. The layout\u2019s placeSubviews(in:proposal:subviews:cache:) implementation calculates the donuts\u2019 positions.\n\nfor index in subviews.indices {\n    switch (index, subviews.count) {\n    case (_, 1):\n        subviews[index].place(\n            at: center,\n            anchor: .center,\n            proposal: ProposedViewSize(size)\n        )\n        \n    case (_, 2):\n        let direction = index == 0 ? -1.0 : 1.0\n        let offsetX = minBound * direction * 0.15\n        let offsetY = minBound * direction * 0.20\n        subviews[index].place(\n            at: CGPoint(x: center.x + offsetX, y: center.y + offsetY),\n            anchor: .center,\n            proposal: ProposedViewSize(CGSize(width: size.width * 0.7, height: size.height * 0.7))\n        )\n    case (1, 3):\n        subviews[index].place(\n            at: center,\n            anchor: .center,\n            proposal: ProposedViewSize(CGSize(width: size.width * 0.65, height: size.height * 0.65))\n        )\n        \n    case (_, 3):\n        let direction = index == 0 ? -1.0 : 1.0\n        let offsetX = minBound * direction * 0.15\n        let offsetY = minBound * direction * 0.23\n        subviews[index].place(\n            at: CGPoint(x: center.x + offsetX, y: center.y + offsetY),\n            anchor: .center,\n            proposal: ProposedViewSize(CGSize(width: size.width * 0.7, height: size.height * 0.65))\n        )\n\nDisplay a chart of popular items\n\nThe sample contains several charts. The most popular items are shown on the TopFiveDonutsView. This chart is implemented in TopDonutSalesChart, which uses a BarMark to construct a bar chart.\n\nChart {\n    ForEach(sortedSales) { sale in\n        BarMark(\n            x: .value(\"Donut\", sale.donut.name),\n            y: .value(\"Sales\", sale.sales)\n        )\n        .cornerRadius(6, style: .continuous)\n        .foregroundStyle(.linearGradient(colors: [Color(\"BarBottomColor\"), .accentColor], startPoint: .bottom, endPoint: .top))\n        .annotation(position: .top, alignment: .top) {\n            Text(sale.sales.formatted())\n                .padding(.vertical, 4)\n                .padding(.horizontal, 8)\n                .background(.quaternary.opacity(0.5), in: Capsule())\n                .background(in: Capsule())\n                .font(.caption)\n        }\n    }\n}\n\n\nThe x axis of the chart shows labels with the names and thumbnails of the items that correspond to each data point.\n\n.chartXAxis {\n    AxisMarks { value in\n        AxisValueLabel {\n            let donut = donutFromAxisValue(for: value)\n            VStack {\n                DonutView(donut: donut)\n                    .frame(height: 35)\n                    \n                Text(donut.name)\n                    .lineLimit(2, reservesSpace: true)\n                    .multilineTextAlignment(.center)\n            }\n            .frame(idealWidth: 80)\n            .padding(.horizontal, 4)\n            \n        }\n    }\n}\n\nObtain a weather forecast\n\nThe app shows a forecasted temperature graph in the Forecast panel in the Truck view. The app obtains this data from the WeatherKit framework.\n\n.task(id: city.id) {\n    for parkingSpot in city.parkingSpots {\n        do {\n            let weather = try await WeatherService.shared.weather(for: parkingSpot.location)\n            condition = weather.currentWeather.condition\n            willRainSoon = weather.minuteForecast?.contains(where: { $0.precipitationChance >= 0.3 })\n            cloudCover = weather.currentWeather.cloudCover\n            temperature = weather.currentWeather.temperature\n            symbolName = weather.currentWeather.symbolName\n            \n            let attribution = try await WeatherService.shared.attribution\n            attributionLink = attribution.legalPageURL\n            attributionLogo = colorScheme == .light ? attribution.combinedMarkLightURL : attribution.combinedMarkDarkURL\n            \n            if willRainSoon == false {\n                spot = parkingSpot\n                break\n            }\n        } catch {\n            print(\"Could not gather weather information...\", error.localizedDescription)\n            condition = .clear\n            willRainSoon = false\n            cloudCover = 0.15\n        }\n    }\n}\n\nConfigure the project for WeatherKit\n\nThe data from the WeatherService instance in WeatherKit requires additional configuration for the Food Truck All target. If you don\u2019t configure WeatherKit, the sample will detect an error and use static data in the project instead.\n\nCreate a unique App ID on the Provisioning Portal, and select the WeatherKit service on the App Services tab.\n\nIn Xcode, for the Food Truck All target on the Signing & Capabilities tab, change the bundle ID to be the same as the App ID from step 1, and add the WeatherKit capability.\n\nFor the Widgets target on the Signing & Capabilities tab, change the bundle ID to make the part before .Widgets the same as the bundle ID for the Food Truck All target.\n\nWait 30 minutes while the service registers your app\u2019s bundle ID.\n\nBuild and run the Food Truck All target.\n\nTrack preparation time with Live Activity\n\nThe app allows the food truck operator to keep track of order preparation time, which is guaranteed to be 60 seconds or less. To facilitate this, the app implements a toolbar button on the order details screen for orders with placed status. Tapping this button changes the order status to preparing, and creates an Activity instance to start a Live Activity, which shows the countdown timer and order details on an iPhone lock screen.\n\nlet timerSeconds = 60\nlet activityAttributes = TruckActivityAttributes(\n    orderID: String(order.id.dropFirst(6)),\n    order: order.donuts.map(\\.id),\n    sales: order.sales,\n    activityName: \"Order preparation activity.\"\n)\n\n\nlet future = Date(timeIntervalSinceNow: Double(timerSeconds))\n\n\nlet initialContentState = TruckActivityAttributes.ContentState(timerRange: Date.now...future)\n\n\nlet activityContent = ActivityContent(state: initialContentState, staleDate: Calendar.current.date(byAdding: .minute, value: 2, to: Date())!)\n\n\ndo {\n    let myActivity = try Activity<TruckActivityAttributes>.request(attributes: activityAttributes, content: activityContent,\n        pushType: nil)\n    print(\" Requested MyActivity live activity. ID: \\(myActivity.id)\")\n    postNotification()\n} catch let error {\n    print(\"Error requesting live activity: \\(error.localizedDescription)\")\n}\n\n\nThe app also implements DynamicIsland to show the same information as on the lock screen in the Dynamic Island on iPhone 14 Pro devices.\n\nDynamicIsland {\n    DynamicIslandExpandedRegion(.leading) {\n        ExpandedLeadingView()\n    }\n\n\n    DynamicIslandExpandedRegion(.trailing, priority: 1) {\n        ExpandedTrailingView(orderNumber: context.attributes.orderID, timerInterval: context.state.timerRange)\n            .dynamicIsland(verticalPlacement: .belowIfTooWide)\n    }\n} compactLeading: {\n    Image(\"IslandCompactIcon\")\n        .padding(4)\n        .background(.indigo.gradient, in: ContainerRelativeShape())\n       \n} compactTrailing: {\n    Text(timerInterval: context.state.timerRange, countsDown: true)\n        .monospacedDigit()\n        .foregroundColor(Color(\"LightIndigo\"))\n        .frame(width: 40)\n} minimal: {\n    Image(\"IslandCompactIcon\")\n        .padding(4)\n        .background(.indigo.gradient, in: ContainerRelativeShape())\n}\n.contentMargins(.trailing, 32, for: .expanded)\n.contentMargins([.leading, .top, .bottom], 6, for: .compactLeading)\n.contentMargins(.all, 6, for: .minimal)\n.widgetURL(URL(string: \"foodtruck://order/\\(context.attributes.orderID)\"))\n\n\nTapping the same button again changes the status to complete, and ends the Live Activity. This removes the Live Activity from the lock screen and from the Dynamic Island.\n\nTask {\n    for activity in Activity<TruckActivityAttributes>.activities {\n        // Check if this is the activity associated with this order.\n        if activity.attributes.orderID == String(order.id.dropFirst(6)) {\n            await activity.end(nil, dismissalPolicy: .immediate)\n        }\n    }\n}\n"
    },
    {
        "title": "NSApplicationDelegateAdaptor",
        "url": "https://developer.apple.com/documentation/swiftui/nsapplicationdelegateadaptor",
        "html": "Overview\n\nTo handle app delegate callbacks in an app that uses the SwiftUI life cycle, define a type that conforms to the NSApplicationDelegate protocol, and implement the delegate methods that you need. For example, you can implement the application(_:didRegisterForRemoteNotificationsWithDeviceToken:) method to handle remote notification registration:\n\nclass MyAppDelegate: NSObject, NSApplicationDelegate, ObservableObject {\n    func application(\n        _ application: NSApplication,\n        didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n    ) {\n        // Record the device token.\n    }\n}\n\n\nThen use the NSApplicationDelegateAdaptor property wrapper inside your App declaration to tell SwiftUI about the delegate type:\n\n@main\nstruct MyApp: App {\n    @NSApplicationDelegateAdaptor private var appDelegate: MyAppDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI instantiates the delegate and calls the delegate\u2019s methods in response to life cycle events. Define the delegate adaptor only in your App declaration, and only once for a given app. If you declare it more than once, SwiftUI generates a runtime error.\n\nIf your app delegate conforms to the ObservableObject protocol, as in the example above, then SwiftUI puts the delegate it creates into the Environment. You can access the delegate from any scene or view in your app using the EnvironmentObject property wrapper:\n\n@EnvironmentObject private var appDelegate: MyAppDelegate\n\n\nThis enables you to use the dollar sign ($) prefix to get a binding to published properties that you declare in the delegate. For more information, see projectedValue.\n\nImportant\n\nManage an app\u2019s life cycle events without using an app delegate whenever possible. For example, prefer to handle changes in ScenePhase instead of relying on delegate callbacks, like applicationDidFinishLaunching(_:).\n\nTopics\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates an AppKit app delegate adaptor using a delegate that\u2019s an observable object.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to NSApplicationDelegate, and DelegateType conforms to ObservableObject.\ninit(DelegateType.Type)\nCreates an AppKit app delegate adaptor.\ninit(DelegateType.Type)\nCreates an AppKit app delegate adaptor using an observable delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to NSApplicationDelegate, and DelegateType conforms to Observable.\nGetting the delegate adaptor\nvar projectedValue: ObservedObject<DelegateType>.Wrapper\nA projection of the observed object that provides bindings to its properties.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to NSApplicationDelegate, and DelegateType conforms to ObservableObject.\nvar wrappedValue: DelegateType\nThe underlying delegate.\nRelationships\nConforms To\nDynamicProperty\nSendable"
    },
    {
        "title": "searchSuggestions(_:for:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchsuggestions(_:for:)",
        "html": "Parameters\nvisibility\n\nThe visibility of the search suggestions for the specified locations.\n\nplacements\n\nThe set of locations in which to set the visibility of search suggestions.\n\nDiscussion\n\nSwiftUI presents search suggestions differently depending on several factors, like the platform, the position of the search field, and the size class. Use this modifier when you want to only display suggestions in certain ways under certain conditions. For example, you might choose to display suggestions in a menu when possible, but directly filter your data source otherwise.\n\nenum FruitSuggestion: String, Identifiable {\n    case apple, banana, orange\n    var id: Self { self }\n}\n\n\n@State private var text = \"\"\n@State private var suggestions: [FruitSuggestion] = []\n\n\nvar body: some View {\n    MainContent()\n        .searchable(text: $text) {\n            ForEach(suggestions) { suggestion\n                Text(suggestion.rawValue)\n                    .searchCompletion(suggestion.rawValue)\n            }\n            .searchSuggestions(.hidden, for: .content)\n        }\n}\n\nSee Also\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions."
    },
    {
        "title": "UIApplicationDelegateAdaptor",
        "url": "https://developer.apple.com/documentation/swiftui/uiapplicationdelegateadaptor",
        "html": "Overview\n\nTo handle app delegate callbacks in an app that uses the SwiftUI life cycle, define a type that conforms to the UIApplicationDelegate protocol, and implement the delegate methods that you need. For example, you can implement the application(_:didRegisterForRemoteNotificationsWithDeviceToken:) method to handle remote notification registration:\n\nclass MyAppDelegate: NSObject, UIApplicationDelegate, ObservableObject {\n    func application(\n        _ application: UIApplication,\n        didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n    ) {\n        // Record the device token.\n    }\n}\n\n\nThen use the UIApplicationDelegateAdaptor property wrapper inside your App declaration to tell SwiftUI about the delegate type:\n\n@main\nstruct MyApp: App {\n    @UIApplicationDelegateAdaptor private var appDelegate: MyAppDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI instantiates the delegate and calls the delegate\u2019s methods in response to life cycle events. Define the delegate adaptor only in your App declaration, and only once for a given app. If you declare it more than once, SwiftUI generates a runtime error.\n\nIf your app delegate conforms to the ObservableObject protocol, as in the example above, then SwiftUI puts the delegate it creates into the Environment. You can access the delegate from any scene or view in your app using the EnvironmentObject property wrapper:\n\n@EnvironmentObject private var appDelegate: MyAppDelegate\n\n\nThis enables you to use the dollar sign ($) prefix to get a binding to published properties that you declare in the delegate. For more information, see projectedValue.\n\nImportant\n\nManage an app\u2019s life cycle events without using an app delegate whenever possible. For example, prefer to handle changes in ScenePhase instead of relying on delegate callbacks, like application(_:didFinishLaunchingWithOptions:).\n\nScene delegates\n\nSome iOS apps define a UIWindowSceneDelegate to handle scene-based events, like app shortcuts:\n\nclass MySceneDelegate: NSObject, UIWindowSceneDelegate, ObservableObject {\n    func windowScene(\n        _ windowScene: UIWindowScene,\n        performActionFor shortcutItem: UIApplicationShortcutItem\n    ) async -> Bool {\n        // Do something with the shortcut...\n\n\n        return true\n    }\n}\n\n\nYou can provide this kind of delegate to a SwiftUI app by returning the scene delegate\u2019s type from the application(_:configurationForConnecting:options:) method inside your app delegate:\n\nextension MyAppDelegate {\n    func application(\n        _ application: UIApplication,\n        configurationForConnecting connectingSceneSession: UISceneSession,\n        options: UIScene.ConnectionOptions\n    ) -> UISceneConfiguration {\n\n\n        let configuration = UISceneConfiguration(\n                                name: nil,\n                                sessionRole: connectingSceneSession.role)\n        if connectingSceneSession.role == .windowApplication {\n            configuration.delegateClass = MySceneDelegate.self\n        }\n        return configuration\n    }\n}\n\n\nWhen you configure the UISceneConfiguration instance, you only need to indicate the delegate class, and not a scene class or storyboard. SwiftUI creates and manages the delegate instance, and sends it any relevant delegate callbacks.\n\nAs with the app delegate, if you make your scene delegate an observable object, SwiftUI automatically puts it in the Environment, from where you can access it with the EnvironmentObject property wrapper, and create bindings to its published properties.\n\nTopics\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates a UIKit app delegate adaptor.\ninit(DelegateType.Type)\nCreates a UIKit app delegate adaptor using a delegate that\u2019s an observable object.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to UIApplicationDelegate.\ninit(DelegateType.Type)\nCreates a UIKit app delegate adaptor using an observable delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to Observable, and DelegateType conforms to UIApplicationDelegate.\nGetting the delegate adaptor\nvar projectedValue: ObservedObject<DelegateType>.Wrapper\nA projection of the observed object that provides bindings to its properties.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to UIApplicationDelegate.\nvar wrappedValue: DelegateType\nThe underlying app delegate.\nRelationships\nConforms To\nDynamicProperty\nSendable"
    },
    {
        "title": "searchable(text:editableTokens:placement:prompt:token:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/searchable(text:editabletokens:placement:prompt:token:)-41gcr",
        "html": "Parameters\ntext\n\nThe text to display and edit in the search field.\n\neditableTokens\n\nA collection of tokens to display and edit in the search field.\n\nplacement\n\nThe preferred placement of the search field within the containing view hierarchy.\n\nprompt\n\nA Text view representing the prompt of the search field which provides users with guidance on what to search for.\n\ntoken\n\nA view builder that creates a view given an element in tokens.\n\nDiscussion\n\nFor more information about using searchable modifiers, see Adding a search interface to your app.\n\nSee Also\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy."
    },
    {
        "title": "environment(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/environment(_:)",
        "html": "Parameters\nobject\n\nThe object to set for this object\u2019s type in the environment, or nil to clear an object of this type from the environment.\n\nReturn Value\n\nA scene that has the specified object in its environment.\n\nDiscussion\n\nUse this modifier to place an object that you declare with the Observable() macro into a scene\u2019s environment. For example, you can add an instance of a custom observable Profile class to the environment of a WindowGroup scene:\n\n@Observable class Profile { ... }\n\n\n@main\nstruct MyApp: App {\n    var body: some View {\n        WindowGroup {\n            ContentView()\n        }\n        .environment(Profile.currentProfile)\n    }\n}\n\n\nYou then read the object inside ContentView or one of its descendants using the Environment property wrapper:\n\nstruct ContentView: View {\n    @Environment(Profile.self) private var currentProfile: Profile\n\n\n    var body: some View { ... }\n}\n\n\nThis modifier affects the given scene, as well as the scene\u2019s descendant views. It has no effect outside the view hierarchy on which you call it. The environment of a given view hierarchy holds only one observable object of a given type.\n\nNote\n\nThis modifier takes an object that conforms to the Observable protocol. To add environment objects that conform to the ObservableObject protocol, use environmentObject(_:) instead.\n\nSee Also\nModifying the environment of a scene\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some Scene\nSets the environment value of the specified key path to the given value.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some Scene\nTransforms the environment value of the specified key path with the given function."
    },
    {
        "title": "Lists",
        "url": "https://developer.apple.com/documentation/swiftui/lists",
        "html": "Overview\n\nUse a list to display a one-dimensional vertical collection of views.\n\nThe list is a complex container type that automatically provides scrolling when it grows too large for the current display. You build a list by providing it with individual views for the rows in the list, or by using a ForEach to enumerate a group of rows. You can also mix these strategies, blending any number of individual views and ForEach constructs.\n\nUse view modifiers to configure the appearance and behavior of a list and its rows, headers, sections, and separators. For example, you can apply a style to the list, add swipe gestures to individual rows, or make the list refreshable with a pull-down gesture. You can also use the configuration associated with Scroll views to control the list\u2019s implicit scrolling behavior.\n\nFor design guidance, see Lists and tables in the Human Interface Guidelines.\n\nTopics\nCreating a list\nDisplaying data in lists\nVisualize collections of data with platform-appropriate appearance.\nstruct List\nA container that presents rows of data arranged in a single column, optionally providing the ability to select one or more members.\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nstruct Section\nA container view that you can use to add hierarchy within certain views.\nIterating over list content\nstruct ForEach\nA structure that computes views on demand from an underlying collection of identified data.\nprotocol DynamicViewContent\nA type of view that generates views from an underlying collection of data.\nDisclosing information progressively\nstruct OutlineGroup\nA structure that computes views and disclosure groups on demand from an underlying collection of tree-structured, identified data.\nstruct DisclosureGroup\nA view that shows or hides another content view, based on the state of a disclosure control.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view.\nConfiguring rows\nfunc listRowInsets(EdgeInsets?) -> some View\nApplies an inset to the rows in a list.\nfunc listRowHoverEffect(HoverEffect?) -> some View\nRequests that the containing list row use the provided hover effect.\nBeta\nfunc listRowHoverEffectDisabled(Bool) -> some View\nRequests that the containing list row have its hover effect disabled.\nBeta\nfunc listItemTint(Color?) -> some View\nSets a fixed tint color associated with specific content in a list.\nfunc listItemTint(ListItemTint?) -> some View\nSets the tint effect for content in a list.\nstruct ListItemTint\nThe configuration of a tint effect applied to content within a List.\nvar defaultMinListRowHeight: CGFloat\nThe default minimum height of a row in a list.\nConfiguring separators\nfunc listRowSeparatorTint(Color?, edges: VerticalEdge.Set) -> some View\nSets the tint color associated with a row.\nfunc listSectionSeparatorTint(Color?, edges: VerticalEdge.Set) -> some View\nSets the tint color associated with a section.\nfunc listRowSeparator(Visibility, edges: VerticalEdge.Set) -> some View\nSets the display mode for the separator associated with this specific row.\nfunc listSectionSeparator(Visibility, edges: VerticalEdge.Set) -> some View\nSets whether to hide the separator associated with a list section.\nConfiguring headers\nfunc headerProminence(Prominence) -> some View\nSets the header prominence for this view.\nvar headerProminence: Prominence\nThe prominence to apply to section headers within a view.\nenum Prominence\nA type indicating the prominence of a view hierarchy.\nvar defaultMinListHeaderHeight: CGFloat?\nThe default minimum height of a header in a list.\nConfiguring spacing\nfunc listRowSpacing(CGFloat?) -> some View\nSets the vertical spacing between two adjacent rows in a List.\nfunc listSectionSpacing(CGFloat) -> some View\nSets the spacing to a custom value between adjacent sections in a List.\nfunc listSectionSpacing(ListSectionSpacing) -> some View\nSets the spacing between adjacent sections in a List.\nstruct ListSectionSpacing\nThe spacing options between two adjacent sections in a list.\nConfiguring backgrounds\nfunc listRowBackground<V>(V?) -> some View\nPlaces a custom background view behind a list row item.\nfunc alternatingRowBackgrounds(AlternatingRowBackgroundBehavior) -> some View\nOverrides whether lists and tables in this view have alternating row backgrounds.\nstruct AlternatingRowBackgroundBehavior\nThe styling of views with respect to alternating row backgrounds.\nvar backgroundProminence: BackgroundProminence\nThe prominence of the background underneath views associated with this environment.\nstruct BackgroundProminence\nThe prominence of backgrounds underneath other views.\nDisplaying a badge on a list item\nfunc badge(Text?) -> some View\nGenerates a badge for the view from a text view.\nfunc badge<S>(S?) -> some View\nGenerates a badge for the view from a string.\nfunc badge(LocalizedStringKey?) -> some View\nGenerates a badge for the view from a localized string key.\nfunc badge(Int) -> some View\nGenerates a badge for the view from an integer value.\nfunc badgeProminence(BadgeProminence) -> some View\nSpecifies the prominence of badges created by this view.\nvar badgeProminence: BadgeProminence\nThe prominence to apply to badges associated with this environment.\nstruct BadgeProminence\nThe visual prominence of a badge.\nConfiguring interaction\nfunc swipeActions<T>(edge: HorizontalEdge, allowsFullSwipe: Bool, content: () -> T) -> some View\nAdds custom swipe actions to a row in a list.\nfunc selectionDisabled(Bool) -> some View\nAdds a condition that controls whether users can select this view.\nRefreshing a list\u2019s content\nfunc refreshable(action: () async -> Void) -> some View\nMarks this view as refreshable.\nvar refresh: RefreshAction?\nA refresh action stored in a view\u2019s environment.\nstruct RefreshAction\nAn action that initiates a refresh operation.\nEditing a list\nfunc moveDisabled(Bool) -> some View\nAdds a condition for whether the view\u2019s view hierarchy is movable.\nfunc deleteDisabled(Bool) -> some View\nAdds a condition for whether the view\u2019s view hierarchy is deletable.\nvar editMode: Binding<EditMode>?\nAn indication of whether the user can edit the contents of a view associated with this environment.\nenum EditMode\nA mode that indicates whether the user can edit a view\u2019s content.\nstruct EditActions\nA set of edit actions on a collection of data that a view can offer to a user.\nstruct EditableCollectionContent\nAn opaque wrapper view that adds editing capabilities to a row in a list.\nstruct IndexedIdentifierCollection\nA collection wrapper that iterates over the indices and identifiers of a collection together.\nSee Also\nView layout\nLayout fundamentals\nArrange views inside built-in layout containers like stacks and grids.\nLayout adjustments\nMake fine adjustments to alignment, spacing, padding, and other layout parameters.\nCustom layout\nPlace views in custom arrangements and create animated transitions between layout types.\nTables\nDisplay selectable, sortable data arranged in rows and columns.\nView groupings\nPresent views in different kinds of purpose-driven containers, like forms or control groups.\nScroll views\nEnable people to scroll to content that doesn\u2019t fit in the current display."
    },
    {
        "title": "Scroll views",
        "url": "https://developer.apple.com/documentation/swiftui/scroll-views",
        "html": "Overview\n\nWhen the content of a view doesn\u2019t fit in the display, you can wrap the view in a ScrollView to enable people to scroll on one or more axes. Configure the scroll view using view modifiers. For example, you can set the visibility of the scroll indicators or the availability of scrolling in a given dimension.\n\nYou can put any view type in a scroll view, but you most often use a scroll view for a layout container with too many elements to fit in the display. For some container views that you put in a scroll view, like lazy stacks, the container doesn\u2019t load views until they are visible or almost visible. For others, like regular stacks and grids, the container loads the content all at once, regardless of the state of scrolling.\n\nLists and Tables implicitly include a scroll view, so you don\u2019t need to add scrolling to those container types. However, you can configure their implicit scroll views with the same view modifiers that apply to explicit scroll views.\n\nFor design guidance, see Scroll views in the Human Interface Guidelines.\n\nTopics\nCreating a scroll view\nstruct ScrollView\nA scrollable view.\nstruct ScrollViewReader\nA view that provides programmatic scrolling, by working with a proxy to scroll to known child views.\nstruct ScrollViewProxy\nA proxy value that supports programmatic scrolling of the scrollable views within a view hierarchy.\nManaging scroll position\nfunc scrollPosition(id: Binding<(some Hashable)?>, anchor: UnitPoint?) -> some View\nAssociates a binding to be updated when a scroll view within this view scrolls.\nfunc defaultScrollAnchor(UnitPoint?) -> some View\nAssociates an anchor to control which part of the scroll view\u2019s content should be rendered by default.\nDefining scroll targets\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> some View\nSets the scroll behavior of views scrollable in the provided axes.\nfunc scrollTargetLayout(isEnabled: Bool) -> some View\nConfigures the outermost layout as a scroll target layout.\nstruct ScrollTarget\nA type defining the target in which a scroll view should try and scroll to.\nprotocol ScrollTargetBehavior\nA type that defines the scroll behavior of a scrollable view.\nstruct ScrollTargetBehaviorContext\nThe context in which a scroll target behavior updates its scroll target.\nstruct PagingScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to container-based geometry.\nstruct ViewAlignedScrollTargetBehavior\nThe scroll behavior that aligns scroll targets to view-based geometry.\nAnimating scroll transitions\nfunc scrollTransition(ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nfunc scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View\nApplies the given transition, animating between the phases of the transition as this view appears and disappears within the visible region of the containing scroll view, or other container specified using the coordinateSpace parameter.\nenum ScrollTransitionPhase\nThe phases that a view transitions between when it scrolls among other views.\nstruct ScrollTransitionConfiguration\nThe configuration of a scroll transition that controls how a transition is applied as a view is scrolled through the visible region of a containing scroll view or other container.\nShowing scroll indicators\nfunc scrollIndicatorsFlash(onAppear: Bool) -> some View\nFlashes the scroll indicators of a scrollable view when it appears.\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> some View\nFlashes the scroll indicators of scrollable views when a value changes.\nfunc scrollIndicators(ScrollIndicatorVisibility, axes: Axis.Set) -> some View\nSets the visibility of scroll indicators within this view.\nvar horizontalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visibility to apply to scroll indicators of any horizontally scrollable content.\nvar verticalScrollIndicatorVisibility: ScrollIndicatorVisibility\nThe visiblity to apply to scroll indicators of any vertically scrollable content.\nstruct ScrollIndicatorVisibility\nThe visibility of scroll indicators of a UI element.\nManaging content visibility\nfunc scrollContentBackground(Visibility) -> some View\nSpecifies the visibility of the background for scrollable views within this view.\nfunc scrollClipDisabled(Bool) -> some View\nSets whether a scroll view clips its content to its bounds.\nDisabling scrolling\nfunc scrollDisabled(Bool) -> some View\nDisables or enables scrolling in scrollable views.\nvar isScrollEnabled: Bool\nA Boolean value that indicates whether any scroll views associated with this environment allow scrolling to occur.\nConfiguring scroll bounce behavior\nfunc scrollBounceBehavior(ScrollBounceBehavior, axes: Axis.Set) -> some View\nConfigures the bounce behavior of scrollable views along the specified axis.\nvar horizontalScrollBounceBehavior: ScrollBounceBehavior\nThe scroll bounce mode for the horizontal axis of scrollable views.\nvar verticalScrollBounceBehavior: ScrollBounceBehavior\nThe scroll bounce mode for the vertical axis of scrollable views.\nstruct ScrollBounceBehavior\nThe ways that a scrollable view can bounce when it reaches the end of its content.\nInteracting with a software keyboard\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nvar scrollDismissesKeyboardMode: ScrollDismissesKeyboardMode\nThe way that scrollable content interacts with the software keyboard.\nstruct ScrollDismissesKeyboardMode\nThe ways that scrollable content can interact with the software keyboard.\nSee Also\nView layout\nLayout fundamentals\nArrange views inside built-in layout containers like stacks and grids.\nLayout adjustments\nMake fine adjustments to alignment, spacing, padding, and other layout parameters.\nCustom layout\nPlace views in custom arrangements and create animated transitions between layout types.\nLists\nDisplay a structured, scrollable column of information.\nTables\nDisplay selectable, sortable data arranged in rows and columns.\nView groupings\nPresent views in different kinds of purpose-driven containers, like forms or control groups."
    },
    {
        "title": "ContainerRelativeShape",
        "url": "https://developer.apple.com/documentation/swiftui/containerrelativeshape",
        "html": "Topics\nCreating the shape\ninit()\nRelationships\nConforms To\nAnimatable\nInsettableShape\nSendable\nShape\nView\nSee Also\nSetting a container shape\nfunc containerShape<T>(T) -> some View\nSets the container shape to use for any container relative shape within this view.\nprotocol InsettableShape\nA shape type that is able to inset itself to produce another shape."
    },
    {
        "title": "TransformedShape",
        "url": "https://developer.apple.com/documentation/swiftui/transformedshape",
        "html": "Topics\nCreating a transformed shape\ninit(shape: Content, transform: CGAffineTransform)\nGetting the shape\u2019s characteristics\nvar shape: Content\nvar transform: CGAffineTransform\nRelationships\nConforms To\nAnimatable\nSendable\nShape\nView\nSee Also\nTransforming a shape\nstruct ScaledShape\nA shape with a scale transform applied to it.\nstruct RotatedShape\nA shape with a rotation transform applied to it.\nstruct OffsetShape\nA shape with a translation offset transform applied to it."
    },
    {
        "title": "StrokeBorderShapeView",
        "url": "https://developer.apple.com/documentation/swiftui/strokebordershapeview",
        "html": "Overview\n\nYou don\u2019t create this type directly; it\u2019s the return type of Shape.strokeBorder.\n\nTopics\nCreating a stroke border shape view\ninit(shape: Content, style: Style, strokeStyle: StrokeStyle, isAntialiased: Bool, background: Background)\nCreate a stroke border shape.\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape.\nvar style: Style\nThe style that strokes the border of this view\u2019s shape.\nRelationships\nConforms To\nShapeView\nView\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "RotatedShape",
        "url": "https://developer.apple.com/documentation/swiftui/rotatedshape",
        "html": "Topics\nCreating a rotated shape\ninit(shape: Content, angle: Angle, anchor: UnitPoint)\nGetting the shape\u2019s characteristics\nvar anchor: UnitPoint\nvar angle: Angle\nvar shape: Content\nSupporting types\nvar animatableData: RotatedShape<Content>.AnimatableData\nThe data to animate.\nRelationships\nConforms To\nAnimatable\nConforms when Content conforms to InsettableShape.\nInsettableShape\nConforms when Content conforms to InsettableShape.\nSendable\nShape\nView\nConforms when Content conforms to InsettableShape.\nSee Also\nTransforming a shape\nstruct ScaledShape\nA shape with a scale transform applied to it.\nstruct OffsetShape\nA shape with a translation offset transform applied to it.\nstruct TransformedShape\nA shape with an affine transform applied to it."
    },
    {
        "title": "defaultSize(width:height:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultsize(width:height:)",
        "html": "Parameters\nwidth\n\nThe default width for windows created from a scene.\n\nheight\n\nThe default height for windows created from a scene.\n\nReturn Value\n\nA scene that uses a default size for new windows.\n\nDiscussion\n\nUse this scene modifier to indicate a default initial size for a new window that the system creates from a Scene declaration. For example, you can request that new windows that a WindowGroup generates occupy 600 points in the x-dimension and 400 points in the y-dimension:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .defaultSize(width: 600, height: 400)\n    }\n}\n\n\nThe size that you specify acts only as a default for when the window first appears. People can later resize the window using interface controls that the system provides. Also, during state restoration, the system restores windows to their most recent size rather than the default size.\n\nIf you specify a default size that\u2019s outside the range of the window\u2019s inherent resizability in one or both dimensions, the system clamps the affected dimension to keep it in range. You can configure the resizability of a scene using the windowResizability(_:) modifier.\n\nThe default size modifier affects any scene type that creates windows in macOS, namely:\n\nWindowGroup\n\nWindow\n\nDocumentGroup\n\nSettings\n\nIf you want to specify the size input in terms of size instance, use defaultSize(_:) instead.\n\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "Circle",
        "url": "https://developer.apple.com/documentation/swiftui/circle",
        "html": "Overview\n\nThe circle\u2019s radius equals half the length of the frame rectangle\u2019s smallest edge.\n\nTopics\nCreating a circle\ninit()\nCreates a new circle shape.\nRelationships\nConforms To\nAnimatable\nChartSymbolShape\nInsettableShape\nSendable\nShape\nView\nSee Also\nCreating circular shapes\nstruct Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nstruct Capsule\nA capsule shape aligned inside the frame of the view containing it."
    },
    {
        "title": "RectangleCornerRadii",
        "url": "https://developer.apple.com/documentation/swiftui/rectanglecornerradii",
        "html": "Topics\nCreating a set of radii\ninit(topLeading: CGFloat, bottomLeading: CGFloat, bottomTrailing: CGFloat, topTrailing: CGFloat)\nCreates a new set of corner radii for a rounded rectangle with uneven corners.\nGetting values for specific corners\nvar topLeading: CGFloat\nThe radius of the top-leading corner.\nvar topTrailing: CGFloat\nThe radius of the top-trailing corner.\nvar bottomLeading: CGFloat\nThe radius of the bottom-leading corner.\nvar bottomTrailing: CGFloat\nThe radius of the bottom-trailing corner.\nRelationships\nConforms To\nAnimatable\nEquatable\nSendable\nSee Also\nCreating rectangular shapes\nstruct Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nstruct RoundedRectangle\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nenum RoundedCornerStyle\nDefines the shape of a rounded rectangle\u2019s corners.\nstruct UnevenRoundedRectangle\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it."
    },
    {
        "title": "ReferenceFileDocument",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocument",
        "html": "Overview\n\nTo store a document as a reference type \u2014 like a class \u2014 create a type that conforms to the ReferenceFileDocument protocol and implement the required methods and properties. Your implementation:\n\nProvides a list of the content types that the document can read from and write to by defining readableContentTypes. If the list of content types that the document can write to is different from those that it reads from, you can optionally also define writableContentTypes.\n\nLoads documents from file in the init(configuration:) initializer.\n\nStores documents to file by providing a snapshot of the document\u2019s content in the snapshot(contentType:) method, and then serializing that content in the fileWrapper(snapshot:configuration:) method.\n\nImportant\n\nIf you store your document as a value type \u2014 like a structure \u2014 use FileDocument instead.\n\nEnsure that types that conform to this protocol are thread-safe. In particular, SwiftUI calls the protocol\u2019s methods on a background thread. Don\u2019t use that thread to perform user interface updates. Use it only to serialize and deserialize the document data.\n\nTopics\nReading a document\ninit(configuration: Self.ReadConfiguration) throws\nCreates a document and initializes it with the contents of a file.\n\nRequired\n\nstatic var readableContentTypes: [UTType]\nThe file and data types that the document reads from.\n\nRequired\n\ntypealias ReadConfiguration\nThe configuration for reading document contents.\nGetting a snapshot\nfunc snapshot(contentType: UTType) throws -> Self.Snapshot\nCreates a snapshot that represents the current state of the document.\n\nRequired\n\nassociatedtype Snapshot\nA type that represents the document\u2019s stored content.\n\nRequired\n\nWriting a document\nfunc fileWrapper(snapshot: Self.Snapshot, configuration: Self.WriteConfiguration) throws -> FileWrapper\nSerializes a document snapshot to a file wrapper.\n\nRequired\n\nstatic var writableContentTypes: [UTType]\nThe file types that the document supports saving or exporting to.\n\nRequired Default implementation provided.\n\ntypealias WriteConfiguration\nThe configuration for writing document contents.\nRelationships\nInherits From\nObservableObject\nSee Also\nStoring document data in a class instance\nstruct ReferenceFileDocumentConfiguration\nThe properties of an open reference file document.\nvar undoManager: UndoManager?\nThe undo manager used to register a view\u2019s undo operations."
    },
    {
        "title": "ReferenceFileDocumentConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/referencefiledocumentconfiguration",
        "html": "Overview\n\nYou receive an instance of this structure when you create a DocumentGroup with a reference file type. Use it to access the document in your viewer or editor.\n\nTopics\nGetting and setting the document\nvar document: Document\nThe current document model.\nvar $document: ObservedObject<Document>.Wrapper\nGetting document properties\nvar fileURL: URL?\nThe URL of the open file document.\nvar isEditable: Bool\nA Boolean that indicates whether you can edit the document.\nSee Also\nStoring document data in a class instance\nprotocol ReferenceFileDocument\nA type that you use to serialize reference type documents to and from file.\nvar undoManager: UndoManager?\nThe undo manager used to register a view\u2019s undo operations."
    },
    {
        "title": "DocumentGroup",
        "url": "https://developer.apple.com/documentation/swiftui/documentgroup",
        "html": "Overview\n\nUse a DocumentGroup scene to tell SwiftUI what kinds of documents your app can open when you declare your app using the App protocol.\n\nInitialize a document group scene by passing in the document model and a view capable of displaying the document type. The document types you supply to DocumentGroup must conform to FileDocument or ReferenceFileDocument. SwiftUI uses the model to add document support to your app. In macOS this includes document-based menu support, including the ability to open multiple documents. On iOS this includes a document browser that can navigate to the documents stored on the file system and multiwindow support:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextFile()) { configuration in\n            ContentView(document: configuration.$document)\n        }\n    }\n}\n\n\nAny time the configuration changes, SwiftUI updates the contents with that new configuration, similar to other parameterized builders.\n\nViewing documents\n\nIf your app only needs to display but not modify a specific document type, you can use the file viewer document group scene. You supply the file type of the document, and a view that displays the document type that you provide:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(viewing: MyImageFormatDocument.self) {\n            MyImageFormatViewer(image: $0.document)\n        }\n    }\n}\n\nSupporting multiple document types\n\nYour app can support multiple document types by adding additional document group scenes:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextFile()) { group in\n            ContentView(document: group.$document)\n        }\n        DocumentGroup(viewing: MyImageFormatDocument.self) { group in\n            MyImageFormatViewer(image: group.document)\n        }\n    }\n}\n\nAccessing the document\u2019s URL\n\nIf your app needs to know the document\u2019s URL, you can read it from the editor closure\u2019s configuration parameter, along with the binding to the document. When you create a new document, the configuration\u2019s fileURL property is nil. Every time it changes, it is passed over to the DocumentGroup builder in the updated configuration. This ensures that the view you define in the closure always knows the URL of the document it hosts.\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextFile()) { configuration in\n            ContentView(\n                document: configuration.$document,\n                fileURL: configuration.fileURL\n            )\n        }\n    }\n}\n\n\nThe URL can be used, for example, to present the file path of the file name in the user interface. Don\u2019t access the document\u2019s contents or metadata using the URL because that can conflict with the management of the file that SwiftUI performs. Instead, use the methods that FileDocument and ReferenceFileDocument provide to perform read and write operations.\n\nTopics\nCreating a document group\ninit(newDocument: () -> Document, editor: (FileDocumentConfiguration<Document>) -> Content)\nCreates a document group for creating and editing file documents.\nAvailable when Document conforms to FileDocument and Content conforms to View.\ninit(viewing: Document.Type, viewer: (FileDocumentConfiguration<Document>) -> Content)\nCreates a document group capable of viewing file documents.\nAvailable when Document conforms to FileDocument and Content conforms to View.\nCreating a reference file document group\ninit(newDocument: () -> Document, editor: (ReferenceFileDocumentConfiguration<Document>) -> Content)\nCreates a document group that is able to create and edit reference file documents.\nAvailable when Document conforms to ReferenceFileDocument and Content conforms to View.\ninit(viewing: Document.Type, viewer: (ReferenceFileDocumentConfiguration<Document>) -> Content)\nCreates a document group that is able to view reference file documents.\nAvailable when Document conforms to ReferenceFileDocument and Content conforms to View.\nEditing a document backed by a persistent store\ninit(editing: [PersistentModel.Type], contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store several model types.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(editing: PersistentModel.Type, contentType: UTType, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(editing: UTType, migrationPlan: SchemaMigrationPlan.Type, editor: () -> Content, prepareDocument: ((ModelContext) -> Void))\nInstantiates a document group for creating and editing documents described by the last Schema in the migration plan.\nAvailable when Document is ModelDocument and Content conforms to View.\nViewing a document backed by a persistent store\ninit(viewing: [PersistentModel.Type], contentType: UTType, viewer: () -> Content)\nInstantiates a document group for viewing documents that store several model types.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(viewing: PersistentModel.Type, contentType: UTType, viewer: () -> Content)\nInstantiates a document group for viewing documents that store a specific model type.\nAvailable when Document is ModelDocument and Content conforms to View.\ninit(viewing: UTType, migrationPlan: SchemaMigrationPlan.Type, viewer: () -> Content)\nInstantiates a document group for viewing documents described by the last Schema in the migration plan.\nAvailable when Document is ModelDocument and Content conforms to View.\nRelationships\nConforms To\nScene\nSee Also\nCreating a document\nBuilding a document-based app using SwiftData\nCode along with the WWDC presenter to transform an app with SwiftData."
    },
    {
        "title": "WindowResizability",
        "url": "https://developer.apple.com/documentation/swiftui/windowresizability",
        "html": "Overview\n\nUse the windowResizability(_:) scene modifier to apply a value of this type to a Scene that you define in your App declaration. The value that you specify indicates the strategy the system uses to place minimum and maximum size restrictions on windows that it creates from that scene.\n\nFor example, you can create a window group that people can resize to between 100 and 400 points in both dimensions by applying both a frame with those constraints to the scene\u2019s content, and the contentSize resizability to the scene:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .frame(\n                    minWidth: 100, maxWidth: 400,\n                    minHeight: 100, maxHeight: 400)\n        }\n        .windowResizability(.contentSize)\n    }\n}\n\n\nThe default value for all scenes if you don\u2019t apply the modifier is automatic. With that strategy, Settings windows use the contentSize strategy, while all others use contentMinSize.\n\nTopics\nGetting the resizability\nstatic var automatic: WindowResizability\nThe automatic window resizability.\nstatic var contentMinSize: WindowResizability\nA window resizability that\u2019s partially derived from the window\u2019s content.\nstatic var contentSize: WindowResizability\nA window resizability that\u2019s derived from the window\u2019s content.\nRelationships\nConforms To\nSendable\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window."
    },
    {
        "title": "windowResizability(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/windowresizability(_:)",
        "html": "Parameters\nresizability\n\nThe resizability to use for windows created by this scene.\n\nReturn Value\n\nA scene that uses the specified resizability strategy.\n\nDiscussion\n\nUse this scene modifier to apply a value of type WindowResizability to a Scene that you define in your App declaration. The value that you specify indicates the strategy the system uses to place minimum and maximum size restrictions on windows that it creates from that scene.\n\nFor example, you can create a window group that people can resize to between 100 and 400 points in both dimensions by applying both a frame with those constraints to the scene\u2019s content, and the contentSize resizability to the scene:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .frame(\n                    minWidth: 100, maxWidth: 400,\n                    minHeight: 100, maxHeight: 400)\n        }\n        .windowResizability(.contentSize)\n    }\n}\n\n\nThe default value for all scenes if you don\u2019t apply the modifier is automatic. With that strategy, Settings windows use the contentSize strategy, while all others use contentMinSize.\n\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "FileDocument",
        "url": "https://developer.apple.com/documentation/swiftui/filedocument",
        "html": "Overview\n\nTo store a document as a value type \u2014 like a structure \u2014 create a type that conforms to the FileDocument protocol and implement the required methods and properties. Your implementation:\n\nProvides a list of the content types that the document can read from and write to by defining readableContentTypes. If the list of content types that the document can write to is different from those that it reads from, you can optionally also define writableContentTypes.\n\nLoads documents from file in the init(configuration:) initializer.\n\nStores documents to file by serializing their content in the fileWrapper(configuration:) method.\n\nImportant\n\nIf you store your document as a reference type \u2014 like a class \u2014 use ReferenceFileDocument instead.\n\nEnsure that types that conform to this protocol are thread-safe. In particular, SwiftUI calls the protocol\u2019s methods on a background thread. Don\u2019t use that thread to perform user interface updates. Use it only to serialize and deserialize the document data.\n\nTopics\nReading a document\ninit(configuration: Self.ReadConfiguration) throws\nCreates a document and initializes it with the contents of a file.\n\nRequired\n\nstatic var readableContentTypes: [UTType]\nThe file and data types that the document reads from.\n\nRequired\n\ntypealias ReadConfiguration\nThe configuration for reading document contents.\nWriting a document\nfunc fileWrapper(configuration: Self.WriteConfiguration) throws -> FileWrapper\nSerializes a document snapshot to a file wrapper.\n\nRequired\n\nstatic var writableContentTypes: [UTType]\nThe file types that the document supports saving or exporting to.\n\nRequired Default implementation provided.\n\ntypealias WriteConfiguration\nThe configuration for writing document contents.\nSee Also\nStoring document data in a structure instance\nstruct FileDocumentConfiguration\nThe properties of an open file document."
    },
    {
        "title": "FileDocumentConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/filedocumentconfiguration",
        "html": "Overview\n\nYou receive an instance of this structure when you create a DocumentGroup with a value file type. Use it to access the document in your viewer or editor.\n\nTopics\nGetting and setting the document\nvar document: Document\nThe current document model.\nvar $document: Binding<Document>\nGetting document properties\nvar fileURL: URL?\nThe URL of the open file document.\nvar isEditable: Bool\nA Boolean that indicates whether you can edit the document.\nSee Also\nStoring document data in a structure instance\nprotocol FileDocument\nA type that you use to serialize documents to and from file."
    },
    {
        "title": "defaultPosition(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultposition(_:)",
        "html": "Parameters\nposition\n\nA UnitPoint that specifies where to place a newly opened window relative to the screen bounds.\n\nReturn Value\n\nA scene that uses a default position for new windows.\n\nDiscussion\n\nThe first time your app opens a window from a particular scene declaration, the system places the window at the center of the screen by default. For scene types that support multiple simultaneous windows, the system offsets each additional window by a small amount to avoid completely obscuring existing windows.\n\nYou can override the default placement of the first window by applying a scene modifier that indicates where to place the window relative to the screen bounds. For example, you can request that the system place a new window in the bottom trailing corner of the screen:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .defaultPosition(.bottomTrailing)\n    }\n}\n\n\nThe system aligns the point in the window that corresponds to the specified UnitPoint with the point in the screen that corresponds to the same unit point.\n\nYou typically use one of the predefined unit points \u2014 like bottomTrailing in the above example \u2014 but you can also use a custom unit point. For example, the following modifier aligns the point that\u2019s one quarter of the way from the leading edge of the window with the point that\u2019s one quarter of the way from the leading edge of the screen, while centering the window in the y-dimension:\n\nWindowGroup {\n    ContentView()\n}\n.defaultPosition(UnitPoint(x: 0.25, y: 0.5))\n\n\nThe modifier affects any scene type that creates windows in macOS, namely:\n\nWindowGroup\n\nWindow\n\nDocumentGroup\n\nSettings\n\nThe value that you provide acts only as an initial default. During state restoration, the system restores the window to the position that it last occupied.\n\nSee Also\nPositioning and sizing a window\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "Building a document-based app using SwiftData",
        "url": "https://developer.apple.com/documentation/swiftui/building-a-document-based-app-using-swiftdata",
        "html": "Overview\n\nLearn how to use @Query, @Bindable, .modelContainer, the .modelContext environment variable, and DocumentGroup to integrate with the SwiftData framework.\n\nNote\n\nThis sample code project is associated with WWDC23 session 10154: Build an app with SwiftData.\n\nSee Also\nCreating a document\nstruct DocumentGroup\nA scene that enables support for opening, creating, and saving documents."
    },
    {
        "title": "Building a Document-Based App with SwiftUI",
        "url": "https://developer.apple.com/documentation/swiftui/building_a_document-based_app_with_swiftui",
        "html": "Overview\n\nThis sample creates a checklist document that can have one or more checklist items. The user can select and deselect the checkboxes of items in the list, add and delete items, and rearrange items. The sample implements a DocumentGroup scene, and adopts the ReferenceFileDocument protocol.\n\nConfigure the Sample Code Project\n\nTo build and run this sample on your device, you must first select your development team for the project\u2019s target using these steps:\n\nOpen the sample with the latest version of Xcode.\n\nSelect the top-level project.\n\nFor the project\u2019s target, choose your team from the Team drop-down menu in the Signing & Capabilities pane to let Xcode automatically manage your provisioning profile.\n\nCreate the Data Model\n\nThis sample is a simple checklist app that keeps track of one or more items in a checklist, and whether the checkboxes of the items are in a selected state. The app has a data model that defines ChecklistItem and Checklist objects, and these objects conform to Codable to enable easy serialization. They also conform to Identifiable for unique identification during enumeration.\n\nstruct ChecklistItem: Identifiable, Codable {\n    var id = UUID()\n    var isChecked = false\n    var title: String\n}\n\n\nstruct Checklist: Identifiable, Codable {\n    var id = UUID()\n    var items: [ChecklistItem]\n}\n\n\nExport the App\u2019s Document Type\n\nThe app defines and exports a custom checklist document type that tells the operating system to open checklist documents with this app. The app does this by including an entry in its Information Property List file under the CFBundleDocumentTypes and UTExportedTypeDeclarations keys. Additionally, the sample defines the bundle\u2019s exported type as a UTType to support the sample app\u2019s data format.\n\nextension UTType {\n    static let checklistDocument = UTType(exportedAs: \"com.example.checklist\")\n}\n\n\nFor more information, see Defining file and data types for your app.\n\nDefine the App\u2019s Scene\n\nA document-based SwiftUI app returns a DocumentGroup scene from its body property. The newDocument parameter that an app supplies to the document group\u2019s init(newDocument:editor:) initializer must conform to FileDocument or ReferenceFileDocument. This sample adopts ReferenceFileDocument. The trailing closure of the initializer returns a view that renders the document\u2019s contents.\n\n@main\nstruct DocumentBasedApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: { ChecklistDocument() }) { configuration in\n            ChecklistView()\n        }\n    }\n}\n\n\nAdopt the Reference File Document Protocol\n\nThe sample\u2019s ChecklistDocument structure adopts the ReferenceFileDocument protocol to serialize checklists to and from files. This sample implements the required properties and methods to conform to the protocol. The readableContentTypes property defines the types that the sample can read, namely, the .checklistDocument type.\n\nstatic var readableContentTypes: [UTType] { [.checklistDocument] }\n\n\nThe sample reads data from a document in the init(configuration:) method. After reading the file\u2019s data, the initializer uses a JSONDecoder to deserialize the data into model objects.\n\ninit(configuration: ReadConfiguration) throws {\n    guard let data = configuration.file.regularFileContents\n    else {\n        throw CocoaError(.fileReadCorruptFile)\n    }\n    self.checklist = try JSONDecoder().decode(Checklist.self, from: data)\n}\n\n\nWhen the user saves the document, the sample returns a snapshot of the document\u2019s data for serialization in the snapshot(contentType:) instance method.\n\nfunc snapshot(contentType: UTType) throws -> Checklist {\n    checklist // Make a copy.\n}\n\n\nConversely, in the fileWrapper(configuration:) method, a JSONEncoder instance serializes the data model into a FileWrapper object that represents the data in the file system.\n\nfunc fileWrapper(snapshot: Checklist, configuration: WriteConfiguration) throws -> FileWrapper {\n    let data = try JSONEncoder().encode(snapshot)\n    let fileWrapper = FileWrapper(regularFileWithContents: data)\n    return fileWrapper\n}\n\n\nRegister Undo and Redo Actions\n\nIn an app that uses FileDocument for its document object, undo management and the registration of undo actions are automatic. However, because this sample uses a ReferenceFileDocument document class, the sample itself must perform undo management. Implementing undo management also alerts SwiftUI when the document changes. The UndoManager class handles undo management, and SwiftUI supplies an instance of this class in the environment.\n\n@Environment(\\.undoManager) var undoManager\n\n\nIn this sample, the SwiftUI views handle user actions by calling the ChecklistDocument and passing along the UndoManager object.\n\ndocument.toggleItem($item.wrappedValue, undoManager: undoManager)\n\n\nThe ChecklistDocument toggles the isChecked state of the ChecklistItem, and registers an undo action that calls itself. This way, the sample doesn\u2019t need to register a redo action when performing an undo action.\n\nfunc toggleItem(_ item: ChecklistItem, undoManager: UndoManager? = nil) {\n    let index = checklist.items.firstIndex(of: item)!\n    \n    checklist.items[index].isChecked.toggle()\n    \n    undoManager?.registerUndo(withTarget: self) { doc in\n        // Because it calls itself, this is redoable, as well.\n        doc.toggleItem(item, undoManager: undoManager)\n    }\n}\n"
    },
    {
        "title": "DismissAction",
        "url": "https://developer.apple.com/documentation/swiftui/dismissaction",
        "html": "Overview\n\nUse the dismiss environment value to get the instance of this structure for a given Environment. Then call the instance to perform the dismissal. You call the instance directly because it defines a callAsFunction() method that Swift calls when you call the instance.\n\nYou can use this action to:\n\nDismiss a modal presentation, like a sheet or a popover.\n\nPop the current view from a NavigationStack.\n\nClose a window that you create with WindowGroup or Window.\n\nThe specific behavior of the action depends on where you call it from. For example, you can create a button that calls the DismissAction inside a view that acts as a sheet:\n\nprivate struct SheetContents: View {\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        Button(\"Done\") {\n            dismiss()\n        }\n    }\n}\n\n\nWhen you present the SheetContents view, someone can dismiss the sheet by tapping or clicking the sheet\u2019s button:\n\nprivate struct DetailView: View {\n    @State private var isSheetPresented = false\n\n\n    var body: some View {\n        Button(\"Show Sheet\") {\n            isSheetPresented = true\n        }\n        .sheet(isPresented: $isSheetPresented) {\n            SheetContents()\n        }\n    }\n}\n\n\nBe sure that you define the action in the appropriate environment. For example, don\u2019t reorganize the DetailView in the example above so that it creates the dismiss property and calls it from the sheet(item:onDismiss:content:) view modifier\u2019s content closure:\n\nprivate struct DetailView: View {\n    @State private var isSheetPresented = false\n    @Environment(\\.dismiss) private var dismiss // Applies to DetailView.\n\n\n    var body: some View {\n        Button(\"Show Sheet\") {\n            isSheetPresented = true\n        }\n        .sheet(isPresented: $isSheetPresented) {\n            Button(\"Done\") {\n                dismiss() // Fails to dismiss the sheet.\n            }\n        }\n    }\n}\n\n\nIf you do this, the sheet fails to dismiss because the action applies to the environment where you declared it, which is that of the detail view, rather than the sheet. In fact, in macOS and iPadOS, if the DetailView is the root view of a window, the dismiss action closes the window instead.\n\nThe dismiss action has no effect on a view that isn\u2019t currently presented. If you need to query whether SwiftUI is currently presenting a view, read the isPresented environment value.\n\nTopics\nCalling the action\nfunc callAsFunction()\nDismisses the view if it is currently presented.\nSee Also\nDismissing a presentation\nvar isPresented: Bool\nA Boolean value that indicates whether the view associated with this environment is currently presented.\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nfunc interactiveDismissDisabled(Bool) -> some View\nConditionally prevents interactive dismissal of presentations like popovers, sheets, and inspectors."
    },
    {
        "title": "WindowToolbarStyle",
        "url": "https://developer.apple.com/documentation/swiftui/windowtoolbarstyle",
        "html": "Topics\nGetting built-in window toolbar styles\nstatic var automatic: DefaultWindowToolbarStyle\nThe automatic window toolbar style.\nAvailable when Self is DefaultWindowToolbarStyle.\nstatic var expanded: ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nAvailable when Self is ExpandedWindowToolbarStyle.\nstatic var unified: UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic func unified(showsTitle: Bool) -> UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nAvailable when Self is UnifiedWindowToolbarStyle.\nstatic var unifiedCompact: UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle.\nstatic func unifiedCompact(showsTitle: Bool) -> UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nAvailable when Self is UnifiedCompactWindowToolbarStyle.\nSupporting types\nstruct DefaultWindowToolbarStyle\nThe default window toolbar style.\nstruct ExpandedWindowToolbarStyle\nA window toolbar style which displays its title bar area above the toolbar.\nstruct UnifiedWindowToolbarStyle\nA window toolbar style which displays its toolbar and title bar inline.\nstruct UnifiedCompactWindowToolbarStyle\nA window toolbar style similar to unified, but with a more compact vertical sizing.\nRelationships\nConforming Types\nDefaultWindowToolbarStyle\nExpandedWindowToolbarStyle\nUnifiedCompactWindowToolbarStyle\nUnifiedWindowToolbarStyle\nSee Also\nStyling a toolbar\nfunc toolbarBackground<S>(S, for: ToolbarPlacement...) -> some View\nSpecifies the preferred shape style of the background of a bar managed by SwiftUI.\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the preferred visibility of backgrounds on a bar managed by SwiftUI.\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> some View\nSpecifies the preferred color scheme of a bar managed by SwiftUI.\nfunc windowToolbarStyle<S>(S) -> some Scene\nSets the style for the toolbar defined within this scene."
    },
    {
        "title": "windowToolbarStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/windowtoolbarstyle(_:)",
        "html": "See Also\nStyling a toolbar\nfunc toolbarBackground<S>(S, for: ToolbarPlacement...) -> some View\nSpecifies the preferred shape style of the background of a bar managed by SwiftUI.\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the preferred visibility of backgrounds on a bar managed by SwiftUI.\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> some View\nSpecifies the preferred color scheme of a bar managed by SwiftUI.\nprotocol WindowToolbarStyle\nA specification for the appearance and behavior of a window\u2019s toolbar."
    },
    {
        "title": "openWindow",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/openwindow",
        "html": "Discussion\n\nUse the openWindow environment value to get an OpenWindowAction instance for a given Environment. Then call the instance to open a window. You call the instance directly because it defines a callAsFunction(id:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that opens a new mail viewer window:\n\n@main\nstruct Mail: App {\n    var body: some Scene {\n        WindowGroup(id: \"mail-viewer\") {\n            MailViewer()\n        }\n    }\n}\n\n\nstruct NewViewerButton: View {\n    @Environment(\\.openWindow) private var openWindow\n\n\n    var body: some View {\n        Button(\"Open new mail viewer\") {\n            openWindow(id: \"mail-viewer\")\n        }\n    }\n}\n\n\nYou indicate which scene to open by providing one of the following:\n\nA string identifier that you pass through the id parameter, as in the above example.\n\nA value parameter that has a type that matches the type that you specify in the scene\u2019s initializer.\n\nBoth an identifier and a value. This enables you to define multiple window groups that take input values of the same type like a UUID.\n\nUse the first option to target either a WindowGroup or a Window scene in your app that has a matching identifier. For a WindowGroup, the system creates a new window for the group. If the window group presents data, the system provides the default value or nil to the window\u2019s root view. If the targeted scene is a Window, the system orders it to the front.\n\nUse the other two options to target a WindowGroup and provide a value to present. If the interface already has a window from the group that\u2019s presenting the specified value, the system brings the window to the front. Otherwise, the system creates a new window and passes a binding to the specified value.\n\nSee Also\nOpening windows\nvar supportsMultipleWindows: Bool\nA Boolean value that indicates whether the current platform supports opening multiple windows.\nstruct OpenWindowAction\nAn action that presents a window."
    },
    {
        "title": "DismissBehavior",
        "url": "https://developer.apple.com/documentation/swiftui/dismissbehavior",
        "html": "Overview\n\nUse values of this type to control window dismissal during the current transaction.\n\nFor example, to dismiss windows showing a modal presentation that would otherwise prohibit dismissal, use the destructive behavior:\n\nstruct DismissWindowButton: View {\n    @Environment(\\.dismissWindow) private var dismissWindow\n\n\n    var body: some View {\n        Button(\"Close Auxiliary Window\") {\n            withTransaction(\\.dismissBehavior, .destructive) {\n                dismissWindow(id: \"auxiliary\")\n            }\n        }\n    }\n}\n\nTopics\nGetting behaviors\nstatic let destructive: DismissBehavior\nThe destructive dismiss behavior.\nstatic let interactive: DismissBehavior\nThe interactive dismiss behavior.\nRelationships\nConforms To\nSendable\nSee Also\nClosing windows\nvar dismissWindow: DismissWindowAction\nA window dismissal action stored in a view\u2019s environment.\nstruct DismissWindowAction\nAn action that dismisses a window associated to a particular scene.\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nstruct DismissAction\nAn action that dismisses a presentation."
    },
    {
        "title": "OpenWindowAction",
        "url": "https://developer.apple.com/documentation/swiftui/openwindowaction",
        "html": "Overview\n\nUse the openWindow environment value to get the instance of this structure for a given Environment. Then call the instance to open a window. You call the instance directly because it defines a callAsFunction(id:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that opens a new mail viewer window:\n\n@main\nstruct Mail: App {\n    var body: some Scene {\n        WindowGroup(id: \"mail-viewer\") {\n            MailViewer()\n        }\n    }\n}\n\n\nstruct NewViewerButton: View {\n    @Environment(\\.openWindow) private var openWindow\n\n\n    var body: some View {\n        Button(\"Open new mail viewer\") {\n            openWindow(id: \"mail-viewer\")\n        }\n    }\n}\n\n\nYou indicate which scene to open by providing one of the following:\n\nA string identifier that you pass through the id parameter, as in the above example.\n\nA value parameter that has a type that matches the type that you specify in the scene\u2019s initializer.\n\nBoth an identifier and a value. This enables you to define multiple window groups that take input values of the same type, like a UUID.\n\nUse the first option to target either a WindowGroup or a Window scene in your app that has a matching identifier. For a WindowGroup, the system creates a new window for the group. If the window group presents data, the system provides the default value or nil to the window\u2019s root view. If the targeted scene is a Window, the system orders it to the front.\n\nUse the other two options to target a WindowGroup and provide a value to present. If the interface already has a window from the group that\u2019s presenting the specified value, the system brings the window to the front. Otherwise, the system creates a new window and passes a binding to the specified value.\n\nTopics\nCalling the action\nfunc callAsFunction(id: String)\nOpens a window that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(id: String, value: D)\nOpens a window defined by the window group that presents the specified value type and that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(value: D)\nOpens a window defined by a window group that presents the type of the specified value.\nSee Also\nOpening windows\nvar supportsMultipleWindows: Bool\nA Boolean value that indicates whether the current platform supports opening multiple windows.\nvar openWindow: OpenWindowAction\nA window presentation action stored in a view\u2019s environment."
    },
    {
        "title": "DismissWindowAction",
        "url": "https://developer.apple.com/documentation/swiftui/dismisswindowaction",
        "html": "Overview\n\nUse the dismissWindow environment value to get the instance of this structure for a given Environment. Then call the instance to dismiss a window. You call the instance directly because it defines a callAsFunction(id:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that closes an auxiliary window:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        #if os(macOS)\n        Window(\"Auxiliary\", id: \"auxiliary\") {\n            AuxiliaryContentView()\n        }\n        #endif\n    }\n}\n\n\nstruct DismissWindowButton: View {\n    @Environment(\\.dismissWindow) private var dismissWindow\n\n\n    var body: some View {\n        Button(\"Close Auxiliary Window\") {\n            dismissWindow(id: \"auxiliary\")\n        }\n    }\n}\n\nTopics\nCalling the action\nfunc callAsFunction()\nDismisses the current window.\nfunc callAsFunction(id: String)\nDismisses the window that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(id: String, value: D)\nDismisses the window defined by the window group that is presenting the specified value type and that\u2019s associated with the specified identifier.\nfunc callAsFunction<D>(value: D)\nDismisses the window defined by the window group that is presenting the specified value type.\nSee Also\nClosing windows\nvar dismissWindow: DismissWindowAction\nA window dismissal action stored in a view\u2019s environment.\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nstruct DismissAction\nAn action that dismisses a presentation.\nstruct DismissBehavior\nProgrammatic window dismissal behaviors."
    },
    {
        "title": "WindowStyle",
        "url": "https://developer.apple.com/documentation/swiftui/windowstyle",
        "html": "Topics\nGetting built-in window styles\nstatic var automatic: DefaultWindowStyle\nThe default window style.\nAvailable when Self is DefaultWindowStyle.\nstatic var hiddenTitleBar: HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nAvailable when Self is HiddenTitleBarWindowStyle.\nstatic var plain: PlainWindowStyle\nThe plain window style.\nAvailable when Self is PlainWindowStyle.\nBeta\nstatic var titleBar: TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nAvailable when Self is TitleBarWindowStyle.\nstatic var volumetric: VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nAvailable when Self is VolumetricWindowStyle.\nBeta\nSupporting types\nstruct DefaultWindowStyle\nThe default window style.\nstruct HiddenTitleBarWindowStyle\nA window style which hides both the window\u2019s title and the backing of the titlebar area, allowing more of the window\u2019s content to show.\nstruct PlainWindowStyle\nThe plain window style.\nBeta\nstruct TitleBarWindowStyle\nA window style which displays the title bar section of the window.\nstruct VolumetricWindowStyle\nA window style that creates a 3D volumetric window.\nBeta\nRelationships\nConforming Types\nDefaultWindowStyle\nHiddenTitleBarWindowStyle\nPlainWindowStyle\nTitleBarWindowStyle\nVolumetricWindowStyle\nSee Also\nCreating windows\nstruct WindowGroup\nA scene that presents a group of identically structured windows.\nstruct Window\nA scene that presents its content in a single, unique window.\nfunc windowStyle<S>(S) -> some Scene\nSets the style for windows created by this scene."
    },
    {
        "title": "Window",
        "url": "https://developer.apple.com/documentation/swiftui/window",
        "html": "Overview\n\nUse a Window scene to augment the main interface of your app with a window that gives people access to supplemental functionality. For example, you can create a secondary window in a mail reader app that enables people to view the status of their account connections:\n\n @main\n struct Mail: App {\n     var body: some Scene {\n         WindowGroup {\n             MailViewer()\n         }\n         Window(\"Connection Doctor\", id: \"connection-doctor\") {\n             ConnectionDoctor()\n         }\n     }\n }\n\n\nProvide a title as the first argument to the window\u2019s intializer. The system uses the title to identify the window to people using your app in the window\u2019s title bar or in the list of available singleton windows that the Windows menu displays automatically.\n\nNote\n\nYou can override the title in the window\u2019s title bar by adding one of the navigationTitle(_:) view modifiers to the window\u2019s content. This enables you to dynamically update the title bar.\n\nOpen a window programmatically\n\nPeople open the window by selecting it in the Windows menu, but you can also open the window programmatically using the openWindow action that you read from the environment. Use the id parameter that you initialize the window with to indicate which window to open. For example, you can create a button to open the window from the previous example:\n\nstruct OpenConnectionDoctorButton: View {\n    @Environment(\\.openWindow) private var openWindow\n\n\n    var body: some View {\n        Button(\"Connection doctor\") {\n            openWindow(id: \"connection-doctor\") // Match the window's identifier.\n        }\n    }\n}\n\n\nIf the window is already open when you call this action, the action brings the open window to the front. Be sure to use unique identifiers across all of the Window and WindowGroup instances that you define.\n\nDismiss a window programmatically\n\nThe system provides people with controls to close windows, but you can also close a window programmatically using the dismiss action from within the window\u2019s view hierarchy. For example, you can include a button in the connection doctor view that dismisses the view:\n\nstruct ConnectionDoctor: View {\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        VStack {\n            // ...\n\n\n            Button(\"Dismiss\") {\n                dismiss()\n            }\n        }\n    }\n}\n\n\nThe dismiss action doesn\u2019t close the window if you call it from a modal \u2014 like a sheet or a popover \u2014 that you present from within the window. In that case, the action dismisses the modal presentation instead.\n\nUse a window as the main scene\n\nYou can use a window as the main scene of your app when multi-window functionality isn\u2019t appropriate. For example, it might not make sense to display more than one window for a video call app that relies on a hardware resource, like a camera:\n\n@main\nstruct VideoCall: App {\n    var body: some Scene {\n        Window(\"VideoCall\", id: \"main\") {\n            CameraView()\n        }\n    }\n}\n\n\nIf your app uses a single window as its primary scene, the app quits when the window closes. This behavior differs from an app that uses a WindowGroup as its primary scene, where the app continues to run even after closing all of its windows.\n\nNote\n\nIn most cases it\u2019s best to use a WindowGroup to represent the main scene of your app. A window group provides multi-window functionality on platforms that support it, like iPadOS and macOS, and makes it easier to share code across platforms.\n\nTopics\nCreating a window\ninit(LocalizedStringKey, id: String, content: () -> Content)\nCreates a window with a localized title and an identifier.\ninit<S>(S, id: String, content: () -> Content)\nCreates a window with a title string and an identifier.\ninit(Text, id: String, content: () -> Content)\nCreates a window with a title and an identifier.\nRelationships\nConforms To\nScene\nSee Also\nCreating windows\nstruct WindowGroup\nA scene that presents a group of identically structured windows.\nprotocol WindowStyle\nA specification for the appearance and interaction of a window.\nfunc windowStyle<S>(S) -> some Scene\nSets the style for windows created by this scene."
    },
    {
        "title": "Bringing multiple windows to your SwiftUI app",
        "url": "https://developer.apple.com/documentation/swiftui/bringing_multiple_windows_to_your_swiftui_app",
        "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC22 session 10061: Bring multiple windows to your SwiftUI app.\n\nConfigure the sample code project\n\nBefore you run the sample code project in Xcode:\n\nTo run the sample on an iOS device or Mac, make sure you select your team in the Signing & Capabilities tab in each target\u2019s settings."
    },
    {
        "title": "progressive",
        "url": "https://developer.apple.com/documentation/swiftui/immersionstyle/progressive",
        "html": "Discussion\n\nThe system initially uses a radial portal effect. People can interactively dial in and out to switch between the portal style and a style that matches the FullImmersionStyle. In the case of the latter, passthrough is obscured except for people\u2019s hands if configured accordingly.\n\nSee Also\nGetting built-in styles\nstatic var automatic: AutomaticImmersionStyle\nThe default immersion style.\nAvailable when Self is AutomaticImmersionStyle.\nBeta\nstatic var full: FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video, except for the user\u2019s hands, if configured accordingly.\nAvailable when Self is FullImmersionStyle.\nBeta\nstatic var mixed: MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nAvailable when Self is MixedImmersionStyle.\nBeta"
    },
    {
        "title": "mixed",
        "url": "https://developer.apple.com/documentation/swiftui/immersionstyle/mixed",
        "html": "See Also\nGetting built-in styles\nstatic var automatic: AutomaticImmersionStyle\nThe default immersion style.\nAvailable when Self is AutomaticImmersionStyle.\nBeta\nstatic var full: FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video, except for the user\u2019s hands, if configured accordingly.\nAvailable when Self is FullImmersionStyle.\nBeta\nstatic var progressive: ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nAvailable when Self is ProgressiveImmersionStyle.\nBeta"
    },
    {
        "title": "OpenImmersiveSpaceAction",
        "url": "https://developer.apple.com/documentation/swiftui/openimmersivespaceaction",
        "html": "Overview\n\nIf the targeted immersive space accepts data, the system provides the value that you pass to the action to the space\u2019s content closure.\n\nUse the openImmersiveSpace environment value to get the instance of this structure for a given Environment. Then call the instance to present a space. You call the instance directly because it defines a callAsFunction(id:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that opens the specified solar system item in a new immersive space:\n\n@main\nstruct SolarSystemApp: App {\n    var body: some Scene {\n        ImmersiveSpace(for: SolarSystem.ID.self) { $solarSystemID in\n            // ...\n        }\n    }\n}\n\n\nstruct NewSolarSystemImmersiveSpace: View {\n    var solarSystem: SolarSystem\n    @Environment(\\.openImmersiveSpace) private var openImmersiveSpace\n\n\n    var body: some View {\n        Button(\"Present Solar System In New Immersive Space\") {\n            Task {\n                await openImmersiveSpace(value: solarSystem.ID)\n            }\n        }\n    }\n}\n\n\nFor best performance, use lightweight data for the presentation value. For structured model values that conform to Identifiable, the value\u2019s identifier makes a good presentation value.\n\nTopics\nCalling the action\nfunc callAsFunction(id: String) async -> OpenImmersiveSpaceAction.Result\nPresents an immersive space for the scene with the specified identifier.\nfunc callAsFunction<D>(id: String, value: D) async -> OpenImmersiveSpaceAction.Result\nPresents the immersive space that your app defines for the specified identifier and that handles the type of the presented value.\nfunc callAsFunction<D>(value: D) async -> OpenImmersiveSpaceAction.Result\nPresents the immersive space that handles the type of the presented value.\nGetting the result\nenum Result\nRepresents the result of opening an immersive space.\nRelationships\nConforms To\nSendable\nSee Also\nOpening an immersive space\nvar openImmersiveSpace: OpenImmersiveSpaceAction\nAn action that presents an immersive space.\nBeta"
    },
    {
        "title": "ImmersionStyle",
        "url": "https://developer.apple.com/documentation/swiftui/immersionstyle",
        "html": "Overview\n\nThe style affects the appearance and behavior of the immersive space. To configure the current style of an immersive space, use the immersionStyle(selection:in:) modifier. Specify a style that conforms to ImmersionStyle when creating a space.\n\nTopics\nGetting built-in styles\nstatic var automatic: AutomaticImmersionStyle\nThe default immersion style.\nAvailable when Self is AutomaticImmersionStyle.\nstatic var full: FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video, except for the user\u2019s hands, if configured accordingly.\nAvailable when Self is FullImmersionStyle.\nstatic var mixed: MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nAvailable when Self is MixedImmersionStyle.\nstatic var progressive: ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nAvailable when Self is ProgressiveImmersionStyle.\nSupporting types\nstruct AutomaticImmersionStyle\nThe default style of immersive spaces.\nstruct FullImmersionStyle\nAn immersion style that displays unbounded content that obscures passthrough video.\nstruct MixedImmersionStyle\nAn immersion style that displays unbounded content intermixed with other app content, along with passthrough video.\nstruct ProgressiveImmersionStyle\nAn immersion style where content displays with no clipping boundaries applied.\nRelationships\nConforming Types\nAutomaticImmersionStyle\nFullImmersionStyle\nMixedImmersionStyle\nProgressiveImmersionStyle\nSee Also\nCreating an immersive space\nstruct ImmersiveSpace\nA scene that presents its content in an unbounded space.\nBeta\nstruct ImmersiveSpaceContentBuilder\nA result builder for composing a collection of immersive space elements.\nBeta\nfunc immersionStyle(selection: Binding<ImmersionStyle>, in: ImmersionStyle...) -> some Scene\nSets the allowed styles for the immersive space.\nBeta"
    },
    {
        "title": "dismissImmersiveSpace",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/dismissimmersivespace",
        "html": "Discussion\n\nThe call returns once the immersive space is dismissed.\n\nUse the dismissImmersiveSpace environment value to get an DismissImmersiveSpaceAction instance for a given Environment. Then call the instance to dismiss a space. You call the instance directly because it defines a callAsFunction() method that Swift calls when you call the instance.\n\nFor example, you can define a button that dismisses an immersive space:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        ImmersiveSpace(id: \"solarSystem\") {\n            SolarSystemView()\n        }\n    }\n}\n\n\nstruct DismissImmersiveSpaceButton: View {\n    @Environment(\\.dismissImmersiveSpace)\n    private var dismissImmersiveSpace\n\n\n    var body: some View {\n        Button(\"Close Solar System Immersive Space\") {\n            Task {\n                await dismissImmersiveSpace()\n                print(\"Dismissing complete\")\n            }\n        }\n    }\n}\n\nSee Also\nClosing the immersive space\nstruct DismissImmersiveSpaceAction\nAn action that dismisses an immersive space.\nBeta"
    },
    {
        "title": "openImmersiveSpace",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/openimmersivespace",
        "html": "Discussion\n\nThe call returns either once the space is presented, or once an error occurred.\n\nIf the targeted scene accepts data, then the value passed to the action that you pass to the action to the scene\u2019s content closure.\n\nUse the openImmersiveSpace environment value to get the instance of this structure for a given Environment. Then call the instance to present a space. You call the instance directly because it defines a callAsFunction(id:) method that Swift calls when you call the instance.\n\nFor example, you can define a button that opens the specified solar system value in a new space.\n\n@main\nstruct SolarSystemApp: App {\n    var body: some Scene {\n        ImmersiveSpace(for: SolarSystem.ID.self) { $solarSystemID in\n            // ...\n        }\n    }\n}\n\n\nstruct NewSolarSystemImmersiveSpace: View {\n    var solarSystem: SolarSystem\n    @Environment(\\.openImmersiveSpace)\n    private var openImmersiveSpace\n\n\n    var body: some View {\n        Button(\"Present Solar System In New Immersive Space\") {\n            Task {\n                await openImmersiveSpace(value: solarSystem.ID)\n            }\n        }\n    }\n}\n\nSee Also\nOpening an immersive space\nstruct OpenImmersiveSpaceAction\nAn action that presents an immersive space.\nBeta"
    },
    {
        "title": "ImmersiveSpaceContentBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/immersivespacecontentbuilder",
        "html": "Topics\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nSee Also\nCreating an immersive space\nstruct ImmersiveSpace\nA scene that presents its content in an unbounded space.\nBeta\nfunc immersionStyle(selection: Binding<ImmersionStyle>, in: ImmersionStyle...) -> some Scene\nSets the allowed styles for the immersive space.\nBeta\nprotocol ImmersionStyle\nThe styles that an immersive space can have.\nBeta"
    },
    {
        "title": "commands(content:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/commands(content:)",
        "html": "Discussion\n\nCommands are realized in different ways on different platforms. On macOS, the main menu uses the available command menus and groups to organize its main menu items. Each menu is represented as a top-level menu bar menu, and each command group has a corresponding set of menu items in one of the top-level menus, delimited by separator menu items.\n\nOn iPadOS, commands with keyboard shortcuts are exposed in the shortcut discoverability HUD that users see when they hold down the Command (\u2318) key.\n\nSee Also\nDefining commands\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to."
    },
    {
        "title": "WindowGroup",
        "url": "https://developer.apple.com/documentation/swiftui/windowgroup",
        "html": "Overview\n\nUse a WindowGroup as a container for a view hierarchy that your app presents. The hierarchy that you declare as the group\u2019s content serves as a template for each window that the app creates from that group:\n\n@main\nstruct Mail: App {\n    var body: some Scene {\n        WindowGroup {\n            MailViewer() // Define a view hierarchy for the window.\n        }\n    }\n}\n\n\nSwiftUI takes care of certain platform-specific behaviors. For example, on platforms that support it, like macOS and iPadOS, people can open more than one window from the group simultaneously. In macOS, people can gather open windows together in a tabbed interface. Also in macOS, window groups automatically provide commands for standard window management.\n\nImportant\n\nTo enable an iPadOS app to simultaneously display multiple windows, be sure to include the UIApplicationSupportsMultipleScenes key with a value of true in the UIApplicationSceneManifest dictionary of your app\u2019s Information Property List.\n\nEvery window in the group maintains independent state. For example, the system allocates new storage for any State or StateObject variables instantiated by the scene\u2019s view hierarchy for each window that it creates.\n\nFor document-based apps, use DocumentGroup to define windows instead.\n\nOpen windows programmatically\n\nIf you initialize a window group with an identifier, a presentation type, or both, you can programmatically open a window from the group. For example, you can give the mail viewer scene from the previous example an identifier:\n\nWindowGroup(id: \"mail-viewer\") { // Identify the window group.\n    MailViewer()\n}\n\n\nElsewhere in your code, you can use the openWindow action from the environment to create a new window from the group:\n\nstruct NewViewerButton: View {\n    @Environment(\\.openWindow) private var openWindow\n\n\n    var body: some View {\n        Button(\"Open new mail viewer\") {\n            openWindow(id: \"mail-viewer\") // Match the group's identifier.\n        }\n    }\n}\n\n\nBe sure to use unique strings for identifiers that you apply to window groups in your app.\n\nPresent data in a window\n\nIf you initialize a window group with a presentation type, you can pass data of that type to the window when you open it. For example, you can define a second window group for the Mail app that displays a specified message:\n\n@main\nstruct Mail: App {\n    var body: some Scene {\n        WindowGroup {\n            MailViewer(id: \"mail-viewer\")\n        }\n\n\n        // A window group that displays messages.\n        WindowGroup(for: Message.ID.self) { $messageID in\n            MessageDetail(messageID: messageID)\n        }\n    }\n}\n\n\nWhen you call the openWindow action with a value, SwiftUI finds the window group with the matching type and passes a binding to the value into the window group\u2019s content closure. For example, you can define a button that opens a message by passing the message\u2019s identifier:\n\nstruct NewMessageButton: View {\n    var message: Message\n    @Environment(\\.openWindow) private var openWindow\n\n\n    var body: some View {\n        Button(\"Open message\") {\n            openWindow(value: message.id)\n        }\n    }\n}\n\n\nBe sure that the type you present conforms to both the Hashable and Codable protocols. Also, prefer lightweight data for the presentation value. For model values that conform to the Identifiable protocol, the value\u2019s identifier works well as a presentation type, as the above example demonstrates.\n\nIf a window with a binding to the same value that you pass to the openWindow action already appears in the user interface, the system brings the existing window to the front rather than opening a new window. If SwiftUI doesn\u2019t have a value to provide \u2014 for example, when someone opens a window by choosing File > New Window from the macOS menu bar \u2014 SwiftUI passes a binding to a nil value instead. To avoid receiving a nil value, you can optionally specify a default value in your window group initializer. For example, for the message viewer, you can present a new empty message:\n\nWindowGroup(for: Message.ID.self) { $messageID in\n    MessageDetail(messageID: messageID)\n} defaultValue: {\n    model.makeNewMessage().id // A new message that your model stores.\n}\n\n\nSwiftUI persists the value of the binding for the purposes of state restoration, and reapplies the same value when restoring the window. If the restoration process results in an error, SwiftUI sets the binding to the default value if you provide one, or nil otherwise.\n\nTitle your app\u2019s windows\n\nTo help people distinguish among windows from different groups, include a title as the first parameter in the group\u2019s initializer:\n\nWindowGroup(\"Message\", for: Message.ID.self) { $messageID in\n    MessageDetail(messageID: messageID)\n}\n\n\nSwiftUI uses this title when referring to the window in:\n\nThe list of new windows that someone can open using the File > New menu.\n\nThe window\u2019s title bar.\n\nThe list of open windows that the Window menu displays.\n\nIf you don\u2019t provide a title for a window, the system refers to the window using the app\u2019s name instead.\n\nNote\n\nYou can override the title that SwiftUI uses for a window in the window\u2019s title bar and the menu\u2019s list of open windows by adding one of the navigationTitle(_:) modifiers to the window\u2019s content. This enables you to customize and dynamically update the title for each individual window instance.\n\nDistinguish windows that present like data\n\nTo programmatically distinguish between windows that present the same type of data, like when you use a UUID as the identifier for more than one model type, add the id parameter to the group\u2019s initializer to provide a unique string identifier:\n\nWindowGroup(\"Message\", id: \"message\", for: UUID.self) { $uuid in\n    MessageDetail(uuid: uuid)\n}\nWindowGroup(\"Account\", id: \"account-info\", for: UUID.self) { $uuid in\n    AccountDetail(uuid: uuid)\n}\n\n\nThen use both the identifer and a value to open the window:\n\nstruct ActionButtons: View {\n    var messageID: UUID\n    var accountID: UUID\n\n\n    @Environment(\\.openWindow) private var openWindow\n\n\n    var body: some View {\n        HStack {\n            Button(\"Open message\") {\n                openWindow(id: \"message\", value: messageID)\n            }\n            Button(\"Edit account information\") {\n                openWindow(id: \"account-info\", value: accountID)\n            }\n        }\n    }\n}\n\nDismiss a window programmatically\n\nThe system provides people with platform-appropriate controls to dismiss a window. You can also dismiss windows programmatically by calling the dismiss action from within the window\u2019s view hierarchy. For example, you can include a button in the account detail view from the previous example that dismisses the view:\n\nstruct AccountDetail: View {\n    var uuid: UUID?\n    @Environment(\\.dismiss) private var dismiss\n\n\n    var body: some View {\n        VStack {\n            // ...\n\n\n            Button(\"Dismiss\") {\n                dismiss()\n            }\n        }\n    }\n}\n\n\nThe dismiss action doesn\u2019t close the window if you call it from a modal \u2014 like a sheet or a popover \u2014 that you present from the window. In that case, the action dismisses the modal presentation instead.\n\nTopics\nCreating a window group\ninit(content: () -> Content)\nCreates a window group.\ninit(Text, content: () -> Content)\nCreates a window group with a text view title.\ninit(LocalizedStringKey, content: () -> Content)\nCreates a window group with a localized title string.\ninit<S>(S, content: () -> Content)\nCreates a window group with a title string.\nIdentifying a window group\ninit(id: String, content: () -> Content)\nCreates a window group with an identifier.\ninit(Text, id: String, content: () -> Content)\nCreates a window group with a text view title and an identifier.\ninit(LocalizedStringKey, id: String, content: () -> Content)\nCreates a window group with a localized title string and an identifier.\ninit<S>(S, id: String, content: () -> Content)\nCreates a window group with a title string and an identifier.\nCreating a data-driven window group\ninit<D, C>(for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string.\nAvailable when Content conforms to View.\ninit<D, C>(Text, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title.\nAvailable when Content conforms to View.\nProviding default data to a window group\ninit<D, C>(for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a default value.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a localized title string and a default value.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a title string and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(Text, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a text view title and a default value.\nAvailable when Content conforms to View.\nIdentifying a data-driven window group\ninit<D, C>(id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with an identifier.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a localized title string and an identifier.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a title string and an identifier.\nAvailable when Content conforms to View.\ninit<D, C>(Text, id: String, for: D.Type, content: (Binding<D?>) -> C)\nCreates a data-presenting window group with a text view title and an identifier.\nAvailable when Content conforms to View.\nIdentifying a window group that has default data\ninit<D, C>(id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with an identifier and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(LocalizedStringKey, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a localized title string, an identifier, and a default value.\nAvailable when Content conforms to View.\ninit<S, D, C>(S, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a title string, an identifier, and a default value.\nAvailable when Content conforms to View.\ninit<D, C>(Text, id: String, for: D.Type, content: (Binding<D>) -> C, defaultValue: () -> D)\nCreates a data-presenting window group with a text view title, an identifier, and a default value.\nAvailable when Content conforms to View.\nSupporting types\nstruct PresentedWindowContent\nA view that represents the content of a presented window.\nRelationships\nConforms To\nScene\nSee Also\nCreating windows\nstruct Window\nA scene that presents its content in a single, unique window.\nprotocol WindowStyle\nA specification for the appearance and interaction of a window.\nfunc windowStyle<S>(S) -> some Scene\nSets the style for windows created by this scene."
    },
    {
        "title": "MenuBarExtra",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextra",
        "html": "Overview\n\nUse a MenuBarExtra when you want to provide access to commonly used functionality, even when your app is not active.\n\n@main\nstruct AppWithMenuBarExtra: App {\n    @AppStorage(\"showMenuBarExtra\") private var showMenuBarExtra = true\n\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        MenuBarExtra(\n            \"App Menu Bar Extra\", systemImage: \"star\",\n            isInserted: $showMenuBarExtra)\n        {\n            StatusMenu()\n        }\n    }\n}\n\n\nOr alternatively, to create a utility app that only shows in the menu bar.\n\n@main\nstruct UtilityApp: App {\n    var body: some Scene {\n        MenuBarExtra(\"Utility App\", systemImage: \"hammer\") {\n            AppMenu()\n        }\n    }\n}\n\n\nAn app that only shows in the menu bar will be automatically terminated if the user removes the extra from the menu bar.\n\nFor apps that only show in the menu bar, a common behavior is for the app to not display its icon in either the Dock or the application switcher. To enable this behavior, set the LSUIElement flag in your app\u2019s Information Property List file to true.\n\nFor more complex or data rich menu bar extras, you can use the window style, which displays a popover-like window from the menu bar icon that contains standard controls. You define the layout and contents of those controls with the content that you provide:\n\nMenuBarExtra(\"Utility App\", systemImage: \"hammer\") {\n    ScrollView {\n        LazyVGrid(...)\n    }\n}\n.menuBarExtraStyle(.window)\n\nTopics\nCreating a menu bar extra\ninit(LocalizedStringKey, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The extra defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item defines the primary scene of an App.\nAvailable when Label is Text and Content conforms to View.\ninit(content: () -> Content, label: () -> Label)\nCreates a menu bar extra that will be displayed in the system menu bar, and defines the primary scene of an App.\ninit(LocalizedStringKey, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a key for a localized string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit<S>(S, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a string to use as the label. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nAvailable when Label is Text and Content conforms to View.\ninit(isInserted: Binding<Bool>, content: () -> Content, label: () -> Label)\nCreates a menu bar extra. The item will be displayed in the system menu bar when the specified binding is set to true. If the user removes the item from the menu bar, the binding will be set to false.\nCreating a menu bar extra with a named image\ninit(LocalizedStringKey, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a named image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\nCreating a menu bar extra with a system image\ninit(LocalizedStringKey, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, systemImage: String, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with a system image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\nCreating a menu bar extra with an image resource\ninit(LocalizedStringKey, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit(LocalizedStringKey, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\ninit<S>(S, image: ImageResource, isInserted: Binding<Bool>, content: () -> Content)\nCreates a menu bar extra with an image to use as the items label. The provided title will be used by the accessibility system.\nAvailable when Label is Label<Text, Image> and Content conforms to View.\nRelationships\nConforms To\nScene\nSee Also\nCreating a menu bar extra\nfunc menuBarExtraStyle<S>(S) -> some Scene\nSets the style for menu bar extra created by this scene.\nprotocol MenuBarExtraStyle\nA specification for the appearance and behavior of a menu bar extra scene."
    },
    {
        "title": "Settings",
        "url": "https://developer.apple.com/documentation/swiftui/settings",
        "html": "Overview\n\nUse a settings scene to have SwiftUI manage views with controls for your app\u2019s settings when you declare your app using the App protocol. When you use an App declaration for multiple platforms, compile the settings scene only in macOS:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        #if os(macOS)\n        Settings {\n            SettingsView()\n        }\n        #endif\n    }\n}\n\n\nPassing a view as the argument to a settings scene in the App declaration causes SwiftUI to enable the app\u2019s Settings menu item. SwiftUI manages displaying and removing the settings view when the user selects the Settings item from the application menu or the equivalent keyboard shortcut:\n\nThe contents of your settings view are controls that modify bindings to UserDefaults values that SwiftUI manages using the AppStorage property wrapper:\n\nstruct GeneralSettingsView: View {\n    @AppStorage(\"showPreview\") private var showPreview = true\n    @AppStorage(\"fontSize\") private var fontSize = 12.0\n\n\n    var body: some View {\n        Form {\n            Toggle(\"Show Previews\", isOn: $showPreview)\n            Slider(value: $fontSize, in: 9...96) {\n                Text(\"Font Size (\\(fontSize, specifier: \"%.0f\") pts)\")\n            }\n        }\n        .padding(20)\n        .frame(width: 350, height: 100)\n    }\n}\n\n\nYou can define your settings in a single view, or you can use a TabView to group settings into different collections:\n\nstruct SettingsView: View {\n    private enum Tabs: Hashable {\n        case general, advanced\n    }\n    var body: some View {\n        TabView {\n            GeneralSettingsView()\n                .tabItem {\n                    Label(\"General\", systemImage: \"gear\")\n                }\n                .tag(Tabs.general)\n            AdvancedSettingsView()\n                .tabItem {\n                    Label(\"Advanced\", systemImage: \"star\")\n                }\n                .tag(Tabs.advanced)\n        }\n        .padding(20)\n        .frame(width: 375, height: 150)\n    }\n}\n\n\nTopics\nCreating a settings scene\ninit(content: () -> Content)\nCreates a scene that presents an interface for viewing and modifying an app\u2019s preferences.\nRelationships\nConforms To\nScene\nSee Also\nManaging a settings window\nstruct SettingsLink\nA view that opens the Settings scene defined by an app."
    },
    {
        "title": "ScenePhase",
        "url": "https://developer.apple.com/documentation/swiftui/scenephase",
        "html": "Overview\n\nThe system moves your app\u2019s Scene instances through phases that reflect a scene\u2019s operational state. You can trigger actions when the phase changes. Read the current phase by observing the scenePhase value in the Environment:\n\n@Environment(\\.scenePhase) private var scenePhase\n\n\nHow you interpret the value depends on where it\u2019s read from. If you read the phase from inside a View instance, you obtain a value that reflects the phase of the scene that contains the view. The following example uses the onChange(of:perform:) method to enable a timer whenever the enclosing scene enters the ScenePhase.active phase and disable the timer when entering any other phase:\n\nstruct MyView: View {\n    @ObservedObject var model: DataModel\n    @Environment(\\.scenePhase) private var scenePhase\n\n\n    var body: some View {\n        TimerView()\n            .onChange(of: scenePhase) { phase in\n                model.isTimerRunning = (phase == .active)\n            }\n    }\n}\n\n\nIf you read the phase from within an App instance, you obtain an aggregate value that reflects the phases of all the scenes in your app. The app reports a value of ScenePhase.active if any scene is active, or a value of ScenePhase.inactive when no scenes are active. This includes multiple scene instances created from a single scene declaration; for example, from a WindowGroup. When an app enters the ScenePhase.background phase, expect the app to terminate soon after. You can use that opportunity to free any resources:\n\n@main\nstruct MyApp: App {\n    @Environment(\\.scenePhase) private var scenePhase\n\n\n    var body: some Scene {\n        WindowGroup {\n            MyRootView()\n        }\n        .onChange(of: scenePhase) { phase in\n            if phase == .background {\n                // Perform cleanup when all scenes within\n                // MyApp go to the background.\n            }\n        }\n    }\n}\n\n\nIf you read the phase from within a custom Scene instance, the value similarly reflects an aggregation of all the scenes that make up the custom scene:\n\nstruct MyScene: Scene {\n    @Environment(\\.scenePhase) private var scenePhase\n\n\n    var body: some Scene {\n        WindowGroup {\n            MyRootView()\n        }\n        .onChange(of: scenePhase) { phase in\n            if phase == .background {\n                // Perform cleanup when all scenes within\n                // MyScene go to the background.\n            }\n        }\n    }\n}\n\nTopics\nGetting scene phases\ncase active\nThe scene is in the foreground and interactive.\ncase inactive\nThe scene is in the foreground but should pause its work.\ncase background\nThe scene isn\u2019t currently visible in the UI.\nRelationships\nConforms To\nComparable\nEquatable\nHashable\nSendable\nSee Also\nMonitoring scene life cycle\nvar scenePhase: ScenePhase\nThe current phase of the scene."
    },
    {
        "title": "MenuBarExtraStyle",
        "url": "https://developer.apple.com/documentation/swiftui/menubarextrastyle",
        "html": "Topics\nGetting menu bar extra styles\nstatic var automatic: AutomaticMenuBarExtraStyle\nThe default menu bar extra style.\nAvailable when Self is AutomaticMenuBarExtraStyle.\nstatic var menu: PullDownMenuBarExtraStyle\nA menu bar extra style that renders its contents as a menu that pulls down from the icon in the menu bar.\nAvailable when Self is PullDownMenuBarExtraStyle.\nstatic var window: WindowMenuBarExtraStyle\nA menu bar extra style that renders its contents in a popover-like window.\nAvailable when Self is WindowMenuBarExtraStyle.\nSupporting types\nstruct AutomaticMenuBarExtraStyle\nThe default menu bar extra style. You can also use automatic to construct this style.\nstruct PullDownMenuBarExtraStyle\nA menu bar extra style that renders its contents as a menu that pulls down from the icon in the menu bar.\nstruct WindowMenuBarExtraStyle\nA menu bar extra style that renders its contents in a popover-like window.\nRelationships\nConforming Types\nAutomaticMenuBarExtraStyle\nPullDownMenuBarExtraStyle\nWindowMenuBarExtraStyle\nSee Also\nCreating a menu bar extra\nstruct MenuBarExtra\nA scene that renders itself as a persistent control in the system menu bar.\nfunc menuBarExtraStyle<S>(S) -> some Scene\nSets the style for menu bar extra created by this scene."
    },
    {
        "title": "WKNotificationScene",
        "url": "https://developer.apple.com/documentation/swiftui/wknotificationscene",
        "html": "Topics\nCreating a notification scene\ninit(controller: Controller.Type, category: String)\nCreates a scene that appears in response to receiving a specific category of remote or local notifications.\nRelationships\nConforms To\nScene"
    },
    {
        "title": "windowStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/windowstyle(_:)",
        "html": "See Also\nCreating windows\nstruct WindowGroup\nA scene that presents a group of identically structured windows.\nstruct Window\nA scene that presents its content in a single, unique window.\nprotocol WindowStyle\nA specification for the appearance and interaction of a window."
    },
    {
        "title": "renameAction(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/renameaction(_:)-6lghl",
        "html": "Parameters\naction\n\nA closure to run when renaming.\n\nReturn Value\n\nA view that has the specified rename action.\n\nDiscussion\n\nUse this modifier in conjunction with the RenameButton to implement standard rename interactions. A rename button receives its action from the environment. Use this modifier to customize the action provided to the rename button.\n\nstruct RowView: View {\n    @State private var text = \"\"\n    @FocusState private var isFocused: Bool\n\n\n    var body: some View {\n        TextField(text: $item.name) {\n            Text(\"Prompt\")\n        }\n        .focused($isFocused)\n        .contextMenu {\n            RenameButton()\n            // ... your own custom actions\n        }\n        .renameAction { isFocused = true }\n}\n\n\nWhen the user taps the rename button in the context menu, the rename action focuses the text field by setting the isFocused property to true.\n\nSee Also\nRenaming a document\nstruct RenameButton\nA button that triggers a standard rename action.\nfunc renameAction(FocusState<Bool>.Binding) -> some View\nSets the rename action in the environment to update focus state.\nvar rename: RenameAction?\nAn action that activates the standard rename interaction.\nstruct RenameAction\nAn action that activates a standard rename interaction."
    },
    {
        "title": "ToolbarItemGroup",
        "url": "https://developer.apple.com/documentation/swiftui/toolbaritemgroup",
        "html": "Topics\nCreating a toolbar item group\ninit(placement: ToolbarItemPlacement, content: () -> Content)\nCreates a toolbar item group with a specified placement and content.\ninit<C, L>(placement: ToolbarItemPlacement, content: () -> C, label: () -> L)\nCreates a toolbar item group with the specified placement, content, and a label describing that content.\nAvailable when Content conforms to View.\nSupporting types\nstruct LabeledToolbarItemGroupContent\nA view that represents the view of a toolbar item group with a specified label.\nRelationships\nConforms To\nToolbarContent\nSee Also\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nstruct ToolbarItem\nA model that represents an item which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemPlacement\nA structure that defines the placement of a toolbar item.\nprotocol ToolbarContent\nConforming types represent items that can be placed in various locations in a toolbar.\nstruct ToolbarContentBuilder\nConstructs a toolbar item set from multi-expression closures."
    },
    {
        "title": "openDocument",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/opendocument",
        "html": "Discussion\n\nUse the openDocument environment value to get the instance of the OpenDocumentAction structure for a given Environment. Then call the instance to present an existing document. You call the instance directly because it defines a callAsFunction(at:) method that Swift calls when you call the instance.\n\nFor example, you can create a button that opens the document at the specified URL:\n\nstruct OpenDocumentButton: View {\n    var url: URL\n    @Environment(\\.openDocument) private var openDocument\n\n\n    var body: some View {\n        Button(url.deletingPathExtension().lastPathComponent) {\n            Task {\n                do {\n                    try await openDocument(at: url)\n                } catch {\n                    // Handle error\n                }\n            }\n        }\n    }\n}\n\n\nThe above example uses a do-catch statement to handle any errors that the open document action might throw. It also places the action inside a task and awaits the result because the action operates asynchronously.\n\nTo present an existing document, your app must define a DocumentGroup that handles the content type of the specified file. For a document that\u2019s already open, the system brings the existing window to the front. Otherwise, the system opens a new window.\n\nSee Also\nOpening a document programmatically\nvar newDocument: NewDocumentAction\nAn action in the environment that presents a new document.\nstruct NewDocumentAction\nAn action that presents a new document.\nstruct OpenDocumentAction\nAn action that presents an existing document."
    },
    {
        "title": "DocumentConfiguration",
        "url": "https://developer.apple.com/documentation/swiftui/documentconfiguration",
        "html": "Topics\nGetting configuration values\nvar fileURL: URL?\nA URL of an open document.\nvar isEditable: Bool\nA Boolean value that indicates whether you can edit the document.\nRelationships\nConforms To\nSendable\nSee Also\nAccessing document configuration\nvar documentConfiguration: DocumentConfiguration?\nThe configuration of a document in a DocumentGroup."
    },
    {
        "title": "Scene",
        "url": "https://developer.apple.com/documentation/swiftui/scene",
        "html": "Overview\n\nYou create an App by combining one or more instances that conform to the Scene protocol in the app\u2019s body. You can use the built-in scenes that SwiftUI provides, like WindowGroup, along with custom scenes that you compose from other scenes. To create a custom scene, declare a type that conforms to the Scene protocol. Implement the required body computed property and provide the content for your custom scene:\n\nstruct MyScene: Scene {\n    var body: some Scene {\n        WindowGroup {\n            MyRootView()\n        }\n    }\n}\n\n\nA scene acts as a container for a view hierarchy that you want to display to the user. The system decides when and how to present the view hierarchy in the user interface in a way that\u2019s platform-appropriate and dependent on the current state of the app. For example, for the window group shown above, the system lets the user create or remove windows that contain MyRootView on platforms like macOS and iPadOS. On other platforms, the same view hierarchy might consume the entire display when active.\n\nRead the scenePhase environment value from within a scene or one of its views to check whether a scene is active or in some other state. You can create a property that contains the scene phase, which is one of the values in the ScenePhase enumeration, using the Environment attribute:\n\nstruct MyScene: Scene {\n    @Environment(\\.scenePhase) private var scenePhase\n\n\n    // ...\n}\n\n\nThe Scene protocol provides scene modifiers, defined as protocol methods with default implementations, that you use to configure a scene. For example, you can use the onChange(of:perform:) modifier to trigger an action when a value changes. The following code empties a cache when all of the scenes in the window group have moved to the background:\n\nstruct MyScene: Scene {\n    @Environment(\\.scenePhase) private var scenePhase\n    @StateObject private var cache = DataCache()\n\n\n    var body: some Scene {\n        WindowGroup {\n            MyRootView()\n        }\n        .onChange(of: scenePhase) { newScenePhase in\n            if newScenePhase == .background {\n                cache.empty()\n            }\n        }\n    }\n}\n\nTopics\nCreating a scene\nvar body: Self.Body\nThe content and behavior of the scene.\n\nRequired\n\nassociatedtype Body : Scene\nThe type of scene that represents the body of this scene.\n\nRequired\n\nWatching for changes\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> some Scene\nAdds an action to perform when the given value changes.\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> some Scene\nAdds an action to perform when the given value changes.\nfunc handlesExternalEvents(matching: Set<String>) -> some Scene\nSpecifies a modifier to indicate if this Scene can be used when creating a new Scene for the received External Event.\nCreating background tasks\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some Scene\nRuns the specified action when the system provides a background task.\nManaging app storage\nfunc defaultAppStorage(UserDefaults) -> some Scene\nThe default store used by AppStorage contained within the scene and its view content.\nSetting commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nfunc keyboardShortcut(KeyboardShortcut?) -> some Scene\nDefines a keyboard shortcut for opening new scene windows.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some Scene\nDefines a keyboard shortcut for opening new scene windows.\nSizing and positioning the scene\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nStyling the scene\nfunc immersionStyle(selection: Binding<ImmersionStyle>, in: ImmersionStyle...) -> some Scene\nSets the allowed styles for the immersive space.\nBeta\nfunc upperLimbVisibility(Visibility) -> some Scene\nSets the preferred visibility of the user\u2019s upper limbs, while an ImmersiveSpace scene is presented.\nBeta\nfunc windowStyle<S>(S) -> some Scene\nSets the style for windows created by this scene.\nfunc windowToolbarStyle<S>(S) -> some Scene\nSets the style for the toolbar defined within this scene.\nConfiguring a data model\nfunc modelContext(ModelContext) -> some Scene\nSets the model context in this scene\u2019s environment.\nfunc modelContainer(ModelContainer) -> some Scene\nSets the model container and associated model context in this scene\u2019s environment.\nfunc modelContainer(for: [PersistentModel.Type], inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model types, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment.\nfunc modelContainer(for: PersistentModel.Type, inMemory: Bool, isAutosaveEnabled: Bool, isUndoEnabled: Bool, onSetup: (Result<ModelContainer, Error>) -> Void) -> some Scene\nSets the model container in this scene for storing the provided model type, creating a new container if necessary, and also sets a model context for that container in this scene\u2019s environment.\nManaging the environment\nfunc environment<T>(T?) -> some Scene\nPlaces an observable object in the scene\u2019s environment.\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some Scene\nSets the environment value of the specified key path to the given value.\nfunc environmentObject<T>(T) -> some Scene\nSupplies an ObservableObject to a view subhierarchy.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some Scene\nTransforms the environment value of the specified key path with the given function.\nDeprecated symbols\nfunc onChange<V>(of: V, perform: (V) -> Void) -> some Scene\nAdds an action to perform when the given value changes.\nDeprecated\nInstance Methods\nfunc preferredAmbientBrightness(ImmersiveAmbientBrightness) -> some Scene\nSpecify to the system the preferred ambient brightness of an ImmersiveSpace.\nBeta\nRelationships\nConforming Types\nDocumentGroup\nGroup\nConforms when Content conforms to Scene.\nImmersiveSpace\nMenuBarExtra\nModifiedContent\nConforms when Content conforms to Scene and Modifier conforms to _SceneModifier.\nSettings\nWKNotificationScene\nWindow\nWindowGroup\nSee Also\nCreating scenes\nstruct SceneBuilder\nA result builder for composing a collection of scenes into a single composite scene."
    },
    {
        "title": "SceneBuilder",
        "url": "https://developer.apple.com/documentation/swiftui/scenebuilder",
        "html": "Topics\nBuilding content\nstatic func buildBlock<Content>(Content) -> Content\nPasses a single scene written as a child scene through unmodified.\nstatic func buildBlock<C0, C1>(C0, C1) -> some Scene\nstatic func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Scene\nstatic func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Scene\nstatic func buildExpression<Content>(Content) -> Content\nBuilds an expression within the builder.\nstatic func buildLimitedAvailability(some Scene) -> Scene & _LimitedAvailabilitySceneMarker\nProcesses scene content for a conditional compiler-control statement that performs an availability check.\nstatic func buildOptional((Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene\nProduces an optional scene for conditional statements in multi-statement closures that\u2019s only visible when the condition evaluates to true.\nSee Also\nCreating scenes\nprotocol Scene\nA part of an app\u2019s user interface with a life cycle managed by the system."
    },
    {
        "title": "scenePhase",
        "url": "https://developer.apple.com/documentation/swiftui/environmentvalues/scenephase",
        "html": "Discussion\n\nThe system sets this value to provide an indication of the operational state of a scene or collection of scenes. The exact meaning depends on where you access the value. For more information, see ScenePhase.\n\nSee Also\nMonitoring scene life cycle\nenum ScenePhase\nAn indication of a scene\u2019s operational state."
    },
    {
        "title": "WKExtensionDelegateAdaptor",
        "url": "https://developer.apple.com/documentation/swiftui/wkextensiondelegateadaptor",
        "html": "Overview\n\nTo handle extension delegate callbacks in an extension that uses the SwiftUI life cycle, define a type that conforms to the WKExtensionDelegate protocol, and implement the delegate methods that you need. For example, you can implement the didRegisterForRemoteNotifications(withDeviceToken:) method to handle remote notification registration:\n\nclass MyExtensionDelegate: NSObject, WKExtensionDelegate, ObservableObject {\n    func didRegisterForRemoteNotifications(withDeviceToken: Data) {\n        // Record the device token.\n    }\n}\n\n\nThen use the WKExtensionDelegateAdaptor property wrapper inside your App declaration to tell SwiftUI about the delegate type:\n\n@main\nstruct MyApp: App {\n    @WKExtensionDelegateAdaptor private var extensionDelegate: MyExtensionDelegate\n\n\n    var body: some Scene { ... }\n}\n\n\nSwiftUI instantiates the delegate and calls the delegate\u2019s methods in response to life cycle events. Define the delegate adaptor only in your App declaration, and only once for a given extension. If you declare it more than once, SwiftUI generates a runtime error.\n\nIf your extension delegate conforms to the ObservableObject protocol, as in the example above, then SwiftUI puts the delegate it creates into the Environment. You can access the delegate from any scene or view in your extension using the EnvironmentObject property wrapper:\n\n@EnvironmentObject private var extensionDelegate: MyExtensionDelegate\n\n\nThis enables you to use the dollar sign ($) prefix to get a binding to published properties that you declare in the delegate. For more information, see projectedValue.\n\nImportant\n\nManage an externsion\u2019s life cycle events without using a delegate whenever possible. For example, prefer to handle changes in ScenePhase instead of relying on delegate callbacks, like applicationDidFinishLaunching().\n\nTopics\nCreating a delegate adaptor\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor.\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor using a delegate that\u2019s an observable object.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to WKExtensionDelegate.\ninit(DelegateType.Type)\nCreates a WatchKit extension delegate adaptor using an observable delegate.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to Observable, and DelegateType conforms to WKExtensionDelegate.\nGetting the delegate adaptor\nvar projectedValue: ObservedObject<DelegateType>.Wrapper\nA projection of the observed object that provides bindings to its properties.\nAvailable when DelegateType inherits NSObject, DelegateType conforms to ObservableObject, and DelegateType conforms to WKExtensionDelegate.\nvar wrappedValue: DelegateType\nThe underlying delegate.\nRelationships\nConforms To\nDynamicProperty\nSendable\nSee Also\nTargeting watchOS\nstruct WKApplicationDelegateAdaptor\nA property wrapper that is used in App to provide a delegate from WatchKit."
    },
    {
        "title": "Accessible navigation",
        "url": "https://developer.apple.com/documentation/swiftui/accessible-navigation",
        "html": "Overview\n\nAn accessibility rotor is a shortcut that enables users to quickly navigate to specific elements of the user interface, and, optionally, to specific ranges of text within those elements.\n\nThe system automatically provides rotors for many navigable elements, but you can supply additional rotors for specific purposes, or replace system rotors when they don\u2019t automatically pick up off-screen elements, like those far down in a LazyVStack or a List.\n\nFor design guidance, see Navigation in the Accessibility section of the Human Interface Guidelines.\n\nTopics\nCreating rotors\nfunc accessibilityRotor<Content>(LocalizedStringKey, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<Content>(Text, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nfunc accessibilityRotor<L, Content>(L, entries: () -> Content) -> some View\nCreate an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.\nprotocol AccessibilityRotorContent\nContent within an accessibility rotor.\nstruct AccessibilityRotorContentBuilder\nResult builder you use to generate rotor entry content.\nstruct AccessibilityRotorEntry\nA struct representing an entry in an Accessibility Rotor.\nCreating rotors from a collection\nfunc accessibilityRotor<EntryModel, ID>(LocalizedStringKey, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<EntryModel, ID>(Text, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel, ID>(L, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nCreating rotors with a label\nfunc accessibilityRotor<EntryModel>(LocalizedStringKey, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<EntryModel>(Text, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nfunc accessibilityRotor<L, EntryModel>(L, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries.\nCreating rotors for text ranges\nfunc accessibilityRotor(LocalizedStringKey, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nfunc accessibilityRotor(Text, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nfunc accessibilityRotor<L>(L, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nReplacing system rotors\nfunc accessibilityRotor<Content>(AccessibilitySystemRotor, entries: () -> Content) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel, ID>(AccessibilitySystemRotor, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor<EntryModel>(AccessibilitySystemRotor, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor.\nfunc accessibilityRotor(AccessibilitySystemRotor, textRanges: [Range<String.Index>]) -> some View\nCreate an Accessibility Rotor replacing the specified system-provided Rotor. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.\nstruct AccessibilitySystemRotor\nDesignates a Rotor that replaces one of the automatic, system-provided Rotors with a developer-provided Rotor.\nConfiguring rotors\nfunc accessibilityRotorEntry<ID>(id: ID, in: Namespace.ID) -> some View\nDefines an explicit identifier tying an Accessibility element for this view to an entry in an Accessibility Rotor.\nfunc accessibilityLinkedGroup<ID>(id: ID, in: Namespace.ID) -> some View\nLinks multiple accessibility elements so that the user can quickly navigate from one element to another, even when the elements are not near each other in the accessibility hierarchy.\nfunc accessibilitySortPriority(Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the sort priority order for this view\u2019s accessibility element, relative to other elements at the same level.\nSee Also\nAccessibility\nAccessibility fundamentals\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAccessible appearance\nEnhance the legibility of content in your app\u2019s interface.\nAccessible controls\nImprove access to actions that your app can undertake.\nAccessible descriptions\nDescribe interface elements to help people understand what they represent."
    },
    {
        "title": "Input events",
        "url": "https://developer.apple.com/documentation/swiftui/input-events",
        "html": "Overview\n\nSwiftUI provides view modifiers that enable your app to listen for and react to various kinds of user input. For example, you can create keyboard shortcuts, respond to a form submission, or take input from the digital crown of an Apple Watch.\n\nFor design guidance, see Inputs in the Human Interface Guidelines.\n\nTopics\nResponding to keyboard input\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses any key on a hardware keyboard while the view has focus.\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses a key on a hardware keyboard while the view has focus.\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> some View\nPerforms an action if the user presses one or more keys on a hardware keyboard while the view has focus.\nstruct KeyPress\nCreating keyboard shortcuts\nfunc keyboardShortcut(KeyboardShortcut) -> some View\nAssigns a keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyboardShortcut?) -> some View\nAssigns an optional keyboard shortcut to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nfunc keyboardShortcut(KeyEquivalent, modifiers: EventModifiers, localization: KeyboardShortcut.Localization) -> some View\nDefines a keyboard shortcut and assigns it to the modified control.\nvar keyboardShortcut: KeyboardShortcut?\nThe keyboard shortcut that buttons in this environment will be triggered with.\nstruct KeyboardShortcut\nKeyboard shortcuts describe combinations of keys on a keyboard that the user can press in order to activate a button or toggle.\nstruct KeyEquivalent\nKey equivalents consist of a letter, punctuation, or function key that can be combined with an optional set of modifier keys to specify a keyboard shortcut.\nstruct EventModifiers\nA set of key modifiers that you can add to a gesture.\nResponding to hover events\nfunc onHover(perform: (Bool) -> Void) -> some View\nAdds an action to perform when the user moves the pointer over or away from the view\u2019s frame.\nfunc onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol, perform: (HoverPhase) -> Void) -> some View\nAdds an action to perform when the pointer enters, moves within, and exits the view\u2019s bounds.\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> some View\nApplies a hover effect to this view.\nfunc hoverEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display hover effects.\nfunc defaultHoverEffect(HoverEffect?) -> some View\nSets the default hover effect to use for views within this view.\nvar isHoverEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows hover effects to be displayed.\nenum HoverPhase\nThe current hovering state and value of the pointer.\nChanging view appearance for hover events\nfunc hoverEffect(HoverEffect) -> some View\nApplies a hover effect to this view.\nstruct HoverEffect\nAn effect applied when the pointer hovers over a view.\nResponding to submission events\nfunc onSubmit(of: SubmitTriggers, (() -> Void)) -> some View\nAdds an action to perform when the user submits a value to this view.\nfunc submitScope(Bool) -> some View\nPrevents submission triggers originating from this view to invoke a submission action configured by a submission modifier higher up in the view hierarchy.\nstruct SubmitTriggers\nA type that defines various triggers that result in the firing of a submission action.\nLabeling a submission event\nfunc submitLabel(SubmitLabel) -> some View\nSets the submit label for this view.\nstruct SubmitLabel\nA semantic label describing the label of submission within a view hierarchy.\nResponding to commands\nfunc onMoveCommand(perform: ((MoveCommandDirection) -> Void)?) -> some View\nAdds an action to perform in response to a move command, like when the user presses an arrow key on a Mac keyboard, or taps the edge of the Siri Remote when controlling an Apple TV.\nfunc onDeleteCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Delete command, or pressing either the \u232b (backspace) or \u2326 (forward delete) keys while the view has focus.\nfunc pageCommand<V>(value: Binding<V>, in: ClosedRange<V>, step: V) -> some View\nSteps a value through a range in response to page up or page down commands.\nfunc onExitCommand(perform: (() -> Void)?) -> some View\nSets up an action that triggers in response to receiving the exit command while the view has focus.\nfunc onPlayPauseCommand(perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the system\u2019s Play/Pause command.\nfunc onCommand(Selector, perform: (() -> Void)?) -> some View\nAdds an action to perform in response to the given selector.\nenum MoveCommandDirection\nSpecifies the direction of an arrow key movement.\nControlling hit testing\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nfunc contentShape<S>(S, eoFill: Bool) -> some View\nDefines the content shape for hit testing.\nfunc contentShape<S>(ContentShapeKinds, S, eoFill: Bool) -> some View\nSets the content shape for this view.\nstruct ContentShapeKinds\nA kind for the content shape of a view.\nInteracting with the Digital Crown\nfunc digitalCrownAccessory(Visibility) -> some View\nSpecifies the visibility of Digital Crown accessory Views on Apple Watch.\nfunc digitalCrownAccessory<Content>(content: () -> Content) -> some View\nPlaces an accessory View next to the Digital Crown on Apple Watch.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(detent: Binding<V>, from: V, through: V, by: V.Stride, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool, onChange: (DigitalCrownEvent) -> Void, onIdle: () -> Void) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nfunc digitalCrownRotation<V>(Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: DigitalCrownRotationalSensitivity, isContinuous: Bool, isHapticFeedbackEnabled: Bool) -> some View\nTracks Digital Crown rotations by updating the specified binding.\nstruct DigitalCrownEvent\nAn event emitted when the user rotates the Digital Crown.\nenum DigitalCrownRotationalSensitivity\nThe amount of Digital Crown rotation needed to move between two integer numbers.\nManaging Touch Bar input\nfunc touchBar<Content>(content: () -> Content) -> some View\nSets the content that the Touch Bar displays.\nfunc touchBar<Content>(TouchBar<Content>) -> some View\nSets the Touch Bar content to be shown in the Touch Bar when applicable.\nfunc touchBarItemPrincipal(Bool) -> some View\nSets principal views that have special significance to this Touch Bar.\nfunc touchBarCustomizationLabel(Text) -> some View\nSets a user-visible string that identifies the view\u2019s functionality.\nfunc touchBarItemPresence(TouchBarItemPresence) -> some View\nSets the behavior of the user-customized view.\nstruct TouchBar\nA container for a view that you can show in the Touch Bar.\nenum TouchBarItemPresence\nOptions that affect user customization of the Touch Bar.\nSee Also\nEvent handling\nGestures\nDefine interactions from taps, clicks, and swipes to fine-grained gestures.\nClipboard\nEnable people to move or duplicate items by issuing Copy and Paste commands.\nDrag and drop\nEnable people to move or duplicate items by dragging them from one location to another.\nFocus\nIdentify and control which visible object responds to user interaction.\nSystem events\nReact to system events, like opening a URL."
    },
    {
        "title": "Backyard Birds: Building an app with SwiftData and widgets",
        "url": "https://developer.apple.com/documentation/swiftui/backyard-birds-sample",
        "html": "Overview\n\nBackyard Birds offers a rich environment in which you can watch the birds that visit your backyard garden. You can monitor their water and food supply to ensure they always have fresh water and plenty to eat, or upgrade the game using an in-app purchase to provide tastier food for the birds to eat.\n\nThe sample implements its data model using SwiftData for persistence, and integrates seamlessly with SwiftUI using the Observable protocol. The game\u2019s widgets implement App Intents for interactive and configurable widgets. The in-app purchase experience uses the ProductView and SubscriptionStoreView from StoreKit.\n\nYou can access the source code for this sample on GitHub.\n\nNote\n\nThis sample code project is associated with WWDC23 session 102: State of the Union.\n\nConfigure the sample code project\n\nTo configure the Backyard Birds app to run on your devices, follow these steps:\n\nOpen the project in Xcode 15 or later.\n\nEdit the multiplatform target\u2019s scheme, and on the Options tab, choose the Store.storekit file for StoreKit configuration.\n\nRepeat the previous step for the watchOS target\u2019s scheme.\n\nSelect the top-level Backyard Birds project.\n\nFor all targets, choose your team from the Team menu in the Signing & Capabilities pane so Xcode can automatically manage your provisioning profile.\n\nCreate a data-driven app\n\nThe app defines its data model by conforming the model objects to PersistentModel using the Model macro. Using the Attribute macro with the unique option ensures that the id property is unique.\n\n@Model public class BirdSpecies {\n    @Attribute(.unique) public var id: String\n    public var naturalScale: Double\n    public var isEarlyAccess: Bool\n    public var parts: [BirdPart]\n    \n    @Relationship(deleteRule: .cascade, inverse: \\Bird.species)\n    public var birds: [Bird] = []\n    \n    public var info: BirdSpeciesInfo { BirdSpeciesInfo(rawValue: id) }\n    \n    public init(info: BirdSpeciesInfo, naturalScale: Double = 1, isEarlyAccess: Bool = false, parts: [BirdPart]) {\n        self.id = info.rawValue\n        self.naturalScale = naturalScale\n        self.isEarlyAccess = isEarlyAccess\n        self.parts = parts\n    }\n}\n\nConstruct interactive widgets\n\nBackyard Birds displays interactive widgets by presenting a Button to refill a backyard\u2019s supplies when the water and food are running low. The app does this by placing a Button in the widget\u2019s view, and passing a ResupplyBackyardIntent instance to the init(intent:label:) initializer:\n\nButton(intent: ResupplyBackyardIntent(backyard: BackyardEntity(from: snapshot.backyard))) {\n    Label(\"Refill Water\", systemImage: \"arrow.clockwise\")\n        .foregroundStyle(.secondary)\n        .frame(maxWidth: .infinity)\n        .padding(.vertical, 8)\n        .padding(.horizontal, 12)\n        .background(.quaternary, in: .containerRelative)\n}\n\n\nThe app allows for configuration of the widget by implementing the WidgetConfigurationIntent protocol:\n\nstruct BackyardWidgetIntent: WidgetConfigurationIntent {\n    static let title: LocalizedStringResource = \"Backyard\"\n    static let description = IntentDescription(\"Keep track of your backyards.\")\n    \n    @Parameter(title: \"Backyards\", default: BackyardWidgetContent.all)\n    var backyards: BackyardWidgetContent\n    \n    @Parameter(title: \"Backyard\")\n    var specificBackyard: BackyardEntity?\n    \n    init(backyards: BackyardWidgetContent = .all, specificBackyard: BackyardEntity? = nil) {\n        self.backyards = backyards\n        self.specificBackyard = specificBackyard\n    }\n    \n    init() {\n    }\n    \n    static var parameterSummary: some ParameterSummary {\n        When(\\.$backyards, .equalTo, BackyardWidgetContent.specific) {\n            Summary {\n                \\.$backyards\n                \\.$specificBackyard\n            }\n        } otherwise: {\n            Summary {\n                \\.$backyards\n            }\n        }\n    }\n}\n\nProvide a new in-app purchase experience\n\nThe sample app uses ProductView to display several different bird food upgrades available for purchase on a store shelf. To prominently feature an in-app purchase item, the app uses the .productViewStyle(.large) modifier:\n\nProductView(id: product.id) {\n    BirdFoodProductIcon(birdFood: birdFood, quantity: product.quantity)\n        .bestBirdFoodValueBadge()\n}\n.padding(.vertical)\n.background(.background.secondary, in: .rect(cornerRadius: 20))\n.productViewStyle(.large)\n\n\nThe Backyard Birds Pass page displays renewable subscriptions using the SubscriptionStoreView view. The app uses the PassMarketingContent view as the content of the SubscriptionStoreView:\n\nSubscriptionStoreView(\n    groupID: passGroupID,\n    visibleRelationships: showPremiumUpgrade ? .upgrade : .all\n) {\n    PassMarketingContent(showPremiumUpgrade: showPremiumUpgrade)\n        #if !os(watchOS)\n        .containerBackground(for: .subscriptionStoreFullHeight) {\n            SkyBackground()\n        }\n        #endif\n}\n\nSee Also\nCreating an app\nprotocol App\nA type that represents the structure and behavior of an app."
    },
    {
        "title": "View",
        "url": "https://developer.apple.com/documentation/swiftui/view",
        "html": "Overview\n\nYou create custom views by declaring types that conform to the View protocol. Implement the required body computed property to provide the content for your custom view.\n\nstruct MyView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n    }\n}\n\n\nAssemble the view\u2019s body by combining one or more of the built-in views provided by SwiftUI, like the Text instance in the example above, plus other custom views that you define, into a hierarchy of views. For more information about creating custom views, see Declaring a custom view.\n\nThe View protocol provides a set of modifiers \u2014 protocol methods with default implementations \u2014 that you use to configure views in the layout of your app. Modifiers work by wrapping the view instance on which you call them in another view with the specified characteristics, as described in Configuring views. For example, adding the opacity(_:) modifier to a text view returns a new view with some amount of transparency:\n\nText(\"Hello, World!\")\n    .opacity(0.5) // Display partially transparent text.\n\n\nThe complete list of default modifiers provides a large set of controls for managing views. For example, you can fine tune Layout modifiers, add Accessibility modifiers information, and respond to Input and event modifiers. You can also collect groups of default modifiers into new, custom view modifiers for easy reuse.\n\nTopics\nImplementing a custom view\nvar body: Self.Body\nThe content and behavior of the view.\n\nRequired Default implementations provided.\n\nassociatedtype Body : View\nThe type of view representing the body of this view.\n\nRequired\n\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nPreviews in Xcode\nGenerate dynamic, interactive previews of your custom views.\nConfiguring view elements\nAccessibility modifiers\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAppearance modifiers\nConfigure a view\u2019s foreground and background styles, controls, and visibility.\nText and symbol modifiers\nManage the rendering, selection, and entry of text in your view.\nAuxiliary view modifiers\nAdd and configure supporting views, like toolbars and context menus.\nChart view modifiers\nConfigure charts that you declare with Swift Charts.\nDrawing views\nStyle modifiers\nApply built-in styles to different types of views.\nLayout modifiers\nTell a view how to arrange itself within a view hierarchy by adjusting its size, position, alignment, padding, and so on.\nGraphics and rendering modifiers\nAffect the way the system draws a view, for example by scaling or masking a view, or by applying graphical effects.\nProviding interactivity\nInput and event modifiers\nSupply actions for a view to perform in response to user input and system events.\nSearch modifiers\nEnable people to search for content in your app.\nPresentation modifiers\nDefine additional views for the view to present under specified conditions.\nState modifiers\nAccess storage and provide child views with configuration data.\nDeprecated modifiers\nDeprecated modifiers\nReview unsupported modifiers and their replacements.\nInstance Methods\nfunc managedContentStyle(ManagedContentStyle) -> some View\nApplies a ManagedContentStyle to the view\nBeta\nRelationships\nInherited By\nDynamicViewContent\nInsettableShape\nNSViewControllerRepresentable\nNSViewRepresentable\nShape\nShapeView\nUIViewControllerRepresentable\nUIViewRepresentable\nWKInterfaceObjectRepresentable\nConforming Types\nAngularGradient\nAnyShape\nAnyView\nAsyncImage\nButton\nButtonBorderShape\nButtonStyleConfiguration.Label\nCanvas\nConforms when Symbols conforms to View.\nCapsule\nCircle\nColor\nColorPicker\nContainerRelativeShape\nContentUnavailableView\nControlGroup\nControlGroupStyleConfiguration.Content\nControlGroupStyleConfiguration.Label\nDatePicker\nDatePickerStyleConfiguration.Label\nDefaultDateProgressLabel\nDefaultSettingsLinkLabel\nDefaultShareLinkLabel\nDisclosureGroup\nDisclosureGroupStyleConfiguration.Content\nDisclosureGroupStyleConfiguration.Label\nDivider\nEditButton\nEditableCollectionContent\nConforms when Content conforms to View.\nEllipse\nEllipticalGradient\nEmptyView\nEquatableView\nFillShapeView\nForEach\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, and Content conforms to View.\nForm\nFormStyleConfiguration.Content\nGauge\nGaugeStyleConfiguration.CurrentValueLabel\nGaugeStyleConfiguration.Label\nGaugeStyleConfiguration.MarkedValueLabel\nGaugeStyleConfiguration.MaximumValueLabel\nGaugeStyleConfiguration.MinimumValueLabel\nGeometryReader\nGeometryReader3D\nGrid\nConforms when Content conforms to View.\nGridRow\nConforms when Content conforms to View.\nGroup\nConforms when Content conforms to View.\nGroupBox\nGroupBoxStyleConfiguration.Content\nGroupBoxStyleConfiguration.Label\nHSplitView\nHStack\nHelpLink\nImage\nKeyframeAnimator\nLabel\nLabelStyleConfiguration.Icon\nLabelStyleConfiguration.Title\nLabeledContent\nConforms when Label conforms to View and Content conforms to View.\nLabeledContentStyleConfiguration.Content\nLabeledContentStyleConfiguration.Label\nLabeledControlGroupContent\nLabeledToolbarItemGroupContent\nLazyHGrid\nLazyHStack\nLazyVGrid\nLazyVStack\nLinearGradient\nLink\nList\nMenu\nMenuButton\nMenuStyleConfiguration.Content\nMenuStyleConfiguration.Label\nModifiedContent\nConforms when Content conforms to View and Modifier conforms to ViewModifier.\nMultiDatePicker\nNavigationLink\nNavigationSplitView\nNavigationStack\nNavigationView\nOffsetShape\nConforms when Content conforms to InsettableShape.\nOutlineGroup\nConforms when Data conforms to RandomAccessCollection, ID conforms to Hashable, Parent conforms to View, Leaf conforms to View, and Subgroup conforms to View.\nOutlineSubgroupChildren\nPasteButton\nPath\nPhaseAnimator\nPicker\nPlaceholderContentView\nPresentedWindowContent\nPrimitiveButtonStyleConfiguration.Label\nProgressView\nProgressViewStyleConfiguration.CurrentValueLabel\nProgressViewStyleConfiguration.Label\nRadialGradient\nRectangle\nRenameButton\nRotatedShape\nConforms when Content conforms to InsettableShape.\nRoundedRectangle\nScaledShape\nScrollView\nScrollViewReader\nSearchUnavailableContent.Actions\nSearchUnavailableContent.Description\nSearchUnavailableContent.Label\nSection\nConforms when Parent conforms to View, Content conforms to View, and Footer conforms to View.\nSecureField\nSettingsLink\nShareLink\nSlider\nSpacer\nStepper\nStrokeBorderShapeView\nStrokeShapeView\nSubscriptionView\nTabView\nTable\nText\nTextEditor\nTextField\nTextFieldLink\nTimelineView\nConforms when Schedule conforms to TimelineSchedule and Content conforms to View.\nToggle\nToggleStyleConfiguration.Label\nTransformedShape\nTupleView\nUnevenRoundedRectangle\nVSplitView\nVStack\nViewThatFits\nZStack\nSee Also\nCreating a view\nDeclaring a custom view\nDefine views and assemble them into a view hierarchy.\nstruct ViewBuilder\nA custom parameter attribute that constructs views from closures."
    },
    {
        "title": "containerShape(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/containershape(_:)",
        "html": "Discussion\n\nThe example below defines a view that shows its content with a rounded rectangle background and the same container shape. Any ContainerRelativeShape within the content matches the rounded rectangle shape from this container inset as appropriate.\n\nstruct PlatterContainer<Content: View> : View {\n    @ViewBuilder var content: Content\n    var body: some View {\n        content\n            .padding()\n            .containerShape(shape)\n            .background(shape.fill(.background))\n    }\n    var shape: RoundedRectangle { RoundedRectangle(cornerRadius: 20) }\n}\n\nSee Also\nSetting a container shape\nprotocol InsettableShape\nA shape type that is able to inset itself to produce another shape.\nstruct ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle."
    },
    {
        "title": "OffsetShape",
        "url": "https://developer.apple.com/documentation/swiftui/offsetshape",
        "html": "Topics\nCreating an offset shape\ninit(shape: Content, offset: CGSize)\nGetting the shape\u2019s characteristics\nvar offset: CGSize\nvar shape: Content\nSupporting types\nvar animatableData: OffsetShape<Content>.AnimatableData\nThe data to animate.\nRelationships\nConforms To\nAnimatable\nConforms when Content conforms to InsettableShape.\nInsettableShape\nConforms when Content conforms to InsettableShape.\nSendable\nShape\nView\nConforms when Content conforms to InsettableShape.\nSee Also\nTransforming a shape\nstruct ScaledShape\nA shape with a scale transform applied to it.\nstruct RotatedShape\nA shape with a rotation transform applied to it.\nstruct TransformedShape\nA shape with an affine transform applied to it."
    },
    {
        "title": "FillShapeView",
        "url": "https://developer.apple.com/documentation/swiftui/fillshapeview",
        "html": "Overview\n\nYou do not create this type directly, it is the return type of Shape.fill.\n\nTopics\nCreating a stroke shape view\ninit(shape: Content, style: Style, fillStyle: FillStyle, background: Background)\nCreate a FillShapeView.\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar fillStyle: FillStyle\nThe fill style used when filling this view\u2019s shape.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar style: Style\nThe style that fills this view\u2019s shape.\nRelationships\nConforms To\nShapeView\nView\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes."
    },
    {
        "title": "FillStyle",
        "url": "https://developer.apple.com/documentation/swiftui/fillstyle",
        "html": "Topics\nCreating a fill style\ninit(eoFill: Bool, antialiased: Bool)\nCreates a new fill style with the specified settings.\nSetting fill style properties\nvar isEOFilled: Bool\nA Boolean value that indicates whether to use the even-odd rule when rendering a shape.\nvar isAntialiased: Bool\nA Boolean value that indicates whether to apply antialiasing to the edges of a shape.\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "ScaledShape",
        "url": "https://developer.apple.com/documentation/swiftui/scaledshape",
        "html": "Topics\nCreating a scaled shape\ninit(shape: Content, scale: CGSize, anchor: UnitPoint)\nGetting the shape\u2019s characteristics\nvar anchor: UnitPoint\nvar scale: CGSize\nvar shape: Content\nSupporting types\nvar animatableData: ScaledShape<Content>.AnimatableData\nThe data to animate.\nRelationships\nConforms To\nAnimatable\nSendable\nShape\nView\nSee Also\nTransforming a shape\nstruct RotatedShape\nA shape with a rotation transform applied to it.\nstruct OffsetShape\nA shape with a translation offset transform applied to it.\nstruct TransformedShape\nA shape with an affine transform applied to it."
    },
    {
        "title": "AnyShape",
        "url": "https://developer.apple.com/documentation/swiftui/anyshape",
        "html": "Overview\n\nYou can use this type to dynamically switch between shape types:\n\nstruct MyClippedView: View {\n    var isCircular: Bool\n\n\n    var body: some View {\n        OtherView().clipShape(isCircular ?\n            AnyShape(Circle()) : AnyShape(Capsule()))\n    }\n}\n\nTopics\nCreating a shape\ninit<S>(S)\nCreate an any shape instance from a shape.\nRelationships\nConforms To\nAnimatable\nSendable\nShape\nView\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "Shape",
        "url": "https://developer.apple.com/documentation/swiftui/shape",
        "html": "Overview\n\nShapes without an explicit fill or stroke get a default fill based on the foreground color.\n\nYou can define shapes in relation to an implicit frame of reference, such as the natural size of the view that contains it. Alternatively, you can define shapes in terms of absolute coordinates.\n\nTopics\nGetting standard shapes\nstatic var buttonBorder: ButtonBorderShape\nA shape that defers to the environment to determine the resolved button border shape.\nAvailable when Self is ButtonBorderShape.\nstatic var capsule: Capsule\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic func capsule(style: RoundedCornerStyle) -> Self\nA capsule shape aligned inside the frame of the view containing it.\nAvailable when Self is Capsule.\nstatic var circle: Circle\nA circle centered on the frame of the view containing it.\nAvailable when Self is Circle.\nstatic var containerRelative: ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nAvailable when Self is ContainerRelativeShape.\nstatic var ellipse: Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nAvailable when Self is Ellipse.\nstatic var rect: Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nAvailable when Self is Rectangle.\nstatic func rect(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nstatic func rect(cornerRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(cornerSize: CGSize, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nAvailable when Self is RoundedRectangle.\nstatic func rect(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle) -> Self\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nAvailable when Self is UnevenRoundedRectangle.\nDefining a shape\u2019s size and path\nfunc sizeThatFits(ProposedViewSize) -> CGSize\nReturns the size of the view that will render the shape, given a proposed size.\n\nRequired Default implementation provided.\n\nfunc path(in: CGRect) -> Path\nDescribes this shape as a path within a rectangular frame of reference.\n\nRequired\n\nTransforming a shape\nfunc trim(from: CGFloat, to: CGFloat) -> some Shape\nTrims this shape by a fractional amount based on its representation as a path.\nfunc transform(CGAffineTransform) -> TransformedShape<Self>\nApplies an affine transform to this shape.\nfunc size(CGSize) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size. This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc size(width: CGFloat, height: CGFloat) -> some Shape\nReturns a new version of self representing the same shape, but that will ask it to create its path from a rect of size (width, height). This does not affect the layout properties of any views created from the shape (e.g. by filling it).\nfunc scale(CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> ScaledShape<Self>\nScales this shape without changing its bounding frame.\nfunc rotation(Angle, anchor: UnitPoint) -> RotatedShape<Self>\nRotates this shape around an anchor point at the angle you specify.\nfunc offset(CGSize) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified size.\nfunc offset(CGPoint) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nfunc offset(x: CGFloat, y: CGFloat) -> OffsetShape<Self>\nChanges the relative position of this shape using the specified point.\nSetting the stroke characteristics\nfunc stroke<S>(S, lineWidth: CGFloat) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(lineWidth: CGFloat) -> some Shape\nReturns a new shape that is a stroked copy of self with line-width defined by lineWidth and all other properties of StrokeStyle having their default values.\nfunc stroke<S>(S, style: StrokeStyle) -> some View\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self, S, EmptyView>\nTraces the outline of this shape with a color or gradient.\nfunc stroke(style: StrokeStyle) -> some Shape\nReturns a new shape that is a stroked copy of self, using the contents of style to define the stroke characteristics.\nFilling a shape\nfunc fill<S>(S, style: FillStyle) -> _ShapeView<Self, S>\nFills this shape with a color or gradient.\nfunc fill<S>(S, style: FillStyle) -> some View\nFills this shape with a color or gradient.\nfunc fill(style: FillStyle) -> some View\nFills this shape with the foreground color.\nSetting the role\nstatic var role: ShapeRole\nAn indication of how to style a shape.\n\nRequired Default implementation provided.\n\nIndicating a layout direction\nvar layoutDirectionBehavior: LayoutDirectionBehavior\nReturns the behavior this shape should use for different layout directions.\n\nRequired Default implementation provided.\n\nPerforming operations on a shape\nfunc intersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions common to both shapes.\nfunc lineIntersection<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that overlaps the filled regions of the given shape.\nfunc lineSubtraction<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with a line from this shape that does not overlap the filled region of the given shape.\nfunc subtracting<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions from this shape that are not in the given shape.\nfunc symmetricDifference<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions either from this shape or the given shape, but not in both.\nfunc union<T>(T, eoFill: Bool) -> some Shape\nReturns a new shape with filled regions in either this shape or the given shape.\nRelationships\nInherits From\nAnimatable\nSendable\nView\nInherited By\nInsettableShape\nConforming Types\nAnyShape\nButtonBorderShape\nCapsule\nCircle\nContainerRelativeShape\nEllipse\nOffsetShape\nPath\nRectangle\nRotatedShape\nRoundedRectangle\nScaledShape\nTransformedShape\nUnevenRoundedRectangle\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "StrokeShapeView",
        "url": "https://developer.apple.com/documentation/swiftui/strokeshapeview",
        "html": "Overview\n\nYou don\u2019t create this type directly; it\u2019s the return type of Shape.stroke.\n\nTopics\nCreating a stroke shape view\ninit(shape: Content, style: Style, strokeStyle: StrokeStyle, isAntialiased: Bool, background: Background)\nCreate a StrokeShapeView.\nGetting shape view properties\nvar background: Background\nThe background shown beneath this view.\nvar isAntialiased: Bool\nWhether this shape should be drawn antialiased.\nvar shape: Content\nThe shape that this type draws and provides for other drawing operations.\nvar strokeStyle: StrokeStyle\nThe stroke style used when stroking this view\u2019s shape.\nvar style: Style\nThe style that strokes this view\u2019s shape.\nRelationships\nConforms To\nShapeView\nView\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "StrokeStyle",
        "url": "https://developer.apple.com/documentation/swiftui/strokestyle",
        "html": "Topics\nCreating a stroke style\ninit(lineWidth: CGFloat, lineCap: CGLineCap, lineJoin: CGLineJoin, miterLimit: CGFloat, dash: [CGFloat], dashPhase: CGFloat)\nCreates a new stroke style from the given components.\nSetting stroke style properties\nvar lineWidth: CGFloat\nThe width of the stroked path.\nvar lineCap: CGLineCap\nThe endpoint style of a line.\nvar lineJoin: CGLineJoin\nThe join type of a line.\nvar miterLimit: CGFloat\nA threshold used to determine whether to use a bevel instead of a miter at a join.\nvar dash: [CGFloat]\nThe lengths of painted and unpainted segments used to make a dashed line.\nvar dashPhase: CGFloat\nHow far into the dash pattern the line starts.\nRelationships\nConforms To\nAnimatable\nEquatable\nSendable\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "Path",
        "url": "https://developer.apple.com/documentation/swiftui/path",
        "html": "Topics\nCreating a path\ninit()\nCreates an empty path.\ninit((inout Path) -> ())\nCreates an empty path, then executes a closure to add its initial elements.\ninit(CGMutablePath)\nCreates a path from a copy of a mutable shape path.\ninit(CGPath)\nCreates a path from an immutable shape path.\ninit?(String)\nInitializes from the result of a previous call to Path.stringRepresentation. Fails if the string does not describe a valid path.\ninit(CGRect)\nCreates a path containing a rectangle.\ninit(ellipseIn: CGRect)\nCreates a path as an ellipse within the given rectangle.\ninit(roundedRect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a path containing a rounded rectangle.\ninit(roundedRect: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a path as the given rounded rectangle, which may have uneven corner radii.\nGetting the path\u2019s characteristics\nvar boundingRect: CGRect\nA rectangle containing all path segments.\nvar cgPath: CGPath\nAn immutable path representing the elements in the path.\nfunc contains(CGPoint, eoFill: Bool) -> Bool\nReturns true if the path contains a specified point.\nvar currentPoint: CGPoint?\nReturns the last point in the path, or nil if the path contains no points.\nvar description: String\nA description of the path that may be used to recreate the path via init?(_:).\nvar isEmpty: Bool\nA Boolean value indicating whether the path contains zero elements.\nDrawing a path\nfunc move(to: CGPoint)\nBegins a new subpath at the specified point.\nfunc addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and angles.\nfunc addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and two tangent lines.\nfunc addCurve(to: CGPoint, control1: CGPoint, control2: CGPoint)\nthe curve.\nfunc addEllipse(in: CGRect, transform: CGAffineTransform)\nAdds an ellipse that fits inside the specified rectangle to the path.\nfunc addLine(to: CGPoint)\nAppends a straight line segment from the current point to the specified point.\nfunc addLines([CGPoint])\nAdds a sequence of connected straight-line segments to the path.\nfunc addPath(Path, transform: CGAffineTransform)\nAppends another path value to this path.\nfunc addQuadCurve(to: CGPoint, control: CGPoint)\nthe curve.\nfunc addRect(CGRect, transform: CGAffineTransform)\nAdds a rectangular subpath to the path.\nfunc addRects([CGRect], transform: CGAffineTransform)\nAdds a set of rectangular subpaths to the path.\nfunc addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform)\nAdds an arc of a circle to the path, specified with a radius and a difference in angle.\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc closeSubpath()\nCloses and completes the current subpath.\nTransforming the path\nfunc applying(CGAffineTransform) -> Path\nReturns a path constructed by applying the transform to all points of the path.\nfunc offsetBy(dx: CGFloat, dy: CGFloat) -> Path\nReturns a path constructed by translating all its points.\nfunc trimmedPath(from: CGFloat, to: CGFloat) -> Path\nReturns a partial copy of the path.\nPerforming operations on the path\nfunc addRoundedRect(in: CGRect, cornerSize: CGSize, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle to the path.\nfunc intersection(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions common to both paths.\nfunc lineIntersection(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that overlaps the filled regions of the given path.\nfunc lineSubtraction(Path, eoFill: Bool) -> Path\nReturns a new path with a line from this path that does not overlap the filled region of the given path.\nfunc normalized(eoFill: Bool) -> Path\nReturns a new weakly-simple copy of this path.\nfunc subtracting(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions from this path that are not in the given path.\nfunc symmetricDifference(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions either from this path or the given path, but not in both.\nfunc union(Path, eoFill: Bool) -> Path\nReturns a new path with filled regions in either this path or the given path.\nOperating over path elements\nfunc forEach((Path.Element) -> Void)\nCalls body with each element in the path.\nenum Element\nAn element of a path.\nApplying a style\nfunc strokedPath(StrokeStyle) -> Path\nReturns a stroked copy of the path using style to define how the stroked outline is created.\nInstance Methods\nfunc addRoundedRect(in: CGRect, cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle, transform: CGAffineTransform)\nAdds a rounded rectangle with uneven corners to the path.\nRelationships\nConforms To\nAnimatable\nCustomStringConvertible\nEquatable\nLosslessStringConvertible\nSendable\nShape\nView"
    },
    {
        "title": "Canvas",
        "url": "https://developer.apple.com/documentation/swiftui/canvas",
        "html": "Overview\n\nUse a canvas to draw rich and dynamic 2D graphics inside a SwiftUI view. The canvas passes a GraphicsContext to the closure that you use to perform immediate mode drawing operations. The canvas also passes a CGSize value that you can use to customize what you draw. For example, you can use the context\u2019s stroke(_:with:lineWidth:) command to draw a Path instance:\n\nCanvas { context, size in\n    context.stroke(\n        Path(ellipseIn: CGRect(origin: .zero, size: size)),\n        with: .color(.green),\n        lineWidth: 4)\n}\n.frame(width: 300, height: 200)\n.border(Color.blue)\n\n\nThe example above draws the outline of an ellipse that exactly inscribes a canvas with a blue border:\n\nIn addition to outlined and filled paths, you can draw images, text, and complete SwiftUI views. To draw views, use the init(opaque:colorMode:rendersAsynchronously:renderer:symbols:) method to supply views that you can reference from inside the renderer. You can also add masks, apply filters, perform transforms, control blending, and more. For information about how to draw, see GraphicsContext.\n\nA canvas doesn\u2019t offer interactivity or accessibility for individual elements, including for views that you pass in as symbols. However, it might provide better performance for a complex drawing that involves dynamic data. Use a canvas to improve performance for a drawing that doesn\u2019t primarily involve text or require interactive elements.\n\nTopics\nCreating a canvas\ninit(opaque: Bool, colorMode: ColorRenderingMode, rendersAsynchronously: Bool, renderer: (inout GraphicsContext, CGSize) -> Void)\nCreates and configures a canvas.\nAvailable when Symbols is EmptyView.\ninit(opaque: Bool, colorMode: ColorRenderingMode, rendersAsynchronously: Bool, renderer: (inout GraphicsContext, CGSize) -> Void, symbols: () -> Symbols)\nCreates and configures a canvas that you supply with renderable child views.\nManaging opacity and color\nvar isOpaque: Bool\nA Boolean that indicates whether the canvas is fully opaque.\nvar colorMode: ColorRenderingMode\nThe working color space and storage format of the canvas.\nReferencing symbols\nvar symbols: Symbols\nA view that provides child views that you can use in the drawing callback.\nRendering\nvar rendersAsynchronously: Bool\nA Boolean that indicates whether the canvas can present its contents to its parent view asynchronously.\nvar renderer: (inout GraphicsContext, CGSize) -> Void\nThe drawing callback that you use to draw into the canvas.\nRelationships\nConforms To\nView\nConforms when Symbols conforms to View.\nSee Also\nImmediate mode drawing\nstruct GraphicsContext\nAn immediate mode drawing destination, and its current state."
    },
    {
        "title": "Ellipse",
        "url": "https://developer.apple.com/documentation/swiftui/ellipse",
        "html": "Topics\nCreating an ellipse\ninit()\nCreates a new ellipse shape.\nRelationships\nConforms To\nAnimatable\nInsettableShape\nSendable\nShape\nView\nSee Also\nCreating circular shapes\nstruct Circle\nA circle centered on the frame of the view containing it.\nstruct Capsule\nA capsule shape aligned inside the frame of the view containing it."
    },
    {
        "title": "Capsule",
        "url": "https://developer.apple.com/documentation/swiftui/capsule",
        "html": "Overview\n\nA capsule shape is equivalent to a rounded rectangle where the corner radius is chosen as half the length of the rectangle\u2019s smallest edge.\n\nTopics\nCreating a capsule\ninit(style: RoundedCornerStyle)\nCreates a new capsule shape.\nGetting the shape\u2019s characteristics\nvar style: RoundedCornerStyle\nRelationships\nConforms To\nAnimatable\nInsettableShape\nSendable\nShape\nView\nSee Also\nCreating circular shapes\nstruct Circle\nA circle centered on the frame of the view containing it.\nstruct Ellipse\nAn ellipse aligned inside the frame of the view containing it."
    },
    {
        "title": "UnevenRoundedRectangle",
        "url": "https://developer.apple.com/documentation/swiftui/unevenroundedrectangle",
        "html": "Topics\nCreating an uneven rounded rectangle\ninit(cornerRadii: RectangleCornerRadii, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape with uneven corners.\ninit(topLeadingRadius: CGFloat, bottomLeadingRadius: CGFloat, bottomTrailingRadius: CGFloat, topTrailingRadius: CGFloat, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape with uneven corners.\nGetting the shape\u2019s characteristics\nvar cornerRadii: RectangleCornerRadii\nThe radii of each corner of the rounded rectangle.\nvar style: RoundedCornerStyle\nThe style of corners drawn by the rounded rectangle.\nSupporting types\nvar animatableData: RectangleCornerRadii.AnimatableData\nThe data to animate.\nRelationships\nConforms To\nAnimatable\nInsettableShape\nSendable\nShape\nView\nSee Also\nCreating rectangular shapes\nstruct Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nstruct RoundedRectangle\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nenum RoundedCornerStyle\nDefines the shape of a rounded rectangle\u2019s corners.\nstruct RectangleCornerRadii\nDescribes the corner radius values of a rounded rectangle with uneven corners."
    },
    {
        "title": "RoundedRectangle",
        "url": "https://developer.apple.com/documentation/swiftui/roundedrectangle",
        "html": "Topics\nCreating a rounded rectangle\ninit(cornerRadius: CGFloat, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape.\ninit(cornerSize: CGSize, style: RoundedCornerStyle)\nCreates a new rounded rectangle shape.\nGetting the shape\u2019s characteristics\nvar cornerSize: CGSize\nThe width and height of the rounded rectangle\u2019s corners.\nvar style: RoundedCornerStyle\nThe style of corners drawn by the rounded rectangle.\nSupporting types\nvar animatableData: CGSize.AnimatableData\nThe data to animate.\nRelationships\nConforms To\nAnimatable\nInsettableShape\nSendable\nShape\nView\nSee Also\nCreating rectangular shapes\nstruct Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nenum RoundedCornerStyle\nDefines the shape of a rounded rectangle\u2019s corners.\nstruct UnevenRoundedRectangle\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nstruct RectangleCornerRadii\nDescribes the corner radius values of a rounded rectangle with uneven corners."
    },
    {
        "title": "RoundedCornerStyle",
        "url": "https://developer.apple.com/documentation/swiftui/roundedcornerstyle",
        "html": "Topics\nGetting corner styles\ncase circular\nQuarter-circle rounded rect corners.\ncase continuous\nContinuous curvature rounded rect corners.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nCreating rectangular shapes\nstruct Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nstruct RoundedRectangle\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nstruct UnevenRoundedRectangle\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nstruct RectangleCornerRadii\nDescribes the corner radius values of a rounded rectangle with uneven corners."
    },
    {
        "title": "Navigation",
        "url": "https://developer.apple.com/documentation/swiftui/navigation",
        "html": "Overview\n\nUse navigation containers to provide structure to your app\u2019s user interface, enabling people to easily move among the parts of your app.\n\nFor example, people can move forward and backward through a stack of views using a NavigationStack, or choose which view to display from a tab bar using a TabView.\n\nConfigure navigation containers by adding view modifiers like navigationSplitViewStyle(_:) to the container. Use other modifiers on the views inside the container to affect the container\u2019s behavior when showing that view. For example, you can use navigationTitle(_:) on a view to provide a toolbar title to display when showing that view.\n\nTopics\nPresenting views in columns\nBringing robust navigation structure to your SwiftUI app\nUse navigation links, stacks, destinations, and paths to provide a streamlined experience for all platforms, as well as behaviors such as deep linking and state restoration.\nMigrating to new navigation types\nImprove navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.\nstruct NavigationSplitView\nA view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nfunc navigationSplitViewColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the column containing this view.\nfunc navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the column containing this view.\nstruct NavigationSplitViewVisibility\nThe visibility of the leading columns in a navigation split view.\nstruct NavigationLink\nA view that controls a navigation presentation.\nStacking views in one column\nstruct NavigationStack\nA view that displays a root view and enables you to present additional views over the root view.\nstruct NavigationPath\nA type-erased list of data representing the content of a navigation stack.\nfunc navigationDestination<D, C>(for: D.Type, destination: (D) -> C) -> some View\nAssociates a destination view with a presented data type for use within a navigation stack.\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> some View\nAssociates a destination view with a binding that can be used to push the view onto a NavigationStack.\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> some View\nAssociates a destination view with a bound value for use within a navigation stack or navigation split view\nManaging column collapse\nstruct NavigationSplitViewColumn\nA view that represents a column in a navigation split view.\nSetting titles for navigation content\nfunc navigationTitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a localized string.\nfunc navigationTitle(Text) -> some View\nConfigures the view\u2019s title for purposes of navigation.\nfunc navigationTitle<S>(S) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string.\nfunc navigationTitle<V>(() -> V) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a custom view.\nfunc navigationTitle(Binding<String>) -> some View\nConfigures the view\u2019s title for purposes of navigation, using a string binding.\nfunc navigationSubtitle<S>(S) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a string.\nfunc navigationSubtitle(Text) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation.\nfunc navigationSubtitle(LocalizedStringKey) -> some View\nConfigures the view\u2019s subtitle for purposes of navigation, using a localized string.\nfunc navigationDocument<D>(D) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument(URL) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<I, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I>(D, preview: SharePreview<Never, I>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D>(D, preview: SharePreview<Never, Never>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nfunc navigationDocument<D, I1, I2>(D, preview: SharePreview<I1, I2>) -> some View\nConfigures the view\u2019s document for purposes of navigation.\nConfiguring the navigation bar\nfunc navigationBarBackButtonHidden(Bool) -> some View\nHides the navigation bar back button for the view.\nfunc navigationBarTitleDisplayMode(NavigationBarItem.TitleDisplayMode) -> some View\nConfigures the title display mode for this view.\nstruct NavigationBarItem\nA configuration for a navigation bar that represents a view at the top of a navigation stack.\nConfiguring the sidebar\nvar sidebarRowSize: SidebarRowSize\nThe current size of sidebar rows.\nenum SidebarRowSize\nThe standard sizes of sidebar rows.\nPresenting views in tabs\nstruct TabView\nA view that switches between multiple child views using interactive user interface elements.\nfunc tabViewStyle<S>(S) -> some View\nSets the style for the tab view within the current environment.\nfunc tabItem<V>(() -> V) -> some View\nSets the tab bar item associated with this view.\nDisplaying views in multiple panes\nstruct HSplitView\nA layout container that arranges its children in a horizontal line and allows the user to resize them using dividers placed between them.\nstruct VSplitView\nA layout container that arranges its children in a vertical line and allows the user to resize them using dividers placed between them.\nDeprecated Types\nstruct NavigationView\nA view for presenting a stack of views that represents a visible path in a navigation hierarchy.\nDeprecated\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "presentedWindowStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/presentedwindowstyle(_:)",
        "html": "See Also\nStyling windows from a view inside the window\nfunc presentedWindowToolbarStyle<S>(S) -> some View\nSets the style for the toolbar in windows created by interacting with this view."
    },
    {
        "title": "Controls and indicators",
        "url": "https://developer.apple.com/documentation/swiftui/controls-and-indicators",
        "html": "Overview\n\nSwiftUI provides controls that enable user interaction specific to each platform and context. For example, people can initiate events with buttons and links, or choose among a set of discrete values with different kinds of pickers. You can also display information to the user with indicators like progress views and gauges.\n\nUse these built-in controls and indicators when composing custom views, and style them to match the needs of your app\u2019s user interface. For design guidance, see All components in the Human Interface Guidelines.\n\nTopics\nCreating buttons\nstruct Button\nA control that initiates an action.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nfunc buttonBorderShape(ButtonBorderShape) -> some View\nSets the border shape for buttons in this view.\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> some View\nSets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.\nvar buttonRepeatBehavior: ButtonRepeatBehavior\nWhether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.\nstruct ButtonBorderShape\nA shape that is used to draw a button\u2019s border.\nstruct ButtonRole\nA value that describes the purpose of a button.\nstruct ButtonRepeatBehavior\nThe options for controlling the repeatability of button actions.\nCreating special-purpose buttons\nstruct EditButton\nA button that toggles the edit mode environment value.\nstruct PasteButton\nA system button that reads items from the pasteboard and delivers it to a closure.\nstruct RenameButton\nA button that triggers a standard rename action.\nLinking to other content\nstruct Link\nA control for navigating to a URL.\nstruct ShareLink\nA view that controls a sharing presentation.\nstruct SharePreview\nA representation of a type to display in a share preview.\nstruct TextFieldLink\nA control that requests text input from the user when pressed.\nstruct HelpLink\nA button with a standard appearance that opens app-specific help documentation.\nGetting numeric inputs\nstruct Slider\nA control for selecting a value from a bounded linear range of values.\nstruct Stepper\nA control that performs increment and decrement actions.\nstruct Toggle\nA control that toggles between on and off states.\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy.\nChoosing from a set of options\nstruct Picker\nA control for selecting from a set of mutually exclusive values.\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nfunc horizontalRadioGroupLayout() -> some View\nSets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.\nfunc defaultWheelPickerItemHeight(CGFloat) -> some View\nSets the default wheel-style picker item height.\nvar defaultWheelPickerItemHeight: CGFloat\nThe default height of an item in a wheel-style picker, such as a date picker.\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> some View\nSpecifies the selection effect to apply to a palette item.\nstruct PaletteSelectionEffect\nThe selection effect to apply to a palette item.\nChoosing dates\nstruct DatePicker\nA control for selecting an absolute date.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nstruct MultiDatePicker\nA control for picking multiple dates.\nvar calendar: Calendar\nThe current calendar that views should use when handling dates.\nvar timeZone: TimeZone\nThe current time zone that views should use when handling dates.\nChoosing a color\nstruct ColorPicker\nA control used to select a color from the system color picker UI.\nIndicating a value\nstruct Gauge\nA view that shows a value within a range.\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nstruct ProgressView\nA view that shows the progress toward completion of a task.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nstruct DefaultDateProgressLabel\nThe default type of the current value label when used by a date-relative progress view.\nIndicating missing content\nstruct ContentUnavailableView\nAn interface, consisting of a label and additional content, that you display when the content of your app is unavailable to users.\nProviding haptic feedback\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> some View\nPlays the specified feedback when the provided trigger value changes.\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> some View\nPlays feedback when returned from the feedback closure after the provided trigger value changes.\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> some View\nPlays the specified feedback when the provided trigger value changes and the condition closure returns true.\nstruct SensoryFeedback\nRepresents a type of haptic and/or audio feedback that can be played.\nSizing controls\nfunc controlSize(ControlSize) -> some View\nSets the size for controls within this view.\nvar controlSize: ControlSize\nThe size to apply to controls within a view.\nenum ControlSize\nThe size classes, like regular or small, that you can apply to controls within a view.\nActivating controls\nvar controlActiveState: ControlActiveState\nThe active state of controls in the view.\nenum ControlActiveState\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "Rectangle",
        "url": "https://developer.apple.com/documentation/swiftui/rectangle",
        "html": "Topics\nCreating a rectangle\ninit()\nCreates a new rectangle shape.\nRelationships\nConforms To\nAnimatable\nInsettableShape\nSendable\nShape\nView\nSee Also\nCreating rectangular shapes\nstruct RoundedRectangle\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nenum RoundedCornerStyle\nDefines the shape of a rounded rectangle\u2019s corners.\nstruct UnevenRoundedRectangle\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nstruct RectangleCornerRadii\nDescribes the corner radius values of a rounded rectangle with uneven corners."
    },
    {
        "title": "defaultSize(width:height:depth:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultsize(width:height:depth:)",
        "html": "Parameters\nwidth\n\nThe default width for the created window.\n\nheight\n\nThe default height for the created window.\n\ndepth\n\nThe default depth for the created volumetric window.\n\nReturn Value\n\nA scene that uses a default size for new windows.\n\nDiscussion\n\nUse this modifier to indicate the default initial size for a new 3D window created from a Scene using VolumetricWindowStyle:\n\nWindowGroup {\n    ContentView()\n}\n.windowStyle(.volumetric)\n.defaultSize(width: 600, height: 400, depth: 600)\n\n\nEach parameter is specified in points. The size of a volumetric scene is immutable after creation.\n\nThis modifier affects only windows that have the volumetric style in visionOS.\n\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "defaultSize(width:height:depth:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultsize(width:height:depth:in:)",
        "html": "Parameters\nwidth\n\nThe default width for the created window.\n\nheight\n\nThe default height for the created window.\n\ndepth\n\nThe default depth for the created volumetric window.\n\nunit\n\nThe unit of length the dimensions of the window are specified in.\n\nReturn Value\n\nA scene that uses a default size for new windows.\n\nDiscussion\n\nUse this modifier to indicate the default initial size for a new 3D window created from a Scene using VolumetricWindowStyle:\n\nWindowGroup {\n    ContentView()\n}\n.windowStyle(.volumetric)\n.defaultSize(width: 1, height: 1, depth: 0.5, in: .meters)\n\n\nEach parameter is specified in the unit you provide. The size of a volumetric scene is immutable after creation.\n\nThis modifier affects only windows that have the volumetric style in visionOS.\n\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "defaultSize(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultsize(_:)-5y8n",
        "html": "Parameters\nsize\n\nThe default size for new windows created from a scene.\n\nReturn Value\n\nA scene that uses a default size for new windows.\n\nDiscussion\n\nUse this scene modifier to indicate a default initial size for a new window that the system creates from a Scene declaration. For example, you can request that new windows that a WindowGroup generates occupy 600 points in the x-dimension and 400 points in the y-dimension:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .defaultSize(CGSize(width: 600, height: 400))\n    }\n}\n\n\nThe size that you specify acts only as a default for when the window first appears. People can later resize the window using interface controls that the system provides. Also, during state restoration, the system restores windows to their most recent size rather than the default size.\n\nIf you specify a default size that\u2019s outside the range of the window\u2019s inherent resizability in one or both dimensions, the system clamps the affected dimension to keep it in range. You can configure the resizability of a scene using the windowResizability(_:) modifier.\n\nThe default size modifier affects any scene type that creates windows in macOS, namely:\n\nWindowGroup\n\nWindow\n\nDocumentGroup\n\nSettings\n\nIf you want to specify the input directly in terms of width and height, use defaultSize(width:height:) instead.\n\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "defaultSize(_:in:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultsize(_:in:)",
        "html": "Parameters\nwidth\n\nThe default width for the created window.\n\nheight\n\nThe default height for the created window.\n\ndepth\n\nThe default depth for the created volumetric window.\n\nunit\n\nThe unit of length the dimensions of the window are specified in.\n\nReturn Value\n\nA scene that uses a default size for new windows.\n\nDiscussion\n\nUse this modifier to indicate the default initial size for a new 3D window created from a Scene using VolumetricWindowStyle:\n\nWindowGroup {\n    ContentView()\n}\n.windowStyle(.volumetric)\n.defaultSize(Size3D(width: 1, height: 1, depth: 0.5), in: .meters)\n\n\nEach parameter is specified in the unit you provide. The size of a volumetric scene is immutable after creation.\n\nThis modifier affects only windows that have the volumetric style in visionOS.\n\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "defaultSize(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/defaultsize(_:)-4w9ac",
        "html": "Parameters\nsize\n\nThe default 3D size for the created window.\n\nReturn Value\n\nA scene that uses a default size for new windows.\n\nDiscussion\n\nUse this modifier to indicate the default initial size for a new 3D window created from a Scene using VolumetricWindowStyle:\n\nWindowGroup {\n    ContentView()\n}\n.windowStyle(.volumetric)\n.defaultSize(Size3D(width: 600, height: 400, depth: 600))\n\n\nEach parameter is specified in points. The size of a volumetric scene is immutable after creation.\n\nThis modifier affects only windows that have the volumetric style in visionOS.\n\nSee Also\nPositioning and sizing a window\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window."
    },
    {
        "title": "upperLimbVisibility(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/view/upperlimbvisibility(_:)",
        "html": "Discussion\n\nThe system can show the user\u2019s upper limbs during fully immersive experiences, but you can also hide them, for example, in order to display virtual hands instead.\n\nNote that this modifier only sets a preference and ultimately the system will decide if it will honor it or not. The system may by unable to honor the preference if the immersive space is currently not visible.\n\nSee Also\nHiding upper limbs during immersion\nfunc upperLimbVisibility(Visibility) -> some Scene\nSets the preferred visibility of the user\u2019s upper limbs, while an ImmersiveSpace scene is presented.\nBeta"
    },
    {
        "title": "upperLimbVisibility(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/upperlimbvisibility(_:)",
        "html": "Discussion\n\nThe system can show the user\u2019s upper limbs during fully immersive experiences, but you can also hide them, for example, in order to display virtual hands instead.\n\nNote that this modifier only sets a preference and ultimately the system will decide if it will honor it or not. The system may by unable to honor the preference if the immersive space is currently not visible.\n\nSee Also\nHiding upper limbs during immersion\nfunc upperLimbVisibility(Visibility) -> some View\nSets the preferred visibility of the user\u2019s upper limbs, while an ImmersiveSpace scene is presented.\nBeta"
    },
    {
        "title": "DismissImmersiveSpaceAction",
        "url": "https://developer.apple.com/documentation/swiftui/dismissimmersivespaceaction",
        "html": "Overview\n\nUse the dismissImmersiveSpace environment value to get the instance of this structure for a given Environment. Then call the instance to dismiss the currently opened space. You call the instance directly because it defines a callAsFunction() method that Swift calls when you call the instance.\n\nFor example, you can define a button that closes the currently opened immersive space:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        ImmersiveSpace(id: \"solarSystem\") {\n            SolarSystemView()\n        }\n    }\n}\n\n\nstruct DismissImmersiveSpaceButton: View {\n    @Environment(\\.dismissImmersiveSpace)\n    private var dismissImmersiveSpace\n\n\n    var body: some View {\n        Button(\"Close Solar System Immersive Space\") {\n            Task {\n                await dismissImmersiveSpace()\n                print(\"Dismissing Immersive Space complete\")\n            }\n        }\n    }\n}\n\nTopics\nCalling the action\nfunc callAsFunction() async\nDismisses the currently opened immersive space.\nSee Also\nClosing the immersive space\nvar dismissImmersiveSpace: DismissImmersiveSpaceAction\nAn immersive space dismissal action stored in a view\u2019s environment.\nBeta"
    },
    {
        "title": "Technology-specific views",
        "url": "https://developer.apple.com/documentation/swiftui/technology-specific-views",
        "html": "Overview\n\nTo access SwiftUI views that another framework defines, import both SwiftUI and the other framework into the file where you use the view. You can find the framework to import by looking at the availability information on the view\u2019s documentation page.\n\nFor example, to use the Map view in your app, import both SwiftUI and MapKit.\n\nimport SwiftUI\nimport MapKit\n\n\nstruct MyMapView: View {\n    // Center the map on Joshua Tree National Park.\n    @State private var region = MKCoordinateRegion(\n            center: CLLocationCoordinate2D(latitude: 34.011_286, longitude: -116.166_868),\n            span: MKCoordinateSpan(latitudeDelta: 0.2, longitudeDelta: 0.2)\n        )\n\n\n    var body: some View {\n        Map(coordinateRegion: $region)\n    }\n}\n\n\nFor design guidance, see All technologies in the Human Interface Guidelines.\n\nTopics\nAccessing Apple Pay and Wallet\nstruct PayWithApplePayButton\nstruct AddPassToWalletButton\nstruct VerifyIdentityWithWalletButton\nA view that displays a button for identity verification.\nstruct AsyncShareablePassConfiguration\nAuthorizing and authenticating\nstruct LocalAuthenticationView\nA SwiftUI view that displays an authentication interface.\nstruct SignInWithAppleButton\nThe view that creates the Sign in with Apple button for display.\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style).\nvar authorizationController: AuthorizationController\nA value provided in the SwiftUI environment that views can use to perform authorization requests.\nvar webAuthenticationSession: WebAuthenticationSession\nA value provided in the SwiftUI environment that views can use to authenticate a user through a web service.\nConfiguring Family Sharing\nstruct FamilyActivityPicker\nA view in which users specify applications, web domains, and categories without revealing their choices to the app.\nfunc familyActivityPicker(isPresented: Binding<Bool>, selection: Binding<FamilyActivitySelection>) -> some View\nPresents an activity picker view as a sheet.\nfunc familyActivityPicker(headerText: String?, footerText: String?, isPresented: Binding<Bool>, selection: Binding<FamilyActivitySelection>) -> some View\nPresents an activity picker view as a sheet.\nReporting on device activity\nstruct DeviceActivityReport\nA view that reports the user\u2019s application, category, and web domain activity in a privacy-preserving way.\nCreating graphics\nstruct Chart\nA SwiftUI view that displays a chart.\nstruct SceneView\nA SwiftUI view for displaying 3D SceneKit content.\nstruct SpriteView\nA SwiftUI view that renders a SpriteKit scene.\nGetting location information\nstruct LocationButton\nA SwiftUI button that grants one-time location authorization.\nstruct Map\nA view that displays an embedded map interface.\nDisplaying media\nstruct CameraView\nA SwiftUI view into which a video stream or an image snapshot is rendered.\nstruct NowPlayingView\nA view that displays the system\u2019s Now Playing interface so that the user can control audio.\nstruct VideoPlayer\nA view that displays content from a player and a native user interface to control playback.\nSelecting photos\nstruct PhotosPicker\nA view that displays a Photos picker for choosing assets from the photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<PhotosPickerItem?>, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a PhotosPickerItem from a given photo library.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem.\nfunc photosPicker(isPresented: Binding<Bool>, selection: Binding<[PhotosPickerItem]>, maxSelectionCount: Int?, selectionBehavior: PhotosPickerSelectionBehavior, matching: PHPickerFilter?, preferredItemEncoding: PhotosPickerItem.EncodingDisambiguationPolicy, photoLibrary: PHPhotoLibrary) -> some View\nPresents a Photos picker that selects a collection of PhotosPickerItem from a given photo library.\nfunc photosPickerAccessoryVisibility(Visibility, edges: Edge.Set) -> some View\nSets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.\nfunc photosPickerDisabledCapabilities(PHPickerCapabilities) -> some View\nDisables capabilities of the Photos picker.\nfunc photosPickerStyle(PhotosPickerStyle) -> some View\nSets the mode of the Photos picker.\nPreviewing content\nfunc quickLookPreview(Binding<URL?>) -> some View\nPresents a Quick Look preview of the contents of a single URL.\nfunc quickLookPreview<Items>(Binding<Items.Element?>, in: Items) -> some View\nPresents a Quick Look preview of the URLs you provide.\nInteracting with networked devices\nstruct DevicePicker\nA SwiftUI view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.\nConfiguring a Live Activity\nfunc activitySystemActionForegroundColor(Color?) -> some View\nThe text color for the auxiliary action button that the system shows next to a Live Activity on the Lock Screen.\nfunc activityBackgroundTint(Color?) -> some View\nSets the tint color for the background of a Live Activity that appears on the Lock Screen.\nvar isActivityFullscreen: Bool\nA Boolean value that indicates whether the Live Activity appears in a full-screen presentation.\nInteracting with the App Store and Apple Music\nfunc appStoreOverlay(isPresented: Binding<Bool>, configuration: () -> SKOverlay.Configuration) -> some View\nPresents a StoreKit overlay when a given condition is true.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>) -> some View\nfunc refundRequestSheet(for: Transaction.ID, isPresented: Binding<Bool>, onDismiss: ((Result<Transaction.RefundRequestStatus, Transaction.RefundRequestError>) -> ())?) -> some View\nDisplay the refund request sheet for the given transaction.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: (Result<Void, Error>) -> Void) -> some View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nfunc musicSubscriptionOffer(isPresented: Binding<Bool>, options: MusicSubscriptionOffer.Options, onLoadCompletion: ((Error)?) -> Void) -> some View\nInitiates the process of presenting a sheet with subscription offers for Apple Music when the isPresented binding is true.\nfunc currentEntitlementTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<VerificationResult<Transaction>?>) async -> ()) -> some View\nDeclares the view as dependent on the entitlement of an in-app purchase product for productID and returns a modified view.\nfunc inAppPurchaseOptions(((Product) async -> Set<Product.PurchaseOption>)?) -> some View\nAdd a function to call before initiating a purchase from an in-app store within view, providing a set of options for the purchase.\nfunc manageSubscriptionsSheet(isPresented: Binding<Bool>, subscriptionGroupID: String) -> some View\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, Error>) async -> ())?) -> some View\nAdd an action to perform when a purchase initiated from an in-app store within this view completes.\nfunc onInAppPurchaseStart(perform: ((Product) async -> ())?) -> some View\nAdd an action to perform when a user triggers the purchase button on an in-app store within this view.\nfunc productIconBorder() -> some View\nAdds a standard border to an icon used by an ProductView .\nfunc productViewStyle(some ProductViewStyle) -> some View\nSets the style for in-app store products within a view.\nfunc storeButton(Visibility, for: StoreButtonKind...) -> some View\nSpecifies the visibility of certain kinds of auxiliary buttons used by StoreView or SubscriptionStoreView instances within the view.\nfunc storeProductTask(for: Product.ID, priority: TaskPriority, action: (Product.TaskState) async -> ()) -> some View\nDeclares the view as dependent on the in-app purchase product for id and returns a modified view.\nfunc storeProductsTask(for: some Collection<String> & Equatable & Sendable, priority: TaskPriority, action: (Product.CollectionTaskState) async -> ()) -> some View\nDeclares the view as dependent on a collection of in-app purchase products and returns a modified view.\nfunc subscriptionStatusTask(for: String, priority: TaskPriority, action: (EntitlementTaskState<[Product.SubscriptionInfo.Status]>) async -> ()) -> some View\nDeclares the view as dependent on the status of an auto-renewable subscription group for groupID and returns a modified view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> some View\nConfigures in-app subscription store instances within a view to use a certain button label.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> some View\nSet a view to use to decorate individual subscription options within a SubscriptionStoreView.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> some View\nSets the control style for in-app subscription stores within a view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> some View\nSets the background style for picker items of SubscriptionStoreView instances within this view.\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> some View\nConfigures a view as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> some View\nConfigures a URL as the destination when someone chooses to view the corresponding policy in a SubscriptionStoreView within this view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> some View\nSets the style for terms of service or privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> some View\nSets the style for terms of service and privacy policy buttons created by SubscriptionStoreView within a view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> some View\nAdd an action to perform when someone triggers the sign in button on a SubscriptionStoreView within this view.\nfunc subscriptionStoreControlBackground(SubscriptionStoreControlBackground) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nfunc subscriptionStoreControlBackground(some ShapeStyle) -> some View\nSet the control background style for SubscriptionStoreView instances within the view.\nAccessing health data\nfunc healthDataAccessRequest(store: HKHealthStore, objectType: HKObjectType, predicate: NSPredicate?, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nRequests authorization to specific samples of the given HealthKit types; used only with types that require authorization per object Parameters: store: Your app\u2019s HKHealthStore, for which authorization will be requested objectType: The data type you want to read; this type must be a type that requires per-object authorization. predicate: An optional predicate that further restricts the objects of interest trigger: A generic equatable value; change this value to initiate a new request completion: A block that will be passed success or error when the request completes.\nfunc healthDataAccessRequest(store: HKHealthStore, readTypes: Set<HKObjectType>, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nfunc healthDataAccessRequest(store: HKHealthStore, shareTypes: Set<HKSampleType>, readTypes: Set<HKObjectType>?, trigger: some Equatable, completion: (Result<Bool, Error>) -> Void) -> some View\nRequests authorization to read and share the given HealthKit types Parameters: store: Your app\u2019s HKHealthStore, for which authorization will be requested shareTypes: An optional set containing the data types you want to share readTypes: An optional set containing the data types you want to read trigger: A generic equatable value; change this value to initiate a new request completion: A block that will be passed success or error when the request completes.\nProviding tips\nfunc popoverTip<Content>(Content, arrowEdge: Edge) -> some View\nPresents a popover tip on the modified view.\nfunc popoverTip<Content>(Content, arrowEdge: Edge, action: (Tips.Action) -> Void) -> some View\nPresents a popover tip on the modified view.\nfunc tipBackground(some ShapeStyle) -> some View\nSets the tip\u2019s view background to a style.\nfunc tipCornerRadius(CGFloat, antialiased: Bool) -> some View\nfunc tipImageSize(CGSize) -> some View\nfunc tipViewStyle(some TipViewStyle) -> some View\nSets the given style for TipView within the view hierarchy\nSee Also\nFramework integration\nAppKit integration\nAdd AppKit views to your SwiftUI app, or use SwiftUI views in your AppKit app.\nUIKit integration\nAdd UIKit views to your SwiftUI app, or use SwiftUI views in your UIKit app.\nWatchKit integration\nAdd WatchKit views to your SwiftUI app, or use SwiftUI views in your WatchKit app."
    },
    {
        "title": "BlurReplaceTransition",
        "url": "https://developer.apple.com/documentation/swiftui/blurreplacetransition",
        "html": "Topics\nStructures\nstruct Configuration\nConfiguration properties for a transition.\nInitializers\ninit(configuration: BlurReplaceTransition.Configuration)\nCreates a new transition.\nInstance Properties\nvar configuration: BlurReplaceTransition.Configuration\nThe transition configuration.\nRelationships\nConforms To\nTransition"
    },
    {
        "title": "Xcode library customization",
        "url": "https://developer.apple.com/documentation/swiftui/xcode-library-customization",
        "html": "Overview\n\nYou can add your custom SwiftUI views and view modifiers to Xcode\u2019s library. This allows anyone developing your app or adopting your framework to access them by clicking the Library button (+) in Xcode\u2019s toolbar. You can select and drag the custom library items into code, just like you would for system-provided items.\n\nTo add items to the library, create a structure that conforms to the LibraryContentProvider protocol and encapsulate any items you want to add as LibraryItem instances. Implement the views computed property to add library items containing views. Implement the modifiers(base:) method to add items containing view modifiers. Xcode harvests items from all of the library content providers in your project as you work, and makes them available to you in its library.\n\nTopics\nCreating library items\nprotocol LibraryContentProvider\nA source of Xcode library and code completion content.\nstruct LibraryItem\nA single item to add to the Xcode library.\nSee Also\nTool support\nPreviews in Xcode\nGenerate dynamic, interactive previews of your custom views."
    },
    {
        "title": "SettingsLink",
        "url": "https://developer.apple.com/documentation/swiftui/settingslink",
        "html": "Overview\n\nOn macOS, clicking on the link opens the window for the scene or orders it to the front if it is already open.\n\nTopics\nCreating a settings link\ninit()\nCreates a settings link with the default system label.\ninit(label: () -> Label)\nCreates a settings link with a custom label.\nSupporting types\nstruct DefaultSettingsLinkLabel\nThe default label to use for a settings link.\nRelationships\nConforms To\nView\nSee Also\nManaging a settings window\nstruct Settings\nA scene that presents an interface for viewing and modifying an app\u2019s settings."
    },
    {
        "title": "menuBarExtraStyle(_:)",
        "url": "https://developer.apple.com/documentation/swiftui/scene/menubarextrastyle(_:)",
        "html": "See Also\nCreating a menu bar extra\nstruct MenuBarExtra\nA scene that renders itself as a persistent control in the system menu bar.\nprotocol MenuBarExtraStyle\nA specification for the appearance and behavior of a menu bar extra scene."
    },
    {
        "title": "Previews in Xcode",
        "url": "https://developer.apple.com/documentation/swiftui/previews-in-xcode",
        "html": "Overview\n\nWhen you create a custom View with SwiftUI, Xcode can display a preview of the view\u2019s content that stays up-to-date as you make changes to the view\u2019s code. You use one of the preview macros \u2014 like Preview(_:body:) \u2014 to tell Xcode what to display. Xcode shows the preview in a canvas beside your code.\n\nDifferent preview macros enable different kinds of configuration. For example, you can add traits that affect the preview\u2019s appearance using the Preview(_:traits:_:body:) macro or add custom viewpoints for the preview using the Preview(_:traits:body:cameras:) macro. You can also check how your view behaves inside a specific scene type. For example, in visionOS you can use the Preview(_:immersionStyle:traits:body:) macro to preview your view inside an ImmersiveSpace.\n\nYou typically rely on preview macros to create previews in your code. However, if you can\u2019t get the behavior you need using a preview macro, you can use the PreviewProvider protocol and its associated supporting types to define and configure a preview.\n\nTopics\nCreating a preview\nmacro Preview(String?, body: () -> View)\nCreates a preview of a SwiftUI view.\nmacro Preview(String?, traits: PreviewTrait<Preview.ViewTraits>, PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view using the specified traits.\nmacro Preview(String?, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view using the specified traits and custom viewpoints.\nBeta\nCreating a preview in the context of a scene\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in an immersive space.\nBeta\nmacro Preview<Style>(String?, immersionStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in an immersive space with custom viewpoints.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View)\nCreates a preview of a SwiftUI view in a window.\nBeta\nmacro Preview<Style>(String?, windowStyle: Style, traits: PreviewTrait<Preview.ViewTraits>..., body: () -> View, cameras: () -> [PreviewCamera])\nCreates a preview of a SwiftUI view in a window with custom viewpoints.\nBeta\nDefining a preview\nprotocol PreviewProvider\nA type that produces view previews in Xcode.\nenum PreviewPlatform\nPlatforms that can run the preview.\nfunc previewDisplayName(String?) -> some View\nSets a user visible name to show in the canvas for a preview.\nCustomizing a preview\nfunc previewDevice(PreviewDevice?) -> some View\nOverrides the device for a preview.\nstruct PreviewDevice\nA simulator device that runs a preview.\nfunc previewLayout(PreviewLayout) -> some View\nOverrides the size of the container for the preview.\nfunc previewInterfaceOrientation(InterfaceOrientation) -> some View\nOverrides the orientation of the preview.\nstruct InterfaceOrientation\nThe orientation of the interface from the user\u2019s perspective.\nSetting a context\nfunc previewContext<C>(C) -> some View\nDeclares a context for the preview.\nprotocol PreviewContext\nA context type for use with a preview.\nprotocol PreviewContextKey\nA key type for a preview context.\nSee Also\nTool support\nXcode library customization\nExpose custom views and modifiers in the Xcode library."
    },
    {
        "title": "ImmersiveAmbientBrightness",
        "url": "https://developer.apple.com/documentation/swiftui/immersiveambientbrightness",
        "html": "Topics\nType Properties\nstatic let automatic: ImmersiveAmbientBrightness\nThe default environment brightness. The value will be picked by the system.\nstatic let bright: ImmersiveAmbientBrightness\nA bright environment brightness.\nstatic let dark: ImmersiveAmbientBrightness\nA dark environment brightness.\nstatic let dim: ImmersiveAmbientBrightness\nA dimmed environment brightness.\nType Methods\nstatic func custom(Double) -> ImmersiveAmbientBrightness\nCreates an environment brightness with a custom value.\nRelationships\nConforms To\nEquatable"
    },
    {
        "title": "UIKit integration",
        "url": "https://developer.apple.com/documentation/swiftui/uikit-integration",
        "html": "Overview\n\nIntegrate SwiftUI with your app\u2019s existing content using hosting controllers to add SwiftUI views into UIKit interfaces. A hosting controller wraps a set of SwiftUI views in a form that you can then add to your storyboard-based app.\n\nYou can also add UIKit views and view controllers to your SwiftUI interfaces. A representable object wraps the designated view or view controller, and facilitates communication between the wrapped object and your SwiftUI views.\n\nFor design guidance, see the following sections in the Human Interface Guidelines:\n\nDesigning for iOS\n\nDesigning for iPadOS\n\nDesigning for tvOS\n\nTopics\nDisplaying SwiftUI views in UIKit\nUsing SwiftUI with UIKit\nLearn how to incorporate SwiftUI views into a UIKit app.\nclass UIHostingController\nA UIKit view controller that manages a SwiftUI view hierarchy.\nstruct UIHostingControllerSizingOptions\nOptions for how a hosting controller tracks its content\u2019s size.\nstruct UIHostingConfiguration\nA content configuration suitable for hosting a hierarchy of SwiftUI views.\nAdding UIKit views to SwiftUI view hierarchies\nprotocol UIViewRepresentable\nA wrapper for a UIKit view that you use to integrate that view into your SwiftUI view hierarchy.\nstruct UIViewRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view.\nprotocol UIViewControllerRepresentable\nA view that represents a UIKit view controller.\nstruct UIViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your UIKit view controller.\nSharing configuration information\nprotocol UITraitBridgedEnvironmentKey\nAn environment key that is bridged to a UIKit trait.\nHosting an ornament in UIKit\nclass UIHostingOrnament\nA model that represents an ornament suitable for being hosted in UIKit.\nBeta\nclass UIOrnament\nThe abstract base class that represents an ornament.\nBeta\nSee Also\nFramework integration\nAppKit integration\nAdd AppKit views to your SwiftUI app, or use SwiftUI views in your AppKit app.\nWatchKit integration\nAdd WatchKit views to your SwiftUI app, or use SwiftUI views in your WatchKit app.\nTechnology-specific views\nUse SwiftUI views that other Apple frameworks provide."
    },
    {
        "title": "WatchKit integration",
        "url": "https://developer.apple.com/documentation/swiftui/watchkit-integration",
        "html": "Overview\n\nIntegrate SwiftUI with your app\u2019s existing content using hosting controllers to add SwiftUI views into WatchKit interfaces. A hosting controller wraps a set of SwiftUI views in a form that you can then add to your storyboard-based app.\n\nYou can also add WatchKit views and view controllers to your SwiftUI interfaces. A representable object wraps the designated view or view controller, and facilitates communication between the wrapped object and your SwiftUI views.\n\nFor design guidance, see Designing for watchOS in the Human Interface Guidelines.\n\nTopics\nDisplaying SwiftUI views in WatchKit\nclass WKHostingController\nA WatchKit interface controller that hosts a SwiftUI view hierarchy.\nclass WKUserNotificationHostingController\nA WatchKit user notification interface controller that hosts a SwiftUI view hierarchy.\nAdding WatchKit views to SwiftUI view hierarchies\nprotocol WKInterfaceObjectRepresentable\nA view that represents a WatchKit interface object.\nstruct WKInterfaceObjectRepresentableContext\nContextual information about the state of the system that you use to create and update your WatchKit interface object.\nSee Also\nFramework integration\nAppKit integration\nAdd AppKit views to your SwiftUI app, or use SwiftUI views in your AppKit app.\nUIKit integration\nAdd UIKit views to your SwiftUI app, or use SwiftUI views in your UIKit app.\nTechnology-specific views\nUse SwiftUI views that other Apple frameworks provide."
    },
    {
        "title": "Accessible descriptions",
        "url": "https://developer.apple.com/documentation/swiftui/accessible-descriptions",
        "html": "Overview\n\nSwiftUI can often infer some information about your user interface elements, but you can use accessibility modifiers to provide even more information for users that need it.\n\nFor design guidance, see Content descriptions in the Accessibility section of the Human Interface Guidelines.\n\nTopics\nApplying labels\nfunc accessibilityLabel<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityLabel(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a label to the view that describes its contents.\nfunc accessibilityInputLabels([LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels<S>([S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityInputLabels([Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets alternate input labels with which users identify a view.\nfunc accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in: Namespace.ID) -> some View\nPairs an accessibility element representing a label with the element for the matching content.\nenum AccessibilityLabeledPairRole\nThe role of an accessibility element in a label / content pair.\nDescribing values\nfunc accessibilityValue<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nfunc accessibilityValue(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nfunc accessibilityValue(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds a textual description of the value that the view contains.\nDescribing content\nfunc accessibilityTextContentType(AccessibilityTextContentType) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets an accessibility text content type.\nfunc accessibilityHeading(AccessibilityHeadingLevel) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSets the accessibility level of this heading.\nenum AccessibilityHeadingLevel\nThe hierarchy of a heading in relation other headings.\nstruct AccessibilityTextContentType\nTextual context that assistive technologies can use to improve the presentation of spoken text.\nDescribing charts\nfunc accessibilityChartDescriptor<R>(R) -> some View\nAdds a descriptor to a View that represents a chart to make the chart\u2019s contents accessible to all users.\nprotocol AXChartDescriptorRepresentable\nA type to generate an AXChartDescriptor object that you use to provide information about a chart and its data for an accessible experience in VoiceOver or other assistive technologies.\nAdding custom descriptions\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(AccessibilityCustomContentKey, Text?, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(LocalizedStringKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(Text, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, LocalizedStringKey, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent<V>(AccessibilityCustomContentKey, V, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nfunc accessibilityCustomContent(LocalizedStringKey, Text, importance: AXCustomContent.Importance) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdd additional accessibility information to the view.\nstruct AccessibilityCustomContentKey\nKey used to specify the identifier and label associated with an entry of additional accessibility information.\nAssigning traits to content\nfunc accessibilityAddTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds the given traits to the view.\nfunc accessibilityRemoveTraits(AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nRemoves the given traits from this view.\nstruct AccessibilityTraits\nA set of accessibility traits that describe how an element behaves.\nOffering hints\nfunc accessibilityHint(LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nfunc accessibilityHint(Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nfunc accessibilityHint<S>(S) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nCommunicates to the user what happens after performing the view\u2019s action.\nConfiguring VoiceOver\nfunc speechAdjustedPitch(Double) -> some View\nRaises or lowers the pitch of spoken text.\nfunc speechAlwaysIncludesPunctuation(Bool) -> some View\nSets whether VoiceOver should always speak all punctuation in the text view.\nfunc speechAnnouncementsQueued(Bool) -> some View\nControls whether to queue pending announcements behind existing speech rather than interrupting speech in progress.\nfunc speechSpellsOutCharacters(Bool) -> some View\nSets whether VoiceOver should speak the contents of the text view character by character.\nSee Also\nAccessibility\nAccessibility fundamentals\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAccessible appearance\nEnhance the legibility of content in your app\u2019s interface.\nAccessible controls\nImprove access to actions that your app can undertake.\nAccessible navigation\nEnable users to navigate to specific user interface elements using rotors."
    },
    {
        "title": "AppKit integration",
        "url": "https://developer.apple.com/documentation/swiftui/appkit-integration",
        "html": "Overview\n\nIntegrate SwiftUI with your app\u2019s existing content using hosting controllers to add SwiftUI views into AppKit interfaces. A hosting controller wraps a set of SwiftUI views in a form that you can then add to your storyboard-based app.\n\nYou can also add AppKit views and view controllers to your SwiftUI interfaces. A representable object wraps the designated view or view controller, and facilitates communication between the wrapped object and your SwiftUI views.\n\nFor design guidance, see Designing for macOS in the Human Interface Guidelines.\n\nTopics\nDisplaying SwiftUI views in AppKit\nclass NSHostingController\nAn AppKit view controller that hosts SwiftUI view hierarchy.\nclass NSHostingView\nAn AppKit view that hosts a SwiftUI view hierarchy.\nstruct NSHostingSizingOptions\nOptions for how hosting views and controllers reflect their content\u2019s size into Auto Layout constraints.\nstruct NSHostingSceneBridgingOptions\nOptions for how hosting views and controllers manage aspects of the associated window.\nAdding AppKit views to SwiftUI view hierarchies\nprotocol NSViewRepresentable\nA wrapper that you use to integrate an AppKit view into your SwiftUI view hierarchy.\nstruct NSViewRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view.\nprotocol NSViewControllerRepresentable\nA wrapper that you use to integrate an AppKit view controller into your SwiftUI interface.\nstruct NSViewControllerRepresentableContext\nContextual information about the state of the system that you use to create and update your AppKit view controller.\nSee Also\nFramework integration\nUIKit integration\nAdd UIKit views to your SwiftUI app, or use SwiftUI views in your UIKit app.\nWatchKit integration\nAdd WatchKit views to your SwiftUI app, or use SwiftUI views in your WatchKit app.\nTechnology-specific views\nUse SwiftUI views that other Apple frameworks provide."
    },
    {
        "title": "Accessible controls",
        "url": "https://developer.apple.com/documentation/swiftui/accessible-controls",
        "html": "Overview\n\nHelp people using assistive technologies to gain access to controls in your app.\n\nFor design guidance, see Buttons and controls in the Accessibility section of the Human Interface Guidelines.\n\nTopics\nAdding actions to views\nfunc accessibilityAction(AccessibilityActionKind, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityActions<Content>(() -> Content) -> some View\nAdds multiple accessibility actions to the view.\nfunc accessibilityAction(named: Text, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<S>(named: S, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction(named: LocalizedStringKey, () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAction<Label>(action: () -> Void, label: () -> Label) -> some View\nAdds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityAdjustableAction((AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nfunc accessibilityScrollAction((Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityActionKind\nThe structure that defines the kinds of available accessibility actions.\nenum AccessibilityAdjustmentDirection\nA directional indicator you use when making an accessibility adjustment.\nOffering Quick Actions to people\nfunc accessibilityQuickAction<Style, Content>(style: Style, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active.\nfunc accessibilityQuickAction<Style, Content>(style: Style, isActive: Binding<Bool>, content: () -> Content) -> some View\nAdds a quick action to be shown by the system when active.\nprotocol AccessibilityQuickActionStyle\nA type that describes the presentation style of an accessibility quick action.\nMaking gestures accessible\nfunc accessibilityActivationPoint(CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityActivationPoint(UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nThe activation point for an element is the location assistive technologies use to initiate gestures.\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional AccessibilityDirectTouchOptions option set to customize the functionality of the direct touch area.\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nAdds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.\nstruct AccessibilityDirectTouchOptions\nAn option set that defines the functionality of a view\u2019s direct touch area.\nstruct AccessibilityZoomGestureAction\nPosition and direction information of a zoom gesture that someone performs with an assistive technology like VoiceOver.\nControlling focus\nfunc accessibilityFocused(AccessibilityFocusState<Bool>.Binding) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given boolean state value.\nfunc accessibilityFocused<Value>(AccessibilityFocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its accessibility element\u2019s focus state to the given state value.\nstruct AccessibilityFocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the focus of any active accessibility technology, such as VoiceOver, changes.\nManaging interactivity\nfunc accessibilityRespondsToUserInteraction(Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nExplicitly set whether this Accessibility element responds to user interaction and would thus be interacted with by technologies such as Switch Control, Voice Control or Full Keyboard Access.\nSee Also\nAccessibility\nAccessibility fundamentals\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAccessible appearance\nEnhance the legibility of content in your app\u2019s interface.\nAccessible descriptions\nDescribe interface elements to help people understand what they represent.\nAccessible navigation\nEnable users to navigate to specific user interface elements using rotors."
    },
    {
        "title": "System events",
        "url": "https://developer.apple.com/documentation/swiftui/system-events",
        "html": "Overview\n\nSpecify view and scene modifiers to indicate how your app responds to certain system events. For example, you can use the onOpenURL(perform:) view modifier to define an action to take when your app receives a universal link, or use the backgroundTask(_:action:) scene modifier to specify an asynchronous task to carry out in response to a background task event, like the completion of a background URL session.\n\nTopics\nHandling user activities\nRestoring Your App\u2019s State with SwiftUI\nProvide app continuity for users by preserving their current activities.\nfunc userActivity<P>(String, element: P?, (P, NSUserActivity) -> ()) -> some View\nAdvertises a user activity type.\nfunc userActivity(String, isActive: Bool, (NSUserActivity) -> ()) -> some View\nAdvertises a user activity type.\nfunc onContinueUserActivity(String, perform: (NSUserActivity) -> ()) -> some View\nRegisters a handler to invoke when the view receives the specified activity type for the scene or window the view is in.\nHandling background tasks\nfunc backgroundTask<D, R>(BackgroundTask<D, R>, action: (D) async -> R) -> some Scene\nRuns the specified action when the system provides a background task.\nstruct BackgroundTask\nThe kinds of background tasks that your app or extension can handle.\nstruct SnapshotData\nThe associated data of a snapshot background task.\nstruct SnapshotResponse\nYour appplication\u2019s response to a snapshot background task.\nHandling URLs\nfunc onOpenURL(perform: (URL) -> ()) -> some View\nRegisters a handler to invoke when the view receives a url for the scene or window the view is in.\nvar openURL: OpenURLAction\nAn action that opens a URL.\nstruct OpenURLAction\nAn action that opens a URL.\nImporting and exporting transferable items\nfunc importableFromServices<T>(for: T.Type, action: ([T]) -> Bool) -> some View\nEnables importing items from services, such as Continuity Camera on macOS.\nfunc exportableToServices<T>(() -> [T]) -> some View\nExports items for consumption by shortcuts, quick actions, and services.\nfunc exportableToServices<T>(() -> [T], onEdit: ([T]) -> Bool) -> some View\nExports read-write items for consumption by shortcuts, quick actions, and services.\nImporting and exporting using item providers\nfunc importsItemProviders([UTType], onImport: ([NSItemProvider]) -> Bool) -> some View\nEnables importing item providers from services, such as Continuity Camera on macOS.\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider]) -> some View\nExports a read-only item provider for consumption by shortcuts, quick actions, and services.\nfunc exportsItemProviders([UTType], onExport: () -> [NSItemProvider], onEdit: ([NSItemProvider]) -> Bool) -> some View\nExports a read-write item provider for consumption by shortcuts, quick actions, and services.\nHandling external events\nfunc handlesExternalEvents(preferring: Set<String>, allowing: Set<String>) -> some View\nSpecifies a modifier indicating the Scene this View is in can handle matching incoming External Events.\nSee Also\nEvent handling\nGestures\nDefine interactions from taps, clicks, and swipes to fine-grained gestures.\nInput events\nRespond to input from a hardware device, like a keyboard or a Touch Bar.\nClipboard\nEnable people to move or duplicate items by issuing Copy and Paste commands.\nDrag and drop\nEnable people to move or duplicate items by dragging them from one location to another.\nFocus\nIdentify and control which visible object responds to user interaction."
    },
    {
        "title": "Accessibility fundamentals",
        "url": "https://developer.apple.com/documentation/swiftui/accessibility-fundamentals",
        "html": "Overview\n\nLike all Apple UI frameworks, SwiftUI comes with built-in accessibility support. The framework introspects common elements like navigation views, lists, text fields, sliders, buttons, and so on, and provides basic accessibility labels and values by default. You don\u2019t have to do any extra work to enable these standard accessibility features.\n\nSwiftUI also provides tools to help you enhance the accessibility of your app. To find out what enhancements you need, try using your app with accessibility features like VoiceOver, Voice Control, and Switch Control, or get feedback from users of your app that regularly use these features. Then use the accessibility view modifiers that SwiftUI provides to improve the experience. For example, you can explicitly add accessibility labels to elements in your UI using the accessibilityLabel(_:) or the accessibilityValue(_:) view modifier.\n\nCustomize your use of accessibility modifiers for all the platforms that your app runs on. For example, you may need to adjust the accessibility elements for a companion Apple Watch app that shares a common code base with an iOS app. If you integrate AppKit or UIKit controls in SwiftUI, expose any accessibility labels and make them accessible from your NSViewRepresentable or UIViewRepresentable views, or provide custom accessibility information if the underlying accessibility labels aren\u2019t available.\n\nFor design guidance, see Accessibility in the Human Interface Guidelines.\n\nTopics\nEssentials\nCreating Accessible Views\nMake your app accessible to everyone by applying accessibility modifiers to your SwiftUI views.\nCreating accessible elements\nfunc accessibilityElement(children: AccessibilityChildBehavior) -> some View\nCreates a new accessibility element, or modifies the AccessibilityChildBehavior of the existing accessibility element.\nfunc accessibilityChildren<V>(children: () -> V) -> some View\nReplaces the existing accessibility element\u2019s children with one or more new synthetic accessibility elements.\nfunc accessibilityRepresentation<V>(representation: () -> V) -> some View\nReplaces one or more accessibility elements for this view with new accessibility elements.\nstruct AccessibilityChildBehavior\nDefines the behavior for the child elements of the new parent element.\nIdentifying elements\nfunc accessibilityIdentifier(String) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nUses the string you specify to identify the view.\nHiding elements\nfunc accessibilityHidden(Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>\nSpecifies whether to hide this view from system accessibility features.\nSupporting types\nstruct AccessibilityTechnologies\nAccessibility technologies available to the system.\nstruct AccessibilityAttachmentModifier\nA view modifier that adds accessibility properties to the view\nSee Also\nAccessibility\nAccessible appearance\nEnhance the legibility of content in your app\u2019s interface.\nAccessible controls\nImprove access to actions that your app can undertake.\nAccessible descriptions\nDescribe interface elements to help people understand what they represent.\nAccessible navigation\nEnable users to navigate to specific user interface elements using rotors."
    },
    {
        "title": "Accessible appearance",
        "url": "https://developer.apple.com/documentation/swiftui/accessible-appearance",
        "html": "Overview\n\nMake content easier for people to see by making it larger, giving it greater contrast, or reducing the amount of distracting motion.\n\nFor design guidance, see Text display in the Accessibility section of the Human Interface Guidelines.\n\nTopics\nManaging color\nfunc accessibilityIgnoresInvertColors(Bool) -> some View\nSets whether this view should ignore the system Smart Invert setting.\nvar accessibilityInvertColors: Bool\nWhether the system preference for Invert Colors is enabled.\nvar accessibilityDifferentiateWithoutColor: Bool\nWhether the system preference for Differentiate without Color is enabled.\nEnlarging content\nfunc accessibilityShowsLargeContentViewer() -> some View\nAdds a default large content view to be shown by the large content viewer.\nfunc accessibilityShowsLargeContentViewer<V>(() -> V) -> some View\nAdds a custom large content view to be shown by the large content viewer.\nvar accessibilityLargeContentViewerEnabled: Bool\nWhether the Large Content Viewer is enabled.\nImproving legibility\nvar accessibilityShowButtonShapes: Bool\nWhether the system preference for Show Button Shapes is enabled.\nvar accessibilityReduceTransparency: Bool\nWhether the system preference for Reduce Transparency is enabled.\nvar legibilityWeight: LegibilityWeight?\nThe font weight to apply to text.\nenum LegibilityWeight\nThe Accessibility Bold Text user setting options.\nMinimizing motion\nvar accessibilityDimFlashingLights: Bool\nWhether the setting to reduce flashing or strobing lights in video content is on. This setting can also be used to determine if UI in playback controls should be shown to indicate upcoming content that includes flashing or strobing lights.\nvar accessibilityPlayAnimatedImages: Bool\nWhether the setting for playing animations in an animated image is on. When this value is false, any presented image that contains animation should not play automatically.\nvar accessibilityReduceMotion: Bool\nWhether the system preference for Reduce Motion is enabled.\nSee Also\nAccessibility\nAccessibility fundamentals\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAccessible controls\nImprove access to actions that your app can undertake.\nAccessible descriptions\nDescribe interface elements to help people understand what they represent.\nAccessible navigation\nEnable users to navigate to specific user interface elements using rotors."
    },
    {
        "title": "Clipboard",
        "url": "https://developer.apple.com/documentation/swiftui/clipboard",
        "html": "Overview\n\nWhen people issue standard Copy and Cut commands, they expect to move items to the system\u2019s Clipboard, from which they can paste the items into another place in the same app or into another app. Your app can participate in this activity if you add view modifiers that indicate how to respond to the standard commands.\n\nIn your copy and paste modifiers, provide or accept types that conform to the Transferable protocol, or that inherit from the NSItemProvider class. When possible, prefer using transferable items.\n\nTopics\nCopying transferable items\nfunc copyable<T>(() -> [T]) -> some View\nSpecifies a list of items to copy in response to the system\u2019s Copy command.\nfunc cuttable<T>(for: T.Type, action: () -> [T]) -> some View\nSpecifies an action that moves items to the Clipboard in response to the system\u2019s Cut command.\nfunc pasteDestination<T>(for: T.Type, action: ([T]) -> Void, validator: ([T]) -> [T]) -> some View\nSpecifies an action that adds validated items to a view in response to the system\u2019s Paste command.\nCopying items using item providers\nfunc onCopyCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Copy command.\nfunc onCutCommand(perform: (() -> [NSItemProvider])?) -> some View\nAdds an action to perform in response to the system\u2019s Cut command.\nfunc onPasteCommand(of: [UTType], perform: ([NSItemProvider]) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command.\nfunc onPasteCommand<Payload>(of: [UTType], validator: ([NSItemProvider]) -> Payload?, perform: (Payload) -> Void) -> some View\nAdds an action to perform in response to the system\u2019s Paste command with items that you validate.\nSee Also\nEvent handling\nGestures\nDefine interactions from taps, clicks, and swipes to fine-grained gestures.\nInput events\nRespond to input from a hardware device, like a keyboard or a Touch Bar.\nDrag and drop\nEnable people to move or duplicate items by dragging them from one location to another.\nFocus\nIdentify and control which visible object responds to user interaction.\nSystem events\nReact to system events, like opening a URL."
    },
    {
        "title": "Drag and drop",
        "url": "https://developer.apple.com/documentation/swiftui/drag-and-drop",
        "html": "Overview\n\nDrag and drop offers people a convenient way to move content from one part of your app to another, or from one app to another, using an intuitive dragging gesture. Support this feature in your app by adding view modifiers to potential source and destination views within your app\u2019s interface.\n\nIn your modifiers, provide or accept types that conform to the Transferable protocol, or that inherit from the NSItemProvider class. When possible, prefer using transferable items.\n\nFor design guidance, see Drag and drop in the Human Interface Guidelines.\n\nTopics\nMoving transferable items\nfunc draggable<T>(() -> T) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc draggable<V, T>(() -> T, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc dropDestination<T>(for: T.Type, action: ([T], CGPoint) -> Bool, isTargeted: (Bool) -> Void) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nMoving items using item providers\nfunc itemProvider(Optional<() -> NSItemProvider?>) -> some View\nProvides a closure that vends the drag representation to be used for a particular data element.\nfunc onDrag<V>(() -> NSItemProvider, preview: () -> V) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrag(() -> NSItemProvider) -> some View\nActivates this view as the source of a drag and drop operation.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider]) -> Bool) -> some View\nDefines the destination of a drag-and-drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], isTargeted: Binding<Bool>?, perform: ([NSItemProvider], CGPoint) -> Bool) -> some View\nDefines the destination of a drag and drop operation that handles the dropped content with a closure that you specify.\nfunc onDrop(of: [UTType], delegate: DropDelegate) -> some View\nDefines the destination of a drag and drop operation using behavior controlled by the delegate that you provide.\nprotocol DropDelegate\nAn interface that you implement to interact with a drop operation in a view modified to accept drops.\nstruct DropProposal\nThe behavior of a drop.\nenum DropOperation\nOperation types that determine how a drag and drop session resolves when the user drops a drag item.\nstruct DropInfo\nThe current state of a drop.\nConfiguring spring loading\nfunc springLoadingBehavior(SpringLoadingBehavior) -> some View\nSets the spring loading behavior this view.\nvar springLoadingBehavior: SpringLoadingBehavior\nThe behavior of spring loaded interactions for the views associated with this environment.\nstruct SpringLoadingBehavior\nThe options for controlling the spring loading behavior of views.\nSee Also\nEvent handling\nGestures\nDefine interactions from taps, clicks, and swipes to fine-grained gestures.\nInput events\nRespond to input from a hardware device, like a keyboard or a Touch Bar.\nClipboard\nEnable people to move or duplicate items by issuing Copy and Paste commands.\nFocus\nIdentify and control which visible object responds to user interaction.\nSystem events\nReact to system events, like opening a URL."
    },
    {
        "title": "Focus",
        "url": "https://developer.apple.com/documentation/swiftui/focus",
        "html": "Overview\n\nFocus indicates which element in the display recieves the next input. Use view modifiers to indicate which views can receive focus, to detect which view has focus, and to programmatically control focus state.\n\nFor design guidance, see Focus and selection in the Human Interface Guidelines.\n\nTopics\nEssentials\nFocus Cookbook: Supporting and enhancing focus-driven interactions in your SwiftUI app\nCreate custom focusable views with key-press handlers that accelerate keyboard input and support movement, and control focus programmatically.\nIndicating that a view can receive focus\nfunc focusable(Bool) -> some View\nSpecifies if the view is focusable.\nfunc focusable(Bool, interactions: FocusInteractions) -> some View\nSpecifies if the view is focusable, and if so, what focus-driven interactions it supports.\nstruct FocusInteractions\nValues describe different focus interactions that a view can support.\nManaging focus state\nfunc focused<Value>(FocusState<Value>.Binding, equals: Value) -> some View\nModifies this view by binding its focus state to the given state value.\nfunc focused(FocusState<Bool>.Binding) -> some View\nModifies this view by binding its focus state to the given Boolean state value.\nvar isFocused: Bool\nReturns whether the nearest focusable ancestor has focus.\nstruct FocusState\nA property wrapper type that can read and write a value that SwiftUI updates as the placement of focus within the scene changes.\nstruct FocusedValue\nA property wrapper for observing values from the focused view or one of its ancestors.\nprotocol FocusedValueKey\nA protocol for identifier types used when publishing and observing focused values.\nstruct FocusedBinding\nA convenience property wrapper for observing and automatically unwrapping state bindings from the focused view or one of its ancestors.\nExposing value types to focused views\nfunc focusedValue<T>(T?) -> some View\nSets the focused value for the given object type.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused view hierarchy.\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the focused view hierarchy.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> some View\nCreates a new view that exposes the provided value to other views whose state depends on the active scene.\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T) -> some View\nModifies this view by injecting a value that you provide for use by other views whose state depends on the focused scene.\nstruct FocusedValues\nA collection of state exported by the focused view and its ancestors.\nExposing reference types to focused views\nfunc focusedObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose state depends on the focused view hierarchy.\nfunc focusedObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the focused view hierarchy.\nfunc focusedSceneObject<T>(T?) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nfunc focusedSceneObject<T>(T) -> some View\nCreates a new view that exposes the provided object to other views whose whose state depends on the active scene.\nstruct FocusedObject\nA property wrapper type for an observable object supplied by the focused view or one of its ancestors.\nSetting focus scope\nfunc focusScope(Namespace.ID) -> some View\nCreates a focus scope that SwiftUI uses to limit default focus preferences.\nfunc focusSection() -> some View\nIndicates that the view\u2019s frame and cohort of focusable descendants should be used to guide focus movement.\nControlling default focus\nfunc prefersDefaultFocus(Bool, in: Namespace.ID) -> some View\nIndicates that the view should receive focus by default for a given namespace.\nfunc defaultFocus<V>(FocusState<V>.Binding, V, priority: DefaultFocusEvaluationPriority) -> some View\nDefines a region of the window in which default focus is evaluated by assigning a value to a given focus state binding.\nstruct DefaultFocusEvaluationPriority\nPrioritizations for default focus preferences when evaluating where to move focus in different circumstances.\nResetting focus\nvar resetFocus: ResetFocusAction\nAn action that requests the focus system to reevaluate default focus.\nstruct ResetFocusAction\nAn environment value that provides the ability to reevaluate default focus.\nConfiguring effects\nfunc focusEffectDisabled(Bool) -> some View\nAdds a condition that controls whether this view can display focus effects, such as a default focus ring or hover effect.\nvar isFocusEffectEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows focus effects to be displayed.\nSee Also\nEvent handling\nGestures\nDefine interactions from taps, clicks, and swipes to fine-grained gestures.\nInput events\nRespond to input from a hardware device, like a keyboard or a Touch Bar.\nClipboard\nEnable people to move or duplicate items by issuing Copy and Paste commands.\nDrag and drop\nEnable people to move or duplicate items by dragging them from one location to another.\nSystem events\nReact to system events, like opening a URL."
    },
    {
        "title": "Gestures",
        "url": "https://developer.apple.com/documentation/swiftui/gestures",
        "html": "Overview\n\nRespond to gestures by adding gesture modifiers to your views. You can listen for taps, drags, pinches, and other standard gestures.\n\nYou can also compose custom gestures from individual gestures using the simultaneously(with:), sequenced(before:), or exclusively(before:) modifiers, or combine gestures with keyboard modifiers using the modifiers(_:) modifier.\n\nImportant\n\nWhen you need a button, use a Button instance rather than a tap gesture. You can use any view as the button\u2019s label, and the button type automatically provides many of the standard behaviors that users expect from a button, like accessibility labels and hints.\n\nFor design guidance, see Touchscreen gestures in the Human Interface Guidelines.\n\nTopics\nEssentials\nAdding interactivity with gestures\nUse gesture modifiers to add interactivity to your app.\nRecognizing tap gestures\nfunc onTapGesture(count: Int, perform: () -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture.\nfunc onTapGesture(count: Int, coordinateSpace: some CoordinateSpaceProtocol, perform: (CGPoint) -> Void) -> some View\nAdds an action to perform when this view recognizes a tap gesture, and provides the action with the location of the interaction.\nstruct TapGesture\nA gesture that recognizes one or more taps.\nstruct SpatialTapGesture\nA gesture that recognizes one or more taps and reports their location.\nRecognizing long press gestures\nfunc onLongPressGesture(minimumDuration: Double, maximumDistance: CGFloat, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongPressGesture(minimumDuration: Double, perform: () -> Void, onPressingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a long press gesture.\nfunc onLongTouchGesture(minimumDuration: Double, perform: () -> Void, onTouchingChanged: ((Bool) -> Void)?) -> some View\nAdds an action to perform when this view recognizes a remote long touch gesture. A long touch gesture is when the finger is on the remote touch surface without actually pressing.\nstruct LongPressGesture\nA gesture that succeeds when the user performs a long press.\nRecognizing spatial events\nstruct SpatialEventGesture\nA gesture that provides information about ongoing spatial events like clicks and touches.\nBeta\nstruct SpatialEventCollection\nA collection of spatial input events that target a specific view.\nBeta\nRecognizing gestures that change over time\nfunc gesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a lower precedence than gestures defined by the view.\nstruct DragGesture\nA dragging motion that invokes an action as the drag-event sequence changes.\nstruct MagnifyGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nstruct RotateGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nstruct RotateGesture3D\nA gesture that recognizes 3D rotation motion and tracks the angle and axis of the rotation.\nBeta\nstruct GestureMask\nOptions that control how adding a gesture to a view affects other gestures recognized by the view and its subviews.\nCombining gestures\nComposing SwiftUI gestures\nCombine gestures to create complex interactions.\nfunc simultaneousGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view to process simultaneously with gestures defined by the view.\nstruct SequenceGesture\nA gesture that\u2019s a sequence of two gestures.\nstruct SimultaneousGesture\nA gesture containing two gestures that can happen at the same time with neither of them preceding the other.\nstruct ExclusiveGesture\nA gesture that consists of two gestures where only one of them can succeed.\nDefining custom gestures\nfunc highPriorityGesture<T>(T, including: GestureMask) -> some View\nAttaches a gesture to the view with a higher precedence than gestures defined by the view.\nfunc defersSystemGestures(on: Edge.Set) -> some View\nSets the screen edge from which you want your gesture to take precedence over the system gesture.\nprotocol Gesture\nAn instance that matches a sequence of events to a gesture, and returns a stream of values for each of its states.\nstruct AnyGesture\nA type-erased gesture.\nstruct HandActivationBehavior\nAn activation behavior specific to hand-driven input.\nBeta\nManaging gesture state\nstruct GestureState\nA property wrapper type that updates a property while the user performs a gesture and resets the property back to its initial state when the gesture ends.\nstruct GestureStateGesture\nA gesture that updates the state provided by a gesture\u2019s updating callback.\nDeprecated gestures\nstruct MagnificationGesture\nA gesture that recognizes a magnification motion and tracks the amount of magnification.\nDeprecated\nstruct RotationGesture\nA gesture that recognizes a rotation motion and tracks the angle of the rotation.\nDeprecated\nSee Also\nEvent handling\nInput events\nRespond to input from a hardware device, like a keyboard or a Touch Bar.\nClipboard\nEnable people to move or duplicate items by issuing Copy and Paste commands.\nDrag and drop\nEnable people to move or duplicate items by dragging them from one location to another.\nFocus\nIdentify and control which visible object responds to user interaction.\nSystem events\nReact to system events, like opening a URL."
    },
    {
        "title": "View groupings",
        "url": "https://developer.apple.com/documentation/swiftui/view-groupings",
        "html": "Overview\n\nYou can create groups of views that serve different purposes.\n\nFor example, a Group construct treats the specified views as a unit without imposing any additional layout or appearance characteristics. A Form presents a group of elements with a platform-specific appearance that\u2019s suitable for gathering input from people.\n\nFor design guidance, see Layout in the Human Interface Guidelines.\n\nTopics\nCollecting views into a unit\nstruct Group\nA type that collects multiple instances of a content type \u2014 like views, scenes, or commands \u2014 into a single unit.\nGrouping views into a box\nstruct GroupBox\nA stylized view, with an optional label, that visually collects a logical grouping of content.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nGrouping inputs\nstruct Form\nA container for grouping controls used for data entry, such as in settings or inspectors.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nstruct LabeledContent\nA container for attaching a label to a value-bearing view.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nPresenting a group of controls\nstruct ControlGroup\nA container view that displays semantically-related controls in a visually-appropriate manner for the context\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nSee Also\nView layout\nLayout fundamentals\nArrange views inside built-in layout containers like stacks and grids.\nLayout adjustments\nMake fine adjustments to alignment, spacing, padding, and other layout parameters.\nCustom layout\nPlace views in custom arrangements and create animated transitions between layout types.\nLists\nDisplay a structured, scrollable column of information.\nTables\nDisplay selectable, sortable data arranged in rows and columns.\nScroll views\nEnable people to scroll to content that doesn\u2019t fit in the current display."
    },
    {
        "title": "Tables",
        "url": "https://developer.apple.com/documentation/swiftui/tables",
        "html": "Overview\n\nUse a table to display multiple values across a collection of elements. Each element in the collection appears in a different row of the table, while each value for a given element appears in a different column. Narrow displays may adapt to show only the first column of the table.\n\nWhen you create a table, you provide a collection of elements, and then tell the table how to find the needed value for each column. In simple cases, SwiftUI infers the element for each row, but you can also specify the row elements explicitly in more complex scenarios. With a small amount of additional configuration, you can also make the items in the table selectable, and the columns sortable.\n\nLike a List, a table includes implicit vertical scrolling that you can configure using the view modifiers described in Scroll views. For design guidance, see Lists and tables in the Human Interface Guidelines.\n\nTopics\nCreating a table\nBuilding a Great Mac App with SwiftUI\nCreate engaging SwiftUI Mac apps by incorporating side bars, tables, toolbars, and several other popular user interface elements.\nstruct Table\nA container that presents rows of data arranged in one or more columns, optionally providing the ability to select one or more members.\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view.\nCreating columns\nstruct TableColumn\nA column that displays a view for each row in a table.\nprotocol TableColumnContent\nA type used to represent columns within a table.\nstruct TableColumnAlignment\nDescribes the alignment of the content of a table column.\nstruct TableColumnBuilder\nA result builder that creates table column content from closures.\nCustomizing columns\nfunc tableColumnHeaders(Visibility) -> some View\nControls the visibility of a Table\u2019s column header views.\nstruct TableColumnCustomization\nA representation of the state of the columns in a table.\nstruct TableColumnCustomizationBehavior\nA set of customization behaviors of a column that a table can offer to a user.\nCreating rows\nstruct TableRow\nA row that represents a data value in a table.\nprotocol TableRowContent\nA type used to represent table rows.\nstruct TableHeaderRowContent\nA table row that displays a single view instead of columned content.\nstruct TupleTableRowContent\nA type of table column content that creates table rows created from a Swift tuple of table rows.\nstruct TableForEachContent\nA type of table row content that creates table rows created by iterating over a collection.\nstruct EmptyTableRowContent\nA table row content that doesn\u2019t produce any rows.\nprotocol DynamicTableRowContent\nA type of table row content that generates table rows from an underlying collection of data.\nstruct TableRowBuilder\nA result builder that creates table row content from closures.\nAdding progressive disclosure\nstruct DisclosureTableRow\nA kind of table row that shows or hides additional rows based on the state of a disclosure control.\nstruct TableOutlineGroupContent\nAn opaque table row type created by a table\u2019s hierarchical initializers.\nSee Also\nView layout\nLayout fundamentals\nArrange views inside built-in layout containers like stacks and grids.\nLayout adjustments\nMake fine adjustments to alignment, spacing, padding, and other layout parameters.\nCustom layout\nPlace views in custom arrangements and create animated transitions between layout types.\nLists\nDisplay a structured, scrollable column of information.\nView groupings\nPresent views in different kinds of purpose-driven containers, like forms or control groups.\nScroll views\nEnable people to scroll to content that doesn\u2019t fit in the current display."
    },
    {
        "title": "Layout adjustments",
        "url": "https://developer.apple.com/documentation/swiftui/layout-adjustments",
        "html": "Overview\n\nLayout containers like stacks and grids provide a great starting point for arranging views in your app\u2019s user interface. When you need to make fine adjustments, use layout view modifiers. You can adjust or constrain the size, position, and alignment of a view. You can also add padding around a view, and indicate how the view interacts with system-defined safe areas.\n\nTo get started with a basic layout, see Layout fundamentals. For design guidance, see Layout in the Human Interface Guidelines.\n\nTopics\nFinetuning a layout\nLaying out a simple view\nCreate a view layout by adjusting the size of views.\nInspecting view layout\nDetermine the position and extent of a view using Xcode previews or by adding temporary borders.\nAdding padding around a view\nfunc padding(CGFloat) -> some View\nAdds a specific padding amount to each edge of this view.\nfunc padding(Edge.Set, CGFloat?) -> some View\nAdds an equal padding amount to specific edges of this view.\nfunc padding(EdgeInsets) -> some View\nAdds a different padding amount to each edge of this view.\nfunc padding3D(CGFloat) -> some View\nPads this view along all edge insets by the amount you specify.\nBeta\nfunc padding3D(EdgeInsets3D) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc padding3D(Edge3D.Set, CGFloat?) -> some View\nPads this view using the edge insets you specify.\nBeta\nfunc scenePadding(Edge.Set) -> some View\nAdds padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nfunc scenePadding(ScenePadding, edges: Edge.Set) -> some View\nAdds a specified kind of padding to the specified edges of this view using an amount that\u2019s appropriate for the current scene.\nstruct ScenePadding\nThe padding used to space a view from its containing scene.\nInfluencing a view\u2019s size\nfunc frame(width: CGFloat?, height: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame with the specified size.\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame with the specified depth.\nBeta\nfunc frame(minWidth: CGFloat?, idealWidth: CGFloat?, maxWidth: CGFloat?, minHeight: CGFloat?, idealHeight: CGFloat?, maxHeight: CGFloat?, alignment: Alignment) -> some View\nPositions this view within an invisible frame having the specified size constraints.\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> some View\nPositions this view within an invisible frame having the specified depth constraints.\nBeta\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> some View\nPositions this view within an invisible frame with a size relative to the nearest container.\nfunc fixedSize() -> some View\nFixes this view at its ideal size.\nfunc fixedSize(horizontal: Bool, vertical: Bool) -> some View\nFixes this view at its ideal size in the specified dimensions.\nfunc layoutPriority(Double) -> some View\nSets the priority by which a parent layout should apportion space to this child.\nAdjusting a view\u2019s position\nMaking fine adjustments to a view\u2019s position\nShift the position of a view by applying the offset or position modifier.\nfunc position(CGPoint) -> some View\nPositions the center of this view at the specified point in its parent\u2019s coordinate space.\nfunc position(x: CGFloat, y: CGFloat) -> some View\nPositions the center of this view at the specified coordinates in its parent\u2019s coordinate space.\nfunc offset(CGSize) -> some View\nOffset this view by the horizontal and vertical amount specified in the offset parameter.\nfunc offset(x: CGFloat, y: CGFloat) -> some View\nOffset this view by the specified horizontal and vertical distances.\nfunc offset(z: CGFloat) -> some View\nBrings a view forward in Z by the provided distance in points.\nBeta\nAligning views\nAligning views within a stack\nPosition views inside a stack using alignment guides.\nAligning views across stacks\nCreate a custom alignment and use it to align views across multiple stacks.\nfunc alignmentGuide(HorizontalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s horizontal alignment.\nfunc alignmentGuide(VerticalAlignment, computeValue: (ViewDimensions) -> CGFloat) -> some View\nSets the view\u2019s vertical alignment.\nstruct Alignment\nAn alignment in both axes.\nstruct HorizontalAlignment\nAn alignment position along the horizontal axis.\nstruct VerticalAlignment\nAn alignment position along the vertical axis.\nstruct DepthAlignment\nAn alignment position along the depth axis.\nBeta\nprotocol AlignmentID\nA type that you use to create custom alignment guides.\nstruct ViewDimensions\nA view\u2019s size and alignment guides in its own coordinate space.\nSetting margins\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> some View\nConfigures the content margin for a provided placement.\nstruct ContentMarginPlacement\nThe placement of margins.\nStaying in the safe areas\nfunc ignoresSafeArea(SafeAreaRegions, edges: Edge.Set) -> some View\nExpands the view out of its safe area.\nfunc safeAreaInset<V>(edge: HorizontalEdge, alignment: VerticalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content beside the modified view.\nfunc safeAreaInset<V>(edge: VerticalEdge, alignment: HorizontalAlignment, spacing: CGFloat?, content: () -> V) -> some View\nShows the specified content above or below the modified view.\nfunc safeAreaPadding(EdgeInsets) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(CGFloat) -> some View\nAdds the provided insets into the safe area of this view.\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> some View\nAdds the provided insets into the safe area of this view.\nstruct SafeAreaRegions\nA set of symbolic safe area regions.\nSetting a layout direction\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> some View\nSets the behavior of this view for different layout directions.\nenum LayoutDirectionBehavior\nA description of what should happen when the layout direction changes.\nvar layoutDirection: LayoutDirection\nThe layout direction associated with the current environment.\nenum LayoutDirection\nA direction in which SwiftUI can lay out content.\nReacting to interface characteristics\nvar isLuminanceReduced: Bool\nA Boolean value that indicates whether the display or environment currently requires reduced luminance.\nvar displayScale: CGFloat\nThe display scale of this environment.\nvar pixelLength: CGFloat\nThe size of a pixel on the screen.\nvar horizontalSizeClass: UserInterfaceSizeClass?\nThe horizontal size class of this environment.\nvar verticalSizeClass: UserInterfaceSizeClass?\nThe vertical size class of this environment.\nenum UserInterfaceSizeClass\nA set of values that indicate the visual size available to the view.\nAccessing edges and regions\nenum Edge\nAn enumeration to indicate one edge of a rectangle.\nenum Edge3D\nAn edge or face of a 3D volume.\nBeta\nenum HorizontalEdge\nAn edge on the horizontal axis.\nenum VerticalEdge\nAn edge on the vertical axis.\nstruct EdgeInsets\nThe inset distances for the sides of a rectangle.\nstruct EdgeInsets3D\nThe inset distances for the faces of a 3D volume.\nBeta\nSee Also\nView layout\nLayout fundamentals\nArrange views inside built-in layout containers like stacks and grids.\nCustom layout\nPlace views in custom arrangements and create animated transitions between layout types.\nLists\nDisplay a structured, scrollable column of information.\nTables\nDisplay selectable, sortable data arranged in rows and columns.\nView groupings\nPresent views in different kinds of purpose-driven containers, like forms or control groups.\nScroll views\nEnable people to scroll to content that doesn\u2019t fit in the current display."
    },
    {
        "title": "Custom layout",
        "url": "https://developer.apple.com/documentation/swiftui/custom-layout",
        "html": "Overview\n\nYou can create complex view layouts using the built-in layout containers and layout view modifiers that SwiftUI provides. However, if you need behavior that you can\u2019t achieve with the built-in layout tools, create a custom layout container type using the Layout protocol. A container that you define asks for the sizes of all its subviews, and then indicates where to place the subviews within its own bounds.\n\nYou can also create animated transitions among layout types that conform to the Layout procotol, including both built-in and custom layouts.\n\nFor design guidance, see Layout in the Human Interface Guidelines.\n\nTopics\nCreating a custom layout container\nComposing custom layouts with SwiftUI\nArrange views in your app\u2019s interface using layout tools that SwiftUI provides.\nprotocol Layout\nA type that defines the geometry of a collection of views.\nstruct LayoutSubview\nA proxy that represents one subview of a layout.\nstruct LayoutSubviews\nA collection of proxy values that represent the subviews of a layout view.\nConfiguring a custom layout\nstruct LayoutProperties\nLayout-specific properties of a layout container.\nstruct ProposedViewSize\nA proposal for the size of a view.\nstruct ViewSpacing\nA collection of the geometric spacing preferences of a view.\nAssociating values with views in a custom layout\nfunc layoutValue<K>(key: K.Type, value: K.Value) -> some View\nAssociates a value with a custom layout property.\nprotocol LayoutValueKey\nA key for accessing a layout value of a layout container\u2019s subviews.\nTransitioning between layout types\nstruct AnyLayout\nA type-erased instance of the layout protocol.\nstruct HStackLayout\nA horizontal container that you can use in conditional layouts.\nstruct VStackLayout\nA vertical container that you can use in conditional layouts.\nstruct ZStackLayout\nAn overlaying container that you can use in conditional layouts.\nstruct GridLayout\nA grid that you can use in conditional layouts.\nSee Also\nView layout\nLayout fundamentals\nArrange views inside built-in layout containers like stacks and grids.\nLayout adjustments\nMake fine adjustments to alignment, spacing, padding, and other layout parameters.\nLists\nDisplay a structured, scrollable column of information.\nTables\nDisplay selectable, sortable data arranged in rows and columns.\nView groupings\nPresent views in different kinds of purpose-driven containers, like forms or control groups.\nScroll views\nEnable people to scroll to content that doesn\u2019t fit in the current display."
    },
    {
        "title": "Drawing and graphics",
        "url": "https://developer.apple.com/documentation/swiftui/drawing-and-graphics",
        "html": "Overview\n\nYou create rich, dynamic user interfaces with the built-in views and Shapes that SwiftUI provides. To enhance any view, you can apply many of the graphical effects typically associated with a graphics context, like setting colors, adding masks, and creating composites.\n\nWhen you need the flexibility of immediate mode drawing in a graphics context, use a Canvas view. This can be particularly helpful when you want to draw an extremely large number of dynamic shapes \u2014 for example, to create particle effects.\n\nFor design guidance, see Materials and Color in the Human Interface Guidelines.\n\nTopics\nImmediate mode drawing\nAdd Rich Graphics to Your SwiftUI App\nMake your apps stand out by adding background materials, vibrancy, custom graphics, and animations.\nstruct Canvas\nA view type that supports immediate mode drawing.\nstruct GraphicsContext\nAn immediate mode drawing destination, and its current state.\nSetting a color\nfunc tint<S>(S?) -> some View\nSets the tint within this view.\nfunc tint(Color?) -> some View\nSets the tint color within this view.\nstruct Color\nA representation of a color that adapts to a given context.\nStyling content\nfunc border<S>(S, width: CGFloat) -> some View\nAdds a border to this view with the specified style and width.\nfunc foregroundStyle<S>(S) -> some View\nSets a view\u2019s foreground elements to use a given style.\nfunc foregroundStyle<S1, S2>(S1, S2) -> some View\nSets the primary and secondary levels of the foreground style in the child view.\nfunc foregroundStyle<S1, S2, S3>(S1, S2, S3) -> some View\nSets the primary, secondary, and tertiary levels of the foreground style.\nfunc backgroundStyle<S>(S) -> some View\nSets the specified style to render backgrounds within the view.\nvar backgroundStyle: AnyShapeStyle?\nAn optional style that overrides the default system background style when set.\nprotocol ShapeStyle\nA color or pattern to use when rendering a shape.\nstruct AnyShapeStyle\nA type-erased ShapeStyle value.\nstruct Gradient\nA color gradient represented as an array of color stops, each having a parametric location value.\nstruct AnyGradient\nA color gradient.\nstruct ShadowStyle\nA style to use when rendering shadows.\nTransforming colors\nfunc brightness(Double) -> some View\nBrightens this view by the specified amount.\nfunc contrast(Double) -> some View\nSets the contrast and separation between similar colors in this view.\nfunc colorInvert() -> some View\nInverts the colors in this view.\nfunc colorMultiply(Color) -> some View\nAdds a color multiplication effect to this view.\nfunc saturation(Double) -> some View\nAdjusts the color saturation of this view.\nfunc grayscale(Double) -> some View\nAdds a grayscale effect to this view.\nfunc hueRotation(Angle) -> some View\nApplies a hue rotation effect to this view.\nfunc luminanceToAlpha() -> some View\nAdds a luminance to alpha effect to this view.\nScaling, rotating, or transforming a view\nfunc scaledToFill() -> some View\nScales this view to fill its parent.\nfunc scaledToFit() -> some View\nScales this view to fit its parent.\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(CGSize, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point.\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified factor.\nBeta\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> some View\nScales this view uniformly by the specified size in each dimension.\nBeta\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<Self, _UniformScaleEffect>\nScales this view\u2019s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, anchor: UnitPoint) -> some View\nScales this view\u2019s rendered output by the given horizontal and vertical amounts, relative to an anchor point.\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> some View\nScales this view by the specified horizontal, vertical, and depth factors.\nBeta\nfunc aspectRatio(CGFloat?, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the specified aspect ratio.\nfunc aspectRatio(CGSize, contentMode: ContentMode) -> some View\nConstrains this view\u2019s dimensions to the aspect ratio of the given size.\nfunc rotationEffect(Angle, anchor: UnitPoint) -> some View\nRotates a view\u2019s rendered output in two dimensions around the specified point.\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> some View\nRenders a view\u2019s content as if it\u2019s rotated in three dimensions around the specified axis.\nBeta\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by the specified 3D rotation value.\nBeta\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a rotation axis value.\nBeta\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> some View\nRotates the view\u2019s content by an angle about an axis that you specify as a tuple of elements.\nBeta\nfunc transformEffect(CGAffineTransform) -> some View\nApplies an affine transformation to this view\u2019s rendered output.\nfunc transform3DEffect(AffineTransform3D) -> some View\nApplies a 3D transformation to the receiver.\nBeta\nfunc projectionEffect(ProjectionTransform) -> some View\nApplies a projection transformation to this view\u2019s rendered output.\nstruct ProjectionTransform\nenum ContentMode\nConstants that define how a view\u2019s content fills the available space.\nMasking and clipping\nfunc mask<Mask>(alignment: Alignment, () -> Mask) -> some View\nMasks this view using the alpha channel of the given view.\nfunc clipped(antialiased: Bool) -> some View\nClips this view to its bounding rectangular frame.\nfunc clipShape<S>(S, style: FillStyle) -> some View\nSets a clipping shape for this view.\nApplying blur and shadows\nfunc blur(radius: CGFloat, opaque: Bool) -> some View\nApplies a Gaussian blur to this view.\nfunc shadow(color: Color, radius: CGFloat, x: CGFloat, y: CGFloat) -> some View\nAdds a shadow to this view.\nstruct ColorMatrix\nA matrix to use in an RGBA color transformation.\nApplying effects based on geometry\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a geometry proxy.\nfunc visualEffect3D((EmptyVisualEffect, GeometryProxy3D) -> some VisualEffect) -> some View\nApplies effects to this view, while providing access to layout information through a 3D geometry proxy.\nBeta\nprotocol VisualEffect\nVisual Effects change the visual appearance of a view without changing its ancestors or descendents.\nstruct EmptyVisualEffect\nThe base visual effect that you apply additional effect to.\nCompositing views\nfunc blendMode(BlendMode) -> some View\nSets the blend mode for compositing this view with overlapping views.\nfunc compositingGroup() -> some View\nWraps this view in a compositing group.\nfunc drawingGroup(opaque: Bool, colorMode: ColorRenderingMode) -> some View\nComposites this view\u2019s contents into an offscreen image before final display.\nenum BlendMode\nModes for compositing a view with overlapping content.\nenum ColorRenderingMode\nThe set of possible working color spaces for color-compositing operations.\nMeasuring a view\nstruct GeometryReader\nA container view that defines its content as a function of its own size and coordinate space.\nstruct GeometryReader3D\nA container view that defines its content as a function of its own size and coordinate space.\nBeta\nstruct GeometryProxy\nA proxy for access to the size and coordinate space (for anchor resolution) of the container view.\nstruct GeometryProxy3D\nA proxy for access to the size and coordinate space of the container view.\nBeta\nfunc coordinateSpace(NamedCoordinateSpace) -> some View\nAssigns a name to the view\u2019s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.\nenum CoordinateSpace\nA resolved coordinate space created by the coordinate space protocol.\nprotocol CoordinateSpaceProtocol\nA frame of reference within the layout system.\nstruct PhysicalMetric\nProvides access to a value in points that corresponds to the specified physical measurement.\nBeta\nstruct PhysicalMetricsConverter\nA physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.\nBeta\nAccessing Metal shaders\nfunc colorEffect(Shader, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter effect on the color of each pixel.\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a geometric distortion effect on the location of each pixel.\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> some View\nReturns a new view that applies shader to self as a filter on the raster layer created from self.\nstruct Shader\nA reference to a function in a Metal shader library, along with its bound uniform argument values.\nstruct ShaderFunction\nA reference to a function in a Metal shader library.\nstruct ShaderLibrary\nA Metal shader library.\nAccessing geometric constructs\nenum Axis\nThe horizontal or vertical dimension in a 2D coordinate system.\nstruct Angle\nA geometric angle whose value you access in either radians or degrees.\nstruct UnitPoint\nA normalized 2D point in a view\u2019s coordinate space.\nstruct UnitPoint3D\nA normalized 3D point in a view\u2019s coordinate space.\nBeta\nstruct Anchor\nAn opaque value derived from an anchor source and a particular view.\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern."
    },
    {
        "title": "Layout fundamentals",
        "url": "https://developer.apple.com/documentation/swiftui/layout-fundamentals",
        "html": "Overview\n\nUse layout containers to arrange the elements of your user interface. Stacks and grids update and adjust the positions of the subviews they contain in response to changes in content or interface dimensions. You can nest layout containers inside other layout containers to any depth to achieve complex layout effects.\n\nTo finetune the position, alignment, and other elements of a layout that you build with layout container views, see Layout adjustments. To define custom layout containers, see Custom layout. For design guidance, see Layout in the Human Interface Guidelines.\n\nTopics\nChoosing a layout\nPicking container views for your content\nBuild flexible user interfaces by using stacks, grids, lists, and forms.\nStatically arranging views in one dimension\nBuilding layouts with stack views\nCompose complex layouts from primitive container views.\nstruct HStack\nA view that arranges its subviews in a horizontal line.\nstruct VStack\nA view that arranges its subviews in a vertical line.\nDynamically arranging views in one dimension\nGrouping data with lazy stack views\nSplit content into logical sections inside lazy stack views.\nCreating performant scrollable stacks\nDisplay large numbers of repeated views efficiently with scroll views, stack views, and lazy stacks.\nstruct LazyHStack\nA view that arranges its children in a line that grows horizontally, creating items only as needed.\nstruct LazyVStack\nA view that arranges its children in a line that grows vertically, creating items only as needed.\nstruct PinnedScrollableViews\nA set of view types that may be pinned to the bounds of a scroll view.\nStatically arranging views in two dimensions\nstruct Grid\nA container view that arranges other views in a two dimensional layout.\nstruct GridRow\nA horizontal row in a two dimensional grid container.\nfunc gridCellColumns(Int) -> some View\nTells a view that acts as a cell in a grid to span the specified number of columns.\nfunc gridCellAnchor(UnitPoint) -> some View\nSpecifies a custom alignment anchor for a view that acts as a grid cell.\nfunc gridCellUnsizedAxes(Axis.Set) -> some View\nAsks grid layouts not to offer the view extra size in the specified axes.\nfunc gridColumnAlignment(HorizontalAlignment) -> some View\nOverrides the default horizontal alignment of the grid column that the view appears in.\nDynamically arranging views in two dimensions\nstruct LazyHGrid\nA container view that arranges its child views in a grid that grows horizontally, creating items only as needed.\nstruct LazyVGrid\nA container view that arranges its child views in a grid that grows vertically, creating items only as needed.\nstruct GridItem\nA description of a row or a column in a lazy grid.\nLayering views\nAdding a background to your view\nCompose a background behind your view and extend it beyond the safe area insets.\nstruct ZStack\nA view that overlays its subviews, aligning them in both axes.\nfunc zIndex(Double) -> some View\nControls the display order of overlapping views.\nfunc background<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify behind this view.\nfunc background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to a style.\nfunc background(ignoresSafeAreaEdges: Edge.Set) -> some View\nSets the view\u2019s background to the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to an insettable shape filled with the default background style.\nfunc background<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with a style.\nfunc background<S>(in: S, fillStyle: FillStyle) -> some View\nSets the view\u2019s background to a shape filled with the default background style.\nfunc overlay<V>(alignment: Alignment, content: () -> V) -> some View\nLayers the views that you specify in front of this view.\nfunc overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View\nLayers the specified style in front of this view.\nfunc overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View\nLayers a shape that you specify in front of this view.\nvar backgroundMaterial: Material?\nThe material underneath the current view.\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some View\nSets the container background of the enclosing container using a view.\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> some View\nSets the container background of the enclosing container using a view.\nstruct ContainerBackgroundPlacement\nThe placement of a container background.\nAutomatically choosing the layout that fits\nstruct ViewThatFits\nA view that adapts to the available space by providing the first child view that fits.\nSeparators\nstruct Spacer\nA flexible space that expands along the major axis of its containing stack layout, or on both axes if not contained in a stack.\nstruct Divider\nA visual element that can be used to separate other content.\nSee Also\nView layout\nLayout adjustments\nMake fine adjustments to alignment, spacing, padding, and other layout parameters.\nCustom layout\nPlace views in custom arrangements and create animated transitions between layout types.\nLists\nDisplay a structured, scrollable column of information.\nTables\nDisplay selectable, sortable data arranged in rows and columns.\nView groupings\nPresent views in different kinds of purpose-driven containers, like forms or control groups.\nScroll views\nEnable people to scroll to content that doesn\u2019t fit in the current display."
    },
    {
        "title": "Menus and commands",
        "url": "https://developer.apple.com/documentation/swiftui/menus-and-commands",
        "html": "Overview\n\nUse a menu to provide people with easy access to common commands. You can add items to a macOS app\u2019s menu bar using the commands(content:) scene modifier, or create context menus that people reveal near their current task using the contextMenu(menuItems:) view modifier.\n\nCreate submenus by nesting Menu instances inside others. Use a Divider view to create a separator between menu elements.\n\nFor design guidance, see Menus in the Human Interface Guidelines.\n\nTopics\nCreating a menu\nstruct Menu\nA control for presenting a menu of actions.\nfunc menuStyle<S>(S) -> some View\nSets the style for menus within this view.\nCreating context menus\nfunc contextMenu<MenuItems>(menuItems: () -> MenuItems) -> some View\nAdds a context menu to a view.\nfunc contextMenu<M, P>(menuItems: () -> M, preview: () -> P) -> some View\nAdds a context menu with a preview to a view.\nfunc contextMenu<I, M>(forSelectionType: I.Type, menu: (Set<I>) -> M, primaryAction: ((Set<I>) -> Void)?) -> some View\nAdds an item-based context menu to a view.\nDefining commands\nfunc commands<Content>(content: () -> Content) -> some Scene\nAdds commands to the scene.\nfunc commandsRemoved() -> some Scene\nRemoves all commands defined by the modified scene.\nfunc commandsReplaced<Content>(content: () -> Content) -> some Scene\nReplaces all commands defined by the modified scene with the commands from the builder.\nprotocol Commands\nConforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.\nstruct CommandMenu\nCommand menus are stand-alone, top-level containers for controls that perform related, app-specific commands.\nstruct CommandGroup\nGroups of controls that you can add to existing command menus.\nstruct CommandsBuilder\nConstructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.\nstruct CommandGroupPlacement\nThe standard locations that you can place new command groups relative to.\nGetting built-in command groups\nstruct SidebarCommands\nA built-in set of commands for manipulating window sidebars.\nstruct TextEditingCommands\nA built-in group of commands for searching, editing, and transforming selections of text.\nstruct TextFormattingCommands\nA built-in set of commands for transforming the styles applied to selections of text.\nstruct ToolbarCommands\nA built-in set of commands for manipulating window toolbars.\nstruct ImportFromDevicesCommands\nA built-in set of commands that enables importing content from nearby devices.\nstruct InspectorCommands\nA built-in set of commands for manipulating inspectors.\nstruct EmptyCommands\nAn empty group of commands.\nShowing a menu indicator\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view.\nvar menuIndicatorVisibility: Visibility\nThe menu indicator visibility to apply to controls within a view.\nConfiguring menu dismissal\nfunc menuActionDismissBehavior(MenuActionDismissBehavior) -> some View\nTells a menu whether to dismiss after performing an action.\nstruct MenuActionDismissBehavior\nThe set of menu dismissal behavior options.\nSetting a preferred order\nfunc menuOrder(MenuOrder) -> some View\nSets the preferred order of items for menus presented from this view.\nvar menuOrder: MenuOrder\nThe preferred order of items for menus presented from this view.\nstruct MenuOrder\nThe order in which a menu presents its content.\nDeprecated types\nstruct MenuButton\nA button that displays a menu containing a list of choices when pressed.\nDeprecated\ntypealias PullDownButton\nDeprecated\nstruct ContextMenu\nA container for views that you present as menu items in a context menu.\nDeprecated\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "App",
        "url": "https://developer.apple.com/documentation/swiftui/app",
        "html": "Overview\n\nCreate an app by declaring a structure that conforms to the App protocol. Implement the required body computed property to define the app\u2019s content:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            Text(\"Hello, world!\")\n        }\n    }\n}\n\n\nPrecede the structure\u2019s declaration with the @main attribute to indicate that your custom App protocol conformer provides the entry point into your app. The protocol provides a default implementation of the main() method that the system calls to launch your app. You can have exactly one entry point among all of your app\u2019s files.\n\nCompose the app\u2019s body from instances that conform to the Scene protocol. Each scene contains the root view of a view hierarchy and has a life cycle managed by the system. SwiftUI provides some concrete scene types to handle common scenarios, like for displaying documents or settings. You can also create custom scenes.\n\n@main\nstruct Mail: App {\n    var body: some Scene {\n        WindowGroup {\n            MailViewer()\n        }\n        Settings {\n            SettingsView()\n        }\n    }\n}\n\n\nYou can declare state in your app to share across all of its scenes. For example, you can use the StateObject attribute to initialize a data model, and then provide that model on a view input as an ObservedObject or through the environment as an EnvironmentObject to scenes in the app:\n\n@main\nstruct Mail: App {\n    @StateObject private var model = MailModel()\n\n\n    var body: some Scene {\n        WindowGroup {\n            MailViewer()\n                .environmentObject(model) // Passed through the environment.\n        }\n        Settings {\n            SettingsView(model: model) // Passed as an observed object.\n        }\n    }\n}\n\nTopics\nImplementing an app\nvar body: Self.Body\nThe content and behavior of the app.\n\nRequired\n\nassociatedtype Body : Scene\nThe type of scene representing the content of the app.\n\nRequired\n\nRunning an app\ninit()\nCreates an instance of the app using the body that you define for its content.\n\nRequired\n\nstatic func main()\nInitializes and runs the app.\nSee Also\nCreating an app\nBackyard Birds: Building an app with SwiftData and widgets\nCreate an app with persistent data, interactive widgets, and an all new in-app purchase experience."
    },
    {
        "title": "ShapeRole",
        "url": "https://developer.apple.com/documentation/swiftui/shaperole",
        "html": "Topics\nGetting shape roles\ncase fill\nIndicates to the shape\u2019s style that SwiftUI fills the shape.\ncase stroke\nIndicates to the shape\u2019s style that SwiftUI applies a stroke to the shape\u2019s path.\ncase separator\nIndicates to the shape\u2019s style that SwiftUI uses the shape as a separator.\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "ShapeView",
        "url": "https://developer.apple.com/documentation/swiftui/shapeview",
        "html": "Overview\n\nUse this type with the drawing methods on Shape to apply multiple fills and/or strokes to a shape. For example, the following code applies a fill and stroke to a capsule shape:\n\nCapsule()\n    .fill(.yellow)\n    .stroke(.blue, lineWidth: 8)\n\nTopics\nGetting the shape\nvar shape: Self.Content\nThe shape that this type draws and provides for other drawing operations.\n\nRequired\n\nassociatedtype Content : Shape\nThe type of shape this can provide.\n\nRequired\n\nModify the shape\nfunc fill<S>(S, style: FillStyle) -> FillShapeView<Self.Content, S, Self>\nFills this shape with a color or gradient.\nfunc stroke<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc stroke<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeShapeView<Self.Content, S, Self>\nTraces the outline of this shape with a color or gradient.\nfunc strokeBorder<S>(S, style: StrokeStyle, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of insetting this view by half of its style\u2019s line width.\nAvailable when Content conforms to InsettableShape.\nfunc strokeBorder<S>(S, lineWidth: CGFloat, antialiased: Bool) -> StrokeBorderShapeView<Self.Content, S, Self>\nReturns a view that\u2019s the result of filling an inner stroke of this view with the content you supply.\nAvailable when Content conforms to InsettableShape.\nRelationships\nInherits From\nView\nConforming Types\nFillShapeView\nStrokeBorderShapeView\nStrokeShapeView\nSee Also\nDefining shape behavior\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape."
    },
    {
        "title": "Text input and output",
        "url": "https://developer.apple.com/documentation/swiftui/text-input-and-output",
        "html": "Overview\n\nTo display read-only text, or read-only text paired with an image, use the built-in Text or Label views, respectively. When you need to collect text input from the user, use an appropriate text input view, like TextField or TextEditor.\n\nYou add view modifiers to control the text\u2019s font, selectability, alignment, layout direction, and so on. These modifiers also affect other views that display text, like the labels on controls, even if you don\u2019t define an explicit Text view.\n\nFor design guidance, see Typography in the Human Interface Guidelines.\n\nTopics\nDisplaying text\nstruct Text\nA view that displays one or more lines of read-only text.\nstruct Label\nA standard label for user interface items, consisting of an icon with a title.\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nGetting text input\nstruct TextField\nA control that displays an editable text interface.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nstruct SecureField\nA control into which the user securely enters private text.\nstruct TextEditor\nA view that can display and edit long-form text.\nSelecting text\nfunc textSelection<S>(S) -> some View\nControls whether people can select text within this view.\nprotocol TextSelectability\nA type that describes the ability to select text.\nSetting a font\nApplying custom fonts to text\nAdd and use a font in your app that scales with Dynamic Type.\nfunc font(Font?) -> some View\nSets the default font for text in this view.\nfunc fontDesign(Font.Design?) -> some View\nSets the font design of the text in this view.\nfunc fontWeight(Font.Weight?) -> some View\nSets the font weight of the text in this view.\nfunc fontWidth(Font.Width?) -> some View\nSets the font width of the text in this view.\nvar font: Font?\nThe default font of this environment.\nstruct Font\nAn environment-dependent font.\nAdjusting text size\nfunc textScale(Text.Scale, isEnabled: Bool) -> some View\nApplies a text scale to text in the view.\nfunc dynamicTypeSize<T>(T) -> some View\nLimits the Dynamic Type size within the view to the given range.\nfunc dynamicTypeSize(DynamicTypeSize) -> some View\nSets the Dynamic Type size within the view to the given value.\nvar dynamicTypeSize: DynamicTypeSize\nThe current Dynamic Type size.\nenum DynamicTypeSize\nA Dynamic Type size, which specifies how large scalable content should be.\nstruct ScaledMetric\nA dynamic property that scales a numeric value.\nControlling text style\nfunc bold(Bool) -> some View\nApplies a bold font weight to the text in this view.\nfunc italic(Bool) -> some View\nApplies italics to the text in this view.\nfunc underline(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies an underline to the text in this view.\nfunc strikethrough(Bool, pattern: Text.LineStyle.Pattern, color: Color?) -> some View\nApplies a strikethrough to the text in this view.\nfunc textCase(Text.Case?) -> some View\nSets a transform for the case of the text contained in this view when displayed.\nvar textCase: Text.Case?\nA stylistic override to transform the case of Text when displayed, using the environment\u2019s locale.\nfunc monospaced(Bool) -> some View\nModifies the fonts of all child views to use the fixed-width variant of the current font, if possible.\nfunc monospacedDigit() -> some View\nModifies the fonts of all child views to use fixed-width digits, if possible, while leaving other characters proportionally spaced.\nManaging text layout\nfunc truncationMode(Text.TruncationMode) -> some View\nSets the truncation mode for lines of text that are too long to fit in the available space.\nvar truncationMode: Text.TruncationMode\nA value that indicates how the layout truncates the last line of text to fit into the available space.\nfunc allowsTightening(Bool) -> some View\nSets whether text in this view can compress the space between characters when necessary to fit text in a line.\nvar allowsTightening: Bool\nA Boolean value that indicates whether inter-character spacing should tighten to fit the text into the available space.\nfunc minimumScaleFactor(CGFloat) -> some View\nSets the minimum amount that text in this view scales down to fit in the available space.\nvar minimumScaleFactor: CGFloat\nThe minimum permissible proportion to shrink the font size to fit the text into the available space.\nfunc baselineOffset(CGFloat) -> some View\nSets the vertical offset for the text relative to its baseline in this view.\nfunc kerning(CGFloat) -> some View\nSets the spacing, or kerning, between characters for the text in this view.\nfunc tracking(CGFloat) -> some View\nSets the tracking for the text in this view.\nfunc flipsForRightToLeftLayoutDirection(Bool) -> some View\nSets whether this view mirrors its contents horizontally when the layout direction is right-to-left.\nenum TextAlignment\nAn alignment position for text along the horizontal axis.\nLimiting line count for multiline text\nfunc lineLimit(Int?) -> some View\nSets the maximum number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeFrom<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(PartialRangeThrough<Int>) -> some View\nSets to a partial range the number of lines that text can occupy in this view.\nfunc lineLimit(ClosedRange<Int>) -> some View\nSets to a closed range the number of lines that text can occupy in this view.\nfunc lineLimit(Int, reservesSpace: Bool) -> some View\nSets a limit for the number of lines text can occupy in this view.\nvar lineLimit: Int?\nThe maximum number of lines that text can occupy in a view.\nFormatting multiline text\nfunc lineSpacing(CGFloat) -> some View\nSets the amount of space between lines of text in this view.\nvar lineSpacing: CGFloat\nThe distance in points between the bottom of one line fragment and the top of the next.\nfunc multilineTextAlignment(TextAlignment) -> some View\nSets the alignment of a text view that contains multiple lines of text.\nvar multilineTextAlignment: TextAlignment\nAn environment value that indicates how a text view aligns its lines when the content wraps or contains newlines.\nManaging text entry\nfunc autocorrectionDisabled(Bool) -> some View\nSets whether to disable autocorrection for this view.\nvar autocorrectionDisabled: Bool\nA Boolean value that determines whether the view hierarchy has auto-correction enabled.\nfunc keyboardType(UIKeyboardType) -> some View\nSets the keyboard type for this view.\nfunc scrollDismissesKeyboard(ScrollDismissesKeyboardMode) -> some View\nConfigures the behavior in which scrollable content interacts with the software keyboard.\nfunc textContentType(UITextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on an iOS or tvOS device.\nfunc textContentType(NSTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.\nfunc textContentType(WKTextContentType?) -> some View\nSets the text content type for this view, which the system uses to offer suggestions while the user enters text on a watchOS device.\nfunc textInputAutocapitalization(TextInputAutocapitalization?) -> some View\nSets how often the shift key in the keyboard is automatically enabled.\nstruct TextInputAutocapitalization\nThe kind of autocapitalization behavior applied during text input.\nDictating text\nfunc searchDictationBehavior(TextInputDictationBehavior) -> some View\nstruct TextInputDictationActivation\nstruct TextInputDictationBehavior\nSpecifying text equivalents\nfunc typeSelectEquivalent(Text?) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nfunc typeSelectEquivalent(LocalizedStringKey) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nfunc typeSelectEquivalent<S>(S) -> some View\nSets an explicit type select equivalent text in a collection, such as a list or table.\nLocalizing text\nPreparing views for localization\nSpecify hints and add strings to localize your SwiftUI views.\nstruct LocalizedStringKey\nThe key used to look up an entry in a strings file or strings dictionary file.\nvar locale: Locale\nThe current locale that views should use.\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> some View\nSpecifies the language for typesetting.\nstruct TypesettingLanguage\nDefines how typesetting language is determined for text.\nDeprecated types\nenum ContentSizeCategory\nThe sizes that you can specify for content.\nDeprecated\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "Animations",
        "url": "https://developer.apple.com/documentation/swiftui/animations",
        "html": "Overview\n\nYou tell SwiftUI how to draw your app\u2019s user interface for different states, and then rely on SwiftUI to make interface updates when the state changes.\n\nTo avoid abrupt visual transitions when the state changes, add animation in one of the following ways:\n\nAnimate all of the visual changes for a state change by changing the state inside a call to the withAnimation(_:_:) global function.\n\nAdd animation to a particular view when a specific value changes by applying the animation(_:value:) view modifier to the view.\n\nAnimate changes to a Binding by using the binding\u2019s animation(_:) method.\n\nSwiftUI animates the effects that many built-in view modifiers produce, like those that set a scale or opacity value. You can animate other values by making your custom views conform to the Animatable protocol, and telling SwiftUI about the value you want to animate.\n\nWhen an animated state change results in adding or removing a view to or from the view hierarchy, you can tell SwiftUI how to transition the view into or out of place using built-in transitions that AnyTransition defines, like slide or scale. You can also create custom transitions.\n\nFor design guidance, see Motion in the Human Interface Guidelines.\n\nTopics\nAdding state-based animation to an action\nfunc withAnimation<Result>(Animation?, () throws -> Result) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation.\nfunc withAnimation<Result>(Animation?, completionCriteria: AnimationCompletionCriteria, () throws -> Result, completion: () -> Void) rethrows -> Result\nReturns the result of recomputing the view\u2019s body with the provided animation, and runs the completion when all animations are complete.\nstruct AnimationCompletionCriteria\nThe criteria that determines when an animation is considered finished.\nstruct Animation\nThe way a view changes over time to create a smooth visual transition from one state to another.\nAdding state-based animation to a view\nfunc animation(Animation?) -> some View\nApplies the given animation to this view when this view changes.\nAvailable when Self conforms to Equatable.\nfunc animation<V>(Animation?, value: V) -> some View\nApplies the given animation to this view when the specified value changes.\nfunc animation<V>(Animation?, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given animation to all animatable values within the body closure.\nCreating phase-based animation\nControlling the timing and movements of your animations\nBuild sophisticated animations that you control using phase and keyframe animators.\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change continuously.\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View\nAnimates effects that you apply to a view over a sequence of phases that change based on a trigger.\nstruct PhaseAnimator\nA container that animates its content by automatically cycling through a collection of phases that you provide, each defining a discrete step within an animation.\nCreating keyframe-based animation\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nLoops the given keyframes continuously, updating the view using the modifiers you apply in body.\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View\nPlays the given keyframes when the given trigger value changes, updating the view using the modifiers you apply in body.\nstruct KeyframeAnimator\nA container that animates its content with keyframes.\nprotocol Keyframes\nA type that defines changes to a value over time.\nstruct KeyframeTimeline\nA description of how a value changes over time, modeled using keyframes.\nstruct KeyframeTrack\nA sequence of keyframes animating a single property of a root type.\nstruct KeyframeTrackContentBuilder\nThe builder that creates keyframe track content from the keyframes that you define within a closure.\nstruct KeyframesBuilder\nA builder that combines keyframe content values into a single value.\nprotocol KeyframeTrackContent\nA group of keyframes that define an interpolation curve of an animatable value.\nstruct CubicKeyframe\nA keyframe that uses a cubic curve to smoothly interpolate between values.\nstruct LinearKeyframe\nA keyframe that uses simple linear interpolation.\nstruct MoveKeyframe\nA keyframe that immediately moves to the given value without interpolating.\nstruct SpringKeyframe\nA keyframe that uses a spring function to interpolate to the given value.\nCreating custom animations\nprotocol CustomAnimation\nA type that defines how an animatable value changes over time.\nstruct AnimationContext\nContextual values that a custom animation can use to manage state and access a view\u2019s environment.\nstruct AnimationState\nA container that stores the state for a custom animation.\nprotocol AnimationStateKey\nA key for accessing animation state values.\nstruct UnitCurve\nA function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed.\nstruct Spring\nA representation of a spring\u2019s motion.\nMaking data animatable\nprotocol Animatable\nA type that describes how to animate a property of a view.\nstruct AnimatablePair\nA pair of animatable values, which is itself animatable.\nprotocol VectorArithmetic\nA type that can serve as the animatable data of an animatable type.\nstruct EmptyAnimatableData\nAn empty type for animatable data.\nUpdating a view on a schedule\nUpdating watchOS apps with timelines\nSeamlessly schedule updates to your user interface, even while it\u2019s inactive.\nstruct TimelineView\nA view that updates according to a schedule that you provide.\nprotocol TimelineSchedule\nA type that provides a sequence of dates for use as a schedule.\ntypealias TimelineViewDefaultContext\nInformation passed to a timeline view\u2019s content callback.\nSynchronizing geometries\nfunc matchedGeometryEffect<ID>(id: ID, in: Namespace.ID, properties: MatchedGeometryProperties, anchor: UnitPoint, isSource: Bool) -> some View\nDefines a group of views with synchronized geometry using an identifier and namespace that you provide.\nstruct MatchedGeometryProperties\nA set of view properties that may be synchronized between views using the View.matchedGeometryEffect() function.\nprotocol GeometryEffect\nAn effect that changes the visual appearance of a view, largely without changing its ancestors or descendants.\nstruct Namespace\nA dynamic property type that allows access to a namespace defined by the persistent identity of the object containing the property (e.g. a view).\nfunc geometryGroup() -> some View\nIsolates the geometry (e.g. position and size) of the view from its parent view.\nDefining transitions\nfunc transition<T>(T) -> some View\nAssociates a transition with the view.\nfunc transition(AnyTransition) -> some View\nAssociates a transition with the view.\nprotocol Transition\nA description of view changes to apply when a view is added to and removed from the view hierarchy.\nstruct TransitionProperties\nThe properties a Transition can have.\nenum TransitionPhase\nAn indication of which the current stage of a transition.\nstruct AsymmetricTransition\nA composite Transition that uses a different transition for insertion versus removal.\nstruct AnyTransition\nA type-erased transition.\nfunc contentTransition(ContentTransition) -> some View\nModifies the view to use a given transition as its method of animating changes to the contents of its views.\nvar contentTransition: ContentTransition\nThe current method of animating the contents of views.\nvar contentTransitionAddsDrawingGroup: Bool\nA Boolean value that controls whether views that render content transitions use GPU-accelerated rendering.\nstruct ContentTransition\nA kind of transition that applies to the content within a single view, rather than to the insertion or removal of a view.\nstruct PlaceholderContentView\nA placeholder used to construct an inline modifier, transition, or other helper type.\nMoving an animation to another view\nfunc withTransaction<Result>(Transaction, () throws -> Result) rethrows -> Result\nExecutes a closure with the specified transaction and returns the result.\nfunc withTransaction<R, V>(WritableKeyPath<Transaction, V>, V, () throws -> R) rethrows -> R\nExecutes a closure with the specified transaction key path and value and returns the result.\nfunc transaction((inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> some View\nApplies the given transaction mutation function to all animations used within the view.\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<Self>) -> V) -> some View\nApplies the given transaction mutation function to all animations used within the body closure.\nstruct Transaction\nThe context of the current state-processing update.\nprotocol TransactionKey\nA key for accessing values in a transaction.\nDeprecated types\nprotocol AnimatableModifier\nA modifier that can create another modifier with animation.\nDeprecated\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "Images",
        "url": "https://developer.apple.com/documentation/swiftui/images",
        "html": "Overview\n\nDisplay images, including SF Symbols, images that you store in an asset catalog, and images that you store on disk, using an Image view.\n\nFor images that take time to retrieve \u2014 for example, when you load an image from a network endpoint \u2014 load the image asynchronously using AsyncImage. You can instruct that view to display a placeholder during the load operation.\n\nFor design guidance, see Images in the Human Interface Guidelines.\n\nTopics\nCreating an image\nstruct Image\nA view that displays an image.\nConfiguring an image\nFitting images into available space\nAdjust the size and shape of images in your app\u2019s user interface by applying view modifiers.\nfunc imageScale(Image.Scale) -> some View\nScales images within the view according to one of the relative sizes available including small, medium, and large images sizes.\nvar imageScale: Image.Scale\nThe image scale for this environment.\nenum Scale\nA scale to apply to vector images relative to text.\nenum Orientation\nThe orientation of an image.\nenum ResizingMode\nThe modes that SwiftUI uses to resize an image to fit within its containing view.\nLoading images asynchronously\nstruct AsyncImage\nA view that asynchronously loads and displays an image.\nenum AsyncImagePhase\nThe current phase of the asynchronous image loading operation.\nSetting a symbol variant\nfunc symbolVariant(SymbolVariants) -> some View\nMakes symbols within the view show a particular variant.\nvar symbolVariants: SymbolVariants\nThe symbol variant to use in this environment.\nstruct SymbolVariants\nA variant of a symbol.\nManaging symbol effects\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> some View\nReturns a new view with a symbol effect added to it.\nfunc symbolEffectsRemoved(Bool) -> some View\nReturns a new view with its inherited symbol image effects either removed or left unchanged.\nstruct SymbolEffectTransition\nCreates a transition that applies the Appear or Disappear symbol animation to symbol images within the inserted or removed view hierarchy.\nSetting symbol rendering modes\nfunc symbolRenderingMode(SymbolRenderingMode?) -> some View\nSets the rendering mode for symbol images within this view.\nvar symbolRenderingMode: SymbolRenderingMode?\nThe current symbol rendering mode, or nil denoting that the mode is picked automatically using the current image and foreground style as parameters.\nstruct SymbolRenderingMode\nA symbol rendering mode.\nRendering images from views\nclass ImageRenderer\nAn object that creates images from SwiftUI views.\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "View styles",
        "url": "https://developer.apple.com/documentation/swiftui/view-styles",
        "html": "Overview\n\nSwiftUI defines built-in styles for certain kinds of views and automatically selects the appropriate style for a particular presentation context. For example, a Label might appear as an icon, a string title, or both, depending on factors like the platform, whether the view appears in a toolbar, and so on.\n\nYou can override the automatic style by using one of the style view modifiers. These modifiers typically propagate throughout a container view, so that you can wrap a view hierarchy in a style modifier to affect all the views of the given type within the hierarchy.\n\nAny of the style protocols that define a makeBody(configuration:) method, like ToggleStyle, also enable you to define custom styles. Create a type that conforms to the corresponding style protocol and implement its makeBody(configuration:) method. Then apply the new style using a style view modifier exactly like a built-in style.\n\nTopics\nStyling buttons\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.\nprotocol ButtonStyle\nA type that applies standard interaction behavior and a custom appearance to all buttons within a view hierarchy.\nstruct ButtonStyleConfiguration\nThe properties of a button.\nfunc buttonStyle<S>(S) -> some View\nSets the style for buttons within this view to a button style with a custom appearance and custom interaction behavior.\nprotocol PrimitiveButtonStyle\nA type that applies custom interaction behavior and a custom appearance to all buttons within a view hierarchy.\nstruct PrimitiveButtonStyleConfiguration\nThe properties of a button.\nfunc signInWithAppleButtonStyle(SignInWithAppleButton.Style) -> some View\nSets the style used for displaying the control (see SignInWithAppleButton.Style).\nStyling pickers\nfunc pickerStyle<S>(S) -> some View\nSets the style for pickers within this view.\nprotocol PickerStyle\nA type that specifies the appearance and interaction of all pickers within a view hierarchy.\nfunc datePickerStyle<S>(S) -> some View\nSets the style for date pickers within this view.\nprotocol DatePickerStyle\nA type that specifies the appearance and interaction of all date pickers within a view hierarchy.\nStyling menus\nfunc menuStyle<S>(S) -> some View\nSets the style for menus within this view.\nprotocol MenuStyle\nA type that applies standard interaction behavior and a custom appearance to all menus within a view hierarchy.\nstruct MenuStyleConfiguration\nA configuration of a menu.\nStyling toggles\nfunc toggleStyle<S>(S) -> some View\nSets the style for toggles in a view hierarchy.\nprotocol ToggleStyle\nThe appearance and behavior of a toggle.\nstruct ToggleStyleConfiguration\nThe properties of a toggle instance.\nStyling indicators\nfunc gaugeStyle<S>(S) -> some View\nSets the style for gauges within this view.\nprotocol GaugeStyle\nDefines the implementation of all gauge instances within a view hierarchy.\nstruct GaugeStyleConfiguration\nThe properties of a gauge instance.\nfunc progressViewStyle<S>(S) -> some View\nSets the style for progress views in this view.\nprotocol ProgressViewStyle\nA type that applies standard interaction behavior to all progress views within a view hierarchy.\nstruct ProgressViewStyleConfiguration\nThe properties of a progress view instance.\nStyling views that display text\nfunc labelStyle<S>(S) -> some View\nSets the style for labels within this view.\nprotocol LabelStyle\nA type that applies a custom appearance to all labels within a view.\nstruct LabelStyleConfiguration\nThe properties of a label.\nfunc textFieldStyle<S>(S) -> some View\nSets the style for text fields within this view.\nprotocol TextFieldStyle\nA specification for the appearance and interaction of a text field.\nfunc textEditorStyle(some TextEditorStyle) -> some View\nSets the style for text editors within this view.\nprotocol TextEditorStyle\nA specification for the appearance and interaction of a text editor.\nstruct TextEditorStyleConfiguration\nThe properties of a text editor.\nStyling collection views\nfunc listStyle<S>(S) -> some View\nSets the style for lists within this view.\nprotocol ListStyle\nA protocol that describes the behavior and appearance of a list.\nfunc tableStyle<S>(S) -> some View\nSets the style for tables within this view.\nprotocol TableStyle\nA type that applies a custom appearance to all tables within a view.\nstruct TableStyleConfiguration\nThe properties of a table.\nfunc disclosureGroupStyle<S>(S) -> some View\nSets the style for disclosure groups within this view.\nprotocol DisclosureGroupStyle\nA type that specifies the appearance and interaction of disclosure groups within a view hierarchy.\nStyling navigation views\nfunc navigationSplitViewStyle<S>(S) -> some View\nSets the style for navigation split views within this view.\nprotocol NavigationSplitViewStyle\nA type that specifies the appearance and interaction of navigation split views within a view hierarchy.\nfunc tabViewStyle<S>(S) -> some View\nSets the style for the tab view within the current environment.\nprotocol TabViewStyle\nA specification for the appearance and interaction of a TabView.\nStyling groups\nfunc controlGroupStyle<S>(S) -> some View\nSets the style for control groups within this view.\nprotocol ControlGroupStyle\nDefines the implementation of all control groups within a view hierarchy.\nstruct ControlGroupStyleConfiguration\nThe properties of a control group.\nfunc formStyle<S>(S) -> some View\nSets the style for forms in a view hierarchy.\nprotocol FormStyle\nThe appearance and behavior of a form.\nstruct FormStyleConfiguration\nThe properties of a form instance.\nfunc groupBoxStyle<S>(S) -> some View\nSets the style for group boxes within this view.\nprotocol GroupBoxStyle\nA type that specifies the appearance and interaction of all group boxes within a view hierarchy.\nstruct GroupBoxStyleConfiguration\nThe properties of a group box instance.\nfunc indexViewStyle<S>(S) -> some View\nSets the style for the index view within the current environment.\nprotocol IndexViewStyle\nDefines the implementation of all IndexView instances within a view hierarchy.\nfunc labeledContentStyle<S>(S) -> some View\nSets a style for labeled content.\nprotocol LabeledContentStyle\nThe appearance and behavior of a labeled content instance..\nstruct LabeledContentStyleConfiguration\nThe properties of a labeled content instance.\nStyling windows from a view inside the window\nfunc presentedWindowStyle<S>(S) -> some View\nSets the style for windows created by interacting with this view.\nfunc presentedWindowToolbarStyle<S>(S) -> some View\nSets the style for the toolbar in windows created by interacting with this view.\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "View configuration",
        "url": "https://developer.apple.com/documentation/swiftui/view-configuration",
        "html": "Overview\n\nSwiftUI enables you to tune the appearance and behavior of views using view modifiers.\n\nMany modifiers apply to specific kinds of views or behaviors, but some apply more generally. For example, you can conditionally hide any view by dynamically setting its opacity, display contextual help when people hover over a view, or request the light or dark appearance for a view.\n\nTopics\nHiding views\nfunc opacity(Double) -> some View\nSets the transparency of this view.\nfunc hidden() -> some View\nHides this view unconditionally.\nHiding system elements\nfunc labelsHidden() -> some View\nHides the labels of any controls contained within this view.\nfunc menuIndicator(Visibility) -> some View\nSets the menu indicator visibility for controls within this view.\nfunc statusBarHidden(Bool) -> some View\nSets the visibility of the status bar.\nfunc persistentSystemOverlays(Visibility) -> some View\nSets the preferred visibility of the non-transient system views overlaying the app.\nenum Visibility\nThe visibility of a UI element, chosen automatically based on the platform, current context, and other factors.\nManaging view interaction\nfunc disabled(Bool) -> some View\nAdds a condition that controls whether users can interact with this view.\nvar isEnabled: Bool\nA Boolean value that indicates whether the view associated with this environment allows user interaction.\nfunc interactionActivityTrackingTag(String) -> some View\nSets a tag that you use for tracking interactivity.\nfunc invalidatableContent(Bool) -> some View\nMark the receiver as their content might be invalidated.\nProviding contextual help\nfunc help(LocalizedStringKey) -> some View\nAdds help text to a view using a localized string that you provide.\nfunc help<S>(S) -> some View\nAdds help text to a view using a string that you provide.\nfunc help(Text) -> some View\nAdds help text to a view using a text view that you provide.\nAdding a glass background\nfunc glassBackgroundEffect(displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material that\u2019s shaped as a container-relative rounded rectangle.\nBeta\nfunc glassBackgroundEffect<S>(in: S, displayMode: GlassBackgroundDisplayMode) -> some View\nFills the view\u2019s background with a glass material using a shape that you specify.\nBeta\nenum GlassBackgroundDisplayMode\nThe display mode of a glass background.\nBeta\nDetecting and requesting the light or dark appearance\nfunc preferredColorScheme(ColorScheme?) -> some View\nSets the preferred color scheme for this presentation.\nvar colorScheme: ColorScheme\nThe color scheme of this environment.\nenum ColorScheme\nThe possible color schemes, corresponding to the light and dark appearances.\nGetting the color scheme contrast\nvar colorSchemeContrast: ColorSchemeContrast\nThe contrast associated with the color scheme of this environment.\nenum ColorSchemeContrast\nThe contrast between the app\u2019s foreground and background colors.\nConfiguring passthrough\nfunc preferredSurroundingsEffect(SurroundingsEffect?) -> some View\nSets the preferred video passthrough effect of the user\u2019s surroundings.\nBeta\nstruct SurroundingsEffect\nBeta\nRedacting private content\nDesigning your app for the Always On state\nCustomize your watchOS app\u2019s user interface for continuous display.\nfunc privacySensitive(Bool) -> some View\nMarks the view as containing sensitive, private user data.\nfunc redacted(reason: RedactionReasons) -> some View\nAdds a reason to apply a redaction to this view hierarchy.\nfunc unredacted() -> some View\nRemoves any reason to apply a redaction to this view hierarchy.\nvar redactionReasons: RedactionReasons\nThe current redaction reasons applied to the view hierarchy.\nvar isSceneCaptured: Bool\nThe current capture state.\nstruct RedactionReasons\nThe reasons to apply a redaction to data displayed on screen.\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "View fundamentals",
        "url": "https://developer.apple.com/documentation/swiftui/view-fundamentals",
        "html": "Overview\n\nViews are the building blocks that you use to declare your app\u2019s user interface. Each view contains a description of what to display for a given state. Every bit of your app that\u2019s visible to the user derives from the description in a view, and any type that conforms to the View protocol can act as a view in your app.\n\nCompose a custom view by combining built-in views that SwiftUI provides with other custom views that you create in your view\u2019s body computed property. Configure views using the view modifiers that SwiftUI provides, or by defining your own view modifiers using the ViewModifier protocol and the modifier(_:) method.\n\nTopics\nCreating a view\nDeclaring a custom view\nDefine views and assemble them into a view hierarchy.\nprotocol View\nA type that represents part of your app\u2019s user interface and provides modifiers that you use to configure views.\nstruct ViewBuilder\nA custom parameter attribute that constructs views from closures.\nModifying a view\nConfiguring views\nAdjust the characteristics of a view by applying view modifiers.\nReducing view modifier maintenance\nBundle view modifiers that you regularly reuse into a custom view modifier.\nfunc modifier<T>(T) -> ModifiedContent<Self, T>\nApplies a modifier to a view and returns a new view.\nprotocol ViewModifier\nA modifier that you apply to a view or another view modifier, producing a different version of the original value.\nstruct EmptyModifier\nAn empty, or identity, modifier, used during development to switch modifiers at compile time.\nstruct ModifiedContent\nA value with a modifier applied to it.\nprotocol EnvironmentalModifier\nA modifier that must resolve to a concrete modifier in an environment before use.\nResponding to view life cycle updates\nfunc onAppear(perform: (() -> Void)?) -> some View\nAdds an action to perform before this view appears.\nfunc onDisappear(perform: (() -> Void)?) -> some View\nAdds an action to perform after this view disappears.\nfunc task(priority: TaskPriority, () async -> Void) -> some View\nAdds an asynchronous task to perform before this view appears.\nfunc task<T>(id: T, priority: TaskPriority, () async -> Void) -> some View\nAdds a task to perform before this view appears or when a specified value changes.\nManaging the view hierarchy\nfunc id<ID>(ID) -> some View\nBinds a view\u2019s identity to the given proxy value.\nfunc tag<V>(V) -> some View\nSets the unique tag value of this view.\nfunc equatable() -> EquatableView<Self>\nPrevents the view from updating its child view when its new value is the same as its old value.\nAvailable when Self conforms to Equatable.\nSupporting view types\nstruct AnyView\nA type-erased view.\nstruct EmptyView\nA view that doesn\u2019t contain any content.\nstruct EquatableView\nA view type that compares itself against its previous value and prevents its child updating if its new value is the same as its old value.\nstruct SubscriptionView\nA view that subscribes to a publisher with an action.\nstruct TupleView\nA View created from a swift tuple of View values.\nSee Also\nViews\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "Persistent storage",
        "url": "https://developer.apple.com/documentation/swiftui/persistent-storage",
        "html": "Overview\n\nThe operating system provides ways to store data when your app closes, so that when people open your app again later, they can continue working without interruption. The mechanism that you use depends on factors like what and how much you need to store, whether you need serialized or random access to the data, and so on.\n\nYou use the same kinds of storage in a SwiftUI app that you use in any other app. For example, you can access files on disk using the FileManager interface. However, SwiftUI also provides conveniences that make it easier to use certain kinds of persistent storage in a declarative environment. For example, you can use FetchRequest and FetchedResults to interact with a Core Data model.\n\nTopics\nSaving state across app launches\nRestoring Your App\u2019s State with SwiftUI\nProvide app continuity for users by preserving their current activities.\nfunc defaultAppStorage(UserDefaults) -> some View\nThe default store used by AppStorage contained within the view.\nstruct AppStorage\nA property wrapper type that reflects a value from UserDefaults and invalidates a view on a change in value in that user default.\nstruct SceneStorage\nA property wrapper type that reads and writes to persisted, per-scene storage.\nAccessing Core Data\nLoading and Displaying a Large Data Feed\nConsume data in the background, and lower memory use by batching imports and preventing duplicate records.\nvar managedObjectContext: NSManagedObjectContext\nstruct FetchRequest\nA property wrapper type that retrieves entities from a Core Data persistent store.\nstruct FetchedResults\nA collection of results retrieved from a Core Data store.\nstruct SectionedFetchRequest\nA property wrapper type that retrieves entities, grouped into sections, from a Core Data persistent store.\nstruct SectionedFetchResults\nA collection of results retrieved from a Core Data persistent store, grouped into sections.\nSee Also\nData and storage\nModel data\nManage the data that your app uses to drive its interface.\nEnvironment values\nShare data throughout a view hierarchy using the environment.\nPreferences\nIndicate configuration preferences from views to their container views."
    },
    {
        "title": "Preferences",
        "url": "https://developer.apple.com/documentation/swiftui/preferences",
        "html": "Overview\n\nWhereas you use the environment to configure the subviews of a view, you use preferences to send configuration information from subviews toward their container. However, unlike configuration information that flows down a view hierarchy from one container to many subviews, a single container needs to reconcile potentially conflicting preferences flowing up from its many subviews.\n\nWhen you use the PreferenceKey protocol to define a custom preference, you indicate how to merge preferences from multiple subviews. You can then set a value for the preference on a view using the preference(key:value:) view modifier. Many built-in modifiers, like navigationTitle(_:), rely on preferences to send configuration information to their container.\n\nTopics\nSetting preferences\nfunc preference<K>(key: K.Type, value: K.Value) -> some View\nSets a value for the given preference.\nfunc transformPreference<K>(K.Type, (inout K.Value) -> Void) -> some View\nApplies a transformation to a preference value.\nCreating custom preferences\nprotocol PreferenceKey\nA named value produced by a view.\nSetting preferences based on geometry\nfunc anchorPreference<A, K>(key: K.Type, value: Anchor<A>.Source, transform: (Anchor<A>) -> K.Value) -> some View\nSets a value for the specified preference key, the value is a function of a geometry value tied to the current coordinate space, allowing readers of the value to convert the geometry to their local coordinates.\nfunc transformAnchorPreference<A, K>(key: K.Type, value: Anchor<A>.Source, transform: (inout K.Value, Anchor<A>) -> Void) -> some View\nSets a value for the specified preference key, the value is a function of the key\u2019s current value and a geometry value tied to the current coordinate space, allowing readers of the value to convert the geometry to their local coordinates.\nResponding to changes in preferences\nfunc onPreferenceChange<K>(K.Type, perform: (K.Value) -> Void) -> some View\nAdds an action to perform when the specified preference key\u2019s value changes.\nGenerating backgrounds and overlays from preferences\nfunc backgroundPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc backgroundPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as the background of the original view.\nfunc overlayPreferenceValue<Key, T>(Key.Type, (Key.Value) -> T) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view.\nfunc overlayPreferenceValue<K, V>(K.Type, alignment: Alignment, (K.Value) -> V) -> some View\nReads the specified preference value from the view, using it to produce a second view that is applied as an overlay to the original view.\nSee Also\nData and storage\nModel data\nManage the data that your app uses to drive its interface.\nEnvironment values\nShare data throughout a view hierarchy using the environment.\nPersistent storage\nStore data for use across sessions of your app."
    },
    {
        "title": "Modal presentations",
        "url": "https://developer.apple.com/documentation/swiftui/modal-presentations",
        "html": "Overview\n\nTo draw attention to an important, narrowly scoped task, you display a modal presentation, like an alert, popover, sheet, or confirmation dialog.\n\nIn SwiftUI, you create a modal presentation using a view modifier that defines how the presentation looks and the condition under which SwiftUI presents it. SwiftUI detects when the condition changes and makes the presentation for you. Because you provide a Binding to the condition that initiates the presentation, SwiftUI can reset the underlying value when the user dismisses the presentation.\n\nFor design guidance, see Modality in the Human Interface Guidelines.\n\nTopics\nConfiguring a dialog\nstruct DialogSeverity\nThe severity of an alert or confirmation dialog.\nShowing a sheet, cover, or popover\nfunc sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a sheet when a binding to a Boolean value that you provide is true.\nfunc sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a sheet using the given item as a data source for the sheet\u2019s content.\nfunc fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)?, content: () -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.\nfunc fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)?, content: (Item) -> Content) -> some View\nPresents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet\u2019s content.\nfunc popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: () -> Content) -> some View\nPresents a popover when a given condition is true.\nfunc popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor, arrowEdge: Edge, content: (Item) -> Content) -> some View\nPresents a popover using the given item as a data source for the popover\u2019s content.\nenum PopoverAttachmentAnchor\nAn attachment anchor for a popover.\nAdapting a presentation to size classes\nfunc presentationCompactAdaptation(horizontal: PresentationAdaptation, vertical: PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to horizontally and vertically compact size classes.\nfunc presentationCompactAdaptation(PresentationAdaptation) -> some View\nSpecifies how to adapt a presentation to compact size classes.\nstruct PresentationAdaptation\nStrategies for adapting a presentation to a different size class.\nConfiguring a sheet\u2019s height\nfunc presentationDetents(Set<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet.\nfunc presentationDetents(Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View\nSets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.\nfunc presentationContentInteraction(PresentationContentInteraction) -> some View\nConfigures the behavior of swipe gestures on a presentation.\nfunc presentationDragIndicator(Visibility) -> some View\nSets the visibility of the drag indicator on top of a sheet.\nstruct PresentationDetent\nA type that represents a height where a sheet naturally rests.\nprotocol CustomPresentationDetent\nThe definition of a custom detent with a calculated height.\nstruct PresentationContentInteraction\nA behavior that you can use to influence how a presentation responds to swipe gestures.\nStyling a sheet and its background\nfunc presentationCornerRadius(CGFloat?) -> some View\nRequests that the presentation have a specific corner radius.\nfunc presentationBackground<S>(S) -> some View\nSets the presentation background of the enclosing sheet using a shape style.\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> some View\nSets the presentation background of the enclosing sheet to a custom view.\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> some View\nControls whether people can interact with the view behind a presentation.\nstruct PresentationBackgroundInteraction\nThe kinds of interaction available to views behind a presentation.\nPresenting an alert\nfunc alert<S, A>(S, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a string variable as a title.\nfunc alert<A>(Text, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a text view for the title.\nfunc alert<A>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A) -> some View\nPresents an alert when a given condition is true, using a localized string key for the title.\nfunc alert<A, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a text view as a title.\nfunc alert<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<S, A, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A) -> some View\nPresents an alert using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A>(isPresented: Binding<Bool>, error: E?, actions: () -> A) -> some View\nPresents an alert when an error is present.\nPresenting an alert with a message\nfunc alert<S, A, M>(S, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a string variable as a title.\nfunc alert<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true, using a localized string key for a title.\nfunc alert<A, M>(Text, isPresented: Binding<Bool>, actions: () -> A, message: () -> M) -> some View\nPresents an alert with a message when a given condition is true using a text view as a title.\nfunc alert<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a localized string key for a title.\nfunc alert<A, M, T>(Text, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a text view for a title.\nfunc alert<S, A, M, T>(S, isPresented: Binding<Bool>, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents an alert with a message using the given data to produce the alert\u2019s content and a string variable as a title.\nfunc alert<E, A, M>(isPresented: Binding<Bool>, error: E?, actions: (E) -> A, message: (E) -> M) -> some View\nPresents an alert with a message when an error is present.\nGetting confirmation for an action\nfunc confirmationDialog<S, A>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a string variable as a title.\nfunc confirmationDialog<A>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A) -> some View\nPresents a confirmation dialog when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a text view for the title.\nfunc confirmationDialog<A, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a localized string key for the title.\nfunc confirmationDialog<S, A, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A) -> some View\nPresents a confirmation dialog using data to produce the dialog\u2019s content and a string variable for the title.\nShowing a confirmation dialog with a message\nfunc confirmationDialog<S, A, M>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a string variable for the title.\nfunc confirmationDialog<A, M>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a localized string key for the title.\nfunc confirmationDialog<A, M>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, actions: () -> A, message: () -> M) -> some View\nPresents a confirmation dialog with a message when a given condition is true, using a text view for the title.\nfunc confirmationDialog<A, M, T>(Text, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a text view for the message.\nfunc confirmationDialog<S, A, M, T>(S, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a string variable for the title.\nfunc confirmationDialog<A, M, T>(LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility, presenting: T?, actions: (T) -> A, message: (T) -> M) -> some View\nPresents a confirmation dialog with a message using data to produce the dialog\u2019s content and a localized string key for the title.\nConfiguring a dialog\nfunc dialogIcon(Image?) -> some View\nConfigures the icon used by dialogs within this view.\nfunc dialogSeverity(DialogSeverity) -> some View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a default suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View\nEnables user suppression of dialogs and alerts presented within self, with a custom suppression message on macOS. Unused on other platforms.\nExporting to file\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a value type, like a structure, to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for exporting a document that\u2019s stored in a reference type, like a class, to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of value type documents to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for exporting a collection of reference type documents to files on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface for allowing the user to export a FileDocument to a file on disk.\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a ReferenceFileDocument to a file on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to ReferenceFileDocument to files on disk.\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to export a collection of documents that conform to FileDocument to files on disk.\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a Transferable item to file on disk.\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system interface allowing the user to export a collection of items to files on disk.\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nfunc fileExporterFilenameLabel(Text?) -> some View\nOn macOS, configures the fileExporter with a text to use as a label for the file name field.\nfunc fileExporterFilenameLabel<S>(S) -> some View\nOn macOS, configures the fileExporter with a label for the file name field.\nImporting from file\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import multiple files.\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to import an existing file.\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to import multiple files.\nMoving a file\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void) -> some View\nPresents a system interface for allowing the user to move a collection of existing files to a new location.\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move an existing file to a new location.\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> some View\nPresents a system dialog for allowing the user to move a collection of existing files to a new location.\nConfiguring a file dialog\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.\nfunc fileDialogConfirmationLabel<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogConfirmationLabel(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with custom text as a confirmation button label.\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom confirmation button label.\nfunc fileDialogCustomizationID(String) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover to persist and restore the file dialog configuration.\nfunc fileDialogDefaultDirectory(URL?) -> some View\nConfigures the fileExporter, fileImporter, or fileMover to open with the specified default directory.\nfunc fileDialogImportsUnresolvedAliases(Bool) -> some View\nOn macOS, configures the fileExporter, fileImporter, or fileMover behavior when a user chooses an alias.\nfunc fileDialogMessage<S>(S) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogMessage(Text?) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom text that is presented to the user, similar to a title.\nfunc fileDialogMessage(LocalizedStringKey) -> some View\nOn macOS, configures the the fileExporter, fileImporter, or fileMover with a custom message that is presented to the user, similar to a title.\nfunc fileDialogURLEnabled(Predicate<URL>) -> some View\nOn macOS, configures the the fileImporter or fileMover to conditionally disable presented URLs.\nstruct FileDialogBrowserOptions\nThe way that file dialogs present the file system.\nPresenting an inspector\nfunc inspector<V>(isPresented: Binding<Bool>, content: () -> V) -> some View\nInserts an inspector at the applied position in the view hierarchy.\nfunc inspectorColumnWidth(CGFloat) -> some View\nSets a fixed, preferred width for the inspector containing this view when presented as a trailing column.\nfunc inspectorColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View\nSets a flexible, preferred width for the inspector in a trailing-column presentation.\nDismissing a presentation\nvar isPresented: Bool\nA Boolean value that indicates whether the view associated with this environment is currently presented.\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nstruct DismissAction\nAn action that dismisses a presentation.\nfunc interactiveDismissDisabled(Bool) -> some View\nConditionally prevents interactive dismissal of presentations like popovers, sheets, and inspectors.\nDeprecated modal presentations\nstruct Alert\nA representation of an alert presentation.\nDeprecated\nstruct ActionSheet\nA representation of an action sheet presentation.\nDeprecated\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "Search",
        "url": "https://developer.apple.com/documentation/swiftui/search",
        "html": "Overview\n\nTo present a search field in your app, create and manage storage for search text and optionally for discrete search terms known as tokens. Then bind the storage to the search field by applying the searchable view modifier to a view in your app.\n\nAs people interact with the field, they implicitly modify the underlying storage and, thereby, the search parameters. Your app correspondingly updates other parts of its interface. To enhance the search interaction, you can also:\n\nOffer suggestions during search, for both text and tokens.\n\nImplement search scopes that help people to narrow the search space.\n\nDetect when people activate the search field, and programmatically dismiss the search field using environment values.\n\nFor design guidance, see Searching in the Human Interface Guidelines.\n\nTopics\nSearching your app\u2019s data model\nAdding a search interface to your app\nPresent an interface that people can use to search for content in your app.\nPerforming a search operation\nUpdate search results based on search text and optional tokens that you store.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable(text: Binding<String>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<S>(text: Binding<String>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nstruct SearchFieldPlacement\nThe placement of a search field in a view hierarchy.\nMaking search suggestions\nSuggesting search terms\nProvide suggestions to people searching for content in your app.\nfunc searchSuggestions<S>(() -> S) -> some View\nConfigures the search suggestions for this view.\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> some View\nConfigures how to display search suggestions within this view.\nfunc searchCompletion<T>(T) -> some View\nAssociates a search token with the value of this view.\nfunc searchCompletion(String) -> some View\nAssociates a fully formed string with the value of this view.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions.\nstruct SearchSuggestionsPlacement\nThe ways that SwiftUI displays search suggestions.\nLimiting search scope\nScoping a search operation\nDivide the search space into a few broad categories.\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> some View\nConfigures the search scopes for this view.\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> some View\nConfigures the search scopes for this view with the specified activation strategy.\nstruct SearchScopeActivation\nThe ways that searchable modifiers can show or hide search scopes.\nDetecting, activating, and dismissing search\nManaging search interface activation\nProgrammatically detect and dismiss a search field.\nvar isSearching: Bool\nA Boolean value that indicates when the user is searching.\nvar dismissSearch: DismissSearchAction\nAn action that ends the current search interaction.\nstruct DismissSearchAction\nAn action that can end a search interaction.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> some View\nMarks this view as searchable with programmatic presentation of the search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text and tokens, as well as programmatic presentation.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> some View\nMarks this view as searchable, which configures the display of a search field.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> some View\nMarks this view as searchable with text, tokens, and suggestions, as well as programmatic presentation.\nDisplaying toolbar content during search\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> some View\nConfigures the search toolbar presentation behavior for any searchable modifiers within this view.\nstruct SearchPresentationToolbarBehavior\nA type that defines how the toolbar behaves when presenting search.\nSearching for text in a view with find and replace\nfunc findNavigator(isPresented: Binding<Bool>) -> some View\nProgrammatically presents the find and replace interface for text editor views.\nfunc findDisabled(Bool) -> some View\nPrevents find and replace operations in a text editor.\nfunc replaceDisabled(Bool) -> some View\nPrevents replace operations in a text editor.\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "Environment values",
        "url": "https://developer.apple.com/documentation/swiftui/environment-values",
        "html": "Overview\n\nViews in SwiftUI can react to configuration information that they read from the environment using an Environment property wrapper.\n\nA view inherits its environment from its container view, subject to explicit changes from an environment(_:_:) view modifier, or by implicit changes from one of the many modifiers that operate on environment values. As a result, you can configure a entire hierarchy of views by modifying the environment of the group\u2019s container.\n\nYou can find many built-in environment values in the EnvironmentValues structure. You can also create custom values using the EnvironmentKey protocol.\n\nTopics\nAccessing environment values\nstruct Environment\nA property wrapper that reads a value from a view\u2019s environment.\nstruct EnvironmentValues\nA collection of environment values propagated through a view hierarchy.\nCreating custom environment values\nprotocol EnvironmentKey\nA key for accessing values in the environment.\nModifying the environment of a view\nfunc environment<T>(T?) -> some View\nPlaces an observable object in the view\u2019s environment.\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some View\nSets the environment value of the specified key path to the given value.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some View\nTransforms the environment value of the specified key path with the given function.\nModifying the environment of a scene\nfunc environment<T>(T?) -> some Scene\nPlaces an observable object in the scene\u2019s environment.\nfunc environment<V>(WritableKeyPath<EnvironmentValues, V>, V) -> some Scene\nSets the environment value of the specified key path to the given value.\nfunc transformEnvironment<V>(WritableKeyPath<EnvironmentValues, V>, transform: (inout V) -> Void) -> some Scene\nTransforms the environment value of the specified key path with the given function.\nSee Also\nData and storage\nModel data\nManage the data that your app uses to drive its interface.\nPreferences\nIndicate configuration preferences from views to their container views.\nPersistent storage\nStore data for use across sessions of your app."
    },
    {
        "title": "Model data",
        "url": "https://developer.apple.com/documentation/swiftui/model-data",
        "html": "Overview\n\nSwiftUI offers a declarative approach to user interface design. As you compose a hierarchy of views, you also indicate data dependencies for the views. When the data changes, either due to an external event or because of an action that the user performs, SwiftUI automatically updates the affected parts of the interface. As a result, the framework automatically performs most of the work that view controllers traditionally do.\n\nThe framework provides tools, like state variables and bindings, for connecting your app\u2019s data to the user interface. These tools help you maintain a single source of truth for every piece of data in your app, in part by reducing the amount of glue logic you write. Select the tool that best suits the task you need to perform:\n\nManage transient UI state locally within a view by wrapping value types as State properties.\n\nShare a reference to a source of truth, like local state, using the Binding property wrapper.\n\nConnect to and observe reference model data in views by applying the Observable() macro to the model data type. Instantiate an observable model data type directly in a view using a State property. Share the observable model data with other views in the hierarchy without passing a reference using the Environment property wrapper.\n\nLeveraging property wrappers\n\nSwiftUI implements many data management types, like State and Binding, as Swift property wrappers. Apply a property wrapper by adding an attribute with the wrapper\u2019s name to a property\u2019s declaration.\n\n@State private var isVisible = true // Declares isVisible as a state variable.\n\n\nThe property gains the behavior that the wrapper specifies. The state and data flow property wrappers in SwiftUI watch for changes in your data, and automatically update affected views as necessary. When you refer directly to the property in your code, you access the wrapped value, which for the isVisible state property in the example above is the stored Boolean.\n\nif isVisible == true {\n    Text(\"Hello\") // Only renders when isVisible is true.\n}\n\n\nAlternatively, you can access a property wrapper\u2019s projected value by prefixing the property name with the dollar sign ($). SwiftUI state and data flow property wrappers project a Binding, which is a two-way connection to the wrapped value, allowing another view to access and mutate a single source of truth.\n\nToggle(\"Visible\", isOn: $isVisible) // The toggle can update the stored value.\n\n\nFor more information about property wrappers, see Property Wrappers in The Swift Programming Language.\n\nTopics\nCreating and sharing view state\nManaging user interface state\nEncapsulate view-specific data within your app\u2019s view hierarchy to make your views reusable.\nstruct State\nA property wrapper type that can read and write a value managed by SwiftUI.\nstruct Bindable\nA property wrapper type that supports creating bindings to the mutable properties of observable objects.\nstruct Binding\nA property wrapper type that can read and write a value owned by a source of truth.\nCreating model data\nManaging model data in your app\nCreate connections between your app\u2019s data model and views.\nMigrating from the Observable Object protocol to the Observable macro\nUpdate your existing app to leverage the benefits of Observation in Swift.\nmacro Observable()\nDefines and implements conformance of the Observable protocol.\nMonitoring data changes in your app\nShow changes to data in your app\u2019s user interface by using observable objects.\nstruct StateObject\nA property wrapper type that instantiates an observable object.\nstruct ObservedObject\nA property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes.\nprotocol ObservableObject\nA type of object with a publisher that emits before the object has changed.\nResponding to data changes\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes.\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> some View\nAdds a modifier for this view that fires an action when a specific value changes.\nfunc onReceive<P>(P, perform: (P.Output) -> Void) -> some View\nAdds an action to perform when this view detects data emitted by the given publisher.\nDistributing model data throughout your app\nfunc environmentObject<T>(T) -> some View\nSupplies an observable object to a view\u2019s hierarchy.\nfunc environmentObject<T>(T) -> some Scene\nSupplies an ObservableObject to a view subhierarchy.\nstruct EnvironmentObject\nA property wrapper type for an observable object that a parent or ancestor view supplies.\nManaging dynamic data\nprotocol DynamicProperty\nAn interface for a stored variable that updates an external property of a view.\nSee Also\nData and storage\nEnvironment values\nShare data throughout a view hierarchy using the environment.\nPreferences\nIndicate configuration preferences from views to their container views.\nPersistent storage\nStore data for use across sessions of your app."
    },
    {
        "title": "App extensions",
        "url": "https://developer.apple.com/documentation/swiftui/app-extensions",
        "html": "Overview\n\nUse SwiftUI along with WidgetKit to add widgets to your app.\n\nWidgets provide quick access to relevant content from your app. Define a structure that conforms to the Widget protocol, and declare a view hierarchy for the widget. Configure the views inside the widget as you do other SwiftUI views, using view modifiers, including a few widget-specific modifiers.\n\nFor design guidance, see Widgets in the Human Interface Guidelines.\n\nTopics\nCreating widgets\nBuilding Widgets Using WidgetKit and SwiftUI\nCreate widgets to show your app\u2019s content on the Home screen, with custom intents for user-customizable settings.\nCreating a widget extension\nDisplay your app\u2019s content in a convenient, informative widget on various devices.\nKeeping a widget up to date\nPlan your widget\u2019s timeline to show timely, relevant information using dynamic views, and update the timeline when things change.\nMaking a configurable widget\nGive people the option to customize their widgets by adding a custom app intent to your project.\nprotocol Widget\nThe configuration and content of a widget to display on the Home screen or in Notification Center.\nprotocol WidgetBundle\nA container used to expose multiple widgets from a single widget extension.\nstruct LimitedAvailabilityConfiguration\nA type-erased widget configuration.\nprotocol WidgetConfiguration\nA type that describes a widget\u2019s content.\nstruct EmptyWidgetConfiguration\nAn empty widget configuration.\nLabeling a widget\nfunc widgetLabel<S>(S) -> some View\nReturns a text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view.\nfunc widgetLabel(LocalizedStringKey) -> some View\nReturns a localized text label that displays additional content outside the accessory family widget\u2019s main SwiftUI view.\nfunc widgetLabel<Label>(label: () -> Label) -> some View\nCreates a label for displaying additional content outside an accessory family widget\u2019s main SwiftUI view.\nControlling the accented group\nfunc widgetAccentable(Bool) -> some View\nAdds the view and all of its subviews to the accented group.\nManaging placement in the Dynamic Island\nfunc dynamicIsland(verticalPlacement: DynamicIslandExpandedRegionVerticalPlacement) -> some View\nSpecifies the vertical placement for a view of an expanded Live Activity that appears in the Dynamic Island.\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app."
    },
    {
        "title": "Toolbars",
        "url": "https://developer.apple.com/documentation/swiftui/toolbars",
        "html": "Overview\n\nThe system might present toolbars above or below your app\u2019s content, depending on the platform and the context.\n\nAdd items to a toolbar by applying the toolbar(content:) view modifier to a view in your app. You can also configure the toolbar using view modifiers. For example, you can set the visibility of a toolbar with the toolbar(_:for:) modifier.\n\nFor design guidance, see Toolbars in the Human Interface Guidelines.\n\nTopics\nPopulating a toolbar\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the views you provide.\nfunc toolbar<Content>(content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items.\nstruct ToolbarItem\nA model that represents an item which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemGroup\nA model that represents a group of ToolbarItems which can be placed in the toolbar or navigation bar.\nstruct ToolbarItemPlacement\nA structure that defines the placement of a toolbar item.\nprotocol ToolbarContent\nConforming types represent items that can be placed in various locations in a toolbar.\nstruct ToolbarContentBuilder\nConstructs a toolbar item set from multi-expression closures.\nPopulating a customizable toolbar\nfunc toolbar<Content>(id: String, content: () -> Content) -> some View\nPopulates the toolbar or navigation bar with the specified items, allowing for user customization.\nprotocol CustomizableToolbarContent\nConforming types represent items that can be placed in various locations in a customizable toolbar.\nstruct ToolbarCustomizationBehavior\nThe customization behavior of customizable toolbar content.\nstruct ToolbarCustomizationOptions\nOptions that influence the default customization behavior of customizable toolbar content.\nRemoving default items\nfunc toolbar(removing: ToolbarDefaultItemKind?) -> some View\nRemove a toolbar item present by default\nstruct ToolbarDefaultItemKind\nA kind of toolbar item a View adds by default.\nSetting toolbar visibility\nfunc toolbar(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the visibility of a bar managed by SwiftUI.\nstruct ToolbarPlacement\nThe placement of a toolbar.\nSpecifying the role of toolbar content\nfunc toolbarRole(ToolbarRole) -> some View\nConfigures the semantic role for the content populating the toolbar.\nstruct ToolbarRole\nThe purpose of content that populates the toolbar.\nStyling a toolbar\nfunc toolbarBackground<S>(S, for: ToolbarPlacement...) -> some View\nSpecifies the preferred shape style of the background of a bar managed by SwiftUI.\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> some View\nSpecifies the preferred visibility of backgrounds on a bar managed by SwiftUI.\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> some View\nSpecifies the preferred color scheme of a bar managed by SwiftUI.\nfunc windowToolbarStyle<S>(S) -> some Scene\nSets the style for the toolbar defined within this scene.\nprotocol WindowToolbarStyle\nA specification for the appearance and behavior of a window\u2019s toolbar.\nConfiguring the toolbar title display mode\nfunc toolbarTitleDisplayMode(ToolbarTitleDisplayMode) -> some View\nConfigures the toolbar title display mode for this view.\nstruct ToolbarTitleDisplayMode\nA type that defines the behavior of title of a toolbar.\nSetting the toolbar title menu\nfunc toolbarTitleMenu<C>(content: () -> C) -> some View\nConfigure the title menu of a toolbar.\nstruct ToolbarTitleMenu\nThe title menu of a toolbar.\nCreating an ornament\nfunc ornament<Content>(visibility: Visibility, attachmentAnchor: OrnamentAttachmentAnchor, contentAlignment: Alignment, ornament: () -> Content) -> some View\nPresents an ornament.\nBeta\nstruct OrnamentAttachmentAnchor\nBeta\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "Documents",
        "url": "https://developer.apple.com/documentation/swiftui/documents",
        "html": "Overview\n\nCreate a user interface for opening and editing documents using the DocumentGroup scene type.\n\nYou initialize the scene with a model that describes the organization of the document\u2019s data, and a view hierarchy that SwiftUI uses to display the document\u2019s contents to the user. You can use either a value type model, which you typically store as a structure, that conforms to the FileDocument protocol, or a reference type model you store in a class instance that conforms to the ReferenceFileDocument protocol.\n\nSwiftUI supports standard behaviors that users expect from a document-based app, appropriate for each platform, like multiwindow support, open and save panels, drag and drop, and so on. For related design guidance, see Patterns in the Human Interface Guidelines.\n\nTopics\nCreating a document\nBuilding a Document-Based App with SwiftUI\nCreate, save, and open documents in a SwiftUI multiplatform app.\nBuilding a document-based app using SwiftData\nCode along with the WWDC presenter to transform an app with SwiftData.\nstruct DocumentGroup\nA scene that enables support for opening, creating, and saving documents.\nStoring document data in a structure instance\nprotocol FileDocument\nA type that you use to serialize documents to and from file.\nstruct FileDocumentConfiguration\nThe properties of an open file document.\nStoring document data in a class instance\nprotocol ReferenceFileDocument\nA type that you use to serialize reference type documents to and from file.\nstruct ReferenceFileDocumentConfiguration\nThe properties of an open reference file document.\nvar undoManager: UndoManager?\nThe undo manager used to register a view\u2019s undo operations.\nAccessing document configuration\nvar documentConfiguration: DocumentConfiguration?\nThe configuration of a document in a DocumentGroup.\nstruct DocumentConfiguration\nReading and writing documents\nstruct FileDocumentReadConfiguration\nThe configuration for reading file contents.\nstruct FileDocumentWriteConfiguration\nThe configuration for serializing file contents.\nOpening a document programmatically\nvar newDocument: NewDocumentAction\nAn action in the environment that presents a new document.\nstruct NewDocumentAction\nAn action that presents a new document.\nvar openDocument: OpenDocumentAction\nAn action in the environment that presents an existing document.\nstruct OpenDocumentAction\nAn action that presents an existing document.\nRenaming a document\nstruct RenameButton\nA button that triggers a standard rename action.\nfunc renameAction(FocusState<Bool>.Binding) -> some View\nSets the rename action in the environment to update focus state.\nfunc renameAction(() -> Void) -> some View\nSets a closure to run for the rename action.\nvar rename: RenameAction?\nAn action that activates the standard rename interaction.\nstruct RenameAction\nAn action that activates a standard rename interaction.\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "Windows",
        "url": "https://developer.apple.com/documentation/swiftui/windows",
        "html": "Overview\n\nThe most common way to present a view hierarchy in your app\u2019s interface is with a WindowGroup, which produces a platform-specific behavior and appearance.\n\nOn platforms that support it, people can open multiple windows from the group simultaneously. Each window relies on the same root view definition, but retains its own view state. On some platforms, you can also supplement your app\u2019s user interface with a single-instance window using the Window scene type.\n\nConfigure windows using scene modifiers that you add to the window declaration, like windowStyle(_:) or defaultPosition(_:). You can also indicate how to configure new windows that you present from a view hierarchy by adding the presentedWindowStyle(_:) view modifier to a view in the hierarchy.\n\nFor design guidance, see Windows in the Human Interface Guidelines.\n\nTopics\nCreating windows\nBringing multiple windows to your SwiftUI app\nCompose rich views by reacting to state changes and customize your app\u2019s scene presentation and behavior on iPadOS and macOS.\nstruct WindowGroup\nA scene that presents a group of identically structured windows.\nstruct Window\nA scene that presents its content in a single, unique window.\nprotocol WindowStyle\nA specification for the appearance and interaction of a window.\nfunc windowStyle<S>(S) -> some Scene\nSets the style for windows created by this scene.\nStyling the associated toolbar\nfunc windowToolbarStyle<S>(S) -> some Scene\nSets the style for the toolbar defined within this scene.\nprotocol WindowToolbarStyle\nA specification for the appearance and behavior of a window\u2019s toolbar.\nOpening windows\nPresenting windows and spaces\nOpen and close the scenes that make up your app\u2019s interface.\nvar supportsMultipleWindows: Bool\nA Boolean value that indicates whether the current platform supports opening multiple windows.\nvar openWindow: OpenWindowAction\nA window presentation action stored in a view\u2019s environment.\nstruct OpenWindowAction\nAn action that presents a window.\nClosing windows\nvar dismissWindow: DismissWindowAction\nA window dismissal action stored in a view\u2019s environment.\nstruct DismissWindowAction\nAn action that dismisses a window associated to a particular scene.\nvar dismiss: DismissAction\nAn action that dismisses the current presentation.\nstruct DismissAction\nAn action that dismisses a presentation.\nstruct DismissBehavior\nProgrammatic window dismissal behaviors.\nPositioning and sizing a window\nPositioning and sizing windows\nInfluence the initial geometry of windows that your app presents.\nfunc defaultPosition(UnitPoint) -> some Scene\nSets a default position for a window.\nfunc defaultSize(CGSize) -> some Scene\nSets a default size for a window.\nfunc defaultSize(Size3D) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat) -> some Scene\nSets a default width and height for a window.\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(Size3D, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc defaultSize(width: CGFloat, height: CGFloat, depth: CGFloat, in: UnitLength) -> some Scene\nSets a default size for a volumetric window.\nBeta\nfunc windowResizability(WindowResizability) -> some Scene\nSets the kind of resizability to use for a window.\nstruct WindowResizability\nThe resizability of a window.\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "Immersive spaces",
        "url": "https://developer.apple.com/documentation/swiftui/immersive-spaces",
        "html": "Overview\n\nUse an immersive space to present SwiftUI views outside of any containers. You can include any views in a space, although you typically use a RealityView to present RealityKit content.\n\nYou can request one of three styles of spaces with the immersionStyle(selection:in:) scene modifier:\n\nThe mixed style blends your content with passthrough. This enables you to place virtual objects in a person\u2019s surroundings.\n\nThe full style displays only your content, with passthrough turned off. This enables you to completely control the visual experience, like when you want to transport people to a new world.\n\nThe progressive style completely replaces passthrough in a portion of the display. You might use this style to keep people grounded in the real world while displaying a view into another world.\n\nWhen you open an immersive space, the system continues to display all of your app\u2019s windows, but hides windows from other apps. The system supports displaying only one space at a time across all apps, so your app can only open a space if one isn\u2019t already open.\n\nTopics\nCreating an immersive space\nstruct ImmersiveSpace\nA scene that presents its content in an unbounded space.\nBeta\nstruct ImmersiveSpaceContentBuilder\nA result builder for composing a collection of immersive space elements.\nBeta\nfunc immersionStyle(selection: Binding<ImmersionStyle>, in: ImmersionStyle...) -> some Scene\nSets the allowed styles for the immersive space.\nBeta\nprotocol ImmersionStyle\nThe styles that an immersive space can have.\nBeta\nOpening an immersive space\nvar openImmersiveSpace: OpenImmersiveSpaceAction\nAn action that presents an immersive space.\nBeta\nstruct OpenImmersiveSpaceAction\nAn action that presents an immersive space.\nBeta\nClosing the immersive space\nvar dismissImmersiveSpace: DismissImmersiveSpaceAction\nAn immersive space dismissal action stored in a view\u2019s environment.\nBeta\nstruct DismissImmersiveSpaceAction\nAn action that dismisses an immersive space.\nBeta\nHiding upper limbs during immersion\nfunc upperLimbVisibility(Visibility) -> some Scene\nSets the preferred visibility of the user\u2019s upper limbs, while an ImmersiveSpace scene is presented.\nBeta\nfunc upperLimbVisibility(Visibility) -> some View\nSets the preferred visibility of the user\u2019s upper limbs, while an ImmersiveSpace scene is presented.\nBeta\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "Scenes",
        "url": "https://developer.apple.com/documentation/swiftui/scenes",
        "html": "Overview\n\nA scene represents a part of your app\u2019s user interface that has a life cycle that the system manages. An App instance presents the scenes it contains, while each Scene acts as the root element of a View hierarchy.\n\nThe system presents scenes in different ways depending on the type of scene, the platform, and the context. A scene might fill the entire display, part of the display, a window, a tab in a window, or something else. In some cases, your app might also be able to display more than one instance of the scene at a time, like when a user simultaneously opens multiple windows based on a single WindowGroup declaration in your app. For more information about the primary built-in scene types, see Windows and Documents.\n\nYou configure scenes using modifiers, similar to how you configure views. For example, you can adjust the appearance of the window that contains a scene \u2014 if the scene happens to appear in a window \u2014 using the windowStyle(_:) modifier. Similarly, you can add menu commands that become available when the scene is in the foreground on certain platforms using the commands(content:) modifier.\n\nTopics\nCreating scenes\nprotocol Scene\nA part of an app\u2019s user interface with a life cycle managed by the system.\nstruct SceneBuilder\nA result builder for composing a collection of scenes into a single composite scene.\nMonitoring scene life cycle\nvar scenePhase: ScenePhase\nThe current phase of the scene.\nenum ScenePhase\nAn indication of a scene\u2019s operational state.\nManaging a settings window\nstruct Settings\nA scene that presents an interface for viewing and modifying an app\u2019s settings.\nstruct SettingsLink\nA view that opens the Settings scene defined by an app.\nCreating a menu bar extra\nstruct MenuBarExtra\nA scene that renders itself as a persistent control in the system menu bar.\nfunc menuBarExtraStyle<S>(S) -> some Scene\nSets the style for menu bar extra created by this scene.\nprotocol MenuBarExtraStyle\nA specification for the appearance and behavior of a menu bar extra scene.\nCreating watch notifications\nstruct WKNotificationScene\nA scene which appears in response to receiving the specified category of remote or local notifications.\nSee Also\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "App organization",
        "url": "https://developer.apple.com/documentation/swiftui/app-organization",
        "html": "Overview\n\nDescribe your app\u2019s structure declaratively, much like you declare a view\u2019s appearance. Create a type that conforms to the App protocol and use it to enumerate the Scenes that represent aspects of your app\u2019s user interface.\n\nSwiftUI enables you to write code that works across all of Apple\u2019s platforms. However, it also enables you to tailor your app to the specific capabilities of each platform. For example, if you need to respond to the callbacks that the system traditionally makes on a UIKit, AppKit, or WatchKit app\u2019s delegate, define a delegate object and instantiate it in your app structure using an appropriate delegate adaptor property wrapper, like UIApplicationDelegateAdaptor.\n\nFor platform-specific design guidance, see Platforms in the Human Interface Guidelines.\n\nTopics\nCreating an app\nHello World\nUse windows, volumes, and immersive spaces to teach people about the Earth.\nBackyard Birds: Building an app with SwiftData and widgets\nCreate an app with persistent data, interactive widgets, and an all new in-app purchase experience.\nFood Truck: Building a SwiftUI multiplatform app\nCreate a single codebase and app target for Mac, iPad, and iPhone.\nFruta: Building a Feature-Rich App with SwiftUI\nCreate a shared codebase to build a multiplatform app that offers widgets and an App Clip.\nprotocol App\nA type that represents the structure and behavior of an app.\nTargeting iOS and iPadOS\nUILaunchScreen\nThe user interface to show while an app launches.\nUILaunchScreens\nThe user interfaces to show while an app launches in response to different URL schemes.\nstruct UIApplicationDelegateAdaptor\nA property wrapper type that you use to create a UIKit app delegate.\nTargeting macOS\nstruct NSApplicationDelegateAdaptor\nA property wrapper type that you use to create an AppKit app delegate.\nTargeting watchOS\nstruct WKApplicationDelegateAdaptor\nA property wrapper that is used in App to provide a delegate from WatchKit.\nstruct WKExtensionDelegateAdaptor\nA property wrapper type that you use to create a WatchKit extension delegate.\nSee Also\nApp structure\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget."
    },
    {
        "title": "Shapes",
        "url": "https://developer.apple.com/documentation/swiftui/shapes",
        "html": "Overview\n\nDraw shapes like circles and rectangles, as well as custom paths that define shapes of your own design. Apply styles that include environment-aware colors, rich gradients, and material effects to the foreground, background, and outline of your shapes.\n\nIf you need the efficiency or flexibility of immediate mode drawing \u2014 for example, to create particle effects \u2014 use a Canvas view instead.\n\nTopics\nCreating rectangular shapes\nstruct Rectangle\nA rectangular shape aligned inside the frame of the view containing it.\nstruct RoundedRectangle\nA rectangular shape with rounded corners, aligned inside the frame of the view containing it.\nenum RoundedCornerStyle\nDefines the shape of a rounded rectangle\u2019s corners.\nstruct UnevenRoundedRectangle\nA rectangular shape with rounded corners with different values, aligned inside the frame of the view containing it.\nstruct RectangleCornerRadii\nDescribes the corner radius values of a rounded rectangle with uneven corners.\nCreating circular shapes\nstruct Circle\nA circle centered on the frame of the view containing it.\nstruct Ellipse\nAn ellipse aligned inside the frame of the view containing it.\nstruct Capsule\nA capsule shape aligned inside the frame of the view containing it.\nDrawing custom shapes\nstruct Path\nThe outline of a 2D shape.\nDefining shape behavior\nprotocol ShapeView\nA view that provides a shape that you can use for drawing operations.\nprotocol Shape\nA 2D shape that you can use when drawing a view.\nstruct AnyShape\nA type-erased shape value.\nenum ShapeRole\nWays of styling a shape.\nstruct StrokeStyle\nThe characteristics of a stroke that traces a path.\nstruct StrokeShapeView\nA shape provider that strokes its shape.\nstruct StrokeBorderShapeView\nA shape provider that strokes the border of its shape.\nstruct FillStyle\nA style for rasterizing vector shapes.\nstruct FillShapeView\nA shape provider that fills its shape.\nTransforming a shape\nstruct ScaledShape\nA shape with a scale transform applied to it.\nstruct RotatedShape\nA shape with a rotation transform applied to it.\nstruct OffsetShape\nA shape with a translation offset transform applied to it.\nstruct TransformedShape\nA shape with an affine transform applied to it.\nSetting a container shape\nfunc containerShape<T>(T) -> some View\nSets the container shape to use for any container relative shape within this view.\nprotocol InsettableShape\nA shape type that is able to inset itself to produce another shape.\nstruct ContainerRelativeShape\nA shape that is replaced by an inset version of the current container shape. If no container shape was defined, is replaced by a rectangle.\nSee Also\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings."
    },
    {
        "title": "SwiftUI",
        "url": "https://developer.apple.com/documentation/swiftui",
        "html": "Overview\n\nSwiftUI provides views, controls, and layout structures for declaring your app\u2019s user interface. The framework provides event handlers for delivering taps, gestures, and other types of input to your app, and tools to manage the flow of data from your app\u2019s models down to the views and controls that users see and interact with.\n\nDefine your app structure using the App protocol, and populate it with scenes that contain the views that make up your app\u2019s user interface. Create your own custom views that conform to the View protocol, and compose them with SwiftUI views for displaying text, images, and custom shapes using stacks, lists, and more. Apply powerful modifiers to built-in views and your own views to customize their rendering and interactivity. Share code between apps on multiple platforms with views and controls that adapt to their context and presentation.\n\nYou can integrate SwiftUI views with objects from the UIKit, AppKit, and WatchKit frameworks to take further advantage of platform-specific functionality. You can also customize accessibility support in SwiftUI, and localize your app\u2019s interface for different languages, countries, or cultural regions.\n\nFeatured samples\nHello World\nUse windows, volumes, and immersive spaces to teach people about the Earth.\nView sample code\nBackyard Birds: Building an app with SwiftData and widgets\nCreate an app with persistent data, interactive widgets, and an all new in-app purchase experience.\nView sample code\nTopics\nEssentials\nIntroducing SwiftUI\nSwiftUI is a modern way to declare user interfaces for any Apple platform. Create beautiful, dynamic apps faster than ever before.\nLearning SwiftUI\nDiscover tips and techniques for building multiplatform apps with this set of conceptual articles and sample code.\nExploring SwiftUI Sample Apps\nExplore these SwiftUI samples using Swift Playgrounds on iPad or in Xcode to learn about defining user interfaces, responding to user interactions, and managing data flow.\nSwiftUI updates\nLearn about important changes to SwiftUI.\nApp structure\nApp organization\nDefine the entry point and top-level structure of your app.\nScenes\nDeclare the user interface groupings that make up the parts of your app.\nWindows\nDisplay user interface content in a window or a collection of windows.\nImmersive spaces\nDisplay unbounded content in a person\u2019s surroundings.\nDocuments\nEnable people to open and manage documents.\nNavigation\nEnable people to move between different parts of your app\u2019s view hierarchy within a scene.\nModal presentations\nPresent content in a separate view that offers focused interaction.\nToolbars\nProvide immediate access to frequently used commands and controls.\nSearch\nEnable people to search for text or other content within your app.\nApp extensions\nExtend your app\u2019s basic functionality to other parts of the system, like by adding a Widget.\nData and storage\nModel data\nManage the data that your app uses to drive its interface.\nEnvironment values\nShare data throughout a view hierarchy using the environment.\nPreferences\nIndicate configuration preferences from views to their container views.\nPersistent storage\nStore data for use across sessions of your app.\nViews\nView fundamentals\nDefine the visual elements of your app using a hierarchy of views.\nView configuration\nAdjust the characteristics of views in a hierarchy.\nView styles\nApply built-in and custom appearances and behaviors to different types of views.\nAnimations\nCreate smooth visual updates in response to state changes.\nText input and output\nDisplay formatted text and get text input from the user.\nImages\nAdd images and symbols to your app\u2019s user interface.\nControls and indicators\nDisplay values and get user selections.\nMenus and commands\nProvide space-efficient, context-dependent access to commands and controls.\nShapes\nTrace and fill built-in and custom shapes with a color, gradient, or other pattern.\nDrawing and graphics\nEnhance your views with graphical effects and customized drawings.\nView layout\nLayout fundamentals\nArrange views inside built-in layout containers like stacks and grids.\nLayout adjustments\nMake fine adjustments to alignment, spacing, padding, and other layout parameters.\nCustom layout\nPlace views in custom arrangements and create animated transitions between layout types.\nLists\nDisplay a structured, scrollable column of information.\nTables\nDisplay selectable, sortable data arranged in rows and columns.\nView groupings\nPresent views in different kinds of purpose-driven containers, like forms or control groups.\nScroll views\nEnable people to scroll to content that doesn\u2019t fit in the current display.\nEvent handling\nGestures\nDefine interactions from taps, clicks, and swipes to fine-grained gestures.\nInput events\nRespond to input from a hardware device, like a keyboard or a Touch Bar.\nClipboard\nEnable people to move or duplicate items by issuing Copy and Paste commands.\nDrag and drop\nEnable people to move or duplicate items by dragging them from one location to another.\nFocus\nIdentify and control which visible object responds to user interaction.\nSystem events\nReact to system events, like opening a URL.\nAccessibility\nAccessibility fundamentals\nMake your SwiftUI apps accessible to everyone, including people with disabilities.\nAccessible appearance\nEnhance the legibility of content in your app\u2019s interface.\nAccessible controls\nImprove access to actions that your app can undertake.\nAccessible descriptions\nDescribe interface elements to help people understand what they represent.\nAccessible navigation\nEnable users to navigate to specific user interface elements using rotors.\nFramework integration\nAppKit integration\nAdd AppKit views to your SwiftUI app, or use SwiftUI views in your AppKit app.\nUIKit integration\nAdd UIKit views to your SwiftUI app, or use SwiftUI views in your UIKit app.\nWatchKit integration\nAdd WatchKit views to your SwiftUI app, or use SwiftUI views in your WatchKit app.\nTechnology-specific views\nUse SwiftUI views that other Apple frameworks provide.\nTool support\nPreviews in Xcode\nGenerate dynamic, interactive previews of your custom views.\nXcode library customization\nExpose custom views and modifiers in the Xcode library.\nStructures\nstruct BlurReplaceTransition\nA transition that animates the insertion or removal of a view by combining blurring and scaling effects.\nstruct ImmersiveAmbientBrightness\nBeta"
    }
]