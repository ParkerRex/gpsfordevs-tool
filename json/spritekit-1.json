[
  {
    "title": "valueForAttributeNamed: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/2715846-valueforattributenamed",
    "html": "Parameters\nkey\n\nThe attribute name.\n\nReturn Value\n\nAn attribute value object containing the scalar or vector value or nil if no such attribute exists.\n\nSee Also\nAdding a Custom Shader to a Sprite\nApplying Shaders to a Sprite\nWrite custom GLSL code that modifies the look of your sprite.\nshader\nA text file that defines code that does custom per-pixel drawing or colorization.\nattributeValues\nThe values of each attribute associated with the node's attached shader.\n- setValue:forAttributeNamed:\nSets an attribute value for an attached shader."
  },
  {
    "title": "initWithColor:size: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519762-initwithcolor",
    "html": "Parameters\ncolor\n\nThe color for the resulting sprite node.\n\nsize\n\nThe size of the sprite node in points.\n\nReturn Value\n\nA newly initialized sprite node.\n\nDiscussion\n\nAlthough textured nodes are the most common way to use the SKSpriteNode class, you can also create sprite nodes without a texture. The behavior of the class changes when the node lacks a texture:\n\nThe sprite node that is returned from this method has its texture property set to nil.\n\nThere is no texture to stretch, so the centerRect parameter is ignored.\n\nThere is no colorization step; the color property is used as the sprite’s color.\n\nThe sprite node's alpha component is used to determine how it is blended into the buffer.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "labelNodeWithText: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519612-labelnodewithtext",
    "html": "Parameters\ntext\n\nThe text to use to initialize the label node.\n\nReturn Value\n\nAn initialized label object.\n\nDiscussion\n\nThe label node’s font is set to Helvetica Neue Ultra Light, 32 point.\n\nSee Also\nCreating a Label\n- initWithFontNamed:\nInitializes a new label object with a specified font.\n+ labelNodeWithFontNamed:\nInitializes a new label object.\n+ labelNodeWithAttributedText:\nInitializes a new label object with an attributed text string."
  },
  {
    "title": "spriteNodeWithTexture: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1579716-spritenodewithtexture",
    "html": "Parameters\ntexture\n\nA SpriteKit texture.\n\nReturn Value\n\nA newly initialized sprite object.\n\nSee Also\nCreating a Sprite from a Texture\n- initWithTexture:\nInitializes a textured sprite using an existing texture object.\n- initWithTexture:color:size:\nInitializes a textured sprite in color using an existing texture object.\n+ spriteNodeWithColor:size:\nInitializes a single-color sprite.\n+ spriteNodeWithImageNamed:\nInitializes a textured sprite using an image file.\n+ spriteNodeWithTexture:size:\nInitializes a textured sprite using an existing texture object but with a specified size.\n+ spriteNodeWithTexture:normalMap:\nInitializes a textured sprite with a normal map to simulate 3D lighting.\ntexture\nThe texture used to draw the sprite."
  },
  {
    "title": "init(tileSet:columns:rows:tileSize:fillWith:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643612-init",
    "html": "Parameters\ntileSet\n\nThe tile set that is used to render the tiles.\n\ncolumns\n\nThe number of columns in the map.\n\nrows\n\nThe number of rows in the map.\n\ntileSize\n\nThe size of each tile in points.\n\ntileGroup\n\nThe tile group to fill the tile map with.\n\nReturn Value\n\nA new tile map node.\n\nDiscussion\n\nFor a grid set type, the overall size, in points, of the node will be numberOfColumns * tileSize.width wide and numberOfRows * tileSize.height high. This initializer fills each tile with a texture defined by the descriptors in the final SKTileGroup argument.\n\nSee Also\nCreating a Tile Map\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, tileGroupLayout: [SKTileGroup])\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows. For a grid set type, the overall size, in points, of the node will be numberOfColumns * tileSize.widthwide andnumberOfRows * tileSize.height high.\nclass func tileMapNodes(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, from: GKNoiseMap, tileTypeNoiseMapThresholds: [NSNumber]) -> [SKTileMapNode]\nCreates a tile map node by allowing a GKNoiseMap to choose its tiles."
  },
  {
    "title": "init(tileSet:columns:rows:tileSize:tileGroupLayout:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643597-init",
    "html": "Parameters\ntileSet\n\nThe tile set that is used to render the tiles\n\ncolumns\n\nThe number of columns in the map\n\nrows\n\nThe number of rows in the map\n\ntileSize\n\nThe size of each tile in points\n\ntileGroupLayout\n\nAn array of tile groups to fill the tile map with.\n\nReturn Value\n\nA new tile map node.\n\nDiscussion\n\nThis initializer fills each tile with a texture defined by the final argument which is a row-major array of SKTileGroup objects. For example, for a 2 by 2 map node, a tileGroupLayout of [A, B, C, D] would place tile group A in the bottom left of the node and group D in the top right. The length of the tile group layout array should be the same as columns multiplied by rows.\n\nSee Also\nCreating a Tile Map\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, fillWith: SKTileGroup)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\nclass func tileMapNodes(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, from: GKNoiseMap, tileTypeNoiseMapThresholds: [NSNumber]) -> [SKTileMapNode]\nCreates a tile map node by allowing a GKNoiseMap to choose its tiles."
  },
  {
    "title": "initWithImageNamed: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520391-initwithimagenamed",
    "html": "Parameters\nname\n\nThe name of an image file stored in the app bundle.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThis method creates a new texture object from the image file and assigns that texture to the texture property, the normalTexture properties is set to nil. The size property of the sprite is set to the dimensions of the image. The color property is set to white with an alpha of zero (1.0,1.0,1.0,0.0).\n\nSee Also\nCreating a Sprite from an Image Filename\nGetting Started with Sprite Nodes\nLearn the basics about using images, also known as sprites, with SpriteKit.\n+ spriteNodeWithImageNamed:normalMapped:\nInitializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting."
  },
  {
    "title": "labelNodeWithAttributedText: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/2865817-labelnodewithattributedtext",
    "html": "Parameters\nattributedText\n\nThe attributed string from which to initialize the label.\n\nReturn Value\n\nA lable initialized from attributed text.\n\nDiscussion\n\nSee Also\nCreating a Label\n- initWithFontNamed:\nInitializes a new label object with a specified font.\n+ labelNodeWithFontNamed:\nInitializes a new label object.\n+ labelNodeWithText:\nInitializes a new label object with a text string."
  },
  {
    "title": "init(tileSet:columns:rows:tileSize:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643609-init",
    "html": "Parameters\ntileSet\n\nThe tile set that is used to render the tiles\n\ncolumns\n\nThe number of columns in the map\n\nrows\n\nThe number of rows in the map\n\ntileSize\n\nThe size of each tile in points\n\nReturn Value\n\nA new tile map node.\n\nDiscussion\n\nCreates an empty tile map.\n\nFor a grid set type, the overall size in points of the node will be numberOfColumns * tileSize.width wide and numberOfRows * tileSize.height high.\n\nSee Also\nCreating a Tile Map\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, fillWith: SKTileGroup)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, tileGroupLayout: [SKTileGroup])\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows. For a grid set type, the overall size, in points, of the node will be numberOfColumns * tileSize.widthwide andnumberOfRows * tileSize.height high.\nclass func tileMapNodes(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, from: GKNoiseMap, tileTypeNoiseMapThresholds: [NSNumber]) -> [SKTileMapNode]\nCreates a tile map node by allowing a GKNoiseMap to choose its tiles."
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749289-init",
    "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749286-init",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749287-init",
    "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
  },
  {
    "title": "enableAutomapping | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643604-enableautomapping",
    "html": "Discussion\n\nThis function is for use when you're creating a tile map programmatically, versus creating it ahead of time with the scene editor.\n\nSet this value to true when you want automapping behavior (equivalent to using the paint brush in the scene editor) when using the fill(with:), and setTileGroup(_:andTileDefinition:forColumn:row:) functions.\n\nSee Also\nDefining a Tile Map's Contents\nfunc fill(with: SKTileGroup?)\nWhen creating a tile map node programmatically, this function performs a fill operation with the specified tile group.\nfunc setTileGroup(SKTileGroup, andTileDefinition: SKTileDefinition, forColumn: Int, row: Int)\nSet the tile group and tile definition at the specified tile index.\nfunc setTileGroup(SKTileGroup?, forColumn: Int, row: Int)\nSet the tile group at the specified tile index."
  },
  {
    "title": "initWithTexture:color:size: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520029-initwithtexture",
    "html": "Parameters\ntexture\n\nA texture to apply to the sprite.\n\ncolor\n\nThe color for the new sprite.\n\nsize\n\nThe size for the new sprite.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nTo colorize your texture, you also need to set the colorBlendFactor property of the sprite.\n\nSee Also\nCreating a Sprite from a Texture\n- initWithTexture:\nInitializes a textured sprite using an existing texture object.\n+ spriteNodeWithColor:size:\nInitializes a single-color sprite.\n+ spriteNodeWithImageNamed:\nInitializes a textured sprite using an image file.\n+ spriteNodeWithTexture:\nInitializes a textured sprite using an existing texture object.\n+ spriteNodeWithTexture:size:\nInitializes a textured sprite using an existing texture object but with a specified size.\n+ spriteNodeWithTexture:normalMap:\nInitializes a textured sprite with a normal map to simulate 3D lighting.\ntexture\nThe texture used to draw the sprite.\nRelated Documentation\ncolorBlendFactor\nA floating-point value that describes how the color is blended with the sprite’s texture."
  },
  {
    "title": "spriteNodeWithTexture:size: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519812-spritenodewithtexture",
    "html": "Parameters\ntexture\n\nA SpriteKit texture.\n\nsize\n\nThe size of the sprite in points.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThe sprite is initialized using the texture, but the texture’s dimensions are not used. Instead, the size passed into the constructor method is used.\n\nSee Also\nCreating a Sprite from a Texture\n- initWithTexture:\nInitializes a textured sprite using an existing texture object.\n- initWithTexture:color:size:\nInitializes a textured sprite in color using an existing texture object.\n+ spriteNodeWithColor:size:\nInitializes a single-color sprite.\n+ spriteNodeWithImageNamed:\nInitializes a textured sprite using an image file.\n+ spriteNodeWithTexture:\nInitializes a textured sprite using an existing texture object.\n+ spriteNodeWithTexture:normalMap:\nInitializes a textured sprite with a normal map to simulate 3D lighting.\ntexture\nThe texture used to draw the sprite."
  },
  {
    "title": "spriteNodeWithImageNamed:normalMapped: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519721-spritenodewithimagenamed",
    "html": "Parameters\nname\n\nThe name of an image file stored in the app bundle.\n\ngenerateNormalMap\n\nIf YES, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If NO, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThe normal map is used only when lighting is enabled in the scene. For more information, see Lighting a Sprite and SKLightNode.\n\nSee Also\nCreating a Sprite from an Image Filename\nGetting Started with Sprite Nodes\nLearn the basics about using images, also known as sprites, with SpriteKit.\n- initWithImageNamed:\nInitializes a textured sprite using an image file."
  },
  {
    "title": "initWithTexture: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519942-initwithtexture",
    "html": "Parameters\ntexture\n\nA SpriteKit texture.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThe size property of the sprite is set to the dimensions of the texture. The color property is set to white with an alpha of zero (1.0,1.0,1.0,0.0).\n\nSee Also\nCreating a Sprite from a Texture\n- initWithTexture:color:size:\nInitializes a textured sprite in color using an existing texture object.\n+ spriteNodeWithColor:size:\nInitializes a single-color sprite.\n+ spriteNodeWithImageNamed:\nInitializes a textured sprite using an image file.\n+ spriteNodeWithTexture:\nInitializes a textured sprite using an existing texture object.\n+ spriteNodeWithTexture:size:\nInitializes a textured sprite using an existing texture object but with a specified size.\n+ spriteNodeWithTexture:normalMap:\nInitializes a textured sprite with a normal map to simulate 3D lighting.\ntexture\nThe texture used to draw the sprite."
  },
  {
    "title": "initWithFontNamed: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519917-initwithfontnamed",
    "html": "Parameters\nfontName\n\nThe name of the font used by the label.\n\nReturn Value\n\nAn initialized label object.\n\nSee Also\nCreating a Label\n+ labelNodeWithFontNamed:\nInitializes a new label object.\n+ labelNodeWithText:\nInitializes a new label object with a text string.\n+ labelNodeWithAttributedText:\nInitializes a new label object with an attributed text string.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "formIntersection(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592881-formintersection",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "isSuperset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749305-issuperset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "subtracting(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592913-subtracting",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "scaleToSize: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1645445-scaletosize",
    "html": "Discussion\n\nThis method works by setting the sprite node's xScale and yScale to achieve the specified size in its parent's coordinate space.\n\nSee Also\nSetting a Sprite's Size and Position\nUsing the Anchor Point to Move a Sprite\nLearn how the anchor point affects a sprite's position.\nsize\nThe dimensions of the sprite, in points.\nanchorPoint\nDefines the point in the sprite that corresponds to the node’s position."
  },
  {
    "title": "spriteNodeWithColor:size: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1579717-spritenodewithcolor",
    "html": "Parameters\ncolor\n\nThe color for the resulting sprite.\n\nsize\n\nThe size of the sprite in points.\n\nReturn Value\n\nA newly initialized sprite object.\n\nSee Also\nCreating a Sprite from a Texture\n- initWithTexture:\nInitializes a textured sprite using an existing texture object.\n- initWithTexture:color:size:\nInitializes a textured sprite in color using an existing texture object.\n+ spriteNodeWithImageNamed:\nInitializes a textured sprite using an image file.\n+ spriteNodeWithTexture:\nInitializes a textured sprite using an existing texture object.\n+ spriteNodeWithTexture:size:\nInitializes a textured sprite using an existing texture object but with a specified size.\n+ spriteNodeWithTexture:normalMap:\nInitializes a textured sprite with a normal map to simulate 3D lighting.\ntexture\nThe texture used to draw the sprite.\nRelated Documentation\n- initWithColor:size:\nInitializes a single-color sprite node."
  },
  {
    "title": "init(rawValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749291-init",
    "html": "Relationships\nFrom Protocol\nOptionSet\nRawRepresentable"
  },
  {
    "title": "rawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749307-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749281-contains",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "formIntersection(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749283-formintersection",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "formSymmetricDifference(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749284-formsymmetricdifference",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "formUnion(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749285-formunion",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "insert(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749292-insert",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "intersection(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749294-intersection",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "isStrictSuperset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749301-isstrictsuperset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "isSubset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749303-issubset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "update(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749324-update",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "symmetricDifference(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749321-symmetricdifference",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
  },
  {
    "title": "formSymmetricDifference(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592882-formsymmetricdifference",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592879-contains",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "formUnion(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592883-formunion",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "intersection(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592893-intersection",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "isStrictSuperset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592900-isstrictsuperset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "isStrictSubset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592898-isstrictsubset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "isDisjoint(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592895-isdisjoint",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "isSubset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592902-issubset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "isSuperset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592904-issuperset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "subtract(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592911-subtract",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "spriteNodeWithTexture:normalMap: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520153-spritenodewithtexture",
    "html": "Parameters\ntexture\n\nA SpriteKit texture used to draw the sprite.\n\nnormalMap\n\nA SpriteKit texture used to add lighting behavior to the sprite.\n\nReturn Value\n\nA newly initialized sprite object.\n\nSee Also\nCreating a Sprite from a Texture\n- initWithTexture:\nInitializes a textured sprite using an existing texture object.\n- initWithTexture:color:size:\nInitializes a textured sprite in color using an existing texture object.\n+ spriteNodeWithColor:size:\nInitializes a single-color sprite.\n+ spriteNodeWithImageNamed:\nInitializes a textured sprite using an image file.\n+ spriteNodeWithTexture:\nInitializes a textured sprite using an existing texture object.\n+ spriteNodeWithTexture:size:\nInitializes a textured sprite using an existing texture object but with a specified size.\ntexture\nThe texture used to draw the sprite."
  },
  {
    "title": "initWithCoder: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520399-initwithcoder",
    "html": "Discussion\n\nDon't call this function directly; the system calls this function when you should initialize your sprite from the argument archived data."
  },
  {
    "title": "tileMapNodes(tileSet:columns:rows:tileSize:from:tileTypeNoiseMapThresholds:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1640698-tilemapnodes",
    "html": "See Also\nCreating a Tile Map\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, fillWith: SKTileGroup)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, tileGroupLayout: [SKTileGroup])\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows. For a grid set type, the overall size, in points, of the node will be numberOfColumns * tileSize.widthwide andnumberOfRows * tileSize.height high."
  },
  {
    "title": "symmetricDifference(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592915-symmetricdifference",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
  },
  {
    "title": "isStrictSubset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749299-isstrictsubset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "isDisjoint(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749296-isdisjoint",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "remove(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749308-remove",
    "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "subtract(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749317-subtract",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "subtracting(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749319-subtracting",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "union(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions/3749322-union",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592886-init",
    "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592885-init",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592888-init",
    "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
  },
  {
    "title": "rawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592906-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "init(rawValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592890-init",
    "html": "Relationships\nFrom Protocol\nOptionSet\nRawRepresentable"
  },
  {
    "title": "insert(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592891-insert",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "remove(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592907-remove",
    "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "union(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592916-union",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "update(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options/3592918-update",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "setTileGroup(_:forColumn:row:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643605-settilegroup",
    "html": "Parameters\ntileGroup\n\nThe tile group to place in the map.\n\ncolumn\n\nThe column index of the tile.\n\nrow\n\nThe row index of the tile.\n\nDiscussion\n\nThis function is for use when you're creating a tile map programmatically, versus creating it ahead of time with the scene editor.\n\nWhen enableAutomapping is set to true, the surrounding tiles of a painted area will be controlled by the tile group, too. When automapping is disabled, just the tile definition will be placed without modify any of the neighboring tiles.\n\nSee Also\nDefining a Tile Map's Contents\nvar enableAutomapping: Bool\nWhen creating a tile map node programmatically, specifies whether the tile map uses automapping behavior like the scene editor.\nfunc fill(with: SKTileGroup?)\nWhen creating a tile map node programmatically, this function performs a fill operation with the specified tile group.\nfunc setTileGroup(SKTileGroup, andTileDefinition: SKTileDefinition, forColumn: Int, row: Int)\nSet the tile group and tile definition at the specified tile index."
  },
  {
    "title": "spriteNodeWithImageNamed: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1579718-spritenodewithimagenamed",
    "html": "Parameters\nname\n\nThe name of an image file stored in the app bundle.\n\nReturn Value\n\nA newly initialized sprite object.\n\nSee Also\nCreating a Sprite from a Texture\n- initWithTexture:\nInitializes a textured sprite using an existing texture object.\n- initWithTexture:color:size:\nInitializes a textured sprite in color using an existing texture object.\n+ spriteNodeWithColor:size:\nInitializes a single-color sprite.\n+ spriteNodeWithTexture:\nInitializes a textured sprite using an existing texture object.\n+ spriteNodeWithTexture:size:\nInitializes a textured sprite using an existing texture object but with a specified size.\n+ spriteNodeWithTexture:normalMap:\nInitializes a textured sprite with a normal map to simulate 3D lighting.\ntexture\nThe texture used to draw the sprite.\nRelated Documentation\n- initWithImageNamed:\nInitializes a textured sprite using an image file."
  },
  {
    "title": "labelNodeWithFontNamed: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1576448-labelnodewithfontnamed",
    "html": "Parameters\nfontName\n\nThe name of the font used by the label.\n\nReturn Value\n\nAn initialized label object.\n\nSee Also\nCreating a Label\n- initWithFontNamed:\nInitializes a new label object with a specified font.\n+ labelNodeWithText:\nInitializes a new label object with a text string.\n+ labelNodeWithAttributedText:\nInitializes a new label object with an attributed text string."
  },
  {
    "title": "changeObstruction(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1520346-changeobstruction",
    "html": "Parameters\nv\n\nThe amount to change the obstruction by, in decibels.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s obstruction animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.changeObstruction(by: -v, duration: sec)\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "changeOcclusion(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1520433-changeocclusion",
    "html": "Parameters\nv\n\nThe new value for the occlusion, in decibels.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s occlusion animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "changeObstruction(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1519718-changeobstruction",
    "html": "Parameters\nv\n\nThe new value for the obstruction, in decibels.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s obstruction animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "changeOcclusion(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1520117-changeocclusion",
    "html": "Parameters\nv\n\nThe amount to change the occlusion by, in decibels.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s occlusion animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.changeOcclusion(by: -v, duration: sec)\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "run(_:onChildWithName:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417671-run",
    "html": "Parameters\naction\n\nThe action to execute.\n\nname\n\nThe name of a child object. See the name property on the SKNode object.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nBecause this action references child nodes by name, it is especially handy for nodes that the scene subclass (or scene delegate) does not maintain a reference to, for example, child nodes that are defined in an .sks file.\n\nThis action has an instantaneous duration, although the action executed on the child may have a duration of its own. When the action executes, it looks up an appropriate child node and calls its run(_:) method, passing in the action to execute.\n\nThis action is reversible; it tells the child to execute the reverse of the action specified by the action parameter."
  },
  {
    "title": "Creating a Shape Node from an Array of Points | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/creating_a_shape_node_from_an_array_of_points",
    "html": "Overview\n\nAn SKShapeNode object can be initialized with an array of points describing a path. The init(splinePoints:count:) method can smoothly interpolate between these points to create a curve rather than the series of straight lines created by init(points:count:). The following code shows how to create two shape nodes using the same array of points for both initializers.\n\nvar points = [CGPoint(x: 0, y: 0),               \n              CGPoint(x: 100, y: 100),               \n              CGPoint(x: 200, y: -50),               \n              CGPoint(x: 300, y: 30),               \n              CGPoint(x: 400, y: 20)]         \nlet linearShapeNode = SKShapeNode(points: &points,                                   \n                                  count: points.count)          \nlet splineShapeNode = SKShapeNode(splinePoints: &points,                                   \n                                  count: points.count)\n\n\nThe following image shows linearShapeNode in blue and splineShapeNode in red.\n\nSee Also\nCreating a Shape from an Array of Points\ninit(points: UnsafeMutablePointer<CGPoint>, count: Int)\nCreates a shape node from a series of points.\ninit(splinePoints: UnsafeMutablePointer<CGPoint>, count: Int)\nCreates a shape node from a series of spline points."
  },
  {
    "title": "changeReverb(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1520320-changereverb",
    "html": "Parameters\nv\n\nThe new value for the reverb. The value should be between 0.0 and 1.0, inclusive.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "changeReverb(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1519568-changereverb",
    "html": "Parameters\nv\n\nThe amount to change the reverb by.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.changeReverb(by: -v, duration: sec)\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "SKInterpolationMode.spline | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skinterpolationmode/spline",
    "html": "Discussion\n\nGiven a sequence with the key values of [5, 1, 10, 0] and times of [0, 0.25, 0.5, 1], spline interpolation produces a set of values that follow a smooth curve.\n\nFigure 1 Playground graph generated by SKKeyframeSequence using spline interpolation"
  },
  {
    "title": "SKInterpolationMode.step | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skinterpolationmode/step",
    "html": "Discussion\n\nGiven a sequence with the key values of [5, 1, 10, 0] and times of [0, 0.25, 0.5, 1], step interpolation produces a set of values that follow a series of steps between each keyframe.\n\nFigure 1 Playground graph generated by SKKeyframeSequence using step interpolation"
  },
  {
    "title": "SKInterpolationMode.linear | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skinterpolationmode/linear",
    "html": "Discussion\n\nGiven a sequence with the key values of [5, 1, 10, 0] and times of [0, 0.25, 0.5, 1], linear interpolation produces a set of values that follow a series of straight lines between each keyframe.\n\nFigure 1 Playground graph generated by SKKeyframeSequence using linear interpolation"
  },
  {
    "title": "SKActionTimingMode.easeOut | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skactiontimingmode/easeout",
    "html": "Discussion\n\nBy creating two separate actions, a moveTo(x:duration:) and a moveTo(y:duration:), and setting the former to SKActionTimingMode.easeOut, you can visualize the effect of this timing mode by tracing the path of a circular shape node running the actions in a group:"
  },
  {
    "title": "SKActionTimingMode.easeIn | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skactiontimingmode/easein",
    "html": "Discussion\n\nBy creating two separate actions, a moveTo(x:duration:) and a moveTo(y:duration:), and setting the former to SKActionTimingMode.easeIn, you can visualize the effect of this timing mode by tracing the path of a circular shape node running the actions in a group:"
  },
  {
    "title": "SKActionTimingMode.easeInEaseOut | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skactiontimingmode/easeineaseout",
    "html": "Discussion\n\nBy creating two separate actions, a moveTo(x:duration:) and a moveTo(y:duration:), and setting the former to SKActionTimingMode.easeInEaseOut, you can visualize the effect of this timing mode by tracing the path of a circular shape node running the actions in a group:"
  },
  {
    "title": "SKNodeFocusBehavior.none | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknodefocusbehavior/none",
    "html": "Discussion\n\nThis behavior is the default for a node."
  },
  {
    "title": "miterLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520240-miterlimit",
    "html": "Discussion\n\nIf the line join style is set to CGLineJoin.miter, SpriteKit uses the miter limit to determine whether the lines should be joined with a bevel instead of a miter. SpriteKit divides the length of the miter by the line width. If the result is greater than the miter limit, SpriteKit converts the style to a bevel.\n\nSee Also\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn."
  },
  {
    "title": "lineJoin | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520358-linejoin",
    "html": "Discussion\n\nThe default value is CGLineJoin.bevel. See CGLineJoin.\n\nSee Also\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn."
  },
  {
    "title": "stereoPan(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1519976-stereopan",
    "html": "Parameters\nv\n\nThe new value for stereo panning. The value must between -1.0 (left channel only) and 1.0 (right channel only), inclusive.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "scale(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417712-scale",
    "html": "Parameters\nscale\n\nThe new value for the node’s x and y scale values.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s xScale and yScale properties are animated to the new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Scaling of a Node\nclass func scale(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node by a relative value.\nclass func scale(to: CGSize, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node to achieve\nclass func scaleX(by: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adds relative values to the x and y scale values of a node.\nclass func scaleX(to: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x scale value of a node to a new value.\nclass func scaleY(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the y scale value of a node to a new value."
  },
  {
    "title": "scaleX(by:y:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417796-scalex",
    "html": "Parameters\nxScale\n\nThe amount to add to the node’s x scale value.\n\nyScale\n\nThe amount to add to the node’s y scale value.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s xScale and yScale properties are animated to the new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)\n\nSee Also\nAnimating the Scaling of a Node\nclass func scale(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node by a relative value.\nclass func scale(to: CGSize, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node to achieve\nclass func scale(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(to: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x scale value of a node to a new value.\nclass func scaleY(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the y scale value of a node to a new value."
  },
  {
    "title": "scaleX(to:y:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417728-scalex",
    "html": "Parameters\nxScale\n\nThe new value for the node’s x scale value.\n\nyScale\n\nThe new value for the node’s y scale value.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s xScale and yScale properties are animated to the new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Scaling of a Node\nclass func scale(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node by a relative value.\nclass func scale(to: CGSize, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node to achieve\nclass func scale(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(by: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adds relative values to the x and y scale values of a node.\nclass func scaleX(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x scale value of a node to a new value.\nclass func scaleY(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the y scale value of a node to a new value."
  },
  {
    "title": "strokeTexture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519824-stroketexture",
    "html": "Discussion\n\nThe default value is nil. If a stroke texture is specified, the strokeColor property is ignored and the stroked portion of the shape node is rendered using the texture instead.\n\nSee Also\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn."
  },
  {
    "title": "scaleX(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417699-scalex",
    "html": "Parameters\nscale\n\nThe new value for the node’s x scale value.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s xScale property animates to the new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Scaling of a Node\nclass func scale(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node by a relative value.\nclass func scale(to: CGSize, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node to achieve\nclass func scale(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(by: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adds relative values to the x and y scale values of a node.\nclass func scaleX(to: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleY(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the y scale value of a node to a new value."
  },
  {
    "title": "scaleY(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417708-scaley",
    "html": "Parameters\nscale\n\nThe new value for the node’s y scale value.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s yScale property animates to the new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Scaling of a Node\nclass func scale(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node by a relative value.\nclass func scale(to: CGSize, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node to achieve\nclass func scale(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(by: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adds relative values to the x and y scale values of a node.\nclass func scaleX(to: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x scale value of a node to a new value."
  },
  {
    "title": "fillColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520154-fillcolor",
    "html": "Discussion\n\nThe default fill color is [SKColor clearColor], which means the shape is not filled.\n\nSee Also\nFilling a Shape\nvar fillTexture: SKTexture?\nThe texture used to fill the shape."
  },
  {
    "title": "fadeIn(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417818-fadein",
    "html": "Parameters\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s alpha property animates from its current value to 1.0.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.fadeOut(withDuration: sec)\n\nSee Also\nAnimating the Transparency of a Node\nclass func fadeOut(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 0.0.\nclass func fadeAlpha(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node by a relative value.\nclass func fadeAlpha(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node to a new value."
  },
  {
    "title": "init(rectOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520147-init",
    "html": "Parameters\nsize\n\nThe size of the rectangle.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating a Shape from a Rectangle\ninit(rect: CGRect)\nCreates a shape node with a rectangular path.\ninit(rect: CGRect, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners.\ninit(rectOf: CGSize, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners centered on the node’s position."
  },
  {
    "title": "fadeAlpha(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417716-fadealpha",
    "html": "Parameters\nfactor\n\nThe amount to add to the node’s alpha value.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s alpha property animates to its new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.fadeAlpha(by: -factor, duration: sec)\n\nSee Also\nAnimating the Transparency of a Node\nclass func fadeIn(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 1.0.\nclass func fadeOut(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 0.0.\nclass func fadeAlpha(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node to a new value."
  },
  {
    "title": "resize(byWidth:height:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417812-resize",
    "html": "Parameters\nwidth\n\nThe amount to add to the sprite’s width.\n\nheight\n\nThe amount to add to the sprite’s height.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by a SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.resize(byWidth: -width, height: -height, duration: sec)\n\nSee Also\nAnimating a Node's Texture\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "fadeAlpha(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417673-fadealpha",
    "html": "Parameters\nalpha\n\nThe new value of the node’s alpha.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s alpha property animates to its new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Transparency of a Node\nclass func fadeIn(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 1.0.\nclass func fadeOut(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 0.0.\nclass func fadeAlpha(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node by a relative value."
  },
  {
    "title": "resize(toWidth:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417686-resize",
    "html": "Parameters\nwidth\n\nThe new width of the sprite.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "resize(toWidth:height:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417724-resize",
    "html": "Parameters\nwidth\n\nThe new width of the sprite.\n\nheight\n\nThe new height of the sprite.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "setTexture(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417784-settexture",
    "html": "Parameters\ntexture\n\nThe new texture to use on the sprite.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property changes immediately to the new texture.\n\nThis action is not reversible; the reverse of this action does nothing.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "setTexture(_:resize:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417743-settexture",
    "html": "Parameters\ntexture\n\nThe new texture to use on the sprite.\n\nresize\n\nIf true, the sprite is resized to match the new texture. Otherwise, the size of the sprite is unchanged.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property changes immediately to the new texture and the sprite is resized to match.\n\nThis action is not reversible; the reverse of this action does nothing.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "animate(with:timePerFrame:resize:restore:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417656-animate",
    "html": "Parameters\ntextures\n\nAn array of textures to use when animating a sprite.\n\nsec\n\nThe amount of time, in seconds, that each texture is displayed.\n\nresize\n\nIf true, the sprite is resized to match each new texture. If false, the size of the sprite remains at a constant size.\n\nrestore\n\nIf true:\n\nWhen the action completes, the sprite’s texture is restored to the texture it had before the action completed. (If the resize parameter is true, the sprite is resized to match the size of the original texture.)\n\nIf false:\n\nWhen the action completes, the sprite’s texture remains set to the final texture in the array.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property animates through the array of textures. The sprite’s texture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.\n\nNote\n\nIf the restore parameter is true and this action is removed from a node before it completes, then node’s texture is still restored. This differs from the default behavior of removing an action.\n\nThis action is reversible; the resulting action animates through the same textures from last to first.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "animate(with:timePerFrame:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417828-animate",
    "html": "Parameters\ntextures\n\nAn array of textures to use when animating a sprite.\n\nsec\n\nThe duration, in seconds, that each texture is displayed.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property animates through the array of textures. The sprite’s texture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.\n\nThis action is reversible; the resulting action animates through the same textures from last to first.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "setNormalTexture(_:resize:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417654-setnormaltexture",
    "html": "Parameters\ntexture\n\nThe new texture to use on the sprite.\n\nresize\n\nIf true, the sprite is resized to match the new texture. Otherwise, the size of the sprite is unchanged.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s normalTexture property changes immediately to the new texture and the sprite is resized to match.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "animate(withNormalTextures:timePerFrame:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417746-animate",
    "html": "Parameters\ntextures\n\nAn array of textures to use.\n\nsec\n\nThe amount of time that each texture is displayed.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s normalTexture property animates through the array of textures. The sprite’s normalTexture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.\n\nThis action is reversible; the resulting action animates through the same textures from last to first.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "animate(withNormalTextures:timePerFrame:resize:restore:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417810-animate",
    "html": "Parameters\ntextures\n\nAn array of textures to use when animating a sprite.\n\nsec\n\nThe amount of time that each texture is displayed.\n\nresize\n\nIf true, the sprite is resized to match each new texture. If false, the size of the sprite remains at a constant size.\n\nrestore\n\nIf true:\n\nWhen the action completes, the sprite’s texture is restored to the texture it had before the action completed. (If the resize parameter is true, the sprite is resized to match the size of the original texture.)\n\nIf false:\n\nWhen the action completes, the sprite’s texture remains set to the final texture in the array.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s normalTexture property animates through the array of textures. The sprite’s normalTexture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.\n\nNote\n\nIf the restore parameter is true and this action is removed from a node before it completes, then node’s normal texture is still restored. This differs from the default behavior of removing an action.\n\nThis action is reversible; the resulting action animates through the same textures from last to first.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "colorize(with:colorBlendFactor:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417678-colorize",
    "html": "Parameters\ncolor\n\nThe new color for the sprite.\n\ncolorBlendFactor\n\nThe new blend factor for the sprite.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s color and colorBlendFactor properties are animated to their new values.\n\nThis action is not reversible; the reverse of this action does nothing.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "applyForce(_:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417782-applyforce",
    "html": "Parameters\nforce\n\nA vector that describes how much force is applied in each dimension. The force is measured in Newtons.\n\nsec\n\nThe duration over which the force is applied to the physics body.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the force is applied continuously to the physics body for the duration of the action. This action accelerates the body without imparting any angular acceleration to it.\n\nThis action is reversible; it applies an equal force in the opposite direction.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "applyTorque(_:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417756-applytorque",
    "html": "Parameters\ntorque\n\nThe amount of torque, in Newton-meters.\n\nsec\n\nThe duration over which the torque is applied to the physics body.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the torque is applied continuously to the physics body for the duration of the action. This action generates an angular acceleration on the body without causing any linear acceleration.\n\nThis action is reversible; it applies an equal torque in the opposite direction.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "applyForce(_:at:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417823-applyforce",
    "html": "Parameters\nforce\n\nA vector that describes how much force is applied in each dimension. The force is measured in Newtons.\n\npoint\n\nA point in scene coordinates that defines where the force is applied to the physics body.\n\nsec\n\nThe duration over which the force is applied to the physics body.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the force is applied continuously to the physics body for the duration of the action. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration.\n\nThis action is reversible; it applies an equal force in the opposite direction.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "colorize(withColorBlendFactor:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417736-colorize",
    "html": "Parameters\ncolorBlendFactor\n\nThe new blend factor for the sprite.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s colorBlendFactor property animates to the new value.\n\nThis action is not reversible; the reverse of this action does nothing.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor."
  },
  {
    "title": "applyImpulse(_:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417770-applyimpulse",
    "html": "Parameters\nimpulse\n\nA vector that describes how much momentum to impart to the body in each dimension over the duration of the action. The impulse is measured in Newton-seconds.\n\nsec\n\nThe duration over which the total impulse should be applied to the physics body.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body.\n\nThis action is reversible; it applies an equal impulse in the opposite direction.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "applyAngularImpulse(_:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417775-applyangularimpulse",
    "html": "Parameters\nimpulse\n\nThe total impulse to apply to the physics body. The impulse is measured in Newton-seconds.\n\nsec\n\nThe number of seconds over which to apply the impulse. For example, if you specify a duration of four seconds, one quarter of the impulse will be applied each second.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, applies a constant torque to the physics body for the duration of the action. The torque is calculated by dividing the impulse strength by the duration of the action. This action affects the body’s angular velocity without changing the body’s linear velocity.\n\nThis action is reversible; it applies an equal angular impulse in the opposite direction.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "applyImpulse(_:at:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417732-applyimpulse",
    "html": "Parameters\nimpulse\n\nThe total impulse to apply to the physics body. The impulse is measured in Newton-seconds.\n\npoint\n\nA point in scene coordinates that defines where the impulse was applied to the physics body.\n\nsec\n\nA new action object.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration.\n\nThis action is reversible; it applies an equal impulse in the opposite direction.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "changeCharge(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417752-changecharge",
    "html": "Parameters\nv\n\nThe new charge of the physics body.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the physics body’s charge property animates from its current value to its new value.\n\nThis action is not reversible.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "changeCharge(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417714-changecharge",
    "html": "Parameters\nv\n\nThe amount to add to the physics body’s charge.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the physics body’s charge property animates from its current value to its new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.changeCharge(by: -v, duration: sec)\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "strength(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417815-strength",
    "html": "Parameters\nstrength\n\nThe new strength for the field.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the field node’s strength property animates from its current value to its new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not do anything.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "shader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643596-shader",
    "html": "See Also\nWorking with Custom Shaders\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute."
  },
  {
    "title": "playSoundFileNamed(_:waitForCompletion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417664-playsoundfilenamed",
    "html": "Parameters\nsoundFile\n\nThe name of a sound file in the app’s bundle.\n\nwait\n\nIf true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nUse SKAction playSoundFileNamed:waitForCompletion: only for short incidentals. Use AVAudioPlayer for long running background music. This action is not reversible; the reversed action is identical to the original action.\n\nSee Also\nControlling the Audio of a Node\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "changePlaybackRate(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417808-changeplaybackrate",
    "html": "Parameters\nv\n\nThe new value for the playback rate. A playback rate of 1.0 represents normal speed.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "pause() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417820-pause",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nThis action may only be executed on an SKAudioNode object. The audio is paused, and if restarted, resumes at where it was paused.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "stop() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417794-stop",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nThis action may only be executed on an SKAudioNode object. The audio is stopped, and if restarted, begins at the beginning.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "changeVolume(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417682-changevolume",
    "html": "Parameters\nv\n\nThe new value for the volume. The value should be between 0.0 (silence) and 1.0 (maximum value for source audio), inclusive.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s volume animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "changePlaybackRate(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417670-changeplaybackrate",
    "html": "Parameters\nv\n\nThe amount to change the playback rate by. A playback rate of 1.0 represents normal speed.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.changePlaybackRate(by: -v, duration: sec)\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "tileDefinition(atColumn:row:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643602-tiledefinition",
    "html": "Parameters\ncolumn\n\nThe column index of the tile.\n\nrow\n\nThe row index of the tile.\n\nReturn Value\n\nThe tile definition for the tile at the specified column and row.\n\nSee Also\nQuerying the Tile Map's Properties\nfunc centerOfTile(atColumn: Int, row: Int) -> CGPoint\nfunc tileColumnIndex(fromPosition: CGPoint) -> Int\nfunc tileGroup(atColumn: Int, row: Int) -> SKTileGroup?\nfunc tileRowIndex(fromPosition: CGPoint) -> Int\nReturns the tile map node object’s tile row index for the specified position in points.\nvar mapSize: CGSize\nThe overall size of the tile map."
  },
  {
    "title": "setValue(_:forAttribute:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/2715855-setvalue",
    "html": "Parameters\nvalue\n\nAn attribute value object containing the scalar or vector value to set in the attached shader.\n\nkey\n\nThe attribute name.\n\nSee Also\nCustomizing Stroking or Fill Drawing\nControlling Shape Drawing with Shaders\nChange a shape node's appearance by supplying custom shader code.\nvar strokeShader: SKShader?\nA custom shader used to determine the color of the stroked portion of the shape node.\nvar fillShader: SKShader?\nA custom shader used to determine the color of the filled portion of the shape node.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute."
  },
  {
    "title": "value(forAttributeNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/2715843-value",
    "html": "Parameters\nkey\n\nThe attribute name.\n\nReturn Value\n\nAn attribute value object containing the scalar or vector value or nil if no such attribute exists.\n\nSee Also\nCustomizing Stroking or Fill Drawing\nControlling Shape Drawing with Shaders\nChange a shape node's appearance by supplying custom shader code.\nvar strokeShader: SKShader?\nA custom shader used to determine the color of the stroked portion of the shape node.\nvar fillShader: SKShader?\nA custom shader used to determine the color of the filled portion of the shape node.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader."
  },
  {
    "title": "fillShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519629-fillshader",
    "html": "Discussion\n\nThe default value is nil. If a fillShader is specified, when the shape node is drawn, the shader is used to determine the output colors for any part of the shape node that's fillled. SpriteKit implements many fill features using a default shader, such as:\n\nFill color.\n\nAnimations on alpha.\n\nLight cast by SKLightNode.\n\nIf you supply a custom value for fillShader, your custom shader overrides the default shader which neutralizes the default features. It is the responsibility of your custom fillShader to implement any of the features your shape requires.\n\nSee Also\nCustomizing Stroking or Fill Drawing\nControlling Shape Drawing with Shaders\nChange a shape node's appearance by supplying custom shader code.\nvar strokeShader: SKShader?\nA custom shader used to determine the color of the stroked portion of the shape node.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute."
  },
  {
    "title": "Controlling Shape Drawing with Shaders | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/controlling_shape_drawing_with_shaders",
    "html": "Overview\n\nWhen you want to go beyond the effects provided by a shape node's properties, you can take full control of its stroking or filling by using the strokeShader and fillShader properties, respectively. To do that, you supply custom OpenGL ES shader code embedded within a SKShader object. Custom shaders allow you to create custom effects, such as dashed lines and gradient strokes, and custom fills, such as checkerboards and random patterns.\n\nCustomize a Shape Node's Stroke\n\nShape nodes have two additional stroke-related properties that extend the properties defined by SKShader:\n\nSymbol declaration\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nfloat u_path_length;\n\n\t\n\nUniform\n\n\t\n\nThe total length of the path, in points.\n\n\n\n\nfloat v_path_distance;\n\n\t\n\nVarying\n\n\t\n\nThe distance along the path, in points.\n\nBy dividing the distance along the path by the total length of the path, you get the normalized position (between 0 and 1) of each point along a shape node's path and use it to construct the color of each pixel along the shape node's stroke. The following code shows how you create a custom shader to do this:\n\nlet gradientShader = SKShader(source: \"void main() {\" +\n    \"float normalisedPosition = v_path_distance / u_path_length;\" +\n    \"gl_FragColor = vec4(normalisedPosition, normalisedPosition, 0.0, 1.0);\" +\n    \"}\")\nlet squareShapeNode = SKShapeNode(rectOf: CGSize(width: 610, height: 200),\n                                  cornerRadius: 25)\nsquareShapeNode.fillColor = .clear\nsquareShapeNode.lineWidth = 20\nsquareShapeNode.strokeShader = gradientShader\n\n\nThe generated shape node looks like this:\n\nAlternatively, by casting both symbols to integers and using the modulo operator, you get the same shape node with a shader that generates a dashed line, as shown in the following code:\n\nlet dashedShader = SKShader(source: \"void main() {\" +\n    \"int stripe = int(u_path_length) / 150;\" +\n    \"int h = int(v_path_distance) / stripe % 2;\" +\n    \"gl_FragColor = float4(h);\" +\n    \"}\")\n\n\nThe generated shape node looks like this:\n\nCustomize a Shape Node's Fill\n\nYou create a custom fill for a shape node by writing shader code and embedding it within an SKShader object. Assigning the shader to the fillShader property overrides the appearance that would otherwise be defined by fillColor and fillTexture.\n\nThe following shader code demonstrates filling a shape node with a simple checkerboard texture. Inside the shader, the variables h and v would, on their own, form horizontal and vertical stripes. The exclusive or operator, ^, creates the checkerboard pattern from those stripes.\n\nlet checkerboardShader = SKShader(source: \"void main() {\" +\n    \"int size = 20;\" +\n    \"int h = int(v_tex_coord.x * u_texture_size.x) / size % 2;\" +\n    \"int v = int(v_tex_coord.y * u_texture_size.y) / size % 2;\" +\n    \"gl_FragColor = float4(v ^ h, v ^ h, v ^ h, 1.0);\" +\n    \"}\")\n   \nlet size = CGSize(width: 610, height: 200)\n   \ncheckerboardShader.uniforms = [\n    SKUniform(name: \"u_texture_size\",\n              vectorFloat2: vector_float2(Float(size.width), Float(size.height)))\n]\n   \nlet squareShapeNode = SKShapeNode(rectOf: size,\n                                  cornerRadius: 25)\nsquareShapeNode.fillShader = checkerboardShader\n\n\nThe generated shape node looks like this:\n\nSee Also\nCustomizing Stroking or Fill Drawing\nvar strokeShader: SKShader?\nA custom shader used to determine the color of the stroked portion of the shape node.\nvar fillShader: SKShader?\nA custom shader used to determine the color of the filled portion of the shape node.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute."
  },
  {
    "title": "strokeShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519784-strokeshader",
    "html": "Discussion\n\nThe default value is nil. If a strokeShader is specified, when the shape node is drawn, the shader is used to determine the output colors for any part of the shape node that's stroked. SpriteKit implements many stroke features using a default shader, such as:\n\nlineCap\n\nglowWidth\n\nstrokeColor\n\nIf you supply a custom value for strokeShader, your custom shader overrides the default shader which neutralizes the default features. It is the responsibility of your custom strokeShader to implement any of the features your shape requires.\n\nSee Also\nCustomizing Stroking or Fill Drawing\nControlling Shape Drawing with Shaders\nChange a shape node's appearance by supplying custom shader code.\nvar fillShader: SKShader?\nA custom shader used to determine the color of the filled portion of the shape node.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute."
  },
  {
    "title": "blendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520045-blendmode",
    "html": "Discussion\n\nThe default value is SKBlendMode.alpha."
  },
  {
    "title": "lineLength | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520398-linelength",
    "html": "Discussion\n\nThis property takes effect only when the shape has a stroke. The valid range is between [0.1] where one indicates that the shape is fully stroked, and zero indicates that the shape is not stroked at all. By interpolating this value over time (for example, in your scene's update(_:) callback), you can animate the shape as if it were drawn in real time."
  },
  {
    "title": "isAntialiased | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519719-isantialiased",
    "html": "Discussion\n\nThe default value is true.\n\nSee Also\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style."
  },
  {
    "title": "lineCap | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520360-linecap",
    "html": "Discussion\n\nThe default value is CGLineCap.butt. See CGLineCap.\n\nSee Also\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn."
  },
  {
    "title": "strokeColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519748-strokecolor",
    "html": "Discussion\n\nThe default stroke color is [SKColor whiteColor]. If you do not want to stroke the shape, use [SKColor clearColor].\n\nSee Also\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn."
  },
  {
    "title": "lineWidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519885-linewidth",
    "html": "Discussion\n\nA line width larger than 2.0 may cause rendering artifacts in the final rendered image. The default value is 1.0.\n\nSee Also\nStroking a Shape\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn."
  },
  {
    "title": "init(points:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520120-init",
    "html": "Parameters\npoints\n\nAn array of Core Graphics points. The points are relative to the node’s origin.\n\nnumPoints\n\nThe number of points in the array.\n\nReturn Value\n\nA new shape node. The node is created with a path that starts at the first point in the array, joining each adjacent pair of points with a line segment.\n\nSee Also\nCreating a Shape from an Array of Points\nCreating a Shape Node from an Array of Points\nCreate jagged or smooth shapes from the same array of points.\ninit(splinePoints: UnsafeMutablePointer<CGPoint>, count: Int)\nCreates a shape node from a series of spline points."
  },
  {
    "title": "glowWidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520116-glowwidth",
    "html": "Discussion\n\nThe default value is 0.0, which means no glow is added. The glow color is determined by strokeColor.\n\nSee Also\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn."
  },
  {
    "title": "init(splinePoints:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520140-init",
    "html": "Parameters\npoints\n\nAn array of Core Graphics points.\n\nnumPoints\n\nThe number of points in the array.\n\nReturn Value\n\nA new shape node is created. The node is created with a path that starts at the first point in the array, joining each pair of points with a quadratic curve. The control points are calculated automatically based on previous points in the array.\n\nSee Also\nCreating a Shape from an Array of Points\nCreating a Shape Node from an Array of Points\nCreate jagged or smooth shapes from the same array of points.\ninit(points: UnsafeMutablePointer<CGPoint>, count: Int)\nCreates a shape node from a series of points."
  },
  {
    "title": "fillTexture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519956-filltexture",
    "html": "Discussion\n\nThe default value is nil. If a fill texture is specified, the shape node is rendered using that texture blended with the fillColor.\n\nImportant\n\nThe default fill color of a SKShapeNode is SKColor.clear. Since the fill texture is blended with the fill color, fillColor needs to be set to a non-clear color for it to display. For example, to display the texture without any color blend effects, set fillColor to SKColor.white.\n\nSee Also\nFilling a Shape\nvar fillColor: UIColor\nThe color used to fill the shape."
  },
  {
    "title": "init(ellipseIn:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520412-init",
    "html": "Parameters\nrect\n\nA rectangle, relative to the node’s origin.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating an Ellipse Shape\ninit(ellipseOf: CGSize)\nCreates a shape node with an elliptical path centered on the node’s origin."
  },
  {
    "title": "init(ellipseOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519980-init",
    "html": "Parameters\nsize\n\nThe height and width of the ellipse.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating an Ellipse Shape\ninit(ellipseIn: CGRect)\nCreates a shape node with an elliptical path that fills the specified rectangle."
  },
  {
    "title": "init(rectOf:cornerRadius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519712-init",
    "html": "Parameters\nsize\n\nThe size of the rectangle.\n\ncornerRadius\n\nThe radius of the rounded corners. The radius should not be a negative number. The value should be no larger than half of the rectangle’s width or height, whichever is smaller.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating a Shape from a Rectangle\ninit(rect: CGRect)\nCreates a shape node with a rectangular path.\ninit(rectOf: CGSize)\nCreates a shape node with a rectangular path centered on the node’s origin.\ninit(rect: CGRect, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners."
  },
  {
    "title": "init(rect:cornerRadius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519769-init",
    "html": "Parameters\nrect\n\nA rectangle, relative to the node’s origin.\n\ncornerRadius\n\nThe radius of the rounded corners. The radius should not be a negative number. The value should be no larger than half of the rectangle’s width or height, whichever is smaller.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating a Shape from a Rectangle\ninit(rect: CGRect)\nCreates a shape node with a rectangular path.\ninit(rectOf: CGSize)\nCreates a shape node with a rectangular path centered on the node’s origin.\ninit(rectOf: CGSize, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners centered on the node’s position."
  },
  {
    "title": "stereoPan(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1519713-stereopan",
    "html": "Parameters\nv\n\nThe amount to change the stereo panning by.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.stereoPan(by: -v, duration: sec)\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value."
  },
  {
    "title": "rotate(toAngle:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417668-rotate",
    "html": "Parameters\nradians\n\nThe angle to rotate the node to, in radians.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s zRotation property is interpolated to the new angle.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Rotation of a Node\nclass func rotate(byAngle: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that rotates the node by a relative value.\nclass func rotate(toAngle: CGFloat, duration: TimeInterval, shortestUnitArc: Bool) -> SKAction\nCreates an action that rotates the node to an absolute value."
  },
  {
    "title": "removeFromParent() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417748-removefromparent",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node is immediately removed from its parent.\n\nThis action is not reversible; the reverse of this action is the same action."
  },
  {
    "title": "speed(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417684-speed",
    "html": "Parameters\nspeed\n\nThe new value for the node’s speed.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s speed property animates to the new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nControlling the Action's Speed\nclass func speed(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes how fast the node executes actions by a relative value."
  },
  {
    "title": "scale(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417741-scale",
    "html": "Parameters\nscale\n\nThe amount to add to the node’s x and y scale values.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s xScale and yScale properties are animated to the new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.scale(by: -scale, duration: sec)\n\nSee Also\nAnimating the Scaling of a Node\nclass func scale(to: CGSize, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node to achieve\nclass func scale(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(by: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adds relative values to the x and y scale values of a node.\nclass func scaleX(to: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x scale value of a node to a new value.\nclass func scaleY(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the y scale value of a node to a new value."
  },
  {
    "title": "speed(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417690-speed",
    "html": "Parameters\nspeed\n\nThe amount to add to the node’s speed.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s speed property animates to the new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.speed(by: -speed, duration: sec)\n\nSee Also\nControlling the Action's Speed\nclass func speed(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes how fast the node executes actions."
  },
  {
    "title": "scale(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1643619-scale",
    "html": "Parameters\nsize\n\nThe new size of the node.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s xScale and yScale properties are animated to achieve the specified size in its parent's coordinate space.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Scaling of a Node\nclass func scale(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node by a relative value.\nclass func scale(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(by: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adds relative values to the x and y scale values of a node.\nclass func scaleX(to: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x scale value of a node to a new value.\nclass func scaleY(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the y scale value of a node to a new value."
  },
  {
    "title": "rotate(byAngle:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417805-rotate",
    "html": "Parameters\nradians\n\nThe amount to rotate the node, in radians.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s zRotation property animates to the new angle.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.rotate(byAngle: -radians, duration: sec)\n\nSee Also\nAnimating the Rotation of a Node\nclass func rotate(toAngle: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that rotates the node counterclockwise to an absolute angle.\nclass func rotate(toAngle: CGFloat, duration: TimeInterval, shortestUnitArc: Bool) -> SKAction\nCreates an action that rotates the node to an absolute value."
  },
  {
    "title": "init(ciFilter:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395895-init",
    "html": "Parameters\nfilter\n\nA Core Image filter.\n\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nDiscussion\n\nThe filter used to perform the transition must a be filter that requires only two image parameters (inputImage, inputTargetImage) and generates a single image (outputImage). The transition automatically sets the filter’s inputImage, inputTargetImage, and inputTime properties. You must set up any other filter properties before creating the transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it."
  },
  {
    "title": "rotate(toAngle:duration:shortestUnitArc:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417700-rotate",
    "html": "Parameters\nradians\n\nThe angle to rotate the node to, in radians.\n\nsec\n\nThe duration of the animation.\n\nshortestUnitArc\n\nIf true, the rotation is performed in whichever direction results in the smallest rotation. If false, the rotation is interpolated.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s zRotation property is animated to the new angle.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating the Rotation of a Node\nclass func rotate(byAngle: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that rotates the node by a relative value.\nclass func rotate(toAngle: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that rotates the node counterclockwise to an absolute angle."
  },
  {
    "title": "init(rect:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520047-init",
    "html": "Parameters\nrect\n\nA rectangle, relative to the node’s origin.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating a Shape from a Rectangle\ninit(rectOf: CGSize)\nCreates a shape node with a rectangular path centered on the node’s origin.\ninit(rect: CGRect, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners.\ninit(rectOf: CGSize, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners centered on the node’s position."
  },
  {
    "title": "resize(toHeight:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417825-resize",
    "html": "Parameters\nheight\n\nThe new height of the sprite.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "setNormalTexture(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417706-setnormaltexture",
    "html": "Parameters\ntexture\n\nThe new texture to use on the sprite.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nOnly an SKSpriteNode object can execute this action. When the action executes, the sprite’s normalTexture property changes immediately to the new texture.\n\nThis action is not reversible; the reverse of this action does nothing.\n\nSee Also\nAnimating a Node's Texture\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor."
  },
  {
    "title": "SKRepeatMode.loop | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrepeatmode/loop",
    "html": "Discussion\n\nGiven a sequence with the key values of [5, 1, 10] and times of [0, 0.25, 0.5], loop repeat mode produces a set of values that repeats the previous keyframes when the sample time is 0.5:\n\nFigure 1 Playground graph generated by SKKeyframeSequence using loop repeat mode"
  },
  {
    "title": "SKRepeatMode.clamp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrepeatmode/clamp",
    "html": "Discussion\n\nGiven a sequence with the key values of [5, 1, 10] and times of [0, 0.25, 0.5], clamp repeat mode produces a set of values that follow straight line when the sample time is greater or equal to 0.5:\n\nFigure 1 Playground graph generated by SKKeyframeSequence using clamp repeat mode"
  },
  {
    "title": "attributeValues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/2715851-attributevalues",
    "html": "Discussion\n\nAll nodes have their own copy of an attribute value and therefore the attribute values can be different per-node across the same SKShader. If instead you need all nodes to share the same value, use SKUniform. Uniforms can change values every frame, but uniforms cannot vary per-node like attributes can.\n\nSee Also\nWorking with Custom Shaders\nvar shader: SKShader?\nDefines a shader which is applied to each tile of the tile map.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute."
  },
  {
    "title": "distance(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519688-distance",
    "html": "Parameters\nrange\n\nThe range of allowed distances between the node and the point.\n\npoint\n\nA point in the coordinate system of the node’s parent that is used to calculate the distance.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time when constraints are applied, a line is projected between the node’s position and the target point. The distance between the two points is calculated, and if it lies outside the specified range, the node is pushed or pulled along this line until it lies within the range.\n\nSee Also\nCreating Distance Constraints\nclass func distance(SKRange, to: SKNode) -> Self\nCreates a constraint that keeps a node within a certain distance of another node.\nclass func distance(SKRange, to: CGPoint, in: SKNode) -> Self\nCreates a constraint that keeps a node within a certain distance of a point in another node’s coordinate system.\nRelated Documentation\nvar referenceNode: SKNode?\nThe node whose coordinate system should be used to apply the constraint."
  },
  {
    "title": "didApplyConstraints(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenedelegate/1520375-didapplyconstraints",
    "html": "Parameters\nscene\n\nThe scene that is being animated.\n\nDiscussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. It is called after any enabled constraints in the scene have been applied.\n\nAny additional actions applied are not evaluated until the next update.\n\nAny changes to physics bodies is not simulated until the next update.\n\nAny changes to constraints will not be applied until the next update.\n\nSee Also\nHandling Animation Events\nUse SpriteKit Objects within Scene Delegate Callbacks\nFollow threading guidelines to keep your SpriteKit app thread safe.\nfunc update(TimeInterval, for: SKScene)\nTells you to perform any app specific logic to update your scene.\nfunc didEvaluateActions(for: SKScene)\nTells you to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics(for: SKScene)\nTells you to peform any necessary logic after physics simulations are performed.\nfunc didFinishUpdate(for: SKScene)\nTells you to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "didFinishUpdate(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenedelegate/1519814-didfinishupdate",
    "html": "Parameters\nscene\n\nThe scene that is being animated.\n\nDiscussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. It is called after all update logic has been completed and before the scene is rendered.\n\nAny additional actions applied are not evaluated until the next update.\n\nAny changes to physics bodies are not simulated until the next update.\n\nAny changes to constraints will not be applied until the next update.\n\nNo further update logic will be applied to the scene after this call. Any values set on nodes here will be used when the scene is rendered for the current frame.\n\nSee Also\nHandling Animation Events\nUse SpriteKit Objects within Scene Delegate Callbacks\nFollow threading guidelines to keep your SpriteKit app thread safe.\nfunc update(TimeInterval, for: SKScene)\nTells you to perform any app specific logic to update your scene.\nfunc didEvaluateActions(for: SKScene)\nTells you to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics(for: SKScene)\nTells you to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints(for: SKScene)\nTells you to peform any necessary logic after constraints are applied."
  },
  {
    "title": "view(_:shouldRenderAtTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skviewdelegate/1642775-view",
    "html": "Parameters\nview\n\nThe SKView.\n\ntime\n\nThe target time.\n\nReturn Value\n\nReturn true to initiate an update and render for the target time. Return false to skip the update and render for the target time."
  },
  {
    "title": "value(forAttributeNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/2715847-value",
    "html": "Parameters\nkey\n\nThe attribute name.\n\nReturn Value\n\nAn attribute value object containing the scalar or vector value or nil if no such attribute exists.\n\nSee Also\nWorking with Custom Shaders\nvar shader: SKShader?\nDefines a shader which is applied to each tile of the tile map.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader."
  },
  {
    "title": "maskNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skcropnode/1520449-masknode",
    "html": "Discussion\n\nThe node supplied to the crop node must not be a child of another node; however, it may have children of its own.\n\nWhen the crop node’s contents are rendered, the crop node first draws its mask into a private buffer. Then, it renders its children. When rendering its children, each pixel is verified against the corresponding pixel in the mask. If the pixel in the mask has an alpha value of less than 0.05, the image pixel is masked out. Any pixel not rendered by the mask node is automatically masked out.\n\nThe default value of this property is nil, which indicates that the child nodes should not be cropped.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643601-color",
    "html": "See Also\nTinting a Tile Map\nvar colorBlendFactor: CGFloat\nControls the blending between the texture and the tile map object’s color. Values are clamped between zero and one where zero has no color blending and one has the maximum color blending."
  },
  {
    "title": "setValue(_:forAttribute:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/2715852-setvalue",
    "html": "Parameters\nvalue\n\nAn attribute value object containing the scalar or vector value to set in the attached shader.\n\nkey\n\nThe attribute name.\n\nSee Also\nWorking with Custom Shaders\nvar shader: SKShader?\nDefines a shader which is applied to each tile of the tile map.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute."
  },
  {
    "title": "mapSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643595-mapsize",
    "html": "Discussion\n\nFor a grid set type, the overall size, in points, of the node will be numberOfColumns * tileSize.width wide and numberOfRows * tileSize.height high.\n\nSee Also\nQuerying the Tile Map's Properties\nfunc centerOfTile(atColumn: Int, row: Int) -> CGPoint\nfunc tileColumnIndex(fromPosition: CGPoint) -> Int\nfunc tileDefinition(atColumn: Int, row: Int) -> SKTileDefinition?\nfunc tileGroup(atColumn: Int, row: Int) -> SKTileGroup?\nfunc tileRowIndex(fromPosition: CGPoint) -> Int\nReturns the tile map node object’s tile row index for the specified position in points."
  },
  {
    "title": "lightingBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643618-lightingbitmask",
    "html": "Discussion\n\nTo determine whether this sprite is lit by a light node, the sprite’s lightingBitMask property is tested against the light’s categoryBitMask property by performing a logical AND operation. If the comparison results in a nonzero value, the sprite is lit by this light.\n\nThe default value is 0x00000000 (all bits cleared)."
  },
  {
    "title": "colorBlendFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643607-colorblendfactor",
    "html": "See Also\nTinting a Tile Map\nvar color: UIColor\nThe base color for the tile map. The influence of the color over the tile map node’s textures is controlled by colorBlendFactor."
  },
  {
    "title": "tileRowIndex(fromPosition:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643614-tilerowindex",
    "html": "Parameters\nposition\n\nThe position in the tile map to check.\n\nReturn Value\n\nThe tile map node object’s tile row index for the specified position.\n\nSee Also\nQuerying the Tile Map's Properties\nfunc centerOfTile(atColumn: Int, row: Int) -> CGPoint\nfunc tileColumnIndex(fromPosition: CGPoint) -> Int\nfunc tileDefinition(atColumn: Int, row: Int) -> SKTileDefinition?\nfunc tileGroup(atColumn: Int, row: Int) -> SKTileGroup?\nvar mapSize: CGSize\nThe overall size of the tile map."
  },
  {
    "title": "setTileGroup(_:andTileDefinition:forColumn:row:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1690935-settilegroup",
    "html": "Parameters\ntileGroup\n\nThe tile group to place in the map.\n\ntileDefinition\n\nThe tile definition to place in the map.\n\ncolumn\n\nThe column index of the tile.\n\nrow\n\nThe row index of the tile.\n\nDiscussion\n\nThis function is for use when you're creating a tile map programmatically, versus creating it ahead of time with the scene editor.\n\nWhen enableAutomapping is set to true, the surrounding tiles of a painted area will be controlled by the tile group, too. When automapping is disabled, just the tile definition will be placed without modify any of the neighboring tiles.\n\nSee Also\nDefining a Tile Map's Contents\nvar enableAutomapping: Bool\nWhen creating a tile map node programmatically, specifies whether the tile map uses automapping behavior like the scene editor.\nfunc fill(with: SKTileGroup?)\nWhen creating a tile map node programmatically, this function performs a fill operation with the specified tile group.\nfunc setTileGroup(SKTileGroup?, forColumn: Int, row: Int)\nSet the tile group at the specified tile index."
  },
  {
    "title": "fill(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643615-fill",
    "html": "Parameters\ntileGroup\n\nThe tile group that will be used to fill the map.\n\nDiscussion\n\nThis function is for use when you're creating a tile map programmatically, versus creating it ahead of time with the scene editor.\n\nSee Also\nDefining a Tile Map's Contents\nvar enableAutomapping: Bool\nWhen creating a tile map node programmatically, specifies whether the tile map uses automapping behavior like the scene editor.\nfunc setTileGroup(SKTileGroup, andTileDefinition: SKTileDefinition, forColumn: Int, row: Int)\nSet the tile group and tile definition at the specified tile index.\nfunc setTileGroup(SKTileGroup?, forColumn: Int, row: Int)\nSet the tile group at the specified tile index."
  },
  {
    "title": "tileGroup(atColumn:row:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643613-tilegroup",
    "html": "Parameters\ncolumn\n\nThe column index of the tile.\n\nrow\n\nThe row index of the tile.\n\nReturn Value\n\nThe tile group for the tile at the specified column and row.\n\nSee Also\nQuerying the Tile Map's Properties\nfunc centerOfTile(atColumn: Int, row: Int) -> CGPoint\nfunc tileColumnIndex(fromPosition: CGPoint) -> Int\nfunc tileDefinition(atColumn: Int, row: Int) -> SKTileDefinition?\nfunc tileRowIndex(fromPosition: CGPoint) -> Int\nReturns the tile map node object’s tile row index for the specified position in points.\nvar mapSize: CGSize\nThe overall size of the tile map."
  },
  {
    "title": "tileColumnIndex(fromPosition:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643617-tilecolumnindex",
    "html": "Parameters\nposition\n\nThe position in the tile map to check.\n\nReturn Value\n\nThe tile map node object’s tile column index for the specified position.\n\nSee Also\nQuerying the Tile Map's Properties\nfunc centerOfTile(atColumn: Int, row: Int) -> CGPoint\nfunc tileDefinition(atColumn: Int, row: Int) -> SKTileDefinition?\nfunc tileGroup(atColumn: Int, row: Int) -> SKTileGroup?\nfunc tileRowIndex(fromPosition: CGPoint) -> Int\nReturns the tile map node object’s tile row index for the specified position in points.\nvar mapSize: CGSize\nThe overall size of the tile map."
  },
  {
    "title": "centerOfTile(atColumn:row:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643599-centeroftile",
    "html": "Parameters\ncolumn\n\nThe column index of the tile.\n\nrow\n\nThe row index of the tile.\n\nReturn Value\n\nThe coordinates in points of the center of the tile for a given column and row.\n\nSee Also\nQuerying the Tile Map's Properties\nfunc tileColumnIndex(fromPosition: CGPoint) -> Int\nfunc tileDefinition(atColumn: Int, row: Int) -> SKTileDefinition?\nfunc tileGroup(atColumn: Int, row: Int) -> SKTileGroup?\nfunc tileRowIndex(fromPosition: CGPoint) -> Int\nReturns the tile map node object’s tile row index for the specified position in points.\nvar mapSize: CGSize\nThe overall size of the tile map."
  },
  {
    "title": "numberOfRows | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643611-numberofrows",
    "html": "See Also\nReading or Manually Configuring the Tile Map's Size\nvar tileSize: CGSize\nThe size of each tile in points.\nvar tileSet: SKTileSet\nThe tile set being used by this tile map. The tile map object can only display tiles that exist in this set.\nvar numberOfColumns: Int\nThe number of columns in the tile map"
  },
  {
    "title": "animate(withWarps:times:restore:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1690936-animate",
    "html": "Parameters\nwarps\n\nThe sequence of warps to apply to the node.\n\ntimes\n\nThe times at which each warp distortion in the sequence should complete.\n\nrestore\n\nA Boolean specifying whether to restore the original node's warpGeometry from before the action.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThe numberOfColumns and numberOfRows in each geometry in the sequence should match.\n\nSee Also\nAnimate the Warping of a Node\nclass func animate(withWarps: [SKWarpGeometry], times: [NSNumber]) -> SKAction?\nCreates an action to distort a node through a sequence of SKWarpGeometry objects.\nclass func warp(to: SKWarpGeometry, duration: TimeInterval) -> SKAction?\nCreates an action to distort a node based using an SKWarpGeometry object.\nRelated Documentation\nclass SKWarpGeometryGrid\nA definition for a grid-based deformation of nodes that conform to ."
  },
  {
    "title": "strength(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417762-strength",
    "html": "Parameters\nstrength\n\nThe value to add to the field.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the field node’s strength property animates from its current value to its new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.strength(by: -strength, duration: sec)\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "falloff(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417766-falloff",
    "html": "Parameters\nfalloff\n\nThe value to add to the falloff.\n\nsec\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the field node’s falloff property animates from its current value to its new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.falloff(by: -falloff, duration: sec)\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff."
  },
  {
    "title": "numberOfColumns | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643600-numberofcolumns",
    "html": "See Also\nReading or Manually Configuring the Tile Map's Size\nvar tileSize: CGSize\nThe size of each tile in points.\nvar tileSet: SKTileSet\nThe tile set being used by this tile map. The tile map object can only display tiles that exist in this set.\nvar numberOfRows: Int\nThe number of rows in the tile map."
  },
  {
    "title": "changeMass(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417710-changemass",
    "html": "Parameters\nv\n\nThe amount to add to the physics body’s mass.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the physics body’s mass property animates from its current value to its new value.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.changeMass(by: -v, duration: sec)\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "falloff(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417758-falloff",
    "html": "Parameters\nfalloff\n\nThe new falloff for the field.\n\nsec\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action runs, the field node’s falloff property animates from its current value to its new value. This action is not reversible.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "changeMass(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417780-changemass",
    "html": "Parameters\nv\n\nThe new mass of the physics body.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the physics body’s mass property animates from its current value to its new value.\n\nThis action is not reversible.\n\nSee Also\nAnimating Properties of a Node's Physics Body\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value."
  },
  {
    "title": "play() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417730-play",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nThis action may only be executed on an SKAudioNode object.\n\nThis action is not reversible.\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "animate(withWarps:times:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1690937-animate",
    "html": "Parameters\nwarps\n\nThe sequence of warps to apply to the node.\n\ntimes\n\nThe times at which each warp distortion in the sequence should complete.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThe numberOfColumns and numberOfRows in each geometry in the sequence should match.\n\nSee Also\nAnimate the Warping of a Node\nclass func animate(withWarps: [SKWarpGeometry], times: [NSNumber], restore: Bool) -> SKAction?\nCreates an action to distort a node through a sequence of SKWarpGeometry objects.\nclass func warp(to: SKWarpGeometry, duration: TimeInterval) -> SKAction?\nCreates an action to distort a node based using an SKWarpGeometry object.\nRelated Documentation\nclass SKWarpGeometryGrid\nA definition for a grid-based deformation of nodes that conform to ."
  },
  {
    "title": "warp(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1690951-warp",
    "html": "Parameters\nwarp\n\nThe warp geometry to distort the node to.\n\nduration\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThe numberOfColumns and numberOfRows in the node's current geometry should match those of the specified geometry.\n\nSee Also\nAnimate the Warping of a Node\nclass func animate(withWarps: [SKWarpGeometry], times: [NSNumber]) -> SKAction?\nCreates an action to distort a node through a sequence of SKWarpGeometry objects.\nclass func animate(withWarps: [SKWarpGeometry], times: [NSNumber], restore: Bool) -> SKAction?\nCreates an action to distort a node through a sequence of SKWarpGeometry objects.\nRelated Documentation\nclass SKWarpGeometryGrid\nA definition for a grid-based deformation of nodes that conform to ."
  },
  {
    "title": "fade(with:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395871-fade",
    "html": "Parameters\ncolor\n\nThe color to use as the fade color.\n\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "tileSet | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643610-tileset",
    "html": "See Also\nReading or Manually Configuring the Tile Map's Size\nvar tileSize: CGSize\nThe size of each tile in points.\nvar numberOfColumns: Int\nThe number of columns in the tile map\nvar numberOfRows: Int\nThe number of rows in the tile map."
  },
  {
    "title": "tileSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/1643594-tilesize",
    "html": "See Also\nReading or Manually Configuring the Tile Map's Size\nvar tileSet: SKTileSet\nThe tile set being used by this tile map. The tile map object can only display tiles that exist in this set.\nvar numberOfColumns: Int\nThe number of columns in the tile map\nvar numberOfRows: Int\nThe number of rows in the tile map."
  },
  {
    "title": "Transitioning Between Two Scenes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/transitioning_between_two_scenes",
    "html": "Overview\n\nTypically, you transition to a new scene based on gameplay or user input. For example, if the user presses a button in your main menu scene, you might transition to a new scene to configure the match the player wants to play.\n\nListing 1 shows how you might implement the event handler in a sprite. The handler first runs an animation on itself to highlight the button (not described here). Then, it creates a transition object and the new scene. Finally, it calls the view to present the new scene. The transition means that this change is animated.\n\nListing 1 Transitioning to a new scene\n    override func mouseUp(with event: NSEvent) {\n        run(buttonPressAnimation)\n        let reveal = SKTransition.reveal(with: .down,\n                                         duration: 1)\n        let newScene = GameConfigScene(size: CGSize(width: 1024, height: 768))\n        \n        scene.view.presentScene(newScene,\n                                transition: reveal)\n    }\n\n\nWhen the transition occurs, the scene property is immediately updated to point to the new scene. Then, the animation occurs. Finally, the strong reference to the old scene is removed. If you need to keep the scene around after the transition occurs, your app needs to keep its own strong reference to the old scene.\n\nWhen organizing your game, it can be helpful to create a diagram that shows all the scenes in a game, the transitions that occur between scenes, and the data that must be passed to the new scene when a transition occurs. Unlike view controllers in iOS, SpriteKit does not provide a built-in mechanism for passing data between scenes. If you need to provide data during a scene transition, you need to implement your own mechanism to configure the new scene. Typically, this means defining custom methods and properties on each scene.\n\nSee Also\nCreating Transitions\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "flipHorizontal(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395901-fliphorizontal",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "flipVertical(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395889-flipvertical",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "changeVolume(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417726-changevolume",
    "html": "Parameters\nv\n\nThe amount to change the volume by.\n\nduration\n\nThe duration of the animation, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the audio node’s volume animates from its current value to its new value. For more information, see AVAudio3DMixing.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.changeVolume(by: -v, duration: sec)\n\nSee Also\nControlling the Audio of a Node\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value."
  },
  {
    "title": "init(circleOfRadius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519570-init",
    "html": "Parameters\nradius\n\nThe radius of the circle.\n\nReturn Value\n\nA new shape node."
  },
  {
    "title": "path | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519741-path",
    "html": "Discussion\n\nThe path is defined in the node’s coordinate space.\n\nSee Also\nCreating a Shape from a Path\ninit(path: CGPath)\nCreates a shape node from a Core Graphics path.\ninit(path: CGPath, centered: Bool)\nCreates a shape node from a Core Graphics path, centered around its position."
  },
  {
    "title": "moveIn(with:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395905-movein",
    "html": "Parameters\ndirection\n\nThe direction of the move. Possible values are described in SKTransitionDirection.\n\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "push(with:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395903-push",
    "html": "Parameters\ndirection\n\nThe direction of the push. Possible values are described in SKTransitionDirection.\n\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "reveal(with:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395887-reveal",
    "html": "Parameters\ndirection\n\nThe direction of the reveal. Possible values are described in SKTransitionDirection.\n\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "pausesOutgoingScene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395877-pausesoutgoingscene",
    "html": "Discussion\n\nThe default value is true.\n\nSee Also\nPausing\nvar pausesIncomingScene: Bool\nA Boolean value that determines whether the incoming scene is paused during the transition."
  },
  {
    "title": "distance(_:to:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519746-distance",
    "html": "Parameters\nrange\n\nThe range of allowed distances.\n\npoint\n\nThe point to use as the target point.\n\nnode\n\nThe node whose coordinate system the point is specified in.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time when constraints are applied, a line is projected between the node’s position and the target point. The distance between the two points is calculated, and if it lies outside the specified range, the node is pushed or pulled along this line until it lies within the range.\n\nSee Also\nCreating Distance Constraints\nclass func distance(SKRange, to: SKNode) -> Self\nCreates a constraint that keeps a node within a certain distance of another node.\nclass func distance(SKRange, to: CGPoint) -> Self\nCreates a constraint that keeps a node within a certain distance of a point."
  },
  {
    "title": "distance(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519750-distance",
    "html": "Parameters\nrange\n\nThe range of allowed distances between the two nodes.\n\nnode\n\nThe target node used to calculate the distance.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nDistance constraints constrain a node to a specified distance range of another node or a point and can be used for effects such a simulating flocking around a node, repulsive fields and trails. Supplying a distance constraint with a range with a lower limit, an upper limit or both results in very different behaviors:\n\nExample initialization\n\n\t\n\nBehavior\n\n\n\n\nSKConstraint.distance(SKRange(lowerLimit: 20), to: targetNode)\n\n\t\n\nIf targetNode is moving and constrained objects are static, gives an effect similar to a repulsive magnetic field\n\n\n\n\nSKConstraint.distance(SKRange(upperLimit: 10), to: targetNode)\n\n\t\n\nAll constrained nodes are immediately attracted to targetNode. Multiple constrained nodes can converge to a single point if targetNode is moved.\n\n\n\n\nSKConstraint.distance(SKRange(lowerLimit: 40, upperLimit: 50), to: targetNode)\n\n\t\n\nAll constrained nodes are immediately attracted to targetNode. Multiple constrained nodes can form a ring around targetNode if it is moved.\n\nEach time when constraints are applied, a line is projected between the node’s position and the target node’s position. The distance between the two points is calculated, and if it lies outside the specified range, the node is pushed or pulled along this line until it lies within the range.\n\nSee Also\nCreating Distance Constraints\nclass func distance(SKRange, to: CGPoint) -> Self\nCreates a constraint that keeps a node within a certain distance of a point.\nclass func distance(SKRange, to: CGPoint, in: SKNode) -> Self\nCreates a constraint that keeps a node within a certain distance of a point in another node’s coordinate system."
  },
  {
    "title": "orient(to:offset:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519686-orient",
    "html": "Parameters\npoint\n\nA point in the node’s parent’s coordinate system.\n\nradians\n\nAn offset that is added to the zRotation value after it is calculated.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time when constraints are applied, a new angle is calculated so that a line projected at this angle would point at the target point. This angle is added to the values specified in the radians property to create a new range. Finally, the node’s zRotation value is clamped to fit inside this range.\n\nSee Also\nCreating Orientation Constraints\nCreating a Look-At Constraint\nMake a node automatically rotate itself based on the changing position of another node, by using orientation constraints.\nclass func orient(to: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face another node.\nclass func orient(to: CGPoint, in: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a point in another node’s coordinate system.\nclass func zRotation(SKRange) -> Self\nCreates a constraint that limits the orientation of a node.\nRelated Documentation\nvar referenceNode: SKNode?\nThe node whose coordinate system should be used to apply the constraint."
  },
  {
    "title": "zRotation(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519706-zrotation",
    "html": "Parameters\nzRange\n\nA range value that specifies the minimum and maximum values of the node’s zRotation property.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time when constraints are applied, the node’s zRotation property is clamped so that it is within the specified range.\n\nSee Also\nCreating Orientation Constraints\nCreating a Look-At Constraint\nMake a node automatically rotate itself based on the changing position of another node, by using orientation constraints.\nclass func orient(to: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face another node.\nclass func orient(to: CGPoint, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a fixed point.\nclass func orient(to: CGPoint, in: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a point in another node’s coordinate system."
  },
  {
    "title": "referenceNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1520369-referencenode",
    "html": "Discussion\n\nThe default value is nil, meaning that the coordinate system of the node’s parent is used to apply the constraint. If another node is specified, all positions are converted into this node’s coordinate system before the constraint is applied."
  },
  {
    "title": "orient(to:in:offset:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519627-orient",
    "html": "Parameters\npoint\n\nA point in the node parameter’s coordinate system.\n\nnode\n\nThe node whose coordinate system the point is specified in.\n\nradians\n\nAn offset that is added to the zRotation value after it is calculated.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time when constraints are applied, a new angle is calculated so that a line projected at this angle would point at the target point. This angle is added to the values specified in the radians property to create a new range. Finally, the node’s zRotation value is clamped to fit inside this range.\n\nSee Also\nCreating Orientation Constraints\nCreating a Look-At Constraint\nMake a node automatically rotate itself based on the changing position of another node, by using orientation constraints.\nclass func orient(to: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face another node.\nclass func orient(to: CGPoint, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a fixed point.\nclass func zRotation(SKRange) -> Self\nCreates a constraint that limits the orientation of a node."
  },
  {
    "title": "orient(to:offset:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519744-orient",
    "html": "Parameters\nnode\n\nThe node that should be used to orient the node that this constraint is attached to.\n\nradians\n\nAn offset that is added to the zRotation value after it is calculated.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time when constraints are applied, a new angle is calculated so that a line projected at this angle would point at the other node’s origin. This angle is added to the values specified in the radians property to create a new range. Finally, the node’s zRotation value is clamped to fit inside this range.\n\nSee Also\nCreating Orientation Constraints\nCreating a Look-At Constraint\nMake a node automatically rotate itself based on the changing position of another node, by using orientation constraints.\nclass func orient(to: CGPoint, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a fixed point.\nclass func orient(to: CGPoint, in: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a point in another node’s coordinate system.\nclass func zRotation(SKRange) -> Self\nCreates a constraint that limits the orientation of a node."
  },
  {
    "title": "positionY(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1520356-positiony",
    "html": "Parameters\nrange\n\nThe range to restrict the coordinate to.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time when constraints are applied, the y-coordinate of the node’s position property is clamped so that it lies inside the specified range.\n\nSee Also\nCreating Position Constraints\nCreating Position Constraints\nCreate a position constraint and add it to a node.\nclass func positionX(SKRange, y: SKRange) -> Self\nCreates a constraint that restricts both coordinates of a node’s position.\nclass func positionX(SKRange) -> Self\nCreates a constraint that restricts the x-coordinate of a node’s position."
  },
  {
    "title": "positionX(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519716-positionx",
    "html": "Parameters\nrange\n\nThe range to restrict the coordinate to.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time constraints are applied, the x-coordinate of the node’s position property is clamped so that it lies inside the specified range.\n\nSee Also\nCreating Position Constraints\nCreating Position Constraints\nCreate a position constraint and add it to a node.\nclass func positionX(SKRange, y: SKRange) -> Self\nCreates a constraint that restricts both coordinates of a node’s position.\nclass func positionY(SKRange) -> Self\nCreates a constraint that restricts the y-coordinate of a node’s position.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "Creating Position Constraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/creating_position_constraints",
    "html": "Overview\n\nYou lock a node at a specific coordinate with positionX(_:y:). Constrain a node’s horizontal position with positionX(_:), or constrain its vertical position with positionY(_:).\n\nThe following code shows how you can create a node with an attached physics body that’s affected by a noise field. The node moves with the noise but the constraints keep it within a rectangular region between 300 and 340 points on both the horizontal and vertical axes.\n\nscene.physicsWorld.gravity = CGVector(dx: 0, dy: 0)\n   \nlet noiseField = SKFieldNode.noiseField(withSmoothness: 1, animationSpeed: 0.1)\nscene.addChild(noiseField)\n     \nlet node = SKShapeNode(circleOfRadius: 10)\nnode.physicsBody = SKPhysicsBody(circleOfRadius: 10)\nscene.addChild(node)\n     \nlet range = SKRange(lowerLimit: 300, upperLimit: 340)\n\n\nlet lockToCenter = SKConstraint.positionX(range, y: range)\n\n\nnode.constraints = [ lockToCenter ]\n\n\nSee Also\nCreating Position Constraints\nclass func positionX(SKRange, y: SKRange) -> Self\nCreates a constraint that restricts both coordinates of a node’s position.\nclass func positionX(SKRange) -> Self\nCreates a constraint that restricts the x-coordinate of a node’s position.\nclass func positionY(SKRange) -> Self\nCreates a constraint that restricts the y-coordinate of a node’s position."
  },
  {
    "title": "init(noiseWithSmoothness:size:grayscale:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519971-init",
    "html": "Parameters\nsmoothness\n\nA value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.\n\nsize\n\nThe size of the new texture in points.\n\ngrayscale\n\nIf true, all four components of each texel will have equal values. If false, all four values are completely randomized.\n\nReturn Value\n\nA new noise texture.\n\nDiscussion\n\nUnlike other textures produced by SpriteKit, the texels are not premultiplied by the alpha value. Your custom shaders should compensate for this as necessary.\n\nThe following code creates three sprite nodes with textures generated by\n\ninit(noiseWithSmoothness:size:grayscale:)\n\nwith smoothness values of 0.0, 0.5 and 1.0.\n\nlet columWidth = scene.size.width / 3\n\n\nfor i in 0...2 {\n    \n    let size = CGSize(width: ceil(columWidth),\n                      height: 0.5 * scene.size.height)\n    \n    let smoothness = CGFloat(i) / 2\n    \n    let noiseTexture = SKTexture(noiseWithSmoothness: smoothness,\n                                  size: size,\n                                  grayscale: false)\n    \n    let sprite = SKSpriteNode(texture: noiseTexture, size: size)\n    \n    sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),\n                              y: scene.size.height / 2)\n    \n    scene.addChild(sprite)\n}\n\n\nSee Also\nNoise Textures\ninit(vectorNoiseWithSmoothness: CGFloat, size: CGSize)\nCreates a new texture whose contents are procedurally generated directional noise data."
  },
  {
    "title": "init(noiseMap:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1640752-init",
    "html": "Parameters\nnoiseMap\n\nThe noise map object from which to generate a texture.\n\nReturn Value\n\nA new texture based on the contents of the noise map.\n\nDiscussion\n\nThe GKNoiseMap class encapsulates the output of procedural noise generation and processing. You use noise sources (the GKNoiseSource class cluster), noise objects (the GKNoise class), and noise maps to generate, process, and combine styles of noise, then use this method to create a graphical representation of the noise for use as a texture image in your game. Noise textures can be useful for imitating natural phenomena such as clouds, stone surfaces, and wood grain. You can also use noise textures as normal maps to make surfaces appear more natural under lighting.\n\nThis method colorizes the generated texture using the gradientColors property of the GKNoise object from which the noise map was created. By default, that property specifies a simple grayscale ramp, but you can change it to create more colorful textures. When you use the init(componentNoises:selectionNoise:) method to combine noise objects, each component noise object keeps its original colors, and the selection noise determines which component noise’s colors appear in which areas of a generated texture.\n\nThe following code shows how to create a texture based on Perlin noise:\n\nlet noiseSource = GKPerlinNoiseSource(frequency: 4,\n                                      octaveCount: 3,\n                                      persistence: 0.2,\n                                      lacunarity: 1,\n                                      seed: 0)\n\n\nlet noise = GKNoise(noiseSource)\n\n\nlet noiseMap = GKNoiseMap(noise, size: double2(8,8),\n                          origin: double2(0,0),\n                          sampleCount: int2(640,640),\n                          seamless: false)\n\n\nlet noiseTexture = SKTexture(noiseMap: noiseMap)\n\n\nThe following image illustrates a sprite node using this texture as both arguments for init(texture:normalMap:)."
  },
  {
    "title": "didSimulatePhysics(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenedelegate/1520392-didsimulatephysics",
    "html": "Parameters\nscene\n\nThe scene that is being animated.\n\nDiscussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. It is called after physics has been simulated in the scene.\n\nAny additional actions applied are not evaluated until the next update.\n\nAny changes to physics bodies are not simulated until the next update.\n\nSee Also\nHandling Animation Events\nUse SpriteKit Objects within Scene Delegate Callbacks\nFollow threading guidelines to keep your SpriteKit app thread safe.\nfunc update(TimeInterval, for: SKScene)\nTells you to perform any app specific logic to update your scene.\nfunc didEvaluateActions(for: SKScene)\nTells you to peform any necessary logic after scene actions are evaluated.\nfunc didApplyConstraints(for: SKScene)\nTells you to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate(for: SKScene)\nTells you to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "didEvaluateActions(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenedelegate/1520071-didevaluateactions",
    "html": "Parameters\nscene\n\nThe scene that is being animated.\n\nDiscussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. It is called after any actions have been evaluated by nodes in the scene but before any physics are simulated.\n\nAny additional actions applied are not evaluated until the next update.\n\nSee Also\nHandling Animation Events\nUse SpriteKit Objects within Scene Delegate Callbacks\nFollow threading guidelines to keep your SpriteKit app thread safe.\nfunc update(TimeInterval, for: SKScene)\nTells you to perform any app specific logic to update your scene.\nfunc didSimulatePhysics(for: SKScene)\nTells you to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints(for: SKScene)\nTells you to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate(for: SKScene)\nTells you to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "Use SpriteKit Objects within Scene Delegate Callbacks | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenedelegate/use_spritekit_objects_within_scene_delegate_callbacks",
    "html": "Overview\n\nSpriteKit is largely a single threaded game engine and as such the API provides developers with callbacks to implement your custom game logic. The primary callback for your game logic is update(_:for:). Other callbacks are illustrated in Figure 1. Modifying SpriteKit objects outside of the scene delegate callbacks (such as in a background queue or anything else not running on the main thread) can result in concurrency related problems. Even dispatching work on the main thread asynchronously or at a later time is risky because the closure is likely to be done outside of the timeframe SpriteKit expects. If you're experiencing a segmentation fault or other type of crash occurring deep within the SpriteKit framework, there's a good chance your code is modifying a SpriteKit object outside of the scene delegate callbacks.\n\nNote\n\nTo check at runtime if a particular block of code is running on the main thread, inspect NSThread isMainThread.\n\nSee Also\nHandling Animation Events\nfunc update(TimeInterval, for: SKScene)\nTells you to perform any app specific logic to update your scene.\nfunc didEvaluateActions(for: SKScene)\nTells you to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics(for: SKScene)\nTells you to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints(for: SKScene)\nTells you to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate(for: SKScene)\nTells you to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "Getting Started with Shape Nodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/getting_started_with_shape_nodes",
    "html": "Overview\n\nA graphics path is a collection of straight lines and curves that can define either open or closed subpaths. You can specify separate rendering behavior for the filled and stroked portion of the path. Each part can be rendered using either a solid color or a texture; if you need to render more sophisticated effects, you can also use a custom shader.\n\nShape nodes are useful for content that cannot be easily decomposed into simple textured sprites. They're also useful for building and displaying debugging information on top of your game content. However, the SKSpriteNode class offers higher performance than this class, so use shape nodes sparingly.\n\nCreate a Shape Node\n\nThe following code demonstrates how to create a shape node. The example creates a circle with a blue interior and a white outline. The path is created and attached to the shape node’s path property.\n\nlet path = CGMutablePath()\npath.addArc(center: CGPoint.zero,\n            radius: 15,\n            startAngle: 0,\n            endAngle: CGFloat.pi * 2,\n            clockwise: true)\nlet ball = SKShapeNode(path: path)\nball.lineWidth = 1\nball.fillColor = .blue\nball.strokeColor = .white\nball.glowWidth = 0.5\n\n\nYou can see from the code that the shape has three essential elements:\n\nThe interior of the shape is filled. The fillColor property specifies the color used to fill the interior.\n\nThe outline of the shape is rendered as a line. The strokeColor and lineWidth properties define how the line is stroked.\n\nA glow extends from the outline. The glowWidth and strokeColor properties define the glow.\n\nYou can disable any of these elements by setting its color to [SKColor clearColor].\n\nThe shape node provides properties that let you control how the shape is blended into the framebuffer. You use these properties the same way as the properties of the SKSpriteNode class. See SKShapeNode."
  },
  {
    "title": "init(path:centered:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1519649-init",
    "html": "Parameters\npath\n\nThe Core Graphics path to use.\n\ncentered\n\nIf true, the path is translated so that the center of the path’s bounding box is at the node’s origin; otherwise the path is relative to the node’s origin.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating a Shape from a Path\ninit(path: CGPath)\nCreates a shape node from a Core Graphics path.\nvar path: CGPath?\nThe path that defines the shape."
  },
  {
    "title": "init(path:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode/1520022-init",
    "html": "Parameters\npath\n\nThe Core Graphics path to use. The path is relative to the node’s origin.\n\nReturn Value\n\nA new shape node.\n\nSee Also\nCreating a Shape from a Path\ninit(path: CGPath, centered: Bool)\nCreates a shape node from a Core Graphics path, centered around its position.\nvar path: CGPath?\nThe path that defines the shape.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "Cropping Nodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skcropnode/cropping_nodes",
    "html": "Overview\n\nA crop node is useful for implementing cockpit views, controls, and other game indicators, as well as any effect where a set of nodes should be drawn only inside a specific part of a scene. The following image shows how a crop node works. It uses the rocket ship art shown on the left as a mask for a sprite drawn as a child of the crop node shown on the right.\n\nThe cropped area is specified using a mask. The mask is not a fixed image. The mask is rendered from a node, just like other content in SpriteKit. This means a crop node can use simple masks derived from a piece of artwork, but it can also use more sophisticated masks.\n\nTo use a crop node, add child nodes as you would for any other node. Then set the crop node’s maskNode property to point to another node. When the scene is rendered, the crop mask renders its mask node and uses the resulting mask to determine which pixels of its children should be rendered to the parent’s framebuffer.\n\nThe example code below shows a simple use of a mask. This code loads a mask image from a texture in the app bundle. A portion of the scene’s content is then rendered as children of the crop node, using the mask to prevent it from overdrawing the portion of the screen that the game uses to show controls.\n\nSKCropNode *cropNode = [[SKCropNode alloc] init];\ncropNode.maskNode = [[SKSpriteNode alloc] initWithImageNamed:@\"cockpitMask\"];\n[cropNode addChild: sceneContentNode];\n[self addChild:cropNode];\n[self addChild:gameControlNodes];\n\n\nWhen the crop node’s children are rendered, the mask node is first rendered and used to crop the node’s children."
  },
  {
    "title": "doorsCloseHorizontal(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395899-doorsclosehorizontal",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "doorsCloseVertical(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395914-doorsclosevertical",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "crossFade(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395897-crossfade",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "doorsOpenHorizontal(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395875-doorsopenhorizontal",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "Configuring Whether Animations Play During the Transition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/configuring_whether_animations_play_during_the_transition",
    "html": "Overview\n\nThe pausesIncomingScene and pausesOutgoingScene properties on the transition object define which animations are played during the transition. By default, both scenes are paused during the transition. However, you might want to enable animation on either scene during the transition.\n\nFigure 1 illustrates which frames of the incoming and outgoing scenes are displayed on screen during a three frame transition with different permutations of pausesIncomingScene and pausesOutgoingScene.\n\nFigure 1 Frame progression during transitions\n\nFor example, consider the code again in . Because the button is going to run an action, this code expects the outgoing scene to be animated. But perhaps the incoming scene should not animate its content until the transition completes. Adding the code in Listing 1 has the desired effect.\n\nListing 1 Pausing frame processing during a transition\nreveal.pausesOutgoingScene = true;\nreveal.pausesIncomingScene = false;\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "doorsOpenVertical(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395909-doorsopenvertical",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "doorway(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395881-doorway",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nDiscussion\n\nThe new scene starts in the background and moves closer as the doors open.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "Creating a Tile Map Programmatically | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode/creating_a_tile_map_programmatically",
    "html": "Overview\n\nThe collection of functions you use to create a tile map node programmatically.\n\nTip\n\nYou can create a tile map node much quicker by using Xcode's SpriteKit Scene Editor.\n\nTopics\nCreating a Tile Map\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, fillWith: SKTileGroup)\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows.\ninit(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, tileGroupLayout: [SKTileGroup])\nCreates and initializes a tile map node using the provided tile set with a specified number of columns and rows. For a grid set type, the overall size, in points, of the node will be numberOfColumns * tileSize.widthwide andnumberOfRows * tileSize.height high.\nclass func tileMapNodes(tileSet: SKTileSet, columns: Int, rows: Int, tileSize: CGSize, from: GKNoiseMap, tileTypeNoiseMapThresholds: [NSNumber]) -> [SKTileMapNode]\nCreates a tile map node by allowing a GKNoiseMap to choose its tiles.\nDefining a Tile Map's Contents\nvar enableAutomapping: Bool\nWhen creating a tile map node programmatically, specifies whether the tile map uses automapping behavior like the scene editor.\nfunc fill(with: SKTileGroup?)\nWhen creating a tile map node programmatically, this function performs a fill operation with the specified tile group.\nfunc setTileGroup(SKTileGroup, andTileDefinition: SKTileDefinition, forColumn: Int, row: Int)\nSet the tile group and tile definition at the specified tile index.\nfunc setTileGroup(SKTileGroup?, forColumn: Int, row: Int)\nSet the tile group at the specified tile index."
  },
  {
    "title": "init(rect:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520425-init",
    "html": "Parameters\nrect\n\nA rectangle in the unit coordinate space that specifies the portion of the texture to use.\n\ntexture\n\nThe texture to create the new texture from.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe returned texture object shares the same texture data as the original texture object, meaning that only one copy of the texture data is kept in memory.\n\nIf you call this method on a texture that itself was created using this method, the original texture is used as the source instead. That is, the rectangle is considered to be in the source texture’s coordinate system. To do this, you should use the source texture's textureRect() rather than relying on hard coded {(0,0) (1,1)} as the coordinates.\n\nListing 1 shows how you can use the source texture's textureRect() to calculate the portion of the texture to use.\n\nListing 1 Creating a texture from a portion of another texture.\nlet originalTexture = SKTexture(imageNamed: \"sourceImage.png\")\n\n\nlet rect = CGRect(origin: originalTexture.textureRect().origin,\n                  size: CGSize(width: originalTexture.textureRect().midX,\n                               height: originalTexture.textureRect().midY))\n\n\nlet croppedTexture = SKTexture(rect: rect,\n                               in: originalTexture)\n\n\nIn the above example, if originalTexture had a size of (348.0, 282.0) and a textureRect() of {(0,0) (1,1)}, croppedTexture will have a size of (174.0, 141.0) and a textureRect() of {(0,0) (1,1)}. croppedTexture will be a copy of the bottom left quadrant of originalTexture."
  },
  {
    "title": "init(vectorNoiseWithSmoothness:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520393-init",
    "html": "Parameters\nsmoothness\n\nA value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.\n\nsize\n\nThe size of the new texture in points.\n\nReturn Value\n\nA new noise texture.\n\nDiscussion\n\nThe noise texture is tileable with itself. The RGB values stored in the texture can be used as directional (XYZ) data. The alpha values are also randomized and can be used as magnitude data, if desired.\n\nThe following code creates three sprite nodes with textures generated by\n\ninit(vectorNoiseWithSmoothness:size:)\n\nwith smoothness values of 0.0, 0.5 and 1.0.\n\nlet columWidth = scene.size.width / 3\n\n\nfor i in 0...2 {\n    \n    let size = CGSize(width: ceil(columWidth),\n                      height: 0.5 * scene.size.height)\n    \n    let smoothness = CGFloat(i) / 2\n    \n    let vectorTexture = SKTexture(vectorNoiseWithSmoothness: smoothness,\n                                  size: size)\n    \n    let sprite = SKSpriteNode(texture: vectorTexture, size: size)\n    \n    sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),\n                              y: \nscene.size.height / 2)\n\n\n    \n    scene.addChild(sprite)\n}\n\n\nSee Also\nNoise Textures\ninit(noiseWithSmoothness: CGFloat, size: CGSize, grayscale: Bool)\nCreates a new texture whose contents are procedurally generated color noise data."
  },
  {
    "title": "init(data:size:flipped:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519674-init",
    "html": "Parameters\npixelData\n\nAn NSData object that holds the bitmap data. The pixels must be 32 bpp, 8bpc (unsigned integer) RGBA pixel data. The color components should have been already multiplied by the alpha value.\n\nsize\n\nThe size of the new texture in points.\n\nflipped\n\nA Boolean value that indicates whether the image data should be vertically flipped before creating the texture.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe image data is copied before control is returned to your game.\n\nSee Also\nTexture from Data\ninit(data: Data, size: CGSize)\nCreates a new texture from raw pixel data.\ninit(data: Data, size: CGSize, rowLength: UInt32, alignment: UInt32)\nCreates a new texture from custom formatted raw pixel data."
  },
  {
    "title": "generatingNormalMap(withSmoothness:contrast:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520441-generatingnormalmap",
    "html": "Parameters\nsmoothness\n\nA number between 0.0 and 1.0 indicating how much the texture should be smoothed before the normal map is generated. A value of 0.0 means that the texture is not smoothed at all before being processed.\n\ncontrast\n\nA value used to magnify the effect of the generated normal map. A value of 1.0 indicates no magnification is applied.\n\nReturn Value\n\nA new texture object that contains a normal map.\n\nDiscussion\n\nA normal map texture is similar to an image texture, but instead of holding image data to be displayed onscreen, every texel represents a normal vector. Normal map textures are used to simulate 3D lighting (see the normalTexture property) or used to generate velocity values (see velocityField(with:)).\n\nYou can create normal maps in two different ways. First, you can take an existing image map and use it to generate a normal map. SpriteKit filters the color data in the texture and then uses it to generate a map based on pixel contrast. Alternatively, you can load a regular image file but treat it as a normal map. To do this, provide a texture with 32-bit RGBx pixel data. Each component’s 8-bit integer value is mapped to a floating point number between the values of -1.0 and 1.0. Use a 0 to represent -1.0f, a value of 127 to represent 0.0, and a value of 255 to represent +1.0.\n\nThe image below shows two sprite nodes both with the same texture. The node on the right has a normal map from the same noise texture generated using the generatingNormalMap() method.\n\nFigure 1 Comparison of sprites with and without normal mapping\n\nSee Also\nTexture from Normal Map\nfunc generatingNormalMap() -> Self\nCreates a normal map texture by analyzing the contents of an existing texture."
  },
  {
    "title": "generatingNormalMap() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519687-generatingnormalmap",
    "html": "Return Value\n\nA new texture object that contains a normal map.\n\nDiscussion\n\nA normal map texture is similar to an image texture, but instead of holding image data to be displayed onscreen, every texel represents a normal vector. Normal map textures are used to simulate 3D lighting (see the normalTexture property) or used to generate velocity values (see velocityField(with:)).\n\nYou can create normal maps in two different ways. First, you can take an existing image map and use it to generate a normal map. SpriteKit filters the color data in the texture and then uses it to generate a map based on pixel contrast. Alternatively, you can load a regular image file but treat it as a normal map. To do this, provide a texture with 32-bit RGBx pixel data. Each component’s 8-bit integer value is mapped to a floating point number between the values of -1.0 and 1.0. Use a 0 to represent -1.0f, a value of 127 to represent 0.0, and a value of 255 to represent +1.0.\n\nThe image below shows two sprite nodes both with the same texture. The node on the right has a normal map from the same noise texture generated using the generatingNormalMap() method.\n\nFigure 1 Comparison of sprites with and without normal mapping\n\nSee Also\nTexture from Normal Map\nfunc generatingNormalMap(withSmoothness: CGFloat, contrast: CGFloat) -> Self\nCreates a normal map texture by analyzing the contents of an existing texture."
  },
  {
    "title": "init(data:size:rowLength:alignment:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520181-init",
    "html": "Parameters\npixelData\n\nAn NSData object that holds the bitmap data. The pixels must be 32 bpp, 8bpc (unsigned integer) RGBA pixel data. The color components should have been already multiplied by the alpha value.\n\nsize\n\nThe size of the new texture in points.\n\nrowLength\n\nThe number of bytes of memory to use per row of the bitmap.\n\nalignment\n\nThe offset between individual pixels of the pixel data. Specify 0 for tightly packed data.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe image data is copied before control is returned to your game.\n\nSee Also\nTexture from Data\ninit(data: Data, size: CGSize)\nCreates a new texture from raw pixel data.\ninit(data: Data, size: CGSize, flipped: Bool)\nCreates a new texture from raw pixel data."
  },
  {
    "title": "init(data:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519962-init",
    "html": "Parameters\npixelData\n\nAn NSData object that holds the bitmap data. The pixels must be 32 bpp, 8bpc (unsigned integer) RGBA pixel data. The color components should have been already multiplied by the alpha value.\n\nsize\n\nThe size of the new texture in points.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe image data is copied before control is returned to your game.\n\nCreating textures from raw pixel data is useful if you have a CPU based routine for creating imagery. The following code shows how you can use init(data:size:) to create a texture containing random colors and a solid alpha. The bytes array is populated by iterating over the total number of pixels and adding four UInt8 values for the red, green, blue, and alpha channels.\n\nlet width = 128\nlet height = 128\nlet bytes = stride(from: 0, to: width * height, by: 1).flatMap {\n    _ in\n    return [\n        UInt8(drand48() * 255), // red\n        UInt8(drand48() * 255), // green\n        UInt8(drand48() * 255), // blue\n        UInt8(255)              // alpha\n    ]\n}\nlet data = Data(bytes: bytes)\nlet texture = SKTexture(data: data,\n                        size: CGSize(width: width, height: height))\n\n\nSee Also\nTexture from Data\ninit(data: Data, size: CGSize, rowLength: UInt32, alignment: UInt32)\nCreates a new texture from custom formatted raw pixel data.\ninit(data: Data, size: CGSize, flipped: Bool)\nCreates a new texture from raw pixel data."
  },
  {
    "title": "pausesIncomingScene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395883-pausesincomingscene",
    "html": "Discussion\n\nThe default value is true.\n\nSee Also\nPausing\nvar pausesOutgoingScene: Bool\nA Boolean value that determines whether the outgoing scene is paused during the transition."
  },
  {
    "title": "applying(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520388-applying",
    "html": "Parameters\nfilter\n\nA Core Image filter that requires a single inputImage parameter and produces an outputImage parameter.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe image data is copied before control is returned to your game."
  },
  {
    "title": "Creating a Look-At Constraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/creating_a_look-at_constraint",
    "html": "Overview\n\nA common use for orientation constraints is to make a look-at constraint. For example, you may create a look-at constraint to make a pair of eyes follow a moving object or to have a rocket point in the direction of its target.\n\nThe following code shows how to create a constraint to make a sprite node named pointer always point toward a circular-shape node named target. The texture assigned to pointer is an upward-pointing arrow and, because SpriteKit's angular coordinates have their origin at the three o'clock position, the orient constraint has an offset of 90° (pi/2 radians) so that the arrow is correctly oriented toward the target.\n\nlet target = SKShapeNode(circleOfRadius: 10)\ntarget.position = CGPoint(x: 100, y: 100)\nscene.addChild(target)\n    \nlet pointer = SKSpriteNode(imageNamed: \"arrowUp.png\")\npointer.position = CGPoint(x: 200, y: 200)\nscene.addChild(pointer)\n    \nlet lookAtConstraint = SKConstraint.orient(to: target,\n                                           offset: SKRange(constantValue: -CGFloat.pi / 2))\npointer.constraints = [ lookAtConstraint ]\n\n\nA further orientation constraint, zRotation(_:), can be used in combination with the look-at constraint shown above to limit rotation. When you add the code above, the arrow's rotation is limited so that it never points downward:\n\nlet limitLookAt = SKConstraint.zRotation(SKRange(lowerLimit: -CGFloat.pi / 2,\n                                                 upperLimit: CGFloat.pi / 2))\n      \npointer.constraints = [ lookAtConstraint, limitLookAt ]\n\n\nSee Also\nCreating Orientation Constraints\nclass func orient(to: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face another node.\nclass func orient(to: CGPoint, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a fixed point.\nclass func orient(to: CGPoint, in: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a point in another node’s coordinate system.\nclass func zRotation(SKRange) -> Self\nCreates a constraint that limits the orientation of a node."
  },
  {
    "title": "positionX(_:y:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint/1519760-positionx",
    "html": "Parameters\nxRange\n\nThe range to restrict the x-coordinate to.\n\nyRange\n\nThe range to restrict the y-coordinate to.\n\nReturn Value\n\nA new constraint.\n\nDiscussion\n\nEach time constraints are applied, the node’s position property is clamped so that both coordinates lie inside the specified ranges.\n\nSee Also\nCreating Position Constraints\nCreating Position Constraints\nCreate a position constraint and add it to a node.\nclass func positionX(SKRange) -> Self\nCreates a constraint that restricts the x-coordinate of a node’s position.\nclass func positionY(SKRange) -> Self\nCreates a constraint that restricts the y-coordinate of a node’s position."
  },
  {
    "title": "init(image:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520136-init",
    "html": "Parameters\nimage\n\nAn image.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe image data is copied before control is returned to your game.\n\nSee Also\nTexture from Image\ninit(cgImage: CGImage)\nCreate a new texture object from a Quartz 2D image."
  },
  {
    "title": "init(cgImage:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519576-init",
    "html": "Parameters\nimage\n\nA Quartz 2D image (CGImage) object. For more information, see Quartz 2D Programming Guide and CGImage.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe image data is copied before control is returned to your game.\n\nSee Also\nTexture from Image\ninit(image: UIImage)\nCreate a new texture object from an image object."
  },
  {
    "title": "SpriteView.DebugOptions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/debugoptions",
    "html": "Topics\nType Aliases\ntypealias SpriteView.DebugOptions.ArrayLiteralElement\ntypealias SpriteView.DebugOptions.Element\ntypealias SpriteView.DebugOptions.RawValue\nInitializers\ninit()\nCreates an empty option set.\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: SpriteView.DebugOptions...)\nCreates a set containing the elements of the given array literal.\ninit(rawValue: Int)\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nlet rawValue: Int\nType Properties\nstatic let showsDrawCount: SpriteView.DebugOptions\nstatic let showsFPS: SpriteView.DebugOptions\nstatic let showsFields: SpriteView.DebugOptions\nstatic let showsNodeCount: SpriteView.DebugOptions\nstatic let showsPhysics: SpriteView.DebugOptions\nstatic let showsQuadCount: SpriteView.DebugOptions\nInstance Methods\nfunc contains(SpriteView.DebugOptions) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nfunc formIntersection(SpriteView.DebugOptions)\nRemoves all elements of this option set that are not also present in the given set.\nfunc formSymmetricDifference(SpriteView.DebugOptions)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nfunc formUnion(SpriteView.DebugOptions)\nInserts the elements of another set into this option set.\nfunc insert(SpriteView.DebugOptions) -> (inserted: Bool, memberAfterInsert: SpriteView.DebugOptions)\nAdds the given element to the option set if it is not already a member.\nfunc intersection(SpriteView.DebugOptions) -> SpriteView.DebugOptions\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc isDisjoint(with: SpriteView.DebugOptions) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: SpriteView.DebugOptions) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: SpriteView.DebugOptions) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: SpriteView.DebugOptions) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: SpriteView.DebugOptions) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc remove(SpriteView.DebugOptions) -> SpriteView.DebugOptions?\nRemoves the given element and all elements subsumed by it.\nfunc subtract(SpriteView.DebugOptions)\nRemoves the elements of the given set from this set.\nfunc subtracting(SpriteView.DebugOptions) -> SpriteView.DebugOptions\nReturns a new set containing the elements of this set that do not occur in the given set.\nfunc symmetricDifference(SpriteView.DebugOptions) -> SpriteView.DebugOptions\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(SpriteView.DebugOptions) -> SpriteView.DebugOptions\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: SpriteView.DebugOptions) -> SpriteView.DebugOptions?\nInserts the given element into the set.\nOperator Functions\nstatic func != (SpriteView.DebugOptions, SpriteView.DebugOptions) -> Bool\nRelationships\nConforms To\nOptionSet\nSee Also\nCreating a Sprite View\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, shouldRender: (TimeInterval) -> Bool)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, debugOptions: SpriteView.DebugOptions, shouldRender: (TimeInterval) -> Bool)\nstruct SpriteView.Options"
  },
  {
    "title": "init(scene:transition:isPaused:preferredFramesPerSecond:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/3592999-init",
    "html": "See Also\nCreating a Sprite View\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, shouldRender: (TimeInterval) -> Bool)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, debugOptions: SpriteView.DebugOptions, shouldRender: (TimeInterval) -> Bool)\nstruct SpriteView.Options\nstruct SpriteView.DebugOptions"
  },
  {
    "title": "particleBlendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397978-particleblendmode",
    "html": "Discussion\n\nThe default value is SKBlendMode.alpha.\n\nSee Also\nBlending Particles with the Framebuffer\nvar particleAlphaSequence: SKKeyframeSequence?\nThe sequence used to specify the alpha value of a particle over its lifetime.\nvar particleAlpha: CGFloat\nThe average starting alpha value for a particle.\nvar particleAlphaRange: CGFloat\nThe range of allowed random values for a particle’s starting alpha value.\nvar particleAlphaSpeed: CGFloat\nThe rate at which the alpha value of a particle changes per second."
  },
  {
    "title": "blendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/1459386-blendmode",
    "html": "Discussion\n\nThe default value is SKBlendMode.alpha."
  },
  {
    "title": "init(texture:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645815-init",
    "html": "Parameters\ntexture\n\nThe texture to reference for the definition's size and content.\n\nReturn Value\n\nA new tile definition.\n\nDiscussion\n\nThe size of the newly created tile definition will be the same as the texture used to initialize it."
  },
  {
    "title": "shader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/1459388-shader",
    "html": "Discussion\n\nThe default value is nil, meaning that default blending behavior executes. If a shader is specified, it is called when the rasterized image is blended into the parent’s framebuffer.\n\nSee Also\nApplying a Shader with an Effect Node\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute."
  },
  {
    "title": "filter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/1459392-filter",
    "html": "Discussion\n\nThe Core Image filter must have a single inputImage parameter and produce a single outputImage parameter. The default value is nil. If the value is nil and the effect node is enabled, no filtering takes place. However, its children are still rendered in a separate pass and blended to the parent’s framebuffer.\n\nIf you wish to use a Core Image filter that doesn't have an inputImage parameter, such as a sunbeams generator, you can subclass CIFilter and add an inputImage property. The input image's extent can be used to define properties such as radius on the filter. The following code creates a filter based on CISunbeamsGenerator which can be used as an effect node's filter:\n\nclass StarGenerator: CIFilter {    \n    var inputImage: CIImage?        \n    override var outputImage: CIImage? {        \n        guard let inputImage = inputImage else {            \n            return nil        \n        }                \n        let extent = inputImage.extent                \n        let center = CIVector(x: extent.midX, y: extent.midY)                \n        let starShineGenerator = CIFilter(            \n            name: \"CISunbeamsGenerator\",            \n            withInputParameters: [                \n                \"inputMaxStriationRadius\": 2,                \n                \"inputSunRadius\": extent.midX / 2,                \n            kCIInputCenterKey: center])                \n        return starShineGenerator!.outputImage?.cropping(to: extent)    \n    }\n}\n\n\nSee Also\nApplying Core Image Filters with an Effect Node\nApplying Special Effects to a Node's Children\nApply the Core Image suite of filters to child nodes of an effect node.\nvar shouldEnableEffects: Bool\nA Boolean value that determines whether the effect node applies the filter to its children as they are drawn.\nvar shouldCenterFilter: Bool\nA Boolean value that determines whether the effect node automatically sets the filter’s image center.\nRelated Documentation\nvar blendMode: SKBlendMode\nThe blend mode used to draw the node's contents into its parent’s framebuffer."
  },
  {
    "title": "init(textures:normalTextures:size:timePerFrame:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645814-init",
    "html": "Parameters\ntextures\n\nAn array of textures to reference for the definition's content.\n\nnormalTextures\n\nAn array of textures to reference for generating normals to simulate 3D lighting.\n\nsize\n\nThe size of the tile in points.\n\ntimePerFrame\n\nThe duration, in seconds, that each texture is displayed.\n\nReturn Value\n\nA new tile definition.\n\nSee Also\nCreating an Animated Tile\ninit(textures: [SKTexture], size: CGSize, timePerFrame: CGFloat)\nInitializes a new tile definition with an array of textures for animation."
  },
  {
    "title": "init(texture:normalTexture:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645778-init",
    "html": "Parameters\ntexture\n\nThe texture to reference for the definition's content.\n\nnormalTexture\n\nThe texture to reference for generating normals to simulate 3D lighting.\n\nsize\n\nThe size of the tile in points.\n\nReturn Value\n\nA new tile definition."
  },
  {
    "title": "shouldCenterFilter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/1459390-shouldcenterfilter",
    "html": "Discussion\n\nIf the value of this property is true and the filter has an inputCenter parameter, the effect node automatically sets the filter’s input center to the effect node’s origin. The default value is true.\n\nSee Also\nApplying Core Image Filters with an Effect Node\nApplying Special Effects to a Node's Children\nApply the Core Image suite of filters to child nodes of an effect node.\nvar filter: CIFilter?\nThe Core Image filter to apply.\nvar shouldEnableEffects: Bool\nA Boolean value that determines whether the effect node applies the filter to its children as they are drawn."
  },
  {
    "title": "init(name:type:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattribute/1643431-init",
    "html": "Parameters\nname\n\nThe name of the attribute.\n\ntype\n\nThe type of the attribute.\n\nReturn Value\n\nA new attribute object.\n\nDiscussion\n\nAttribute names are typically named with a preceding \"a\" and an underscore. The following code shows how to initialize an attribute named a_frequency which is of type SKAttributeType.float.\n\nlet attribute = SKAttribute(name: \"a_frequency\", \n                            type: SKAttributeType.float)\n"
  },
  {
    "title": "init(scene:transition:isPaused:preferredFramesPerSecond:options:shouldRender:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/3593000-init",
    "html": "See Also\nCreating a Sprite View\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, debugOptions: SpriteView.DebugOptions, shouldRender: (TimeInterval) -> Bool)\nstruct SpriteView.Options\nstruct SpriteView.DebugOptions"
  },
  {
    "title": "init(scene:transition:isPaused:preferredFramesPerSecond:options:debugOptions:shouldRender:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/3751723-init",
    "html": "See Also\nCreating a Sprite View\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, shouldRender: (TimeInterval) -> Bool)\nstruct SpriteView.Options\nstruct SpriteView.DebugOptions"
  },
  {
    "title": "SpriteView.Options | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview/options",
    "html": "Topics\nType Aliases\ntypealias SpriteView.Options.ArrayLiteralElement\ntypealias SpriteView.Options.Element\ntypealias SpriteView.Options.RawValue\nInitializers\ninit()\nCreates an empty option set.\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: SpriteView.Options...)\nCreates a set containing the elements of the given array literal.\ninit(rawValue: Int)\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nlet rawValue: Int\nType Properties\nstatic let allowsTransparency: SpriteView.Options\nstatic let ignoresSiblingOrder: SpriteView.Options\nstatic let shouldCullNonVisibleNodes: SpriteView.Options\nInstance Methods\nfunc contains(SpriteView.Options) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nfunc formIntersection(SpriteView.Options)\nRemoves all elements of this option set that are not also present in the given set.\nfunc formSymmetricDifference(SpriteView.Options)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nfunc formUnion(SpriteView.Options)\nInserts the elements of another set into this option set.\nfunc insert(SpriteView.Options) -> (inserted: Bool, memberAfterInsert: SpriteView.Options)\nAdds the given element to the option set if it is not already a member.\nfunc intersection(SpriteView.Options) -> SpriteView.Options\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc isDisjoint(with: SpriteView.Options) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: SpriteView.Options) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: SpriteView.Options) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: SpriteView.Options) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: SpriteView.Options) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc remove(SpriteView.Options) -> SpriteView.Options?\nRemoves the given element and all elements subsumed by it.\nfunc subtract(SpriteView.Options)\nRemoves the elements of the given set from this set.\nfunc subtracting(SpriteView.Options) -> SpriteView.Options\nReturns a new set containing the elements of this set that do not occur in the given set.\nfunc symmetricDifference(SpriteView.Options) -> SpriteView.Options\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(SpriteView.Options) -> SpriteView.Options\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: SpriteView.Options) -> SpriteView.Options?\nInserts the given element into the set.\nOperator Functions\nstatic func != (SpriteView.Options, SpriteView.Options) -> Bool\nRelationships\nConforms To\nOptionSet\nSee Also\nCreating a Sprite View\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, shouldRender: (TimeInterval) -> Bool)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, debugOptions: SpriteView.DebugOptions, shouldRender: (TimeInterval) -> Bool)\nstruct SpriteView.DebugOptions"
  },
  {
    "title": "particleScaleSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398073-particlescalespeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nScaling Particles by a Factor\nvar particleScale: CGFloat\nThe average initial scale factor of a particle.\nvar particleScaleRange: CGFloat\nThe range of allowed random values for a particle’s initial scale.\nvar particleScaleSequence: SKKeyframeSequence?\nThe sequence used to specify the scale factor of a particle over its lifetime."
  },
  {
    "title": "init(tileDefinition:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegroup/1643832-init",
    "html": "Parameters\ntileDefinition\n\nThe tile definition to place in a tile map.\n\nReturn Value\n\nA new tile group.\n\nSee Also\nCreating Tile Groups\nCreating Tile Groups Programmatically\nPaint tiles on a map by putting tile definitions in a group that you create in code.\ninit(rules: [SKTileGroupRule])\nCreates and initializes a tile group with the specified tile group rules."
  },
  {
    "title": "particleColorBlendFactorSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397980-particlecolorblendfactorsequence",
    "html": "Discussion\n\nThe default value is nil. If a non-nil value is specified, then the particleColorBlendFactor, particleColorBlendFactorRange, and particleColorBlendFactorSpeed properties are ignored. Instead, the sequence is used to specify the color blend factor.\n\nSee Also\nControlling How the Texture is Blended with Particle Color\nvar particleColorBlendFactor: CGFloat\nThe average starting value for the color blend factor.\nvar particleColorBlendFactorRange: CGFloat\nThe range of allowed random values for a particle’s starting color blend factor.\nvar particleColorBlendFactorSpeed: CGFloat\nThe rate at which the color blend factor changes per second."
  },
  {
    "title": "particleColorRedSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398041-particlecolorredspeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second."
  },
  {
    "title": "shouldRasterize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/1459381-shouldrasterize",
    "html": "Discussion\n\nIf the value of this property is true, the effect node caches the filtered image for use in future frames. If the value is false, then SpriteKit discards the rendered image and redraws it from scratch the next time the node is rendered. The default value is false. Caching the rendered image uses more memory and may take more time to render. However, if the effect node’s descendants rarely change, caching can improve performance.\n\nWhen caching is enabled, changes to the effect node’s children trigger updates to the cached image in the next frame of animation. However, changing the filter’s properties does not.\n\nSee Also\nFlattening an Effect Node's Child Tree for Performance Improvement\nImproving the Performance of Static Content\nFlatten a portion of your node hierarchy to a single texture to improve performance."
  },
  {
    "title": "Improving the Performance of Static Content | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/improving_the_performance_of_static_content",
    "html": "Overview\n\nAn effect node normally discards its private framebuffer after rendering is complete. Rendering the content is necessary because it typically changes every frame. However, if the content is static, discarding the rendered framebuffer is unnecessary, and it might make more sense to keep it.\n\nIf the content of the effect node is static, set the node’s shouldRasterize property to true. Setting this property causes the following changes in behavior:\n\nThe framebuffer is not discarded at the end of rasterization. This also means that more memory is being used by the effect node, and rendering may take slightly longer.\n\nWhen a new frame is rendered, the framebuffer is rendered only if the contents of the effect node’s descendants have changed.\n\nIf the effect node has a Core Image filter, changes to its properties no longer automatically update the framebuffer. You can force it to be updated by setting the shouldRasterize property to false.\n\nYou can use effect nodes to cache static content even when you aren’t applying a filter to the rendered image. This technique can be useful when the contents of a subtree are static and expensive to render.\n\nSee Also\nFlattening an Effect Node's Child Tree for Performance Improvement\nvar shouldRasterize: Bool\nA Boolean value that indicates whether the results of rendering the child nodes should be cached."
  },
  {
    "title": "value(forAttributeNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/2715844-value",
    "html": "Parameters\nkey\n\nThe attribute name.\n\nReturn Value\n\nAn attribute value object containing the scalar or vector value or nil if no such attribute exists.\n\nSee Also\nApplying a Shader with an Effect Node\nvar shader: SKShader?\nA custom shader that is called when the effect node is blended into the parent’s framebuffer.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader."
  },
  {
    "title": "setValue(_:forAttribute:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/2715853-setvalue",
    "html": "Parameters\nvalue\n\nAn attribute value object containing the scalar or vector value to set in the attached shader.\n\nkey\n\nThe attribute name.\n\nSee Also\nApplying a Shader with an Effect Node\nvar shader: SKShader?\nA custom shader that is called when the effect node is blended into the parent’s framebuffer.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute."
  },
  {
    "title": "Warping SpriteKit Content By Using an Effect Node | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/warping_spritekit_content_by_using_an_effect_node",
    "html": "Overview\n\nIf you want to warp a node that doesn't conform to SKWarpable, you can add it as a child to an effect node that is warped. As an implementor of SKWarpable, effect node inherits the SKWarpGeometry property that you assign one of the SKWarpGeometry types to then warp the effect node's children.\n\nWarp Text By Using an Effect Node\n\nSKLabelNode is one such class that doesn't conform to SKWarpable. The following code shows how you can warp a label node by adding it as a child to a SKEffectNode and assign the effect node a SKWarpGeometryGrid that pulls out the corners horizontally and stretches the center vertically.\n\nlet labelNode = SKLabelNode(text: \"SpriteKit\")\nlabelNode.fontColor = UIColor.blue\nlabelNode.fontSize = 144\n     \nlet effectNode = SKEffectNode()\neffectNode.addChild(labelNode)\n     \nlet destinationPositions: [vector_float2] = [\n    vector_float2(-0.1, 1), vector_float2(0.5, 1.3), vector_float2(1.1, 1),\n    vector_float2(0.1, 0.5), vector_float2(0.5, 0.5), vector_float2(0.9, 0.5),\n    vector_float2(-0.1, 0), vector_float2(0.5, -0.3), vector_float2(1.1, 0)\n]\n     \nlet warpGeometryGrid = SKWarpGeometryGrid(columns: 2,\n                                          rows: 2)\n     \neffectNode.warpGeometry = warpGeometryGrid.replacingByDestinationPositions(positions: destinationPositions)\n\n\nThe following image shows the warped label."
  },
  {
    "title": "attributeValues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/2715848-attributevalues",
    "html": "Discussion\n\nAll nodes have their own copy of an attribute value and therefore the attribute values can be different per-node across the same SKShader. If instead you need all nodes to share the same value, use SKUniform. Uniforms can change values every frame, but uniforms cannot vary per-node like attributes can.\n\nSee Also\nApplying a Shader with an Effect Node\nvar shader: SKShader?\nA custom shader that is called when the effect node is blended into the parent’s framebuffer.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute."
  },
  {
    "title": "shouldEnableEffects | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/1459385-shouldenableeffects",
    "html": "Discussion\n\nIf the value of this property is true, the effect node applies the filter and blends the results. If the value is false, the effect node is ignored and its children are rendered normally. The default value is false.\n\nSee Also\nApplying Core Image Filters with an Effect Node\nApplying Special Effects to a Node's Children\nApply the Core Image suite of filters to child nodes of an effect node.\nvar filter: CIFilter?\nThe Core Image filter to apply.\nvar shouldCenterFilter: Bool\nA Boolean value that determines whether the effect node automatically sets the filter’s image center.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "Applying Special Effects to a Node's Children | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode/applying_special_effects_to_a_node_s_children",
    "html": "Overview\n\nIn the example image below, the effect node’s children are two sprites that provide lighting information. The effect node accumulates the effects of these lights, applies a blur filter to soften the resulting image, and uses a multiply blend mode to apply this lighting to a texture.\n\nImportant\n\nAny Core Image filter that you use must be able to produce a single output image from a single input image.\n\nHereʼs how the scene generates this lighting effect:\n\nThe scene has two children. The first is a textured sprite that represents the ground. The second is an effect node to apply lighting.\n\nThe effect nodeʼs children are sprite nodes rendered using an additive blend mode.\n\nThe effect node includes a filter effect to soften the lighting.\n\nThe effect node uses a multiplication blend mode to apply its lighting effect to the sceneʼs framebuffer.\n\nThe following code demonstrates an implementation of this technique:\n\nlet lightingNode = SKEffectNode()\n\n\nlet light = SKSpriteNode(texture: lightTexture)\nlight.blendMode = .add\n...\nlightingNode.addChild(light)\n\n\nlet blurFilter = CIFilter(name: \"CIBoxBlur\",\nwithInputParameters: [\"inputRadius\": 20])\n\n\nlightingNode.filter = blurFilter\n\n\nlightingNode.blendMode = .multiply\n\n\nSee Also\nApplying Core Image Filters with an Effect Node\nvar filter: CIFilter?\nThe Core Image filter to apply.\nvar shouldEnableEffects: Bool\nA Boolean value that determines whether the effect node applies the filter to its children as they are drawn.\nvar shouldCenterFilter: Bool\nA Boolean value that determines whether the effect node automatically sets the filter’s image center."
  },
  {
    "title": "init(texture:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645787-init",
    "html": "Parameters\ntexture\n\nThe texture to reference for the definition's content.\n\nsize\n\nThe size of the tile in points.\n\nReturn Value\n\nA new tile definition."
  },
  {
    "title": "init(textures:size:timePerFrame:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645776-init",
    "html": "Parameters\ntextures\n\nAn array of textures to reference for the definition's size and content.\n\nsize\n\nThe size of the tile in points.\n\ntimePerFrame\n\nThe duration, in seconds, that each texture is displayed.\n\nReturn Value\n\nA new tile definition.\n\nSee Also\nCreating an Animated Tile\ninit(textures: [SKTexture], normalTextures: [SKTexture], size: CGSize, timePerFrame: CGFloat)\nInitializes a new tile definition with arrays of textures and normal textures for animation."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645779-name",
    "html": "See Also\nReading or Adjusting a Tile's Instance Properties\nvar placementWeight: Int\nThe placement weight of the tile definition.\nvar size: CGSize\nThe size of the tile definition in points."
  },
  {
    "title": "flipHorizontally | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645804-fliphorizontally",
    "html": "See Also\nFlipping a Tile Vertically or Horizontally\nvar flipVertically: Bool\nA Boolean that flips the definition’s image horizontally."
  },
  {
    "title": "timePerFrame | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645811-timeperframe",
    "html": "See Also\nConfigure Animated Tile Properties\nvar textures: [SKTexture]\nAn array of SKTexture objects that defines the tile definition object's content.\nvar normalTextures: [SKTexture]\nAn array of SKTexture objects used to generate the normals for the tile to simulate 3D lighting."
  },
  {
    "title": "placementWeight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645820-placementweight",
    "html": "Discussion\n\nThis value is used to determine how likely this tile definition is to be chosen for placement when a SKTileGroupRule has multiple tile definitions assigned to it. A higher value relative to the other definitions assigned to the rule make it more likely for this definition to be selected; lower values make it less likely. Defaults to 1. When set to 0, the definition will never be chosen as long as there is at least one other definition with a placementWeight above 0.\n\nSee Also\nReading or Adjusting a Tile's Instance Properties\nvar name: String?\nA name associated with the tile definition.\nvar size: CGSize\nThe size of the tile definition in points."
  },
  {
    "title": "userData | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645813-userdata",
    "html": "Discussion\n\nYou use this property to store your own data in a tile definition. For example, you might use this property to specify whether this tile is a platform that a player can land on.\n\nSpriteKit doesn't do anything with this data. However, the data is archived when the tile definition is archived."
  },
  {
    "title": "init(source:uniforms:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477555-init",
    "html": "Parameters\nsource\n\nA string that holds the initial source for the shader.\n\nuniforms\n\nA list of uniforms to add to the shader object.\n\nReturn Value\n\nAn initialized shader object.\n\nSee Also\nCreating a Shader\nCreating a Custom Fragment Shader\nWrite a fragment shader using the set of SpriteKit-exposed symbols, and supply it with custom data.\ninit(fileNamed: String)\nCreates a new shader object by loading the source for a fragment shader from a file stored in the app’s bundle.\ninit(source: String)\nInitializes a new shader object using the specified source code."
  },
  {
    "title": "size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645790-size",
    "html": "See Also\nReading or Adjusting a Tile's Instance Properties\nvar name: String?\nA name associated with the tile definition.\nvar placementWeight: Int\nThe placement weight of the tile definition."
  },
  {
    "title": "init(fileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477557-init",
    "html": "Parameters\nname\n\nThe name of the fragment shader to load. The file must be present in your app bundle with the same name and a .fsh file extension.\n\nReturn Value\n\nA newly initialized shader object whose initial source is loaded from the shader file.\n\nSee Also\nCreating a Shader\nCreating a Custom Fragment Shader\nWrite a fragment shader using the set of SpriteKit-exposed symbols, and supply it with custom data.\ninit(source: String, uniforms: [SKUniform])\nInitializes a new shader object using the specified source and uniform data.\ninit(source: String)\nInitializes a new shader object using the specified source code.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "Creating a Custom Fragment Shader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/creating_a_custom_fragment_shader",
    "html": "Overview\n\nYour fragment shader should be written in the OpenGL ES 2.0 shading language. SpriteKit automatically does the necessary work to make sure this shader compiles correctly in both iOS and macOS. The shader object compiles your shader by appending the source code you provide to a preamble created by SpriteKit. This preamble declares all of the standard SpriteKit variables and functions, including declarations for any uniforms you have associated with the shader object.\n\nUse SpriteKit-Provided Data in a Shader\n\nThe following table describes the SpriteKit symbols made available to your shader.\n\nSymbol declaration\n\n\t\n\nType\n\n\t\n\nDescription\n\n\n\n\nsampler2D u_texture;\n\n\t\n\nUniform\n\n\t\n\nA sampler associated with the texture used to render the node.\n\n\n\n\nfloat u_time;\n\n\t\n\nUniform\n\n\t\n\nThe elapsed time in the simulation.\n\n\n\n\nfloat u_path_length;\n\n\t\n\nUniform\n\n\t\n\nProvided only when the shader is attached to an SKShapeNode object’s strokeShader property. This value represents the total length of the path, in points.\n\n\n\n\nvec2 v_tex_coord;\n\n\t\n\nVarying\n\n\t\n\nThe coordinates used to access the texture. These coordinates are normalized so that the point (0.0,0.0) is in the bottom-left corner of the texture.\n\n\n\n\nvec4 v_color_mix;\n\n\t\n\nVarying\n\n\t\n\nThe premultiplied color value for the node being rendered.\n\n\n\n\nfloat v_path_distance;\n\n\t\n\nVarying\n\n\t\n\nProvided only when the shader is attached to an SKShapeNode object’s strokeShader property. This value represents the distance along the path in points.\n\n\n\n\nvec4 SKDefaultShading()\n\n\t\n\nFunction\n\n\t\n\nA function that provides the default behavior used by SpriteKit.\n\nProvide Custom Per-Frame Data to a Shader\n\nTo make a global variable available to your shader, you create an SKUniform and add it to the shader's uniforms array. Uniforms can be modified at any time on the CPU, but they're constant on the GPU. Therefore, uniforms are the way to provide your shader with per-frame data.\n\nThe following code shows how to pass a size value to a shader by using a uniform.\n\nlet uniformBasedShader = SKShader(fileNamed: \"UsingUniform.fsh\")\n \nlet sprite = SKSpriteNode()\nsprite.shader = uniformBasedShader\n \t \nlet spriteSize = vector_float2(Float(sprite.frame.size.width),\n                               Float(sprite.frame.size.height))\nuniformBasedShader.uniforms = [    \n    SKUniform(name: \"u_sprite_size\", vectorFloat2: spriteSize)\n]\n\n\nBecause uniforms are shared across executions in a given frame, every node that executes uniformBasedShader in the example above will read the same value for u_sprite_size.\n\nProvide Custom Per-Primitive Data to a Shader\n\nTo associate shader variables with specific nodes, you use SKAttribute. Using attributes rather than uniforms allows a single SKShader to be shared between nodes, each one defining their own value for a shader variable. The following code demonstrates attributes by passing the size of a sprite to a shader as an attribute.\n\nlet attributeBasedShader = SKShader(fileNamed: \"UsingAttributes.fsh\")\nattributeBasedShader.attributes = [\n    SKAttribute(name: \"a_sprite_size\", type: .vectorFloat2)\n]\n \nlet sprite = SKSpriteNode()\nsprite.shader = attributeBasedShader\n \nlet spriteSize = vector_float2(Float(sprite.frame.size.width),\n                               Float(sprite.frame.size.height))\nsprite.setValue(SKAttributeValue(vectorFloat2: spriteSize),\n                forAttribute: \"a_sprite_size\")\n\n\nBecause an attribute defines a shader variable on the sprite node and not the shader object, every execution of attributeBasedShader will read its own value of a_sprite_size.\n\nDefine a Function Body\n\nYour shader should define a main() function. This function must set the gl_FragColor variable to a color value to use in the blend stage. Typically, the color value you return in this variable should already be premultiplied by the fragment’s alpha value.\n\nThe following code shows a very simple fragment shader that provides the default shading behavior.\n\nvoid main()\n{\n   gl_FragColor = SKDefaultShading();\n}\n\nSee Also\nCreating a Shader\ninit(fileNamed: String)\nCreates a new shader object by loading the source for a fragment shader from a file stored in the app’s bundle.\ninit(source: String, uniforms: [SKUniform])\nInitializes a new shader object using the specified source and uniform data.\ninit(source: String)\nInitializes a new shader object using the specified source code."
  },
  {
    "title": "init(source:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477571-init",
    "html": "Parameters\nsource\n\nA string that holds the initial source for the shader.\n\nReturn Value\n\nAn initialized shader object.\n\nSee Also\nCreating a Shader\nCreating a Custom Fragment Shader\nWrite a fragment shader using the set of SpriteKit-exposed symbols, and supply it with custom data.\ninit(fileNamed: String)\nCreates a new shader object by loading the source for a fragment shader from a file stored in the app’s bundle.\ninit(source: String, uniforms: [SKUniform])\nInitializes a new shader object using the specified source and uniform data."
  },
  {
    "title": "addUniform(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477561-adduniform",
    "html": "Parameters\nuniform\n\nThe new uniform object to add. The uniform object’s name must not already be in use by another uniform attached to the shader.\n\nDiscussion\n\nThe uniform variable is automatically accessible inside your shader; do not add a declaration for it in your shader’s source code. The uniform must be accessed in the fragment shader.\n\nSee Also\nProviding Uniform Data to a Shader\nfunc removeUniformNamed(String)\nRemoves a uniform from the shader.\nvar uniforms: [SKUniform]\nThe list of uniforms associated with the shader.\nfunc uniformNamed(String) -> SKUniform?\nReturns the uniform object corresponding to a particular uniform variable."
  },
  {
    "title": "removeUniformNamed(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477553-removeuniformnamed",
    "html": "Parameters\nname\n\nThe name of the uniform to remove.\n\nDiscussion\n\nIf a uniform with that name does not exist in the shader, nothing happens.\n\nSee Also\nProviding Uniform Data to a Shader\nfunc addUniform(SKUniform)\nAdds a uniform to the shader.\nvar uniforms: [SKUniform]\nThe list of uniforms associated with the shader.\nfunc uniformNamed(String) -> SKUniform?\nReturns the uniform object corresponding to a particular uniform variable."
  },
  {
    "title": "uniformNamed(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477567-uniformnamed",
    "html": "Parameters\nname\n\nThe name of the uniform to search for.\n\nReturn Value\n\nThe uniform object corresponding to the name, or nil if that uniform cannot be found.\n\nSee Also\nProviding Uniform Data to a Shader\nfunc addUniform(SKUniform)\nAdds a uniform to the shader.\nfunc removeUniformNamed(String)\nRemoves a uniform from the shader.\nvar uniforms: [SKUniform]\nThe list of uniforms associated with the shader."
  },
  {
    "title": "uniforms | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477565-uniforms",
    "html": "Discussion\n\nThis property is not read-only, so you can also use it to provide all of the uniforms in a single operation. Each of the uniforms should be uniquely named.\n\nSee Also\nProviding Uniform Data to a Shader\nfunc addUniform(SKUniform)\nAdds a uniform to the shader.\nfunc removeUniformNamed(String)\nRemoves a uniform from the shader.\nfunc uniformNamed(String) -> SKUniform?\nReturns the uniform object corresponding to a particular uniform variable."
  },
  {
    "title": "attributes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1645287-attributes",
    "html": "Discussion\n\nThis property is not read-only, so you can also use it to provide all of the attributes in a single operation. Each of the attributes should be uniquely named."
  },
  {
    "title": "source | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/1477544-source",
    "html": "Discussion\n\nThe source code for a shader object can be updated at runtime. However, recompiling the fragment shader can be an expensive operation."
  },
  {
    "title": "Executing Shaders in Metal and OpenGL | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader/executing_shaders_in_metal_and_opengl",
    "html": "Overview\n\nOn devices that support it, the GLSL code you provide to SKShader is automatically converted to Metal shading language and run on a Metal renderer. On older devices, shader code is run in OpenGL. It's important to be mindful of this for debugging purposes because some issues may appear in one renderer but not the other.\n\nYou can specify which renderer your device uses—for example, forcing a Metal-enabled device to use SpriteKit's OpenGL renderer for debugging purposes—by adding a PrefersOpenGL to your app's Info.plist key with a value of true. See Requesting the OpenGL Renderer for more information.\n\nImportant\n\nTo ensure compatibility across all devices, test your shader code with and without the PrefersOpenGL key, to be certain it compiles in both environments."
  },
  {
    "title": "Creating Tile Groups Programmatically | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegroup/creating_tile_groups_programmatically",
    "html": "Overview\n\nTo paint tiles on a map using a tile group, you call fill(with:) on the group. The fill behaviors you use depend on the type of group you make:\n\nGroup type\n\n\t\n\nFill behavior\n\n\n\n\nSingle tile\n\n\t\n\nRepeats the single center tile.\n\n\n\n\nMultiple tiles without adjacency rules\n\n\t\n\nChooses randomly among the multiple center tiles, abiding by the placement weights you choose.\n\n\n\n\nMultiple tiles with adjacency rules\n\n\t\n\nRepeats the center tile and borders all of its edges using the peripheral adjacency tiles you define.\n\nCreate a Tile Group with a Single Tile\n\nAlthough a tile group is a container for multiple tiles, you can create one with a single tile, if you wish. Use the init(tileDefinition:) initializer, as shown in the following code.\n\nlet backgroundTexture = SKTexture(imageNamed: \"BG.png\")\nlet backgroundDefinition = SKTileDefinition(texture: backgroundTexture)\nlet backgroundGroup = SKTileGroup(tileDefinition: backgroundDefinition)\n\n\nCreate a Heterogenous Tile Group with Random Placement\n\nFor a tile group with more than one texture, use the init(rules:) initializer. The following code shows how you can create a tile group containing two definitions—one based on an image named RED.png and the other on an image named BLUE.png.\n\nlet redTexture = SKTexture(imageNamed: \"RED.png\")\nlet redDefinition = SKTileDefinition(texture: redTexture)\nredDefinition.placementWeight = 3\n \nlet blueTexture = SKTexture(imageNamed: \"BLUE.png\")\nlet blueDefinition = SKTileDefinition(texture: blueTexture)\nblueDefinition.placementWeight = 1\n \nlet redBlueRule = SKTileGroupRule(adjacency: .adjacencyAll,                                                                    tileDefinitions: [redDefinition, blueDefinition])\nlet group = SKTileGroup(rules: [redBlueRule])\n\n\nWhen a tile map node is supplied with a tile set using this group and its tiles are filled with the fill(with:) method, the placement weights control the random assignment of tiles. In this case, there are three times more red than blue tiles.\n\nCreate a Tile Group Using Adjacency Rules\n\nTo create a tile group that uses adjacency, you need to create a set of rules for each of the adjacency values. For a grid-based layout, you need 13 rules, as shown in the following illustration:\n\nTo create the tile group programmatically, create definitions and rules for each adjacency:\n\nlet centerTileDefintion = SKTileDefinition(texture: SKTexture(imageNamed: \"CENTER.png\"))\nlet centerRule = SKTileGroupRule(adjacency: .adjacencyAll,\n                                 tileDefinitions: [ centerTileDefintion ])\n \nlet upEdgeDefinition = SKTileDefinition(texture: SKTexture(imageNamed: \"N.png\"))\nlet upEdgeRule = SKTileGroupRule(adjacency: .adjacencyUpEdge,\n                                 tileDefinitions: [ upEdgeDefinition ])\n \nlet downEdgeDefinition = SKTileDefinition(texture: SKTexture(imageNamed: \"S.png\"))\nlet downEdgeRule = SKTileGroupRule(adjacency: .adjacencyDownEdge,\n                                   tileDefinitions: [ downEdgeDefinition ])\n \n\n\n[...]\n\n\nThe 13 rules are used to make a tile group:\n\nlet group = SKTileGroup(rules: [centerRule, upEdgeRule, downEdgeRule, ...]\n\n\nWith automapping enabled, when an individual tile is placed on the map using setTileGroup(_:forColumn:row:), SpriteKit also sets the tile definitions for the surrounding tiles based on the group's adjacency rules.\n\nSee Also\nCreating Tile Groups\ninit(tileDefinition: SKTileDefinition)\nCreates and initializes a simple tile group with a single tile definition.\ninit(rules: [SKTileGroupRule])\nCreates and initializes a tile group with the specified tile group rules."
  },
  {
    "title": "particleScaleRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397990-particlescalerange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the initial scale of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nScaling Particles by a Factor\nvar particleScale: CGFloat\nThe average initial scale factor of a particle.\nvar particleScaleSpeed: CGFloat\nThe rate at which a particle’s scale factor changes per second.\nvar particleScaleSequence: SKKeyframeSequence?\nThe sequence used to specify the scale factor of a particle over its lifetime."
  },
  {
    "title": "particleSpeedRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398045-particlespeedrange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the speed of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nControlling Particle Velocity and Acceleration\nvar particleSpeed: CGFloat\nThe average initial speed of a new particle, in points per second.\nvar emissionAngle: CGFloat\nThe average initial direction of a particle, expressed as an angle in radians.\nvar emissionAngleRange: CGFloat\nThe range of allowed random values for a particle’s initial direction, expressed as an angle in radians.\nvar xAcceleration: CGFloat\nThe acceleration to apply to a particle’s horizontal velocity.\nvar yAcceleration: CGFloat\nThe acceleration to apply to a particle’s vertical velocity.\nvar particleZPositionSpeed: CGFloat\nThe speed at which the particle’s depth changes."
  },
  {
    "title": "particlePositionRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397972-particlepositionrange",
    "html": "Discussion\n\nThe default value is (0.0,0.0). If a component is non-zero, the same component of a particle’s position is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nControlling Particle Position\nvar particlePosition: CGPoint\nThe average starting position for a particle.\nvar particleZPosition: CGFloat\nThe average starting depth of a particle.\nvar particleZPositionRange: CGFloat\nThe range of allowed random values for a particle’s depth."
  },
  {
    "title": "init(rules:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegroup/1643839-init",
    "html": "Parameters\nrules\n\nThe tile group rules to determine tile placement.\n\nReturn Value\n\nA new tile group.\n\nSee Also\nCreating Tile Groups\nCreating Tile Groups Programmatically\nPaint tiles on a map by putting tile definitions in a group that you create in code.\ninit(tileDefinition: SKTileDefinition)\nCreates and initializes a simple tile group with a single tile definition."
  },
  {
    "title": "anchorPoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519877-anchorpoint",
    "html": "Discussion\n\nYou specify the value for this property in the unit coordinate space. The default value is (0.5,0.5), which means that the sprite is centered on its position.\n\nSee Also\nSetting a Sprite's Size and Position\nUsing the Anchor Point to Move a Sprite\nLearn how the anchor point affects a sprite's position.\nvar size: CGSize\nThe dimensions of the sprite, in points.\nfunc scale(to: CGSize)\nScales the sprite node to a specified size."
  },
  {
    "title": "particleRenderOrder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397986-particlerenderorder",
    "html": "Discussion\n\nThe default value is SKParticleRenderOrder.oldestLast.\n\nSee Also\nControlling the Rendering Order of an Emitter's Particles\nenum SKParticleRenderOrder\nThe order to use when the emitter’s particles are rendered."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegroup/1643893-name",
    "html": "See Also\nAccessing or Setting a Tile Group's Properties\nvar rules: [SKTileGroupRule]\nAn array of SKTileGroupRule objects that the tile group uses to determine tile placement."
  },
  {
    "title": "particleBirthRate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398039-particlebirthrate",
    "html": "Discussion\n\nThe number of particles generated by the emitter every second. The default value is 0.0.\n\nSee Also\nControlling When Particles Are Created\nfunc advanceSimulationTime(TimeInterval)\nAdvances the emitter particle simulation.\nfunc resetSimulation()\nRemoves all existing particles and restarts the simulation.\nvar numParticlesToEmit: Int\nThe number of particles the emitter should emit before stopping."
  },
  {
    "title": "rules | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegroup/1643867-rules",
    "html": "See Also\nAccessing or Setting a Tile Group's Properties\nvar name: String?\nThe receiver's name."
  },
  {
    "title": "shader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398069-shader",
    "html": "Discussion\n\nThe default value is nil. If a shader is specified, then the shader is used to determine the output colors for any of the emitter’s particles.\n\nSee Also\nTaking Full Control of Particle Drawing with a Shader\nGetting Started with Particle Shaders\nProvide custom shader code to alter a particle's look.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute."
  },
  {
    "title": "particleAction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397970-particleaction",
    "html": "Discussion\n\nAlthough you do not have direct access to the particles created by SpriteKit, you can specify an action that all particles execute. Whenever a new particle is created, the emitter tells the particle to run that action. You can use actions to create very sophisticated behaviors.\n\nFor the purpose of using actions on particles, you can treat the particle as if it were a normal node. This means you can perform other interesting tricks, such as animating the particle’s textures.\n\nTip\n\nAdding complex actions to particles can severely impact the performance of the particle emitter. Also, because the particles do not exist as an explicit node that you can manipulate, you cannot remove the actions from existing particles.\n\nSee Also\nAnimating Particles\nAnimating Particle Properties Across Disparate Values\nSupply keyframe sequences to do linear or nonlinear particle animations."
  },
  {
    "title": "Getting Started with Particle Shaders | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/getting_started_with_particle_shaders",
    "html": "Overview\n\nUse the shader property of an emitter node to change the appearance of a texture with a custom OpenGL ES fragment shader embedded within an SKShader. Custom shaders offer almost limitless possibilities, from adding blurs and color treatments to textures, to generating imagery such as random noise.\n\nThe following code shows a custom shader that renders particles with a radial gradient. The center of each particle is opaque white and the edges are transparent black.\n\nlet emitter = SKEmitterNode()\n    \nlet radialGradientShader = SKShader(source: \"void main() {\" +\n    \"    vec2 coord = (v_tex_coord - 0.5) * 2.0;\" +\n    \"    gl_FragColor = vec4(1.0 - length(coord));\" +\n    \"}\")  \n      \nemitter.shader = radialGradientShader\n\n\nSee Also\nTaking Full Control of Particle Drawing with a Shader\nvar shader: SKShader?\nA custom shader used to determine how particles are rendered.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute."
  },
  {
    "title": "Animating Particle Properties Across Disparate Values | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/animating_particle_properties_across_disparate_values",
    "html": "Overview\n\nAn SKKeyframeSequence object enables you to specify multiple values for an emitter node's properties over a specific time period. The property values you choose may be arbitrary, which results in your ability to graph those property changes linearly or nonlinearly over time.\n\nWhen you use a sequence, the values are not randomized. Instead, the sequence specifies all of the values of the property. Each keyframe value includes a value object and a timestamp. The timestamps are specified in a range from 0 to 1.0, where 0 represents the birth of the particle and 1.0 represents its death.\n\nThe properties for which SKEmitterNode offers a keyframe sequence are:\n\nProperty\n\n\t\n\nSpecifies\n\n\t\n\nExample use\n\n\n\n\nparticleColorSequence\n\n\t\n\nA sequence of arbitrary colors a particle should reflect over its lifetime.\n\n\t\n\nEmbers from a fire might specify the color sequence (white, yellow, orange, and brown) to appear hot, and then cool.\n\n\n\n\nparticleColorBlendFactorSequence\n\n\t\n\nA sequence of color blend factors a particle should apply over its lifetime.\n\n\t\n\nEmbers from a fire might specify the color blend factor sequence (0, 1, 0, 1, ... etc.) to simulate flickering.\n\n\n\n\nparticleScaleSequence\n\n\t\n\nA sequence of sizes of a particle over its lifetime.\n\n\t\n\nBalloons might use the scale sequence (0.1, 1, 1, 1, 0.1) to simulate inflation, and flying for some time before deflating.\n\n\n\n\nparticleAlphaSequence\n\n\t\n\nA sequence of levels of transparency a particle undergoes over its lifetime.\n\n\t\n\nFireflies might specify a disparate sequence of alpha values to simulate random lighting patterns as they travel.\n\nThe following code demonstrates using particleScaleSequence to animate the scale of an emitter node's particles over their lifetime. Initially, the particles' scale is 0.2 and then increases to 0.7 one-quarter of the way through the sequence. Three-quarters of the way through the sequence, the scale reaches its minimum size, 0.1. It remains at this size until it dies.\n\nlet scaleSequence = SKKeyframeSequence(keyframeValues: [0.2, 0.7, 0.1],\n                                       times: [0.0, 0.250, 0.75])\nmyEmitter.particleScaleSequence = scaleSequence\n\nSee Also\nAnimating Particles\nvar particleAction: SKAction?\nAn action executed by new particles."
  },
  {
    "title": "particleAlphaSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398021-particlealphaspeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nBlending Particles with the Framebuffer\nvar particleBlendMode: SKBlendMode\nThe blending mode used to blend particles into the framebuffer.\nvar particleAlphaSequence: SKKeyframeSequence?\nThe sequence used to specify the alpha value of a particle over its lifetime.\nvar particleAlpha: CGFloat\nThe average starting alpha value for a particle.\nvar particleAlphaRange: CGFloat\nThe range of allowed random values for a particle’s starting alpha value."
  },
  {
    "title": "particleAlphaSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398057-particlealphasequence",
    "html": "Discussion\n\nThe default value is nil. If a non-nil value is specified, then the particleAlpha, particleAlphaRange, and particleAlphaSpeed properties are ignored. Instead, the sequence is used to specify the alpha value.\n\nSee Also\nBlending Particles with the Framebuffer\nvar particleBlendMode: SKBlendMode\nThe blending mode used to blend particles into the framebuffer.\nvar particleAlpha: CGFloat\nThe average starting alpha value for a particle.\nvar particleAlphaRange: CGFloat\nThe range of allowed random values for a particle’s starting alpha value.\nvar particleAlphaSpeed: CGFloat\nThe rate at which the alpha value of a particle changes per second."
  },
  {
    "title": "fieldBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398006-fieldbitmask",
    "html": "Discussion\n\nWhen a particle is inside the region of a SKFieldNode object, that field node’s categoryBitMask property is compared to the emitter’s fieldBitMask property by performing a logical AND operation. If the result is a non-zero value, then the field node’s effect is applied to the particle as if it had a physics body. The physics body is assumed to have a mass of 1.0 and a charge of 1.0\n\nThe default value is 0x00000000 (all bits cleared)."
  },
  {
    "title": "particleAlphaRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398031-particlealpharange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the initial alpha value of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nBlending Particles with the Framebuffer\nvar particleBlendMode: SKBlendMode\nThe blending mode used to blend particles into the framebuffer.\nvar particleAlphaSequence: SKKeyframeSequence?\nThe sequence used to specify the alpha value of a particle over its lifetime.\nvar particleAlpha: CGFloat\nThe average starting alpha value for a particle.\nvar particleAlphaSpeed: CGFloat\nThe rate at which the alpha value of a particle changes per second."
  },
  {
    "title": "particleAlpha | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397988-particlealpha",
    "html": "Discussion\n\nThe particle alpha value is equivalent to the alpha property of the SKNode class. The alpha component of the color that results from the texture and color blending state is multiplied by a particle’s alpha value. The resulting particle color is then blended with the parent’s framebuffer. The default value is 1.0.\n\nSee Also\nBlending Particles with the Framebuffer\nvar particleBlendMode: SKBlendMode\nThe blending mode used to blend particles into the framebuffer.\nvar particleAlphaSequence: SKKeyframeSequence?\nThe sequence used to specify the alpha value of a particle over its lifetime.\nvar particleAlphaRange: CGFloat\nThe range of allowed random values for a particle’s starting alpha value.\nvar particleAlphaSpeed: CGFloat\nThe rate at which the alpha value of a particle changes per second."
  },
  {
    "title": "particleColorBlendFactorSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398037-particlecolorblendfactorspeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nControlling How the Texture is Blended with Particle Color\nvar particleColorBlendFactorSequence: SKKeyframeSequence?\nThe sequence used to specify the color blend factor of a particle over its lifetime.\nvar particleColorBlendFactor: CGFloat\nThe average starting value for the color blend factor.\nvar particleColorBlendFactorRange: CGFloat\nThe range of allowed random values for a particle’s starting color blend factor."
  },
  {
    "title": "particleColorBlendFactorRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398047-particlecolorblendfactorrange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the initial color blend factor of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nControlling How the Texture is Blended with Particle Color\nvar particleColorBlendFactorSequence: SKKeyframeSequence?\nThe sequence used to specify the color blend factor of a particle over its lifetime.\nvar particleColorBlendFactor: CGFloat\nThe average starting value for the color blend factor.\nvar particleColorBlendFactorSpeed: CGFloat\nThe rate at which the color blend factor changes per second."
  },
  {
    "title": "particleColorBlendFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398071-particlecolorblendfactor",
    "html": "Discussion\n\nThe default value is 0.0, which means that the texture is used as is, ignoring the particle’s color. Otherwise, the texture is blended with the color. The maximum value is 1.0, which means the particle renders with a full-tint color.\n\nSee Also\nControlling How the Texture is Blended with Particle Color\nvar particleColorBlendFactorSequence: SKKeyframeSequence?\nThe sequence used to specify the color blend factor of a particle over its lifetime.\nvar particleColorBlendFactorRange: CGFloat\nThe range of allowed random values for a particle’s starting color blend factor.\nvar particleColorBlendFactorSpeed: CGFloat\nThe rate at which the color blend factor changes per second."
  },
  {
    "title": "particleColorAlphaSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398051-particlecoloralphaspeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleColorBlueSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398023-particlecolorbluespeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleColorGreenSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398033-particlecolorgreenspeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleColorBlueRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398075-particlecolorbluerange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the starting blue component of a particle’s color is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleColorGreenRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398065-particlecolorgreenrange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the starting green component of a particle’s color is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleColorRedRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397998-particlecolorredrange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the starting red component of a particle’s color is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398049-particlecolor",
    "html": "Discussion\n\nThe default value is [SKColor clearColor].\n\nA particle’s color is blended with the texture using its blend color factor. See Controlling How the Texture is Blended with Particle Color.\n\nImportant\n\nIf you create an SKEmitterNode object using Xcode’s particle editor, it uses the particleColorSequence property to implement the color change. This means that the particleColor property is ignored.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleColorAlphaRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397976-particlecoloralpharange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the starting alpha component of a particle’s color is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "rotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645775-rotation",
    "html": "See Also\nRotating a Tile\nenum SKTileDefinitionRotation\nThe allowed rotations for a given tile."
  },
  {
    "title": "flipVertically | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645800-flipvertically",
    "html": "See Also\nFlipping a Tile Vertically or Horizontally\nvar flipHorizontally: Bool\nA Boolean that flips the definition’s image vertically."
  },
  {
    "title": "normalTextures | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645780-normaltextures",
    "html": "Discussion\n\nIf the tile is non-animated, this will be an array containing one texture.\n\nSee Also\nConfigure Animated Tile Properties\nvar textures: [SKTexture]\nAn array of SKTexture objects that defines the tile definition object's content.\nvar timePerFrame: CGFloat\nThe duration, in seconds, that each texture in the textures array is displayed before switching to the next texture in the sequence."
  },
  {
    "title": "textures | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition/1645802-textures",
    "html": "Discussion\n\nIf the tile is non-animated, this will be an array containing one textures.\n\nSee Also\nConfigure Animated Tile Properties\nvar normalTextures: [SKTexture]\nAn array of SKTexture objects used to generate the normals for the tile to simulate 3D lighting.\nvar timePerFrame: CGFloat\nThe duration, in seconds, that each texture in the textures array is displayed before switching to the next texture in the sequence."
  },
  {
    "title": "attributedText | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/2865816-attributedtext",
    "html": "Discussion\n\nThe following properties are ignored if attributedText is defined:\n\ntext\n\n\t\n\nThe label favors the attributed string.\n\n\n\n\nfontColor\n\n\t\n\nFont color is defined by tags in the attributed string.\n\n\n\n\nfontSize\n\n\t\n\nFont size is defined by tags in the attributed string.\n\nSee Also\nSetting a Label's Text\nvar text: String?\nThe string that the label node displays."
  },
  {
    "title": "init(coder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407907-init",
    "html": "Discussion\n\nDo not call this initializer yourself; it is called by the system when you should intialize a video node that was created from an archive.\n\nSee Also\nCreating a Video Node\ninit(avPlayer: AVPlayer)\nInitializes a video node using an existing AVPlayer object.\ninit(fileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(url: URL)\nInitializes a video node using a URL.\ninit(videoFileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(videoURL: URL)\nInitializes a video node using a URL that points to a video file."
  },
  {
    "title": "init(avPlayer:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407900-init",
    "html": "Parameters\nplayer\n\nA player object.\n\nReturn Value\n\nAn initialized video node.\n\nDiscussion\n\nYou can use the AVPlayer object to control playback.\n\nListing 1 shows how you can create a video node using the init(avPlayer:) initializer.\n\nListing 1 Creating a video node with an AV Player\nvar videoNode: SKVideoNode? = {\n    guard let urlString = Bundle.main.path(forResource: \"sample\", ofType: \"mov\") else {\n        return nil\n    }\n    \n    let url = URL(fileURLWithPath: urlString)\n    let item = AVPlayerItem(url: url)\n    let player = AVPlayer(playerItem: item)\n    \n    return SKVideoNode(avPlayer: player)\n}()\n\n\nSee Also\nCreating a Video Node\ninit(fileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(url: URL)\nInitializes a video node using a URL.\ninit?(coder: NSCoder)\nTells you when to initialize a video node that was created from an archive.\ninit(videoFileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(videoURL: URL)\nInitializes a video node using a URL that points to a video file."
  },
  {
    "title": "text | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519788-text",
    "html": "Discussion\n\nThis property is ignored if attributedText is defined.\n\nSee Also\nSetting a Label's Text\nvar attributedText: NSAttributedString?\nThe attributed string displayed by the label."
  },
  {
    "title": "init(attributedText:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/2865817-init",
    "html": "Parameters\nattributedText\n\nThe attributed string from which to initialize the label.\n\nReturn Value\n\nA lable initialized from attributed text.\n\nDiscussion\n\nSee Also\nCreating a Label\ninit(fontNamed: String?)\nInitializes a new label object with a specified font.\ninit(text: String?)\nInitializes a new label object with a text string."
  },
  {
    "title": "shadowedBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519974-shadowedbitmask",
    "html": "Discussion\n\nTo determine whether this sprite is affected by being a shadow generated by a light, its shadowCastBitMask property is tested against the light’s categoryBitMask property by performing a logical AND operation. If the comparison results in a nonzero value, the sprite is drawn using a shadowed effect.\n\nThe default value is 0x00000000 (all bits cleared).\n\nSee Also\nLighting a Sprite\nLighting a Sprite with Light Nodes\nAdd lighting and shadows to your scene with light nodes.\nvar lightingBitMask: UInt32\nA mask that defines how this sprite is lit by light nodes in the scene.\nvar shadowCastBitMask: UInt32\nA mask that defines which lights are occluded by this sprite.\nvar normalTexture: SKTexture?\nA texture that specifies the normal map for the sprite."
  },
  {
    "title": "particleScaleSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398029-particlescalesequence",
    "html": "Discussion\n\nThe default value is nil. If a non-nil value is specified, then the particleScale, particleScaleRange, and particleScaleSpeed properties are ignored. Instead, the sequence is used to specify the scale factor.\n\nSee Also\nScaling Particles by a Factor\nvar particleScale: CGFloat\nThe average initial scale factor of a particle.\nvar particleScaleRange: CGFloat\nThe range of allowed random values for a particle’s initial scale.\nvar particleScaleSpeed: CGFloat\nThe rate at which a particle’s scale factor changes per second."
  },
  {
    "title": "particleColorSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397992-particlecolorsequence",
    "html": "Discussion\n\nThe default value is nil. If a non-nil value is specified, then the particleColor, particleColorAlphaRange, particleColorRedRange, particleColorGreenRange, particleColorBlueRange, particleColorAlphaSpeed, particleColorRedSpeed, particleColorGreenSpeed, and particleColorBlueSpeed properties are ignored. Instead, the sequence is used to specify the particle color.\n\nImportant\n\nIf you create an SKEmitterNode object using Xcode’s particle editor, it uses a color sequence to implement the color change.\n\nSee Also\nConfiguring Particle Color\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second."
  },
  {
    "title": "particleSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398063-particlesize",
    "html": "Discussion\n\nThe default value is CGSizeZero. If set to the default, the size of the texture stored in the particleTexture property is used to determine the size of a particle. If a texture has not been assigned, you must set this property to a non-empty size.\n\nSee Also\nChanging a Particle's Source Image and Size\nvar particleTexture: SKTexture?\nThe texture to use to render a particle."
  },
  {
    "title": "particleTexture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398004-particletexture",
    "html": "Discussion\n\nA particle is rendered as if it were a SKSpriteNode object. The default value is nil, which means a single-color rectangle is used to draw the particle. If a non-nil value is specified, then the texture is colorized and used to draw particles.\n\nSee Also\nChanging a Particle's Source Image and Size\nvar particleSize: CGSize\nThe starting size of each particle."
  },
  {
    "title": "blendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519931-blendmode",
    "html": "Discussion\n\nThe default value is SKBlendMode.alpha.\n\nSee Also\nConfiguring Alpha Blendling\nBlending a Sprite with Different Interpretations of Alpha\nReinterpret a sprite's alpha property to react differently to the objects below it.\nenum SKBlendMode\nThe modes that describe how the source and destination pixel colors are used to calculate the new destination color."
  },
  {
    "title": "Adding Text to a Scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/adding_text_to_a_scene",
    "html": "Overview\n\nMost apps need to display text at some point, and implementing it correctly yourself can take a significant amount of work. But the SKLabelNode class does all of the work necessary to load fonts and create text for display.\n\nCreate a new label node by calling the labelNodeWithFontNamed: class method. Then configure the other label properties, especially the text property. The size of a label node is determined implicitly by its fontName, fontSize, and text properties.\n\nBy default, the text label is centered horizontally on the label node’s origin, with the font’s baseline passing through the origin. The verticalAlignmentMode and horizontalAlignmentMode properties can be used to adjust the label’s position relative to the origin. The following code demonstrates how to create a new text label.\n\nlet winner = SKLabelNode(fontNamed: \"Chalkduster\")\nwinner.text = \"You Win!\"\nwinner.fontSize = 65\nwinner.fontColor = SKColor.green\nwinner.position = CGPoint(x: frame.midX, y: frame.midY)\n   \naddChild(winner)\n\n\nWhenever you change the label node’s properties, the label node is automatically updated the next time the scene is rendered."
  },
  {
    "title": "init(text:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519612-init",
    "html": "Parameters\ntext\n\nThe text to use to initialize the label node.\n\nReturn Value\n\nAn initialized label object.\n\nDiscussion\n\nThe label node’s font is set to Helvetica Neue Ultra Light, 32 point.\n\nSee Also\nCreating a Label\ninit(fontNamed: String?)\nInitializes a new label object with a specified font.\ninit(attributedText: NSAttributedString?)\nInitializes a new label object with an attributed text string."
  },
  {
    "title": "particleRotationRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397996-particlerotationrange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the initial rotation of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nAdjusting a Particle’s Rotation\nvar particleRotation: CGFloat\nThe average initial rotation of a particle, expressed as an angle in radians.\nvar particleRotationSpeed: CGFloat\nThe speed at which a particle rotates, expressed in radians per second."
  },
  {
    "title": "particleRotationSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397968-particlerotationspeed",
    "html": "Discussion\n\nThis is uniform for all particles generated by the emitter. The default value is 0.0.\n\nSee Also\nAdjusting a Particle’s Rotation\nvar particleRotation: CGFloat\nThe average initial rotation of a particle, expressed as an angle in radians.\nvar particleRotationRange: CGFloat\nThe range of allowed random values for a particle’s initial rotation, expressed as an angle in radians."
  },
  {
    "title": "particleRotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398025-particlerotation",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nAdjusting a Particle’s Rotation\nvar particleRotationRange: CGFloat\nThe range of allowed random values for a particle’s initial rotation, expressed as an angle in radians.\nvar particleRotationSpeed: CGFloat\nThe speed at which a particle rotates, expressed in radians per second."
  },
  {
    "title": "particleZPositionSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398008-particlezpositionspeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nControlling Particle Velocity and Acceleration\nvar particleSpeed: CGFloat\nThe average initial speed of a new particle, in points per second.\nvar particleSpeedRange: CGFloat\nThe range of allowed random values for a particle’s initial speed.\nvar emissionAngle: CGFloat\nThe average initial direction of a particle, expressed as an angle in radians.\nvar emissionAngleRange: CGFloat\nThe range of allowed random values for a particle’s initial direction, expressed as an angle in radians.\nvar xAcceleration: CGFloat\nThe acceleration to apply to a particle’s horizontal velocity.\nvar yAcceleration: CGFloat\nThe acceleration to apply to a particle’s vertical velocity.\nRelated Documentation\nvar particleZPosition: CGFloat\nThe average starting depth of a particle."
  },
  {
    "title": "particlePosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398019-particleposition",
    "html": "Discussion\n\nThe default value is (0.0,0.0).\n\nSee Also\nControlling Particle Position\nvar particlePositionRange: CGVector\nThe range of allowed random values for a particle’s position.\nvar particleZPosition: CGFloat\nThe average starting depth of a particle.\nvar particleZPositionRange: CGFloat\nThe range of allowed random values for a particle’s depth."
  },
  {
    "title": "particleSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398061-particlespeed",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nControlling Particle Velocity and Acceleration\nvar particleSpeedRange: CGFloat\nThe range of allowed random values for a particle’s initial speed.\nvar emissionAngle: CGFloat\nThe average initial direction of a particle, expressed as an angle in radians.\nvar emissionAngleRange: CGFloat\nThe range of allowed random values for a particle’s initial direction, expressed as an angle in radians.\nvar xAcceleration: CGFloat\nThe acceleration to apply to a particle’s horizontal velocity.\nvar yAcceleration: CGFloat\nThe acceleration to apply to a particle’s vertical velocity.\nvar particleZPositionSpeed: CGFloat\nThe speed at which the particle’s depth changes."
  },
  {
    "title": "particleZPositionRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397974-particlezpositionrange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the z position of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nControlling Particle Position\nvar particlePosition: CGPoint\nThe average starting position for a particle.\nvar particlePositionRange: CGVector\nThe range of allowed random values for a particle’s position.\nvar particleZPosition: CGFloat\nThe average starting depth of a particle."
  },
  {
    "title": "particleZPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398055-particlezposition",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nControlling Particle Position\nvar particlePosition: CGPoint\nThe average starting position for a particle.\nvar particlePositionRange: CGVector\nThe range of allowed random values for a particle’s position.\nvar particleZPositionRange: CGFloat\nThe range of allowed random values for a particle’s depth."
  },
  {
    "title": "particleLifetimeRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397994-particlelifetimerange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the lifetime of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nControlling Particle Lifetime\nvar particleLifetime: CGFloat\nThe average lifetime of a particle, in seconds."
  },
  {
    "title": "particleLifetime | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398000-particlelifetime",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nControlling Particle Lifetime\nvar particleLifetimeRange: CGFloat\nThe range of allowed random values for a particle’s lifetime."
  },
  {
    "title": "resetSimulation() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398053-resetsimulation",
    "html": "Discussion\n\nResetting the simulation clears the internal state of the simulation.\n\nSee Also\nControlling When Particles Are Created\nfunc advanceSimulationTime(TimeInterval)\nAdvances the emitter particle simulation.\nvar particleBirthRate: CGFloat\nThe rate at which new particles are created.\nvar numParticlesToEmit: Int\nThe number of particles the emitter should emit before stopping."
  },
  {
    "title": "advanceSimulationTime(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398027-advancesimulationtime",
    "html": "Parameters\nsec\n\nThe number of seconds to simulate.\n\nDiscussion\n\nOnce added to a scene, an emitter node automatically creates new particles in new animation frames. This method allows you to artificially advance a running emitter’s simulation, causing it to generate new particles and advance any existing particles. The most common use for this method is to prepopulate an emitter node with particles after it is first added to a scene.\n\nIf an emitter is paused, either directly or by one of its parent nodes being paused, advanceSimulationTime(_:) has no effect. Listing 1 shows how to advance an emitter object while it is paused, by temporarily toggling its isPaused property while advancing the simulation.\n\nListing 1 Temporarily unpausing an emitter to advance simulation time\nlet emitter = SKEmitterNode()\nlet emitterPaused = emitter.isPaused\nif emitterPaused {\n    emitter.isPaused = false\n}\nemitter.advanceSimulationTime(5)\nif emitterPaused {\n    emitter.isPaused = true\n}\n\n\nNote that the isPaused property is inherited from a node’s parents, so even if the emitter hasn’t been explicitly paused but, for example, the scene has, this code will still work.\n\nSee Also\nControlling When Particles Are Created\nfunc resetSimulation()\nRemoves all existing particles and restarts the simulation.\nvar particleBirthRate: CGFloat\nThe rate at which new particles are created.\nvar numParticlesToEmit: Int\nThe number of particles the emitter should emit before stopping.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "autoplayLooped | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode/1520336-autoplaylooped",
    "html": "Discussion\n\nIf the property value is true, then the audio starts playing as soon as the node is added to the scene, and repeats after it completes. If false, then the audio node’s content never plays automatically. It must be explicitly scheduled using the scene’s audio engine. The default value is true.\n\nSee Also\nConfiguring Audio Nodes\nvar avAudioNode: AVAudioNode?\nThe audio node’s current audio asset.\nvar isPositional: Bool\nA Boolean property that indicates whether the node’s audio is altered based on the position of the node."
  },
  {
    "title": "unprojectPoint(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1520024-unprojectpoint",
    "html": "Parameters\npoint\n\nA point in the SpriteKit node’s coordinate system.\n\nReturn Value\n\nThe corresponding point in the world coordinate system of the SceneKit scene.\n\nDiscussion\n\nThe z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the viewing frustum (defined by the SK3DNode property). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.\n\nA point in the SpriteKit node’s 2D viewport coordinate space can refer to any point along a line segment in the 3D SceneKit coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to a touch event—use the SK3DNode method.\n\nThe following code shows how you might convert the location of an iOS touch event inside an SK3DNode, node, to the 3D coordinates within its SceneKit scene. The resulting value, sceneKitCoordinates, is given a z of 0.5, meaning that the coordinate is midway between the near and far clipping planes. You could use this value to set the position of an object within the SceneKit scene.\n\noverride func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {\n    guard let touch = touches.first else {\n        return\n    }\n    \n    let location = touch.location(in: node)\n    let scale = Float(UIScreen.main.scale)\n    \n    let sceneKitCoordinates = node.unprojectPoint(vector_float3(Float(location.x) * scale,\n                                                                Float(location.y) * scale,\n                                                                0.5))\n}\n\n\nSee Also\nProjecting Points and Performing Hit-Testing\nfunc hitTest(CGPoint, options: [String : Any]?) -> [SCNHitTestResult]\nSearches the Scene Kit scene for objects corresponding to a point in the rendered image.\nfunc projectPoint(vector_float3) -> vector_float3\nProjects a point from the 3D world coordinate system of the SceneKit scene to the 2D viewport coordinate system of the SpriteKit node."
  },
  {
    "title": "projectPoint(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1520400-projectpoint",
    "html": "Parameters\npoint\n\nA point in the world coordinate system of the Scene Kit scene.\n\nReturn Value\n\nThe corresponding point in the SpriteKit node’s coordinate system.\n\nDiscussion\n\nThe z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the viewing frustum (defined by the pointOfView property). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.\n\nThe following code illustrates how you might convert the position of a SceneKit node, sphereNode, in 3D space to the 2D coordinates of a SpriteKit SK3DNode, node. The code assumes that sphereNode is the first child node of the SceneKit scene's rootNode.\n\nif let sphereNode = node.scnScene?.rootNode.childNodes.first { \n    let location = node.projectPoint(vector_float3(Float(sphereNode.position.x),\n                                                   Float(sphereNode.position.y),\n                                                   Float(sphereNode.position.z)))\n}\n\n\nSee Also\nProjecting Points and Performing Hit-Testing\nfunc hitTest(CGPoint, options: [String : Any]?) -> [SCNHitTestResult]\nSearches the Scene Kit scene for objects corresponding to a point in the rendered image.\nfunc unprojectPoint(vector_float3) -> vector_float3\nUnprojects a point from the SpriteKit node’s 2D viewport coordinate system to the 3D world coordinate system of the SceneKit scene."
  },
  {
    "title": "isPlaying | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1520297-isplaying",
    "html": "Discussion\n\nIf the value of this property is false (the default), SceneKit does not increment the scene time, so animations associated with the scene do not play. Change this property’s value to true to start animating the scene.\n\nSee Also\nAnimating a 3D Node’s Content in Scene Kit\nvar loops: Bool\nA Boolean value that determines whether Scene Kit restarts the scene time after all animations in the scene have played.\nvar sceneTime: TimeInterval\nThe current scene time."
  },
  {
    "title": "targetNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398012-targetnode",
    "html": "Discussion\n\nThe default value is nil, which means that particles are treated as if they were children of the emitter node. In future frames of animation, the particle positions are affected by the emitter node’s properties. If you specify a different target node, the initial properties of new particles are calculated based on the emitter node’s properties, but in future frames of animation the particles are treated as if they were children of the target node.\n\nFor example, assume you have an emitter node as a child of the scene node and the node is being rotated by changing its zRotation property. The behavior of the emitter node changes based on the value of the target node:\n\nIf the targetNode property is nil, then the positions of both previously generated and new particles are rotated.\n\nIf the targetNode property points to the scene node, then new particles are adjusted when the emitter node rotates, but previously generated particles are not.\n\nBy spawning the particles inside the scene node, they have behavior independent of the emitter’s properties.\n\nSee Also\nChoosing Which Node in the Scene Emits Particles\nChanging the Location of Particles in Your Scene\nSet a target node from which SpriteKit creates particles."
  },
  {
    "title": "hitTest(_:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519782-hittest",
    "html": "Parameters\nthePoint\n\nA point in the viewport coordinate system of the SpriteKit node.\n\noptions\n\nA dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.\n\nReturn Value\n\nAn array of SCNHitTestResult objects representing search results.\n\nDiscussion\n\nA point in the SpriteKit node’s 2D viewport coordinate space can refer to any point along a line segment in the 3D SceneKit coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a touch event.\n\nSee Also\nProjecting Points and Performing Hit-Testing\nfunc projectPoint(vector_float3) -> vector_float3\nProjects a point from the 3D world coordinate system of the SceneKit scene to the 2D viewport coordinate system of the SpriteKit node.\nfunc unprojectPoint(vector_float3) -> vector_float3\nUnprojects a point from the SpriteKit node’s 2D viewport coordinate system to the 3D world coordinate system of the SceneKit scene."
  },
  {
    "title": "Changing the Location of Particles in Your Scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/changing_the_location_of_particles_in_your_scene",
    "html": "Overview\n\nWhen the emitter creates particles, the particles are rendered as children of the emitter node. This means that they inherit the characteristics of the emitter node, just like nodes do. For example, if you rotate the emitter node, the positions of all of the generated particles are also rotated. Depending on what effect you are simulating with the emitter, this may not be the correct behavior.\n\nFor example, assume that you are using the emitter node to create the exhaust from a rocket. When the engines are at full burn, a cone of flame should come out the back of the ship. This is easily simulated using particles. But if the particles are rendered relative to the ship, when the ship turns, the exhaust also turns, which doesn't look right. The particles should be generated, but should thereafter be independent of the emitter node. When the emitter node is rotated, new particles get the new orientation, and old particles maintain their old orientation. You make particles independent of the emitter by specifying a target node.\n\nThe following code shows how to configure a rocket exhaust effect to use a target node. When the custom sprite node class instantiates the exhaust node, it makes the node its child. However, it redirects the particles to the scene.\n\nfunc newExhaustNode(scene: SKScene) {\n    guard let emitter = SKEmitterNode(fileNamed: \"exhaust.sks\") else {\n        return\n    }\n    \n    // Place the emitter at the rear of the ship.\n    emitter.position = CGPoint(x: 0, y: -40)\n    emitter.name = \"exhaust\"\n    \n    // Send the particles to the scene.\n    emitter.targetNode = scene;\n    scene.addChild(emitter)\n}\n\n\nWhen an emitter has a target node, it calculates the position, velocity, and orientation of the particle, exactly as if it were a child of the sprite node. This means that if the ship sprite is rotated, the exhaust orientation is automatically rotated, too. However, at the moment a new particle’s starting values are calculated, the values are transformed into the target node’s coordinate system. Thereafter, they would only be affected by changes to the target node.\n\nSee Also\nChoosing Which Node in the Scene Emits Particles\nvar targetNode: SKNode?\nThe target node that renders the emitter’s particles."
  },
  {
    "title": "sceneTime | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519738-scenetime",
    "html": "Discussion\n\nThis timestamp determines the behavior of running animations, similar to how the playhead time in a video player application determines which frame of a movie to display. It applies only to animations whose usesSceneTimeBase property is true, including those loaded from a scene source using the playUsingSceneTimeBase option.\n\nUse this property together with the above animation options when you want to directly control (or allow the user to directly control) the playback of animations.\n\nSee Also\nAnimating a 3D Node’s Content in Scene Kit\nvar isPlaying: Bool\nA Boolean value that determines whether the scene is playing.\nvar loops: Bool\nA Boolean value that determines whether Scene Kit restarts the scene time after all animations in the scene have played."
  },
  {
    "title": "Creating Particle Effects | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/creating_particle_effects",
    "html": "Overview\n\nAdd special effects to your app, such as glittering or realistic fire with smoke, using particle effects. You create and configure particle effects using Xcode's SpriteKit Particle Editor, or in code. A benefit of using the editor is that you can repeat the particles in different places across your app without duplicating the code.\n\nCreate Emitters with the Particle Editor\n\nIn most cases, you never need to configure an emitter node directly in your game. Instead, you use Xcode to configure an emitter node’s properties. As you change the behavior of the emitter node, Xcode immediately provides you an updated visual effect. When complete, Xcode archives the configured emitter. Then, at runtime, your game uses this archive to instantiate a new emitter node.\n\nUsing Xcode to create emitter nodes has a few important advantages:\n\nIt is the best way to learn the capabilities of the emitter class.\n\nYou can quickly experiment with new particle effects and see the results immediately.\n\nYou separate the task of designing a particle effect from the programming task of using it. Your artists can work on new particle effects independent of your game code.\n\nFor more information on using Xcode to create particle effects, see Add a particle emitter to your project.\n\nThe following code shows how to load a particle effect that was created by Xcode. All particle effects are saved using Cocoa’s standard archiving mechanisms, so the code first creates a path to the smoke effect, and then loads the archive.\n\nfunc newSmokeEmitter() -> SKEmitterNode? {\n    return SKEmitterNode(fileNamed: \"smoke.sks\")\n}\n\nConfigure Particles in Code\n\nThe SKEmitterNode class provides many properties for configuring an emitter node’s behavior. The Xcode emitter editor sets the same property values. You can also create and configure your own emitter, or you can take an emitter node created in the Particle Emitter Editor, load it, and change its property values.\n\nWhen the emitter node is in a scene, it emits new particles. You use the following properties to define how many particles it creates:\n\nThe particleBirthRate property specifies the number of particles that the emitter creates every second. For example, consider using the smoke effect in the previous code to show damage to a rocket ship. As the ship takes more damage, you can increase the birth rate of the emitter to add more smoke.\n\nThe numParticlesToEmit property specifies how many particles are created before the emitter turns itself off. You can also configure the node to emit an unlimited number of particles.\n\nWhen a particle is created, its initial property values are determined by the properties of the emitter. For each of the particle’s properties, the emitter class declares up to four properties:\n\nThe average starting value for the property.\n\nA random range for values of the property. Each time a new particle is emitted, a new random value is calculated within that range.\n\nThe rate at which the value changes over time, also known as the property’s speed. Not all properties have a speed property.\n\nAn optional keyframe sequence.\n\nThe complete list of properties used to configure an emitter node is given in SKEmitterNode.\n\nThe following code shows how you might configure an emitter’s scale property. This is a simplified version of a node’s xScale and yScale properties, and determines how large the particle is.\n\nmyEmitter.particleScale = 0.3;\nmyEmitter.particleScaleRange = 0.2;\nmyEmitter.particleScaleSpeed = -0.1;\n\n\nWhen a new particle is created, its scale value is a random number from 0.2 to 0.4. The scale value then decreases at a rate of 0.1 per second. So, for example, if a particular particle started at the average value, 0.3, it would decrease from 0.3 to 0 over a period of 3 seconds."
  },
  {
    "title": "init(fileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode/1519678-init",
    "html": "Parameters\nname\n\nA file containing an AVAudioNode.\n\nReturn Value\n\nA newly initialized audio node.\n\nDiscussion\n\nThe named file containing the audio asset must reside within the main bundle.\n\nSee Also\nInitializing Audio Nodes\ninit(avAudioNode: AVAudioNode?)\nInitializes an audio node from an AVFoundation audio node.\ninit(url: URL)\nInitializes an audio node from an audio asset with the specified URL.\ninit?(coder: NSCoder)\nTells you when to initialize an audio node that has been unarchived."
  },
  {
    "title": "loops | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519549-loops",
    "html": "Discussion\n\nIf the value of this property is true (the default), SceneKit returns the scene time to zero after all animations associated with the scene have played, causing those animations to repeat. Otherwise, SceneKit stops playing the scene when all animations have completed.\n\nSee Also\nAnimating a 3D Node’s Content in Scene Kit\nvar isPlaying: Bool\nA Boolean value that determines whether the scene is playing.\nvar sceneTime: TimeInterval\nThe current scene time."
  },
  {
    "title": "init(avAudioNode:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode/1520232-init",
    "html": "Parameters\nnode\n\nAn AVAudioNode object that holds an AVAudioEngine sound graph from a single sound source or URL.\n\nReturn Value\n\nA newly initialized audio node.\n\nSee Also\nInitializing Audio Nodes\ninit(fileNamed: String)\nInitializes an audio node from an audio asset with the specified filename.\ninit(url: URL)\nInitializes an audio node from an audio asset with the specified URL.\ninit?(coder: NSCoder)\nTells you when to initialize an audio node that has been unarchived.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "autoenablesDefaultLighting | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519676-autoenablesdefaultlighting",
    "html": "Discussion\n\nIf this property’s value is true (the default), SceneKit automatically adds and places an omnidirectional light source when rendering scenes that contain no lights or only contain ambient lights. If you change the value to false, the only light sources SceneKit uses for rendering a scene are those contained in the scene graph.\n\nSee Also\nConfiguring a 3D Node\nvar viewportSize: CGSize\nThe size of the image rendered by the node.\nvar scnScene: SCNScene?\nThe SceneKit scene to render.\nvar pointOfView: SCNNode?\nThe Scene Kit node from which the scene’s contents are viewed when rendered."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519639-color",
    "html": "Discussion\n\nIf the texture property is non-nil, the red, green, and blue values of the color property are blended with the texture before the texture is drawn and the alpha property is ignored. If the texture property is nil, the color (including the alpha component) is used to draw a single-color rectangle.\n\nSee Also\nTinting a Sprite\nTinting a Sprite\nProvide a color and blend factor to additively color your sprite.\nvar colorBlendFactor: CGFloat\nA floating-point value that describes how the color is blended with the sprite’s texture.\nRelated Documentation\nvar texture: SKTexture?\nThe texture used to draw the sprite."
  },
  {
    "title": "viewportSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1520078-viewportsize",
    "html": "See Also\nConfiguring a 3D Node\nvar scnScene: SCNScene?\nThe SceneKit scene to render.\nvar pointOfView: SCNNode?\nThe Scene Kit node from which the scene’s contents are viewed when rendered.\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether Scene Kit automatically adds lights to a scene."
  },
  {
    "title": "setValue(_:forAttribute:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/2715854-setvalue",
    "html": "Parameters\nvalue\n\nAn attribute value object containing the scalar or vector value to set in the attached shader.\n\nkey\n\nThe attribute name.\n\nSee Also\nTaking Full Control of Particle Drawing with a Shader\nGetting Started with Particle Shaders\nProvide custom shader code to alter a particle's look.\nvar shader: SKShader?\nA custom shader used to determine how particles are rendered.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute."
  },
  {
    "title": "value(forAttributeNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/2715842-value",
    "html": "Parameters\nkey\n\nThe attribute name.\n\nReturn Value\n\nAn attribute value object containing the scalar or vector value or nil if no such attribute exists.\n\nSee Also\nTaking Full Control of Particle Drawing with a Shader\nGetting Started with Particle Shaders\nProvide custom shader code to alter a particle's look.\nvar shader: SKShader?\nA custom shader used to determine how particles are rendered.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader."
  },
  {
    "title": "attributeValues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/2715850-attributevalues",
    "html": "Discussion\n\nAll nodes have their own copy of an attribute value and therefore the attribute values can be different per-node across the same SKShader. If instead you need all nodes to share the same value, use SKUniform. Uniforms can change values every frame, but uniforms cannot vary per-node like attributes can.\n\nSee Also\nTaking Full Control of Particle Drawing with a Shader\nGetting Started with Particle Shaders\nProvide custom shader code to alter a particle's look.\nvar shader: SKShader?\nA custom shader used to determine how particles are rendered.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute."
  },
  {
    "title": "Optimizing Emitter Node Performance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/optimizing_emitter_node_performance",
    "html": "Overview\n\nParticle emitters in SpriteKit are one of the most powerful tools for building visual effects. However, if used incorrectly, particle emitters can be a bottleneck in the design and implementation of your app. Consider the following tips:\n\nUse Xcode to create and test your particle effects, then load the archives in your game.\n\nAdjust emitter properties sparingly inside your game code. Typically, you do this to specify properties that cannot be specified in the Xcode inspector or to control properties inside your game logic.\n\nTry to keep the number of onscreen particles to a minimum by creating particle emitters with a low birth rate, and specifying a short lifetime for particles. For example, instead of creating hundreds or thousands of particles per second, reduce the birth rate and increase the size of the particles slightly. Often, you can create effects with fewer particles but the same net visual appearance.\n\nUse actions on particles only when there isn’t another solution. Executing actions on individual particles is potentially very expensive, especially if the particle emitter also has a high birth rate.\n\nAssign a target node whenever the particles should be independent of the emitter node after they are spawned. For example, particles should be independent if the emitter node moves or rotates in the scene.\n\nConsider removing a particle emitter from the scene when it is not visible onscreen. Add it just before it becomes visible."
  },
  {
    "title": "Using the Anchor Point to Move a Sprite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/using_the_anchor_point_to_move_a_sprite",
    "html": "Overview\n\nBy default, the sprite node’s frame—and thus its texture—is centered on its position. However, you might want a different part of the texture to appear at the node’s position; for example, when the game element depicted in the texture is not centered in the texture image.\n\nA sprite node’s anchorPoint determines which point within its frame corresponds to its position. Anchor points are specified in the unit coordinate system, shown in the following illustration. The unit coordinate system places the origin at the bottom left corner of the frame and (1,1) at the top right corner of the frame. A sprite’s anchor point defaults to (0.5,0.5), which corresponds to the center of the frame.\n\nAlthough you are moving the frame, you do this because you want the corresponding portion of the texture to be centered on the node's position. The following figure shows two pairs of texture images. In the first, the default anchor point centers the texture on the node position. In the second, a point at the top of the image is selected instead. You can see that when the node is rotated, the texture image rotates around this point.\n\nThe following code shows how to place the anchor point on the rocket’s nose cone. Usually, you set the anchor point when the sprite node is initialized, because it corresponds to the artwork. However, you can set this property at any time. The frame is immediately updated, and the node onscreen is updated the next time the scene is rendered.\n\nrocket.anchorPoint = CGPoint(x: 0.5, y: 1.0)\n\n\nSee Also\nSetting a Sprite's Size and Position\nvar size: CGSize\nThe dimensions of the sprite, in points.\nfunc scale(to: CGSize)\nScales the sprite node to a specified size.\nvar anchorPoint: CGPoint\nDefines the point in the sprite that corresponds to the node’s position."
  },
  {
    "title": "shadowColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode/1519844-shadowcolor",
    "html": "Discussion\n\nThe default color is black with an opacity (alpha) of 0.5.\n\nWhen lighting is calculated, shadows are created as if a ray was cast out from the light node’s position. If a sprite casts a shadow, the rays are blocked when they intersect with the sprite’s physics body. Otherwise, the sprite’s texture is used to generate a mask, and any pixel in the sprite node’s texture that has an alpha value that is nonzero blocks the light.\n\nShadows may be cast on content that is rendered prior to the sprite, even if that content does not otherwise interact with the light.\n\nSee Also\nConfiguring the Lighting Properties\nvar ambientColor: UIColor\nThe ambient color of the light.\nvar lightColor: UIColor\nThe diffuse and specular color of the light source.\nvar falloff: CGFloat\nThe exponent for the rate of decay of the light source."
  },
  {
    "title": "lightColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode/1520244-lightcolor",
    "html": "Discussion\n\nThe default value is white.\n\nIf you are using custom shaders, you can substitute an SKUniform object instead.\n\nSee Also\nConfiguring the Lighting Properties\nvar ambientColor: UIColor\nThe ambient color of the light.\nvar shadowColor: UIColor\nThe color of any shadow cast by a sprite.\nvar falloff: CGFloat\nThe exponent for the rate of decay of the light source."
  },
  {
    "title": "init(coder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520399-init",
    "html": "Discussion\n\nDon't call this function directly; the system calls this function when you should initialize your sprite from the argument archived data."
  },
  {
    "title": "falloff | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode/1519776-falloff",
    "html": "Discussion\n\nThe default value is 1.0, which means the light decays linearly with distance. The value must be a positive number less than or equal to 1.0.\n\nSee Also\nConfiguring the Lighting Properties\nvar ambientColor: UIColor\nThe ambient color of the light.\nvar lightColor: UIColor\nThe diffuse and specular color of the light source.\nvar shadowColor: UIColor\nThe color of any shadow cast by a sprite."
  },
  {
    "title": "ambientColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode/1520139-ambientcolor",
    "html": "Discussion\n\nThe alpha value of the color is ignored. The default color is black, meaning that the light does not have an ambient component. The ambient component of the light is not affected by the light’s falloff property, nor is it affected by any normal map (normalTexture) on the sprite node.\n\nSee Also\nConfiguring the Lighting Properties\nvar lightColor: UIColor\nThe diffuse and specular color of the light source.\nvar shadowColor: UIColor\nThe color of any shadow cast by a sprite.\nvar falloff: CGFloat\nThe exponent for the rate of decay of the light source."
  },
  {
    "title": "isEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode/1519826-isenabled",
    "html": "Discussion\n\nIf the value is true, the light is enabled and affects sprite nodes in the scene. The default is true.\n\nSee Also\nDetermining Whether a Light Node Is Active\nvar categoryBitMask: UInt32\nA mask that defines which categories this light belongs to.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode/1519940-categorybitmask",
    "html": "Discussion\n\nEvery light in a scene can be assigned to up to 32 different categories, each corresponding to a bit in the bit mask. SpriteKit does not predefine any lighting categories, so it is up to you to define which values are used in your game. When a scene is rendered, a light’s categoryBitMask property is compared to each sprite node’s lightingBitMask, shadowCastBitMask, and shadowedBitMask properties to determine whether that sprite interacts with the light.\n\nThe default value is 0x00000001.\n\nSee Also\nDetermining Whether a Light Node Is Active\nvar isEnabled: Bool\nA Boolean value that indicates whether the node is casting light."
  },
  {
    "title": "applyImpulse(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520407-applyimpulse",
    "html": "Parameters\nimpulse\n\nA vector that describes how much momentum to impart to the body. The impulse is measured in Newton-seconds.\n\npoint\n\nA point in scene coordinates that defines where the impulse was applied to the physics body.\n\nDiscussion\n\nBecause this impulse is applied to a specific point on the object, it may change both the body’s velocity and angular velocity.\n\nSee Also\nApplying Forces and Impulses to a Physics Body\nMaking Physics Bodies Move\nMove a body using various physics properties, like velocity, gravity or impulses.\nfunc applyForce(CGVector)\nApplies a force to the center of gravity of a physics body.\nfunc applyTorque(CGFloat)\nApplies torque to an object.\nfunc applyForce(CGVector, at: CGPoint)\nApplies a force to a specific point of a physics body.\nfunc applyImpulse(CGVector)\nApplies an impulse to the center of gravity of a physics body.\nfunc applyAngularImpulse(CGFloat)\nApplies an impulse that imparts angular momentum to an object.\nRelated Documentation\nvar mass: CGFloat\nThe mass of the body, in kilograms."
  },
  {
    "title": "init(texture:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519690-init",
    "html": "Parameters\ntexture\n\nThe texture to convert into a physics body.\n\nsize\n\nThe size of the physics body to return.\n\nReturn Value\n\nA new volume-based physics body.\n\nDiscussion\n\nUse this method when your sprite has a shape that you want replicated in its physics body. The texture is scaled to the new size and then analyzed. A new physics body is created that includes all of the texels in the texture that have a nonzero alpha value. The shape of this body attempts to strike a good balance between performance and accuracy. For example, fine details may be ignored if keeping them would cause a significant performance penalty.\n\nSee Also\nCreating a Body from a Texture\nShaping a Physics Body to Match a Node's Graphics\nShape a physics body to your graphics for the right blend of collision accuracy and performance.\ninit(texture: SKTexture, alphaThreshold: Float, size: CGSize)\nCreates a physics body from the contents of a texture, capturing only the texels that exceed a specified transparency value."
  },
  {
    "title": "init(texture:alphaThreshold:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519689-init",
    "html": "Parameters\ntexture\n\nThe texture to analyze.\n\nalphaThreshold\n\nThe minimum alpha value for texels that should be part of the new physics body.\n\nsize\n\nThe size of the physics body to return.\n\nReturn Value\n\nA new volume-based physics body.\n\nDiscussion\n\nUse this method when your sprite has a shape that you want replicated in its physics body. The texture is scaled to the new size and then analyzed. A new physics body is created that includes all of the texels in the texture whose alpha values equal or exceed the alphaThreshold parameter. The shape of this body attempts to strike a good balance between performance and accuracy. For example, fine details may be ignored if keeping them would cause a significant performance penalty.\n\nSee Also\nCreating a Body from a Texture\nShaping a Physics Body to Match a Node's Graphics\nShape a physics body to your graphics for the right blend of collision accuracy and performance.\ninit(texture: SKTexture, size: CGSize)\nCreates a physics body from the contents of a texture."
  },
  {
    "title": "init(color:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519762-init",
    "html": "Parameters\ncolor\n\nThe color for the resulting sprite node.\n\nsize\n\nThe size of the sprite node in points.\n\nReturn Value\n\nA newly initialized sprite node.\n\nDiscussion\n\nAlthough textured nodes are the most common way to use the SKSpriteNode class, you can also create sprite nodes without a texture. The behavior of the class changes when the node lacks a texture:\n\nThe sprite node that is returned from this method has its texture property set to nil.\n\nThere is no texture to stretch, so the centerRect parameter is ignored.\n\nThere is no colorization step; the color property is used as the sprite’s color.\n\nThe sprite node's alpha component is used to determine how it is blended into the buffer.\n\nListing 1 shows how to create a red sprite node 100 x 100 points in size.\n\nListing 1 Creating a non-textured sprite node\nlet node = SKSpriteNode(color: .red,\n                        size: CGSize(width: 100, height: 100))\n\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "init(imageNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520391-init",
    "html": "Parameters\nname\n\nThe name of an image file stored in the app bundle.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThis method creates a new texture object from the image file and assigns that texture to the texture property, the normalTexture properties is set to nil. The size property of the sprite is set to the dimensions of the image. The color property is set to white with an alpha of zero (1.0,1.0,1.0,0.0).\n\nSee Also\nCreating a Sprite from an Image Filename\nGetting Started with Sprite Nodes\nLearn the basics about using images, also known as sprites, with SpriteKit.\ninit(imageNamed: String, normalMapped: Bool)\nInitializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting."
  },
  {
    "title": "pause() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407910-pause",
    "html": "See Also\nControlling Video Playback\nfunc play()\nStarts video playback."
  },
  {
    "title": "play() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407896-play",
    "html": "See Also\nControlling Video Playback\nfunc pause()\nPauses video playback."
  },
  {
    "title": "init(coder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519722-init",
    "html": "Discussion\n\nDo not call this function directly; it is called by the system when you should initialize a 3D node that has been unarchived.\n\nSee Also\nCreating 3D Nodes\ninit(viewportSize: CGSize)\nInitializes a new 3D node."
  },
  {
    "title": "init(viewportSize:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519708-init",
    "html": "Parameters\nviewportSize\n\nThe size of the node’s rendered image.\n\nReturn Value\n\nAn initialized SK3DNode object.\n\nSee Also\nCreating 3D Nodes\ninit?(coder: NSCoder)\nTells you when to initialize a 3D node that has been unarchived."
  },
  {
    "title": "Displaying 3D Content in a SpriteKit Scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/displaying_3d_content_in_a_spritekit_scene",
    "html": "Overview\n\nSceneKit content rendered in SpriteKit is automatically assigned a camera and, because autoenablesDefaultLighting defaults to true, lights. That means you require very little code to add simple 3D primitives to your scene. The following code shows how to create a simple scene containing a torus and display it in a SpriteKit scene.\n\nlet scnScene: SCNScene = {\n    let scnScene = SCNScene()\n    \n    let torusGeometry = SCNTorus(ringRadius: 10, pipeRadius: 3)\n    let torusNode = SCNNode(geometry: torusGeometry)\n    torusNode.eulerAngles = SCNVector3(x: CGFloat.pi / 2, y: 0, z: 0)\n    scnScene.rootNode.addChildNode(torusNode)\n    return scnScene\n}()\n     \nlet node = SK3DNode(viewportSize: CGSize(width: 200, height: 200))\nnode.scnScene = scnScene\n\n\nAfter node is added to a SKScene, the 3D torus is visible:\n\nControl How Your Content Is Rendered\n\nAlthough SK3DNode creates a default camera automatically, you can create your own camera for precise control over how the 3D content is rendered. The following code shows how you can create a 3D node with an explicitly created camera that looks at the first object in the SceneKit scene's node tree.\n\nlet node = SK3DNode(viewportSize: CGSize(width: 200, height: 200))\nnode.position = position\nnode.scnScene = scnScene\nnode.name = \"3dnode\"\nlet camera = SCNCamera()\nlet cameraNode = SCNNode()\ncameraNode.camera = camera\nif let lookAtTarget = scnScene.rootNode.childNodes.first {\n    \n    let constraint = SCNLookAtConstraint(target: lookAtTarget)\n    cameraNode.constraints = [ constraint ]\n}\nnode.pointOfView = cameraNode\nnode.pointOfView?.position = SCNVector3(x: 0, y: 0, z: 20)\n\n\nSet the Position and Orientation of Your 3D Content\n\nYou can create many instances of SK3DNode, each sharing the same SceneKit scene but each with an independent point of view. By updating the position of each 3D node's point of view, you can create code that simulates a top-down, one-point perspective view. The following example shows how to do this by enumerating over all the nodes named 3dnode in the update method of a SKSceneDelegate.\n\nscene.enumerateChildNodes(withName: \"3dnode\") {\n    node, _ in\n    if let node = node as? SK3DNode {\n        let positionX = (width * 0.5 - node.position.x) / 10\n        let positionY = (height * 0.5 - node.position.y) / 10\n        node.pointOfView?.position = SCNVector3(x: positionX, y: positionY, z: 20)\n    }\n}\n\n\nThe following image shows how this code gives the impression of perspective inside SpriteKit:"
  },
  {
    "title": "init(videoURL:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407908-init",
    "html": "Deprecated\n\nUse init(url:) instead.\n\nParameters\nurl\n\nThe URL for the video to play.\n\nReturn Value\n\nAn initialized video node.\n\nSee Also\nCreating a Video Node\ninit(avPlayer: AVPlayer)\nInitializes a video node using an existing AVPlayer object.\ninit(fileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(url: URL)\nInitializes a video node using a URL.\ninit?(coder: NSCoder)\nTells you when to initialize a video node that was created from an archive.\ninit(videoFileNamed: String)\nInitializes a video node using a video file stored in the app bundle."
  },
  {
    "title": "anchorPoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407904-anchorpoint",
    "html": "Discussion\n\nYou specify the anchor point using the unit coordinate space. The default value is (0.5,0.5), which means that the video is centered on the node’s position.\n\nSee Also\nSetting the Video Node’s Visual Properties\nvar size: CGSize\nThe dimensions of the video node, in points."
  },
  {
    "title": "preferredMaxLayoutWidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/2865814-preferredmaxlayoutwidth",
    "html": "Discussion\n\nThe default value is 0, which means that line break mode will not be applied.\n\nSee Also\nDefining a Label's Line-Breaking Behavior\nvar lineBreakMode: NSLineBreakMode\nDetermines the line-break mode for multiple lines.\nvar numberOfLines: Int\nDetermines the number of lines to draw."
  },
  {
    "title": "init(videoFileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407918-init",
    "html": "Deprecated\n\nUse init(fileNamed:) instead.\n\nParameters\nvideoFile\n\nThe name of the video file.\n\nReturn Value\n\nAn initialized video node.\n\nSee Also\nCreating a Video Node\ninit(avPlayer: AVPlayer)\nInitializes a video node using an existing AVPlayer object.\ninit(fileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(url: URL)\nInitializes a video node using a URL.\ninit?(coder: NSCoder)\nTells you when to initialize a video node that was created from an archive.\ninit(videoURL: URL)\nInitializes a video node using a URL that points to a video file."
  },
  {
    "title": "horizontalAlignmentMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519711-horizontalalignmentmode",
    "html": "Discussion\n\nThe possible values for this property are listed in SKLabelHorizontalAlignmentMode. The default value of this property is SKLabelHorizontalAlignmentMode.center.\n\nSee Also\nControlling a Label's Alignment\nvar verticalAlignmentMode: SKLabelVerticalAlignmentMode\nThe vertical position of the text within the node.\nenum SKLabelVerticalAlignmentMode\nOptions for aligning text vertically.\nenum SKLabelHorizontalAlignmentMode\nOptions for aligning text horizontally."
  },
  {
    "title": "init(url:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407898-init",
    "html": "Parameters\nurl\n\nThe URL for the video to play.\n\nReturn Value\n\nAn initialized video node.\n\nSee Also\nCreating a Video Node\ninit(avPlayer: AVPlayer)\nInitializes a video node using an existing AVPlayer object.\ninit(fileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit?(coder: NSCoder)\nTells you when to initialize a video node that was created from an archive.\ninit(videoFileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(videoURL: URL)\nInitializes a video node using a URL that points to a video file."
  },
  {
    "title": "verticalAlignmentMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519933-verticalalignmentmode",
    "html": "Discussion\n\nThe possible values for this property are listed in SKLabelVerticalAlignmentMode. The default value of this property is SKLabelVerticalAlignmentMode.baseline.\n\nSee Also\nControlling a Label's Alignment\nenum SKLabelVerticalAlignmentMode\nOptions for aligning text vertically.\nvar horizontalAlignmentMode: SKLabelHorizontalAlignmentMode\nThe horizontal position of the text within the node.\nenum SKLabelHorizontalAlignmentMode\nOptions for aligning text horizontally."
  },
  {
    "title": "fontSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1520208-fontsize",
    "html": "Discussion\n\nThe default font size is 32 points.\n\nSee Also\nSpecifying a Label's Font\nvar fontColor: UIColor?\nThe color of the label.\nvar fontName: String?\nThe font used for the text in the label."
  },
  {
    "title": "fontName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1520129-fontname",
    "html": "See Also\nSpecifying a Label's Font\nvar fontColor: UIColor?\nThe color of the label.\nvar fontSize: CGFloat\nThe size of the font used in the label."
  },
  {
    "title": "fontColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1520057-fontcolor",
    "html": "Discussion\n\nThe default color is white.\n\nSee Also\nSpecifying a Label's Font\nvar fontName: String?\nThe font used for the text in the label.\nvar fontSize: CGFloat\nThe size of the font used in the label."
  },
  {
    "title": "init(fontNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519917-init",
    "html": "Parameters\nfontName\n\nThe name of the font used by the label.\n\nReturn Value\n\nAn initialized label object.\n\nSee Also\nCreating a Label\ninit(text: String?)\nInitializes a new label object with a text string.\ninit(attributedText: NSAttributedString?)\nInitializes a new label object with an attributed text string.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "setValue(_:forAttribute:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/2715849-setvalue",
    "html": "Parameters\nvalue\n\nAn attribute value object containing the scalar or vector value to set in the attached shader.\n\nkey\n\nThe attribute name.\n\nSee Also\nAdding a Custom Shader to a Sprite\nApplying Shaders to a Sprite\nWrite custom GLSL code that modifies the look of your sprite.\nvar shader: SKShader?\nA text file that defines code that does custom per-pixel drawing or colorization.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nSets the value of a shader attribute."
  },
  {
    "title": "Animating a Sprite by Changing its Texture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/animating_a_sprite_by_changing_its_texture",
    "html": "Overview\n\nA sprite’s texture property points to its current texture. You can change this property to point to a new texture. The next time the scene renders a new frame, it renders with the new texture. Whenever you change the texture, you may also need to change other sprite properties—such as size, anchorPoint, and centerRect—to be consistent with the new texture. Usually, it is better to ensure that all the artwork is consistent so that the same values can be used for all of the textures. That is, the textures should have a consistent size and anchor point placement so that your game does not need to update anything other than the texture.\n\nBecause animation is a common task, you can use actions to animate a series of textures on a sprite. The following code shows how to use an array of frames created to animate a sprite’s texture.\n\nlet walkAnimation = SKAction.animate(with: monsterWalkTextures,\n                                     timePerFrame: 0.1)\n\n\nnode.run(walkAnimation)\n// insert other code here to move the monster.\n\n\nSpriteKit provides you with the option of animating a sprite’s texture. It doesn’t impose a specific design on your animation system. This means you need to determine what kinds of animations a sprite may need and then design your own animation system to switch between those animations at runtime. For example, a monster might have walk, fight, idle, and death animation sequences—and it’s up to you to decide when to switch between these sequences."
  },
  {
    "title": "value(forAttributeNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/2715846-value",
    "html": "Parameters\nkey\n\nThe attribute name.\n\nReturn Value\n\nAn attribute value object containing the scalar or vector value or nil if no such attribute exists.\n\nSee Also\nAdding a Custom Shader to a Sprite\nApplying Shaders to a Sprite\nWrite custom GLSL code that modifies the look of your sprite.\nvar shader: SKShader?\nA text file that defines code that does custom per-pixel drawing or colorization.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader."
  },
  {
    "title": "attributeValues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/2715845-attributevalues",
    "html": "Discussion\n\nAll nodes have their own copy of an attribute value and therefore the attribute values can be different per-node across the same SKShader. If instead you need all nodes to share the same value, use SKUniform. Uniforms can change values every frame, but uniforms cannot vary per-node like attributes can.\n\nSee Also\nAdding a Custom Shader to a Sprite\nApplying Shaders to a Sprite\nWrite custom GLSL code that modifies the look of your sprite.\nvar shader: SKShader?\nA text file that defines code that does custom per-pixel drawing or colorization.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nSets the value of a shader attribute."
  },
  {
    "title": "shader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519714-shader",
    "html": "Discussion\n\nThe default value is nil, which means the default behavior for sprite rendering is performed. SpriteKit implements many sprite features using a default shader, such as:\n\nAnimations on alpha.\n\nSKTexture filteringMode.\n\nLight from SKLightNode.\n\nIf you supply a custom value for shader, your custom shader overrides the default shader which neutralizes the default features. It is the responsibility of your custom shader to implement any of the features your sprites require.\n\nSee Also\nAdding a Custom Shader to a Sprite\nApplying Shaders to a Sprite\nWrite custom GLSL code that modifies the look of your sprite.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nSets the value of a shader attribute."
  },
  {
    "title": "Lighting a Sprite with Light Nodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode/lighting_a_sprite_with_light_nodes",
    "html": "Overview\n\nYou can use a sprite’s lighting properties, lightingBitMask, shadowCastBitMask and shadowedBitMask, to apply effects such as illumination and shadow casting and receiving. These can be used in conjunction with normal mapping to simulate 3D lighting.\n\nThe following figure shows a normal mapped sprite node acting as background and two shadow casting sprite nodes (each with a rabbit texture).\n\nThe SKLightNode object's categoryBitMask matches the lighting bit mask of the background, and the lighting and shadow bit masks of the two rabbits:\n\n// Create the background sprite node\nlet background = SKSpriteNode(texture: noiseTexture,\n                              normalMap: noiseTexture.generatingNormalMap())\nbackground.position = spriteKitViewController.center\nbackground.lightingBitMask = 0b0001\nscene.addChild(background)\n     \nlet x: CGFloat = 150\nlet y = spriteKitViewController.scene.size.width - 150\n     \n// Create a light\nlet lightNode = SKLightNode()\nlightNode.position = CGPoint(x: scene.size.width / 2, y: y)\nlightNode.categoryBitMask = 0b0001\nlightNode.lightColor = .white\nscene.addChild(lightNode)\n     \n// Create two rabbit sprite nodes and assign them with both a lighting and a shadow cast bit mask.\nfor position in [CGPoint(x: x, y: y), CGPoint(x: y, y: y)] {\n                    let rabbit = SKSpriteNode(imageNamed: \"rabbit\")\n                    rabbit.position = position\n                    spriteKitViewController.scene.addChild(rabbit)\n                    rabbit.lightingBitMask = 0b0001\n                    rabbit.shadowCastBitMask = 0b0001\n}\n\n\nThe resulting scene shows the two rabbits casting shadows over the background (the light is rendered as a white circle). The noise texture gains a 3D look from the normal mapping:\n\nSee Also\nLighting a Sprite\nvar lightingBitMask: UInt32\nA mask that defines how this sprite is lit by light nodes in the scene.\nvar shadowedBitMask: UInt32\nA mask that defines which lights add shadows to the sprite.\nvar shadowCastBitMask: UInt32\nA mask that defines which lights are occluded by this sprite.\nvar normalTexture: SKTexture?\nA texture that specifies the normal map for the sprite."
  },
  {
    "title": "lightingBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519637-lightingbitmask",
    "html": "Discussion\n\nTo determine whether this sprite is lit by a light node, the sprite’s lightingBitMask property is tested against the light’s categoryBitMask property by performing a logical AND operation. If the comparison results in a nonzero value, the sprite is lit by this light.\n\nThe default value is 0x00000000 (all bits cleared).\n\nSee Also\nLighting a Sprite\nLighting a Sprite with Light Nodes\nAdd lighting and shadows to your scene with light nodes.\nvar shadowedBitMask: UInt32\nA mask that defines which lights add shadows to the sprite.\nvar shadowCastBitMask: UInt32\nA mask that defines which lights are occluded by this sprite.\nvar normalTexture: SKTexture?\nA texture that specifies the normal map for the sprite."
  },
  {
    "title": "Blending a Sprite with Different Interpretations of Alpha | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/blending_a_sprite_with_different_interpretations_of_alpha",
    "html": "Overview\n\nThe final stage of rendering is to blend the sprite’s texture into its destination frame buffer. The default behavior uses the alpha values of the texture to blend the texture with the destination pixels. However, you can use other blend modes when you want to add other special effects to a scene.\n\nYou control the sprite’s blending behavior using the blendMode property. For example, an additive blend mode is useful to combine multiple sprites together, for effects such as for fire or lighting. The following code shows how to position three overlapping sprite nodes in a circle to demonstrate the effect of different blend modes:\n\nlet blendMode = SKBlendMode.alpha\nlet imageNames = [\"redCircle\", \"greenCircle\", \"blueCircle\"]\n\n\nfor (index, imageName) in imageNames.enumerated() {\n    let node = SKSpriteNode(imageNamed: imageName)\n    \n    node.alpha = 0.5\n    node.blendMode = blendMode\n    \n    let angle = (CGFloat.pi * 2) / CGFloat(colors.count) * CGFloat(index)\n    \n    let positionX = 320 + sin(angle) * radius / 2\n    let positionY = 320 + cos(angle) * radius / 2\n    \n    node.position = CGPoint(x: positionX, y: positionY)\n    \n    scene.addChild(node)\n}\n\n\nWith the default blend mode of SKBlendMode.alpha, the thee circles look like:\n\nHowever, with a blend mode of SKBlendMode.add, the color values are added together, creating a scene that looks like:\n\nSee Also\nConfiguring Alpha Blendling\nvar blendMode: SKBlendMode\nThe blend mode used to draw the sprite into the parent’s framebuffer.\nenum SKBlendMode\nThe modes that describe how the source and destination pixel colors are used to calculate the new destination color."
  },
  {
    "title": "particleScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398014-particlescale",
    "html": "Discussion\n\nThe default value is 1.0.\n\nSee Also\nScaling Particles by a Factor\nvar particleScaleRange: CGFloat\nThe range of allowed random values for a particle’s initial scale.\nvar particleScaleSpeed: CGFloat\nThe rate at which a particle’s scale factor changes per second.\nvar particleScaleSequence: SKKeyframeSequence?\nThe sequence used to specify the scale factor of a particle over its lifetime."
  },
  {
    "title": "colorBlendFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519780-colorblendfactor",
    "html": "Discussion\n\nThe value must be a number between 0.0 and 1.0, inclusive. The default value (0.0) indicates the color property is ignored and that the texture’s values should be used unmodified. For values greater than 0.0, the texture is blended with the color before being drawn to the scene.\n\nSee Also\nTinting a Sprite\nTinting a Sprite\nProvide a color and blend factor to additively color your sprite.\nvar color: UIColor\nThe sprite’s color."
  },
  {
    "title": "emissionAngle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398035-emissionangle",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nControlling Particle Velocity and Acceleration\nvar particleSpeed: CGFloat\nThe average initial speed of a new particle, in points per second.\nvar particleSpeedRange: CGFloat\nThe range of allowed random values for a particle’s initial speed.\nvar emissionAngleRange: CGFloat\nThe range of allowed random values for a particle’s initial direction, expressed as an angle in radians.\nvar xAcceleration: CGFloat\nThe acceleration to apply to a particle’s horizontal velocity.\nvar yAcceleration: CGFloat\nThe acceleration to apply to a particle’s vertical velocity.\nvar particleZPositionSpeed: CGFloat\nThe speed at which the particle’s depth changes."
  },
  {
    "title": "xAcceleration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398017-xacceleration",
    "html": "Discussion\n\nThis property is useful for simulating wind, gravity and other effects. It is uniformly applied to all particles generated by the emitter.\n\nThe default value is 0.0.\n\nSee Also\nControlling Particle Velocity and Acceleration\nvar particleSpeed: CGFloat\nThe average initial speed of a new particle, in points per second.\nvar particleSpeedRange: CGFloat\nThe range of allowed random values for a particle’s initial speed.\nvar emissionAngle: CGFloat\nThe average initial direction of a particle, expressed as an angle in radians.\nvar emissionAngleRange: CGFloat\nThe range of allowed random values for a particle’s initial direction, expressed as an angle in radians.\nvar yAcceleration: CGFloat\nThe acceleration to apply to a particle’s vertical velocity.\nvar particleZPositionSpeed: CGFloat\nThe speed at which the particle’s depth changes."
  },
  {
    "title": "yAcceleration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1397982-yacceleration",
    "html": "Discussion\n\nThis property is useful for simulating wind, gravity and other effects. It is uniformly applied to all particles generated by the emitter.\n\nThe default value is 0.0.\n\nSee Also\nControlling Particle Velocity and Acceleration\nvar particleSpeed: CGFloat\nThe average initial speed of a new particle, in points per second.\nvar particleSpeedRange: CGFloat\nThe range of allowed random values for a particle’s initial speed.\nvar emissionAngle: CGFloat\nThe average initial direction of a particle, expressed as an angle in radians.\nvar emissionAngleRange: CGFloat\nThe range of allowed random values for a particle’s initial direction, expressed as an angle in radians.\nvar xAcceleration: CGFloat\nThe acceleration to apply to a particle’s horizontal velocity.\nvar particleZPositionSpeed: CGFloat\nThe speed at which the particle’s depth changes."
  },
  {
    "title": "emissionAngleRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398067-emissionanglerange",
    "html": "Discussion\n\nThe default value is 0.0. If non-zero, the emission angle of each particle is randomly determined and may vary by plus or minus half of the range value.\n\nSee Also\nControlling Particle Velocity and Acceleration\nvar particleSpeed: CGFloat\nThe average initial speed of a new particle, in points per second.\nvar particleSpeedRange: CGFloat\nThe range of allowed random values for a particle’s initial speed.\nvar emissionAngle: CGFloat\nThe average initial direction of a particle, expressed as an angle in radians.\nvar xAcceleration: CGFloat\nThe acceleration to apply to a particle’s horizontal velocity.\nvar yAcceleration: CGFloat\nThe acceleration to apply to a particle’s vertical velocity.\nvar particleZPositionSpeed: CGFloat\nThe speed at which the particle’s depth changes."
  },
  {
    "title": "numParticlesToEmit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode/1398043-numparticlestoemit",
    "html": "Discussion\n\nThe default value is 0, which indicates that emitter creates an endless stream of particles. If a non-zero value is provided, then the emitter stops generating particles after it has created the specified number of particles.\n\nSee Also\nControlling When Particles Are Created\nfunc advanceSimulationTime(TimeInterval)\nAdvances the emitter particle simulation.\nfunc resetSimulation()\nRemoves all existing particles and restarts the simulation.\nvar particleBirthRate: CGFloat\nThe rate at which new particles are created."
  },
  {
    "title": "isPositional | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode/1520418-ispositional",
    "html": "Discussion\n\nIf true, the audio mixer considers the position and velocity of the SKAudioNode relative to scene's current listener node. The mixer applies distance attenuation, doppler shift, and pan effects to the sound. If false, then the sound is played normally. The default value is true.\n\nSee Also\nConfiguring Audio Nodes\nvar avAudioNode: AVAudioNode?\nThe audio node’s current audio asset.\nvar autoplayLooped: Bool\nA Boolean value that indicates whether the audio should play in a loop when the node is added to the scene."
  },
  {
    "title": "avAudioNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode/1519633-avaudionode",
    "html": "Discussion\n\nThe AV audio node must refer to an AVAudioEngine sound graph from a single sound source or URL.\n\nSee Also\nConfiguring Audio Nodes\nvar isPositional: Bool\nA Boolean property that indicates whether the node’s audio is altered based on the position of the node.\nvar autoplayLooped: Bool\nA Boolean value that indicates whether the audio should play in a loop when the node is added to the scene."
  },
  {
    "title": "init(coder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode/1520341-init",
    "html": "Discussion\n\nDo not call this initializer directly; it's called by the system when you should initialize an audio node that has been unarchived.\n\nSee Also\nInitializing Audio Nodes\ninit(avAudioNode: AVAudioNode?)\nInitializes an audio node from an AVFoundation audio node.\ninit(fileNamed: String)\nInitializes an audio node from an audio asset with the specified filename.\ninit(url: URL)\nInitializes an audio node from an audio asset with the specified URL."
  },
  {
    "title": "init(url:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode/1519661-init",
    "html": "Parameters\nurl\n\nThe URL of an audio file.\n\nReturn Value\n\nA newly initialized audio node.\n\nSee Also\nInitializing Audio Nodes\ninit(avAudioNode: AVAudioNode?)\nInitializes an audio node from an AVFoundation audio node.\ninit(fileNamed: String)\nInitializes an audio node from an audio asset with the specified filename.\ninit?(coder: NSCoder)\nTells you when to initialize an audio node that has been unarchived."
  },
  {
    "title": "scnScene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519834-scnscene",
    "html": "See Also\nConfiguring a 3D Node\nvar viewportSize: CGSize\nThe size of the image rendered by the node.\nvar pointOfView: SCNNode?\nThe Scene Kit node from which the scene’s contents are viewed when rendered.\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether Scene Kit automatically adds lights to a scene."
  },
  {
    "title": "pointOfView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode/1519786-pointofview",
    "html": "Discussion\n\nUse a SCNNode object with an SCNCamera instance assigned to its camera property to view a scene. This SceneKit node provides the position and direction of a virtual camera, and the camera object provides rendering parameters such as field of view and focus. The direction of view is along the negative z-axis of the SceneKit node’s local coordinate space.\n\nSee Also\nConfiguring a 3D Node\nvar viewportSize: CGSize\nThe size of the image rendered by the node.\nvar scnScene: SCNScene?\nThe SceneKit scene to render.\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether Scene Kit automatically adds lights to a scene."
  },
  {
    "title": "Tinting a Sprite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/tinting_a_sprite",
    "html": "Overview\n\nYou can use the color and colorBlendFactor properties to colorize the texture applied to a sprite node. The color blend factor defaults to 0.0, which indicates that the texture should be used unmodified. As you increase this number, more of the texture color is replaced with the blended color. For example, when a monster in your game takes damage, you might want to add a red tint to the character. The following code shows how you would apply a tint to the sprite.\n\nmonsterSprite.color = .red\nmonsterSprite.colorBlendFactor = 0.5\n\n\nYou can also animate the color and color blend factors using actions. The following code shows how to briefly tint the sprite and then return it to normal.\n\nlet pulsedRed = SKAction.sequence([\n    SKAction.colorize(with: .red, colorBlendFactor: 1.0, duration: 0.15),\n    SKAction.wait(forDuration: 0.1),\n    SKAction.colorize(withColorBlendFactor: 0.0, duration: 0.15)])\nspaceship.run(pulsedRed)\n\n\nSee Also\nTinting a Sprite\nvar color: UIColor\nThe sprite’s color.\nvar colorBlendFactor: CGFloat\nA floating-point value that describes how the color is blended with the sprite’s texture."
  },
  {
    "title": "centerRect | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520119-centerrect",
    "html": "Discussion\n\nControls how the texture is stretched to fill the SKSpriteNode.\n\nThe argument rectangle is in the unit coordinate space with a default value of (0,0)-(1.0,1.0), which indicates that the entire texture is stretched to fill the sprite.\n\nIf instead you define a different rectangle, its coordinates are used to break the texture into a 3 x 3 grid that is scaled like the following:\n\nThe four corners of this grid are applied without performing any scaling.\n\nThe upper and lower-middle parts are scaled horizontally\n\nThe left and right-middle parts are scaled vertically\n\nThe center is scaled in all directions.\n\nThis is what's referred to as a 9-part scaling algorithm.\n\nSee Also\nScaling a Sprite in Nine Parts\nResizing a Sprite in Nine Parts\nScale a sprite using nine-part algorithm."
  },
  {
    "title": "Resizing a Sprite in Nine Parts | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/resizing_a_sprite_in_nine_parts",
    "html": "Overview\n\nThe size of the sprite node’s frame property is determined by the values of these properties:\n\nThe sprite node’s size property holds its base (unscaled) size. When a sprite is initialized using init(imageNamed:), the value of this property is initialized to be equal to the size of the supplied image.\n\nThe base size is then scaled by the sprite’s xScale and yScale properties inherited from the SKNode class.\n\nFor example, if the sprite node’s base size is 32 x 32 pixels and it has an xScale value of 1.0 and a yScale value of 2.0, the size of its frame is 32 x 64 pixels.\n\nNote\n\nThe scaling values of the sprite node’s ancestors in the scene are also used to scale it. This changes the effective size of the sprite without changing its actual frame value. See A Node Applies Many of Its Properties to Its Descendants.\n\nWhen a sprite node’s frame is larger than its texture, the texture is stretched to cover its frame. Normally, the texture is stretched uniformly across the frame, as shown in the following figure.\n\nHowever, sometimes you want to use sprite nodes to build user interface elements, such as buttons or health indicators. Often, these elements contain fixed-size elements, such as end caps, that should not be stretched. In this case, use a portion of the texture without stretching, and then stretch the remaining part of the texture over the rest of the frame.\n\nThe sprite’s centerRect property, which is specified in unit coordinates of the texture, controls the scaling behavior. The default value is a rectangle that covers the entire texture, which is why the entire texture is stretched across the frame. If you specify a rectangle that only covers a portion of the texture, you create a 3 x 3 grid. Each box in the grid has its own scaling behavior:\n\nThe portions of the texture in the four corners of the grid are drawn without any scaling.\n\nThe center of the grid is scaled in both dimensions.\n\nThe upper- and lower-middle parts are only scaled horizontally.\n\nThe left- and right-middle parts are only scaled vertically.\n\nThe following figure shows a close-up view of a texture you might use to draw a user interface button. The complete texture is 28 x 28 pixels. The corner pieces are each 12 x 12 pixels and the center is 4 x 4 pixels.\n\nThe following code shows how this button sprite would be initialized. The centerRect property is computed based on the design of the texture.\n\nlet button = SKSpriteNode(imageNamed: \"stretchable_button.png\")\nbutton.centerRect = CGRect(x: 12.0/28.0,\n                           y: 12.0/28.0,\n                           width: 4.0/28.0,\n                           height: 4.0/28.0)\n\n\nThe following figure shows that the corners remain the same, even when the button is drawn at different sizes.\n\nSee Also\nScaling a Sprite in Nine Parts\nvar centerRect: CGRect\nEnable nine-part stretching of the sprite's texture."
  },
  {
    "title": "scale(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1645445-scale",
    "html": "Discussion\n\nThis method works by setting the sprite node's xScale and yScale to achieve the specified size in its parent's coordinate space.\n\nSee Also\nSetting a Sprite's Size and Position\nUsing the Anchor Point to Move a Sprite\nLearn how the anchor point affects a sprite's position.\nvar size: CGSize\nThe dimensions of the sprite, in points.\nvar anchorPoint: CGPoint\nDefines the point in the sprite that corresponds to the node’s position."
  },
  {
    "title": "init(url:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreferencenode/1508366-init",
    "html": "Parameters\nreferenceURL\n\nThe URL of the reference node.\n\nReturn Value\n\nA newly initialized reference node.\n\nDiscussion\n\nThis intializer is for loading archives that reside outside of the app bundle."
  },
  {
    "title": "init(fileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreferencenode/1508369-init",
    "html": "Parameters\nfileName\n\nThe name of a file stored in the app’s main bundle.\n\nReturn Value\n\nA newly initialized reference node.\n\nDiscussion\n\nThis initializer is for loading files that reside inside of the app bundle."
  },
  {
    "title": "size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519668-size",
    "html": "See Also\nSetting a Sprite's Size and Position\nUsing the Anchor Point to Move a Sprite\nLearn how the anchor point affects a sprite's position.\nfunc scale(to: CGSize)\nScales the sprite node to a specified size.\nvar anchorPoint: CGPoint\nDefines the point in the sprite that corresponds to the node’s position."
  },
  {
    "title": "applyAngularImpulse(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520122-applyangularimpulse",
    "html": "Parameters\nimpulse\n\nThe magnitude of the impulse. The impulse is measured in Newton-seconds.\n\nDiscussion\n\nThis method affects the body’s angular velocity without changing the body’s linear velocity.\n\nSee Also\nApplying Forces and Impulses to a Physics Body\nMaking Physics Bodies Move\nMove a body using various physics properties, like velocity, gravity or impulses.\nfunc applyForce(CGVector)\nApplies a force to the center of gravity of a physics body.\nfunc applyTorque(CGFloat)\nApplies torque to an object.\nfunc applyForce(CGVector, at: CGPoint)\nApplies a force to a specific point of a physics body.\nfunc applyImpulse(CGVector)\nApplies an impulse to the center of gravity of a physics body.\nfunc applyImpulse(CGVector, at: CGPoint)\nApplies an impulse to a specific point of a physics body."
  },
  {
    "title": "texture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520011-texture",
    "html": "Discussion\n\nIf the value is nil, the sprite is drawn as a single-color rectangle using its color property. Otherwise, the texture is used to draw the sprite. The related properties affect how the texture is applied.\n\nSpriteKit automatically generates a texture for sprites when they are initialized with init(imageNamed:).\n\nSee Also\nCreating a Sprite from a Texture\ninit(texture: SKTexture?)\nInitializes a textured sprite using an existing texture object.\ninit(texture: SKTexture?, color: UIColor, size: CGSize)\nInitializes a textured sprite in color using an existing texture object.\ninit(texture: SKTexture?, size: CGSize)\nInitializes a textured sprite using an existing texture object but with a specified size.\ninit(texture: SKTexture?, normalMap: SKTexture?)\nInitializes a textured sprite with a normal map to simulate 3D lighting.\nRelated Documentation\nvar colorBlendFactor: CGFloat\nA floating-point value that describes how the color is blended with the sprite’s texture.\nvar centerRect: CGRect\nEnable nine-part stretching of the sprite's texture."
  },
  {
    "title": "init(texture:normalMap:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520153-init",
    "html": "Parameters\ntexture\n\nA SpriteKit texture used to draw the sprite.\n\nnormalMap\n\nA SpriteKit texture used to add lighting behavior to the sprite.\n\nReturn Value\n\nA newly initialized sprite object.\n\nSee Also\nCreating a Sprite from a Texture\ninit(texture: SKTexture?)\nInitializes a textured sprite using an existing texture object.\ninit(texture: SKTexture?, color: UIColor, size: CGSize)\nInitializes a textured sprite in color using an existing texture object.\ninit(texture: SKTexture?, size: CGSize)\nInitializes a textured sprite using an existing texture object but with a specified size.\nvar texture: SKTexture?\nThe texture used to draw the sprite."
  },
  {
    "title": "init(texture:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519812-init",
    "html": "Parameters\ntexture\n\nA SpriteKit texture.\n\nsize\n\nThe size of the sprite in points.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThe sprite is initialized using the texture, but the texture’s dimensions are not used. Instead, the size passed into the constructor method is used.\n\nSee Also\nCreating a Sprite from a Texture\ninit(texture: SKTexture?)\nInitializes a textured sprite using an existing texture object.\ninit(texture: SKTexture?, color: UIColor, size: CGSize)\nInitializes a textured sprite in color using an existing texture object.\ninit(texture: SKTexture?, normalMap: SKTexture?)\nInitializes a textured sprite with a normal map to simulate 3D lighting.\nvar texture: SKTexture?\nThe texture used to draw the sprite."
  },
  {
    "title": "init(texture:color:size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520029-init",
    "html": "Parameters\ntexture\n\nA texture to apply to the sprite.\n\ncolor\n\nThe color for the new sprite.\n\nsize\n\nThe size for the new sprite.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nTo colorize your texture, you also need to set the colorBlendFactor property of the sprite.\n\nSee Also\nCreating a Sprite from a Texture\ninit(texture: SKTexture?)\nInitializes a textured sprite using an existing texture object.\ninit(texture: SKTexture?, size: CGSize)\nInitializes a textured sprite using an existing texture object but with a specified size.\ninit(texture: SKTexture?, normalMap: SKTexture?)\nInitializes a textured sprite with a normal map to simulate 3D lighting.\nvar texture: SKTexture?\nThe texture used to draw the sprite.\nRelated Documentation\nvar colorBlendFactor: CGFloat\nA floating-point value that describes how the color is blended with the sprite’s texture."
  },
  {
    "title": "init(imageNamed:normalMapped:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519721-init",
    "html": "Parameters\nname\n\nThe name of an image file stored in the app bundle.\n\ngenerateNormalMap\n\nIf true, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If false, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThe normal map is used only when lighting is enabled in the scene. For more information, see Lighting a Sprite and SKLightNode.\n\nSee Also\nCreating a Sprite from an Image Filename\nGetting Started with Sprite Nodes\nLearn the basics about using images, also known as sprites, with SpriteKit.\ninit(imageNamed: String)\nInitializes a textured sprite using an image file."
  },
  {
    "title": "init(texture:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519942-init",
    "html": "Parameters\ntexture\n\nA SpriteKit texture.\n\nReturn Value\n\nA newly initialized sprite object.\n\nDiscussion\n\nThe size property of the sprite is set to the dimensions of the texture. The color property is set to white with an alpha of zero (1.0,1.0,1.0,0.0).\n\nSee Also\nCreating a Sprite from a Texture\ninit(texture: SKTexture?, color: UIColor, size: CGSize)\nInitializes a textured sprite in color using an existing texture object.\ninit(texture: SKTexture?, size: CGSize)\nInitializes a textured sprite using an existing texture object but with a specified size.\ninit(texture: SKTexture?, normalMap: SKTexture?)\nInitializes a textured sprite with a normal map to simulate 3D lighting.\nvar texture: SKTexture?\nThe texture used to draw the sprite."
  },
  {
    "title": "Getting Started with Sprite Nodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/getting_started_with_sprite_nodes",
    "html": "Overview\n\nThe simplest way to create a textured sprite node is to have SpriteKit create both the texture and the sprite for you. You store the artwork in the app bundle (ideally in an asset catalog), and then load it at runtime, as shown in this code:\n\nlet spaceship = SKSpriteNode(imageNamed: \"rocket.png\")\nspaceship.position = CGPoint(x: 100, y: 100)\nself.addChild(spaceship)\n\n\nDefault Behavior\n\nWhen you create a sprite as shown in the code above, you get a lot of default behavior for free:\n\nThe sprite node is created with a frame that matches the texture’s size.\n\nThe node is rendered so that it is centered on its position. The node's frame property holds the rectangle that defines the area it covers.\n\nThe texture is alpha blended into the frame buffer.\n\nAn SKTexture object is created and attached to the node. This texture object automatically loads the texture data whenever the sprite node is in the scene, is visible, and is necessary for rendering the scene. Later, if the sprite is removed from the scene or is no longer visible, SpriteKit can delete the texture data if it needs that memory for other purposes. This automatic memory management simplifies but does not eliminate the work you need to do to manage art assets in your game.\n\nTextures\n\nAlthough SpriteKit can create textures for you automatically when a sprite is created, in more complex apps you need finer control over textures. For example, you might want to do any of the following:\n\nShare a texture between multiple sprites.\n\nChange a sprite’s texture after it is created.\n\nAnimate a sprite through a series of textures.\n\nCreate textures from data that is not directly stored in the app bundle.\n\nRender a node tree into a texture. For example, you might want to take a screenshot of your gameplay to show to the player after he or she completes the level.\n\nPreload textures into memory before presenting a scene.\n\nYou do all of these things by working directly with texture objects. For more information, see the SKTexture class reference.\n\nCustomized Rendering Stages\n\nYou can use each sprite node’s properties to independently configure four distinct rendering stages:\n\nMove a sprite node’s frame so that a different point in the texture is placed at its position. See Using the Anchor Point to Move the Sprite Node’s Frame.\n\nResize a sprite node. You control how the texture is applied to the sprite when the size of the sprite does not match the size of the texture. See Resizing a Sprite in 9 Parts.\n\nColorize a sprite node’s texture when it is applied to the sprite. See Colorizing a Sprite Node.\n\nUse other blend modes in a sprite node to combine its contents with that of the framebuffer. Custom blend modes are useful for lighting and other special effects. See Blending the Sprite into the Frame Buffer.\n\nArt and Property Configuration Matching\n\nOften, configuring a sprite node to perform these four steps—positioning, sizing, colorizing, and blending—is based on the artwork used to create its texture. This means that you rarely set property values in isolation from the artwork. You work with your artist to ensure that your game is configuring the sprites to match the artwork.\n\nHere are some of the possible strategies you can follow:\n\nCreate the sprite nodes with hardcoded values in your project. This is the fastest approach, but the least desirable in the long term, because it means that the code must be changed whenever the art assets change.\n\nCreate your own tools using SpriteKit to fine tune the sprite’s property values. When you have a sprite node configured the way you want it, save the sprite to an archive. Your game uses the archive to create sprites at runtime.\n\nStore the configuration data in a property list that is stored in your app bundle. When the sprite node is loaded, load the property list and use its values to configure the node. Your artist can then provide the correct values and change them without requiring changes to your code.\n\nSee Also\nCreating a Sprite from an Image Filename\ninit(imageNamed: String)\nInitializes a textured sprite using an image file.\ninit(imageNamed: String, normalMapped: Bool)\nInitializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting."
  },
  {
    "title": "applyImpulse(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519900-applyimpulse",
    "html": "Parameters\nimpulse\n\nA vector that describes how much momentum was imparted in each dimension. The impulse is measured in Newton-seconds.\n\nDiscussion\n\nThis method affects the body’s linear velocity without changing the body’s angular velocity.\n\nSee Also\nApplying Forces and Impulses to a Physics Body\nMaking Physics Bodies Move\nMove a body using various physics properties, like velocity, gravity or impulses.\nfunc applyForce(CGVector)\nApplies a force to the center of gravity of a physics body.\nfunc applyTorque(CGFloat)\nApplies torque to an object.\nfunc applyForce(CGVector, at: CGPoint)\nApplies a force to a specific point of a physics body.\nfunc applyAngularImpulse(CGFloat)\nApplies an impulse that imparts angular momentum to an object.\nfunc applyImpulse(CGVector, at: CGPoint)\nApplies an impulse to a specific point of a physics body.\nRelated Documentation\nvar mass: CGFloat\nThe mass of the body, in kilograms."
  },
  {
    "title": "restitution | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520447-restitution",
    "html": "Discussion\n\nThis property is used to determine how much energy the physics body loses when it bounces off another object. The property must be a value between 0.0 and 1.0. The default value is 0.2.\n\nSee Also\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar area: CGFloat\nThe area covered by the body.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity."
  },
  {
    "title": "applyTorque(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519588-applytorque",
    "html": "Parameters\ntorque\n\nThe amount of torque, in Newton-meters.\n\nDiscussion\n\nThis method generates an angular acceleration on the body without causing any linear acceleration. The force is applied for a single simulation step (one frame).\n\nSee Also\nApplying Forces and Impulses to a Physics Body\nMaking Physics Bodies Move\nMove a body using various physics properties, like velocity, gravity or impulses.\nfunc applyForce(CGVector)\nApplies a force to the center of gravity of a physics body.\nfunc applyForce(CGVector, at: CGPoint)\nApplies a force to a specific point of a physics body.\nfunc applyImpulse(CGVector)\nApplies an impulse to the center of gravity of a physics body.\nfunc applyAngularImpulse(CGFloat)\nApplies an impulse that imparts angular momentum to an object.\nfunc applyImpulse(CGVector, at: CGPoint)\nApplies an impulse to a specific point of a physics body.\nRelated Documentation\nvar mass: CGFloat\nThe mass of the body, in kilograms."
  },
  {
    "title": "Making Physics Bodies Move | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/making_physics_bodies_move",
    "html": "Overview\n\nBy default, only gravity is applied to physics bodies in the scene. In some cases, that might be enough to build a game. But in most cases, you need to take other steps to change the speed of physics bodies.\n\nFirst, you can control a physics body’s velocity directly, by setting its velocity and angularVelocity properties. As with many other properties, you often set these properties once when the physics body is first created and then let the physics simulation adjust them as necessary. For example, assume for a moment you are making a space-based game where a rocket ship can fire missiles. When the ship fires a missile, the missile should have a starting velocity of the ship plus an additional vector in the direction of the launch. The following code shows one implementation for calculating the launch velocity.\n\nListing 1 Calculating the missile’s initial velocity\n\nmissile.physicsBody?.velocity = self.physicsBody!.velocity\nmissile.physicsBody?.applyImpulse(CGVector(dx: missileLaunchImpulse * cos(shipDirection),\n                                           dy: missileLaunchImpulse * sin(shipDirection)))\n\n\nWhen a body is in the simulation, it is more common for the velocity to be adjusted based on forces applied to the body. Another source of velocity changes, collisions, is discussed later.\n\nThe default collection of forces that apply to a body include:\n\nThe gravitational force applied by the physics world\n\nThe damping forces applied by the body’s own properties\n\nA frictional force based on contact with another body in the system\n\nYou can also apply your own forces and impulses to physics bodies. Most often, you apply forces and impulses in a pre-processing step before the simulation executes. Your game logic is responsible for determining which forces need to be applied and for making the appropriate method calls to apply those forces.\n\nYou can choose to apply either a force or an impulse:\n\nA force is applied for a length of time based on the amount of simulation time that passes between when you apply the force and when the next frame of the simulation is processed. So, to apply a continuous force to an body, you need to make the appropriate method calls each time a new frame is processed. Forces are usually used for continuous effects\n\nAn impulse makes an instantaneous change to the body’s velocity that is independent of the amount of simulation time that has passed. Impulses are usually used for immediate changes to a body’s velocity.\n\nTo continue with the rocket example, a rocket ship probably applies a force to itself when it turns on its engines. However, when it fires a missile, it might launch the missile with the rocket’s own velocity and then apply a single impulse to it to give it the initial burst of speed.\n\nBecause forces and impulses are modeling the same concept—adjusting a body’s velocity—the remainder of this section focuses on forces.\n\nYou can apply a force to a body in one of three ways:\n\nA linear force that only affects the body’s linear velocity.\n\nAn angular force that only affects the body’s angular velocity.\n\nA force applied to a point on the body. The physics simulation calculates separate changes to the body’s angular and linear velocity, based on the shape of the object and the point where the force was applied.\n\nThe following code shows code you could implement in a sprite subclass to apply a force to the ship. This force accelerates the rocket when the main engines are activated. Because the engines are at the back of the rocket, the force is applied to linearly to the rocket body. The code calculates the thrust vector based on the current orientation of the rocket. The orientation is based on the zRotation property of the corresponding node, but the orientation of the artwork may differ from the orientation of the node. The thrust should always be oriented with the artwork. The following code shows a similar effect, but this time the rocket is being rotated by the force, so the thrust is applied as an angular thrust.\n\nListing 2 Applying lateral thrust\n\nself.physicsBody?.applyTorque(thrust)\n\n\nSee Also\nApplying Forces and Impulses to a Physics Body\nfunc applyForce(CGVector)\nApplies a force to the center of gravity of a physics body.\nfunc applyTorque(CGFloat)\nApplies torque to an object.\nfunc applyForce(CGVector, at: CGPoint)\nApplies a force to a specific point of a physics body.\nfunc applyImpulse(CGVector)\nApplies an impulse to the center of gravity of a physics body.\nfunc applyAngularImpulse(CGFloat)\nApplies an impulse that imparts angular momentum to an object.\nfunc applyImpulse(CGVector, at: CGPoint)\nApplies an impulse to a specific point of a physics body."
  },
  {
    "title": "collisionBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520003-collisionbitmask",
    "html": "Discussion\n\nWhen two physics bodies contact each other, a collision may occur. This body’s collision mask is compared to the other body’s category mask by performing a logical AND operation. If the result is a nonzero value, this body is affected by the collision. Each body independently chooses whether it wants to be affected by the other body. For example, you might use this to avoid collision calculations that would make negligible changes to a body’s velocity.\n\nThe default value is 0xFFFFFFFF (all bits set).\n\nSee Also\nWorking with Collisions and Contacts\nAbout Collisions and Contacts\nLearn how to set up nodes for collision detection.\nvar categoryBitMask: UInt32\nA mask that defines which categories this physics body belongs to.\nvar usesPreciseCollisionDetection: Bool\nA Boolean value that determines whether the physics world uses an iterative collision detection algorithm.\nvar contactTestBitMask: UInt32\nA mask that defines which categories of physics bodies cause intersection notifications with this physics body.\nfunc allContactedBodies() -> [SKPhysicsBody]\nThe physics bodies that this physics body is in contact with."
  },
  {
    "title": "allContactedBodies() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520397-allcontactedbodies",
    "html": "Return Value\n\nAn array of SKPhysicsBody objects that this body is in contact with.\n\nSee Also\nWorking with Collisions and Contacts\nAbout Collisions and Contacts\nLearn how to set up nodes for collision detection.\nvar categoryBitMask: UInt32\nA mask that defines which categories this physics body belongs to.\nvar collisionBitMask: UInt32\nA mask that defines which categories of physics bodies can collide with this physics body.\nvar usesPreciseCollisionDetection: Bool\nA Boolean value that determines whether the physics world uses an iterative collision detection algorithm.\nvar contactTestBitMask: UInt32\nA mask that defines which categories of physics bodies cause intersection notifications with this physics body."
  },
  {
    "title": "About Collisions and Contacts | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/about_collisions_and_contacts",
    "html": "Overview\n\nSpriteKit supports two kinds of interaction between physics bodies that come into contact or attempt to occupy the same space:\n\nA contact is used when you need to know that two bodies are touching each other. In most cases, you use contacts when you need to make gameplay changes when a collision occurs.\n\nA collision is used to prevent two objects from interpenetrating each other. When one body strikes another body, SpriteKit automatically computes the results of the collision and applies impulse to the bodies in the collision.\n\nInteraction Limits\n\nYour game configures the physics bodies in the scene to determine when collisions should occur and when interactions between physics bodies require additional game logic to be performed. Limiting these interactions is not only important for defining your game’s logic, it is also necessary in order to get good performance from SpriteKit.\n\nSpriteKit uses two mechanisms to limit the number of interactions in each frame:\n\nEdge-based physics bodies never interact with other edge-based physics bodies. This means that even if you move them by repositioning the nodes, edge-based physics bodies never collide or contact each other.\n\nEvery physics body is categorized. Categories are defined by your app; each scene can have up to 32 categories. When you configure a physics body, you define which categories it belongs to and which categories of bodies it should interact with. You define contacts and collisions separately.\n\nThe following code creates a red and a blue ball, and a ground object constructed from a series of points. By giving the red ball a collisionBitMask that matches the ground’s categoryBitMask, you make the red ball bounce off the ground. However, the blue ball’s collisionBitMask is set to a different value and doesn’t interact with the ground.\n\nlet ballRadius: CGFloat = 20\nlet redBall = SKShapeNode(circleOfRadius: ballRadius)\nredBall.fillColor = .red\nredBall.position = CGPoint(x: 280, y: 320)\nredBall.physicsBody = SKPhysicsBody(circleOfRadius: ballRadius)\n\n\nlet blueBall = SKShapeNode(circleOfRadius: ballRadius)\nblueBall.fillColor = .blue\nblueBall.position = CGPoint(x: 360, y: 320)\nblueBall.physicsBody = SKPhysicsBody(circleOfRadius: ballRadius)\n\n\nvar splinePoints = [CGPoint(x: 0, y: 300),\n                    CGPoint(x: 100, y: 50),\n                    CGPoint(x: 400, y: 110),\n                    CGPoint(x: 640, y: 20)]\nlet ground = SKShapeNode(splinePoints: &splinePoints,\n                         count: splinePoints.count)\nground.physicsBody = SKPhysicsBody(edgeChainFrom: ground.path!)\nground.physicsBody?.restitution = 0.75\n\n\nredBall.physicsBody?.collisionBitMask = 0b0001\nblueBall.physicsBody?.collisionBitMask = 0b0010\nground.physicsBody?.categoryBitMask = 0b0001\n\n\nThe following image shows the paths taken by both balls when the code above is executed.\n\nSee Also\nWorking with Collisions and Contacts\nvar categoryBitMask: UInt32\nA mask that defines which categories this physics body belongs to.\nvar collisionBitMask: UInt32\nA mask that defines which categories of physics bodies can collide with this physics body.\nvar usesPreciseCollisionDetection: Bool\nA Boolean value that determines whether the physics world uses an iterative collision detection algorithm.\nvar contactTestBitMask: UInt32\nA mask that defines which categories of physics bodies cause intersection notifications with this physics body.\nfunc allContactedBodies() -> [SKPhysicsBody]\nThe physics bodies that this physics body is in contact with."
  },
  {
    "title": "usesPreciseCollisionDetection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520014-usesprecisecollisiondetection",
    "html": "Discussion\n\nWhen SpriteKit performs collision detection, it first determines the locations of all of the physics bodies in the scene. Then it determines whether collisions or contacts occurred. This computational method is fast, but can sometimes result in missed collisions. A small body might move so fast that it completely passes through another physics body without ever having a frame of animation where the two touch each other.\n\nIf you have physics bodies that must collide, you can hint to SpriteKit to use a more precise collision model to check for interactions. This model is more expensive, so it should be used sparingly. When either body uses precise collisions, multiple contact iterations are evaluated to ensure that all contacts are detected.\n\nThe default value is false. If two bodies in a collision do not perform precise collision detection, and one passes completely through the other in a single frame, no collision is detected. If this property is set to true on either body, the simulation performs a more precise and more expensive calculation to detect these collisions. This property should be set to true on small, fast moving bodies.\n\nSee Also\nWorking with Collisions and Contacts\nAbout Collisions and Contacts\nLearn how to set up nodes for collision detection.\nvar categoryBitMask: UInt32\nA mask that defines which categories this physics body belongs to.\nvar collisionBitMask: UInt32\nA mask that defines which categories of physics bodies can collide with this physics body.\nvar contactTestBitMask: UInt32\nA mask that defines which categories of physics bodies cause intersection notifications with this physics body.\nfunc allContactedBodies() -> [SKPhysicsBody]\nThe physics bodies that this physics body is in contact with."
  },
  {
    "title": "init(circleOfRadius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520261-init",
    "html": "Parameters\nr\n\nThe radius of the circle.\n\nReturn Value\n\nA new volume-based physics body.\n\nDiscussion\n\nThe following code shows the code that creates the physics body for a spherical or circular object. Because the physics body is attached to a sprite object, it usually needs volume. In this case, the sprite image is assumed to closely approximate a circle centered on the anchor point, so the radius of the circle is calculated and used to create the physics body.\n\nListing 1 A physics body for a circular sprite\nlet sprite = SKSpriteNode(imageNamed: \"sphere.png\")\nsprite.physicsBody = SKPhysicsBody(circleOfRadius: sprite.size.width / 2)\nsprite.physicsBody?.isDynamic = true\n\n\nIf the physics body were significantly smaller than the sprite’s image, the data used to create the physics body might need to be provided by some other source, such as a property list.\n\nSee Also\nCreating a Body from a Shape\ninit(circleOfRadius: CGFloat, center: CGPoint)\nCreates a circular physics body centered on an arbitrary point.\ninit(rectangleOf: CGSize)\nCreates a rectangular physics body centered on the owning node’s origin.\ninit(rectangleOf: CGSize, center: CGPoint)\nCreates a rectangular physics body centered on an arbitrary point.\ninit(polygonFrom: CGPath)\nCreates a polygonal physics body.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "init(circleOfRadius:center:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519692-init",
    "html": "Parameters\nr\n\nThe radius of the circle.\n\ncenter\n\nThe origin of the circle in the owning node’s coordinate system.\n\nReturn Value\n\nA new volume-based physics body.\n\nSee Also\nCreating a Body from a Shape\ninit(circleOfRadius: CGFloat)\nCreates a circular physics body centered on the owning node’s origin.\ninit(rectangleOf: CGSize)\nCreates a rectangular physics body centered on the owning node’s origin.\ninit(rectangleOf: CGSize, center: CGPoint)\nCreates a rectangular physics body centered on an arbitrary point.\ninit(polygonFrom: CGPath)\nCreates a polygonal physics body."
  },
  {
    "title": "init(rectangleOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520295-init",
    "html": "Parameters\ns\n\nThe size of the rectangle.\n\nReturn Value\n\nA new volume-based physics body.\n\nSee Also\nCreating a Body from a Shape\ninit(circleOfRadius: CGFloat)\nCreates a circular physics body centered on the owning node’s origin.\ninit(circleOfRadius: CGFloat, center: CGPoint)\nCreates a circular physics body centered on an arbitrary point.\ninit(rectangleOf: CGSize, center: CGPoint)\nCreates a rectangular physics body centered on an arbitrary point.\ninit(polygonFrom: CGPath)\nCreates a polygonal physics body."
  },
  {
    "title": "init(rectangleOf:center:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519936-init",
    "html": "Parameters\ns\n\nThe size of the rectangle.\n\ncenter\n\nThe center of the square in the owning node’s coordinate system.\n\nReturn Value\n\nA new volume-based physics body.\n\nSee Also\nCreating a Body from a Shape\ninit(circleOfRadius: CGFloat)\nCreates a circular physics body centered on the owning node’s origin.\ninit(circleOfRadius: CGFloat, center: CGPoint)\nCreates a circular physics body centered on an arbitrary point.\ninit(rectangleOf: CGSize)\nCreates a rectangular physics body centered on the owning node’s origin.\ninit(polygonFrom: CGPath)\nCreates a polygonal physics body."
  },
  {
    "title": "init(polygonFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520379-init",
    "html": "Parameters\npath\n\nA convex polygonal path with counterclockwise winding and no self intersections. The points are specified relative to the owning node’s origin.\n\nReturn Value\n\nA new volume-based physics body.\n\nSee Also\nCreating a Body from a Shape\ninit(circleOfRadius: CGFloat)\nCreates a circular physics body centered on the owning node’s origin.\ninit(circleOfRadius: CGFloat, center: CGPoint)\nCreates a circular physics body centered on an arbitrary point.\ninit(rectangleOf: CGSize)\nCreates a rectangular physics body centered on the owning node’s origin.\ninit(rectangleOf: CGSize, center: CGPoint)\nCreates a rectangular physics body centered on an arbitrary point."
  },
  {
    "title": "Shaping a Physics Body to Match a Node's Graphics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/shaping_a_physics_body_to_match_a_node_s_graphics",
    "html": "Overview\n\nIn most cases, a physics body should have a size and shape that closely approximates the visual representation of the corresponding node. For example, the rocket shown below has a narrow shape that is not well represented by either a circle or a rectangle. A convex polygon shape is chosen and fitted to match the sprite’s artwork.\n\nShape a Physics Body Using a Texture's Alpha Channel\n\nIf you do not want to create your own shapes, you can use SpriteKit to create a shape for you based on the sprite’s texture.\n\nlet sprite = SKSpriteNode(imageNamed: \"Spaceship\")\nsprite.physicsBody = SKPhysicsBody(texture: sprite.texture!,\n                                   size: sprite.texture!.size())\n\n\nChoose a Simple Geometric Physics Body Shape\n\nWhen choosing a shape for your physics body, do not be overly precise. More complex shapes require more work to be properly simulated. For volume-based bodies, use the following guidelines:\n\nA circle is the most efficient shape (init(circleOfRadius:))\n\nA path-based polygon is the least efficient shape, and the computational work scales with the complexity of the polygon (init(polygonFrom:))\n\nUse Edge-Based Physics Bodies Only When Needed\n\nAn edge-based body is more expensive to compute than a volume-based body. This is because the bodies it interacts with can potentially be on either side of an open edge or on the inside or outside of a closed shape. Use these guidelines:\n\nLines and rectangles are the most efficient edge-based bodies (init(edgeFrom:to:) and init(edgeLoopFrom:))\n\nEdge loops and edge chains are the most expensive edge-based bodies, and the computational work scales with the complexity of the path (init(edgeLoopFrom:) and init(edgeChainFrom:)).\n\nSee Also\nCreating a Body from a Texture\ninit(texture: SKTexture, size: CGSize)\nCreates a physics body from the contents of a texture.\ninit(texture: SKTexture, alphaThreshold: Float, size: CGSize)\nCreates a physics body from the contents of a texture, capturing only the texels that exceed a specified transparency value."
  },
  {
    "title": "init(bodies:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519736-init",
    "html": "Parameters\nbodies\n\nAn array of SKPhysicsBody objects. The objects must be volume-based physics bodies. (You may not use a compound body created using this method in the array.)\n\nReturn Value\n\nA new compound-physics body.\n\nDiscussion\n\nThe shapes of the physics bodies passed into this method are used to create a new physics body whose covered area is the union of the areas of its children. These areas do not need to be contiguous. If there is space between two parts, other bodies may be able to pass between these parts. However, the physics body is treated as a single connected body, meaning that a force or impulse applied to the body affects all of the pieces as if they are held together with an indestructible frame.\n\nThe properties on the children, such as mass or friction, are ignored. Only the shapes of the child bodies are used."
  },
  {
    "title": "Creating an Edge Loop Around a Scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/creating_an_edge_loop_around_a_scene",
    "html": "Overview\n\nWhen you want to confine your in-app objects to a specific region, use an edge-based physics body to define the area. In an app that models a pool table, for example, the balls are the in-app objects, and the table edges collectively create an edge loop. The following code demonstrates creating an edge loop to implement an impenetrable boundary that extends from edge to edge in the scene.\n\nfunc createSceneContents() {\n    self.backgroundColor = .black\n    self.scaleMode = .aspectFit\n    self.physicsBody = SKPhysicsBody(edgeLoopFrom: self.frame)\n}\n\n\nSee Also\nCreating an Edge-Based Physics Body\ninit(edgeLoopFrom: CGRect)\nCreates an edge loop from a rectangle.\ninit(edgeFrom: CGPoint, to: CGPoint)\nCreates an edge between two points.\ninit(edgeLoopFrom: CGPath)\nCreates an edge loop from a path.\ninit(edgeChainFrom: CGPath)\nCreates an edge chain from a path."
  },
  {
    "title": "init(edgeLoopFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520055-init",
    "html": "Parameters\nrect\n\nThe rectangle that defines the edges. The rectangle is specified relative to the owning node’s origin.\n\nReturn Value\n\nA new edge-based physics body.\n\nDiscussion\n\nAn edge has no volume or mass and is always treated as if the isDynamic property is equal to false. Edges may only collide with volume-based physics bodies.\n\nSee Also\nCreating an Edge-Based Physics Body\nCreating an Edge Loop Around a Scene\nBorder your scene with an obstacle that physics bodies cannot penetrate.\ninit(edgeFrom: CGPoint, to: CGPoint)\nCreates an edge between two points.\ninit(edgeLoopFrom: CGPath)\nCreates an edge loop from a path.\ninit(edgeChainFrom: CGPath)\nCreates an edge chain from a path."
  },
  {
    "title": "size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407916-size",
    "html": "Discussion\n\nThe default value is the size of the video used to instantiate the node.\n\nSee Also\nSetting the Video Node’s Visual Properties\nvar anchorPoint: CGPoint\nThe point in the sprite that corresponds to the node’s position."
  },
  {
    "title": "colorBlendFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519724-colorblendfactor",
    "html": "Discussion\n\nThe value must be a number between 0.0 and 1.0, inclusive. The default value (0.0) indicates that the color property is ignored and that the label’s font color should be used unmodified. For values greater than 0.0, the font color is blended with the blend color, with the maximum value of 1.0 determining that the font color is 100% of the blend color.\n\nSee Also\nColorizing a Label\nvar color: UIColor?\nAn alternative to the font color that can be used for animations."
  },
  {
    "title": "blendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519598-blendmode",
    "html": "Discussion\n\nThe default value is SKBlendMode.alpha."
  },
  {
    "title": "lineBreakMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/2865818-linebreakmode",
    "html": "Discussion\n\nThe default value is NSLineBreakByTruncatingTail.\n\nSee Also\nDefining a Label's Line-Breaking Behavior\nvar preferredMaxLayoutWidth: CGFloat\nThe width, in screen points, after which line-break mode should be applied.\nvar numberOfLines: Int\nDetermines the number of lines to draw."
  },
  {
    "title": "numberOfLines | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/2865815-numberoflines",
    "html": "Discussion\n\nThe default value is 1 (a single line). A value of 0 in interpreted as an unlimited number of lines. If the height of the text reaches the number of lines, the text will be truncated using the line break mode.\n\nSee Also\nDefining a Label's Line-Breaking Behavior\nvar preferredMaxLayoutWidth: CGFloat\nThe width, in screen points, after which line-break mode should be applied.\nvar lineBreakMode: NSLineBreakMode\nDetermines the line-break mode for multiple lines."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode/1519938-color",
    "html": "See Also\nColorizing a Label\nvar colorBlendFactor: CGFloat\nA floating-point value that describes how the color is blended with the font color."
  },
  {
    "title": "init(fileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/1407922-init",
    "html": "Parameters\nvideoFile\n\nThe name of the video file.\n\nReturn Value\n\nAn initialized video node.\n\nSee Also\nCreating a Video Node\ninit(avPlayer: AVPlayer)\nInitializes a video node using an existing AVPlayer object.\ninit(url: URL)\nInitializes a video node using a URL.\ninit?(coder: NSCoder)\nTells you when to initialize a video node that was created from an archive.\ninit(videoFileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(videoURL: URL)\nInitializes a video node using a URL that points to a video file."
  },
  {
    "title": "Adding a Video to a Scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode/adding_a_video_to_a_scene",
    "html": "Overview\n\nA video node renders a video at a given size and location in your scene with no exposed player controls. You might use a video node to animate visual behaviors that would be expensive to define using a collection of textures.\n\nBe aware that a video node offers only a subset of the features available to the SKSpriteNode class. The following are a video node's relevant limitations:\n\nA video node is always scaled proportionally.\n\nA video node cannot be colorized. However, it can be added as a child of a SKEffectNode to add Core Image filters for color treatments and other effects.\n\nA video node always uses an alpha blend mode.\n\nA video node cannot use custom shaders or lighting.\n\nWhen a video node is created, its size property is initialized to the base size of the video content, but you can change it. The video content is automatically stretched to the new size. As with a sprite node, the anchorPoint property defines where the content is displayed relative to the node position.\n\nThe following code initializes the video node using a video file stored in the app bundle and then adds the node to the scene. It calls the node’s play() method to start the video playback.\n\nlet sample = SKVideoNode(fileNamed: \"sample.mov\")\nsample.position = CGPoint(x: frame.midX,\n                          y: frame.midY)\naddChild(sample)\nsample.play()\n\n\nYou control playback using the node’s play() and pause() methods.\n\nIf you need more precise control over the video playback behavior, you can use AVFoundation to create an AVPlayer object for your video content and then use this object to initialize the SKVideoNode node. Then, instead of using the node’s playback methods, you use the AVPlayer object to control playback. The video content is automatically displayed in the video node. For more information, see AVFoundation Programming Guide."
  },
  {
    "title": "normalTexture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1519657-normaltexture",
    "html": "Discussion\n\nA normal map texture is used when a sprite is lit, giving it a more realistic look with shadows and specular highlights. The texture must be a normal map texture.\n\nSee Also\nLighting a Sprite\nLighting a Sprite with Light Nodes\nAdd lighting and shadows to your scene with light nodes.\nvar lightingBitMask: UInt32\nA mask that defines how this sprite is lit by light nodes in the scene.\nvar shadowedBitMask: UInt32\nA mask that defines which lights add shadows to the sprite.\nvar shadowCastBitMask: UInt32\nA mask that defines which lights are occluded by this sprite.\nRelated Documentation\nfunc generatingNormalMap() -> Self\nCreates a normal map texture by analyzing the contents of an existing texture.\ninit(texture: SKTexture?, normalMap: SKTexture?)\nInitializes a textured sprite with a normal map to simulate 3D lighting.\ninit(imageNamed: String, normalMapped: Bool)\nInitializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting."
  },
  {
    "title": "shadowCastBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/1520325-shadowcastbitmask",
    "html": "Discussion\n\nTo determine whether this sprite blocks the light (casting a shadow), the sprite’s shadowedBitMask property is tested against the light’s categoryBitMask property by performing a logical AND operation. If the comparison results in a nonzero value, the sprite casts a shadow past itself.\n\nSee Also\nLighting a Sprite\nLighting a Sprite with Light Nodes\nAdd lighting and shadows to your scene with light nodes.\nvar lightingBitMask: UInt32\nA mask that defines how this sprite is lit by light nodes in the scene.\nvar shadowedBitMask: UInt32\nA mask that defines which lights add shadows to the sprite.\nvar normalTexture: SKTexture?\nA texture that specifies the normal map for the sprite."
  },
  {
    "title": "Applying Shaders to a Sprite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode/applying_shaders_to_a_sprite",
    "html": "Overview\n\nYou can use the shader property of a sprite node to change the appearance of a texture with a custom OpenGL ES fragment shader embedded within a SKShader object. Custom shaders offer almost limitless possibilities, from adding blurs and color treatments to textures to generating imagery such as random noise.\n\nThe following code shows a small custom shader which inverts the color of a texture while leaving the alpha or transparency unaffected:\n\nlet negativeShader = SKShader(source: \"void main() { \" +\n    \"    gl_FragColor = vec4(1.0 - SKDefaultShading().rgb, SKDefaultShading().a); \" +\n    \"}\")\nrocket.shader = negativeShader\n\n\nThe following figure illustrates the effect of the shader. The original image, on the left, has its colors inverted by the shader:\n\nSee Also\nAdding a Custom Shader to a Sprite\nvar shader: SKShader?\nA text file that defines code that does custom per-pixel drawing or colorization.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nSets the value of a shader attribute."
  },
  {
    "title": "accessibilityRole | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645036-accessibilityrole",
    "html": "Discussion\n\nSee Roles for more information.\n\nSee Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "Converting Coordinate Spaces | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/converting_coordinate_spaces",
    "html": "Overview\n\nWhen working with the node tree, sometimes you need to convert a position from one coordinate space to another. For example, when specifying joints in the physics system, the joint positions are specified in scene coordinates. So, if you have those points in a local coordinate system, you need to convert them to the scene’s coordinate space.\n\nThe following code shows how to convert a node’s position into the scene coordinate system. The scene is asked to perform the conversion. Remember that a node’s position is specified in its parent’s coordinate system, so the code passes node.parent as the node to convert from. You could perform the same conversion in reverse by calling the convert(_:to:) method.\n\nlet positionInScene: CGPoint?\n\n\nif let parent = node.parent {\n    positionInScene = node.scene?.convert(node.position,\n                                          from: parent)\n}\nelse {\n    positionInScene = nil\n}\n\n\nOne situation where you need to perform coordinate conversions is when you perform event handling. Mouse and touch events need to be converted from window coordinates to view coordinates, and from there into the scene. To simplify the code you need to write, SpriteKit adds a few convenience methods:\n\nIn iOS, use the location(in:) and previousLocation(in:) on UITouch objects to convert a touch location into a node’s coordinate system.\n\nIn macOS, use the location(in:) method on NSEvent objects to convert a mouse event into a node’s coordinate system.\n\nSee Also\nConverting Between Coordinate Systems of Different Nodes\nfunc convert(CGPoint, from: SKNode) -> CGPoint\nConverts a point from the coordinate system of another node in the node tree to the coordinate system of this node.\nfunc convert(CGPoint, to: SKNode) -> CGPoint\nConverts a point in this node’s coordinate system to the coordinate system of another node in the node tree."
  },
  {
    "title": "accessibilityRoleDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645035-accessibilityroledescription",
    "html": "Discussion\n\nSee Roles for more information.\n\nSee Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "accessibilityHelp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645041-accessibilityhelp",
    "html": "See Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "insertChild(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483062-insertchild",
    "html": "Parameters\nnode\n\nThe node to add. The node must not already have a parent.\n\nindex\n\nThe position in the array to insert the node.\n\nSee Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node.\nRelated Documentation\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "Scaling a Scene's Content to Fit the View | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/scaling_a_scene_s_content_to_fit_the_view",
    "html": "Overview\n\nSet the scene's scaleMode property to determine how it's sized according to the view that's displaying it. For example, in iOS, scaleMode determines the automatic resizing of your scene when the device changes orientation. In macOS, scaleMode affects how your scene is scaled when the user changes the size or proportions of your app's window.\n\nDecide Which Scale Mode Is Best\n\nWhen you design your game, you should decide on a strategy for handling the scene’s size and scaleMode properties. Here are the most common strategies:\n\nInstantiate the scene with a constant size and never change it. Pick a scaling mode that lets the view scale the scene’s content. This gives the scene a predictable coordinate system and frame. You can then base your art assets and gameplay logic on this coordinate system.\n\nAdjust the size of the scene in your game. Where necessary, adjust your game logic and art assets to match the scene’s size.\n\nSet the scaleMode property to SKSceneScaleMode.resizeFill. SpriteKit automatically resizes the scene so that it always matches the view’s size. Where necessary, adjust your game logic and art assets to match the scene’s size.\n\nSet a Fixed Aspect Ratio\n\nListing 1 shows a typical implementation for when you plan to use a constant-sized scene. This code specifies a method to be executed the first time that the scene is presented. It configures the scene’s properties, including its scaling mode, then adds content. In this example, the scale mode is set to SKSceneScaleMode.aspectFit, which scales the contents equally in both dimensions and ensures that all of the scene’s contents are visible. Where necessary, this mode adds letter-boxing.\n\nListing 1 Creating a constant-sized scene\nfunc createSceneContent() {\n    scene.scaleMode = .aspectFit\n    scene.backgroundColor = .black\n    // Add additional scene contents here.  \n    ...\n}\n\n\nUpdate Your Graphics on Scene Resize\n\nIf you expect a scene’s size to change at runtime, then the initial scene size should be used to determine which art assets to use, as well as any game logic that is dependent on the scene size. Your game should also override the scene’s didChangeSize(_:) method, which is called whenever the scene changes size. When this method is called, you should update the scene’s contents to match the new size.\n\nSee Also\nStretching Content to Fit the View\nvar scaleMode: SKSceneScaleMode\nA setting that defines how the scene is mapped to the view that presents it.\nenum SKSceneScaleMode\nThe modes that determine how the scene’s area is mapped to the view that presents it."
  },
  {
    "title": "byIntersection(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1519646-byintersection",
    "html": "Parameters\nregion\n\nThe region to intersect.\n\nReturn Value\n\nA new region whose contents include all points that are included in both regions.\n\nSee Also\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(radius: Float)\nInitializes a new region with a circular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region."
  },
  {
    "title": "init(edgeFrom:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520401-init",
    "html": "Parameters\np1\n\nThe starting point for the edge, relative to the owning node’s origin.\n\np2\n\nThe ending point for the edge, relative to the owning node’s origin.\n\nReturn Value\n\nA new edge-based physics body.\n\nDiscussion\n\nAn edge has no volume or mass and is always treated as if the isDynamic property is equal to false. Edges may only collide with volume-based physics bodies.\n\nSee Also\nCreating an Edge-Based Physics Body\nCreating an Edge Loop Around a Scene\nBorder your scene with an obstacle that physics bodies cannot penetrate.\ninit(edgeLoopFrom: CGRect)\nCreates an edge loop from a rectangle.\ninit(edgeLoopFrom: CGPath)\nCreates an edge loop from a path.\ninit(edgeChainFrom: CGPath)\nCreates an edge chain from a path."
  },
  {
    "title": "init(edgeLoopFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519732-init",
    "html": "Parameters\npath\n\nA Core Graphics path. The points are specified relative to the owning node’s origin. The path must not intersect itself.\n\nReturn Value\n\nA new edge-based physics body.\n\nDiscussion\n\nIf the path is not already closed, a loop is automatically created by joining the last point to the first.\n\nAn edge has no volume or mass and is always treated as if the isDynamic property is equal to false. Edges may only collide with volume-based physics bodies.\n\nSee Also\nCreating an Edge-Based Physics Body\nCreating an Edge Loop Around a Scene\nBorder your scene with an obstacle that physics bodies cannot penetrate.\ninit(edgeLoopFrom: CGRect)\nCreates an edge loop from a rectangle.\ninit(edgeFrom: CGPoint, to: CGPoint)\nCreates an edge between two points.\ninit(edgeChainFrom: CGPath)\nCreates an edge chain from a path."
  },
  {
    "title": "init(edgeChainFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519871-init",
    "html": "Parameters\npath\n\nA Core Graphics path. The points are specified relative to the owning node’s origin. The path must not intersect itself.\n\nReturn Value\n\nA new edge-based physics body.\n\nDiscussion\n\nAn edge has no volume or mass and is always treated as if the isDynamic property is equal to false. Edges may only collide with volume-based physics bodies.\n\nSee Also\nCreating an Edge-Based Physics Body\nCreating an Edge Loop Around a Scene\nBorder your scene with an obstacle that physics bodies cannot penetrate.\ninit(edgeLoopFrom: CGRect)\nCreates an edge loop from a rectangle.\ninit(edgeFrom: CGPoint, to: CGPoint)\nCreates an edge between two points.\ninit(edgeLoopFrom: CGPath)\nCreates an edge loop from a path."
  },
  {
    "title": "allowsRotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519986-allowsrotation",
    "html": "Discussion\n\nThe default value is true. This property is ignored on edge-based bodies, which are unaffected by forces in the system.\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar affectedByGravity: Bool\nA Boolean value that indicates whether this physics body is affected by the physics world’s gravity.\nvar isDynamic: Bool\nA Boolean value that indicates whether the physics body is moved by the physics simulation."
  },
  {
    "title": "Configuring a Physics Body | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/configuring_a_physics_body",
    "html": "Overview\n\nYou configure mass, area and density to values that create the right level of momentum and transfer of kinetic energy upon collisions of your in-game objects. Though you typically configure a physics body only once, there are exceptions; for example, when a node crosses into a different environment, such as land to space, or land to water.\n\nUse Mass to Resist Acceleration\n\nYou set the mass on every volume-based body in your scene so that it properly reacts to forces applied to it.\n\nA physics body’s mass, area, and density properties are all interrelated. When you first create a body, the body’s area is calculated, and never changes afterward. The other two properties change values at the same time, based on the following formula:\n\nmass = density x area\n\nWhen you configure a physics body, you have two options:\n\nSet the mass property of the body. The density property is then automatically recalculated. This approach is most useful when you want to precisely control each body’s mass.\n\nSet the density property of the body. The mass property is then automatically recalculated. This approach is most useful when you have a collection of similar bodies created with different sizes. For example, if your physics bodies were used to simulate asteroids, you might give all asteroids the same density, and then set an appropriate bounding polygon for each. Each body automatically computes an appropriate mass based on its size on the screen.\n\nTime Your Changes to a Physics Body's Properties\n\nMost often, you configure a physics body once and then never change it. For example, the mass of a body is unlikely to change during play. However, you are not restricted from changing it. Some kinds of games may require the ability to adjust a body’s properties even while the simulation is executing. Here are a few examples of when you might do so:\n\nIn a realistic rocket simulation, the rocket expends fuel to apply thrust. As fuel is used up, the mass of the rocket changes. To implement this in SpriteKit, you might create a rocket class that includes a fuel property. When the rocket thrusts, the fuel is reduced and the corresponding body’s mass is recalculated.\n\nThe damping properties are usually based on the body’s characteristics and the medium it is traveling through. For example, a vacuum applies no damping forces, and water applies more damping forces than air. If your game simulates multiple environments and bodies can move between those environments, your game can update a body’s damping properties whenever it enters a new environment.\n\nWhen a contact delegate responds to a collision, and an in-game object, such as a rocket, should be destroyed, you might set the rocket node's physicsBody to nil. This prevents further contact delegate callbacks for the rocket as it plays out its final explosion animation before being deallocated.\n\nTypically, you make these changes as part of scene pre- and post-processing, using the SKSceneDelegate methods.\n\nSee Also\nDefining a Physics Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar area: CGFloat\nThe area covered by the body.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity."
  },
  {
    "title": "affectedByGravity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519774-affectedbygravity",
    "html": "Discussion\n\nThe physics world’s gravity property defines the gravitational forces applied to volume-based bodies in the scene.\n\nThe default value is true. This property is ignored on edge-based bodies, which are always unaffected by gravity.\n\nPhysics bodies with affectedByGravity set to false are still affected by the gravity fields created by linearGravityField(withVector:) and radialGravityField().\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar allowsRotation: Bool\nA Boolean value that indicates whether the physics body is affected by angular forces and impulses applied to it.\nvar isDynamic: Bool\nA Boolean value that indicates whether the physics body is moved by the physics simulation."
  },
  {
    "title": "isDynamic | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520132-isdynamic",
    "html": "Discussion\n\nThe default value is true. If the value is false, the physics body ignores all forces and impulses applied to it. This property is ignored on edge-based bodies; they are automatically static.\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar affectedByGravity: Bool\nA Boolean value that indicates whether this physics body is affected by the physics world’s gravity.\nvar allowsRotation: Bool\nA Boolean value that indicates whether the physics body is affected by angular forces and impulses applied to it."
  },
  {
    "title": "area | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520034-area",
    "html": "Discussion\n\nThis property is used in conjunction with the density property to calculate the body’s mass.\n\nThe value returned for the area is measured in meters: if you need to convert it into points — as used by SpriteKit — multiply the values by 150². The following listing shows how to calculate the area of a box which is ten points square.\n\nlet bodySize = CGSize(width: 10, height: 10)\nlet physicsBody = SKPhysicsBody(rectangleOf: bodySize)\nlet areaInPoints = physicsBody.area * pow(150, 2) // areaInPoints = 100\n\n\nSee Also\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity."
  },
  {
    "title": "mass | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519906-mass",
    "html": "Discussion\n\nThe actual unit is arbitrary as long as relative masses of objects are consistent throughout the game. The mass of the body affects its momentum as well as how forces are applied to the object.\n\nThe mass and density properties are interrelated. When you change the value of either property, the other property’s value is automatically recalculated to be consistent. The default value is based on the size of the physics body and the body’s default density.\n\nSee Also\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar area: CGFloat\nThe area covered by the body.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity."
  },
  {
    "title": "density | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519983-density",
    "html": "Discussion\n\nThe actual unit is arbitrary as long as relative masses of objects are consistent throughout the game.\n\nThe mass and density properties are interrelated. When you change the value of either property, the other property’s value is automatically recalculated to be consistent.\n\nThe default value is 1.0.\n\nSee Also\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar area: CGFloat\nThe area covered by the body.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity."
  },
  {
    "title": "friction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519840-friction",
    "html": "Discussion\n\nThis property is used to apply a frictional force to physics bodies in contact with this physics body. The property must be a value between 0.0 and 1.0. The default value is 0.2.\n\nSee Also\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar area: CGFloat\nThe area covered by the body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity."
  },
  {
    "title": "didLoad(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreferencenode/1508364-didload",
    "html": "Parameters\nnode\n\nThe deserialized content’s root node.\n\nDiscussion\n\nThis method is called after the referenced content is added as a child of the reference node. Override this method in a subclass to implement custom loading behavior."
  },
  {
    "title": "resolve() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreferencenode/1508371-resolve",
    "html": "Discussion\n\nThe archive is deserialized and the root node is added as a child of the reference node. If this method is called on a reference node whose content is already loaded, the existing node tree is discarded and replaced with a fresh copy of the archive’s data.\n\nSpriteKit calls this method automatically if the scene renders the reference node and the reference node has not previously been loaded."
  },
  {
    "title": "init(fileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreferencenode/1508368-init",
    "html": "Parameters\nfileName\n\nThe name of a file stored in the app’s main bundle.\n\nReturn Value\n\nA newly initialized reference node.\n\nDiscussion\n\nThis initializer is for loading files that reside inside of the app bundle."
  },
  {
    "title": "init(url:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreferencenode/1508365-init",
    "html": "Parameters\nreferenceURL\n\nThe URL of the reference node.\n\nReturn Value\n\nA newly initialized reference node.\n\nDiscussion\n\nThis intializer is for loading archives that reside outside of the app bundle.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "gravity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449623-gravity",
    "html": "Discussion\n\nThe components of this property are measured in meters per second. The default value is (0.0,-9.8), which represent’s Earth’s gravity.\n\nSee Also\nConfiguring the Physics World\nvar speed: CGFloat\nThe rate at which the simulation executes.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "speed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449611-speed",
    "html": "Discussion\n\nThe default value is 1.0, which means the simulation runs at normal speed. A value other than the default changes the rate at which time passes in the physics simulation. For example, a speed value of 2.0 indicates that time in the physics simulation passes twice as fast as the scene’s simulation time. A value of 0.0 pauses the physics simulation.\n\nSee Also\nConfiguring the Physics World\nvar gravity: CGVector\nA vector that specifies the gravitational acceleration applied to physics bodies in the physics world."
  },
  {
    "title": "body(alongRayStart:end:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449613-body",
    "html": "Parameters\nstart\n\nThe starting point for the ray in scene coordinates.\n\nend\n\nThe ending point for the ray in scene coordinates.\n\nReturn Value\n\nThe first physics body discovered that intersects the ray. This may be any body along the ray; it is not guaranteed to be the closest physics body. If no body intersects the ray, this method returns nil.\n\nSee Also\nSearching the Scene for Physics Bodies\nSearching the World for Physics Bodies\nCast a ray to find the physics bodies in the scene that intersect it.\nfunc body(at: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that contains a point.\nfunc body(in: CGRect) -> SKPhysicsBody?\nSearches for the first physics body that intersects the specified rectangle.\nfunc enumerateBodies(alongRayStart: CGPoint, end: CGPoint, using: (SKPhysicsBody, CGPoint, CGVector, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect a ray.\nfunc enumerateBodies(at: CGPoint, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that contain a point.\nfunc enumerateBodies(in: CGRect, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect the specified rectangle."
  },
  {
    "title": "removeAllJoints() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449621-removealljoints",
    "html": "See Also\nJoining Physics Bodies with Joints\nfunc add(SKPhysicsJoint)\nAdds a joint to the physics world.\nfunc remove(SKPhysicsJoint)\nRemoves a specific joint from the physics world."
  },
  {
    "title": "add(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449617-add",
    "html": "Parameters\njoint\n\nThe joint to add.\n\nDiscussion\n\nFor a joint to take effect, it must be added to the physics world.\n\nSee Also\nJoining Physics Bodies with Joints\nfunc removeAllJoints()\nRemoves all joints from the physics world.\nfunc remove(SKPhysicsJoint)\nRemoves a specific joint from the physics world."
  },
  {
    "title": "Searching the World for Physics Bodies | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/searching_the_world_for_physics_bodies",
    "html": "Overview\n\nSometimes, it is necessary to find physics bodies in a scene. For example, you might need to:\n\nDiscover whether a physics body is located in a region of the scene.\n\nDetect when a physics body (such as the one controlled by the player) crosses a particular line.\n\nTrace the line of sight between two physics bodies, to see whether another physics body, such as a wall, is interposed between the two objects.\n\nOcclude an audio node if a body is between it and a scene’s listener node.\n\nIn some cases, you can implement these interactions using the collisions and contacts system. For example, to discover when a physics body enters a region, you could create a physics body and attach it to an invisible node in the scene. Then, configure the physics body’s collision mask so that it never collides with anything, and its contact mask to detect the physics bodies you are interested in. Your contact delegate is called when the desired interactions occur.\n\nHowever, it’s not easy to implement concepts such as line of sight using this design. To implement these, you use the scene’s physics world. With the physics world, you can search for all physics bodies along a ray or physics bodies that intersect a particular point or rectangle.\n\nCast a Ray from the Center of the Scene\n\nAn example illustrates the basic technique. The following code shows one possible implementation of a line-of-sight detection system. It casts a ray from the origin of the scene in a particular direction, searching for the nearest physics body along the ray. If it finds a physics body, it tests the category mask to see whether this is a target it should attack. If it sees a target designated for attack, it shoots the cannon.\n\nfunc isTargetVisibleAtAngle(angle: CGFloat, distance: CGFloat) -> Bool {\n    let rayStart = CGPoint.zero\n    let rayEnd = CGPoint(x: distance * cos(angle),\n                         y: distance * sin(angle))\n    \n    let body = scene.physicsWorld.body(alongRayStart: rayStart, end: rayEnd)\n    \n    return body?.categoryBitMask == targetCategory\n}\nfunc attackTargetIfVisible() {\n    if isTargetVisibleAtAngle(angle: cannon.zRotation, distance: 512) {\n        shootCannon()\n    }\n}\n\n\nTry Other Search Methods\n\nAnother way to implement the same behavior is to set the starting and ending positions of the ray to those of two physics bodies in your scene. For example, you might use the location of the player’s game object as one position and the position of an enemy unit as the other position.\n\nYou can also perform searches for physics bodies that intersect a point or rectangle using the body(at:) and body(in:) methods.\n\nSometimes you can’t make a simple determination based on the closest physics body within the scene. For example, in the logic of your game, you might decide that not all physics bodies block the line of sight. In this case, you need to enumerate all of the physics bodies along the ray using the enumerateBodies(alongRayStart:end:using:) method. You supply a block that is called once for each body along the ray. You can then use this information to make a more informed decision about whether the line of sight exists to a target.\n\nSee Also\nSearching the Scene for Physics Bodies\nfunc body(alongRayStart: CGPoint, end: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that intersects a ray.\nfunc body(at: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that contains a point.\nfunc body(in: CGRect) -> SKPhysicsBody?\nSearches for the first physics body that intersects the specified rectangle.\nfunc enumerateBodies(alongRayStart: CGPoint, end: CGPoint, using: (SKPhysicsBody, CGPoint, CGVector, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect a ray.\nfunc enumerateBodies(at: CGPoint, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that contain a point.\nfunc enumerateBodies(in: CGRect, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect the specified rectangle."
  },
  {
    "title": "body(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449604-body",
    "html": "Parameters\nrect\n\nA rectangle in scene coordinates.\n\nReturn Value\n\nThe first physics body discovered that intersects the rectangle. If no body intersects the rectangle, this method returns nil.\n\nSee Also\nSearching the Scene for Physics Bodies\nSearching the World for Physics Bodies\nCast a ray to find the physics bodies in the scene that intersect it.\nfunc body(alongRayStart: CGPoint, end: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that intersects a ray.\nfunc body(at: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that contains a point.\nfunc enumerateBodies(alongRayStart: CGPoint, end: CGPoint, using: (SKPhysicsBody, CGPoint, CGVector, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect a ray.\nfunc enumerateBodies(at: CGPoint, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that contain a point.\nfunc enumerateBodies(in: CGRect, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect the specified rectangle."
  },
  {
    "title": "body(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449625-body",
    "html": "Parameters\npoint\n\nA point in scene coordinates.\n\nReturn Value\n\nThe first physics body discovered that contains the point. If no body contains the point, this method returns nil.\n\nSee Also\nSearching the Scene for Physics Bodies\nSearching the World for Physics Bodies\nCast a ray to find the physics bodies in the scene that intersect it.\nfunc body(alongRayStart: CGPoint, end: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that intersects a ray.\nfunc body(in: CGRect) -> SKPhysicsBody?\nSearches for the first physics body that intersects the specified rectangle.\nfunc enumerateBodies(alongRayStart: CGPoint, end: CGPoint, using: (SKPhysicsBody, CGPoint, CGVector, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect a ray.\nfunc enumerateBodies(at: CGPoint, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that contain a point.\nfunc enumerateBodies(in: CGRect, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect the specified rectangle."
  },
  {
    "title": "enumerateBodies(at:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449597-enumeratebodies",
    "html": "Parameters\npoint\n\nA point in scene coordinates.\n\nblock\n\nA block to be called for each physics body that contains the point. The block takes the following parameters:\n\nbody\n\nThe physics body that the ray intersected.\n\nstop\n\nA pointer to a Boolean variable. Your block can set this to true to terminate the enumeration.\n\nSee Also\nSearching the Scene for Physics Bodies\nSearching the World for Physics Bodies\nCast a ray to find the physics bodies in the scene that intersect it.\nfunc body(alongRayStart: CGPoint, end: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that intersects a ray.\nfunc body(at: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that contains a point.\nfunc body(in: CGRect) -> SKPhysicsBody?\nSearches for the first physics body that intersects the specified rectangle.\nfunc enumerateBodies(alongRayStart: CGPoint, end: CGPoint, using: (SKPhysicsBody, CGPoint, CGVector, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect a ray.\nfunc enumerateBodies(in: CGRect, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect the specified rectangle."
  },
  {
    "title": "enumerateBodies(alongRayStart:end:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449615-enumeratebodies",
    "html": "Parameters\nstart\n\nThe starting point for the ray in scene coordinates.\n\nend\n\nThe ending point for the ray in scene coordinates.\n\nblock\n\nA block to be called for each physics body that the ray touches. The block takes the following parameters:\n\nbody\n\nThe physics body that the ray intersected.\n\npoint\n\nThe point in scene coordinates where the ray contacted the physics body.\n\nnormal\n\nThe normal vector for the physics body at the point of contact.\n\nstop\n\nA pointer to a Boolean variable. Your block can set this to true to terminate the enumeration.\n\nSee Also\nSearching the Scene for Physics Bodies\nSearching the World for Physics Bodies\nCast a ray to find the physics bodies in the scene that intersect it.\nfunc body(alongRayStart: CGPoint, end: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that intersects a ray.\nfunc body(at: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that contains a point.\nfunc body(in: CGRect) -> SKPhysicsBody?\nSearches for the first physics body that intersects the specified rectangle.\nfunc enumerateBodies(at: CGPoint, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that contain a point.\nfunc enumerateBodies(in: CGRect, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect the specified rectangle."
  },
  {
    "title": "enumerateBodies(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449619-enumeratebodies",
    "html": "Parameters\nrect\n\nA rectangle in scene coordinates.\n\nblock\n\nA block to be called for each physics body that contains the point. The block takes the following parameters:\n\nbody\n\nThe physics body that intersected the rectangle.\n\nstop\n\nA pointer to a Boolean variable. Your block can set this to true to terminate the enumeration.\n\nSee Also\nSearching the Scene for Physics Bodies\nSearching the World for Physics Bodies\nCast a ray to find the physics bodies in the scene that intersect it.\nfunc body(alongRayStart: CGPoint, end: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that intersects a ray.\nfunc body(at: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that contains a point.\nfunc body(in: CGRect) -> SKPhysicsBody?\nSearches for the first physics body that intersects the specified rectangle.\nfunc enumerateBodies(alongRayStart: CGPoint, end: CGPoint, using: (SKPhysicsBody, CGPoint, CGVector, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect a ray.\nfunc enumerateBodies(at: CGPoint, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that contain a point."
  },
  {
    "title": "value(forAttributeNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1644182-value",
    "html": "Deprecated\n\nAttributes are only available to node classes supporting SKShader, such as SKSpriteNode, SKEffectNode and SKShapeNode.\n\nParameters\nkey\n\nThe attribute name.\n\nReturn Value\n\nAn attribute value object containing the scalar or vector value or nil if no such attribute exists.\n\nSee Also\nSetting a Node's Unique Attributes for a Shader\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nDeprecated\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader\nDeprecated"
  },
  {
    "title": "SKLabelVerticalAlignmentMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelverticalalignmentmode",
    "html": "Topics\nConstants\ncase baseline\nPositions the text so that the font’s baseline lies on the node’s origin.\ncase center\nCenters the text vertically on the node’s origin.\ncase top\nPositions the text so that the top of the text is on the node’s origin.\ncase bottom\nPositions the text so that the bottom of the text is on the node’s origin.\nRelationships\nConforms To\nSendable\nSee Also\nControlling a Label's Alignment\nvar verticalAlignmentMode: SKLabelVerticalAlignmentMode\nThe vertical position of the text within the node.\nvar horizontalAlignmentMode: SKLabelHorizontalAlignmentMode\nThe horizontal position of the text within the node.\nenum SKLabelHorizontalAlignmentMode\nOptions for aligning text horizontally."
  },
  {
    "title": "applyForce(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520032-applyforce",
    "html": "Parameters\nforce\n\nA vector that describes how much force was applied in each dimension. The force is measured in Newtons.\n\npoint\n\nA point in scene coordinates that defines where the force was applied to the physics body.\n\nDiscussion\n\nBecause the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration. The force is applied for a single simulation step (one frame).\n\nSee Also\nApplying Forces and Impulses to a Physics Body\nMaking Physics Bodies Move\nMove a body using various physics properties, like velocity, gravity or impulses.\nfunc applyForce(CGVector)\nApplies a force to the center of gravity of a physics body.\nfunc applyTorque(CGFloat)\nApplies torque to an object.\nfunc applyImpulse(CGVector)\nApplies an impulse to the center of gravity of a physics body.\nfunc applyAngularImpulse(CGFloat)\nApplies an impulse that imparts angular momentum to an object.\nfunc applyImpulse(CGVector, at: CGPoint)\nApplies an impulse to a specific point of a physics body.\nRelated Documentation\nvar mass: CGFloat\nThe mass of the body, in kilograms."
  },
  {
    "title": "applyForce(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520430-applyforce",
    "html": "Parameters\nforce\n\nA vector that describes how much force was applied in each dimension. The force is measured in Newtons.\n\nDiscussion\n\nThis method accelerates the body without imparting any angular acceleration to it. The acceleration is applied for a single simulation step (one frame).\n\nSee Also\nApplying Forces and Impulses to a Physics Body\nMaking Physics Bodies Move\nMove a body using various physics properties, like velocity, gravity or impulses.\nfunc applyTorque(CGFloat)\nApplies torque to an object.\nfunc applyForce(CGVector, at: CGPoint)\nApplies a force to a specific point of a physics body.\nfunc applyImpulse(CGVector)\nApplies an impulse to the center of gravity of a physics body.\nfunc applyAngularImpulse(CGFloat)\nApplies an impulse that imparts angular momentum to an object.\nfunc applyImpulse(CGVector, at: CGPoint)\nApplies an impulse to a specific point of a physics body.\nRelated Documentation\nvar mass: CGFloat\nThe mass of the body, in kilograms."
  },
  {
    "title": "angularDamping | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519913-angulardamping",
    "html": "Discussion\n\nThis property is used to simulate fluid or air friction forces on the body. The property must be a value between 0.0 and 1.0. The default value is 0.1. If the value is 0.0, no angular damping is applied to the object.\n\nSee Also\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar area: CGFloat\nThe area covered by the body.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity."
  },
  {
    "title": "linearDamping | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519796-lineardamping",
    "html": "Discussion\n\nThis property is used to simulate fluid or air friction forces on the body. The property must be a value between 0.0 and 1.0. The default value is 0.1. If the value is 0.0, no linear damping is applied to the object.\n\nSee Also\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar area: CGFloat\nThe area covered by the body.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity."
  },
  {
    "title": "Positioning a Scene's Origin Within its View | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/positioning_a_scene_s_origin_within_its_view",
    "html": "Overview\n\nYou use the scene's anchorPoint to orient the default screen position of its nodes. For example, setting the scene's anchorPoint to (0,0) makes child nodes with a position of (0,0) display at the bottom-left corner of the scene. However, setting the scene's anchorPoint to (0.5,0.5) makes child nodes with a position of (0,0) display in the center of the scene.\n\nYou only use the scene's anchorPoint for scene's that don't have a camera. If, however, you set a scene's camera, then the camera drives which portion of the scene is visible at any given time, and the anchorPoint is ignored.\n\nSet the Scene's Origin to the Bottom-Left of its View\n\nBy default, a scene’s origin is placed in the lower-left corner of the view, as shown in the figure below. A scene initialized with a height of 1024 and a width of 768 has the origin (0,0) in the lower-left corner, and the (1024,768) coordinate in the upper-right corner. The frame property holds (0,0)-(1024,768).\n\nA scene’s position property is ignored by Scene Kit because the scene is always the root node for a node tree. Its default value is zero and you can’t change it. However, you can move the scene’s origin by setting its anchorPoint property. The anchor point is specified in the unit coordinate space and chooses a point in the enclosing view.\n\nFigure 1 Default anchor for a scene is in the lower-left corner of the view\n\nThe default value for the anchor point is zero, which places it at the lower-left corner. The scene’s visible coordinate space is (0,0) to (width,height). The default anchor point is most useful for games that do not scroll a scene’s content.\n\nCenter the Scene's Origin Within its View\n\nThe second-most common anchor point value is (0.5,0.5), which centers the scene’s origin in the middle of the view as shown in the figure below. The scene’s visible coordinate space is (-width/2,-height/2) to (width/2,height/2). Centering the scene on its anchor point is most useful when you want to easily position nodes relative to the center of the screen, such as in a scrolling game. However, this effect is better achieved using a SKCameraNode.\n\nFigure 2 Moving the anchor point to the center of the view\n\nAs a result of setting the anchorPoint and size, you indirectly set the scene’s frame, which determines the portion of the scene that's visible to the user.\n\nSee Also\nConfiguring the Viewport\nvar camera: SKCameraNode?\nThe camera node in the scene that determines what part of the scene’s coordinate space is visible in the view.\nvar anchorPoint: CGPoint\nThe point in the view’s frame that corresponds to the scene’s origin."
  },
  {
    "title": "init(imageNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520086-init",
    "html": "Parameters\nname\n\nThe name of the image file.\n\nReturn Value\n\nA new texture object.\n\nDiscussion\n\nThe new texture object is initialized with the name of the image file and then control returns immediately to your game. Sprite Kit loads and prepares the texture data when it is needed by your game.\n\nWhen loading the texture data, Sprite Kit searches the app bundle for an image file with the specified filename. If a matching image file cannot be found, Sprite Kit searches for the texture in any texture atlases stored in the app bundle. If the specified image does not exist anywhere in the bundle, Sprite Kit creates a placeholder texture image.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "attributeValues | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1644181-attributevalues",
    "html": "Deprecated\n\nAttributes are only available to node classes supporting SKShader, such as SKSpriteNode, SKEffectNode and SKShapeNode.\n\nDiscussion\n\nAll nodes have their own copy of an attribute value and therefore the attribute values can be different across the same SKShader. If instead you need all nodes to share the same value, use SKUniform. Uniforms can change values every frame, but uniforms cannot vary per-node like attributes can.\n\nSee Also\nSetting a Node's Unique Attributes for a Shader\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader\nDeprecated\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute.\nDeprecated"
  },
  {
    "title": "didChangeSize(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519545-didchangesize",
    "html": "Parameters\noldSize\n\nThe old size of the scene, in points.\n\nDiscussion\n\nThis method is intended to be overridden in a subclass. Typically, you use this method to adjust the positions of nodes in the scene.\n\nSee Also\nResponding to Loading and Resizing Events\nfunc sceneDidLoad()\nTells you when the scene is presented.\nfunc willMove(from: SKView)\nTells you when the scene is about to be removed from a view.\nfunc didMove(to: SKView)\nTells you when the scene is presented by a view.\nRelated Documentation\nvar size: CGSize\nThe dimensions of the scene, in points."
  },
  {
    "title": "accessibilityHitTest(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645040-accessibilityhittest",
    "html": "Parameters\npoint\n\nRelative to the bottom-left of the screen, in screen points, and guaranteed to lie within the receiver.\n\nDiscussion\n\nOverride this method to implement your own, deeper hit testing within a user interface element.\n\nSee Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input."
  },
  {
    "title": "isAccessibilityEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645037-isaccessibilityenabled",
    "html": "See Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "accessibilityParent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645042-accessibilityparent",
    "html": "See Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "scaleMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519562-scalemode",
    "html": "Discussion\n\nIt is possible for a scene’s size to differ from the size of the view it is presented in. The scale mode determines how the visible portion of the scene is mapped to the view. The possible values are listed in SKSceneScaleMode. The default value is SKSceneScaleMode.fill.\n\nSee Also\nStretching Content to Fit the View\nScaling a Scene's Content to Fit the View\nConfigure the scale mode to determine how a scene is sized to fit its view.\nenum SKSceneScaleMode\nThe modes that determine how the scene’s area is mapped to the view that presents it."
  },
  {
    "title": "size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519831-size",
    "html": "Discussion\n\nWhen a scene is first initialized, its size property is configured by the designated initializer. The size of the scene specifies the size of the visible portion of the scene in points. This is only used to specify the visible portion of the scene. Nodes in the tree can be positioned outside of this area; those nodes are still processed by the scene, but are ignored by the renderer.\n\nWhen a scene is presented, the size and anchorPoint properties determine the portion of the scene’s coordinate space that is visible in the view.\n\nIf you set the size property to a new value, the scene’s didChangeSize(_:) method is called. This property can also change if the scaleMode property is set to SKSceneScaleMode.resizeFill and the presenting view is resized. After the scene’s size changes, future updates are rendered immediately at the new size.\n\nSee Also\nCreating a Scene Programmatically\ninit(size: CGSize)\nInitializes a new scene object.\nRelated Documentation\nfunc didChangeSize(CGSize)\nTells you when the scene’s size has changed.\nvar scaleMode: SKSceneScaleMode\nA setting that defines how the scene is mapped to the view that presents it."
  },
  {
    "title": "accessibilitySubrole | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645043-accessibilitysubrole",
    "html": "Discussion\n\nSee Subroles for more information.\n\nSee Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "isAccessibilityElement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645038-isaccessibilityelement",
    "html": "See Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "accessibilityLabel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645039-accessibilitylabel",
    "html": "See Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "convert(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483056-convert",
    "html": "Parameters\npoint\n\nA point in this node’s coordinate system.\n\nnode\n\nAnother node in the same node tree as this node.\n\nReturn Value\n\nThe same point converted to the other node’s coordinate system.\n\nSee Also\nConverting Between Coordinate Systems of Different Nodes\nConverting Coordinate Spaces\nConvert positions across the various coordinate spaces in a scene.\nfunc convert(CGPoint, from: SKNode) -> CGPoint\nConverts a point from the coordinate system of another node in the node tree to the coordinate system of this node."
  },
  {
    "title": "accessibilityChildren | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645045-accessibilitychildren",
    "html": "See Also\nProviding Accessibility\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "accessibilityFrame | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1645044-accessibilityframe",
    "html": "See Also\nProviding Accessibility\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy."
  },
  {
    "title": "userData | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483121-userdata",
    "html": "Discussion\n\nYou use this property to store your own data in a node. For example, you might store game-specific data about each node to use inside your game logic. This can be a useful alternative to creating your own node subclasses to hold game data.\n\nSpriteKit does not do anything with the data stored in the node. However, the data is archived when the node is archived."
  },
  {
    "title": "convert(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483058-convert",
    "html": "Parameters\npoint\n\nA point in the other node’s coordinate system.\n\nnode\n\nAnother node in the same node tree as this node.\n\nReturn Value\n\nThe same point converted to this node’s coordinate system.\n\nSee Also\nConverting Between Coordinate Systems of Different Nodes\nConverting Coordinate Spaces\nConvert positions across the various coordinate spaces in a scene.\nfunc convert(CGPoint, to: SKNode) -> CGPoint\nConverts a point in this node’s coordinate system to the coordinate system of another node in the node tree."
  },
  {
    "title": "nodes(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483072-nodes",
    "html": "Parameters\np\n\nA point in the node’s coordinate system.\n\nReturn Value\n\nAn array of all SKNode objects in the subtree that intersect the point. Only nodes that have an isHidden of false and an alpha greater that zero are included in the returned array. If no nodes intersect the point, an empty array is returned.\n\nDiscussion\n\nA point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.\n\nSee Also\nHit Testing\nUnderstanding Hit-Testing\nLearn how find child nodes at a given point by using hit-testing.\nfunc contains(CGPoint) -> Bool\nReturns a Boolean value that indicates whether a point lies inside the parent’s coordinate system.\nfunc atPoint(CGPoint) -> SKNode\nReturns the deepest visible descendant that intersects a point."
  },
  {
    "title": "removeAllChildren() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483040-removeallchildren",
    "html": "See Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node.\nRelated Documentation\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "removeChildren(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483091-removechildren",
    "html": "Parameters\nnodes\n\nAn array of SKNode objects that are all children of the receiving node.\n\nSee Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node.\nRelated Documentation\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "Customizing the Behavior of a Node | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/customizing_the_behavior_of_a_node",
    "html": "Overview\n\nDelegate tasks to specific nodes as a way to organize your app's logic and display code. Learn which customization approach to take based on the particular behavior or look you want to enable.\n\nSubclass a Node to Add Custom Behavior\n\nSubclass SKNode (or one of its subclasses) when you need to customize the node's look or behavior. For example, you might subclass SKNode to implement a custom drawing layer. Or, you might subclass SKSpriteNode to add some AI logic. If you want a node to respond to user input, you must subclass it. SKScene is a subclass of SKNode, and you subclass SKScene to provide a custom look and behavior for your app.\n\nSubclass a Node to Implement Node Archiving\n\nIf you add properties to a subclass and that subclass needs to be archived, the NSCoding protocol needs to be implemented on your subclasses. See Archives and Serializations Programming Guide.\n\nUse a Shader Instead of Subclassing to do Custom Node Drawing\n\nUnlike views, you cannot subclass SKNode to perform custom drawing. Instead, you use a node subclass that supports SKShader and implement your graphical effects in custom shader source code. Alternatively, you can composite a hierarchy of nodes that collectively effect the look you're going for.\n\nAdd Custom Logic to a Node\n\nIn many cases, expect to add methods that can be called during the scene’s preprocessing and postprocessing steps. Your scene coordinates these steps, but focused node subclasses perform the work.\n\nHandle User Input with a Node\n\nIf you want to implement event handling in a node class, you must implement separate event-handling code for iOS and macOS. The SKNode class inherits from NSResponder on macOS and UIResponder on iOS. See Controlling User Interaction on Nodes for more information.\n\nDelegate Tasks to a Node\n\nIn some app designs, you can rely on the fact that a particular combination of classes is always going to be used together in a specific scene. In other designs, you may want to create classes that can be used in multiple scenes. When two classes are dependent on each other, use delegation to break that dependency. Most often, you do this by defining a delegate on your node and a protocol for delegates to implement. Your scene (or another node, such as the node’s parent) implements this protocol. Your node class can then be reused in multiple scenes, without needing to know the scene’s class."
  },
  {
    "title": "move(toParent:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483021-move",
    "html": "Parameters\nparent\n\nAn SKNode object to move the receiver to. This node must be in the same scene as the node’s current parent.\n\nDiscussion\n\nThe node maintains its current position in scene coordinates.\n\nSee Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node."
  },
  {
    "title": "isEqual(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483078-isequal",
    "html": "Parameters\nnode\n\nThe node to compare to the receiving node.\n\nReturn Value\n\ntrue if the node is a descendant of the parent node; otherwise false.\n\nSee Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node."
  },
  {
    "title": "addChild(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483054-addchild",
    "html": "Parameters\nnode\n\nThe node to add. The node must not already have a parent.\n\nSee Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node.\nRelated Documentation\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "infinite() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1520061-infinite",
    "html": "Return Value\n\nReturns a singleton region that covers an infinite area.\n\nSee Also\nCreating and Initializing Region Objects\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(radius: Float)\nInitializes a new region with a circular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "init(size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1520385-init",
    "html": "Parameters\nsize\n\nThe size of the rectangle in points.\n\nReturn Value\n\nA newly initialized region. The region is rectangular and centered on the origin.\n\nSee Also\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(radius: Float)\nInitializes a new region with a circular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region."
  },
  {
    "title": "init(radius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1520219-init",
    "html": "Parameters\nradius\n\nThe radius of the region in points.\n\nReturn Value\n\nA newly initialized region. The region is circular and centered on the origin.\n\nSee Also\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region."
  },
  {
    "title": "init(path:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1519857-init",
    "html": "Parameters\npath\n\nA path that defines the new region’s shape. The path is assumed to use the even-odd winding rule.\n\nReturn Value\n\nA newly initialized region.\n\nSee Also\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(radius: Float)\nInitializes a new region with a circular area.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region."
  },
  {
    "title": "byUnion(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1519702-byunion",
    "html": "Parameters\nregion\n\nThe region to combine with the current region.\n\nReturn Value\n\nA new region whose contents include all points that are included in either region.\n\nSee Also\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(radius: Float)\nInitializes a new region with a circular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region."
  },
  {
    "title": "inverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1519700-inverse",
    "html": "Return Value\n\nA new region object whose contents include all points that are not in the current region.\n\nSee Also\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(radius: Float)\nInitializes a new region with a circular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region."
  },
  {
    "title": "path | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1520042-path",
    "html": "See Also\nInteracting with a Region\nfunc contains(CGPoint) -> Bool\nReturns a Boolean value that indicates whether a particular point is contained in the region."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1519695-contains",
    "html": "Parameters\npoint\n\nA point.\n\nReturn Value\n\ntrue if the point is contained in the region; otherwise, false.\n\nSee Also\nInteracting with a Region\nvar path: CGPath?\nReturns a Core Graphics path that defines the region."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skcameranode/1434224-contains",
    "html": "Parameters\nnode\n\nAn SKNode object.\n\nReturn Value\n\ntrue if the node in the same scene and inside the camera’s viewport; otherwise false.\n\nDiscussion\n\nThe camera must be part of a scene’s node hierarchy and the scene must be presented in an view.\n\nSee Also\nNode Visibility\nfunc containedNodeSet() -> Set<SKNode>\nFinds nodes that are visible in the camera's viewport."
  },
  {
    "title": "containedNodeSet() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skcameranode/1434222-containednodeset",
    "html": "Return Value\n\nThe set of nodes that are in the same scene as the camera and contained in the camera’s viewport.\n\nDiscussion\n\nThe camera must be part of a scene’s node hierarchy and the scene must be presented in an view.\n\nSee Also\nNode Visibility\nfunc contains(SKNode) -> Bool\nChecks to see if a node is visible in the camera’s viewport.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "Getting Started with a Camera | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skcameranode/getting_started_with_a_camera",
    "html": "Overview\n\nSKCameraNode defines which portion of a scene is visible on the screen. You must do the following to use a camera:\n\nInstantiate a new SKCameraNode and set it as the scene's camera.\n\nAdd the camera node as a child to the scene.\n\nNote\n\nIf you don't use a camera in your scene, the scene's anchorPoint is used to position the scene within the view.\n\nBecause the camera is a node, you define its position within the scene just like any other node. Actions, physics, and GameplayKit behaviors can also be applied to the camera node. When a scene is rendered using a camera node, the following occur:\n\nThe scene is rendered so that the camera node’s origin is placed in the middle of the scene.\n\nThe inverse of the camera node’s xScale, yScale, and zRotation properties are applied to all nodes in the scene.\n\nIn this way, a camera’s position, scale, and rotation always have the opposite effect on how the scene is rendered. For example, if the camera is moved 10 pixels to the right, the scene is rendered as if everything else moved 10 pixels to the left. And similarly, if a camera node has an xScale and yScale of 2.0, the scene is rendered as if every distance was half its normal size, effectively increasing the visible area of the camera’s viewport.\n\nImportant\n\nA camera’s descendants are always rendered relative to the camera node’s origin and without applying the camera’s scaling or rotation to them. For example, if your app displays scores or other data floating above the gameplay, the nodes that render these elements should be added as child nodes to the camera."
  },
  {
    "title": "showsFields | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866082-showsfields",
    "html": "Discussion\n\nWhen this debugging option is enabled, each time a frame is rendered, an image is drawn behind your scene that shows the effects of any physics fields contained in the scene.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information."
  },
  {
    "title": "showsQuadCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866078-showsquadcount",
    "html": "Discussion\n\nSpriteKit converts the node tree into one or more rendering passes. Each rendering pass is rendered using a series of textured rectangles (quads). The showsQuadCount property allows you to see the total number of quads that were used to render the scene’s contents. Use this as another piece of data when you profile your game’s performance. In most cases, fewer quads is better.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "showsDrawCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866077-showsdrawcount",
    "html": "Discussion\n\nSome operations in SpriteKit can require multiple rendering passes to draw a scene’s content. For example, an SKEffectNode object must render its children into a separate buffer, apply the effect, and then perform another pass to blend those results into its parent node. These additional rendering passes use more rendering resources, reducing your game’s frame rate or increasing its total power consumption. Use the draw count as another piece of data when you profile your game’s performance.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "showsPhysics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866076-showsphysics",
    "html": "Discussion\n\nWhen this debugging option is enabled, each time a frame is rendered, an overlay image is drawn on top of your scene that shows the positions and shapes of any physics bodies visible in the scene.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "remove(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449609-remove",
    "html": "Parameters\njoint\n\nThe joint to remove.\n\nSee Also\nJoining Physics Bodies with Joints\nfunc add(SKPhysicsJoint)\nAdds a joint to the physics world.\nfunc removeAllJoints()\nRemoves all joints from the physics world."
  },
  {
    "title": "SKLabelHorizontalAlignmentMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelhorizontalalignmentmode",
    "html": "Topics\nConstants\ncase center\nCenters the text horizontally on the node’s origin.\ncase left\nPositions the text so that the left side of the text is on the node’s origin.\ncase right\nPositions the text so that the right side of the text is on the node’s origin.\nRelationships\nConforms To\nSendable\nSee Also\nControlling a Label's Alignment\nvar verticalAlignmentMode: SKLabelVerticalAlignmentMode\nThe vertical position of the text within the node.\nenum SKLabelVerticalAlignmentMode\nOptions for aligning text vertically.\nvar horizontalAlignmentMode: SKLabelHorizontalAlignmentMode\nThe horizontal position of the text within the node."
  },
  {
    "title": "SKTileDefinitionRotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinitionrotation",
    "html": "Topics\nEnumeration Cases\ncase rotation0\ncase rotation180\ncase rotation270\ncase rotation90\nRelationships\nConforms To\nSendable\nSee Also\nRotating a Tile\nvar rotation: SKTileDefinitionRotation\nThe rotation of the tile definition in 90˚ increments."
  },
  {
    "title": "sampleFields(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449627-samplefields",
    "html": "Parameters\nposition\n\nA position in scene coordinates.\n\nReturn Value\n\nThe summation of forces exerted on that point.\n\nDiscussion\n\nThe sample is calculated as if a physics body is placed at that position in the scene. The body is assumed to have a mass of 1.0, with no charge or velocity. The body is affected by all field nodes."
  },
  {
    "title": "rotationMatrix() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883247-rotationmatrix",
    "html": "See Also\nReading the Current Rotation\nfunc eulerAngles() -> vector_float3\nfunc quaternion() -> simd_quatf"
  },
  {
    "title": "SKBlendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skblendmode",
    "html": "Topics\nConstants\ncase alpha\nThe source and destination colors are blended by multiplying the source alpha value.\ncase add\nThe source and destination colors are added together.\ncase subtract\nThe source color is subtracted from the destination color.\ncase multiply\nThe source color is multiplied by the destination color.\ncase multiplyX2\nThe source color is multiplied by the destination color and then doubled.\ncase screen\nThe source color is added to the destination color times the inverted source color.\ncase replace\nThe source color replaces the destination color.\nEnumeration Cases\ncase multiplyAlpha\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring Alpha Blendling\nBlending a Sprite with Different Interpretations of Alpha\nReinterpret a sprite's alpha property to react differently to the objects below it.\nvar blendMode: SKBlendMode\nThe blend mode used to draw the sprite into the parent’s framebuffer."
  },
  {
    "title": "init(name:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455420-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nReturn Value\n\nAn initialized uniform object.\n\nDiscussion\n\nA uniform initialized with this method has no initial type and cannot be used in a shader until it is given an initial value. To set the initial value, use one of the properties defined in Reading and Writing an Uniform Object’s Value. After its value is set, its uniformType property is set to match the uniform’s new type. Once set, the type may not be changed.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455442-name",
    "html": "Discussion\n\nYour custom fragment shader uses this name to identify the variable. SpriteKit automatically declares the uniform variable for your shader.\n\nSee Also\nReading Information About a Uniform\nvar uniformType: SKUniformType\nThe uniform object’s data type."
  },
  {
    "title": "floatValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455406-floatvalue",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture."
  },
  {
    "title": "convertPoint(fromView:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520395-convertpoint",
    "html": "Parameters\npoint\n\nA point in view coordinates.\n\nReturn Value\n\nThe same point in the scene’s coordinate system.\n\nDiscussion\n\nThe scene must be presented in a view before calling this method.\n\nSee Also\nConverting Between Coordinate Systems\nfunc convertPoint(toView: CGPoint) -> CGPoint\nConverts a point from scene coordinates to view coordinates."
  },
  {
    "title": "convertPoint(toView:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520082-convertpoint",
    "html": "Parameters\npoint\n\nA point in scene coordinates.\n\nReturn Value\n\nThe same point in the view’s coordinate system.\n\nDiscussion\n\nThe scene must be presented in a view before calling this method.\n\nSee Also\nConverting Between Coordinate Systems\nfunc convertPoint(fromView: CGPoint) -> CGPoint\nConverts a point from view coordinates to scene coordinates."
  },
  {
    "title": "backgroundColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520278-backgroundcolor",
    "html": "Discussion\n\nThe default value is a gray color (RGBA 0.15, 0.15, 0.15, 1.0).\n\nSee Also\nSetting the Background Appearance\nCreating a Scene with a Transparent Background\nSet a transparent background color to show the content of the views below.\nvar view: SKView?\nThe view that is currently presenting the scene."
  },
  {
    "title": "render(withViewport:renderCommandEncoder:renderPassDescriptor:commandQueue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866083-render",
    "html": "See Also\nRendering the Scene\nfunc render(withViewport: CGRect, commandBuffer: MTLCommandBuffer, renderPassDescriptor: MTLRenderPassDescriptor)"
  },
  {
    "title": "audioEngine | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519644-audioengine",
    "html": "Discussion\n\nAn audio engine instance is automatically created for you when the scene is created. You can use methods and properties on a scene’s audio engine for overall control of all of its child audio nodes. The following code shows how a scene’s overall volume can be reduced from its default of 1.0 down to 0.2 and then paused:\n\nlet scene = SKScene()\nscene.audioEngine.mainMixerNode.outputVolume = 0.2\nscene.audioEngine.pause()\n\nSee Also\nAdding Positional Audio\nUsing Audio Nodes with the Scene's Listener\nAdd audio to your scene, and optionally give it 2D-positional mixing characteristics.\nvar listener: SKNode?\nA node used to determine the position of the listener for positional audio in the scene."
  },
  {
    "title": "listener | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520363-listener",
    "html": "Discussion\n\nThe default value is nil, which means that the scene’s origin is used as the listener position for audio effects played by SKAudioNode objects in the scene. If a non-nil value is specified, it must be a node in the scene.\n\nTypically, you want the camera to be the listener so that audio nodes which are on screen are louder than off screen ones. In a game, the node that defines the player would likely be set as the listener.\n\nSee Also\nAdding Positional Audio\nUsing Audio Nodes with the Scene's Listener\nAdd audio to your scene, and optionally give it 2D-positional mixing characteristics.\nvar audioEngine: AVAudioEngine\nThe AVFoundation audio engine used to play audio from audio nodes contained in the scene."
  },
  {
    "title": "Using Audio Nodes with the Scene's Listener | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/using_audio_nodes_with_the_scene_s_listener",
    "html": "Overview\n\nThe simplest way to add audio to a SpriteKit scene is to add a child SKAudioNode to it:\n\nlet audio = SKAudioNode(fileNamed: \"drums.mp3\")\n\n\nspriteKitViewController.scene.addChild(audio)\n\n\n\n\nHowever, if you define the presented scene's listener, its audio nodes are played back with positional sound mixing. For example, if you set the scene's listener to be the scene's camera and then add audio nodes as children to various parent nodes in the scene, the further away the parent nodes are from the center of the screen, the quieter their audio will be played.\n\nSee Also\nAdding Positional Audio\nvar listener: SKNode?\nA node used to determine the position of the listener for positional audio in the scene.\nvar audioEngine: AVAudioEngine\nThe AVFoundation audio engine used to play audio from audio nodes contained in the scene."
  },
  {
    "title": "scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866081-scene",
    "html": "See Also\nFirst Steps\ninit(device: MTLDevice)\nInitializes with a specific GPU to render into."
  },
  {
    "title": "init(device:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866072-init",
    "html": "Parameters\ndevice\n\nA Metal device.\n\nReturn Value\n\nA new renderer object.\n\nDiscussion\n\nPass in the same Metal device that is associated to the Metal command buffer passed into render(withViewport:commandBuffer:renderPassDescriptor:).\n\nSee Also\nFirst Steps\nvar scene: SKScene?\nThe scene this renderer will draw into the Metal command buffer."
  },
  {
    "title": "view | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519726-view",
    "html": "Discussion\n\nTo present a scene, you call the presentScene(_:) method or presentScene(_:transition:) method on the SKView class. If the scene is not currently presented, this property holds nil.\n\nSee Also\nSetting the Background Appearance\nCreating a Scene with a Transparent Background\nSet a transparent background color to show the content of the views below.\nvar backgroundColor: UIColor\nThe background color of the scene."
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520213-delegate",
    "html": "Discussion\n\nWhen a delegate is present, when any of the animation loop methods steps are executed, your delegate is called. Typically, you use a delegate when you do not want to implement a scene subclass or if you want to dynamically change the scene behavior at runtime.\n\nSee Also\nConfiguring a Delegate\nSubclassing Scenes Versus Assigning a Delegate\nUse a scene delegate to share app logic across various scenes.\nprotocol SKSceneDelegate\nMethods that, when implemented, allow any class to participate in the SpriteKit render loop callbacks."
  },
  {
    "title": "Creating a Scene with a Transparent Background | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/creating_a_scene_with_a_transparent_background",
    "html": "Overview\n\nTo overlay content rendered with SpriteKit on top of another view, follow these steps:\n\nSet the scene's backgroundColor to clear.\n\nEnable allowsTransparency on the view.\n\nSet the view's backgroundColor to clear.\n\nSee Also\nSetting the Background Appearance\nvar view: SKView?\nThe view that is currently presenting the scene.\nvar backgroundColor: UIColor\nThe background color of the scene."
  },
  {
    "title": "didEvaluateActions() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519903-didevaluateactions",
    "html": "Discussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. It is called after any actions have been evaluated by nodes in the scene but before any physics are simulated.\n\nAny additional actions applied are not evaluated until the next update.\n\nSee Also\nResponding to Frame-Cycle Events\nResponding to Frame-Cycle Events\nImplement per-frame app logic, such as the scene's update function that's called every frame.\nfunc update(TimeInterval)\nTells your app to perform any app-specific logic to update your scene.\nfunc didSimulatePhysics()\nTells your app to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints()\nTells your app to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate()\nTells your app to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "didSimulatePhysics() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519965-didsimulatephysics",
    "html": "Discussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. It is called after physics has been simulated in the scene.\n\nAny additional actions applied are not evaluated until the next update.\n\nAny changes to physics bodies are not simulated until the next update.\n\nSee Also\nResponding to Frame-Cycle Events\nResponding to Frame-Cycle Events\nImplement per-frame app logic, such as the scene's update function that's called every frame.\nfunc update(TimeInterval)\nTells your app to perform any app-specific logic to update your scene.\nfunc didEvaluateActions()\nTells your app to peform any necessary logic after scene actions are evaluated.\nfunc didApplyConstraints()\nTells your app to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate()\nTells your app to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "Responding to Frame-Cycle Events | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/responding_to_frame-cycle_events",
    "html": "Overview\n\nWhen a scene is presented via presentScene(_:), SpriteKit calls you every frame if you implement any of the functions shown in the following image:\n\nIf you don't implement any of the frame-cycle functions, SpriteKit will only render the scene when something within it has changed, improving energy efficiency and allowing your game or app to perform other operations instead.\n\nDecide Which Events to Implement\n\nEach time through the rendering loop, the scene’s contents are updated and then rendered. You can’t override the rendering behavior; instead you update the nodes in the scene. However, the scene includes methods you can override to customize scene processing, and you can use actions and physics to alter properties of nodes in the tree. Here are the steps in the rendering loop:\n\nThe scene’s update(_:) method is called with the time elapsed so far in the simulation. This is the primary place to implement your own in-game simulation, including input handling, artificial intelligence, game scripting, and other similar game logic. Often, you use this method to make changes to nodes or to run actions on nodes.\n\nThe scene processes actions on all the nodes in the tree. It finds any running actions and applies those changes to the tree. In practice, because of custom actions, you can also hook into the action mechanism to call your own code. You cannot directly control the order in which actions are processed or cause the scene to skip actions on certain nodes, except by removing the actions from those nodes or removing the nodes from the tree.\n\nThe scene’s didEvaluateActions() method is called after all actions for the frame have been processed.\n\nThe scene simulates physics on nodes in the tree that have physics bodies. Adding physics to nodes in a scene is described in SKPhysicsBody, but the end result of simulating physics is that the position and rotation of nodes in the tree may be adjusted by the physics simulation. Your game can also receive callbacks when physics bodies come into contact with each other. See SKPhysicsContactDelegate.\n\nThe scene’s didSimulatePhysics() method is called after all physics bodies for the frame have been simulated.\n\nThe scene applies any constraints associated with nodes in the scene. Constraints are used to establish relationships in the scene. For example, you can apply a constraint that makes sure a node is always pointed at another node, regardless of how it is moved. By using constraints, you avoid needing to write a lot of custom code in your scene handling.\n\nThe scene calls its didApplyConstraints() method.\n\nThe scene calls its didFinishUpdate() method. This is your last chance to make changes to the scene.\n\nThe scene is rendered.\n\nUse a Scene Delegate Instead of Subclassing a Scene\n\nSubclassing SKScene and overriding frame-cycle functions is a simple way to implement your app's logic, but you avoid subclassing by using a delegate. All of the frame-cycle functions defined by SKScene have an SKSceneDelegate protocol equivalent function. So, if you provide a scene delegate, the delegate's frame-cycle methods are called instead of those on the scene. For example, an iOS app might use a view controller as the scene delegate. See Subclassing Scenes Versus Assigning a Delegate for more information.\n\nImplement Post-Processing\n\nA scene can process the actions on the scene tree in any order. For this reason, if you have tasks that you need to run each frame and you need precise control over when they run, you should use the didEvaluateActions() and didSimulatePhysics() methods to perform those tasks. Typically, you make changes during post-processing that require the final calculated positions of certain nodes in the tree. Your post-processing can take these positions and perform other useful work on the tree.\n\nSee Also\nResponding to Frame-Cycle Events\nfunc update(TimeInterval)\nTells your app to perform any app-specific logic to update your scene.\nfunc didEvaluateActions()\nTells your app to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics()\nTells your app to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints()\nTells your app to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate()\nTells your app to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "didApplyConstraints() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520006-didapplyconstraints",
    "html": "Discussion\n\nDo not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.\n\nSee Also\nResponding to Frame-Cycle Events\nResponding to Frame-Cycle Events\nImplement per-frame app logic, such as the scene's update function that's called every frame.\nfunc update(TimeInterval)\nTells your app to perform any app-specific logic to update your scene.\nfunc didEvaluateActions()\nTells your app to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics()\nTells your app to peform any necessary logic after physics simulations are performed.\nfunc didFinishUpdate()\nTells your app to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "Subclassing Scenes Versus Assigning a Delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/subclassing_scenes_versus_assigning_a_delegate",
    "html": "Overview\n\nOften, your app subclasses SKScene to deliver gameplay. Your subclass usually:\n\nLays out initial scene content\n\nDefines app logic that runs every frame\n\nImplements responder methods to handle keyboard, mouse, or touch events\n\nAn alternative pattern is to assign a delegate that handles Responding to Frame-Cycle Events instead. For example, if you make the view controller the delegate for your scene, it can use multiple scenes that share the same SKSceneDelegate implementations. The view controller participates in event handling and so it can respond to user input also.\n\nImportant\n\nOn macOS, you need to set the window's nextResponder to your app's view controller because by default, the view is the first responder to user input events.\n\nSee Also\nConfiguring a Delegate\nvar delegate: SKSceneDelegate?\nA delegate to be called during the animation loop.\nprotocol SKSceneDelegate\nMethods that, when implemented, allow any class to participate in the SpriteKit render loop callbacks."
  },
  {
    "title": "willMove(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519703-willmove",
    "html": "Parameters\nview\n\nThe view that is presenting the scene.\n\nDiscussion\n\nThis method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be removed from the view.\n\nSee Also\nResponding to Loading and Resizing Events\nfunc sceneDidLoad()\nTells you when the scene is presented.\nfunc didChangeSize(CGSize)\nTells you when the scene’s size has changed.\nfunc didMove(to: SKView)\nTells you when the scene is presented by a view."
  },
  {
    "title": "removeFromParent() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483119-removefromparent",
    "html": "See Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node.\nRelated Documentation\nvar parent: SKNode?\nThe node’s parent node.\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "didMove(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519607-didmove",
    "html": "Parameters\nview\n\nThe view that is presenting the scene.\n\nDiscussion\n\nThis method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be presented by a view. For example, you might use this method to create the scene’s contents.\n\nSee Also\nResponding to Loading and Resizing Events\nfunc sceneDidLoad()\nTells you when the scene is presented.\nfunc didChangeSize(CGSize)\nTells you when the scene’s size has changed.\nfunc willMove(from: SKView)\nTells you when the scene is about to be removed from a view."
  },
  {
    "title": "init(size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520435-init",
    "html": "Parameters\nsize\n\nThe size of the scene in points.\n\nReturn Value\n\nA newly initialized scene object.\n\nDiscussion\n\nThis is the class’s designated initializer method.\n\nSee Also\nCreating a Scene Programmatically\nvar size: CGSize\nThe dimensions of the scene, in points."
  },
  {
    "title": "Searching the Node Tree | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/searching_the_node_tree",
    "html": "Overview\n\nThe nodes in the scene tree are often organized to determine the precise rendering order for the scene, not the role these nodes play in your scene. You may also be loading nodes from an archive file rather than instantiating them directly at runtime, so you may need to be able to find specific nodes within a node tree. To do this, you provide names to nodes and then search for those names.\n\nThe node name usually serves two purposes in your app:\n\nYou can write your own code that implements game logic based on the node’s name. For example, when two physics objects collide, you might use the node names to determine how the collision affects gameplay.\n\nYou can search for nodes that have a particular name. Typically, this is done once, when a scene is first loaded.\n\nName Your Node\n\nA node’s name property should be an alphanumeric string without any punctuation. The following code shows how you might name three different nodes to distinguish them from each other.\n\nplayerNode.name = \"player\"\nmonsterNode1.name = \"goblin\"\nmonsterNode2.name = \"ogre\"\n\n\nWhen you name nodes in the tree, decide whether those names will be unique. If a node’s name is unique, you should never include more than one node with that name in the scene tree. On the other hand, if a node name is not unique within your app, it might represent a collection of related nodes. For example, in the code above, there are probably multiple goblins within the game, and you might want to identify them all with the same name. But the player might be a unique node within the game.\n\nUse a Simple Search\n\nThe SKNode class implements the following methods for searching the node tree:\n\nThe childNode(withName:) method searches a node’s children until it finds a matching node, then it stops and returns this node. This method is usually used to search for nodes with unique names.\n\nThe enumerateChildNodes(withName:using:) method searches a node’s children and calls your block once for each matching node it finds. You use this method when you want to find all nodes that share the same name.\n\nThe subscript(_:) method returns an array of nodes that match a particular name.\n\nThe following code shows how you might create a method on your scene class to find the player node. You might use a method like this inside your code to load and prepare a scene.\n\nvar playerNode: SKNode? {\n    return childNode(withName: \"player\")\n}\n\n\nWhen this method is called on the scene, the scene searches its children (and only its children) for a node whose name property matches the search string, then returns the node. When specifying a search string, you can either specify the name of the node or a class name. For example, if you create your own subclass for the player node and name it PlayerSprite, then you could specify PlayerSprite as the search string instead of player; the same node would be returned.\n\nUse an Advanced Search\n\nThe default search only searches a node’s children and must exactly match either the node’s name or its class. However, SpriteKit provides an expressive search syntax so that you can perform more advanced searches. For example, you could do the same search as before but search the entire scene tree. Or you could search the node’s children, but match a pattern rather than requiring an exact match.\n\nTable 1 describes the different syntax options. The search uses common regular expression semantics.\n\nTable 1 Search syntax options\n\nSyntax\n\n\t\n\nDescription\n\n\n\n\n/\n\n\t\n\nWhen placed at the start of the search string, this indicates that the search should be performed on the tree’s root node. When placed anywhere but the start of the search string, this indicates that the search should move to the node’s children.\n\n\n\n\n//\n\n\t\n\nWhen placed at the start of the search string, this specifies that the search should begin at the root node and be performed recursively across the entire node tree. Otherwise, it performs a recursive search from its current position.\n\n\n\n\n.\n\n\t\n\nRefers to the current node.\n\n\n\n\n..\n\n\t\n\nThe search should move up to the node’s parent.\n\n\n\n\n*\n\n\t\n\nThe search matches zero or more characters.\n\n\n\n\n[characters delimited by commas or dashes]\n\n\t\n\nThe search matches any of the characters contained inside the brackets.\n\n\n\n\nalphanumeric characters\n\n\t\n\nThe search matches only the specified characters.\n\nTable 2 shows some useful search strings to help get you started.\n\nTable 2 Example searches\n\nSearch string\n\n\t\n\nDescription\n\n\n\n\nMyName\n\n\t\n\nMatches any of the current node’s children that are named MyName.\n\n\n\n\n/MyName\n\n\t\n\nMatches any of the root node’s children that are named MyName.\n\n\n\n\n//MyName\n\n\t\n\nMatches any nodes in the tree that are named MyName.\n\n\n\n\n.//MyName\n\n\t\n\nMatches any descendants of the current node that are named MyName.\n\n\n\n\n//MyName/..\n\n\t\n\nFinds the parent nodes of any nodes in the tree that are named MyName.\n\n\n\n\n//*\n\n\t\n\nMatches every node in the tree.\n\n\n\n\nA[0-9]\n\n\t\n\nMatches any of the current node’s children that are named A0, A1, …, A9.\n\n\n\n\nAbby/Normal\n\n\t\n\nMatches any grandchild of the current node when the grandchild is named Normal and the grandchild’s parent is named Abby.\n\n\n\n\n//Abby/Normal\n\n\t\n\nMatches any nodes in the tree that are named Normal and whose parents are named Abby.\n\nSee Also\nAccessing Nodes by Name\nvar name: String?\nThe node’s assignable name.\nfunc childNode(withName: String) -> SKNode?\nSearches the children of the receiving node for a node with a specific name.\nfunc enumerateChildNodes(withName: String, using: (SKNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nSearches the children of the receiving node to perform processing for nodes that share a name.\nsubscript(String) -> [SKNode]\nReturns an array of nodes that match the name parameter."
  },
  {
    "title": "inParentHierarchy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483111-inparenthierarchy",
    "html": "Parameters\nparent\n\nAn SKNode object to test against.\n\nReturn Value\n\ntrue if the node is a descendant of the parent node; otherwise false.\n\nSee Also\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node."
  },
  {
    "title": "About Node Property Propagation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/about_node_property_propagation",
    "html": "Overview\n\nChanging certain properties on a node can propogate to its decendents:\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nxScale, yScale\n\n\t\n\nThe node’s coordinate system is scaled by these two factors. This property affects coordinate conversion, the node’s frame, drawing, and hit testing. Its descendants are similarly scaled.\n\n\n\n\nzPosition\n\n\t\n\nThe node's draw order. Nodes with a higher zPosition are rendered above nodes with a lower zPosition. This value propagates to its descendants such that a node's zPosition is equal to that of its parent node, plus any value it holds in its own zPosition property.\n\n\n\n\nzRotation\n\n\t\n\nThe node’s coordinate system is rotated. This property affects coordinate conversion, the node’s frame, drawing, and hit testing. Its descendants are similarly scaled.\n\n\n\n\nalpha\n\n\t\n\nIf the node is rendered using a blend mode, the alpha value is multiplied into any alpha value before the blend operation takes place. The descendants are similarly affected.\n\n\n\n\nisHidden\n\n\t\n\nIf a node is hidden, the node and its descendants are not rendered.\n\n\n\n\nspeed\n\n\t\n\nThe speed at which a node processes actions is multiplied by this value. The descendants are similarly affected.\n\nThe net effect is that a child node is rendered based not only on its own properties but also on the properties of its ancestors."
  },
  {
    "title": "byDifference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion/1519879-bydifference",
    "html": "Parameters\nregion\n\nThe region to subtract.\n\nReturn Value\n\nA new region whose contents include all points in the current region that are not also included in the second region.\n\nSee Also\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(radius: Float)\nInitializes a new region with a circular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region."
  },
  {
    "title": "vertexCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/1690940-vertexcount",
    "html": "Discussion\n\nThe number of vertices is the same as (numberOfColumns + 1) * (numberOfRows + 1).\n\nSee Also\nAccessing or Setting Warp Geometry Grid Size\nvar numberOfColumns: Int\nThe object's number of columns.\nvar numberOfRows: Int\nThe object's number of rows."
  },
  {
    "title": "init(tileGroups:tileSetType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643896-init",
    "html": "Parameters\ntileGroups\n\nAn array of SKTileGroup objects from which to create the tile set from.\n\ntileSetType\n\nThe arrangement of the tiles.\n\nReturn Value\n\nA new tile set.\n\nSee Also\nCreating a Tile Set Programmatically\ninit(tileGroups: [SKTileGroup])\nInitializes a new tile set with an array of tile groups and rectangular grid layout."
  },
  {
    "title": "sourcePosition(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/1690952-sourceposition",
    "html": "Parameters\nindex\n\nThe index of the position vertex to query.\n\nReturn Value\n\nThe normalized position of the specified vertex in sourcePositions.\n\nDiscussion\n\nThe specified index must be between 0 and the warp geometry grid's vertexCount - 1.\n\nSee Also\nAccessing or Setting Grid Vertices\nfunc destPosition(at: Int) -> vector_float2\nReturns the destination position of a vertex.\nfunc replacingByDestinationPositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument destination positions.\nfunc replacingBySourcePositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument source positions."
  },
  {
    "title": "vectorFloat3Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643434-vectorfloat3value",
    "html": "Discussion\n\nIf the receiver’s original value is a floating-point number or a vector_float2, the empty items in the vector are set to 0. If the receiver’s original value is a vector_float4, the last item is truncated."
  },
  {
    "title": "type | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643836-type",
    "html": "Discussion\n\nThe tile set's type specifies how the tiles in the set will be arranged when placed in a tile map.\n\nSee Also\nAccessing or Reading a Tile Set's Properties\nvar defaultTileGroup: SKTileGroup?\nThe tile set's default tile group.\nvar defaultTileSize: CGSize\nThe tile set's default tile size.\nvar name: String?\nA name associated with the tile set.\nvar tileGroups: [SKTileGroup]\nThe tile set's array of tile group objects.\nenum SKTileSetType\nAn enumeration defining how tiles are arranged."
  },
  {
    "title": "SKTileSetType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilesettype",
    "html": "Topics\nEnumeration Cases\ncase grid\ncase hexagonalFlat\ncase hexagonalPointy\ncase isometric\nRelationships\nConforms To\nSendable\nSee Also\nAccessing or Reading a Tile Set's Properties\nvar defaultTileGroup: SKTileGroup?\nThe tile set's default tile group.\nvar defaultTileSize: CGSize\nThe tile set's default tile size.\nvar name: String?\nA name associated with the tile set.\nvar tileGroups: [SKTileGroup]\nThe tile set's array of tile group objects.\nvar type: SKTileSetType\nThe tile set's type."
  },
  {
    "title": "setRotationMatrix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883241-setrotationmatrix",
    "html": "See Also\nRotating Child Nodes\nvar xRotation: CGFloat\nvar yRotation: CGFloat\nfunc setEulerAngles(vector_float3)\nfunc setQuaternion(simd_quatf)"
  },
  {
    "title": "quaternion() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883244-quaternion",
    "html": "See Also\nReading the Current Rotation\nfunc eulerAngles() -> vector_float3\nfunc rotationMatrix() -> matrix_float3x3"
  },
  {
    "title": "setEulerAngles(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883246-seteulerangles",
    "html": "See Also\nRotating Child Nodes\nvar xRotation: CGFloat\nvar yRotation: CGFloat\nfunc setQuaternion(simd_quatf)\nfunc setRotationMatrix(matrix_float3x3)"
  },
  {
    "title": "setQuaternion(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883240-setquaternion",
    "html": "See Also\nRotating Child Nodes\nvar xRotation: CGFloat\nvar yRotation: CGFloat\nfunc setEulerAngles(vector_float3)\nfunc setRotationMatrix(matrix_float3x3)"
  },
  {
    "title": "eulerAngles() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883245-eulerangles",
    "html": "See Also\nReading the Current Rotation\nfunc quaternion() -> simd_quatf\nfunc rotationMatrix() -> matrix_float3x3"
  },
  {
    "title": "yRotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883242-yrotation",
    "html": "See Also\nRotating Child Nodes\nvar xRotation: CGFloat\nfunc setEulerAngles(vector_float3)\nfunc setQuaternion(simd_quatf)\nfunc setRotationMatrix(matrix_float3x3)"
  },
  {
    "title": "SKAttributeType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributetype",
    "html": "Topics\nEnumeration Cases\ncase float\ncase halfFloat\ncase none\ncase vectorFloat2\ncase vectorFloat3\ncase vectorFloat4\ncase vectorHalfFloat2\ncase vectorHalfFloat3\ncase vectorHalfFloat4\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "xRotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode/2883239-xrotation",
    "html": "See Also\nRotating Child Nodes\nvar yRotation: CGFloat\nfunc setEulerAngles(vector_float3)\nfunc setQuaternion(simd_quatf)\nfunc setRotationMatrix(matrix_float3x3)"
  },
  {
    "title": "SKTransitionDirection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransitiondirection",
    "html": "Topics\nConstants\ncase up\nThe transition goes up.\ncase down\nThe transition goes down.\ncase right\nThe transition goes right.\ncase left\nThe transition goes left.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "SKNodeFocusBehavior | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknodefocusbehavior",
    "html": "Topics\nEnumeration Cases\ncase none\nNode is not focusable.\ncase occluding\nNode is not focusable and prevents nodes that it visually obscures from becoming focusable.\ncase focusable\nNode is focusable and prevents nodes that it visually obscures from becoming focusable.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "SKParticleRenderOrder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skparticlerenderorder",
    "html": "Topics\nConstants\ncase oldestLast\nThe particles are rendered from newest to oldest. This is the default value.\ncase oldestFirst\nThe particles are rendered from oldest to newest.\ncase dontCare\nThe particles can be rendered in any order. SpriteKit may choose to reorder the particles to improve rendering performance.\nRelationships\nConforms To\nSendable\nSee Also\nControlling the Rendering Order of an Emitter's Particles\nvar particleRenderOrder: SKParticleRenderOrder\nThe order in which the emitter’s particles are rendered."
  },
  {
    "title": "init(name:float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455462-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nvalue\n\nThe initial matrix for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.floatMatrix3.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "init(name:float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455431-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nvalue\n\nThe initial matrix for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.floatMatrix2.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "init(name:float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455429-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nvalue\n\nThe initial matrix for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.floatMatrix4.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "init(name:texture:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455452-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\ntexture\n\nThe initial texture to use for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.texture.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated"
  },
  {
    "title": "uniformType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455440-uniformtype",
    "html": "Discussion\n\nA uniform object’s type is set to SKUniformType.none until the first time that the uniform variable’s value is set; this happens automatically if you use an initialization method that provides an initial type and value. Once the uniform object is given an initial value, its type changes to that value’s type and thereafter cannot be changed.\n\nSee Also\nReading Information About a Uniform\nvar name: String\nThe uniform’s name."
  },
  {
    "title": "floatVector2Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455436-floatvector2value",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture."
  },
  {
    "title": "textureValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455449-texturevalue",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated"
  },
  {
    "title": "SKUniformType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniformtype",
    "html": "Topics\nConstants\ncase none\nIndicates that the uniform variable does not currently hold any data. A uniform object has this type until the first time its value is set.\ncase float\nIndicates that the uniform variable holds a 32-bit floating-point value.\ncase floatVector2\nIndicates that the uniform variable holds a vector of two 32-bit floating-point values.\ncase floatVector3\nIndicates that the uniform variable holds a vector of three 32-bit floating-point values.\ncase floatVector4\nIndicates that the uniform variable holds a vector of four 32-bit floating-point values.\ncase floatMatrix2\nIndicates that the uniform variable holds a 2 x 2 matrix of four 32-bit floating-point values.\ncase floatMatrix3\nIndicates that the uniform variable holds a 3 x 3 matrix of four 32-bit floating-point values.\ncase floatMatrix4\nIndicates that the uniform variable holds a 3 x 3 matrix of four 32-bit floating-point values.\ncase texture\nIndicates that the uniform variable holds a reference to a SpriteKit texture.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "init(columns:rows:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/1690938-init",
    "html": "Parameters\ncols\n\nThe number of columns in the grid.\n\nrows\n\nThe number of rows in the grid.\n\nReturn Value\n\nA new warp geometry grid object.\n\nDiscussion\n\nCreating a warp geometry grid without explicit source and destination positions automatically generates the required position arrays. For example, a 2 column by 2 row grid would create two arrays containing nine positions each, beginning at [0,0] - for the bottom left position - and ending at [1,1] - for the top left position.\n\nTable 1 \n\nindex: 6, position: [0.0, 1.0]\n\n\t\n\nindex: 7, position: [0.5, 1.0]\n\n\t\n\nindex: 8, position: [1.0, 1.0]\n\n\n\n\nindex: 3, position: [0.0, 0.5]\n\n\t\n\nindex: 4, position: [0.5, 0.5]\n\n\t\n\nindex: 5, position: [1.0, 0.5]\n\n\n\n\nindex: 0, position: [0.0, 0.0]\n\n\t\n\nindex: 1, position: [0.5, 0.0]\n\n\t\n\nindex: 2, position: [1.0, 0.0]\n\nSee Also\nCreating a Warp Geometry Grid\ninit(columns: Int, rows: Int, sourcePositions: [SIMD2<Float>], destinationPositions: [SIMD2<Float>])\nCreates a warp geometry grid of a specific size and warp translation, in point arrays.\ninit?(coder: NSCoder)\nTells you when to intialize a grid that was loaded from an archive."
  },
  {
    "title": "init(columns:rows:sourcePositions:destinationPositions:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/2325579-init",
    "html": "Parameters\ncolumns\n\nThe number of columns in the grid.\n\nrows\n\nThe number of rows in the grid.\n\nsourcePositions\n\nOptionally included array of the grid's source warp positions.\n\ndestinationPositions\n\nOptionally included array of the grid's destination warp positions.\n\nReturn Value\n\nA new warp geometry grid object.\n\nDiscussion\n\nYou supply the source and destination position as row-major arrays of normalized vector_float2 coordinates. The number of horizontal coordinates is the column count plus one and the number of vertical coordinates is the row count plus one. Passing nil as either of the position arguments results in an identity warp with vertices distributed evenly throughout the geometry. Passing nil to both sourcePositions and destPositions gives a result identical to init(columns:rows:).\n\nSee Also\nCreating a Warp Geometry Grid\ninit(columns: Int, rows: Int)\nCreates a warp geometry grid of a specified size.\ninit?(coder: NSCoder)\nTells you when to intialize a grid that was loaded from an archive."
  },
  {
    "title": "numberOfRows | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/1690943-numberofrows",
    "html": "See Also\nAccessing or Setting Warp Geometry Grid Size\nvar numberOfColumns: Int\nThe object's number of columns.\nvar vertexCount: Int\nThe object's total number of vertices."
  },
  {
    "title": "init(coder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/1690949-init",
    "html": "See Also\nCreating a Warp Geometry Grid\ninit(columns: Int, rows: Int)\nCreates a warp geometry grid of a specified size.\ninit(columns: Int, rows: Int, sourcePositions: [SIMD2<Float>], destinationPositions: [SIMD2<Float>])\nCreates a warp geometry grid of a specific size and warp translation, in point arrays."
  },
  {
    "title": "Animate the Warping of a Sprite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/animate_the_warping_of_a_sprite",
    "html": "Overview\n\nYou create an SKWarpGeometryGrid by supplying two arrays of normalized vertex positions. The sourcePositions array defines the positions of the vertices in the unwarped geometry and the destinationPositions array defines the final, warped destination positions for the source vertices. Both arrays are one dimensional and in row-major order, which means that you additionally have to supply the number of columns and rows of the geometry.\n\nThe number of columns or rows is one less than the number of horizontal or vertical vertices, respectively.\n\nThe origin of the vertex positions is in the bottom left of the grid. The following code shows how you can create an array of evenly spaced vertices that could act as a default set of source positions for a warp geometry with two columns and two rows. The first item in the array refers to the position at the bottom left, and the last item refers to the position at the top right.\n\nlet sourcePositions: [float2] = [\n    float2(0, 1),   float2(0.5, 1),   float2(1, 1),\n    float2(0, 0.5), float2(0.5, 0.5), float2(1, 0.5),\n    float2(0, 0),   float2(0.5, 0),   float2(1, 0)\n]\n\n\n\n\nIf you wanted to give the effect of horizontally squeezing a grid defined by the above vertices around its middle — which would cause it to stretch vertically — you could use a set of destination positions, as shown in the following code:\n\nlet destinationPositions: [float2] = [\n    float2(-0.25, 1.5), float2(0.5, 1.75), float2(1.25, 1.5),\n    float2(0.25, 0.5),   float2(0.5, 0.5),   float2(0.75, 0.5),\n    float2(-0.25, -0.5),  float2(0.5, -0.75),  float2(1.25, -0.5)\n]\n\n\nYou use the sourcePositions and destinationPositions arrays to define a warp geometry object.\n\nlet warpGeometryGrid = SKWarpGeometryGrid(columns: 2,\n                                          rows: 2,\n                                          sourcePositions: sourcePositions,\n                                          destinationPositions: destinationPositions)\n\n\n\n\nA geometry grid warps the geometry defined by the source positions (left illustration) into a new geometry defined by the destination positions (right illustration).\n\nSeveral options are available for applying this geometry to a node that conforms to SKWarpable, such as an SKSpriteNode.\n\nThe geometry can be applied immediately, without animation, by setting the nodes’s warpGeometry property. You may elect to use this technique if you are calculating and applying the destination positions with each scene update; for example, in response to a user’s touch.\n\nA single warp can be applied over time to give an animated morphing effect using the action created by warp(to:duration:). To use a warp action, you first need to define an initial geometry and set it as the warpGeometry of the node you want to warp. The init(columns:rows:) initializer creates a suitable geometry that has no distortion.\n\nIn the following code, the stretched warp geometry created above is used to initialize a warp action with a duration specified in seconds. The node’s run method executes the action.\n\nlet sprite = SKSpriteNode()\nlet warpGeometryGridNoWarp = SKWarpGeometryGrid(columns: 2, rows: 2)\nsprite.warpGeometry = warpGeometryGridNoWarp\nlet warpAction = SKAction.warp(to: warpGeometryGrid,duration: 0.5)\nsprite.run(warpAction!)\n\n\nYou can chain together multiple warp geometries to create complex morphing animations. For example, you may want to begin with the warp geometry that does not deform the node, morph to the stretched geometry at 0.5”, and finish the sequence by returning to the first geometry at 0.75”. The following code creates this action, using the animate(withWarps:times:) method.\n\nlet warpAction = SKAction.animate(withWarps:[warpGeometryGridNoWarp, \n                                             warpGeometryGrid,\n                                             warpGeometryGridNoWarp],                                  \n                                  times: [0.25, 0.5, 0.75])\n\n\nObjects that subclass SKNode but don't conform to SKWarpable — for example, SKShapeNode, SKEmitterNode, or SKVideoNode — can be warped by adding them as children of an SKEffectNode object. You can, for example, use this approach to distort vector artwork supplied as simple geometric primitives or CGPath objects and rendered with a shape node. Warping a particle emitter node that has been added as a child of an effect node allows precise control of the overall shape of a particle system."
  },
  {
    "title": "numberOfColumns | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/1690942-numberofcolumns",
    "html": "See Also\nAccessing or Setting Warp Geometry Grid Size\nvar numberOfRows: Int\nThe object's number of rows.\nvar vertexCount: Int\nThe object's total number of vertices."
  },
  {
    "title": "Disconnecting Bodies from Joints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjoint/disconnecting_bodies_from_joints",
    "html": "Overview\n\nYou can use the SKPhysicsWorld method remove(_:) to remove joints from a simulation. By making use of the update(_:for:) method of the SKSceneDelegate, you can interrogate joint properties, such as the distance between the two connected bodies.\n\nThe following code shows an example. Each time a new spring joint is created, it is also added to an array named springs of type [SKPhysicsJointSpring]. With each simulation step, every spring is evaluated. If the distance between the two connected bodies is greater than maxSpringDistance, the spring is removed from both the physics world and the array.\n\nvar springs: [SKPhysicsJointSpring] = []\nlet maxSpringDistance: CGFloat = 31\n\n\n// Each `scene.physicsWorld.add(spring)` is accompanied by `springs.append(spring)`\n\n\nfunc update(_ currentTime: TimeInterval, for scene: SKScene) {\n\tfor spring in springs {\n\t\tif let bodyAPosition = spring.bodyA.node?.position,\n\t\tlet bodyBPosition = spring.bodyB.node?.position {\n\t\tlet distance = hypot(bodyAPosition.x - bodyBPosition.x,\n\t\t\tbodyAPosition.y - bodyBPosition.y)\n\t\tif distance > maxSpringDistance {\n\t\t\tscene.physicsWorld.remove(spring)\n\t\t\tif let index = springs.index(of: spring) {\n\t\t\t\tsprings.remove(at: index)\n\t\t\t}\n\t\t}\n\t}\n}}\n"
  },
  {
    "title": "showsNodeCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866071-showsnodecount",
    "html": "Discussion\n\nWhen you enable this option, it shows the number of nodes currently in the scene's node tree.\n\nNote\n\nThe shouldCullNonVisibleNodes property affects how many nodes in the node tree are included in SpriteKit's render pass but it doesn't affect the showsNodeCount statistic.\n\nYou may achieve additional performance gain by actually removing nodes from the node tree manually which are off screen. For example, in the case of shouldCullNonVisibleNodes, there would be less nodes for SpriteKit to test every frame whether they're on screen.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "shouldCullNonVisibleNodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866075-shouldcullnonvisiblenodes",
    "html": "See Also\nConfiguring Performance Related Toggles\nvar ignoresSiblingOrder: Bool"
  },
  {
    "title": "ignoresSiblingOrder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866074-ignoressiblingorder",
    "html": "See Also\nConfiguring Performance Related Toggles\nvar shouldCullNonVisibleNodes: Bool"
  },
  {
    "title": "didFinishUpdate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1520269-didfinishupdate",
    "html": "Discussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. It is called after all update logic has been completed and before the scene is rendered.\n\nAny additional actions applied are not evaluated until the next update.\n\nAny changes to physics bodies are not simulated until the next update.\n\nAny changes to constraints will not be applied until the next update.\n\nNo further update logic will be applied to the scene after this call. Any values set on nodes here will be used when the scene is rendered for the current frame.\n\nSee Also\nResponding to Frame-Cycle Events\nResponding to Frame-Cycle Events\nImplement per-frame app logic, such as the scene's update function that's called every frame.\nfunc update(TimeInterval)\nTells your app to perform any app-specific logic to update your scene.\nfunc didEvaluateActions()\nTells your app to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics()\nTells your app to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints()\nTells your app to peform any necessary logic after constraints are applied."
  },
  {
    "title": "node | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520049-node",
    "html": "Discussion\n\nYou associate the body with a node by assigning it to the physicsBody property of the SKNode object. If the body is not associated with a node, the value is nil."
  },
  {
    "title": "camera | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519696-camera",
    "html": "Discussion\n\nThe default value of this property is nil, which means that the scene’s anchorPoint and size properties determine what portion of the scene is visible. If set to point to a camera node contained in the scene, the anchorPoint property is ignored and the scene is rendered using the camera node’s properties instead.\n\nA camera must be added as a child of the scene for it to render that scene.\n\nListing 1 shows how to add a camera to an SKScene named scene. The camera is positioned in the center of the scene which gives the same result as rendering a camera-less scene with an anchorPoint of zero.\n\nListing 1 Adding a camera to a scene\nlet cameraNode = SKCameraNode()\n    \ncameraNode.position = CGPoint(x: scene.size.width / 2,\n                              y: scene.size.height / 2)\n    \nscene.addChild(cameraNode)\nscene.camera = cameraNode\n\n\nFor more information, see SKCameraNode.\n\nSee Also\nConfiguring the Viewport\nPositioning a Scene's Origin Within its View\nTry the different ways to configure the scene's origin inside its view.\nvar anchorPoint: CGPoint\nThe point in the view’s frame that corresponds to the scene’s origin.\nRelated Documentation\nvar size: CGSize\nThe dimensions of the scene, in points."
  },
  {
    "title": "sceneDidLoad() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1645216-scenedidload",
    "html": "Discussion\n\nThis method is intended to be overridden in a subclass. It is the preferred location to peform custom setup after the scene has been initialized or decoded.\n\nSee Also\nResponding to Loading and Resizing Events\nfunc didChangeSize(CGSize)\nTells you when the scene’s size has changed.\nfunc willMove(from: SKView)\nTells you when the scene is about to be removed from a view.\nfunc didMove(to: SKView)\nTells you when the scene is presented by a view."
  },
  {
    "title": "Getting Started with Spring Joints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointspring/getting_started_with_spring_joints",
    "html": "Overview\n\nThe following code shows how you can create a spring joint between sprite nodes. The physics body of staticNode has its isDynamic property set to false, preventing it from being affected by gravity. It is animated with an SKAction to move it upward.\n\ndynamicNode is joined to staticNode with an SKPhysicsJointSpring named spring, with a frequency of 0.5 and a damping of 0.2.\n\nThe result is that as staticNode moves vertically, dynamicNode follows the upward path with a slight delay and bounce.\n\nlet scene = SKScene()\n \nlet size = CGSize(width: 50, height: 50)\n \nlet staticNode = SKSpriteNode(color: .red,\n                              size: size)\nlet dynamicNode = SKSpriteNode(color: .blue,\n                               size: size)\n \nstaticNode.physicsBody = SKPhysicsBody(rectangleOf: size)\nstaticNode.physicsBody?.isDynamic = false\nstaticNode.position = CGPoint(x: 250, y: 300)\n \ndynamicNode.physicsBody = SKPhysicsBody(rectangleOf: size)\ndynamicNode.position = CGPoint(x: 250, y: 200)\n \nscene.addChild(staticNode)\nscene.addChild(dynamicNode)\n \nlet spring = SKPhysicsJointSpring.joint(withBodyA: staticNode.physicsBody!,\n                                        bodyB: dynamicNode.physicsBody!,\n                                        anchorA: staticNode.position,\n                                        anchorB: dynamicNode.position)\n \nspring.frequency = 0.5\nspring.damping = 0.2\n \nscene.physicsWorld.add(spring)\n \nlet move = SKAction.moveBy(x:0, y: 200,\n                           duration: 1)\nstaticNode.run(move)\n"
  },
  {
    "title": "shouldEnableLimits | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointsliding/1520053-shouldenablelimits",
    "html": "Discussion\n\nThe default value is false. If true, then the lowerDistanceLimit and upperDistanceLimit properties are used to limit the distance of the sliding joint.\n\nSee Also\nConfiguring a Sliding Joint\nvar lowerDistanceLimit: CGFloat\nThe smallest distance allowed for the sliding joint.\nvar upperDistanceLimit: CGFloat\nThe largest distance allowed for the sliding joint."
  },
  {
    "title": "lowerDistanceLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointsliding/1519969-lowerdistancelimit",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring a Sliding Joint\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the sliding joint is restricted so that the objects may only slide a finite distance from the initial anchor point.\nvar upperDistanceLimit: CGFloat\nThe largest distance allowed for the sliding joint."
  },
  {
    "title": "reach(to:rootNode:velocity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417801-reach",
    "html": "Parameters\nnode\n\nThe node whose position the current node should move closer to.\n\nroot\n\nThe highest level ancestor of the target node that should be rotated.\n\nvelocity\n\nThe speed that the current node should move at.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.\n\nThe duration of the action is calculated implicitly based on the speed of movement and the distance that the node needs to travel.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nPerforming Inverse Kinematics\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass func reach(to: CGPoint, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: CGPoint, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nRelated Documentation\nPerforming Inverse Kinematics"
  },
  {
    "title": "upperAngleLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointpin/1519967-upperanglelimit",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring a Pin Joint\nvar rotationSpeed: CGFloat\nThe speed, in radians per second, at which the physics bodies are driven around the pin joint.\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the pin joint’s rotation is limited to a specific range of values.\nvar lowerAngleLimit: CGFloat\nThe smallest angle allowed for the pin joint, in radians.\nvar frictionTorque: CGFloat\nThe resistance applied by the pin joint to spinning around the anchor point."
  },
  {
    "title": "upperDistanceLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointsliding/1519836-upperdistancelimit",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring a Sliding Joint\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the sliding joint is restricted so that the objects may only slide a finite distance from the initial anchor point.\nvar lowerDistanceLimit: CGFloat\nThe smallest distance allowed for the sliding joint."
  },
  {
    "title": "follow(_:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417822-follow",
    "html": "Parameters\npath\n\nA Core Graphics path whose coordinates are relative to the node’s current position.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nCalling this method is equivalent to calling the follow(_:asOffset:orientToPath:duration:) method, passing in true to both the offset and orient parameters.\n\nThis action is reversible; the resulting action creates and then follows a reversed path with the same duration.\n\nSee Also\nAnimating a Node's Position Along a Custom Path\nclass func follow(CGPath, speed: CGFloat) -> SKAction\nCreates an action that moves the node along a relative path at a specified speed, orienting the node to the path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, speed: CGFloat) -> SKAction\nCreates an action that moves the node at a specified speed along a path."
  },
  {
    "title": "follow(_:speed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417786-follow",
    "html": "Parameters\npath\n\nA Core Graphics path whose coordinates are relative to the node’s current position.\n\nspeed\n\nThe speed at which the node should move, in points per second.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nCalling this method is equivalent to calling the follow(_:asOffset:orientToPath:speed:) method, passing in true to both the offset and orient parameters.\n\nThis action is reversible; the resulting action creates and then follows a reversed path with the same speed.\n\nSee Also\nAnimating a Node's Position Along a Custom Path\nclass func follow(CGPath, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a relative path, orienting the node to the path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, speed: CGFloat) -> SKAction\nCreates an action that moves the node at a specified speed along a path."
  },
  {
    "title": "SKActionTimingFunction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skactiontimingfunction",
    "html": "Discussion\n\nThe block parameters are defined as follows:\n\ntime\n\nThe input time, where 0.0 represents the start time of the animation and 1.0 represents the end time of the animation.\n\nThe input value will be a value between 0.0 and 1.0, inclusive. The block must also return a value between 0.0 and 1.0. When the input time is 0.0, the output value should be 0.0. When the input time is 1.0, the output value should also be 1.0.\n\nSee Also\nControlling Action Timing\nConfiguring Action Timing\nTime an action in a scene, by adding or modifying timing properties, or cancel an action.\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar timingMode: SKActionTimingMode\nA setting that controls the speed curve of an animation.\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\nvar timingFunction: SKActionTimingFunction\nA block used to customize the timing function.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs."
  },
  {
    "title": "Action Initializers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/action_initializers",
    "html": "Overview\n\nMost actions implement specific predefined animations that are done for you by SpriteKit. If your animation needs fall outside of the suite provided here, then you should:\n\nConsider using Creating Custom Actions (never subclass SKAction)\n\nConsider the advice in Drive Game Logic\n\nChoose an Initializer for the Property You Want to Alter\n\nMost actions allow you to change a node’s properties and some actions specifically apply to specific nodes, like SKSpriteNode's actions for animating its color or texture.\n\nHere are the most common animated properties:\n\nChanging a node’s position and zRotation\n\nChanging a node’s size or scaling properties\n\nChanging a node’s visibility or making it translucent\n\nChanging a sprite node’s contents so that it animates through a series of textures\n\nColorizing a sprite node\n\nPlaying sounds\n\nRemoving a node from the node tree\n\nCalling a block\n\nInvoking a selector on an object\n\nSee Action Initializers for a full list of action types.\n\nChaining Actions\n\nActions can be chained together in multiple ways:\n\nA sequence action has multiple child actions. Each action in the sequence begins after the previous action ends.\n\nA group action has multiple child actions. All actions stored in the group begin executing at the same time.\n\nA repeating action stores a single child action. When the child action completes, it is restarted.\n\nTo delay a subsequent action in the chain, insert a wait(forDuration:) action in the sequence, and remember that groups, sequences, and repeating actions may be nested.\n\nTopics\nAnimating a Node's Position in a Linear Path\nAnimate linear node movement.\nclass func moveBy(x: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(by: CGVector, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that moves a node to a new position.\nclass func moveTo(x: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node horizontally.\nclass func moveTo(y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node vertically.\nAnimating a Node's Position Along a Custom Path\nProvide a path for the node to follow.\nclass func follow(CGPath, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a relative path, orienting the node to the path.\nclass func follow(CGPath, speed: CGFloat) -> SKAction\nCreates an action that moves the node along a relative path at a specified speed, orienting the node to the path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, speed: CGFloat) -> SKAction\nCreates an action that moves the node at a specified speed along a path.\nAnimating the Rotation of a Node\nAnimate the z rotation of a node. If instead you wish to change the x or y rotation of a node, see SKTransformNode.\nclass func rotate(byAngle: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that rotates the node by a relative value.\nclass func rotate(toAngle: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that rotates the node counterclockwise to an absolute angle.\nclass func rotate(toAngle: CGFloat, duration: TimeInterval, shortestUnitArc: Bool) -> SKAction\nCreates an action that rotates the node to an absolute value.\nControlling the Action's Speed\nControl the speed of an animation.\nclass func speed(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes how fast the node executes actions by a relative value.\nclass func speed(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes how fast the node executes actions.\nAnimating the Scaling of a Node\nAnimate the visual scaling of a node.\nclass func scale(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node by a relative value.\nclass func scale(to: CGSize, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node to achieve\nclass func scale(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(by: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adds relative values to the x and y scale values of a node.\nclass func scaleX(to: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x and y scale values of a node.\nclass func scaleX(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the x scale value of a node to a new value.\nclass func scaleY(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the y scale value of a node to a new value.\nAnimating the Transparency of a Node\nGradually change a node's transparency.\nclass func fadeIn(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 1.0.\nclass func fadeOut(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 0.0.\nclass func fadeAlpha(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node by a relative value.\nclass func fadeAlpha(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node to a new value.\nAnimating a Node's Texture\nChange a node's texture or the texture's properties.\nclass func resize(byWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the size of a sprite.\nclass func resize(toHeight: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the height of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width of a sprite to a new absolute value.\nclass func resize(toWidth: CGFloat, height: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that changes the width and height of a sprite to a new absolute value.\nclass func setTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s texture.\nclass func setTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s texture, possibly resizing the sprite.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func animate(with: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture, possibly resizing the sprite.\nclass func setNormalTexture(SKTexture) -> SKAction\nCreates an action that changes a sprite’s normal texture.\nclass func setNormalTexture(SKTexture, resize: Bool) -> SKAction\nCreates an action that changes a sprite’s normal texture, possibly resizing the sprite.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval) -> SKAction\nCreates an action that animates changes to a sprite’s normal texture.\nclass func animate(withNormalTextures: [SKTexture], timePerFrame: TimeInterval, resize: Bool, restore: Bool) -> SKAction\nCreates an action that animates changes to a sprite’s texture.\nclass func colorize(with: UIColor, colorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an animation that animates a sprite’s color and blend factor.\nclass func colorize(withColorBlendFactor: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that animates a sprite’s blend factor.\nAnimating Properties of a Node's Physics Body\nPhysics actions are instantaneous and therefore more useful when Chaining Actions or Reuse Actions.\nclass func applyForce(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to the center of gravity of a node’s physics body.\nclass func applyTorque(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies a torque to a node’s physics body.\nclass func applyForce(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies a force to a specific point on a node’s physics body.\nclass func applyImpulse(CGVector, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to the center of gravity of a physics body.\nclass func applyAngularImpulse(CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that applies an angular impulse to a node’s physics body.\nclass func applyImpulse(CGVector, at: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that applies an impulse to a specific point of a node’s physics body.\nclass func changeCharge(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body to a new value.\nclass func changeCharge(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the charge of a node’s physics body by a relative value.\nclass func changeMass(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body to a new value.\nclass func changeMass(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes the mass of a node’s physics body by a relative value.\nclass func strength(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength.\nclass func strength(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s strength to a value relative to the existing value.\nclass func falloff(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff.\nclass func falloff(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that animates a change of a physics field’s falloff to a value relative to the existing value.\nReversing an Animation\nCreate a new action that is the opposite of another action.\nfunc reversed() -> SKAction\nCreates an action that reverses the behavior of another action.\nAnimate the Warping of a Node\nInterpolate the warping of a node over time.\nclass func animate(withWarps: [SKWarpGeometry], times: [NSNumber]) -> SKAction?\nCreates an action to distort a node through a sequence of SKWarpGeometry objects.\nclass func animate(withWarps: [SKWarpGeometry], times: [NSNumber], restore: Bool) -> SKAction?\nCreates an action to distort a node through a sequence of SKWarpGeometry objects.\nclass func warp(to: SKWarpGeometry, duration: TimeInterval) -> SKAction?\nCreates an action to distort a node based using an SKWarpGeometry object.\nControlling the Audio of a Node\nAudio actions are instantaneous and so, more useful when Chaining Actions or Reuse Actions.\nclass func playSoundFileNamed(String, waitForCompletion: Bool) -> SKAction\nCreates an action that plays a sound.\nclass func play() -> SKAction\nCreates an action that tells an audio node to start playback.\nclass func pause() -> SKAction\nCreates an action that tells an audio node to pause playback.\nclass func stop() -> SKAction\nCreates an action that tells an audio node to stop playback.\nclass func changePlaybackRate(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate to a new value.\nclass func changePlaybackRate(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s playback rate by a relative amount.\nclass func changeVolume(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume to a new value.\nclass func changeVolume(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s volume by a relative value.\nclass func changeObstruction(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction to a new value.\nclass func changeObstruction(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s obstruction by a relative value.\nclass func changeOcclusion(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion to a new value.\nclass func changeOcclusion(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s occlusion by a relative value.\nclass func changeReverb(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb to a new value.\nclass func changeReverb(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s reverb by a relative value.\nclass func stereoPan(to: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning to a new value.\nclass func stereoPan(by: Float, duration: TimeInterval) -> SKAction\nCreates an action that changes an audio node’s stereo panning by a relative value.\nRemoving a Node from the Scene\nInstantaneous action that is useful when Chaining Actions or Reuse Actions.\nclass func removeFromParent() -> SKAction\nCreates an action that removes the node from its parent.\nRunning Actions on Children\nRun an action on a child node by its name.\nclass func run(SKAction, onChildWithName: String) -> SKAction\nCreates an action that runs an action on a named child object.\nChaining Actions\nCreate an action that contains a series, or chain, of other actions.\nclass func group([SKAction]) -> SKAction\nCreates an action that runs a collection of actions in parallel.\nclass func sequence([SKAction]) -> SKAction\nCreates an action that runs a collection of actions sequentially.\nclass func `repeat`(SKAction, count: Int) -> SKAction\nCreates an action that repeats another action a specified number of times.\nclass func repeatForever(SKAction) -> SKAction\nCreates an action that repeats another action forever.\nDelaying Actions\nDelay a subseqent action in a sequence of other actions.\nclass func wait(forDuration: TimeInterval) -> SKAction\nCreates an action that idles for a specified period of time.\nclass func wait(forDuration: TimeInterval, withRange: TimeInterval) -> SKAction\nCreates an action that idles for a randomized period of time.\nPerforming Inverse Kinematics\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass func reach(to: CGPoint, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: CGPoint, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nCreating Custom Actions\nProvide code that implements your own action.\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue.\nControlling Node Visibility\nControl a node's visibility.\nclass func unhide() -> SKAction\nCreates an action that makes a node visible.\nclass func hide() -> SKAction\nCreates an action that hides a node.\nSee Also\nFirst Steps\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit."
  },
  {
    "title": "move(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417739-move",
    "html": "Parameters\ndelta\n\nA vector that describes the change to apply to the node’s position.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet negDelta = CGVector(dx: -deltaX, dy: -deltaY)\nlet action = SKAction.move(by: negDelta, duration: sec)\n\nSee Also\nAnimating a Node's Position in a Linear Path\nclass func moveBy(x: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that moves a node to a new position.\nclass func moveTo(x: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node horizontally.\nclass func moveTo(y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node vertically."
  },
  {
    "title": "destPosition(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/1690944-destposition",
    "html": "Parameters\nindex\n\nThe index of the position vertex to query.\n\nReturn Value\n\nThe normalized position of the specified vertex in destPositions.\n\nDiscussion\n\nThe specified index must be between 0 and the warp geometry grid's vertexCount - 1.\n\nSee Also\nAccessing or Setting Grid Vertices\nfunc replacingByDestinationPositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument destination positions.\nfunc replacingBySourcePositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument source positions.\nfunc sourcePosition(at: Int) -> vector_float2\nReturns the source position of a vertex."
  },
  {
    "title": "moveBy(x:y:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417722-moveby",
    "html": "Parameters\ndeltaX\n\nThe x-value, in points, to add to the node’s position.\n\ndeltaY\n\nThe y-value, in points, to add to the node’s position.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet negDelta = CGVector(dx: -deltaX, dy: -deltaY)\nlet action = SKAction.moveBy(x: -deltaX, y: -deltaX, duration: sec)\n\nSee Also\nAnimating a Node's Position in a Linear Path\nclass func move(by: CGVector, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that moves a node to a new position.\nclass func moveTo(x: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node horizontally.\nclass func moveTo(y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node vertically.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "replacingByDestinationPositions(positions:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/2292355-replacingbydestinationpositions",
    "html": "Return Value\n\nA new warp geometry grid.\n\nSee Also\nAccessing or Setting Grid Vertices\nfunc destPosition(at: Int) -> vector_float2\nReturns the destination position of a vertex.\nfunc replacingBySourcePositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument source positions.\nfunc sourcePosition(at: Int) -> vector_float2\nReturns the source position of a vertex."
  },
  {
    "title": "setValue(_:forAttribute:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1644180-setvalue",
    "html": "Deprecated\n\nAttributes are only available to node classes supporting SKShader, such as SKSpriteNode, SKEffectNode and SKShapeNode.\n\nParameters\nvalue\n\nAn attribute value object containing the scalar or vector value to set in the attached shader.\n\nkey\n\nThe attribute name.\n\nSee Also\nSetting a Node's Unique Attributes for a Shader\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nDeprecated\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute.\nDeprecated"
  },
  {
    "title": "replacingBySourcePositions(positions:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid/2292354-replacingbysourcepositions",
    "html": "Return Value\n\nA new warp geometry grid.\n\nSee Also\nAccessing or Setting Grid Vertices\nfunc destPosition(at: Int) -> vector_float2\nReturns the destination position of a vertex.\nfunc replacingByDestinationPositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument destination positions.\nfunc sourcePosition(at: Int) -> vector_float2\nReturns the source position of a vertex."
  },
  {
    "title": "subdivisionLevels | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpable/1690947-subdivisionlevels",
    "html": "Required"
  },
  {
    "title": "warpGeometry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpable/1690953-warpgeometry",
    "html": "Required"
  },
  {
    "title": "init(tileGroups:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643885-init",
    "html": "Parameters\ntileGroups\n\nAn array of SKTileGroup objects from which to create the tile set from.\n\nReturn Value\n\nA new tile set.\n\nSee Also\nCreating a Tile Set Programmatically\ninit(tileGroups: [SKTileGroup], tileSetType: SKTileSetType)\nInitializes a new tile set with an array of tile groups and specified layout."
  },
  {
    "title": "init(named:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643819-init",
    "html": "Parameters\nname\n\nThe name of the tile set to search for.\n\nReturn Value\n\nA new tile set or nil if a tile set with a matching name cannot be found.\n\nSee Also\nCreating a Tile Set from a File\ninit?(from: URL)\nInitializes a tile set from a URL to an archived .sks file."
  },
  {
    "title": "vectorFloat4Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643442-vectorfloat4value",
    "html": "Discussion\n\nIf the receiver’s original value is a floating-point number of a vector with a count less than four, the empty items in the vector are set to 0."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643830-init",
    "html": "Parameters\nurl\n\nThe URL of a tile set file.\n\nReturn Value\n\nA new tile set or nil if the URL doesn't point to a valid tile set file.\n\nSee Also\nCreating a Tile Set from a File\ninit?(named: String)\nInitializes a tile set by searching the app bundle for an archived .sks file by name."
  },
  {
    "title": "defaultTileSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643889-defaulttilesize",
    "html": "Discussion\n\nThe default tile size an SKTileMapNode will use for its tiles\n\nSee Also\nAccessing or Reading a Tile Set's Properties\nvar defaultTileGroup: SKTileGroup?\nThe tile set's default tile group.\nvar name: String?\nA name associated with the tile set.\nvar tileGroups: [SKTileGroup]\nThe tile set's array of tile group objects.\nvar type: SKTileSetType\nThe tile set's type.\nenum SKTileSetType\nAn enumeration defining how tiles are arranged."
  },
  {
    "title": "SKTileAdjacencyMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileadjacencymask",
    "html": "Topics\nInitializers\ninit(rawValue: UInt)\nType Properties\nstatic var adjacencyAll: SKTileAdjacencyMask\nstatic var adjacencyDown: SKTileAdjacencyMask\nstatic var adjacencyDownEdge: SKTileAdjacencyMask\nstatic var adjacencyLeft: SKTileAdjacencyMask\nstatic var adjacencyLeftEdge: SKTileAdjacencyMask\nstatic var adjacencyLowerLeft: SKTileAdjacencyMask\nstatic var adjacencyLowerLeftCorner: SKTileAdjacencyMask\nstatic var adjacencyLowerLeftEdge: SKTileAdjacencyMask\nstatic var adjacencyLowerRight: SKTileAdjacencyMask\nstatic var adjacencyLowerRightCorner: SKTileAdjacencyMask\nstatic var adjacencyLowerRightEdge: SKTileAdjacencyMask\nstatic var adjacencyRight: SKTileAdjacencyMask\nstatic var adjacencyRightEdge: SKTileAdjacencyMask\nstatic var adjacencyUp: SKTileAdjacencyMask\nstatic var adjacencyUpEdge: SKTileAdjacencyMask\nstatic var adjacencyUpperLeft: SKTileAdjacencyMask\nstatic var adjacencyUpperLeftCorner: SKTileAdjacencyMask\nstatic var adjacencyUpperLeftEdge: SKTileAdjacencyMask\nstatic var adjacencyUpperRight: SKTileAdjacencyMask\nstatic var adjacencyUpperRightCorner: SKTileAdjacencyMask\nstatic var adjacencyUpperRightEdge: SKTileAdjacencyMask\nstatic var hexFlatAdjacencyAll: SKTileAdjacencyMask\nstatic var hexFlatAdjacencyDown: SKTileAdjacencyMask\nstatic var hexFlatAdjacencyLowerLeft: SKTileAdjacencyMask\nstatic var hexFlatAdjacencyLowerRight: SKTileAdjacencyMask\nstatic var hexFlatAdjacencyUp: SKTileAdjacencyMask\nstatic var hexFlatAdjacencyUpperLeft: SKTileAdjacencyMask\nstatic var hexFlatAdjacencyUpperRight: SKTileAdjacencyMask\nstatic var hexPointyAdjacencyAdd: SKTileAdjacencyMask\nstatic var hexPointyAdjacencyLeft: SKTileAdjacencyMask\nstatic var hexPointyAdjacencyLowerLeft: SKTileAdjacencyMask\nstatic var hexPointyAdjacencyLowerRight: SKTileAdjacencyMask\nstatic var hexPointyAdjacencyRight: SKTileAdjacencyMask\nstatic var hexPointyAdjacencyUpperLeft: SKTileAdjacencyMask\nstatic var hexPointyAdjacencyUpperRight: SKTileAdjacencyMask\nRelationships\nConforms To\nOptionSet\nSendable\nSee Also\nAccessing or Setting Tile Group Rule Properties\nvar adjacency: SKTileAdjacencyMask\nThe adjacency requirement for this rule.\nvar name: String?\nA name associated with the tile group rule.\nvar tileDefinitions: [SKTileDefinition]\nThe tile definitions used for this rule."
  },
  {
    "title": "defaultTileGroup | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643878-defaulttilegroup",
    "html": "Discussion\n\nWith auto-mapping enabled, it is possible for some tiles to be removed because there is either no valid rule or a missing tile group for the required adjacency rule. In this situation, those tiles are replaced by the tile group specified by defaultTileGroup.\n\nSee Also\nAccessing or Reading a Tile Set's Properties\nvar defaultTileSize: CGSize\nThe tile set's default tile size.\nvar name: String?\nA name associated with the tile set.\nvar tileGroups: [SKTileGroup]\nThe tile set's array of tile group objects.\nvar type: SKTileSetType\nThe tile set's type.\nenum SKTileSetType\nAn enumeration defining how tiles are arranged."
  },
  {
    "title": "tileGroups | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643874-tilegroups",
    "html": "See Also\nAccessing or Reading a Tile Set's Properties\nvar defaultTileGroup: SKTileGroup?\nThe tile set's default tile group.\nvar defaultTileSize: CGSize\nThe tile set's default tile size.\nvar name: String?\nA name associated with the tile set.\nvar type: SKTileSetType\nThe tile set's type.\nenum SKTileSetType\nAn enumeration defining how tiles are arranged."
  },
  {
    "title": "obstacles(fromNodeBounds:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483132-obstacles",
    "html": "Parameters\nnodes\n\nAn array of SKNode objects.\n\nReturn Value\n\nAn array of GKPolygonObstacle objects.\n\nDiscussion\n\nUse the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.\n\nSee Also\nAdding GameplayKit Behaviors\nvar entity: GKEntity?\nThe GameplayKit entity this node represents.\nclass func obstacles(fromNodePhysicsBodies: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming the node’s physics body shape into the scene’s coordinate system.\nclass func obstacles(fromSpriteTextures: [SKNode], accuracy: Float) -> [GKPolygonObstacle]\nTurns each node into an obstacle by changing the node’s texture into a physics shape and converting it into the scene’s coordinate system."
  },
  {
    "title": "adjacency | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegrouprule/1643818-adjacency",
    "html": "See Also\nAccessing or Setting Tile Group Rule Properties\nstruct SKTileAdjacencyMask\nAn enumeration defining how neighboring tiles are automatically placed next to each other.\nvar name: String?\nA name associated with the tile group rule.\nvar tileDefinitions: [SKTileDefinition]\nThe tile definitions used for this rule."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset/1643888-name",
    "html": "See Also\nAccessing or Reading a Tile Set's Properties\nvar defaultTileGroup: SKTileGroup?\nThe tile set's default tile group.\nvar defaultTileSize: CGSize\nThe tile set's default tile size.\nvar tileGroups: [SKTileGroup]\nThe tile set's array of tile group objects.\nvar type: SKTileSetType\nThe tile set's type.\nenum SKTileSetType\nAn enumeration defining how tiles are arranged."
  },
  {
    "title": "init(adjacency:tileDefinitions:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegrouprule/1643837-init",
    "html": "Parameters\nadjacency\n\nThe adjacency requirements for this rule.\n\ntileDefinitions\n\nThe tile definitions used for this rule.\n\nReturn Value\n\nA new tile group rule."
  },
  {
    "title": "Connecting Bodies with Joints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjoint/connecting_bodies_with_joints",
    "html": "Overview\n\nAlthough you can make a lot of interesting games that use the physics systems already described, you can take your designs further by connecting physics bodies using joints. When the scene simulates the physics, it takes these joints into account when calculating how forces affect the bodies. The following illustration shows the types of joints you can use.\n\nYou add or remove joints using the physics world. When you create a joint, the points that connect the joint are always specified in the scene’s coordinate system. This may require you to first convert from node coordinates to scene coordinates before creating the joint.\n\nAdd a Joint to Nodes in Your Scene\n\nTo use a physics joint in your app, follow these steps:\n\nCreate two physics bodies.\n\nAttach the physics bodies to a pair of SKNode objects in the scene.\n\nCreate a joint object using one of the types shown above.\n\nIf necessary, configure the joint object’s properties to define how the joint should operate.\n\nRetrieve the scene’s SKPhysicsWorld object.\n\nCall the physics world’s add(_:) method.\n\nImportant\n\nThe anchor arguments passed to physics joint initializers are always in the parent scene’s coordinate space. You can use the convert(_:to:) method to calculate a node’s position in scene coordinates if that node is not an immediate child of the scene.\n\nThe following code pins two nodes, pin and piston, together using a SKPhysicsJointPin joint. In this example, the node pin is a child of connectingRod. Because it is not an immediate child of the scene, its coordinates are converted to scene coordinates for use in initializing the joint.\n\nlet pinPosition = connectingRod.convert(pin.position,\n                                         to: scene)\nlet pinJoint = SKPhysicsJointPin.joint(withBodyA: pin.physicsBody!,\n                                        bodyB: piston.physicsBody!,\n                                        anchor: pinPosition)\nscene.physicsWorld.add(pinJoint)\n"
  },
  {
    "title": "Creating a Scene from a File | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/creating_a_scene_from_a_file",
    "html": "Overview\n\nThe most common way to load an SKScene is through an .sks file configured in Xcode's scene editor. Making your base changes in the editor is faster than writing equivalent initalization code, and it avoids repeating code if you create a scene in multiple places.\n\nCreate a New Scene File\n\nFirst, add a new scene file to your project through Xcode's File menu > New... > File > (choose your platform tab) > SpriteKit Scene.\n\nFigure 1 Creating a new SpriteKit Scene file\n\nConfigure the Scene Using the Editor\n\nYou configure your scene in the scene editor by clicking on the .sks file in Xcode's file navigator pane, then adjusting properties in the Utility pane. For example, to set your scene's background color, follow the steps highlighted in Figure 2:\n\nSelect the .sks file in the file navigator pane.\n\nOpen the Utilities pane.\n\nChoose the Attributes inspector.\n\nDefine a color under Scene.\n\nFigure 2 Setting the background color in the scene editor\n\nLoad the Scene in Code\n\nLoad the newly configured scene file in code using init(fileNamed:).\n\nlet scene = SKScene(fileNamed: \"MyScene\")\n        \n// Now present the scene in a view.\nskView.presentScene(scene)\n\n\nNote\n\nThe .sks file extension is left out of the String name argument to init(fileNamed:)."
  },
  {
    "title": "SKSceneScaleMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenescalemode",
    "html": "Topics\nConstants\ncase fill\nEach axis of the scene is scaled independently so that each axis in the scene exactly maps to the length of that axis in the view.\ncase aspectFill\nThe scaling factor of each dimension is calculated and the larger of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire area of the view is filled but may cause parts of the scene to be cropped.\ncase aspectFit\nThe scaling factor of each dimension is calculated and the smaller of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire scene is visible but may require letterboxing in the view.\ncase resizeFill\nThe scene is not scaled to match the view. Instead, the scene is automatically resized so that its dimensions always match those of the view.\nRelationships\nConforms To\nSendable\nSee Also\nStretching Content to Fit the View\nScaling a Scene's Content to Fit the View\nConfigure the scale mode to determine how a scene is sized to fit its view.\nvar scaleMode: SKSceneScaleMode\nA setting that defines how the scene is mapped to the view that presents it."
  },
  {
    "title": "init(name:float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455447-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nvalue\n\nThe initial floating-point value for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.float.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "init(name:float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455444-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nvalue\n\nThe initial vector for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.floatVector2.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "init(name:float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455416-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nvalue\n\nThe initial vector for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.floatVector3.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "init(name:float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455418-init",
    "html": "Parameters\nname\n\nThe name used to identify the uniform variable; you use this name inside your shader to read the uniform variable’s value.\n\nvalue\n\nThe initial vector for the uniform variable.\n\nReturn Value\n\nAn initialized uniform object whose type is set to SKUniformType.floatVector4.\n\nSee Also\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture."
  },
  {
    "title": "floatVector3Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455434-floatvector3value",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture."
  },
  {
    "title": "floatVector4Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455404-floatvector4value",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture."
  },
  {
    "title": "floatMatrix2Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455410-floatmatrix2value",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture."
  },
  {
    "title": "floatMatrix3Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455438-floatmatrix3value",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture."
  },
  {
    "title": "floatMatrix4Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform/1455460-floatmatrix4value",
    "html": "See Also\nReading and Writing an Uniform Object’s Value\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture."
  },
  {
    "title": "collisionImpulse | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontact/1478523-collisionimpulse",
    "html": "See Also\nInspecting the Contact Properties\nvar bodyA: SKPhysicsBody\nThe first body in the contact.\nvar bodyB: SKPhysicsBody\nThe second body in the contact.\nvar contactPoint: CGPoint\nThe contact point between the two physics bodies, in scene coordinates.\nvar contactNormal: CGVector\nThe normal vector specifying the direction of the collision."
  },
  {
    "title": "angularVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519766-angularvelocity",
    "html": "Discussion\n\nThe angular velocity is a pseudo vector around an axis vector of (0.0,0.0,1.0) measured in radians per second.\n\nSee Also\nInspecting a Physics Body’s Position and Velocity\nvar velocity: CGVector\nThe physics body’s velocity vector, measured in meters per second.\nvar isResting: Bool\nA Boolean property that indicates whether the object is at rest within the physics simulation."
  },
  {
    "title": "interpolationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390914-interpolationmode",
    "html": "Discussion\n\nThe possible values are defined in SKInterpolationMode. The default value is SKInterpolationMode.linear.\n\nSee Also\nInterpolation Modifiers\nvar repeatMode: SKRepeatMode\nThe mode used to determine how the keyframe sequence repeats."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegrouprule/1643860-name",
    "html": "See Also\nAccessing or Setting Tile Group Rule Properties\nvar adjacency: SKTileAdjacencyMask\nThe adjacency requirement for this rule.\nstruct SKTileAdjacencyMask\nAn enumeration defining how neighboring tiles are automatically placed next to each other.\nvar tileDefinitions: [SKTileDefinition]\nThe tile definitions used for this rule."
  },
  {
    "title": "tileDefinitions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegrouprule/1643823-tiledefinitions",
    "html": "Discussion\n\nWhen this rule is evaluated and its conditions met, one of the definitions is randomly selected for placement based on their placement weights.\n\nSee Also\nAccessing or Setting Tile Group Rule Properties\nvar adjacency: SKTileAdjacencyMask\nThe adjacency requirement for this rule.\nstruct SKTileAdjacencyMask\nAn enumeration defining how neighboring tiles are automatically placed next to each other.\nvar name: String?\nA name associated with the tile group rule."
  },
  {
    "title": "joint(withBodyA:bodyB:anchorA:anchorB:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointspring/1519665-joint",
    "html": "Parameters\nbodyA\n\nThe first body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nbodyB\n\nThe second body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nanchorA\n\nThe connection point on the first body in the scene’s coordinate system.\n\nanchorB\n\nThe connection point on the second body in the scene’s coordinate system.\n\nReturn Value\n\nA new spring joint.\n\nDiscussion\n\nYou must add the joint to a physics world associated with the scene before it takes effect.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "damping | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointspring/1519709-damping",
    "html": "Discussion\n\nThe default value is 0.0. Increasing the value increases the energy loss with each oscillation: there will be fewer and smaller oscillations and time taken for the spring to settle will decrease.\n\nSee Also\nConfiguring a Spring Joint\nvar frequency: CGFloat\nDefines the frequency or stiffness characteristics of the spring."
  },
  {
    "title": "frequency | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointspring/1519806-frequency",
    "html": "Discussion\n\nThe default value is 0.0, creating a rigid joint between the spring's two bodies. Setting the frequency to a low value, for example 0.5, creates a spring with slow oscillations that will settle slowly. Setting the frequency to a high value, for example 10.0, creates a stiffer spring with faster and fewer oscillations.\n\nSee Also\nConfiguring a Spring Joint\nvar damping: CGFloat\nDefines how the spring’s motion should be damped due to the forces of friction."
  },
  {
    "title": "joint(withBodyA:bodyB:anchor:axis:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointsliding/1520333-joint",
    "html": "Parameters\nbodyA\n\nThe first body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nbodyB\n\nThe second body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nanchor\n\nThe anchor point for the connection in the scene’s coordinate system.\n\naxis\n\nA vector that defines the direction that the joint is allowed to slide.\n\nReturn Value\n\nA new sliding joint.\n\nDiscussion\n\nYou must add the joint to a physics world associated with the scene before it takes effect.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "joint(withBodyA:bodyB:anchor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointpin/1519698-joint",
    "html": "Parameters\nbodyA\n\nThe first body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nbodyB\n\nThe second body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nanchor\n\nThe connection point between the two bodies in the scene’s coordinate system.\n\nReturn Value\n\nA new pin joint.\n\nDiscussion\n\nYou must add the joint to a physics world associated with the scene before it takes effect.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "lowerAngleLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointpin/1520130-loweranglelimit",
    "html": "Discussion\n\nThe default value is 0.0.\n\nSee Also\nConfiguring a Pin Joint\nvar rotationSpeed: CGFloat\nThe speed, in radians per second, at which the physics bodies are driven around the pin joint.\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the pin joint’s rotation is limited to a specific range of values.\nvar upperAngleLimit: CGFloat\nThe largest angle allowed for the pin joint, in radians.\nvar frictionTorque: CGFloat\nThe resistance applied by the pin joint to spinning around the anchor point."
  },
  {
    "title": "shouldEnableLimits | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointpin/1520292-shouldenablelimits",
    "html": "Discussion\n\nThe default value is false. If true, the lowerAngleLimit and upperAngleLimit properties are used to limit the angle of the pin joint.\n\nSee Also\nConfiguring a Pin Joint\nvar rotationSpeed: CGFloat\nThe speed, in radians per second, at which the physics bodies are driven around the pin joint.\nvar lowerAngleLimit: CGFloat\nThe smallest angle allowed for the pin joint, in radians.\nvar upperAngleLimit: CGFloat\nThe largest angle allowed for the pin joint, in radians.\nvar frictionTorque: CGFloat\nThe resistance applied by the pin joint to spinning around the anchor point."
  },
  {
    "title": "frictionTorque | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointpin/1520299-frictiontorque",
    "html": "Discussion\n\nThe range of values is from 0.0 to 1.0. The default value is 0.0. If a value greater than the default is specified, friction is applied to reduce the object’s angular velocity around the pin.\n\nSee Also\nConfiguring a Pin Joint\nvar rotationSpeed: CGFloat\nThe speed, in radians per second, at which the physics bodies are driven around the pin joint.\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the pin joint’s rotation is limited to a specific range of values.\nvar lowerAngleLimit: CGFloat\nThe smallest angle allowed for the pin joint, in radians.\nvar upperAngleLimit: CGFloat\nThe largest angle allowed for the pin joint, in radians."
  },
  {
    "title": "group(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417688-group",
    "html": "Parameters\nactions\n\nAn array of SKAction objects.\n\nReturn Value\n\nA group action object.\n\nDiscussion\n\nWhen the action executes, the actions that comprise the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes, then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.\n\nThis action is reversible; it creates a new group action that contains the reverse of each action specified in the group.\n\nSee Also\nChaining Actions\nclass func sequence([SKAction]) -> SKAction\nCreates an action that runs a collection of actions sequentially.\nclass func `repeat`(SKAction, count: Int) -> SKAction\nCreates an action that repeats another action a specified number of times.\nclass func repeatForever(SKAction) -> SKAction\nCreates an action that repeats another action forever."
  },
  {
    "title": "sequence(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417817-sequence",
    "html": "Parameters\nactions\n\nAn array of SKAction objects.\n\nReturn Value\n\nA sequence action object.\n\nDiscussion\n\nWhen the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.\n\nThis action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, if an action sequence is {1,2,3}, the reversed sequence would be {3R,2R,1R}.\n\nSee Also\nChaining Actions\nclass func group([SKAction]) -> SKAction\nCreates an action that runs a collection of actions in parallel.\nclass func `repeat`(SKAction, count: Int) -> SKAction\nCreates an action that repeats another action a specified number of times.\nclass func repeatForever(SKAction) -> SKAction\nCreates an action that repeats another action forever."
  },
  {
    "title": "repeatForever(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417676-repeatforever",
    "html": "Parameters\naction\n\nThe action to execute.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the associated action runs to completion and then repeats.\n\nThis action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.\n\nNote\n\nThe action to be repeated must have a non-instantaneous duration.\n\nSee Also\nChaining Actions\nclass func group([SKAction]) -> SKAction\nCreates an action that runs a collection of actions in parallel.\nclass func sequence([SKAction]) -> SKAction\nCreates an action that runs a collection of actions sequentially.\nclass func `repeat`(SKAction, count: Int) -> SKAction\nCreates an action that repeats another action a specified number of times."
  },
  {
    "title": "repeat(_:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417750-repeat",
    "html": "Parameters\naction\n\nThe action to execute.\n\ncount\n\nThe number of times to execute the action.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the associated action runs to completion and then repeats, until the count is reached.\n\nThis action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.\n\nSee Also\nChaining Actions\nclass func group([SKAction]) -> SKAction\nCreates an action that runs a collection of actions in parallel.\nclass func sequence([SKAction]) -> SKAction\nCreates an action that runs a collection of actions sequentially.\nclass func repeatForever(SKAction) -> SKAction\nCreates an action that repeats another action forever."
  },
  {
    "title": "reach(to:rootNode:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417773-reach",
    "html": "Parameters\nposition\n\nThe intended destination for the node, specified in the scene’s coordinate system.\n\nroot\n\nThe highest level ancestor of the target node that should be rotated.\n\nsec\n\nThe length of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nPerforming Inverse Kinematics\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass func reach(to: CGPoint, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nRelated Documentation\nPerforming Inverse Kinematics"
  },
  {
    "title": "wait(forDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417788-wait",
    "html": "Parameters\nsec\n\nThe amount of time to wait.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nDelaying Actions\nclass func wait(forDuration: TimeInterval, withRange: TimeInterval) -> SKAction\nCreates an action that idles for a randomized period of time."
  },
  {
    "title": "reach(to:rootNode:velocity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417720-reach",
    "html": "Parameters\nposition\n\nThe intended destination for the node, specified in the scene’s coordinate system.\n\nroot\n\nThe highest level ancestor of the target node that should be rotated.\n\nvelocity\n\nThe maximum speed at which the node should move.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.\n\nThe duration of the action is calculated implicitly based on the speed of movement and the distance that the node needs to travel.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nPerforming Inverse Kinematics\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass func reach(to: CGPoint, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nRelated Documentation\nPerforming Inverse Kinematics"
  },
  {
    "title": "wait(forDuration:withRange:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417760-wait",
    "html": "Parameters\nsec\n\nThe average amount of time to wait.\n\ndurationRange\n\nThe range of possible values for the duration.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.\n\nEach time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nDelaying Actions\nclass func wait(forDuration: TimeInterval) -> SKAction\nCreates an action that idles for a specified period of time."
  },
  {
    "title": "reach(to:rootNode:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417827-reach",
    "html": "Parameters\nnode\n\nThe node whose position the current node should move closer to.\n\nroot\n\nThe highest level ancestor of the target node that should be rotated.\n\nsec\n\nThe length of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThis action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nPerforming Inverse Kinematics\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass func reach(to: CGPoint, rootNode: SKNode, duration: TimeInterval) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: CGPoint, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nclass func reach(to: SKNode, rootNode: SKNode, velocity: CGFloat) -> SKAction\nCreates an action that performs an inverse kinematic reach.\nRelated Documentation\nPerforming Inverse Kinematics"
  },
  {
    "title": "hide() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417704-hide",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nThis action has an instantaneous duration. When the action executes, the node’s isHidden property is set to true.\n\nThis action is reversible; the reversed action shows the node.\n\nSee Also\nControlling Node Visibility\nclass func unhide() -> SKAction\nCreates an action that makes a node visible."
  },
  {
    "title": "customAction(withDuration:actionBlock:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417745-customaction",
    "html": "Parameters\nseconds\n\nThe duration of the action, in seconds.\n\nblock\n\nThe block to run. The block takes the following parameters:\n\nnode\n\nThe node on which the action is running.\n\nelapsedTime\n\nThe amount of time that has passed in the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the block is called repeatedly until the action’s duration expires. The elapsed time is computed and passed to the block whenever the block is called.\n\nThis action is not reversible; the reverse action executes the same block.\n\nThe following code shows how you can create a custom action to update an attribute of an SKShader attached to a sprite node.\n\nlet customAction = SKAction.customAction(withDuration: 2.0) {\n    node, elapsedTime in\n    \n    if let node = node as? SKSpriteNode {\n        node.setValue(SKAttributeValue(float: Float(elapsedTime)),\n                                       forAttribute: \"a_time\")\n    }\n}\n\n\nSee Also\nCreating Custom Actions\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue."
  },
  {
    "title": "init(named:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417814-init",
    "html": "Parameters\nname\n\nThe name of the action.\n\nReturn Value\n\nA new action object.\n\nSee Also\nCreating Custom Actions\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue."
  },
  {
    "title": "perform(_:onTarget:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417764-perform",
    "html": "Parameters\nselector\n\nThe selector of the method to call.\n\ntarget\n\nThe target object.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nThe action object maintains a strong reference to the target object.\n\nWhen the action executes, the target object’s method is called. This action occurs instantaneously.\n\nThis action is not reversible; the reverse of this action calls the selector again.\n\nSee Also\nCreating Custom Actions\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue."
  },
  {
    "title": "run(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417692-run",
    "html": "Parameters\nblock\n\nThe block to run.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the block is called. This action takes place instantaneously.\n\nThis action is not reversible; the reverse action executes the same block.\n\nSee Also\nCreating Custom Actions\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue."
  },
  {
    "title": "run(_:queue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417799-run",
    "html": "Parameters\nblock\n\nThe block to run.\n\nqueue\n\nThe queue to perform the action on.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the block is called. This action takes place instantaneously.\n\nThis action is not reversible; the reverse action executes the same block.\n\nSee Also\nCreating Custom Actions\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block."
  },
  {
    "title": "unhide() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417660-unhide",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nThis action has an instantaneous duration. When the action executes, the node’s isHidden property is set to false.\n\nThis action is reversible; the reversed action hides the node.\n\nSee Also\nControlling Node Visibility\nclass func hide() -> SKAction\nCreates an action that hides a node."
  },
  {
    "title": "Configuring Action Timing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/configuring_action_timing",
    "html": "Overview\n\nBy default, an action with a duration applies its changes linearly over the duration you specify. However, you can adjust the timing of actions.\n\nAdd or Change Properties to Adjust the Timing of an Action\n\nThese options are available:\n\nUse an action’s timingMode property to choose a nonlinear timing mode for an animation. For example, you can have the action start quickly and then slow down over the remainder of the run (see SKActionTimingMode).\n\nCreate a custom timing function if you want finer control over an action's timing. See timingFunction.\n\nSpeed up or slow down an animation from its default timing using an action’s speed property, which changes the rate at which an animation plays. A speed value of 1.0 is the normal rate, but if you set an action’s speed property to, for example, 2.0, SpriteKit plays the animation twice as fast. To pause the action, set the speed to 0. If you adjust the speed of an action that contains other actions (such as a group, sequence, or repeating action), the rate is applied to the actions contained within. The contained actions are also affected by their own speed property.\n\nNote\n\nA node’s speed property has the same effect as the action’s speed property, but the rate is applied to all actions processed by the node or any of its descendants in the scene tree.\n\nBecause there are multiple rates involved in an animation's speed, SpriteKit finds all the rates that apply to the action and multiplies them to determine the final rate.\n\nCancel Actions that Should Be Stopped\n\nTo cancel actions that a node is running, call its removeAllActions() method. All actions are removed from the node immediately. If a removed action had a duration, any changes it already made to the node remain intact, but further changes are not executed.\n\nSee Also\nControlling Action Timing\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar timingMode: SKActionTimingMode\nA setting that controls the speed curve of an animation.\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\nvar timingFunction: SKActionTimingFunction\nA block used to customize the timing function.\ntypealias SKActionTimingFunction\nThe signature for the custom timing block.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs."
  },
  {
    "title": "SKActionTimingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skactiontimingmode",
    "html": "Topics\nConstants\ncase linear\nSpecifies linear pacing. Linear pacing causes an animation to occur evenly over its duration.\ncase easeIn\nSpecifies ease-in pacing. Ease-in pacing causes the animation to begin slowly and then speed up as it progresses.\ncase easeOut\nSpecifies ease-out pacing. Ease-out pacing causes the animation to begin quickly and then slow as it completes.\ncase easeInEaseOut\nSpecifies ease-in ease-out pacing. An ease-in ease-out animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.\nRelationships\nConforms To\nSendable\nSee Also\nControlling Action Timing\nConfiguring Action Timing\nTime an action in a scene, by adding or modifying timing properties, or cancel an action.\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar timingMode: SKActionTimingMode\nA setting that controls the speed curve of an animation.\nvar timingFunction: SKActionTimingFunction\nA block used to customize the timing function.\ntypealias SKActionTimingFunction\nThe signature for the custom timing block.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs."
  },
  {
    "title": "follow(_:asOffset:orientToPath:speed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417798-follow",
    "html": "Parameters\npath\n\nA path to follow.\n\noffset\n\nIf true, the points in the path are relative offsets to the node’s starting position. If false, the points in the node are absolute coordinate values.\n\norient\n\nIf true, the node’s zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.\n\nspeed\n\nThe speed at which the node should move, in points per second.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position and zRotation properties are animated along the provided path. The duration of the action is determined by the length of the path and the speed of the node.\n\nThis action is reversible; the resulting action creates a reversed path and then follows it, with the same speed.\n\nSee Also\nAnimating a Node's Position Along a Custom Path\nclass func follow(CGPath, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a relative path, orienting the node to the path.\nclass func follow(CGPath, speed: CGFloat) -> SKAction\nCreates an action that moves the node along a relative path at a specified speed, orienting the node to the path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a path."
  },
  {
    "title": "follow(_:asOffset:orientToPath:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417662-follow",
    "html": "Parameters\npath\n\nA path to follow.\n\noffset\n\nIf true, the points in the path are relative offsets to the node’s starting position. If false, the points in the node are absolute coordinate values.\n\norient\n\nIf true, the node’s zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position and zRotation properties are animated along the provided path.\n\nThis action is reversible; the resulting action creates a reversed path and then follows it, with the same duration.\n\nSee Also\nAnimating a Node's Position Along a Custom Path\nclass func follow(CGPath, duration: TimeInterval) -> SKAction\nCreates an action that moves the node along a relative path, orienting the node to the path.\nclass func follow(CGPath, speed: CGFloat) -> SKAction\nCreates an action that moves the node along a relative path at a specified speed, orienting the node to the path.\nclass func follow(CGPath, asOffset: Bool, orientToPath: Bool, speed: CGFloat) -> SKAction\nCreates an action that moves the node at a specified speed along a path."
  },
  {
    "title": "Detecting Changes at Each Step of an Animation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/detecting_changes_at_each_step_of_an_animation",
    "html": "Overview\n\nGenerally, actions do not call public methods on nodes. For example, if you want to subclass SKNode to respond to a move(to:duration:) action, you might consider overriding its position property to add a didSet observer (see Overriding Property Observers).\n\nclass MovingNode: SKSpriteNode {\n    override var position: CGPoint {\n        didSet {\n            // code to react to position change\n        }\n    }\n}\n\n\nHowever, because a move action that's running on an instance of MovingNode (defined in the code listing above) doesn't set its position, the observer isn't invoked and thus, your code is never executed.\n\nIn this case, the solution is to use SKSceneDelegate and compare the node's position across two of its callbacks. You save the node's initial position in update(_:for:), which is called at the beginning of each frame, then calculate any change in position in didEvaluateActions(for:), which is called after actions have been evaluated.\n\nThe following code demonstrates an example of this strategy:\n\nlet node = SKNode()\nvar nodePosition = CGPoint()\n     \nfunc update(_ currentTime: TimeInterval, for scene: SKScene) {\n    nodePosition = node.position\n}\n     \nfunc didEvaluateActions(for scene: SKScene) {\n    let distance = hypot(node.position.x - nodePosition.x,\n                         node.position.y - nodePosition.y)\n    \n    if distance > 0 {\n        // code to react to position change\n    }\n}\n"
  },
  {
    "title": "Controlling Actions Precisely by Using Names | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/controlling_actions_precisely_by_using_names",
    "html": "Overview\n\nNormally, you can’t see which actions a node is executing, and if you want to remove actions, you must remove all of them. If you need to see whether a particular action is executing, or if you want to remove a specific action, use named actions. A named action is characterized by a unique string that identifies the action. Using named actions, you can start, remove, find and replace the actions of a node.\n\nCreate and Run a Named Action\n\nThe following code creates and runs a new action identified with the ignition key.\n\nlet moveNodeUp = SKAction.moveBy(x: 0.0,\n                                 y: 100.0,\n                                 duration: 1.0)\nrocketNode.run(moveNodeUp,\n               withKey: \"ignition\")\n\n\nThe following key-based methods are available:\n\nrun(_:withKey:) method to run the action. If an action with the same key is already executing, it is removed before the new action is added.\n\naction(forKey:) method to determine if an action with that key is already running.\n\nremoveAction(forKey:) method to remove the action.\n\nFind and Replace an In-Flight Action\n\nThe code below shows how you use a name to replace an action that's currently running. The code determines where a mouse click occurred and then runs an action that moves a sprite to the click location. The action duration is calculated ahead of time to move the sprite at a fixed speed. Because this code uses run(_:withKey:), any previous move that's still executing is stopped and replaced by the new action with the same name.\n\noverride func mouseDown(with event: NSEvent) {\n\tguard let playerNodeParent = self.playerNode.parent else { return }\n\n\n\tlet clickPoint = event.location(in: playerNodeParent)\n\n\n\tlet charPos = playerNode.position\n\n\n\tlet distance = hypot(clickPoint.x-charPos.x, \n\t\tclickPoint.y-charPos.y)\n\n\n\tlet moveToClick = SKAction.move(to: clickPoint, \n\t\tduration: TimeInterval(distance / characterSpeed))\n\n\n\tself.playerNode.run(moveToClick, withKey: \"moveToClick\")\n}\n"
  },
  {
    "title": "moveTo(y:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417781-moveto",
    "html": "Parameters\ny\n\nThe y-value for the node’s new position.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is not reversible; the reverse of this action has the same duration but does not move the node.\n\nSee Also\nAnimating a Node's Position in a Linear Path\nclass func moveBy(x: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(by: CGVector, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that moves a node to a new position.\nclass func moveTo(x: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node horizontally."
  },
  {
    "title": "move(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417768-move",
    "html": "Parameters\nlocation\n\nThe coordinates for the node’s new position.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is not reversible; the reverse of this action has the same duration but does not move the node.\n\nSee Also\nAnimating a Node's Position in a Linear Path\nclass func moveBy(x: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(by: CGVector, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func moveTo(x: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node horizontally.\nclass func moveTo(y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node vertically."
  },
  {
    "title": "moveTo(x:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417779-moveto",
    "html": "Parameters\nx\n\nThe x-value for the node’s new position.\n\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is not reversible; the reverse of this action has the same duration but does not move the node.\n\nSee Also\nAnimating a Node's Position in a Linear Path\nclass func moveBy(x: CGFloat, y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(by: CGVector, duration: TimeInterval) -> SKAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: CGPoint, duration: TimeInterval) -> SKAction\nCreates an action that moves a node to a new position.\nclass func moveTo(y: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that moves a node vertically."
  },
  {
    "title": "setKeyframeTime(_:for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390924-setkeyframetime",
    "html": "Parameters\ntime\n\nThe new time value for the keyframe.\n\nindex\n\nThe index of the keyframe to change.\n\nSee Also\nSequence Building\nfunc addKeyframeValue(Any, time: CGFloat)\nAdds a keyframe to the sequence.\nfunc removeKeyframe(at: Int)\nRemoves a keyframe from the sequence.\nfunc removeLastKeyframe()\nRemoves the last value in the sequence.\nfunc setKeyframeValue(Any, for: Int)\nChanges the value for a specific keyframe.\nfunc setKeyframeValue(Any, time: CGFloat, for: Int)\nReplaces a keyframe in the sequence with a new keyframe."
  },
  {
    "title": "init(vectorFloat4:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643436-init",
    "html": "Parameters\nvalue\n\nThe vector of four point values for the new attribute value.\n\nReturn Value\n\nA new attribute value object."
  },
  {
    "title": "init(float:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643428-init",
    "html": "Parameters\nvalue\n\nThe floating point value for the new attribute value.\n\nReturn Value\n\nA new attribute value object."
  },
  {
    "title": "init(vectorFloat2:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643427-init",
    "html": "Parameters\nvalue\n\nThe vector of two point values for the new attribute value.\n\nReturn Value\n\nA new attribute value object."
  },
  {
    "title": "init(vectorFloat3:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643421-init",
    "html": "Parameters\nvalue\n\nThe vector of three point values for the new attribute value.\n\nReturn Value\n\nA new attribute value object."
  },
  {
    "title": "floatValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643424-floatvalue",
    "html": "Discussion\n\nIf the receiver’s original value is a vector, floatValue is the first element of the vector."
  },
  {
    "title": "vectorFloat2Value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue/1643435-vectorfloat2value",
    "html": "Discussion\n\nIf the receiver’s original value is a floating-point number, the second item of the vector is set to 0. If the receiver’s original value is a vector of more than two items, the additional items are truncated."
  },
  {
    "title": "removeLastKeyframe() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390912-removelastkeyframe",
    "html": "See Also\nSequence Building\nfunc addKeyframeValue(Any, time: CGFloat)\nAdds a keyframe to the sequence.\nfunc removeKeyframe(at: Int)\nRemoves a keyframe from the sequence.\nfunc setKeyframeTime(CGFloat, for: Int)\nChanges the time for a specific keyframe.\nfunc setKeyframeValue(Any, for: Int)\nChanges the value for a specific keyframe.\nfunc setKeyframeValue(Any, time: CGFloat, for: Int)\nReplaces a keyframe in the sequence with a new keyframe."
  },
  {
    "title": "removeKeyframe(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390920-removekeyframe",
    "html": "Parameters\nindex\n\nThe index of the keyframe value to remove.\n\nSee Also\nSequence Building\nfunc addKeyframeValue(Any, time: CGFloat)\nAdds a keyframe to the sequence.\nfunc removeLastKeyframe()\nRemoves the last value in the sequence.\nfunc setKeyframeTime(CGFloat, for: Int)\nChanges the time for a specific keyframe.\nfunc setKeyframeValue(Any, for: Int)\nChanges the value for a specific keyframe.\nfunc setKeyframeValue(Any, time: CGFloat, for: Int)\nReplaces a keyframe in the sequence with a new keyframe."
  },
  {
    "title": "run(_:withKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483042-run",
    "html": "Parameters\naction\n\nThe action to perform.\n\nkey\n\nA unique key used to identify the action.\n\nDiscussion\n\nThis method is identical to run(_:), but the action is stored so that it can be retrieved later. If an action using the same key is already running, it is removed before the new action is added.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "lowerLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1520000-lowerlimit",
    "html": "See Also\nInspecting a Range Object’s Limits\nvar upperLimit: CGFloat\nThe maximum possible value."
  },
  {
    "title": "SKSceneDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenedelegate",
    "html": "Overview\n\nThe SKSceneDelegate protocol is used to implement a delegate to be called whenever the scene is being animated. Typically, you supply a delegate when you want to use a scene without requiring the scene to be subclassed. The methods in this protocol all correspond to methods implemented by the SKScene class. If the delegate implements a particular method, that method is called instead of the corresponding method on the scene object.\n\nWhen processing a scene, SpriteKit runs a loop that processes and renders the scene. The SKSceneDelegate methods allows you to add logic at any step of the loop.\n\nFigure 1 Frame processing in a scene\n\nImportant\n\nIf your view has a SKViewDelegate and its view(_:shouldRenderAtTime:) method returns false, the update is skipped and none of the scene delegate methods are called.\n\nTopics\nHandling Animation Events\nUse SpriteKit Objects within Scene Delegate Callbacks\nFollow threading guidelines to keep your SpriteKit app thread safe.\nfunc update(TimeInterval, for: SKScene)\nTells you to perform any app specific logic to update your scene.\nfunc didEvaluateActions(for: SKScene)\nTells you to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics(for: SKScene)\nTells you to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints(for: SKScene)\nTells you to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate(for: SKScene)\nTells you to peform any necessary logic after the scene has finished all of the steps required to process animations.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nConfiguring a Delegate\nSubclassing Scenes Versus Assigning a Delegate\nUse a scene delegate to share app logic across various scenes.\nvar delegate: SKSceneDelegate?\nA delegate to be called during the animation loop."
  },
  {
    "title": "Using Keyframe Sequence to effect Custom Interpolation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/using_keyframe_sequence_to_effect_custom_interpolation",
    "html": "Overview\n\nThe primary use for an SKKeyframeSequence object is to animate properties on particles emitted by an SKEmitterNode object. When a keyframe object is assigned to an appropriate property on the emitter node, particles determine their values by sampling the keyframe sequence. The sequence replaces the normal simulation performed by the emitter node. Only certain properties can be animated using a keyframe sequence. The following table lists the particle emitter properties and the corresponding class for the data that must be stored in the sequence. All value objects stored in a sequence must have the same class.\n\nTable 1 Emitter properties for keyframe sequences\n\nSKEmitterNode property\n\n\t\n\nValue class\n\n\n\n\nparticleColorSequence\n\n\t\n\nSKColor\n\n\n\n\nparticleColorBlendFactorSequence\n\n\t\n\nNSNumber containing a floating point value.\n\n\n\n\nparticleScaleSequence\n\n\t\n\nNSNumber containing a floating point value.\n\n\n\n\nparticleAlphaSequence\n\n\t\n\nNSNumber containing a floating point value.\n\nThe time values stored in the sequence are specified in a normalized range of 0.0 to 1.0, where 0 is the time when the particle was created and 1.0 is the time when the particle dies. You can provide keyframe values for the entire lifetime of the particle or for a subset of the particle’s lifetime. If you choose to cover only a subset of the particle’s lifetime, the repeatMode property determines how samples are determined for time values that lie outside the specified range.\n\nThe interpolationMode property determines how samples between the keyframe values are calculated.\n\nSKKeyframeSequence isn’t limited to working only with SKEmitterNode, you can use the sample(atTime:) method to generate values interpolated between keyframes for other applications. The following code shows how to create a sequence containing four keyframes and how to iterate over the interpolated values:\n\nListing 1 Creating interpolated values\nlet sequence = SKKeyframeSequence(keyframeValues: [5, 1, 10, 0],\n                                  times: [0, 0.25, 0.5, 1])\nsequence.interpolationMode = .spline\nstride(from: 0, to: 1, by: 0.025).forEach {\n    let value = sequence.sample(atTime: CGFloat($0))\n}\n\n\nUsing SKInterpolationMode.spline interpolation, the code above creates the following graph in a playground:\n\nFigure 1 Playground graph generated by SKKeyframeSequence\n\nSKKeyframeSequence can also interpolate colors. The following code shows how to initialize a sequence with four colors and sample the interpolated values:\n\nListing 2 Creating interpolated colors\nlet colorSequence = SKKeyframeSequence(keyframeValues: [SKColor.green,\n                                                        SKColor.yellow,\n                                                        SKColor.red,\n                                                        SKColor.blue],\n                                       times: [0, 0.25, 0.5, 1])\ncolorSequence.interpolationMode = .linear\nstride(from: 0, to: 1, by: 0.001).forEach {\n    let color = colorSequence.sample(atTime: CGFloat($0)) as! SKColor\n}\n\n\nThe samples for each color generated by the code above can be used to create a gradient:\n\nFigure 2 Gradient generated by keyframe sequence interpolated colors\n\nSee Also\nFirst Steps\ninit(keyframeValues: [Any], times: [NSNumber])\nInitializes a keyframe sequence with an initial set of values and times.\ninit(capacity: Int)\nInitializes a new keyframe sequence.\ninit?(coder: NSCoder)"
  },
  {
    "title": "init(keyframeValues:times:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390896-init",
    "html": "Parameters\nvalues\n\nAn array of value objects that define the keyframe values for the sequence.\n\ntimes\n\nAn array of NSNumber objects containing floating-point values that specify the time values for the keyframes.\n\nReturn Value\n\nA newly initialized sequence.\n\nDiscussion\n\nThe two arrays must have an identical number of elements. The keyframes in the new sequence are stored in the same order as the input arrays.\n\nSee Also\nFirst Steps\nUsing Keyframe Sequence to effect Custom Interpolation\nSee a few examples of what keyframe sequence can do.\ninit(capacity: Int)\nInitializes a new keyframe sequence.\ninit?(coder: NSCoder)\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "init(constantValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1520276-init",
    "html": "Parameters\nvalue\n\nA constant.\n\nReturn Value\n\nA newly initialized range object whose minimum and maximum value are both equal to value.\n\nSee Also\nCreating a Range Object\ninit(value: CGFloat, variance: CGFloat)\nCreates and initializes a new range object using a value and a maximum distance from that value.\nclass func withNoLimits() -> Self\nCreates and initializes a new range object that encompasses all possible values.\ninit(lowerLimit: CGFloat)\nCreates and initializes a new range object that specifies only a minimum value.\ninit(upperLimit: CGFloat)\nCreates and initializes a new range object that specifies only a maximum value.\ninit(lowerLimit: CGFloat, upperLimit: CGFloat)\nInitializes a new range object."
  },
  {
    "title": "reactionForce | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjoint/1519866-reactionforce",
    "html": "See Also\nReading the Stress and Speed that Are Currently Applied to a Joint\nvar reactionTorque: CGFloat\nInstantaneous reaction torque, in newton-meters, currently being directed at the anchor point."
  },
  {
    "title": "bodyA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjoint/1520403-bodya",
    "html": "See Also\nAccessing or Setting a Joint's Bodies\nvar bodyB: SKPhysicsBody\nThe second body connected by the joint.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519869-categorybitmask",
    "html": "Discussion\n\nEvery physics body in a scene can be assigned to up to 32 different categories, each corresponding to a bit in the bit mask. You define the mask values used in your game. In conjunction with the collisionBitMask and contactTestBitMask properties, you define which physics bodies interact with each other and when your game is notified of these interactions.\n\nThe default value is 0xFFFFFFFF (all bits set).\n\nSee Also\nWorking with Collisions and Contacts\nAbout Collisions and Contacts\nLearn how to set up nodes for collision detection.\nvar collisionBitMask: UInt32\nA mask that defines which categories of physics bodies can collide with this physics body.\nvar usesPreciseCollisionDetection: Bool\nA Boolean value that determines whether the physics world uses an iterative collision detection algorithm.\nvar contactTestBitMask: UInt32\nA mask that defines which categories of physics bodies cause intersection notifications with this physics body.\nfunc allContactedBodies() -> [SKPhysicsBody]\nThe physics bodies that this physics body is in contact with."
  },
  {
    "title": "bodyB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjoint/1519693-bodyb",
    "html": "See Also\nAccessing or Setting a Joint's Bodies\nvar bodyA: SKPhysicsBody\nThe first body connected by the joint."
  },
  {
    "title": "joint(withBodyA:bodyB:anchorA:anchorB:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointlimit/1520402-joint",
    "html": "Parameters\nbodyA\n\nThe first body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nbodyB\n\nThe second body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nanchorA\n\nA connection point on the first body in the scene’s coordinate system.\n\nanchorB\n\nA connection point on the second body in the scene’s coordinate system.\n\nReturn Value\n\nA new limit joint.\n\nDiscussion\n\nYou must add the joint to a physics world associated with the scene before it takes effect.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "reactionTorque | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjoint/1519682-reactiontorque",
    "html": "See Also\nReading the Stress and Speed that Are Currently Applied to a Joint\nvar reactionForce: CGVector\nThe instantaneous reaction force, in newtons, currently being directed at the anchor point."
  },
  {
    "title": "joint(withBodyA:bodyB:anchor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointfixed/1520076-joint",
    "html": "Parameters\nbodyA\n\nThe first body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nbodyB\n\nThe second body to connect. The body must be connected to a node that is already part of the scene’s node tree.\n\nanchor\n\nThe anchor point for the connection in the scene’s coordinate system.\n\nReturn Value\n\nA new fixed joint.\n\nDiscussion\n\nYou must add the joint to a physics world associated with the scene before it takes effect.\n\nSee Also\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "bodyB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontact/1478526-bodyb",
    "html": "See Also\nInspecting the Contact Properties\nvar bodyA: SKPhysicsBody\nThe first body in the contact.\nvar contactPoint: CGPoint\nThe contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe impulse that specifies how hard these two bodies struck each other in Newton-seconds.\nvar contactNormal: CGVector\nThe normal vector specifying the direction of the collision."
  },
  {
    "title": "bodyA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontact/1478533-bodya",
    "html": "See Also\nInspecting the Contact Properties\nvar bodyB: SKPhysicsBody\nThe second body in the contact.\nvar contactPoint: CGPoint\nThe contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe impulse that specifies how hard these two bodies struck each other in Newton-seconds.\nvar contactNormal: CGVector\nThe normal vector specifying the direction of the collision.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "contactTestBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519781-contacttestbitmask",
    "html": "Discussion\n\nWhen two bodies share the same space, each body’s category mask is tested against the other body’s contact mask by performing a logical AND operation. If either comparison results in a nonzero value, an SKPhysicsContact object is created and passed to the physics world’s delegate. For best performance, only set bits in the contacts mask for interactions you are interested in.\n\nThe default value is 0x00000000 (all bits cleared).\n\nSee Also\nWorking with Collisions and Contacts\nAbout Collisions and Contacts\nLearn how to set up nodes for collision detection.\nvar categoryBitMask: UInt32\nA mask that defines which categories this physics body belongs to.\nvar collisionBitMask: UInt32\nA mask that defines which categories of physics bodies can collide with this physics body.\nvar usesPreciseCollisionDetection: Bool\nA Boolean value that determines whether the physics world uses an iterative collision detection algorithm.\nfunc allContactedBodies() -> [SKPhysicsBody]\nThe physics bodies that this physics body is in contact with."
  },
  {
    "title": "contactPoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontact/1478524-contactpoint",
    "html": "See Also\nInspecting the Contact Properties\nvar bodyA: SKPhysicsBody\nThe first body in the contact.\nvar bodyB: SKPhysicsBody\nThe second body in the contact.\nvar collisionImpulse: CGFloat\nThe impulse that specifies how hard these two bodies struck each other in Newton-seconds.\nvar contactNormal: CGVector\nThe normal vector specifying the direction of the collision."
  },
  {
    "title": "contactDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld/1449602-contactdelegate",
    "html": "Discussion\n\nA contact is created when two physics bodies overlap and one of the physics bodies has a contactTestBitMask property that overlaps with the other body’s categoryBitMask property. By default, a physics body’s contactTestBitMask is set to all bits cleared."
  },
  {
    "title": "velocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519635-velocity",
    "html": "See Also\nInspecting a Physics Body’s Position and Velocity\nvar angularVelocity: CGFloat\nThe physics body’s angular speed.\nvar isResting: Bool\nA Boolean property that indicates whether the object is at rest within the physics simulation."
  },
  {
    "title": "contactNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontact/1478528-contactnormal",
    "html": "See Also\nInspecting the Contact Properties\nvar bodyA: SKPhysicsBody\nThe first body in the contact.\nvar bodyB: SKPhysicsBody\nThe second body in the contact.\nvar contactPoint: CGPoint\nThe contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe impulse that specifies how hard these two bodies struck each other in Newton-seconds."
  },
  {
    "title": "isResting | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520256-isresting",
    "html": "Discussion\n\nThis property is automatically set to true by the physics simulation when it determines that the body is at rest. This means that the body is at rest on another body in the system. Resting bodies do not participate in the physics simulation until an impulse is applied to the object or another object collides with it. This improves the performance of the physics simulation. If all bodies in the world are resting, the entire simulation is at rest, reducing the number of calculations that are performed by the physics world.\n\nSee Also\nInspecting a Physics Body’s Position and Velocity\nvar velocity: CGVector\nThe physics body’s velocity vector, measured in meters per second.\nvar angularVelocity: CGFloat\nThe physics body’s angular speed."
  },
  {
    "title": "didEnd(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontactdelegate/1449599-didend",
    "html": "Parameters\ncontact\n\nAn object that describes the contact.\n\nDiscussion\n\nThe two physics bodies described in the contact parameter are not passed in a guaranteed order. The following code shows how you might respond to the end of a contact event to execute code if either physics body is owned by a node with the name ground.\n\nListing 1 Responding to a contact event\nfunc didEnd(_ contact: SKPhysicsContact){\n    if contact.bodyA.node?.name == \"ground\" || contact.bodyB.node?.name == \"ground\" {\n        // execute code to respond to object hitting ground\n    }\n}\n\n\nSee Also\nResponding to Contact Events\nfunc didBegin(SKPhysicsContact)\nCalled when two bodies first contact each other."
  },
  {
    "title": "didBegin(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontactdelegate/1449595-didbegin",
    "html": "Parameters\ncontact\n\nAn object that describes the contact.\n\nDiscussion\n\nThe two physics bodies described in the contact parameter are not passed in a guaranteed order. The following code shows how you might respond to the beginning of a contact event to execute code if either physics body is owned by a node with the name ground.\n\nListing 1 Responding to a contact event.\nfunc didBegin(_ contact: SKPhysicsContact) {\n    if contact.bodyA.node?.name == \"ground\" || contact.bodyB.node?.name == \"ground\" {\n        // execute code to respond to object hitting ground\n    }\n}\n\n\nSee Also\nResponding to Contact Events\nfunc didEnd(SKPhysicsContact)\nCalled when the contact ends between two physics bodies.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "joints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519849-joints",
    "html": "Discussion\n\nThis property holds an array of SKPhysicsJoint objects that define all joints added to the scene’s physics world that are connected to this physics body."
  },
  {
    "title": "Pinning and Rotating Physics Bodies | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/pinning_and_rotating_physics_bodies",
    "html": "Overview\n\nA common task in a physics simulation is to pin bodies together. Pinning locks the position of an object but allows it to rotate—for example, to fix a wheel to a vehicle. SpriteKit offers two options for pinning physics bodies—either using the pinned property or creating an SKPhysicsJointPin joint.\n\nThe pinned property offers convenience because it requires less code. If you wish to simulate friction, the physics body’s angularDamping property is analogous to the joint’s frictionTorque property. You must use a joint, however, if you want to control the rotation speed. In addition, use a joint to control the anchor point or limit the rotation angles—you do that by using lowerAngleLimit and upperAngleLimit.\n\nPin a Node Using the Pinned Property\n\nThe following code demonstrates using the pinned property. The code creates a sprite node with an image of a pendulum (two circles of different sizes joined by a center rod). A physics body is created based on the generated texture, has its pinned property set to true, and is assigned to the node. The node is rotated 90 degrees—to align horizontally—so that gravity pulls the heavier end toward the ground.\n\nlet pinned = SKSpriteNode(imageNamed: \"pendulum\")\n  \npinned.physicsBody = SKPhysicsBody(texture: pinned.texture!,\n                                   size: pinned.size)\npinned.position = CGPoint(x: 320,\n                          y: 320)\npinned.zRotation = CGFloat.pi / 2\npinned.physicsBody?.pinned = true\n  \nscene.addChild(pinned)\n\n\nBecause the node’s physics body is pinned, it stays in position but rotates around its center.\n\nPin a Node Using a Joint\n\nThe following code demonstrates using a physics joint pin. In this example, a static anchor is created and added to the scene. The sprite node is added as a child of the anchor node and a SKPhysicsJointPin joins the two together.\n\nlet anchor = SKNode()\n  \nanchor.position = CGPoint(x: 320,\n                          y: 320)\nanchor.zRotation = CGFloat.pi / 2\nanchor.physicsBody = SKPhysicsBody()\nanchor.physicsBody?.isDynamic = false\n  \nlet jointed = SKSpriteNode(imageNamed: \"pendulum\")\njointed.physicsBody = SKPhysicsBody(texture: pinned.texture!,\n                                    size: pinned.size)\n  \nscene.addChild(anchor)\nanchor.addChild(jointed)\n  \nlet pinJoint = SKPhysicsJointPin.joint(withBodyA: anchor.physicsBody!,\n                                       bodyB: jointed.physicsBody!,\n                                       anchor: anchor.position)\nscene.physicsWorld.add(pinJoint)\n\n\nSee Also\nPinning a Physics Body to a Node’s Parent\nvar pinned: Bool\nA Boolean value that indicates whether the physics body’s node is pinned to its parent node."
  },
  {
    "title": "charge | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1519881-charge",
    "html": "Discussion\n\nThe electrical charge is used by electromagnetic fields to calculate electromagnetic force effects on the physics body. See SKFieldNode.\n\nSee Also\nInteracting with Physics Fields\nvar fieldBitMask: UInt32\nA mask that defines which categories of physics fields can exert forces on this physics body."
  },
  {
    "title": "SKInterpolationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skinterpolationmode",
    "html": "Topics\nConstants\ncase linear\nValues between two keyframes are interpolated linearly.\ncase spline\nValues between two keyframes using a spline curve.\ncase step\nValues between two keyframes are not interpolated. Instead, the value is that of the most recent keyframe.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "repeatMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390900-repeatmode",
    "html": "Discussion\n\nThe possible values are defined in SKRepeatMode. The default value is SKRepeatMode.clamp.\n\nSee Also\nInterpolation Modifiers\nvar interpolationMode: SKInterpolationMode\nThe mode used to determine how values for times between the keyframes are calculated."
  },
  {
    "title": "showsPhysics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520389-showsphysics",
    "html": "Discussion\n\nWhen this debugging option is enabled, each time a frame is rendered, an overlay image is drawn on top of your scene that shows the positions and shapes of any physics bodies visible in the scene.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsFPS: Bool\nA Boolean value that indicates whether the view displays a frame rate indicator.\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "isAsynchronous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520229-isasynchronous",
    "html": "Discussion\n\nThe default value is true. If the value is false, the contents of this view are synchronized with Core Animation updates.\n\nSee Also\nConfiguring Performance Related Toggles\nvar ignoresSiblingOrder: Bool\nA Boolean value that indicates whether parent-child and sibling relationships affect the rendering order of nodes in the scene.\nvar shouldCullNonVisibleNodes: Bool\nA Boolean value that indicates whether the view automatically culls non-visible nodes from the rendering tree.\nvar allowsTransparency: Bool\nA Boolean property that indicates whether the view is rendered using transparency."
  },
  {
    "title": "rotationSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointpin/1520259-rotationspeed",
    "html": "Discussion\n\nThe frictionTorque property limits the maximum amount of torque that can be applied to the physics bodies.\n\nSee Also\nConfiguring a Pin Joint\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the pin joint’s rotation is limited to a specific range of values.\nvar lowerAngleLimit: CGFloat\nThe smallest angle allowed for the pin joint, in radians.\nvar upperAngleLimit: CGFloat\nThe largest angle allowed for the pin joint, in radians.\nvar frictionTorque: CGFloat\nThe resistance applied by the pin joint to spinning around the anchor point."
  },
  {
    "title": "init(named:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417680-init",
    "html": "Parameters\nname\n\nThe name of the action.\n\nurl\n\nThe URL of the file containing the action.\n\nReturn Value\n\nA new action object.\n\nSee Also\nCreating Custom Actions\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue."
  },
  {
    "title": "init(named:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417697-init",
    "html": "Parameters\nname\n\nThe name of the action.\n\nsec\n\nThe duration of the action.\n\nReturn Value\n\nA new action object.\n\nSee Also\nCreating Custom Actions\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\ninit?(named: String, from: URL, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue."
  },
  {
    "title": "init(named:from:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417754-init",
    "html": "Parameters\nname\n\nThe name of the action.\n\nurl\n\nThe URL of the file containing the action.\n\nsec\n\nThe duration of the action, in seconds.\n\nReturn Value\n\nA new action object.\n\nSee Also\nCreating Custom Actions\ninit?(named: String)\nCreates an action of the given name from an action file.\ninit?(named: String, duration: TimeInterval)\nCreates an action of the given name from an action file with a new duration.\ninit?(named: String, from: URL)\nCreates an action of the given name from an action file.\nclass func customAction(withDuration: TimeInterval, actionBlock: (SKNode, CGFloat) -> Void) -> SKAction\nCreates an action that executes a block over a duration.\nclass func perform(Selector, onTarget: Any) -> SKAction\nCreates an action that calls a method on an object.\nclass func run(() -> Void) -> SKAction\nCreates an action that executes a block.\nclass func run(() -> Void, queue: dispatch_queue_t) -> SKAction\nCreates an action that executes a block on a specific dispatch queue."
  },
  {
    "title": "getKeyframeValue(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390898-getkeyframevalue",
    "html": "Parameters\nindex\n\nThe index of the keyframe.\n\nReturn Value\n\nThe value object for the keyframe.\n\nSee Also\nSequence Information\nfunc count() -> Int\nThe number of keyframes in the sequence.\nfunc getKeyframeTime(for: Int) -> CGFloat\nGets the time for a keyframe in the sequence."
  },
  {
    "title": "Getting Started with Nodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/getting_started_with_nodes",
    "html": "Overview\n\nNodes are organized hierarchically into node trees, similar to how views and subviews work. Most commonly, a node tree is defined with a scene node (SKScene) as the root node and other content nodes as descendants. The scene node runs an animation loop that processes actions on the nodes, simulates physics, and renders the contents of the node tree for display.\n\nEvery node in a node tree provides a coordinate system to its children. After a child is added to the node tree, you position it inside its parent’s coordinate system by setting its zPosition property. A node’s coordinate system can be scaled and rotated by changing its xScale, yScale, and zRotation properties. When a node’s coordinate system is scaled or rotated, this transformation is applied both to the node’s own content and to that of its descendants.\n\nReview Important Properties\n\nThe SKNode class does not perform any drawing of its own. However, many SKNode subclasses render visual content and so the SKNode class understands some visual concepts:\n\nThe frame property provides the bounding rectangle for a node’s visual content, modified by the scale and rotation properties. The frame is nonempty if the node’s class draws content. Each node subclass determines the size of this content differently. In some subclasses, the size of the node’s content is declared explicitly, such as in the SKSpriteNode class. In other subclasses, the content size is calculated implicitly by the class using other object properties. For example, an SKLabelNode object determines its content size using the label’s message text and font characteristics.\n\nA node’s accumulated frame, retrieved by calling the calculateAccumulatedFrame() method, is the largest rectangle that includes the frame of the node and the frames of all its descendants.\n\nOther properties, such as the alpha and isHidden properties, affect how the node and its descendants are drawn.\n\nAll nodes are responder objects that can respond directly to user interaction with the node onscreen. See Controlling User Interaction on Nodes. You can also convert between coordinate systems and perform hit testing to determine which nodes a point lies in, and perform intersections between nodes in the tree to determine if their physical areas overlap.\n\nAny node in the tree may run actions, which are used to animate the properties of a node, add or remove nodes, play sounds, or perform other custom tasks. Actions are the heart of the animation system in SpriteKit. See Getting Started with Actions.\n\nA node can support a physics body, which is an object that simulates the physical properties of the object. When a node has a physics body, the physics simulation automatically computes a new position for the physics body and then moves and rotates the node to match that position. See Getting Started with Physics.\n\nA node can supply constraints that express relationships with other nodes or locations in the scene. These constraints are automatically applied by the scene before the scene is rendered. Another set of constraints is used in conjunction with actions to perform inverse-kinematic animations. See Working with Inverse Kinematics.\n\nEnsure Node Access on the Main Thread\n\nAll of the SpriteKit callbacks for SKViewDelegate, SKSceneDelegate, and SKScene occur in the main thread and therefore, these are safe places to access or manipulate nodes. If you are performing other work in the background, you should adopt an approach similar to\n\nListing 1 Manipulating a node within a scene update callback\nclass ViewController: UIViewController {\n    let queue = DispatchQueue.global()\n    \n    var makeNodeModifications = false\n    \n    func backgroundComputation() {\n        queue.async {\n            // Perform background calculations but do not modify \n            // SpriteKit objects\n            \n            // Set a flag for later modification within the \n            // SKScene or SKSceneDelegate callback of your choosing\n            \n            self.makeNodeModifications = true\n        }\n    }\n}\nextension ViewController: SKSceneDelegate {\n    func update(_ currentTime: TimeInterval, for scene: SKScene) {\n        if makeNodeModifications {\n            makeNodeModifications = false\n            \n            // Make node modifications\n        }\n    }\n}\n\nLay Out Your Scene with Basic Nodes\n\nEven though SKNode objects cannot directly draw content, there are useful ways to use them in your app. Here are some ideas to get you started:\n\nYou have content that is built up from multiple node objects, either sprites or other content nodes. However, you want this content to be thought of as a single object within your game, without promoting any one of the content nodes to be the root. A basic node is appropriate, because you can give it a position in the scene tree and then make all of the other nodes its descendants. These individual pieces can also be moved or adjusted relative to the parent’s location.\n\nYou want to organize your drawn content into a series of layers. For example, many games have a background layer for the world, another layer for characters, and a third layer for text and other game information. Other games have many more layers. Create the layers as basic nodes, and insert them into the scene in order. Then, as necessary, you can make individual layers visible or invisible.\n\nYou need an object in the scene that is invisible but that performs some other necessary function. For example, in a dungeon-exploring game, an invisible node might be used to represent a hidden trap. When another node intersects it, the trap is triggered. For another example, you might add a node as a child of another node that represents the position of the player’s point of view.\n\nThere are advantages to having a node in the tree to represent these concepts:\n\nYou can add or remove entire subtrees by adding or removing a single node. This makes scene management efficient.\n\nYou can adjust properties of a node in the tree and have the effects of those properties propagate down to the node’s descendants. For example, if the basic node has sprite nodes as its children, rotating the basic node also rotates all of the sprite content.\n\nYou can take advantage of actions, physics contacts, and other SpriteKit features to implement the concept.\n\nSee Also\nFirst Steps\ninit()\nInitializes a blank node.\ninit?(fileNamed: String)\nCreates a new node by loading an archive file from the game’s main bundle.\ninit?(coder: NSCoder)\nCalled when a node is initialized from an .sks file.\ninit(fileNamed: String, securelyWithClasses: Set<AnyHashable>)"
  },
  {
    "title": "init(fileNamed:securelyWithClasses:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/3005334-init",
    "html": "See Also\nFirst Steps\nGetting Started with Nodes\nLearn about the fundamental properties that provide a foundation for all other nodes.\ninit()\nInitializes a blank node.\ninit?(fileNamed: String)\nCreates a new node by loading an archive file from the game’s main bundle.\ninit?(coder: NSCoder)\nCalled when a node is initialized from an .sks file."
  },
  {
    "title": "preloadTextureAtlasesNamed(_:withCompletionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/1427377-preloadtextureatlasesnamed",
    "html": "Parameters\natlasNames\n\nAn array containing the atlas names to preload.\n\ncompletionHandler\n\nA block called after all of the texture atlases are loaded.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func preloadTextureAtlasesNamed(_ atlasNames: [String]) async throws -> [SKTextureAtlas]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSpriteKit creates a background task that loads the texture data from all of the specified atlas objects. Then, SpriteKit returns control to your game. After the atlases are loaded, your completion handler is called.\n\nSee Also\nPreloading Textures\nfunc preload(completionHandler: () -> Void)\nLoads an atlas object’s textures into memory, calling a completion handler after the task completes.\nclass func preloadTextureAtlases([SKTextureAtlas], withCompletionHandler: () -> Void)\nLoads the textures of multiple atlas objects into memory, calling a completion handler after the task completes."
  },
  {
    "title": "sample(atTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390904-sample",
    "html": "Parameters\ntime\n\nThe time value to sample.\n\nReturn Value\n\nAn object that contains the interpolated sample. The class of this object matches the class of the values stored in the keyframe sequence — either an NSNumber or an SKColor."
  },
  {
    "title": "getKeyframeTime(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390908-getkeyframetime",
    "html": "Parameters\nindex\n\nThe index of the keyframe.\n\nReturn Value\n\nThe time value for the keyframe.\n\nSee Also\nSequence Information\nfunc count() -> Int\nThe number of keyframes in the sequence.\nfunc getKeyframeValue(for: Int) -> Any\nGets the value for a keyframe in the sequence."
  },
  {
    "title": "setKeyframeValue(_:time:for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390890-setkeyframevalue",
    "html": "Parameters\nvalue\n\nThe new value for the keyframe.\n\ntime\n\nThe new time for the keyframe.\n\nindex\n\nThe index of the keyframe to change.\n\nSee Also\nSequence Building\nfunc addKeyframeValue(Any, time: CGFloat)\nAdds a keyframe to the sequence.\nfunc removeKeyframe(at: Int)\nRemoves a keyframe from the sequence.\nfunc removeLastKeyframe()\nRemoves the last value in the sequence.\nfunc setKeyframeTime(CGFloat, for: Int)\nChanges the time for a specific keyframe.\nfunc setKeyframeValue(Any, for: Int)\nChanges the value for a specific keyframe."
  },
  {
    "title": "setKeyframeValue(_:for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390883-setkeyframevalue",
    "html": "Parameters\nvalue\n\nThe new value for the keyframe.\n\nindex\n\nThe index of the keyframe to change.\n\nSee Also\nSequence Building\nfunc addKeyframeValue(Any, time: CGFloat)\nAdds a keyframe to the sequence.\nfunc removeKeyframe(at: Int)\nRemoves a keyframe from the sequence.\nfunc removeLastKeyframe()\nRemoves the last value in the sequence.\nfunc setKeyframeTime(CGFloat, for: Int)\nChanges the time for a specific keyframe.\nfunc setKeyframeValue(Any, time: CGFloat, for: Int)\nReplaces a keyframe in the sequence with a new keyframe."
  },
  {
    "title": "count() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390928-count",
    "html": "Return Value\n\nThe number of keyframes in the sequence.\n\nSee Also\nSequence Information\nfunc getKeyframeTime(for: Int) -> CGFloat\nGets the time for a keyframe in the sequence.\nfunc getKeyframeValue(for: Int) -> Any\nGets the value for a keyframe in the sequence."
  },
  {
    "title": "addKeyframeValue(_:time:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390894-addkeyframevalue",
    "html": "Parameters\nvalue\n\nAn object that defines the value to add. It must have the same class as other value objects stored in the sequence.\n\ntime\n\nThe corresponding time.\n\nDiscussion\n\nThe new keyframe is appended to the end of the array.\n\nSee Also\nSequence Building\nfunc removeKeyframe(at: Int)\nRemoves a keyframe from the sequence.\nfunc removeLastKeyframe()\nRemoves the last value in the sequence.\nfunc setKeyframeTime(CGFloat, for: Int)\nChanges the time for a specific keyframe.\nfunc setKeyframeValue(Any, for: Int)\nChanges the value for a specific keyframe.\nfunc setKeyframeValue(Any, time: CGFloat, for: Int)\nReplaces a keyframe in the sequence with a new keyframe."
  },
  {
    "title": "init(coder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390892-init",
    "html": "See Also\nFirst Steps\nUsing Keyframe Sequence to effect Custom Interpolation\nSee a few examples of what keyframe sequence can do.\ninit(keyframeValues: [Any], times: [NSNumber])\nInitializes a keyframe sequence with an initial set of values and times.\ninit(capacity: Int)\nInitializes a new keyframe sequence."
  },
  {
    "title": "init(capacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence/1390910-init",
    "html": "Parameters\nnumItems\n\nThe initial capacity of the new sequence.\n\nReturn Value\n\nA newly initialized empty sequence.\n\nDiscussion\n\nSee Also\nFirst Steps\nUsing Keyframe Sequence to effect Custom Interpolation\nSee a few examples of what keyframe sequence can do.\ninit(keyframeValues: [Any], times: [NSNumber])\nInitializes a keyframe sequence with an initial set of values and times.\ninit?(coder: NSCoder)"
  },
  {
    "title": "upperLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1519596-upperlimit",
    "html": "See Also\nInspecting a Range Object’s Limits\nvar lowerLimit: CGFloat\nThe minimum possible value."
  },
  {
    "title": "init(upperLimit:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1519559-init",
    "html": "Parameters\nupper\n\nThe maximum value for the range.\n\nReturn Value\n\nA newly initialized range object whose minimum value is -Inf and whose maximum value is upper.\n\nSee Also\nCreating a Range Object\ninit(value: CGFloat, variance: CGFloat)\nCreates and initializes a new range object using a value and a maximum distance from that value.\nclass func withNoLimits() -> Self\nCreates and initializes a new range object that encompasses all possible values.\ninit(lowerLimit: CGFloat)\nCreates and initializes a new range object that specifies only a minimum value.\ninit(constantValue: CGFloat)\nCreates and initializes a new range object that specifies a constant value.\ninit(lowerLimit: CGFloat, upperLimit: CGFloat)\nInitializes a new range object."
  },
  {
    "title": "pinned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520354-pinned",
    "html": "Discussion\n\nThe default value is false. If true, the node’s position is fixed relative to its parent. The node’s position cannot be changed by actions or physics forces. The node can freely rotate around its position in response to collisions or other forces. If the parent node has a physics body, the two physics bodies are treated as if they are connected with a pin joint.\n\nSee Also\nPinning a Physics Body to a Node’s Parent\nPinning and Rotating Physics Bodies\nPin a node so it's free to rotate about a certain point on its parent node."
  },
  {
    "title": "init(lowerLimit:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1520137-init",
    "html": "Parameters\nlower\n\nThe minimum value for the range.\n\nReturn Value\n\nA newly initialized range object whose minimum value is lower and whose maximum value is +Inf.\n\nSee Also\nCreating a Range Object\ninit(value: CGFloat, variance: CGFloat)\nCreates and initializes a new range object using a value and a maximum distance from that value.\nclass func withNoLimits() -> Self\nCreates and initializes a new range object that encompasses all possible values.\ninit(upperLimit: CGFloat)\nCreates and initializes a new range object that specifies only a maximum value.\ninit(constantValue: CGFloat)\nCreates and initializes a new range object that specifies a constant value.\ninit(lowerLimit: CGFloat, upperLimit: CGFloat)\nInitializes a new range object."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417803-reversed",
    "html": "Return Value\n\nA new action that reverses an action’s behavior.\n\nDiscussion\n\nThis method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or that performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action."
  },
  {
    "title": "fadeOut(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417738-fadeout",
    "html": "Parameters\nsec\n\nThe duration of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s alpha property animates from its current value to 0.0. This causes the node to disappear.\n\nThis action is reversible; the reverse is created as if the following code is executed:\n\nlet action = SKAction.fadeIn(withDuration: sec)\n\nSee Also\nAnimating the Transparency of a Node\nclass func fadeIn(withDuration: TimeInterval) -> SKAction\nCreates an action that changes the alpha value of the node to 1.0.\nclass func fadeAlpha(by: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node by a relative value.\nclass func fadeAlpha(to: CGFloat, duration: TimeInterval) -> SKAction\nCreates an action that adjusts the alpha value of a node to a new value."
  },
  {
    "title": "withNoLimits() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1519920-withnolimits",
    "html": "Return Value\n\nA newly initialized range object whose minimum value is —Inf and whose maximum value is +Inf.\n\nSee Also\nCreating a Range Object\ninit(value: CGFloat, variance: CGFloat)\nCreates and initializes a new range object using a value and a maximum distance from that value.\ninit(lowerLimit: CGFloat)\nCreates and initializes a new range object that specifies only a minimum value.\ninit(upperLimit: CGFloat)\nCreates and initializes a new range object that specifies only a maximum value.\ninit(constantValue: CGFloat)\nCreates and initializes a new range object that specifies a constant value.\ninit(lowerLimit: CGFloat, upperLimit: CGFloat)\nInitializes a new range object."
  },
  {
    "title": "init(value:variance:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1519842-init",
    "html": "Parameters\nvalue\n\nThe midpoint for the range.\n\nvariance\n\nThe maximum amount that a value may differ from the midpoint.\n\nReturn Value\n\nA newly initialized range object whose minimum value is value-variance and whose maximum value is value+variance.\n\nSee Also\nCreating a Range Object\nclass func withNoLimits() -> Self\nCreates and initializes a new range object that encompasses all possible values.\ninit(lowerLimit: CGFloat)\nCreates and initializes a new range object that specifies only a minimum value.\ninit(upperLimit: CGFloat)\nCreates and initializes a new range object that specifies only a maximum value.\ninit(constantValue: CGFloat)\nCreates and initializes a new range object that specifies a constant value.\ninit(lowerLimit: CGFloat, upperLimit: CGFloat)\nInitializes a new range object."
  },
  {
    "title": "update(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519802-update",
    "html": "Parameters\ncurrentTime\n\nThe current system time.\n\nDiscussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. This is the first method called when animating the scene, before any actions are evaluated and before any physics are simulated.\n\nSee Also\nResponding to Frame-Cycle Events\nResponding to Frame-Cycle Events\nImplement per-frame app logic, such as the scene's update function that's called every frame.\nfunc didEvaluateActions()\nTells your app to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics()\nTells your app to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints()\nTells your app to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate()\nTells your app to peform any necessary logic after the scene has finished all of the steps required to process animations."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483070-subscript",
    "html": "Parameters\nname\n\nThe name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.\n\nReturn Value\n\nAn array of SKNode objects that match the name. If no matching nodes are found, an empty array is returned.\n\nSee Also\nAccessing Nodes by Name\nSearching the Node Tree\nAccess nodes by name to avoid needing an instance variable.\nvar name: String?\nThe node’s assignable name.\nfunc childNode(withName: String) -> SKNode?\nSearches the children of the receiving node for a node with a specific name.\nfunc enumerateChildNodes(withName: String, using: (SKNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nSearches the children of the receiving node to perform processing for nodes that share a name."
  },
  {
    "title": "alpha | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483023-alpha",
    "html": "Discussion\n\nThe default value is 1.0.\n\nThe SKNode class does not perform drawing, but many of its subclasses do. When a node or any of its descendants are drawn, the alpha component of each pixel is multiplied by the node’s alpha property and then clamped to the range 0.0-1.0. This modified alpha value is used to blend the pixel into the framebuffer. Subclasses that render content define properties that determine the blending operations used in conjunction with the alpha value to blend pixels into the parent’s framebuffer.\n\nSee Also\nAltering Node Visibility\nvar isHidden: Bool\nA Boolean value that determines whether a node and its descendants are rendered."
  },
  {
    "title": "isHidden | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483048-ishidden",
    "html": "Discussion\n\nWhen hidden, a node and its descendants are not rendered. However, they still exist in the scene and continue to interact in other ways. For example, the node’s actions still run and the node can still be intersected with other nodes. The default value is false.\n\nSee Also\nAltering Node Visibility\nvar alpha: CGFloat\nThe transparency value applied to the node’s contents.\nRelated Documentation\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed."
  },
  {
    "title": "timingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417807-timingmode",
    "html": "Discussion\n\nThe possible values for this property are listed in SKActionTimingMode. The default value is SKActionTimingMode.linear.\n\nSee Also\nControlling Action Timing\nConfiguring Action Timing\nTime an action in a scene, by adding or modifying timing properties, or cancel an action.\nvar duration: TimeInterval\nThe duration required to complete an action.\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\nvar timingFunction: SKActionTimingFunction\nA block used to customize the timing function.\ntypealias SKActionTimingFunction\nThe signature for the custom timing block.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs."
  },
  {
    "title": "run(_:completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483103-run",
    "html": "Parameters\naction\n\nThe action to perform.\n\nblock\n\nA completion block called when the action completes.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc run(_ action: SKAction) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "run(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483093-run",
    "html": "Parameters\naction\n\nThe action to perform.\n\nDiscussion\n\nThe new action is processed the next time the scene’s animation loop is processed.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "isPaused | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483113-ispaused",
    "html": "Discussion\n\nIf the value is true, the node (and all of its descendants) are skipped when a scene processes actions.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "duration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417790-duration",
    "html": "Discussion\n\nThis is the expected duration of an action’s animation. The actual time an action takes to complete is modified by the speed property of the action and the speed property of the node on which it executes.\n\nSee Also\nControlling Action Timing\nConfiguring Action Timing\nTime an action in a scene, by adding or modifying timing properties, or cancel an action.\nvar timingMode: SKActionTimingMode\nA setting that controls the speed curve of an animation.\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\nvar timingFunction: SKActionTimingFunction\nA block used to customize the timing function.\ntypealias SKActionTimingFunction\nThe signature for the custom timing block.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs."
  },
  {
    "title": "timingFunction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417666-timingfunction",
    "html": "Discussion\n\nIf a timing function is provided, after the normal timing mode is applied, the result is sent to the timing function. The return SKActionTimingFunction value of the timing function determines the actual time used to perform the animation.\n\nThe following code shows how you can create a custom timing function using simd_smoothstep(_:_:_:) interpolation:\n\nimport simd\nlet horizontalAction = SKAction.moveTo(x: end.x, duration: 2.0)\nhorizontalAction.timingFunction = {\n    time in\n    return simd_smoothstep(0, 1, time)\n}\n\n\nIf the above code is combined with a vertical linear move action, the path taken by a node running this action describes the curve illustrated below:\n\nSee Also\nControlling Action Timing\nConfiguring Action Timing\nTime an action in a scene, by adding or modifying timing properties, or cancel an action.\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar timingMode: SKActionTimingMode\nA setting that controls the speed curve of an animation.\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\ntypealias SKActionTimingFunction\nThe signature for the custom timing block.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs."
  },
  {
    "title": "speed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483036-speed",
    "html": "Discussion\n\nThe default value is 1.0, which means that all actions run at their normal speed. If you set a different speed, time appears to run faster or slower for all actions executed on the node and its descendants. For example, if you set a speed value of 2.0, actions run twice as fast.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "hasActions() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483081-hasactions",
    "html": "Return Value\n\ntrue if the node has any executing actions; otherwise false.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "action(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483138-action",
    "html": "Parameters\nkey\n\nA string that uniquely identifies an action.\n\nReturn Value\n\nIf an action exists that matches the key, the action object is returned. Otherwise, nil is returned.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "removeAllActions() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483030-removeallactions",
    "html": "Discussion\n\nWhen an action is removed from the node, any remaining animation the action would perform is skipped; however, previous changes are not reverted. It is possible that an action may make a final change to the scene when removed; if so, it is documented for the specific action in SKAction.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "removeAction(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483076-removeaction",
    "html": "Parameters\nkey\n\nA string that uniquely identifies an action.\n\nDiscussion\n\nIf an action is found that matches the key, it is removed from the node.\n\nSee Also\nRunning Actions\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node."
  },
  {
    "title": "physicsBody | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483117-physicsbody",
    "html": "Discussion\n\nThe default value is nil, which indicates that the node does not participate in the physics simulation at all. If a physics body is provided, when the scene’s physics are simulated, the physics body updates the node’s position and rotates the node.\n\nSee Also\nAdding Physics Behaviors\nGetting Started with Physics Bodies\nCreate and assign a physics body to enable physics."
  },
  {
    "title": "entity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1640688-entity",
    "html": "Discussion\n\nThe Entity-Component architecture in the GameplayKit framework is a way to more easily manage complex object graphs in your game. For more information on this architecture, read Entities and Components in GameplayKit Programming Guide.\n\nWhen you add entities (and their components) to a scene in the Xcode SpriteKit Scene Editor, Xcode automatically archive those entities alongside the SpriteKit scene content. Use the GKScene class to load the SpriteKit scene with its associated GameplayKit objects. Each entity associated with a SpriteKit node has a GKSKNodeComponent object that manages the relationship between the node and the GKEntity object it represents.\n\nSee Also\nAdding GameplayKit Behaviors\nclass func obstacles(fromNodeBounds: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming its bounds into the scene’s coordinate system.\nclass func obstacles(fromNodePhysicsBodies: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming the node’s physics body shape into the scene’s coordinate system.\nclass func obstacles(fromSpriteTextures: [SKNode], accuracy: Float) -> [GKPolygonObstacle]\nTurns each node into an obstacle by changing the node’s texture into a physics shape and converting it into the scene’s coordinate system."
  },
  {
    "title": "constraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483124-constraints",
    "html": "Discussion\n\nAssign an array of SKConstraint objects to the node. The scene processes these constraints before the scene is rendered. The constraints are processed in array order. If multiple nodes in the node tree have constraints, there is no guaranteed order that the nodes are processed in.\n\nSee Also\nConstraining Node Position or Rotation\nvar reachConstraints: SKReachConstraints?\nThe reach constraints to apply to the node when executing a reach action."
  },
  {
    "title": "intersects(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483140-intersects",
    "html": "Parameters\nnode\n\nAnother node in the same node tree.\n\nReturn Value\n\ntrue if the two nodes intersect; otherwise false.\n\nDiscussion\n\nThe two nodes are considered to intersect if their frames intersect. The children of both nodes are ignored in this test."
  },
  {
    "title": "SKShapeNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshapenode",
    "html": "Overview\n\nSKShapeNode allows you to create onscreen graphical elements from mathematical points, lines, and curves. The advantage this has over rasterized graphics, such as those displayed by textures, is that shapes are rasterized dynamically at runtime to produce crisp detail and smoother edges.\n\nTopics\nFirst Steps\nGetting Started with Shape Nodes\nCreate a filled or stroked shape from a path object.\nCreating a Shape from a Path\ninit(path: CGPath)\nCreates a shape node from a Core Graphics path.\ninit(path: CGPath, centered: Bool)\nCreates a shape node from a Core Graphics path, centered around its position.\nvar path: CGPath?\nThe path that defines the shape.\nCreating a Shape from a Rectangle\ninit(rect: CGRect)\nCreates a shape node with a rectangular path.\ninit(rectOf: CGSize)\nCreates a shape node with a rectangular path centered on the node’s origin.\ninit(rect: CGRect, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners.\ninit(rectOf: CGSize, cornerRadius: CGFloat)\nCreates a shape with a rectangular path that has rounded corners centered on the node’s position.\nCreating a Circle Shape\ninit(circleOfRadius: CGFloat)\nCreates a shape node with a circular path centered on the node’s origin.\nCreating an Ellipse Shape\ninit(ellipseOf: CGSize)\nCreates a shape node with an elliptical path centered on the node’s origin.\ninit(ellipseIn: CGRect)\nCreates a shape node with an elliptical path that fills the specified rectangle.\nCreating a Shape from an Array of Points\nCreating a Shape Node from an Array of Points\nCreate jagged or smooth shapes from the same array of points.\ninit(points: UnsafeMutablePointer<CGPoint>, count: Int)\nCreates a shape node from a series of points.\ninit(splinePoints: UnsafeMutablePointer<CGPoint>, count: Int)\nCreates a shape node from a series of spline points.\nFilling a Shape\nvar fillColor: UIColor\nThe color used to fill the shape.\nvar fillTexture: SKTexture?\nThe texture used to fill the shape.\nStroking a Shape\nvar lineWidth: CGFloat\nThe width used to stroke the path.\nvar strokeColor: UIColor\nThe color used to stroke the shape.\nvar strokeTexture: SKTexture?\nThe texture used to stroke the shape.\nvar glowWidth: CGFloat\nA glow that extends outward from the stroked line.\nvar lineCap: CGLineCap\nThe style used to render the endpoints of the stroked portion of the shape node.\nvar lineJoin: CGLineJoin\nThe junction type used when the stroked portion of the shape node is rendered.\nvar miterLimit: CGFloat\nThe miter limit to use when the line is stroked using a miter join style.\nvar isAntialiased: Bool\nA Boolean value that determines whether the stroked path is smoothed when drawn.\nConfiguring Alpha Blending\nChange how a shape uses its alpha value, such as additive blending, that results in the shape being brighter than it was before.\nvar blendMode: SKBlendMode\nThe blend mode used to blend the shape into the parent’s framebuffer.\nControlling or Animating Sroke Length\nAdjust or animate a shape's stroke.\nvar lineLength: CGFloat\nThe length of the line defined by the shape node.\nCustomizing Stroking or Fill Drawing\nTake per-pixel control of drawing the stroke or fill by supplying a custom code file.\nControlling Shape Drawing with Shaders\nChange a shape node's appearance by supplying custom shader code.\nvar strokeShader: SKShader?\nA custom shader used to determine the color of the stroked portion of the shape node.\nvar fillShader: SKShader?\nA custom shader used to determine the color of the filled portion of the shape node.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute.\nInstance Properties\nvar customPlaygroundQuickLook: PlaygroundQuickLook\nA custom playground quick look for this instance.\nDeprecated\nRelationships\nInherits From\nSKNode\nSee Also\nNodes that Draw\nMaximizing Node Drawing Performance\nStructure your nodes for maximum performance.\nclass SKSpriteNode\nAn image or solid color.\nclass SKEmitterNode\nA source of various particle effects.\nclass SKLabelNode\nA graphical element that draws text.\nclass SKVideoNode\nA graphical element that plays video content.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SK3DNode\n3D SceneKit content drawn as a flattened sprite."
  },
  {
    "title": "Getting Started with Physics Bodies | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/getting_started_with_physics_bodies",
    "html": "Overview\n\nAn SKPhysicsBody object defines the shape and simulation parameters for a physics body in the system. When the scene simulates physics, it performs the calculations for all physics bodies connected to the scene tree. So, you create an SKPhysicsBody object, configure its properties, and then assign it to a node’s physicsBody property.\n\nThere are three kinds of physics bodies:\n\nA dynamic volume simulates a physical object with volume and mass that can be affected by forces and collisions in the system. Use dynamic volumes to represent items in the scene that need to move around and collide with each other.\n\nA static volume is similar to a dynamic volume, but its velocity is ignored and it is unaffected by forces or collisions. However, because it still has volume, other objects can bounce off it or interact with it. Use static volumes to represent items that take up space in the scene, but that should not be moved by the simulation. For example, you might use static volumes to represent the walls of a maze. While it is useful to think of static and dynamic volumes as distinct entities, in practice these are two different modes you can apply to any volume-based physics body. This can be useful because you can selectively enable or disable effects for a body.\n\nAn edge is a static volume-less body. Edges are never moved by the simulation and their mass doesn’t matter. Edges are used to represent negative space within a scene (such as a hollow spot inside another entity) or an uncrossable, invisibly thin boundary. For example, edges are frequently used to represent the boundaries of your scene. The main difference between an edge and a volume is that an edge permits movement inside its own boundaries, while a volume is considered a solid object. If edges are moved through other means, they only interact with volumes, not with other edges.\n\nSpriteKit provides a few standard shapes—those based on arbitrary paths and those generated from the alpha channel of a texture. The following figure shows the shapes available:\n\nThe following code shows how to generate the four physics bodies called out above:\n\nlet spaceShipTexture = SKTexture(imageNamed: \"spaceShip.png\")\n   \n// Spaceship 1: circular physics body\nlet circularSpaceShip = SKSpriteNode(texture: spaceShipTexture)\ncircularSpaceShip.physicsBody = SKPhysicsBody(circleOfRadius: max(circularSpaceShip.size.width / 2,\n                                                                  circularSpaceShip.size.height / 2))\n   \n// Spaceship 2: rectangular physics body\nlet rectangularSpaceShip = SKSpriteNode(texture: spaceShipTexture)\nrectangularSpaceShip.physicsBody = SKPhysicsBody(rectangleOf: CGSize(width: circularSpaceShip.size.width,\n                                                                     height: circularSpaceShip.size.height))\n   \n// Spaceship 3: polygonal physics body\nlet polygonalSpaceShip = SKSpriteNode(texture: spaceShipTexture)\nlet path = CGMutablePath()\npath.addLines(between: [CGPoint(x: -5, y: 37), CGPoint(x: 5, y: 37), CGPoint(x: 10, y: 20),\n                        CGPoint(x: 56, y: -5), CGPoint(x: 37, y: -35), CGPoint(x: 15, y: -30),\n                        CGPoint(x: 12, y: -37), CGPoint(x: -12, y: -37), CGPoint(x: -15, y: -30),\n                        CGPoint(x: -37, y: -35), CGPoint(x: -56, y: -5), CGPoint(x: -10, y: 20),\n                        CGPoint(x: -5, y: 37)])\npath.closeSubpath()\npolygonalSpaceShip.physicsBody = SKPhysicsBody(polygonFrom: path)\n  \n// Spaceship 4: physics body using texture’s alpha channel\nlet texturedSpaceShip = SKSpriteNode(texture: spaceShipTexture)\ntexturedSpaceShip.physicsBody = SKPhysicsBody(texture: spaceShipTexture,\n                                              size: CGSize(width: circularSpaceShip.size.width,\n                                                           height: circularSpaceShip.size.height))\n\n\nThe shape of a physics body affects performance. A circular physics body offers the best performance and can be significantly faster than other physics bodies. If your simulation contains many physics bodies, circular bodies are the best solution. Rectangular and polygonal shapes improve collision accuracy with reduced speed. Physics bodies created from the alpha channel of a texture offer the best fidelity at the highest performance cost.\n\nCreate and Assign Physics Bodies\n\nA physics body is created by calling one of the SKPhysicsBody class methods. Each class method defines whether a volume-based or edge-based body is being created and what shape it has.\n\nAs soon as a node has its physics body set and is added to a scene, it begins to participate in the physics simulation. The following code shows how to create a simple scene containing a shape node that is the curvy ground and a sprite node—the rocket ship. The shape node’s physics body is created from its path and the sprite node’s physics body is created from the texture automatically generated by SpriteKit when the node was initialized. Because the ground node has its isDynamic set to false, it is not affected by gravity and remains stationary.\n\n// Create the rocket ship node and physics body\nlet spriteNode = SKSpriteNode(imageNamed: \"rocketShip\")\nspriteNode.position = CGPoint(x: 320, y: 320)\nspriteNode.physicsBody = SKPhysicsBody(texture: spriteNode.texture!,\n                                       size: spriteNode.texture!.size())\nspriteNode.physicsBody?.usesPreciseCollisionDetection = true\n     \n// Create the ground node and physics body\nvar splinePoints = [CGPoint(x: 0, y: 500),\n                    CGPoint(x: 100, y: 50),\n                    CGPoint(x: 400, y: 110),\n                    CGPoint(x: 640, y: 20)]\nlet ground = SKShapeNode(splinePoints: &splinePoints,\n                         count: splinePoints.count)\nground.lineWidth = 5\nground.physicsBody = SKPhysicsBody(edgeChainFrom: ground.path!)\nground.physicsBody?.restitution = 0.75\nground.physicsBody?.isDynamic = false\n     \n// Add the two nodes to the scene\nscene.addChild(spriteNode)\nscene.addChild(ground)\n\n\nAfter running for a few moments, the above code creates a scene that looks like the following illustration—the sprite node has come to rest in one of the valleys of the curvy ground line."
  },
  {
    "title": "upperAngleLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreachconstraints/1519699-upperanglelimit",
    "html": "See Also\nWorking with Reach Constraints\ninit(lowerAngleLimit: CGFloat, upperAngleLimit: CGFloat)\nInitializes a new reach constraint object.\nvar lowerAngleLimit: CGFloat\nThe minimum angle that the node can have after it is rotated by a reach event."
  },
  {
    "title": "cgImage() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519755-cgimage",
    "html": "Discussion\n\nThe cgImage() property returns the contents of a texture as a Quartz Image.\n\nAs an example use, you can create an image from a portion of your scene and save it to disk by doing the following:\n\nUse the texture(from:) method to render the scene’s contents to a texture.\n\nCall cgImage() on the result.\n\nUse CGImageDestination to write the CGImage out to disk."
  },
  {
    "title": "physicsWorld | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519584-physicsworld",
    "html": "Discussion\n\nEvery scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scene’s global physics properties, such as gravity. To add physics to a particular node, see physicsBody."
  },
  {
    "title": "update(_:for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscenedelegate/1519757-update",
    "html": "Parameters\ncurrentTime\n\nThe current system time.\n\nscene\n\nThe scene that is being animated.\n\nDiscussion\n\nDo not call this method directly; it is called by the system exactly once per frame, so long as the scene is presented in a view and is not paused. This is the first method called when animating the scene, before any actions are evaluated and before any physics are simulated.\n\nSee Also\nHandling Animation Events\nUse SpriteKit Objects within Scene Delegate Callbacks\nFollow threading guidelines to keep your SpriteKit app thread safe.\nfunc didEvaluateActions(for: SKScene)\nTells you to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics(for: SKScene)\nTells you to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints(for: SKScene)\nTells you to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate(for: SKScene)\nTells you to peform any necessary logic after the scene has finished all of the steps required to process animations.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "SKRepeatMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrepeatmode",
    "html": "Topics\nConstants\ncase clamp\nWhen a sample is calculated, the time value is clamped to the range of time values found in the sequence. For example, if the last keyframe’s time value is 0.5, a sample at any time value from 0.5 to 1.0 returns the last keyframe’s value.\ncase loop\nWhen a sample is calculated, the sequence loops back to the beginning of the sequence. For example, if the last keyframe’s time value is 0.5, then a sample at any time value from 0.5 to 1.0 returns the same value as the sequence did from 0.0 to 0.5.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "convert(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519847-convert",
    "html": "Parameters\npoint\n\nA point in view coordinates.\n\nscene\n\nA scene.\n\nReturn Value\n\nThe same point in the scene’s coordinate system.\n\nDiscussion\n\nThis method performs the coordinate conversion as if the scene is presented inside the view.\n\nSee Also\nConverting Between View and Scene Coordinates\nfunc convert(CGPoint, from: SKScene) -> CGPoint\nConverts a point from scene coordinates to view coordinates."
  },
  {
    "title": "showsFields | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520443-showsfields",
    "html": "Discussion\n\nWhen this debugging option is enabled, each time a frame is rendered, an image is drawn behind your scene that shows the effects of any physics fields contained in the scene.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsFPS: Bool\nA Boolean value that indicates whether the view displays a frame rate indicator.\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information."
  },
  {
    "title": "showsQuadCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519652-showsquadcount",
    "html": "Discussion\n\nSpriteKit converts the node tree into one or more rendering passes. Each rendering pass is rendered using a series of textured rectangles (quads). The showsQuadCount property allows you to see the total number of quads that were used to render the scene’s contents. Use this as another piece of data when you profile your game’s performance. In most cases, fewer quads is better.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsFPS: Bool\nA Boolean value that indicates whether the view displays a frame rate indicator.\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "preferredFrameRate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1642777-preferredframerate",
    "html": "Discussion\n\nThis function is deprecated. Use preferredFramesPerSecond instead.\n\nSee Also\nControlling the Timing of a Scene's Rendering\nvar isPaused: Bool\nA Boolean value that indicates whether the view’s scene animations are paused.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar delegate: SKViewDelegate?\nA delegate that allows dynamic control of the view's render rate.\nprotocol SKViewDelegate\nMethods to take custom control over the view's render rate.\nvar frameInterval: Int\nThe number of frames that must pass before the scene is called to update its contents.\nDeprecated"
  },
  {
    "title": "SKViewDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skviewdelegate",
    "html": "Overview\n\nBy setting a SpriteKit view's delegate with an object that implements SKViewDelegate, you can precisely control the frame rate of a game or app. You may choose to do this to maintain a consistent frame rate for computationally intensive code or for special effects such as simulating cine film.\n\nListing 1 shows an example of a class that implements the SpriteKit view delegate protocol to reduce the frame rate to a specified value. With each call of view(_:shouldRenderAtTime:), it checks the time since the last render and if that value exceeds the required frame duration (1 / fps), the method returns true and the frame is rendered.\n\nclass ViewDelegate: NSObject, SKViewDelegate {\n    var lastRenderTime: TimeInterval = 0\n    \n    let fps: TimeInterval = 3\n    \n    public func view(_ view: SKView, shouldRenderAtTime time: TimeInterval) -> Bool {\n\n\n        if time - lastRenderTime >= 1 / fps {\n            lastRenderTime = time\n            return true\n        }\n        else {\n            return false\n        }\n        \n    }\n}\n\n\nThe return value of view(_:shouldRenderAtTime:) doesn't change the speed of physics simulations and actions in a SpriteKit scene. However, if you return false, SpriteKit will skip updates and SKSceneDelegate methods are not called.\n\nTopics\nInstance Methods\nfunc view(SKView, shouldRenderAtTime: TimeInterval) -> Bool\nSpecifies whether the view should render at the given time.\nRelationships\nInherits From\nNSObjectProtocol\nInherited By\nARSKViewDelegate\nSee Also\nControlling the Timing of a Scene's Rendering\nvar isPaused: Bool\nA Boolean value that indicates whether the view’s scene animations are paused.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar delegate: SKViewDelegate?\nA delegate that allows dynamic control of the view's render rate.\nvar frameInterval: Int\nThe number of frames that must pass before the scene is called to update its contents.\nDeprecated\nvar preferredFrameRate: Float\nDeprecated"
  },
  {
    "title": "frameInterval | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520008-frameinterval",
    "html": "Discussion\n\nThe default value is 1, which results in your game being notified at the refresh rate of the display. If the value is set to a value larger than 1, the display link notifies your game at a fraction of the native refresh rate. For example, setting the interval to 2 causes the scene to be called every other frame, providing half the frame rate.\n\nBehavior is undefined with a value less than 1.\n\nThis property is deprecated. Use preferredFramesPerSecond, or view(_:shouldRenderAtTime:) instead.\n\nSee Also\nControlling the Timing of a Scene's Rendering\nvar isPaused: Bool\nA Boolean value that indicates whether the view’s scene animations are paused.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar delegate: SKViewDelegate?\nA delegate that allows dynamic control of the view's render rate.\nprotocol SKViewDelegate\nMethods to take custom control over the view's render rate.\nvar preferredFrameRate: Float\nDeprecated"
  },
  {
    "title": "preferredFramesPerSecond | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1642773-preferredframespersecond",
    "html": "Discussion\n\nWhen your application sets its preferred frame rate, the view chooses a frame rate as close to that as possible based on the capabilities of the screen the view is displayed on. The actual frame rate chosen is usually a factor of the maximum refresh rate of the screen to provide a consistent frame rate. For example, if the maximum refresh rate of the screen is 60 frames per second, that is also the highest frame rate the view sets as the actual frame rate. However, if you ask for a lower frame rate, the view might choose 30, 20, or 15 frames per second, or another rate, as the actual frame rate.\n\nYour application should choose a frame rate that it can consistently maintain.\n\nThe default value is 60 frames per second.\n\nSee Also\nControlling the Timing of a Scene's Rendering\nvar isPaused: Bool\nA Boolean value that indicates whether the view’s scene animations are paused.\nvar delegate: SKViewDelegate?\nA delegate that allows dynamic control of the view's render rate.\nprotocol SKViewDelegate\nMethods to take custom control over the view's render rate.\nvar frameInterval: Int\nThe number of frames that must pass before the scene is called to update its contents.\nDeprecated\nvar preferredFrameRate: Float\nDeprecated"
  },
  {
    "title": "Controlling User Interaction on Nodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/controlling_user_interaction_on_nodes",
    "html": "Overview\n\nSKNode subclasses UIResponder in iOS and tvOS, and NSResponder in macOS, allowing nodes to respond to user interaction events such as touches and mouse movements.\n\nThere are two strategies you can adopt when supporting user interaction.\n\nEnable user interaction on a single catch-all node, for example the scene, and calculate the child node or nodes that the user is interacting with by doing custom hit tests.\n\nEnable user interaction on every node you want the user to interact with, and subclass them to implement their responder functions.\n\nCatch All User Interaction by Using a Parent Node\n\nListing 1 shows an example of how to handle all user interaction on a parent node–in this case, the scene itself. The TouchScene class subclasses SKScene and overrides its isUserInteractionEnabled to return true.\n\nListing 1 A scene that responds to touches\nclass TouchScene: SKScene {\n    override var isUserInteractionEnabled: Bool {\n        get {\n            return true\n        }\n        set {\n            // ignore\n        }\n    }\n    \n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n        guard let touch = touches.first else {\n            return\n        }\n        \n        let location = touch.location(in: self)\n        \n        let touchedNodes = nodes(at: location)\n        let frontTouchedNode = atPoint(location).name\n    }\n}\n\n\nNote\n\nAlternatively, you could override sceneDidLoad() and set isUserInteractionEnabled to true in your implementation.\n\nThe overridden touchesBegan(_:with:) method shows two techniques to find the nodes that have been touched. nodes(at:) returns an array of all of the sprites and atPoint(_:) returns the top-most touched node.\n\nIn this example, the child nodes should have isUserInteractionEnabled set to false. The parent scene is responsible for responding to user interactions.\n\nListing 2 shows the equivalent code for macOS.\n\nListing 2 A scene that responds to mouse down\nclass TouchScene: SKScene {\n    override var isUserInteractionEnabled: Bool {\n        get {\n            return true\n        }\n        set {\n            // ignore\n        }\n    }\n    \n    override func mouseDown(with event: NSEvent) {\n        let location = event.location(in: self)\n        let touchedNodes = nodes(at: location)\n        let firstTouchedNode = atPoint(location).name\n    }\n}\n\n\nEnable User Interaction on All Nodes\n\nListing 3 shows an example of supporting user interaction on individual nodes in your scene. Instances of TouchSpriteNode are added as children of a standard scene and user interaction is handled by each independently.\n\nIn the case of overlapping nodes, only one will register a user interaction. For example, of two overlapping nodes, the one with the highest zPosition receives the touch. For two nodes with an equal zPosition, the last node in the parent's children array receives the touch.\n\nListing 3 A sprite node that responds to touches\nclass TouchSpriteNode: SKSpriteNode {\n    override var isUserInteractionEnabled: Bool {\n        set {\n            // ignore\n        }\n        get {\n            return true\n        }\n    }\n         \n    // For macOS replace this method with `mouseDown(with:)`\n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n        // User has touched this node\n    }\n}\n\n\nHandle User Interaction on Hidden Nodes by Using Alpha\n\nTranslucent nodes–those with an alpha of less than 1 but greater than 0–still receive user interactions. You can set a node's alpha to leastNonzeroMagnitude to make it effectively transparent and yet still respond to touches or mouse movements, although giving it a color of clear has the same effect.\n\nReview the Bounds of Node User Interaction\n\nUser interaction is based on the bounding box of the node. Sprite nodes containing textures with transparent areas or shape nodes with non-rectangular shapes will still report touches and mouse interactions even if the interaction is over a transparent part of their content.\n\nIf you build a composite node, the region that receives user interaction events is dependent on the node tree. Listing 4 shows the code used to create a subclassed SKNode that renders six circular shape nodes forming a larger circle.\n\nListing 4 A composite node that responds to touches\nclass TouchCompositeNode: SKNode {\n    override var isUserInteractionEnabled: Bool {\n        set {\n            // ignore\n        }\n        get {\n            return true\n        }\n    }\n    \n    let tau = CGFloat.pi * 2\n    \n    required init(color: SKColor, radius: CGFloat = 100) {\n        super.init()\n        \n        stride(from: 0, to: tau, by: tau / 6).forEach {\n            \n            let node = SKShapeNode(circleOfRadius: 20)\n            \n            node.fillColor = color\n            node.position = CGPoint(x: sin($0) * radius,\n                                    y: cos($0) * radius)\n            \n            addChild(node)\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    // For macOS replace this method with `mouseDown(with:)`\n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n        // User has touched this node\n    }\n}\n\n\n\n\nIf you were to add an instance of TouchCompositeNode to an SKScene with no other nodes behind it, all touches inside its calculateAccumulatedFrame() would be reported. Figure 1 shows the accumulated frame of TouchCompositeNode. Any user events within the dashed line will call touchesBegan(_:with:).\n\nFigure 1 User events reported inside a node's accumulated frame\n\nHowever, if you were to place an instance of TouchCompositeNode above another node using, for example, the code in Listing 5, only touches on its child nodes would be reported.\n\nListing 5 Placing a composite node over a background\nlet composite = TouchCompositeNode(color: .red)\ncomposite.position = CGPoint(x: 400, y: 400)\n     \nlet backgroundNode = SKSpriteNode(color: .blue,\n                                  size: CGSize(width: 500, height: 500))\nbackgroundNode.position = CGPoint(x: 400, y: 400)\n     \nscene.addChild(backgroundNode)\nscene.addChild(composite)\n\n\nIn this case, only touches or mouse events over the red spots shown in Figure 2 will call touchesBegan(_:with:).\n\nFigure 2 User events reported over a node's nontransparent content\n\nImportant\n\nNodes that have user interaction disabled will block touch and mouse events on nodes behind them where they overlap.\n\nSee Also\nHandling User Input\nvar isUserInteractionEnabled: Bool\nA Boolean value that indicates whether the node receives touch events.\nvar focusBehavior: SKNodeFocusBehavior\nThe focus behavior for a node."
  },
  {
    "title": "obstacles(fromNodePhysicsBodies:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483085-obstacles",
    "html": "Parameters\nnodes\n\nAn array of SKNode objects.\n\nReturn Value\n\nAn array of GKPolygonObstacle objects.\n\nDiscussion\n\nUse the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.\n\nSee Also\nAdding GameplayKit Behaviors\nvar entity: GKEntity?\nThe GameplayKit entity this node represents.\nclass func obstacles(fromNodeBounds: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming its bounds into the scene’s coordinate system.\nclass func obstacles(fromSpriteTextures: [SKNode], accuracy: Float) -> [GKPolygonObstacle]\nTurns each node into an obstacle by changing the node’s texture into a physics shape and converting it into the scene’s coordinate system."
  },
  {
    "title": "obstacles(fromSpriteTextures:accuracy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483134-obstacles",
    "html": "Parameters\nsprites\n\nAn array of SKNode objects.\n\naccuracy\n\nA floating point value between 0.001 and 1.0, inclusive. Higher values create a more precise (but more complex) representation of the obstacle.\n\nReturn Value\n\nAn array of GKPolygonObstacle objects.\n\nDiscussion\n\nUse the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.\n\nSee Also\nAdding GameplayKit Behaviors\nvar entity: GKEntity?\nThe GameplayKit entity this node represents.\nclass func obstacles(fromNodeBounds: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming its bounds into the scene’s coordinate system.\nclass func obstacles(fromNodePhysicsBodies: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming the node’s physics body shape into the scene’s coordinate system."
  },
  {
    "title": "isUserInteractionEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483109-isuserinteractionenabled",
    "html": "Discussion\n\nThe default value is false.\n\nImportant\n\nIn addition to setting isUserInteractionEnabled to true, you must subclass the node and define event callbacks in order to respond to user input.\n\nSee Also\nHandling User Input\nControlling User Interaction on Nodes\nEnable your node to respond to user input, like touches or mouse clicks.\nvar focusBehavior: SKNodeFocusBehavior\nThe focus behavior for a node."
  },
  {
    "title": "SKTransition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition",
    "html": "Overview\n\nScenes are the basic building blocks of games. Typically, you design self-contained scenes for the parts of your game, and then transition between these scenes as necessary. For example, you might create different scene classes to represent any or all of the following concepts:\n\nA loading scene to display while other content is loaded\n\nA main menu scene to choose what kind of game the user wants to play\n\nA scene to configure the details of the specific kind of game the user chose\n\nA scene that provides the gameplay\n\nA scene displayed when gameplay ends\n\nWhen you present a new scene in a view that is already presenting a scene, you have the option of using a transition to animate the change from the old scene to the new scene. Using a transition provides continuity so that the scene change is not quite so abrupt.\n\nTopics\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func fade(withDuration: TimeInterval) -> SKTransition\nCreates a transition that first fades to black and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition.\nPausing\nvar pausesIncomingScene: Bool\nA Boolean value that determines whether the incoming scene is paused during the transition.\nvar pausesOutgoingScene: Bool\nA Boolean value that determines whether the outgoing scene is paused during the transition.\nConstants\nenum SKTransitionDirection\nFor some transitions, the direction in which the transition is performed.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nSee Also\nDisplaying a Scene\nvar scene: SKScene?\nThe scene currently presented by this view.\nfunc presentScene(SKScene?)\nPresents a scene.\nfunc presentScene(SKScene, transition: SKTransition)\nTransitions from the current scene to a new scene."
  },
  {
    "title": "isPaused | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519654-ispaused",
    "html": "Discussion\n\nIf the value is true, the scene’s content is fixed onscreen. No actions are executed and no physics simulation is performed.\n\nWhen an application moves from an active to an inactive state, isPaused is automatically set to true. When an application returns to an active state, isPaused is automatically set to its previous value.\n\nSee Also\nControlling the Timing of a Scene's Rendering\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar delegate: SKViewDelegate?\nA delegate that allows dynamic control of the view's render rate.\nprotocol SKViewDelegate\nMethods to take custom control over the view's render rate.\nvar frameInterval: Int\nThe number of frames that must pass before the scene is called to update its contents.\nDeprecated\nvar preferredFrameRate: Float\nDeprecated"
  },
  {
    "title": "SKCropNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skcropnode",
    "html": "Overview\n\nSKCropNode is a container node that you use to crop other nodes in the scene. You add other nodes to a crop node and set the crop node's maskNode property. For example, here are some ways you might specify a mask:\n\nAn untextured sprite that limits content to a rectangular portion of the scene.\n\nA textured sprite that works as a precise per-pixel mask.\n\nA collection of child nodes that form a unique shape.\n\nYou can animate the shape or contents of the mask to implement interesting effects such as hiding or revealing.\n\nTip\n\nUse crop nodes sparingly. Because they require an additional offscreen memory buffer to perform the crop and add a rendering operation into the offscreen buffer, they add notably more overhead to the app.\n\nTopics\nFirst Steps\nCrop other nodes in the scene by adding them as child nodes to a crop node.\nCropping Nodes\nUse a texture or a shape to mask pixels out of a crop node's children.\nSetting the Mask Filter\nvar maskNode: SKNode?\nThe node used to determine the crop node’s mask.\nRelationships\nInherits From\nSKNode\nSee Also\nNodes that Modify Drawing\nclass SKEffectNode\nA node that renders its children into a separate buffer, optionally applying an effect, before drawing the final result.\nclass SKTransformNode\nA node that allows its children to rotate in 3D."
  },
  {
    "title": "scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483064-scene",
    "html": "Discussion\n\nIf the node is not embedded in a scene, the value is nil.\n\nSee Also\nAccessing Related Nodes\nAbout SpriteKit Coordinate Systems\nLearn how a node conforms to its coordinate systems.\nvar parent: SKNode?\nThe node’s parent node.\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "About SpriteKit Coordinate Systems | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/about_spritekit_coordinate_systems",
    "html": "Overview\n\nWhen a node is placed in the node tree, its position property places it within a coordinate system provided by its parent. SpriteKit uses the same coordinate system on both iOS and macOS.\n\nPoints as Position Units\n\nWhen a node is placed in the node tree, its position property places it within a coordinate system provided by its parent. SpriteKit uses the same coordinate system on both iOS and macOS. Figure 1 shows the SpriteKit coordinate system. Coordinate values are measured in points, as in UIKit or AppKit; where necessary, points are converted to pixels when the scene is rendered. A positive x coordinate goes to the right and a positive y coordinate goes up the screen.\n\nFigure 1 SpriteKit coordinate system\n\nPolar Coordinate Rotation\n\nSpriteKit also has a standard rotation convention. shows the polar coordinate convention. An angle of 0 radians specifies the positive x axis. A positive angle is in the counterclockwise direction.\n\nFigure 2 Polar coordinate conventions (rotation)\n\nNodes are rotated by setting their zRotation property to the required angle in radians. If you prefer to work in degrees, the following code shows how you can write an extension to CGFloat that converts between the two. The example in Listing 1 rotates spriteNode by 30 degrees counterclockwise.\n\nextension CGFloat {\n    func degreesToRadians() -> CGFloat {\n        return self * CGFloat.pi / 180\n    }\n}\n\n\nlet rabbitTexture = SKTexture(imageNamed: \"rabbit.png\")\n\n\nlet spriteNode = SKSpriteNode(texture: rabbitTexture)\n\n\nspriteNode.zRotation = CGFloat(30).degreesToRadians()\n\n\nSee Also\nAccessing Related Nodes\nvar scene: SKScene?\nThe scene node that contains this node.\nvar parent: SKNode?\nThe node’s parent node.\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "yScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483046-yscale",
    "html": "Discussion\n\nThe yScale property scales the height of the node and all of its descendants. The scale value affects how a node’s frame is calculated, its hit test area, how it is drawn, and other similar characteristics. The default value is 1.0.\n\nSee Also\nScaling and Rotating\nvar zRotation: CGFloat\nThe Euler rotation about the z axis (in radians).\nfunc setScale(CGFloat)\nSets the xScale and yScale properties of the node.\nvar xScale: CGFloat\nA scaling factor that multiplies the width of a node and its children.\nRelated Documentation\nvar frame: CGRect\nA rectangle in the parent’s coordinate system that contains the node’s content, ignoring the node’s children.\nfunc calculateAccumulatedFrame() -> CGRect\nReturns a rectangle in the parent’s coordinate system that contains the position and size of itself and all child nodes."
  },
  {
    "title": "calculateAccumulatedFrame() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483066-calculateaccumulatedframe",
    "html": "Discussion\n\nThe frame takes into the account the cumulative effect of the xScale, yScale, and zRotation properties of each node in the subtree.\n\nListing 1 shows how calculateAccumulatedFrame() can be used display the bounding box of a shape node. The child node, although smaller than its parent, is rotated by 30° so that its bounds extend beyond its parent's bounds. After childNode has been added to parentNode, a further shape node, boundingBoxNode, is created with its size based on the accumulated frame of parentNode.\n\nListing 1 Displaying the accumulated frame of a shape node\nlet parentNode = SKShapeNode(rectOf: CGSize(width: 500, height: 500))\nparentNode.lineWidth = 2\nparentNode.strokeColor = .blue\nparentNode.fillColor = .clear\n     \nlet childNode = SKShapeNode(rectOf: CGSize(width: 400, height: 400))\nchildNode.strokeColor = .red\nchildNode.fillColor = .clear\nchildNode.zRotation = -CGFloat.pi / 6 // pi / 6 = 30°\n     \nparentNode.addChild(childNode)\n     \nlet boundingBoxNode = SKShapeNode(rectOf: parentNode.calculateAccumulatedFrame().size)\nboundingBoxNode.lineWidth = 1\nboundingBoxNode.strokeColor = .black\nboundingBoxNode.fillColor = .clear\nboundingBoxNode.path = boundingBoxNode.path?.copy(dashingWithPhase: 0,\n                                                  lengths: [10,10])\n     \nparentNode.addChild(boundingBoxNode)\n\n\nFigure 1 shows the result of Listing 1 with parentNode rendered in blue, childNode rendered in red and the boundingBoxNode rendered with a dashed line.\n\nFigure 1 Displaying the accumulated frame of a shape node\n\nSee Also\nQuerying the Content Size\nvar frame: CGRect\nA rectangle in the parent’s coordinate system that contains the node’s content, ignoring the node’s children."
  },
  {
    "title": "frame | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483026-frame",
    "html": "Discussion\n\nThe frame is the smallest rectangle that contains the node’s content, taking into account the node’s xScale, yScale, and zRotation properties.\n\nSince SKNode does not draw content of its own, its frame size is arbitrary; it's the visual subclasses of SKNode that do draw that define the frame's size with a meaningful value that encloses its visual content.\n\nTo get a rect that encloses all the child nodes of an SKNode parent object, use calculateAccumulatedFrame().\n\nSee Also\nQuerying the Content Size\nfunc calculateAccumulatedFrame() -> CGRect\nReturns a rectangle in the parent’s coordinate system that contains the position and size of itself and all child nodes."
  },
  {
    "title": "init(coder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483142-init",
    "html": "See Also\nFirst Steps\nGetting Started with Nodes\nLearn about the fundamental properties that provide a foundation for all other nodes.\ninit()\nInitializes a blank node.\ninit?(fileNamed: String)\nCreates a new node by loading an archive file from the game’s main bundle.\ninit(fileNamed: String, securelyWithClasses: Set<AnyHashable>)"
  },
  {
    "title": "init(fileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483083-init",
    "html": "Parameters\nfilename\n\nThe name of the file, without a file extension. The file must be in the app’s main bundle and have a .sks filename extension.\n\nReturn Value\n\nThe unarchived node object.\n\nDiscussion\n\nIf you call this method on a subclass of the SKScene class and the object in the archive is an SKScene object, the returned object is initialized as if it is a member of the subclass. You use this behavior to create scene layouts in the Xcode Editor and provide custom behaviors in your subclass.\n\nSee Also\nFirst Steps\nGetting Started with Nodes\nLearn about the fundamental properties that provide a foundation for all other nodes.\ninit()\nInitializes a blank node.\ninit?(coder: NSCoder)\nCalled when a node is initialized from an .sks file.\ninit(fileNamed: String, securelyWithClasses: Set<AnyHashable>)"
  },
  {
    "title": "preloadTextureAtlases(_:withCompletionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/1427379-preloadtextureatlases",
    "html": "Parameters\ntextureAtlases\n\nAn array of SKTextureAtlas objects.\n\ncompletionHandler\n\nA block called after all of the texture atlases are loaded.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func preloadTextureAtlases(_ textureAtlases: [SKTextureAtlas]) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSpriteKit creates a background task that loads the texture data from all of the specified atlas objects. Then, SpriteKit returns control to your game. After the atlas objects are loaded, your completion handler is called.\n\nSee Also\nPreloading Textures\nfunc preload(completionHandler: () -> Void)\nLoads an atlas object’s textures into memory, calling a completion handler after the task completes.\nclass func preloadTextureAtlasesNamed([String], withCompletionHandler: (Error?, [SKTextureAtlas]) -> Void)\nLoads the textures of multiple atlases into memory, calling a completion handler after the task completes."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483097-init",
    "html": "See Also\nFirst Steps\nGetting Started with Nodes\nLearn about the fundamental properties that provide a foundation for all other nodes.\ninit?(fileNamed: String)\nCreates a new node by loading an archive file from the game’s main bundle.\ninit?(coder: NSCoder)\nCalled when a node is initialized from an .sks file.\ninit(fileNamed: String, securelyWithClasses: Set<AnyHashable>)"
  },
  {
    "title": "init(dictionary:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/1427383-init",
    "html": "Parameters\nproperties\n\nA dictionary that defines which textures are to be merged into the atlas.\n\nReturn Value\n\nA new texture atlas object.\n\nDiscussion\n\nNormally, Xcode creates texture atlases at compile time from the image files included in your project. These atlases are compiled and installed inside the app bundle. However, sometimes the assets needed to create a texture atlas are not available at compile time. For example, those assets might be procedurally generated or downloaded from the network. However, you still want the benefit of texture atlases to reduce the number of state changes required in the hardware. You can use this method to generate an atlas object at runtime. This is a potentially expensive operation best performed when your game loop is not running.\n\nThe keys in the dictionary represent the names of the individual textures. The associated object for each key can be:\n\nAn NSString object that contains a file system path to a file that contains the texture\n\nAn NSURL object that contains a file system path to a file that contains the texture\n\nA UIImage object\n\nAn NSImage object\n\nSee Also\nCreating a Texture Atlas Programmatically\ninit(named: String)\nCreates a texture atlas from data stored in the app bundle."
  },
  {
    "title": "preload(completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1520172-preload",
    "html": "Parameters\ncompletionHandler\n\nA block called after the texture data is loaded.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc preload() async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSpriteKit creates a background task to load the texture data from the associated file, then returns control to your game. After the texture data is loaded, your completion handler is called. Typically, you use this method when you want to guarantee that a particular texture is in memory before accessing it.\n\nIf you need to preload multiple textures at once, use the preload(_:withCompletionHandler:) method instead.\n\nSee Also\nPreloading a Texture for Performance\nPreloading Textures into Memory\nDecompress images ahead of time to avoid performance issues during gameplay.\nclass func preload([SKTexture], withCompletionHandler: () -> Void)\nLoad the data of multiple textures into memory."
  },
  {
    "title": "About Texture Atlases | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/about_texture_atlases",
    "html": "Overview\n\nIn most cases, a SpriteKit texture atlas is created automatically by the Xcode build system after you put multiple images in an .atlas file in the app bundle. Then, you access those images at runtime using textureNamed(_:).\n\nThe benefits are:\n\nMinimized bundle size.\n\nMaximized runtime perfomance when rendering more than one of the atlas's textures at the same time, because SpriteKit is able to effectively render them at the same time.\n\nCreating a Texture Atlas\n\nYou create texture atlases using Xcode. Add a folder with the .atlas extension to your project and place the artwork to be included in the atlas inside this folder. Xcode builds a texture atlas from the artwork and adds it to the app bundle. The format for a compiled texture atlas is private and subject to change.\n\nFor more information about creating texture atlases, see Use texture atlases to improve performance.\n\nLoading Textures from a Texture Atlas\n\nCreating a texture using init(imageNamed:) will create a new SKTexture object from an image file in a texture atlas if one is available.\n\nSpriteKit searches first for an image file with the specified filename. If it doesn’t find one, it searches inside any texture atlases built into the app bundle. This means that you don’t have to make any coding changes to support this in your game. This design also offers your artists the ability to experiment with new textures without requiring that your game be rebuilt. The artists drop the textures into the app bundle. When the app is relaunched, SpriteKit automatically discovers the textures (overriding any previous versions built into the texture atlases). When the artists are satisfied with the textures, you then add those textures to the project and bake them into your texture atlases.\n\nIf you want to explicitly work with texture atlas objects, use the SKTextureAtlas class. First, create a texture atlas object using the name of the atlas. Next, use the names of the image files stored in the atlas to look up the individual textures. The following code shows an example. It uses a texture atlas that holds multiple frames of animation for a monster, and shows how to create textures from those frames and store them in an array. In the actual project, you would add a monster.atlas folder with the four image files.\n\nlet atlas = SKTextureAtlas(named: \"monster\")\nlet f1 = atlas.textureNamed(\"monster-walk1.png\")\nlet f2 = atlas.textureNamed(\"monster-walk2.png\")\nlet f3 = atlas.textureNamed(\"monster-walk3.png\")\nlet f4 = atlas.textureNamed(\"monster-walk4.png\")\nlet monsterWalkTextures = [f1, f2, f3, f4]\n\n\nWhether your project uses a texture atlas or a sprite atlas, the code used to load assets is identical.\n\nCreating a Texture Atlas at Runtime\n\nProvide a dictionary that points to the various image files that should be part of the atlas. The following code shows how you can create an SKTextureAtlas object using the init(dictionary:) from three image files. The initializer doesn’t allow for optional values in the dictionary, so a guard statement is used to ensure that all of the images exist.\n\nguard let pandaImage = UIImage(named: \"panda.png\"),\n    let monkeyImage = UIImage(named: \"monkey.png\"),\n    let rabbitImage = UIImage(named: \"rabbit.png\") else {\n        print(\"unable to resolve all images\")\n        return\n}  \nlet textureAtlas = SKTextureAtlas(dictionary: [\"panda\": pandaImage,\n                                               \"monkey\": monkeyImage,\n                                               \"rabbit\": rabbitImage])\n\n\nCreating a Sprite Atlas\n\nA sprite atlas offers the advantages of a texture atlas with the management functionality of an asset catalog. For example, if you supply assets with different resolutions for different devices, sprite atlases support app thinning, and your users will only download the required images.\n\nYou create a sprite atlas using Xcode. First add a new asset catalog to your project; see Add files and folders to a project. Then, inside the new asset catalog, add a new sprite atlas.\n\nThe process is described in detail in Create asset catalogs and sets. In this document, the term texture atlas can refer to either a sprite atlas or a texture atlas.\n\nDeciding on Texture Count and Size\n\nTo get the most out of a texture atlas, pack it full of textures you'll be using simultaneously. But be aware that you need a balance between too many textures and too few.\n\nIf you include too many images, large amounts of texture data may need to be loaded into memory simultaneously.\n\nWith a common maximum texture size of 4,096 x 4,096 pixels, the build system will ideally fit all of your source textures into one destination texture. The build system may need to disperse your source textures across multiple destinations textures depending on the count and size of your source textures.\n\nIf you use too few images, you won't be getting the most out of the texture atlas's batch rendering ability.\n\nExperiment with different configurations of your texture atlases and choose the combination that gives you the best performance. Xcode builds the atlases for you, so you can switch between different atlas configurations with relative ease."
  },
  {
    "title": "init(named:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/1427381-init",
    "html": "Parameters\nname\n\nThe name of the texture atlas, without the .atlas extension.\n\nReturn Value\n\nA new texture atlas object.\n\nDiscussion\n\nIf the texture atlas cannot be found, an exception is thrown.\n\nSee Also\nCreating a Texture Atlas Programmatically\ninit(dictionary: [String : Any])\nCreates a texture atlas from a set of image files.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "textureNamed(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/1427375-texturenamed",
    "html": "Parameters\nname\n\nThe name of a texture stored in the atlas object.\n\nReturn Value\n\nThe SpriteKit texture associated with the name. If the specified image does not exist in the atlas object, SpriteKit returns a placeholder texture image.\n\nSee Also\nRelated Documentation\nvar textureNames: [String]\nThe names of the texture images stored in the atlas."
  },
  {
    "title": "SKTileMapNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilemapnode",
    "html": "Overview\n\nSKTileMapNode does the work of laying out predefined tiles in a grid of any size. Typically, you configure 9-slice images (tile groups) in Xcode's SpriteKit scene editor and paint the look of your tile map ahead of time versus configuring the tile map in code.\n\nAs with sprite nodes, you can layer tile maps with different blend modes or control it with actions and physics, for example, for the purpose of parallax scrolling. The rendered tile map can be post processed with an SKShader to add effects such as motion blur or atmospheric perspective.\n\nNote\n\nA tile map can only render tile definitions that exist within the SKTileSet you have provided it.\n\nImportant\n\nA tile map does not expose its tiles as nodes, and therefore you cannot assign individual tiles with a different zPosition or physicsBody. Instead, layer tile map nodes on top of each other at the varying zPositions, and layer invisible SKNodes on top of the tile map node to attach physicsBodies to your tile map node.\n\nTo work with a tile map programmatically, you supply SKTileMapNode with a tile set that defines the tile definitions it can render. Then, fill each tile in the tile map with the fill(with:) method and set individual tiles with setTileGroup(_:andTileDefinition:forColumn:row:).\n\nTopics\nCreating a Tile Map Programmatically\nCreate a tile map manually instead of loading it from an archived .sks file.\nCreating a Tile Map Programmatically\nControlling a Tile Map's On-Screen Position Relative to its Origin\nvar anchorPoint: CGPoint\nDefines the point in the tile map that corresponds to its position.\nReading or Manually Configuring the Tile Map's Size\nvar tileSize: CGSize\nThe size of each tile in points.\nvar tileSet: SKTileSet\nThe tile set being used by this tile map. The tile map object can only display tiles that exist in this set.\nvar numberOfColumns: Int\nThe number of columns in the tile map\nvar numberOfRows: Int\nThe number of rows in the tile map.\nQuerying the Tile Map's Properties\nfunc centerOfTile(atColumn: Int, row: Int) -> CGPoint\nfunc tileColumnIndex(fromPosition: CGPoint) -> Int\nfunc tileDefinition(atColumn: Int, row: Int) -> SKTileDefinition?\nfunc tileGroup(atColumn: Int, row: Int) -> SKTileGroup?\nfunc tileRowIndex(fromPosition: CGPoint) -> Int\nReturns the tile map node object’s tile row index for the specified position in points.\nvar mapSize: CGSize\nThe overall size of the tile map.\nTinting a Tile Map\nvar color: UIColor\nThe base color for the tile map. The influence of the color over the tile map node’s textures is controlled by colorBlendFactor.\nvar colorBlendFactor: CGFloat\nControls the blending between the texture and the tile map object’s color. Values are clamped between zero and one where zero has no color blending and one has the maximum color blending.\nLighting a Tile Map\nConfigure how a sprite is lit when its near a light node.\nvar lightingBitMask: UInt32\nA mask that defines how the tile map is lit by light nodes in the scene.\nConfiguring How Alpha Values Blend the Sprite\nChange how a sprite uses its alpha value, such as additive blending, that results in the sprite being brighter than it was before.\nvar blendMode: SKBlendMode\nDefines the blend mode to use when compositing the tile map over other nodes.\nWorking with Custom Shaders\nvar shader: SKShader?\nDefines a shader which is applied to each tile of the tile map.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute.\nRelationships\nInherits From\nSKNode\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nTiling\nclass SKTileDefinition\nA single tile that can be repeated in a tile map.\nclass SKTileGroup\nA set of tiles that collectively define one type of terrain.\nclass SKTileGroupRule\nRules that describe how various tiles should be placed in a map.\nclass SKTileSet\nA container for related tile groups."
  },
  {
    "title": "init(lowerLimit:upperLimit:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange/1520307-init",
    "html": "Parameters\nlower\n\nThe minimum value for the range.\n\nupper\n\nThe maximum value for the range.\n\nReturn Value\n\nA newly initialized range object.\n\nSee Also\nCreating a Range Object\ninit(value: CGFloat, variance: CGFloat)\nCreates and initializes a new range object using a value and a maximum distance from that value.\nclass func withNoLimits() -> Self\nCreates and initializes a new range object that encompasses all possible values.\ninit(lowerLimit: CGFloat)\nCreates and initializes a new range object that specifies only a minimum value.\ninit(upperLimit: CGFloat)\nCreates and initializes a new range object that specifies only a maximum value.\ninit(constantValue: CGFloat)\nCreates and initializes a new range object that specifies a constant value."
  },
  {
    "title": "enumerateChildNodes(withName:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483024-enumeratechildnodes",
    "html": "Parameters\nname\n\nThe name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.\n\nblock\n\nA block to execute on nodes that match the name parameter. The block has the signature (node: SKNode, stop: UnsafeMutablePointer<ObjCBool>).\n\nDiscussion\n\nThis method enumerates the child array in order, searching for nodes whose names match the search parameter. The block is called once for each node that matches the name parameter.\n\nThe following code shows how you could enumerate through the child nodes of a scene with a name containing the string yellow. Each matching node is hidden until the enumeration finds a node that also contains the string triangle. When this node is reached, stop is set to true and the processing stops.\n\nListing 1 Enumerating child nodes\nscene.enumerateChildNodes(withName: \"*yellow*\") {\n    (node, stop) in\n    \n    node.run(SKAction.hide())\n    \n    if let name = node.name, name.contains(\"triangle\") {\n        stop.initialize(to: true)\n    }\n}\n\n\nYou can also search by class name using enumerateChildNodes(withName:using:). However, for custom classes, you need to specify the fully annotated class name (i.e. the project name followed by the class name). The following code shows a custom class, SpaceshipNode, based on SKSpriteNode, and created in a project named SpaceGame. The first search fails to return an instance of SpaceshipNode added as a child of parentNode:\n\nListing 2 Enumerating child nodes\nclass SpaceshipNode: SKSpriteNode {\n}\n     \nlet parentNode = SKNode()\nlet childNode = SpaceshipNode()\nparentNode.addChild(childNode)\n     \nparentNode.enumerateChildNodes(withName: \"SpaceshipNode\") {\n    node, _ in\n    // Unannotated name, returns no results \n}\n     \nparentNode.enumerateChildNodes(withName: \"SpaceGame.SpaceshipNode\") {\n    node, _ in\n    // Annotated name, successfully returns `childNode` \n}\n     \nparentNode.enumerateChildNodes(withName: \"SKSpriteNode\") {\n    node, _ in\n    // Superclass name, successfully returns `childNode` \n}\n\n\nSee Also\nAccessing Nodes by Name\nSearching the Node Tree\nAccess nodes by name to avoid needing an instance variable.\nvar name: String?\nThe node’s assignable name.\nfunc childNode(withName: String) -> SKNode?\nSearches the children of the receiving node for a node with a specific name.\nsubscript(String) -> [SKNode]\nReturns an array of nodes that match the name parameter."
  },
  {
    "title": "childNode(withName:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483060-childnode",
    "html": "Parameters\nname\n\nThe name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.\n\nReturn Value\n\nIf a node object with that name is found, the method returns the node object. Otherwise, it returns nil.\n\nDiscussion\n\nIf more than one child share the same name, the first node discovered is returned.\n\nSee Also\nAccessing Nodes by Name\nSearching the Node Tree\nAccess nodes by name to avoid needing an instance variable.\nvar name: String?\nThe node’s assignable name.\nfunc enumerateChildNodes(withName: String, using: (SKNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nSearches the children of the receiving node to perform processing for nodes that share a name.\nsubscript(String) -> [SKNode]\nReturns an array of nodes that match the name parameter."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483136-name",
    "html": "Discussion\n\nThis property is used to identify a node in other parts of your game logic. For example, you might use this name as part of collision testing. You can also search for nodes in a tree by their name.\n\nWhen choosing a name for a node, decide whether each node gets a unique name or whether some nodes will share a common name. If you give the node a unique name, you can find the node later by calling the childNode(withName:) method. If a name is shared by multiple nodes, the name usually means that these are all a similar object type in your game. In this case, you can iterate over those objects by calling the enumerateChildNodes(withName:using:) method.\n\nSee Also\nAccessing Nodes by Name\nSearching the Node Tree\nAccess nodes by name to avoid needing an instance variable.\nfunc childNode(withName: String) -> SKNode?\nSearches the children of the receiving node for a node with a specific name.\nfunc enumerateChildNodes(withName: String, using: (SKNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nSearches the children of the receiving node to perform processing for nodes that share a name.\nsubscript(String) -> [SKNode]\nReturns an array of nodes that match the name parameter."
  },
  {
    "title": "fade(withDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransition/1395907-fade",
    "html": "Parameters\nsec\n\nThe duration of the transition.\n\nReturn Value\n\nA new transition.\n\nSee Also\nCreating Transitions\nTransitioning Between Two Scenes\nConfiguring Whether Animations Play During the Transition\nclass func crossFade(withDuration: TimeInterval) -> SKTransition\nCreates a cross fade transition.\nclass func doorsCloseHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing horizontal doors.\nclass func doorsCloseVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of closing vertical doors.\nclass func doorsOpenHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening horizontal doors.\nclass func doorsOpenVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the new scene appears as a pair of opening vertical doors.\nclass func doorway(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the previous scene disappears as a pair of opening doors.\nclass func fade(with: UIColor, duration: TimeInterval) -> SKTransition\nCreates a transition that first fades to a constant color and then fades to the new scene.\nclass func flipHorizontal(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a horizontal line running through the center of the view.\nclass func flipVertical(withDuration: TimeInterval) -> SKTransition\nCreates a transition where the two scenes are flipped across a vertical line running through the center of the view.\nclass func moveIn(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in on top of the old scene.\nclass func push(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the new scene moves in, pushing the old scene out of the view.\nclass func reveal(with: SKTransitionDirection, duration: TimeInterval) -> SKTransition\nCreates a transition where the old scene moves out of the view, revealing the new scene underneath it.\ninit(ciFilter: CIFilter, duration: TimeInterval)\nCreates a transition that uses a Core Image filter to perform the transition."
  },
  {
    "title": "speed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction/1417718-speed",
    "html": "Discussion\n\nThe speed factor adjusts how fast an action’s animation runs. For example, a speed factor of 2.0 means the animation runs twice as fast.\n\nSee Also\nControlling Action Timing\nConfiguring Action Timing\nTime an action in a scene, by adding or modifying timing properties, or cancel an action.\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar timingMode: SKActionTimingMode\nA setting that controls the speed curve of an animation.\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\nvar timingFunction: SKActionTimingFunction\nA block used to customize the timing function.\ntypealias SKActionTimingFunction\nThe signature for the custom timing block."
  },
  {
    "title": "region | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519551-region",
    "html": "Discussion\n\nA field node applies its effect to all physics bodies that are partially or completely inside its region. The default value is a region of infinite size.\n\nSee Also\nDetermining Which Physics Bodies Are Affected by the Field\nvar isEnabled: Bool\nA Boolean value that indicates whether the field is active.\nvar isExclusive: Bool\nA Boolean value that indicates whether the field node should override all other field nodes that might otherwise affect physics bodies.\nvar minimumRadius: Float\nThe minimum value for distance-based effects.\nvar categoryBitMask: UInt32\nA mask that defines which categories this field belongs to."
  },
  {
    "title": "isExclusive | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520365-isexclusive",
    "html": "Discussion\n\nIf the value is set to true and a physics body is within this field’s region, all other field nodes that might otherwise affect this body are ignored. The default value is false.\n\nIf you set this property to true on multiple field nodes within a scene, their regions should not overlap. If they do, the results are undefined.\n\nSee Also\nDetermining Which Physics Bodies Are Affected by the Field\nvar isEnabled: Bool\nA Boolean value that indicates whether the field is active.\nvar region: SKRegion?\nThe area (relative to the node’s origin) that the field affects.\nvar minimumRadius: Float\nThe minimum value for distance-based effects.\nvar categoryBitMask: UInt32\nA mask that defines which categories this field belongs to."
  },
  {
    "title": "reachConstraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483019-reachconstraints",
    "html": "Discussion\n\nTo use inverse kinematics, create a new SKReachConstraints object and assign it to this property. When a reach action calculates the new positions of this node, the possible values for this node are restricted to the constraints defined by this object. For more information on the inverse kinematic actions, see SKAction.\n\nSee Also\nConstraining Node Position or Rotation\nvar constraints: [SKConstraint]?\nA list of constraints to apply to the node."
  },
  {
    "title": "Maximizing Node Drawing Performance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/nodes_for_scene_building/maximizing_node_drawing_performance",
    "html": "Overview\n\nAs a high-level graphics framework, you configure your scene by laying out nodes, and SpriteKit builds the Metal draw calls for you that actually render the content. Thus, you have little control over the amount of low-level graphics work that SpriteKit does, but this article gives you hints that can speed up SpriteKit's efforts.\n\nShow Draw Count\n\nEach draw call is an expensive operation; the more graphical elements you can pack into a single draw, the faster your scene can be rendered, and thus the higher frames per second it can achieve.\n\nYou can see the number of draw calls it's taking to render your scene live on the SKView by enabling showsDrawCount.\n\nIn general, all scene nodes can be rendered in a single draw call that came from the same SKTexture, for example:\n\nSprite nodes that use the same SKTexture\n\nSprite nodes whose texture specifies a subrectangle of the same texture through the SKTexture init(rect:in:).\n\nIn general, all nodes can be rendered in a single draw call that came from the same SKTextureAtlas using textureNamed(_:).\n\nImportant\n\nNode zPosition impacts draw call count because, generally, nodes at different zPositions must be rendered on a subsequent pass. For example, nodes that overlap each other must be done in separate draw calls. Overlapping nodes at the same zPosition can be rendered in the same draw call if you enable the SKView ignoresSiblingOrder property.\n\nFor all other SpriteKit nodes that draw, pay attention to the showsDrawCount statistic as you develop your app to gain an understanding of which configurations affect draw count.\n\nShow Node Count\n\nThe number of nodes in your scene relates to the number of draw calls. Therefore, minimizing the number of nodes in your scene is a good practice to keep the draw call count down. Showing the node count in your scene is done through the SKView showsNodeCount property.\n\nThe number of nodes in your scene can also affect performance if you enumerate all of your nodes within the update life cycle. While the SKView shouldCullNonVisibleNodes property can prune offscreen nodes out of an issued draw call, SpriteKit must still enumerate all nodes in your scene to figure out which ones are offscreen, and this is an expensive operation. As a result, eliminating offscreen nodes yourself by using removeFromParent() is the fastest way to cull nonvisible nodes. Once a node is removed from the node tree, SpriteKit no longer needs to consider whether it's onscreen or offscreen every frame.\n\nSee Also\nNodes that Draw\nclass SKSpriteNode\nAn image or solid color.\nclass SKShapeNode\nA mathematical shape that can be stroked or filled.\nclass SKEmitterNode\nA source of various particle effects.\nclass SKLabelNode\nA graphical element that draws text.\nclass SKVideoNode\nA graphical element that plays video content.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SK3DNode\n3D SceneKit content drawn as a flattened sprite."
  },
  {
    "title": "Preloading Textures into Memory | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/preloading_textures_into_memory",
    "html": "Overview\n\nA major advantage to SpriteKit is that it performs a lot of memory management for you automatically. When rendering a new frame of animation, SpriteKit determines whether a texture is needed to render the current frame. If a texture is needed but is not prepared for rendering, SpriteKit loads the texture data from the file, transforms the data into a format that the graphics hardware can use, and uploads it to the graphics hardware.\n\nThis process happens automatically in the background, but it isn’t free. If too many unloaded textures are needed at once, it may be impossible to load all the textures in a single frame of animation, causing the frame rate to stutter. To avoid this problem, you need to preload textures into memory, particularly in larger or complex games.\n\nPreload Texture Objects\n\nListing 1 shows how to preload an array of SKTexture objects. The preload(_:withCompletionHandler:) method calls the completion handler after all of the textures are loaded into memory. In this example, all of the textures for a particular level of the game are preloaded in a single operation. When the textures are all in memory, the completion handler is called. It creates the scene and presents it. (You need to add code to provide these texture objects to the scene; that code isn’t shown here).\n\nSKTexture.preload(textureArrayForLevel1) {\n    // The textures are loaded into memory. Start the level.\n    let gameScene = GamePlayScene(size: CGSize(width: 768, height: 1024))\n    \n    if let spriteView = view as? SKView {\n        spriteView.presentScene(gameScene)\n    }\n}\n\n\nChoose a Time to Preload\n\nBecause you are intimately familiar with the design of your game or app, you are the best person to know when new textures are needed. The exact design of your preloading code is going to depend on your game engine. Here are a few possible designs to consider:\n\nFor a small game or app, you may be able to preload all of its textures when the app is launched, and then keep them in memory forever.\n\nFor a larger game or app, you may need to split the textures into levels or themes. Each level or theme’s textures are designed to fit in a specific amount of memory. When the player starts a new level, you preload all of that level’s texture objects. When the player finishes playing the level, the textures not needed for the next level are discarded. When you preload levels, the load time is all up front, before gameplay starts.\n\nIf a game needs more textures than can fit into memory, you need to preload textures dynamically as the game is being played. Typically, you preload some textures at the start of a level, and then load other textures when you think they will be needed soon. For example, in a racing game, the player is always moving in the same direction, so for each frame you might fetch a new texture for content the player is about to see. The textures are loaded in the background, displacing the oldest textures for the track. In an adventure game that allows for player-controlled movement, you might have to provisionally load textures when a player is moving in a particular direction.\n\nSee Also\nPreloading a Texture for Performance\nfunc preload(completionHandler: () -> Void)\nLoad texture data into memory, calling a completion handler after the task completes.\nclass func preload([SKTexture], withCompletionHandler: () -> Void)\nLoad the data of multiple textures into memory."
  },
  {
    "title": "SKConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skconstraint",
    "html": "Overview\n\nAn SKConstraint object describes a mathematical constraint on a node’s position or orientation. You attach constraints to nodes; after a scene processes any actions and physics interactions, it applies constraints attached to nodes in its node tree. Use constraints to ensure that certain relationships are true before the system renders a scene. For example, you might use a constraint to:\n\nChange a node’s zRotation property so that it always points at another node or a position in the scene.\n\nKeep a node within a specified distance of another node or a point in the scene.\n\nKeep a node inside a specified rectangle.\n\nRestrict the zRotation property of a node so that it has a more limited rotation range of motion.\n\nTo use constraints, create an NSArray object that contains one or more constraint objects and assign the array to a node’s constraints property. When the system evaluates a scene, it executes the constraints on a node in the order they appear in the constraints array.\n\nYou can’t change a constraint after you create it. However, you can selectively disable or enable a constraint by setting its enabled property. You can also use the referenceNode property to convert positions to the referenced coordinate system before applying the constraint.\n\nTopics\nCreating Position Constraints\nLimit a node's movement in one axis or both.\nCreating Position Constraints\nCreate a position constraint and add it to a node.\nclass func positionX(SKRange, y: SKRange) -> Self\nCreates a constraint that restricts both coordinates of a node’s position.\nclass func positionX(SKRange) -> Self\nCreates a constraint that restricts the x-coordinate of a node’s position.\nclass func positionY(SKRange) -> Self\nCreates a constraint that restricts the y-coordinate of a node’s position.\nCreating Orientation Constraints\nProvide limitations on a node's rotation, or create rules the system uses to update a node's rotation for you.\nCreating a Look-At Constraint\nMake a node automatically rotate itself based on the changing position of another node, by using orientation constraints.\nclass func orient(to: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face another node.\nclass func orient(to: CGPoint, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a fixed point.\nclass func orient(to: CGPoint, in: SKNode, offset: SKRange) -> Self\nCreates a constraint that forces a node to rotate to face a point in another node’s coordinate system.\nclass func zRotation(SKRange) -> Self\nCreates a constraint that limits the orientation of a node.\nCreating Distance Constraints\nCreate a rule the system uses to update a node's position relative to another node in the scene.\nclass func distance(SKRange, to: SKNode) -> Self\nCreates a constraint that keeps a node within a certain distance of another node.\nclass func distance(SKRange, to: CGPoint) -> Self\nCreates a constraint that keeps a node within a certain distance of a point.\nclass func distance(SKRange, to: CGPoint, in: SKNode) -> Self\nCreates a constraint that keeps a node within a certain distance of a point in another node’s coordinate system.\nControlling the Coordinate System Where a Constraint is Applied\nvar referenceNode: SKNode?\nThe node whose coordinate system should be used to apply the constraint.\nEnabling and Disabling a Constraint\nvar enabled: Bool\nA Boolean value that specifies whether the constraint is applied.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nConstraints\nclass SKReachConstraints\nA specification of the degree of freedom when solving inverse kinematics."
  },
  {
    "title": "SKAction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaction",
    "html": "Overview\n\nSKAction is an animation that is executed by a node in the scene. Actions are used to change a node in some way (like move its position over time), but you can also use actions to change the scene, like doing a fadeout. When the scene processes its nodes, the actions associated with those nodes are processed.\n\nTopics\nFirst Steps\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nAction Initializers\nUse these functions to create actions.\nControlling Action Timing\nConfiguring Action Timing\nTime an action in a scene, by adding or modifying timing properties, or cancel an action.\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar timingMode: SKActionTimingMode\nA setting that controls the speed curve of an animation.\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\nvar timingFunction: SKActionTimingFunction\nA block used to customize the timing function.\ntypealias SKActionTimingFunction\nThe signature for the custom timing block.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs.\nUsing Action Names\nControlling Actions Precisely by Using Names\nSet an action's name property so you can access it later without needing an instance variable.\nObserving Live Changes\nDetecting Changes at Each Step of an Animation\nGet notified of a property change on your node subclass and retrieve the amount of change.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nAnimation\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit."
  },
  {
    "title": "SKTextureFilteringMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexturefilteringmode",
    "html": "Topics\nConstants\ncase nearest\nEach pixel is drawn using the nearest point in the texture. This mode is faster, but the results are often pixelated.\ncase linear\nEach pixel is drawn by using a linear filter of multiple texels in the texture. This mode produces higher quality results but may be slower.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring a Texture's Behavior for Scaling\nvar filteringMode: SKTextureFilteringMode\nThe filtering mode used when the size of a sprite drawn with the texture is not drawn at the texture’s native size.\nvar usesMipmaps: Bool\nA Boolean value that indicates whether the texture attempts to generate mipmaps."
  },
  {
    "title": "Requesting the OpenGL Renderer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/requesting_the_opengl_renderer",
    "html": "Overview\n\nBy default, SpriteKit renders with Metal in iOS 9 and OS X 10.11, but you can request the OpenGL renderer by adding the PrefersOpenGL key to your app's Info.plist and giving it a boolean value of YES.\n\nImportant\n\nThis key applies to SceneKit content, too. So if your app uses SceneKit within SpriteKit, or displays SceneKit content on its own, that content will also be affected by this key.\n\nDisplaying the Currently Active Renderer\n\nSpriteKit migrated from being implemented in OpenGL to Metal in iOS 9, but there are still situations where the OpenGL renderer might be active, for example:\n\nApps that have specifically requested the OpenGL renderer. See (requesting the OpenGL renderer)\n\nApps running on an iOS device that does not support Metal\n\nIn these situations, it might be handy to see which renderer is active at run time. The following code listing shows the code to do that:\n\n// Get the standard user defaults\nlet defaults = UserDefaults.standard\n\n\n// Create a new string-keyed dictionary of any value type\nvar dict = [String:Any]()\n\n\n// Set the SKContextType debug draw statistics to true\ndict[\"debugDrawStats_SKContextType\"] = true\n\n\n// Supply the dictionary with the SpriteKit defaults key\ndefaults.set( dict, forKey: \"SKDefaults\" )        \n\n\nNote\n\nYou should add this code within your app's initialization code."
  },
  {
    "title": "filteringMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519659-filteringmode",
    "html": "Discussion\n\nThe possible values for this property are listed in SKTextureFilteringMode. The default value is SKTextureFilteringMode.linear where each pixel is drawn by using a linear filter of multiple texels in the texture. The other option is SKTextureFilteringMode.nearest where each pixel is drawn using the nearest point in the texture.\n\nThe figure below shows the effect of different filtering modes. The rabbit texture (original on left) has been scaled up five times. Node 1 has been scaled using SKTextureFilteringMode.nearest and node 2 has been scaled with SKTextureFilteringMode.linear.\n\nFigure 1 The effect of filtering modes on a scaled texture\n\nSee Also\nConfiguring a Texture's Behavior for Scaling\nenum SKTextureFilteringMode\nTexture filtering modes to use when the texture is drawn in a size other than its native size.\nvar usesMipmaps: Bool\nA Boolean value that indicates whether the texture attempts to generate mipmaps."
  },
  {
    "title": "textureRect() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519707-texturerect",
    "html": "Return Value\n\nA rectangle in the unit coordinate space.\n\nDiscussion\n\nThe default value is a rectangle that covers the entire texture (0,0) - (1,1). You cannot set this value directly; to use only a portion of a texture, use the init(rect:in:) method to create a new texture.\n\nSee Also\nReading a Texture's Size and Optional Source Location\nfunc size() -> CGSize\nGets the size of the texture.\nRelated Documentation\ninit(rect: CGRect, in: SKTexture)\nCreates a new texture from a sub-rectangle of an existing texture."
  },
  {
    "title": "usesMipmaps | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519960-usesmipmaps",
    "html": "Discussion\n\nThe default value is false. If you set this to true, Sprite Kit creates mipmaps for the texture when it prepares the texture for rendering. Mipmaps take up additional memory (usually one-third more) but can improve rendering quality and performance when the texture is reduced in size (such as when you reduce the scale of a sprite rendered using the texture).\n\nYou can only request mipmaps if both of the texture’s dimensions are a power of two.\n\nSee Also\nConfiguring a Texture's Behavior for Scaling\nvar filteringMode: SKTextureFilteringMode\nThe filtering mode used when the size of a sprite drawn with the texture is not drawn at the texture’s native size.\nenum SKTextureFilteringMode\nTexture filtering modes to use when the texture is drawn in a size other than its native size."
  },
  {
    "title": "size() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519772-size",
    "html": "Return Value\n\nThe dimensions of the texture, measured in points.\n\nDiscussion\n\nIf the texture was created using an image file and that image file hasn’t been loaded, calling this method forces the texture data to be loaded from the file.\n\nSee Also\nReading a Texture's Size and Optional Source Location\nfunc textureRect() -> CGRect\nGets a rectangle that defines the portion of the texture used to render its image."
  },
  {
    "title": "Creating a New Node By Rendering To a Texture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/creating_a_new_node_by_rendering_to_a_texture",
    "html": "Overview\n\nYou can create a texture from some portion of on-screen content with texture(from:), or its variation, texture(from:crop:). Both of these functions are available for scenes rendered by SKView or WKInterfaceSKScene.\n\nThere are a couple reasons you might want to do this, for example:\n\nCreating a new sprite node whose texture reflects prior shading done with SKShader\n\nFlattening a hierarchy of nodes into a texture, either for performance, or to apply some effect. Note that this can also be done using SKEffectNode and setting shouldRasterize to true.\n\nBreaking appart an existing node into separate nodes, for example, for an explosion effect.\n\nSee Also\nSnapshotting Nodes to a Texture\nfunc texture(from: SKNode, crop: CGRect) -> SKTexture?\nRenders a portion of a node’s contents and returns the rendered image as a texture.\nfunc texture(from: SKNode) -> SKTexture?\nRenders the contents of a node tree and returns the rendered image as a texture."
  },
  {
    "title": "Texture Initializers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/texture_initializers",
    "html": "Overview\n\nUse these functions to create a new texture. While doing so, you should be aware of the memory implications of texture memory, and the other ways to get textures other than SKTexture initializers.\n\nMemory Considerations\n\nWhen creating textures you should be aware of the memory consumed as a result of their file size dimensions. Often, the memory available to prepared textures is limited by hardware because textures are loaded in VRAM. Consider the following tips:\n\nAccess a texture only when needed and dispose of it when you are done. This frees up memory for other parts of the app.\n\nAvoid loading too many textures in a single pass through the rendering loop. The process of decoding an image from disk is an expensive one and can therefore cause a few frames to be skipped. To avoid performance hiccups, preload textures ahead of time, such as when the scene is loaded.\n\nIf you frequently use that same textures together (for example, all the grass tiles any time grass is displayed in a scene) then you should consider bundling them into an SKTextureAtlas to increase loading and runtime peformance.\n\nWays to Access Textures\n\nIn addition to the Texture Initializers in SKTexture, the following other classes vend textures, too:\n\nAccess a texture by its original filename within a SpriteKit texture atlas folder using SKTextureAtlas's textureNamed(_:)\n\nCreate a texture by rendering an existing node in the tree, including its children, using SKView's texture(from:)\n\nTopics\nFilename Initializer\nSearch the app bundle for an image by filename.\ninit(imageNamed: String)\nCreate a new texture object from an image file stored in the app bundle.\nTexture Within a Texture\n\nMuch like a texture atlas, create optimized smaller textures from a larger one without duplicating image data in memory.\n\ninit(rect: CGRect, in: SKTexture)\nCreates a new texture from a sub-rectangle of an existing texture.\nTexture from Image\ninit(image: UIImage)\nCreate a new texture object from an image object.\ninit(cgImage: CGImage)\nCreate a new texture object from a Quartz 2D image.\nTexture with Effects\nfunc applying(CIFilter) -> Self\nCreates a new texture by applying a Core Image filter to an existing texture.\nTexture from Data\ninit(data: Data, size: CGSize)\nCreates a new texture from raw pixel data.\ninit(data: Data, size: CGSize, rowLength: UInt32, alignment: UInt32)\nCreates a new texture from custom formatted raw pixel data.\ninit(data: Data, size: CGSize, flipped: Bool)\nCreates a new texture from raw pixel data.\nTexture from Normal Map\nfunc generatingNormalMap() -> Self\nCreates a normal map texture by analyzing the contents of an existing texture.\nfunc generatingNormalMap(withSmoothness: CGFloat, contrast: CGFloat) -> Self\nCreates a normal map texture by analyzing the contents of an existing texture.\nNoise Textures\ninit(vectorNoiseWithSmoothness: CGFloat, size: CGSize)\nCreates a new texture whose contents are procedurally generated directional noise data.\ninit(noiseWithSmoothness: CGFloat, size: CGSize, grayscale: Bool)\nCreates a new texture whose contents are procedurally generated color noise data.\nTexture from Noise Map\ninit(noiseMap: GKNoiseMap)\nCreates a texture from the specified noise map.\nSee Also\nFirst Steps\nLoading and Using Textures\nLearn the basics about using textures in SpriteKit."
  },
  {
    "title": "convert(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520328-convert",
    "html": "Parameters\npoint\n\nA point in scene coordinates.\n\nscene\n\nA scene.\n\nReturn Value\n\nThe same point in the view’s coordinate system.\n\nDiscussion\n\nThis method performs the coordinate conversion as if the scene is presented inside the view.\n\nSee Also\nConverting Between View and Scene Coordinates\nfunc convert(CGPoint, to: SKScene) -> CGPoint\nConverts a point from view coordinates to scene coordinates."
  },
  {
    "title": "showsDrawCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520112-showsdrawcount",
    "html": "Discussion\n\nSome operations in SpriteKit can require multiple rendering passes to draw a scene’s content. For example, an SKEffectNode object must render its children into a separate buffer, apply the effect, and then perform another pass to blend those results into its parent node. These additional rendering passes use more rendering resources, reducing your game’s frame rate or increasing its total power consumption. Use the draw count as another piece of data when you profile your game’s performance.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsFPS: Bool\nA Boolean value that indicates whether the view displays a frame rate indicator.\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "showsNodeCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520156-showsnodecount",
    "html": "Discussion\n\nWhen you enable this option, it shows the number of nodes currently in the scene's node tree.\n\nNote\n\nTheshouldCullNonVisibleNodes property affects how many nodes in the node tree are included in SpriteKit's render pass but it doesn't affect the showsNodeCount statistic.\n\nYou may achieve additional performance gain by actually removing nodes from the node tree manually which are off screen. For example, in the case of shouldCullNonVisibleNodes, there would be less nodes for SpriteKit to test every frame whether they're on screen.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsFPS: Bool\nA Boolean value that indicates whether the view displays a frame rate indicator.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "showsFPS | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519590-showsfps",
    "html": "Discussion\n\nThe frame rate is a good indicator of the performance of your scene. Avoid creating scenes that have widely varying frame rates.\n\nSee Also\nEnabling Visual Statistics for Debugging\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene."
  },
  {
    "title": "allowsTransparency | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519697-allowstransparency",
    "html": "Discussion\n\nThis property tells the drawing system as to how it should treat the view. If set to false, the drawing system treats the view as fully opaque, which allows the drawing system to optimize some drawing operations and improve performance. If set to true, the drawing system composites the view normally with other content. The default value of this property is false.\n\nAn opaque view is expected to fill its bounds with entirely opaque content—that is, the content should have an alpha value of 1.0. If the view is opaque and either does not fill its bounds or contains wholly or partially transparent content, the results are unpredictable. Always set the value of this property to false if the view is fully or partially transparent.\n\nSee Also\nConfiguring Performance Related Toggles\nvar ignoresSiblingOrder: Bool\nA Boolean value that indicates whether parent-child and sibling relationships affect the rendering order of nodes in the scene.\nvar shouldCullNonVisibleNodes: Bool\nA Boolean value that indicates whether the view automatically culls non-visible nodes from the rendering tree.\nvar isAsynchronous: Bool\nA Boolean value that indicates whether the content is rendered asynchronously."
  },
  {
    "title": "SpriteView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spriteview",
    "html": "Topics\nCreating a Sprite View\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, shouldRender: (TimeInterval) -> Bool)\ninit(scene: SKScene, transition: SKTransition?, isPaused: Bool, preferredFramesPerSecond: Int, options: SpriteView.Options, debugOptions: SpriteView.DebugOptions, shouldRender: (TimeInterval) -> Bool)\nstruct SpriteView.Options\nstruct SpriteView.DebugOptions\nInstance Methods\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<SpriteView, AccessibilityAttachmentModifier>\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<SpriteView, AccessibilityAttachmentModifier>\nfunc allowedDynamicRange(Image.DynamicRange?) -> View\nfunc alternatingRowBackgrounds(AlternatingRowBackgroundBehavior) -> View\nfunc animation<V>(Animation?, body: (PlaceholderContentView<SpriteView>) -> V) -> View\nfunc badgeProminence(BadgeProminence) -> View\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> View\nfunc colorEffect(Shader, isEnabled: Bool) -> View\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> View\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> View\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> View\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> View\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> View\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> View\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> View\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> View\nfunc contextMenu<I, M>(forSelectionType: I.Type, menu: (Set<I>) -> M, primaryAction: ((Set<I>) -> Void)?) -> View\nfunc coordinateSpace(NamedCoordinateSpace) -> View\nfunc copyable<T>(() -> [T]) -> View\nfunc cuttable<T>(for: T.Type, action: () -> [T]) -> View\nfunc defaultHoverEffect(HoverEffect?) -> View\nfunc defaultScrollAnchor(UnitPoint?) -> View\nfunc dialogIcon(Image?) -> View\nfunc dialogSeverity(DialogSeverity) -> View\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> View\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> View\nfunc draggable<V, T>(() -> T, preview: () -> V) -> View\nfunc dropDestination<T>(for: T.Type, action: ([T], CGPoint) -> Bool, isTargeted: (Bool) -> Void) -> View\nfunc environment<T>(T?) -> View\nfunc exportableToServices<T>(() -> [T]) -> View\nfunc exportableToServices<T>(() -> [T], onEdit: ([T]) -> Bool) -> View\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> View\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> View\nfunc fileDialogConfirmationLabel(Text?) -> View\nfunc fileDialogConfirmationLabel<S>(S) -> View\nfunc fileDialogCustomizationID(String) -> View\nfunc fileDialogDefaultDirectory(URL?) -> View\nfunc fileDialogImportsUnresolvedAliases(Bool) -> View\nfunc fileDialogMessage(LocalizedStringKey) -> View\nfunc fileDialogMessage(Text?) -> View\nfunc fileDialogMessage<S>(S) -> View\nfunc fileDialogURLEnabled(Predicate<URL>) -> View\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> View\nfunc fileExporterFilenameLabel(Text?) -> View\nfunc fileExporterFilenameLabel<S>(S) -> View\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc focusEffectDisabled(Bool) -> View\nfunc focusable(Bool, interactions: FocusInteractions) -> View\nfunc focusedObject<T>(T) -> View\nfunc focusedObject<T>(T?) -> View\nfunc focusedSceneObject<T>(T) -> View\nfunc focusedSceneObject<T>(T?) -> View\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> View\nfunc focusedValue<T>(T?) -> View\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> View\nfunc fontDesign(Font.Design?) -> View\nfunc fontWidth(Font.Width?) -> View\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> View\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> View\nfunc geometryGroup() -> View\nfunc glassBackgroundEffect(displayMode: GlassBackgroundDisplayMode) -> View\nfunc glassBackgroundEffect<S>(in: S, displayMode: GlassBackgroundDisplayMode) -> View\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> View\nfunc hoverEffectDisabled(Bool) -> View\nfunc importableFromServices<T>(for: T.Type, action: ([T]) -> Bool) -> View\nfunc inspector<V>(isPresented: Binding<Bool>, content: () -> V) -> View\nfunc inspectorColumnWidth(CGFloat) -> View\nfunc inspectorColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> View\nfunc invalidatableContent(Bool) -> View\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<SpriteView>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> View\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<SpriteView>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> View\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> View\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> View\nfunc listRowHoverEffect(HoverEffect?) -> View\nfunc listRowHoverEffectDisabled(Bool) -> View\nfunc listRowSpacing(CGFloat?) -> View\nfunc listSectionSpacing(CGFloat) -> View\nfunc listSectionSpacing(ListSectionSpacing) -> View\nfunc menuActionDismissBehavior(MenuActionDismissBehavior) -> View\nfunc monospaced(Bool) -> View\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> View\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> View\nfunc offset(z: CGFloat) -> View\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> View\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> View\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> View\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc ornament<Content>(visibility: Visibility, attachmentAnchor: OrnamentAttachmentAnchor, contentAlignment: Alignment, ornament: () -> Content) -> View\nfunc padding3D(CGFloat) -> View\nfunc padding3D(EdgeInsets3D) -> View\nfunc padding3D(Edge3D.Set, CGFloat?) -> View\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> View\nfunc pasteDestination<T>(for: T.Type, action: ([T]) -> Void, validator: ([T]) -> [T]) -> View\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> View\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<SpriteView>, Phase) -> some View, animation: (Phase) -> Animation?) -> View\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<SpriteView>, Phase) -> some View, animation: (Phase) -> Animation?) -> View\nfunc preferredSurroundingsEffect(SurroundingsEffect?) -> View\nfunc presentationBackground<S>(S) -> View\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> View\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> View\nfunc presentationCompactAdaptation(PresentationAdaptation) -> View\nfunc presentationCompactAdaptation(horizontal: PresentationAdaptation, vertical: PresentationAdaptation) -> View\nfunc presentationContentInteraction(PresentationContentInteraction) -> View\nfunc presentationCornerRadius(CGFloat?) -> View\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> View\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> View\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> View\nfunc safeAreaPadding(CGFloat) -> View\nfunc safeAreaPadding(EdgeInsets) -> View\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> View\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<SpriteView, _UniformScaleEffect>\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> View\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> View\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> View\nfunc scrollBounceBehavior(ScrollBounceBehavior, axes: Axis.Set) -> View\nfunc scrollClipDisabled(Bool) -> View\nfunc scrollContentBackground(Visibility) -> View\nfunc scrollIndicatorsFlash(onAppear: Bool) -> View\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> View\nfunc scrollPosition(id: Binding<(some Hashable)?>, anchor: UnitPoint?) -> View\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> View\nfunc scrollTargetLayout(isEnabled: Bool) -> View\nfunc scrollTransition(ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> View\nfunc scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> View\nfunc searchDictationBehavior(TextInputDictationBehavior) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> View\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> View\nfunc searchSuggestions<S>(() -> S) -> View\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> View\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> View\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> View\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> View\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> View\nfunc selectionDisabled(Bool) -> View\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> View\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> View\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> View\nfunc springLoadingBehavior(SpringLoadingBehavior) -> View\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> View\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> View\nfunc symbolEffectsRemoved(Bool) -> View\nfunc tableColumnHeaders(Visibility) -> View\nfunc textEditorStyle(some TextEditorStyle) -> View\nfunc textScale(Text.Scale, isEnabled: Bool) -> View\nfunc toolbar(Visibility, for: ToolbarPlacement...) -> View\nfunc toolbar(removing: ToolbarDefaultItemKind?) -> View\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> View\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> View\nfunc toolbarTitleDisplayMode(ToolbarTitleDisplayMode) -> View\nfunc toolbarTitleMenu<C>(content: () -> C) -> View\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<SpriteView>) -> V) -> View\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> View\nfunc transform3DEffect(AffineTransform3D) -> View\nfunc typeSelectEquivalent(LocalizedStringKey) -> View\nfunc typeSelectEquivalent(Text?) -> View\nfunc typeSelectEquivalent<S>(S) -> View\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> View\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> View\nfunc upperLimbVisibility(Visibility) -> View\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> View\nfunc visualEffect3D((EmptyVisualEffect, GeometryProxy3D) -> some VisualEffect) -> View\nRelationships\nConforms To\nView"
  },
  {
    "title": "shouldCullNonVisibleNodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519683-shouldcullnonvisiblenodes",
    "html": "Discussion\n\nThe default value is true, meaning that when the scene is rendered, the scene first searches the tree for invisible or offscreen nodes and culls them from the list of nodes to be rendered. Then the remaining (visible) nodes are processed and rendered. This is normally the desired behavior, because Scene Kit avoids expensive processing on nodes that cannot affect the final output. However, if your game is already managing the contents of the scene’s node tree (for example, by removing nodes from the tree when they are offscreen), you can set this to false to disable automatic scene culling. Disabling scene culling removes the performance overhead of this check, but each invisible or offscreen node present in the node tree reduces the performance of the renderer.\n\nSee Also\nConfiguring Performance Related Toggles\nvar ignoresSiblingOrder: Bool\nA Boolean value that indicates whether parent-child and sibling relationships affect the rendering order of nodes in the scene.\nvar allowsTransparency: Bool\nA Boolean property that indicates whether the view is rendered using transparency.\nvar isAsynchronous: Bool\nA Boolean value that indicates whether the content is rendered asynchronously."
  },
  {
    "title": "ignoresSiblingOrder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520215-ignoressiblingorder",
    "html": "Discussion\n\nThe default value is false, which means that when multiple nodes share the same z position, those nodes are sorted and rendered in a deterministic order. Parents are rendered before their children, and siblings are rendered in array order. When this property is set to true, the position of the nodes in the tree is ignored when determining the rendering order. The rendering order of nodes at the same z position is arbitrary and may change every time a new frame is rendered. When sibling and parent order is ignored, SpriteKit applies additional optimizations to improve rendering performance. If you need nodes to be rendered in a specific and deterministic order, you must set the z position of those nodes.\n\nSee Also\nConfiguring Performance Related Toggles\nvar shouldCullNonVisibleNodes: Bool\nA Boolean value that indicates whether the view automatically culls non-visible nodes from the rendering tree.\nvar allowsTransparency: Bool\nA Boolean property that indicates whether the view is rendered using transparency.\nvar isAsynchronous: Bool\nA Boolean value that indicates whether the content is rendered asynchronously.\nRelated Documentation\nvar zPosition: CGFloat\nThe height of the node relative to its parent."
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1642774-delegate",
    "html": "See Also\nControlling the Timing of a Scene's Rendering\nvar isPaused: Bool\nA Boolean value that indicates whether the view’s scene animations are paused.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nprotocol SKViewDelegate\nMethods to take custom control over the view's render rate.\nvar frameInterval: Int\nThe number of frames that must pass before the scene is called to update its contents.\nDeprecated\nvar preferredFrameRate: Float\nDeprecated"
  },
  {
    "title": "focusBehavior | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/2882953-focusbehavior",
    "html": "See Also\nHandling User Input\nControlling User Interaction on Nodes\nEnable your node to respond to user input, like touches or mouse clicks.\nvar isUserInteractionEnabled: Bool\nA Boolean value that indicates whether the node receives touch events."
  },
  {
    "title": "atPoint(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483099-atpoint",
    "html": "Parameters\np\n\nA point in the node’s coordinate system.\n\nReturn Value\n\nA descendant in the subtree that intersects the point, or the receiver if no nodes intersect the point. Only nodes that have an isHidden of false and an alpha greater that zero are returned. If multiple descendants intersect the point, the deepest node in the tree is returned. If multiple nodes are at the same level, the intersecting node with the largest z position is returned.\n\nDiscussion\n\nA point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.\n\nSee Also\nHit Testing\nUnderstanding Hit-Testing\nLearn how find child nodes at a given point by using hit-testing.\nfunc contains(CGPoint) -> Bool\nReturns a Boolean value that indicates whether a point lies inside the parent’s coordinate system.\nfunc nodes(at: CGPoint) -> [SKNode]\nReturns an array of all visible descendants that intersect a point."
  },
  {
    "title": "SpriteKit Data Types | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spritekit_data_types",
    "html": "Topics\nData Types\ntypealias SKActionTimingFunction\nThe signature for the custom timing block.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "Understanding Hit-Testing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/understanding_hit-testing",
    "html": "Overview\n\nWhen SpriteKit processes touch or mouse events, it walks the scene to find the closest node that will accept the event. If the first node tested won't accept the event, SpriteKit checks the next closest node, and so on. This process is called hit-testing, and the order in which it's processed is essentially the reverse of drawing order.\n\nFor a node to be considered during hit-testing, its isUserInteractionEnabled property must be set to a true. The default value is a false for any node except a scene node. A node that will receive events needs to implement the appropriate responder methods from its parent class (UIResponder on iOS and NSResponder on macOS). This is one of the few places where you must implement platform-specific code in SpriteKit.\n\nSometimes, you also want to look for nodes directly, rather than relying on the standard event-handling mechanisms. In SpriteKit you can ask a node whether any of its descendants intersect a specific point in their coordinate system. Call the atPoint(_:) method to find the first descendant that intersects the point, or use the nodes(at:) method to receive an array of all of the nodes that intersect the point.\n\nSee Also\nHit Testing\nfunc contains(CGPoint) -> Bool\nReturns a Boolean value that indicates whether a point lies inside the parent’s coordinate system.\nfunc atPoint(CGPoint) -> SKNode\nReturns the deepest visible descendant that intersects a point.\nfunc nodes(at: CGPoint) -> [SKNode]\nReturns an array of all visible descendants that intersect a point."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483044-contains",
    "html": "Parameters\np\n\nA CGPoint to test against.\n\nReturn Value\n\ntrue if the point lies inside the parent’s coordinate system; otherwise false.\n\nSee Also\nHit Testing\nUnderstanding Hit-Testing\nLearn how find child nodes at a given point by using hit-testing.\nfunc atPoint(CGPoint) -> SKNode\nReturns the deepest visible descendant that intersects a point.\nfunc nodes(at: CGPoint) -> [SKNode]\nReturns an array of all visible descendants that intersect a point."
  },
  {
    "title": "preload(_:withCompletionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/1519817-preload",
    "html": "Parameters\ntextures\n\nAn array of SKTexture objects.\n\ncompletionHandler\n\nA block called after all of the textures are loaded.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func preload(_ textures: [SKTexture]) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSpriteKit creates a background task that loads the texture data for all of the textures in the array, then returns control to your game. Your completion handler is called after all of the textures are loaded.\n\nSee Also\nPreloading a Texture for Performance\nPreloading Textures into Memory\nDecompress images ahead of time to avoid performance issues during gameplay.\nfunc preload(completionHandler: () -> Void)\nLoad texture data into memory, calling a completion handler after the task completes."
  },
  {
    "title": "presentScene(_:transition:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520090-presentscene",
    "html": "Parameters\nscene\n\nThe scene to present.\n\ntransition\n\nA transition used to animate between the two scenes.\n\nDiscussion\n\nIf there is currently a scene presented by the view, the view’s scene property is updated immediately, the transition is executed to swap between the scenes. Otherwise, the new scene is presented immediately and the transition property is ignored.\n\nSee Also\nDisplaying a Scene\nvar scene: SKScene?\nThe scene currently presented by this view.\nfunc presentScene(SKScene?)\nPresents a scene.\nclass SKTransition\nAn object used to perform an animated transition to a new scene."
  },
  {
    "title": "SpriteKit Type Aliases | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spritekit_type_aliases",
    "html": "Topics\nType Aliases\ntypealias SKColor"
  },
  {
    "title": "preload(completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/1427385-preload",
    "html": "Parameters\ncompletionHandler\n\nA block called after the texture atlas is loaded.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc preload() async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSpriteKit creates a background task that loads the texture data from the atlas object. Then, SpriteKit returns control to your game. After the texture atlas is loaded, your completion handler is called.\n\nIf you need to preload multiple texture atlas objects immediately, use the preloadTextureAtlases(_:withCompletionHandler:) method instead.\n\nSee Also\nPreloading Textures\nclass func preloadTextureAtlases([SKTextureAtlas], withCompletionHandler: () -> Void)\nLoads the textures of multiple atlas objects into memory, calling a completion handler after the task completes.\nclass func preloadTextureAtlasesNamed([String], withCompletionHandler: (Error?, [SKTextureAtlas]) -> Void)\nLoads the textures of multiple atlases into memory, calling a completion handler after the task completes."
  },
  {
    "title": "SKEffectNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skeffectnode",
    "html": "Overview\n\nAn SKEffectNode object renders its children into a buffer and optionally applies a Core Image filter to this rendered output. Because effect nodes conform to SKWarpable, you can also use them to apply distortions to nodes that don't implement the protocol, such as shape and video nodes. Use effect nodes to incorporate sophisticated special effects into a scene or to cache the contents of a static subtree for faster rendering performance.\n\nEach time a new frame is rendered using the effect node, the effect node follows these steps:\n\nIt draws its children into a private framebuffer.\n\nIt applies a Core Image effect to the private framebuffer. This stage is optional; see the filter and shouldEnableEffects properties.\n\nIt blends the contents of its private framebuffer into its parent’s framebuffer, using one of the standard sprite blend modes.\n\nIt discards its private framebuffer. This step is optional; see the shouldRasterize property.\n\nTopics\nApplying Core Image Filters with an Effect Node\nApplying Special Effects to a Node's Children\nApply the Core Image suite of filters to child nodes of an effect node.\nvar filter: CIFilter?\nThe Core Image filter to apply.\nvar shouldEnableEffects: Bool\nA Boolean value that determines whether the effect node applies the filter to its children as they are drawn.\nvar shouldCenterFilter: Bool\nA Boolean value that determines whether the effect node automatically sets the filter’s image center.\nWarping Nodes with an Effect Node\nWarping SpriteKit Content By Using an Effect Node\nDistort the child nodes of an effect node by applying a warping effect.\nApplying a Shader with an Effect Node\nSupply a code file that does custom per-pixel alteration or colorization of an effect node's children.\nvar shader: SKShader?\nA custom shader that is called when the effect node is blended into the parent’s framebuffer.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute.\nFlattening an Effect Node's Child Tree for Performance Improvement\nImproving the Performance of Static Content\nFlatten a portion of your node hierarchy to a single texture to improve performance.\nvar shouldRasterize: Bool\nA Boolean value that indicates whether the results of rendering the child nodes should be cached.\nConfiguring Alpha Blending\nChange how an effect node uses its alpha value, such as additive blending, that results in the sprite being brighter than it was before.\nvar blendMode: SKBlendMode\nThe blend mode used to draw the node's contents into its parent’s framebuffer.\nRelationships\nInherits From\nSKNode\nConforms To\nSKWarpable\nSee Also\nNodes that Modify Drawing\nclass SKCropNode\nA node that masks pixels drawn by its children so that only some pixels are seen.\nclass SKTransformNode\nA node that allows its children to rotate in 3D."
  },
  {
    "title": "scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520084-scene",
    "html": "Discussion\n\nThe default value is nil.\n\nYou call presentScene(_:) to assign a value to this property.\n\nSee Also\nDisplaying a Scene\nfunc presentScene(SKScene?)\nPresents a scene.\nfunc presentScene(SKScene, transition: SKTransition)\nTransitions from the current scene to a new scene.\nclass SKTransition\nAn object used to perform an animated transition to a new scene."
  },
  {
    "title": "presentScene(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519705-presentscene",
    "html": "Parameters\nscene\n\nThe scene to present.\n\nDiscussion\n\nThe new scene immediately replaces the current scene, if one exists.\n\nSee Also\nDisplaying a Scene\nvar scene: SKScene?\nThe scene currently presented by this view.\nfunc presentScene(SKScene, transition: SKTransition)\nTransitions from the current scene to a new scene.\nclass SKTransition\nAn object used to perform an animated transition to a new scene.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "render(withViewport:commandBuffer:renderPassDescriptor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer/2866073-render",
    "html": "See Also\nRendering the Scene\nfunc render(withViewport: CGRect, renderCommandEncoder: MTLRenderCommandEncoder, renderPassDescriptor: MTLRenderPassDescriptor, commandQueue: MTLCommandQueue)"
  },
  {
    "title": "children | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483028-children",
    "html": "Discussion\n\nThe objects in this array are all SKNode objects.\n\nSee Also\nAccessing Related Nodes\nAbout SpriteKit Coordinate Systems\nLearn how a node conforms to its coordinate systems.\nvar scene: SKScene?\nThe scene node that contains this node.\nvar parent: SKNode?\nThe node’s parent node."
  },
  {
    "title": "parent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483080-parent",
    "html": "Discussion\n\nIf the node is not in a node tree, the value is nil.\n\nSee Also\nAccessing Related Nodes\nAbout SpriteKit Coordinate Systems\nLearn how a node conforms to its coordinate systems.\nvar scene: SKScene?\nThe scene node that contains this node.\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "setScale(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483126-setscale",
    "html": "Parameters\nscale\n\nThe new value to use for the node’s xScale and yScale properties.\n\nSee Also\nScaling and Rotating\nvar zRotation: CGFloat\nThe Euler rotation about the z axis (in radians).\nvar xScale: CGFloat\nA scaling factor that multiplies the width of a node and its children.\nvar yScale: CGFloat\nA scaling factor that multiplies the height of a node and its children."
  },
  {
    "title": "xScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483087-xscale",
    "html": "Discussion\n\nThe xScale property scales the width of the node and all of its descendants. The scale value affects how a node’s frame is calculated, its hit test area, how it is drawn, and other similar characteristics. The default value is 1.0.\n\nSee Also\nScaling and Rotating\nvar zRotation: CGFloat\nThe Euler rotation about the z axis (in radians).\nfunc setScale(CGFloat)\nSets the xScale and yScale properties of the node.\nvar yScale: CGFloat\nA scaling factor that multiplies the height of a node and its children.\nRelated Documentation\nvar frame: CGRect\nA rectangle in the parent’s coordinate system that contains the node’s content, ignoring the node’s children.\nfunc calculateAccumulatedFrame() -> CGRect\nReturns a rectangle in the parent’s coordinate system that contains the position and size of itself and all child nodes."
  },
  {
    "title": "zRotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483089-zrotation",
    "html": "Discussion\n\nThe default value is 0.0, which indicates no rotation. A positive value indicates a counterclockwise rotation. When the coordinate system is rotated, it affects the node and its descendants. The rotation affects the node’s frame property, hit testing, rendering, and other similar characteristics.\n\nSee Also\nScaling and Rotating\nfunc setScale(CGFloat)\nSets the xScale and yScale properties of the node.\nvar xScale: CGFloat\nA scaling factor that multiplies the width of a node and its children.\nvar yScale: CGFloat\nA scaling factor that multiplies the height of a node and its children.\nRelated Documentation\nvar frame: CGRect\nA rectangle in the parent’s coordinate system that contains the node’s content, ignoring the node’s children.\nfunc calculateAccumulatedFrame() -> CGRect\nReturns a rectangle in the parent’s coordinate system that contains the position and size of itself and all child nodes."
  },
  {
    "title": "zPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/1483107-zposition",
    "html": "Discussion\n\nThe default value is 0.0. The positive z axis is projected toward the viewer so that nodes with larger z-position values are closer to the viewer. When a node tree is rendered, the height of each node (in absolute coordinates) is calculated and then all nodes in the tree are rendered from smallest z-position value to largest z-position value. If multiple nodes share the same z-position, those nodes are sorted so that parent nodes are drawn before their children, and siblings are rendered in the order that they appear in their parent’s children array. Hit-testing is processed in the opposite order.\n\nThe SKView class’s ignoresSiblingOrder property controls whether node sorting is enabled for nodes at the same z-position.\n\nImportant\n\nDescendants of an effect node or a crop node are not rendered with other nodes in the same tree. An effect node (SKEffectNode) renders its children into a private framebuffer as a separate node tree, then the composited image is rendered into the tree that contains the effect node. A crop node (SKCropNode) works similarly; it renders the mask separately, then uses the mask to render its actual descendants into the tree that contains the crop node.\n\nUsing a Node’s Depth to Add Effects\n\nSpriteKit uses the zPosition value only to determine the hit testing and drawing order. You can also the z position to implement your own game effects. For example, you might use the height of a node to determine how it is rendered or how it moves onscreen. In this way, you can simulate fog or parallax effects. SpriteKit does not create these effects for you. Usually, you implement them by processing the scene immediately before it is rendered.\n\nSee Also\nConfiguring Draw Order\nAbout Node Drawing Order\nUnderstand how SpriteKit layers your scene's nodes from top to bottom.\nRelated Documentation\nvar children: [SKNode]\nThe node’s children."
  },
  {
    "title": "About Node Drawing Order | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/about_node_drawing_order",
    "html": "Overview\n\nThe standard behavior for scene rendering follows a simple pair of rules (as shown in Figure 1):\n\nA parent draws its content before rendering its children.\n\nChildren are rendered in the order in which they appear in the child array.\n\nFigure 1 Parents drawn before children\n\nIn the figure above, the helicopter body and its components are all children of the sky node. So the scene renders its content as follows:\n\nThe scene renders itself, clearing its contents to its background color.\n\nThe scene renders the sky node.\n\nThe sky node renders its children—the helicopter body and its components—in the order they were added as children.\n\nDraw Order Relative to the Parent Node\n\nMaintaining the order of a node’s children can be a lot of work. Instead, you can give each node an explicit height in the scene. You do this by setting a node’s zPosition property. The zPosition is the node’s height relative to its parent node, much as a node’s position property represents its x and y position relative to its parent’s position. So you use zPosition to place a node above or below the parent’s position.\n\nWhen you take zPosition into account, here is how the node tree is rendered:\n\nEach node’s global zPosition is calculated by recursively adding its zPosition to its parent's zPosition.\n\nNodes are drawn in order from smallest zPosition to largest zPosition.\n\nIf two nodes share the same zPosition, ancestors are rendered first, and siblings are rendered in child order.\n\nSibling Order Performance\n\nSpriteKit uses a deterministic rendering order based on the height nodes and their positions in the node tree. But, because the rendering order is so deterministic, SpriteKit may be unable to apply some rendering optimizations that it might otherwise apply. For example, it might be better if SpriteKit could gather all of the nodes that share the same texture and drawing mode and draw them with a single drawing pass. To enable these sorts of optimizations, you set the view’s ignoresSiblingOrder property to true.\n\nWhen you ignore sibling order, SpriteKit uses the graphics hardware to render the nodes so that they appear sorted by zPosition. It sorts nodes into a drawing order that reduces the number of draw calls needed to render the scene. But with this optimized drawing order, you cannot predict the rendering order for nodes that share the same height. The rendering order may change each time a new frame is rendered. In many cases, the drawing order of these nodes is not important. For example, if the nodes are at the same height but do not overlap on screen, they can be drawn in any order.\n\nFigure 2 shows an example of a tree that uses zPosition to determine the rendering order. In this example, the body of the helicopter is at a height of 100, and its children are rendered relative to its height. The two rotor nodes share the same height but do not overlap.\n\nFigure 2 Depth-only rendering can improve performance\n\nInterleaved Child Nodes from Different Parents\n\nBecause a child node's zPosition is added to its parent's zPosition, you can interleave child nodes from different parent nodes. Listing 1 shows code that creates two square parent nodes, each with a circular child node. The first node has a zPosition of 10 and its child node has a zPosition of 10. The second node has a zPosition of 15 and its child node also has a zPosition of 10.\n\nOnce added to the scene, the child of the first node has an effective global zPosition of 20 and the child of the second node has an effective global zPosition of 25, giving an interleaving effect.\n\nListing 1 Interleaving composite nodes\nfunc addNodesTo(scene: SKScene,\n                color: SKColor, position: CGPoint,\n                parentZ: CGFloat, childZ: CGFloat) {\n    \n    let diameter: CGFloat = 250\n    let rect = CGRect(origin: position,\n                      size: CGSize(width: diameter, height: diameter))\n     \n    let parentNode = SKShapeNode(rect: rect)\n    let childNode = SKShapeNode(ellipseIn: rect.insetBy(dx: 10, dy: 10))\n  \n    [(parentNode, scene, parentZ), (childNode, parentNode, childZ)].forEach {\n        node, parent, zPosition in\n        \n        node.fillColor = color\n        node.strokeColor = .white\n        node.zPosition = zPosition\n        \n        parent.addChild(node)\n    }\n}\n\n\n  \naddNodesTo(scene: scene,\n           color: .red,\n           position: CGPoint(x: 300, y: 300),\n           parentZ: 10,\n           childZ: 10)\n \naddNodesTo(scene: scene,\n           color: .blue,\n           position: CGPoint(x: 350, y: 250),\n           parentZ: 15,\n           childZ: 10)\n\n\nFigure 3 shows the resulting scene.\n\nFigure 3 Interleaved node hierarchies using zPosition\n\nBecause zPosition is additive across parent-child node relationships, you can use both tree order and zPositions to determine your scene’s rendering order. When rendering a complex scene, you should disable the sorting behavior and use the zPositions of nodes to create a deterministic scene order.\n\nImportant\n\nThe SKCropNode and SKEffectNode node classes alter the scene rendering behavior. The children of these nodes are rendered independently as a separate node tree, and the results are rendered into the tree that contains the crop or effect node. For more information, see Working with Other Node Types.\n\nSee Also\nConfiguring Draw Order\nvar zPosition: CGFloat\nThe height of the node relative to its parent."
  },
  {
    "title": "textureNames | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas/1427373-texturenames",
    "html": "Discussion\n\nThe property holds an array of NSString objects. Each string is the name of a texture stored in the atlas. The count of the array is the number of textures stored in the atlas.\n\nIf the atlas is not currently loaded into memory, this method forces it to be loaded from the app bundle. Your game blocks until the atlas is loaded.\n\nSee Also\nRelated Documentation\nfunc textureNamed(String) -> SKTexture\nCreates a texture from data stored in the texture atlas."
  },
  {
    "title": "init(size:pixelFormat:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skmutabletexture/1397879-init",
    "html": "Parameters\nsize\n\nThe size of the texture, in pixels.\n\nformat\n\nA Core Video format code. Three codes are supported: kCVPixelFormatType_32RGBA, kCVPixelFormatType_64RGBAHalf, and kCVPixelFormatType_128RGBAFloat for byte, half-float, and float components respectively.\n\nReturn Value\n\nAn empty mutable texture.\n\nDiscussion\n\nYou must call the modifyPixelData(_:) method at least once before using this texture.\n\nSee Also\nCreating an Empty Mutable Texture\ninit(size: CGSize)\nInitializes an empty texture with a specific size."
  },
  {
    "title": "modifyPixelData(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skmutabletexture/1397881-modifypixeldata",
    "html": "Parameters\nblock\n\nA block to be called when the texture can be safely modified. The block takes the following parameters:\n\npixelData\n\nA pointer to the start of the current texture data.\n\nlengthInBytes\n\nThe length of the texture data in bytes.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc modifyPixelData() async -> (UnsafeMutableRawPointer?, Int)\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThe contents of the texture can be modified only at specific times when the graphics hardware permits it. When this method is called, it schedules a new background task to update the texture and then returns. Your block is called when the texture can be modified. Your block is called on an arbitrary queue. Your block should modify the texture’s contents and then return.\n\nThe texture bytes are assumed to be stored as tightly packed 32 bpp, 8bpc (unsigned integer) RGBA pixel data. The color components you provide should have already been multiplied by the alpha value."
  },
  {
    "title": "init(size:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skmutabletexture/1397883-init",
    "html": "Parameters\nsize\n\nThe size of the texture, in pixels.\n\nReturn Value\n\nAn empty mutable texture.\n\nDiscussion\n\nYou must call the modifyPixelData(_:) method at least once before using this texture.\n\nSee Also\nCreating an Empty Mutable Texture\ninit(size: CGSize, pixelFormat: Int32)\nInitializes an empty texture with a specific size and format."
  },
  {
    "title": "SKTileDefinition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktiledefinition",
    "html": "Overview\n\nTo define the visual representation of a single tile, you create an SKTileDefinition object with texture and size information. Tile definitions support separate normal textures, for simulating 3D lighting, and arrays of textures for animation with speed controlled by the timePerFrame property. Textures can be rotated in 90˚ increments or flipped either vertically or horizontally.\n\nOnce a tile definition has been created, you encapsulate it in a SKTileGroup which is added to a SKTileSet which, in turn, is displayed in the scene with a SKTileMapNode.\n\nTopics\nCreating a Tile with a Texture\ninit(texture: SKTexture)\nInitializes a new tile definition with a single texture.\nCreating a Tile with a Normal Texture\nCreate a tile with an additional texture that's used for lighting effects.\ninit(texture: SKTexture, normalTexture: SKTexture, size: CGSize)\nInitializes a new tile definition with a single texture and separate normal texture for simulating 3D lighting.\nCreating a Tile with a Size\ninit(texture: SKTexture, size: CGSize)\nInitializes a new tile definition of a specified size with a single texture.\nCreating an Animated Tile\nCreate an animated Tile by passing in an array of textures (animation frames) and their respective times per frame.\ninit(textures: [SKTexture], normalTextures: [SKTexture], size: CGSize, timePerFrame: CGFloat)\nInitializes a new tile definition with arrays of textures and normal textures for animation.\ninit(textures: [SKTexture], size: CGSize, timePerFrame: CGFloat)\nInitializes a new tile definition with an array of textures for animation.\nFlipping a Tile Vertically or Horizontally\nvar flipHorizontally: Bool\nA Boolean that flips the definition’s image vertically.\nvar flipVertically: Bool\nA Boolean that flips the definition’s image horizontally.\nRotating a Tile\nvar rotation: SKTileDefinitionRotation\nThe rotation of the tile definition in 90˚ increments.\nenum SKTileDefinitionRotation\nThe allowed rotations for a given tile.\nConfigure Animated Tile Properties\nvar textures: [SKTexture]\nAn array of SKTexture objects that defines the tile definition object's content.\nvar normalTextures: [SKTexture]\nAn array of SKTexture objects used to generate the normals for the tile to simulate 3D lighting.\nvar timePerFrame: CGFloat\nThe duration, in seconds, that each texture in the textures array is displayed before switching to the next texture in the sequence.\nReading or Adding a Tile's Custom Data\nvar userData: NSMutableDictionary?\nA dictionary containing arbitrary data.\nReading or Adjusting a Tile's Instance Properties\nvar name: String?\nA name associated with the tile definition.\nvar placementWeight: Int\nThe placement weight of the tile definition.\nvar size: CGSize\nThe size of the tile definition in points.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nTiling\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SKTileGroup\nA set of tiles that collectively define one type of terrain.\nclass SKTileGroupRule\nRules that describe how various tiles should be placed in a map.\nclass SKTileSet\nA container for related tile groups."
  },
  {
    "title": "SKShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skshader",
    "html": "Overview\n\nAn SKShader object holds a custom OpenGL ES fragment shader. Shader objects are used to customize the drawing behavior of many different kinds of nodes in SpriteKit.\n\nTo use a custom shader, create an SKShader object and provide the source for the custom fragment shader. If your shader needs to provide uniform data to the shader, create one or more SKUniform objects and associate them with the shader object. If your shader needs to provide per-node data to the shader, create one or more SKAttribute objects and associate them with the relevant nodes. Then, assign the shader object to the shader property of any sprites that need the custom behavior.\n\nCompiling a shader and the uniform data associated with it can be expensive. Because of this, you should:\n\nInitialize shader objects when your game launches, not while the game is running.\n\nAvoid changing the shader’s source or changing the list of uniforms or attributes while your game is running. Either of these things recompiles the shader.\n\nShare shader objects whenever possible. If multiple sprites need the same behavior, create one shader object and associate it with every sprite that needs that behavior. Do not create a separate shader for each sprite.\n\nImportant\n\nSKShader does not support OpenGL Extensions. SpriteKit will return an error if you compile a project containing a fragment shader using extensions.\n\nTopics\nCreating a Shader\nCreating a Custom Fragment Shader\nWrite a fragment shader using the set of SpriteKit-exposed symbols, and supply it with custom data.\ninit(fileNamed: String)\nCreates a new shader object by loading the source for a fragment shader from a file stored in the app’s bundle.\ninit(source: String, uniforms: [SKUniform])\nInitializes a new shader object using the specified source and uniform data.\ninit(source: String)\nInitializes a new shader object using the specified source code.\nProviding Uniform Data to a Shader\nfunc addUniform(SKUniform)\nAdds a uniform to the shader.\nfunc removeUniformNamed(String)\nRemoves a uniform from the shader.\nvar uniforms: [SKUniform]\nThe list of uniforms associated with the shader.\nfunc uniformNamed(String) -> SKUniform?\nReturns the uniform object corresponding to a particular uniform variable.\nProviding Attribute Data to a Shader\nvar attributes: [SKAttribute]\nThe list of attributes associated with the shader.\nAccessing or Setting a Shader's Source Code\nvar source: String?\nThe source code for the shader.\nExecuting Shaders in Metal and OpenGL\nExecuting Shaders in Metal and OpenGL\nToggle between renderers to make sure your shader code compiles in both the Metal and OpenGL environments.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nShaders\nclass SKAttribute\nA specification for dynamic per-node data used with a custom shader.\nclass SKAttributeValue\nA container for dynamic shader data associated with a node.\nclass SKUniform\nA container for uniform shader data."
  },
  {
    "title": "Accessing and Modifying the Node Tree | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode/accessing_and_modifying_the_node_tree",
    "html": "Overview\n\nYou create the node tree by creating parent-child relationships between nodes. Each node maintains an ordered list of children, referenced by reading the node’s children property. The order of the children in the tree affects many aspects of scene processing, including hit testing and rendering, so it's important to organize the node tree appropriately.\n\nMethod\n\n\t\n\nDescription\n\n\n\n\naddChild(_:)\n\n\t\n\nAdds a node to the end of the receiver’s list of child nodes.\n\n\n\n\ninsertChild(_:at:)\n\n\t\n\nInserts a child into a specific position in the receiver’s list of child nodes.\n\n\n\n\nremoveFromParent()\n\n\t\n\nRemoves the receiving node from its parent.\n\nWhen you need to directly traverse the node tree, you use the properties in the following table to uncover the tree’s structure.\n\nProperty\n\n\t\n\nDescription\n\n\n\n\nchildren\n\n\t\n\nThe array of SKNode objects that are the receiving node’s children.\n\n\n\n\nparent\n\n\t\n\nIf the node is a child of another node, this property holds the parent. Otherwise, it holds nil.\n\n\n\n\nscene\n\n\t\n\nIf the node is included anywhere in a scene, this property returns the scene node that is the root of the tree. Otherwise it holds nil.\n\nSee Also\nModifying the Node Tree\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node."
  },
  {
    "title": "SKWarpGeometry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometry",
    "html": "Relationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nWarping\nclass SKWarpGeometryGrid\nA definition for a grid-based deformation of nodes that conform to SKWarpable.\nprotocol SKWarpable\nA protocol for objects that can be warped and animated by an SKWarpGeometry."
  },
  {
    "title": "SKAttribute | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattribute",
    "html": "Overview\n\nTo define an attribute for your shader, you create an SKAttribute object with a unique name and data type, which is a SKAttributeType enum. After creating an SKShader object, custom attributes are added to its attributes array. Attribute values are set on the parent node with setValue(_:forAttribute:) and can change for each execution of a shader without the need for recompilation.\n\nThe following listing shows how you can use an attribute to pass the size of a sprite into a shader using an attribute. In this example, a_sprite_size is available as a global vec2 within the GLSL code.\n\nListing 1 Passing an attribute to a shader.\nlet attributeBasedShader = SKShader(fileNamed: \"UsingAttributes.fsh\")\nattributeBasedShader.attributes = [\n    SKAttribute(name: \"a_sprite_size\", type: .vectorFloat2)]\n\n\nlet sprite = SKSpriteNode()\nsprite.shader = attributeBasedShader\nsprite.size = CGSize(width: 10, height: 10)\nlet spriteSize = vector_float2(Float(sprite.frame.size.width), \n                               Float(sprite.frame.size.height))\nsprite.setValue(SKAttributeValue(vectorFloat2: spriteSize), \n                forAttribute: \"a_sprite_size\")\n\n\nTopics\nConstants\nenum SKAttributeType\nOptions that specify an attribute's data type.\nInitializers\ninit(name: String, type: SKAttributeType)\nCreates and initializes a new attribute object of a specified type with a name that can be referenced within the shader.\nInstance Properties\nvar name: String\nThe receiver's name\nvar type: SKAttributeType\nThe data type of the attribute's value.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nShaders\nclass SKShader\nAn object that allows you to apply a custom fragment shader.\nclass SKAttributeValue\nA container for dynamic shader data associated with a node.\nclass SKUniform\nA container for uniform shader data."
  },
  {
    "title": "direction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520091-direction",
    "html": "See Also\nConfiguring Other Field Properties\nvar animationSpeed: Float\nThe rate at which a noise or turbulence field node changes.\nvar smoothness: Float\nThe smoothness of the noise used to generate the forces.\nvar texture: SKTexture?\nA normal texture that specifies the velocities at different points in a velocity field node.\nRelated Documentation\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity."
  },
  {
    "title": "SKTileGroup | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegroup",
    "html": "Overview\n\nAn SKTileGroup object contains either the definition of a single tile or an array of SKTileGroupRule objects that define adjacency rules.\n\nYou supply a tile group with either:\n\nThe definition of a single tile that can be used to populate a tile map node with a single texture.\n\nAn array of one or more tile group rules that allow for the automatic placement of textures dependent on their adjacency and the placement weights of their definitions. For example, a tile group may contain nine tile group rules containing the definitions of the central tile and eight edge tiles that, when placed adjacently, appear as a single object.\n\nThe preferred method to create tile groups is to use the editor tools in Xcode. However, to work with SpriteKit’s tile support programmatically, see the following articles.\n\nTopics\nCreating Tile Groups\nCreating Tile Groups Programmatically\nPaint tiles on a map by putting tile definitions in a group that you create in code.\ninit(tileDefinition: SKTileDefinition)\nCreates and initializes a simple tile group with a single tile definition.\ninit(rules: [SKTileGroupRule])\nCreates and initializes a tile group with the specified tile group rules.\nAccessing or Setting a Tile Group's Properties\nvar name: String?\nThe receiver's name.\nvar rules: [SKTileGroupRule]\nAn array of SKTileGroupRule objects that the tile group uses to determine tile placement.\nCreating an Empty Tile Group\nCreate an empty tile group to erase tiles at a given location on a map.\nclass func empty() -> Self\nCreates an empty tile that erases the existing tile at that location on a tile map.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nTiling\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SKTileDefinition\nA single tile that can be repeated in a tile map.\nclass SKTileGroupRule\nRules that describe how various tiles should be placed in a map.\nclass SKTileSet\nA container for related tile groups."
  },
  {
    "title": "texture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519928-texture",
    "html": "See Also\nConfiguring Other Field Properties\nvar animationSpeed: Float\nThe rate at which a noise or turbulence field node changes.\nvar smoothness: Float\nThe smoothness of the noise used to generate the forces.\nvar direction: vector_float3\nThe direction of a velocity field node.\nRelated Documentation\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture."
  },
  {
    "title": "anchorPoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene/1519864-anchorpoint",
    "html": "Discussion\n\nWhen a scene is presented and a camera node has not been specified, the size and anchorPoint properties determine which part of the scene’s coordinate space is visible in the view.\n\nYou specify the value using the unit coordinate space. The default value is (0,0), which corresponds to the lower-left corner of the view’s frame rectangle.\n\nSee Also\nConfiguring the Viewport\nPositioning a Scene's Origin Within its View\nTry the different ways to configure the scene's origin inside its view.\nvar camera: SKCameraNode?\nThe camera node in the scene that determines what part of the scene’s coordinate space is visible in the view.\nRelated Documentation\nvar size: CGSize\nThe dimensions of the scene, in points."
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520143-categorybitmask",
    "html": "Discussion\n\nEvery field in a scene can be assigned to up to 32 different categories, each corresponding to a bit in the bit mask. The mask values are not predetermined by Sprite Kit. You define the mask values that are used in your game. The field node’s categoryBitMask property is compared to a physics body’s fieldBitMask property using a logical AND operation. If the result is nonzero, the field is applied to the physics body.\n\nThe default value is 0xFFFFFFFF (all bits set).\n\nSee Also\nDetermining Which Physics Bodies Are Affected by the Field\nvar isEnabled: Bool\nA Boolean value that indicates whether the field is active.\nvar isExclusive: Bool\nA Boolean value that indicates whether the field node should override all other field nodes that might otherwise affect physics bodies.\nvar region: SKRegion?\nThe area (relative to the node’s origin) that the field affects.\nvar minimumRadius: Float\nThe minimum value for distance-based effects."
  },
  {
    "title": "minimumRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519804-minimumradius",
    "html": "Discussion\n\nWhen the distance between the node and a physics body is calculated, any distance shorter than the value stored in the minimumRadius property is treated as if it is equal to it. The default value is a very small (but nonzero) value.\n\nSee Also\nDetermining Which Physics Bodies Are Affected by the Field\nvar isEnabled: Bool\nA Boolean value that indicates whether the field is active.\nvar isExclusive: Bool\nA Boolean value that indicates whether the field node should override all other field nodes that might otherwise affect physics bodies.\nvar region: SKRegion?\nThe area (relative to the node’s origin) that the field affects.\nvar categoryBitMask: UInt32\nA mask that defines which categories this field belongs to.\nRelated Documentation\nvar falloff: Float\nThe exponent that defines the rate of decay for the strength of the field as the distance increases between the node and the physics body being affected."
  },
  {
    "title": "customField(evaluationBlock:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519710-customfield",
    "html": "Parameters\nblock\n\nA custom block to be executed when a physics body is affected by the field. Your block should calculate and return the force to be applied to the body.\n\nReturn Value\n\nA new custom field node.\n\nDiscussion\n\nThe value returned by the custom block is a vector for an impulse force which is applied to the physics body being evaluated for that frame. Only the x and y components of the return value are used by SpriteKit, the z component is ignored.\n\nThe values passed into the block by the position and velocity arguments measured in meters: if you need to convert them into points — as used by SpriteKit — multiply the values by 150.\n\nThe following code shows how to create a custom field to emulate drag. The block returns the negative of the square root of the velocity of the physics body. This decelerates a physics body passing through the SKFieldNode object’s region.\n\nListing 1 Creating a custom drag field\nlet simpleDrag = SKFieldNode.customField {\n    (position: vector_float3, velocity: vector_float3, mass: Float, charge: Float, deltaTime: TimeInterval) in\n    return vector_float3(-sqrt(abs(velocity.x)) * sign(velocity.x),\n                         -sqrt(abs(velocity.y)) * sign(velocity.y),\n                         0)\n}\n\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "isEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520079-isenabled",
    "html": "See Also\nDetermining Which Physics Bodies Are Affected by the Field\nvar isExclusive: Bool\nA Boolean value that indicates whether the field node should override all other field nodes that might otherwise affect physics bodies.\nvar region: SKRegion?\nThe area (relative to the node’s origin) that the field affects.\nvar minimumRadius: Float\nThe minimum value for distance-based effects.\nvar categoryBitMask: UInt32\nA mask that defines which categories this field belongs to."
  },
  {
    "title": "vortexField() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520157-vortexfield",
    "html": "Return Value\n\nA new vortex field node.\n\nDiscussion\n\nThe strength of the field measures the acceleration of the field in meters per second squared (meaning that similar to gravity, all physics bodies are affected equally). The physics body is accelerated along the perpendicular of the line between the field node’s position and the position of the physics body. A positive field strength indicates the body is accelerated in a counter-clockwise direction. The falloff property of a vortex field node is set by default to 2.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "SKFieldForceEvaluator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldforceevaluator",
    "html": "Discussion\n\nThe block parameters are defined as follows:\n\nposition\n\nThe position of the physics body. The coordinates are assumed to be in the following order: x, y, z. In SpriteKit, the z coordinate is always 0.\n\nvelocity\n\nThe velocity of the physics body. The coordinates are assumed to be in the following order: dx, dy, dz. In SpriteKit, the dz coordinate is always 0.\n\nmass\n\nThe mass of the physics body.\n\ncharge\n\nThe charge of the physics body.\n\ntime\n\nThe amount of time that has passed since the last time the simulation was executed.\n\nYour block should perform any force calculations you are interested in and return the resulting force.\n\nImportant\n\nAlthough your app can use the z coordinate of any of the float vectors to perform its calculations, the z value of the output vector is ignored by SpriteKit. Essentially, this means that you can use field effects only to animate a node’s position property, not its zPosition property.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body."
  },
  {
    "title": "noiseField(withSmoothness:animationSpeed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519947-noisefield",
    "html": "Parameters\nsmoothness\n\nThe smoothness of the noise used to generate the forces. This parameter should be a value between 0.0 and 1.0, where 1.0 represents a uniform smoothness.\n\nspeed\n\nThe speed at which the noise field should change. A value of 0.0 means that the field should not animate at all.\n\nReturn Value\n\nA new noise field node.\n\nDiscussion\n\nUse a noise field to simulate effects such as fireflies or snow.\n\nThe acceleration is proportional to the field strength in a pseudo-random direction. The calculated force is proportional to the physics body’s mass (meaning that the acceleration applied to all affected physics bodies is a constant).\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field.\nRelated Documentation\nvar animationSpeed: Float\nThe rate at which a noise or turbulence field node changes.\nvar smoothness: Float\nThe smoothness of the noise used to generate the forces."
  },
  {
    "title": "velocityField(withVector:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520271-velocityfield",
    "html": "Parameters\nvelocityVector\n\nThe velocity that any affected physics bodies will have. The z component on the vector is ignored.\n\nReturn Value\n\nA new velocity field node.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field.\nRelated Documentation\nvar direction: vector_float3\nThe direction of a velocity field node."
  },
  {
    "title": "velocityField(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519778-velocityfield",
    "html": "Parameters\nvelocityTexture\n\nA normal texture used to specify the velocities at different points in the field.\n\nReturn Value\n\nA new velocity field node.\n\nDiscussion\n\nWhen a physics body is affected, its new velocity in each frame is calculated by performing a texture lookup (treating the value as a normal vector) and then multiplying that vector by the strength of the field. The field has an implicit size (region) equal to the size of the texture; physics bodies outside this area are unaffected by the field node.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field.\nRelated Documentation\nvar texture: SKTexture?\nA normal texture that specifies the velocities at different points in a velocity field node."
  },
  {
    "title": "springField() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519694-springfield",
    "html": "Return Value\n\nA new spring field node.\n\nDiscussion\n\nThe strength of the field measures the strength of the spring. A positive number indicates that the body is accelerating toward the field node. The falloff property of a spring field node is set by default to -1.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "turbulenceField(withSmoothness:animationSpeed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520018-turbulencefield",
    "html": "Parameters\nsmoothness\n\nThe smoothness of the noise used to generate the forces. This parameter should be a value between 0.0 and 1.0, where 1.0 represents a uniform smoothness.\n\nspeed\n\nThe speed at which the noise field should change. A value of 0.0 means that the field should not animate at all.\n\nReturn Value\n\nA new turbulence field node.\n\nDiscussion\n\nThe acceleration’s magnitude is proportional to a body’s velocity.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field.\nRelated Documentation\nvar animationSpeed: Float\nThe rate at which a noise or turbulence field node changes.\nvar smoothness: Float\nThe smoothness of the noise used to generate the forces."
  },
  {
    "title": "radialGravityField() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520382-radialgravityfield",
    "html": "Return Value\n\nA new radial gravity field node.\n\nDiscussion\n\nThe strength of the field measures the acceleration of the field in meters per second squared. A positive number indicates that the body is accelerating toward the field node. The calculated force is proportional to the physics body’s mass (meaning that the acceleration applied to all affected physics bodies is a constant). The falloff property of a radial gravity field node is set by default to 2.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "magneticField() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520134-magneticfield",
    "html": "Return Value\n\nA new magnetic field node.\n\nDiscussion\n\nThe force generated by this field is directed on a line that is determined by calculating the cross-product between the direction of the the physics body’s velocity property and a line traced between the field node and the physics body. This field models the second part of the Lorentz equation:\n\nF = qvB\n\nWhere F equals force, q equals charge, v equals velocity, B equals magnetic field and E equals electric field.\n\nThe force has a magnitude proportional to the field’s strength property and the physics body’s charge and velocity properties. Therefore, physics bodies that are either stationary or with a charge of zero will not be affected by a magnetic field. Magnetic fields with a negative strength value impart a clockwise spin on the physics bodies they affect, while a positive strength give a clockwise spin.The falloff property of a magnetic field node is set by default to 2.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "linearGravityField(withVector:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520145-lineargravityfield",
    "html": "Parameters\ndirection\n\nThe direction and magnitude of the gravitational force. The values represent the acceleration of the field in meters per second squared. For example, to simulate earth’s gravity, specify (0, -9.8, 0). The z component on the vector is ignored.\n\nReturn Value\n\nA new linear gravity field node.\n\nDiscussion\n\nIf the field node is rotated, the direction of its gravity field is also rotated. The calculated force is proportional to the physics body’s mass (meaning that the acceleration applied to all affected physics bodies is a constant).\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "electricField() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520396-electricfield",
    "html": "Return Value\n\nA new electric field node.\n\nDiscussion\n\nThe force points toward the field node’s position and has a magnitude proportional to the field’s strength property and the physics body’s charge property. This field models the first part of the Lorentz equation:\n\nF = qE\n\nWhere F equals force, q equals charge, and E equals electric field.\n\nThe falloff property of an electrical field node is set by default to 2.\n\nSee Also\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field."
  },
  {
    "title": "Adding Physics Fields to a Scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/adding_physics_fields_to_a_scene",
    "html": "Overview\n\nIt is possible to implement a game using only physics bodies, collisions, and applied forces, but sometimes this can be a lot of work. For example, if you wanted two objects to be attracted to each other, you would have to perform gravity calculations and apply those forces every time a new frame is calculated. When you want to apply generalized effects to a scene, you can do this more easily by using physics fields.\n\nA physics field is a node that is placed inside your scene’s node tree. When the scene simulates physics, the physics field affects physics bodies that are configured to interact with it. There are many different kinds of field effects, all of which are defined in Creating Field Nodes.\n\nThe following code shows one of these fields, a linear gravity field. In this example, a field node replaces the default gravity provided by the scene’s physics world. First, the scene's default gravity is disabled. Then, the scene creates a linear gravity field with a vector pointing toward the bottom of the screen and gives the node a strength equal to Earth’s gravity. Finally, it adds the node to itself.\n\nphysicsWorld.gravity = CGVector(dx:0, dy: 0);\n\n\nlet gravityVector = vector_float3(0,-1,0);\n\n\nlet gravityNode = SKFieldNode.linearGravityField(withVector: gravityVector)\n\n\ngravityNode.strength = 9.8\n\n\naddChild(gravityNode)\n\n\nHere are some reasons you might use a field node rather than the default gravity:\n\nTo vary the strength and direction of gravity independently of each other.\n\nTo vary the strength of the field using actions.\n\nTo change the direction of gravity by rotating the field node.\n\ngravityNode.zRotation = CGFloat.pi // Flip gravity.\n\n\nTo enable and disable gravity using the field node’s isEnabled property, without changing the field node’s strength or direction.\n\nLimit the Effect of Field Nodes Through Categories and Regions\n\nBy default, a field node affects all physics bodies in the scene. However, it doesn’t have to be this way. By carefully controlling which physics bodies are affected by a field node, you can create some interesting effects.\n\nField nodes are categorized just like physics bodies. Similarly, physics bodies declare which field categories affect them. Combining these two properties, you can decide which kinds of fields are implemented by your game and which physics bodies are affected by each of those fields. Typically, you do this by using the field categories to define general effects that you can drop into a game. For example, assume for the moment that you are implementing a game where you want to add gravity to a planet. Gravity should pull objects such as ships and asteroids toward the planet.\n\nThe following code creates a category for gravity effects. When a planet is created, a separate radial gravity field node is added to it as a child, and is configured to use the gravity category. Whenever a new physics body is created, the body’s mask is configured to determine which fields should affect it. Ships are affected by gravity, and missiles are affected by force fields.\n\nlet gravityCategory: UInt32 = 0x1 << 0\nlet shieldCategory: UInt32 = 0x1 << 1\n...\nlet gravity = SKFieldNode.radialGravityField()\ngravity.strength = 3\ngravity.categoryBitMask = gravityCategory\nplanet.addChild(gravity)\n...\nship.physicsBody?.fieldBitMask = gravityCategory\n...\nmissile.physicsBody?.fieldBitMask = shieldCategory\n\n\nIn this example, the force field is a shield object that deflects incoming missiles. You could implement the shield by creating another radial gravity field, but physics bodies are repelled by negative field strength. You probably wouldn't want the field to affect the whole scene, either—only nearby missiles. In this case, you would define the area that a field affects by using these properties:\n\nA field node’s region property determines the area where the field can affect things. By default, this region covers the entire scene. However, you can choose to give the region a finite shape instead. For the forcefield, a circular area is fine, but other shapes are possible. You can even construct them using constructive set geometry (CSG).\n\nA field node’s falloff property determines how fast the field loses its strength. You can choose to have the field not lose strength at all or you can choose to have it fall off more quickly than the default. For a radial gravity field, the default is to have it drop off based on the square of the distance to the other body’s center. Not all field types are affected by the falloff property.\n\nThe following code adds a temporary force field to the rocket ship. The field node is created and configured to repel missiles. Then a circular region is added to limit the area affected by the node, and the field is configured so that its strength drops off more quickly as a function of distance. Finally, the field should weaken and disappear so that the ship is not invulnerable. The field is weakened using an action that first animates a drop in strength to nothing, and then removes the shield node. In an actual game, the shield effect might be embellished with a graphical effect rendered on top of the ship.\n\nlet shield = SKFieldNode.radialGravityField()\nshield.strength = -5\nshield.categoryBitMask = shieldCategory\nshield.region = SKRegion(radius: 100)\nshield.falloff = 4\nshield.run(SKAction.sequence([\n    SKAction.strength(to: 0, duration: 2.0),\n    SKAction.removeFromParent()\n    ]))\nship.addChild(shield)\n"
  },
  {
    "title": "SKLightNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklightnode",
    "html": "Overview\n\nTo use lighting, add a light node to the scene. Because lights are nodes, they can be moved or perform actions just like other nodes. However, light nodes are invisible except through their effects on sprite nodes configured to interact with them. When a sprite node is affected by a light, the lighting properties of the light node and the lighting properties of the sprite node determine what is rendered. Lighting may affect how unrelated portions of the scene are rendered. For example, if a sprite is configured to cast a shadow, the shadow is rendered on top of other content.\n\nAn SKLightNode object and an SKSpriteNode object add lighting to the scene if all of the following are true:\n\nThe light node and the sprite node are both in the scene.\n\nThe light node’s isEnabled property is true.\n\nThe light node’s categoryBitMask property and one of the sprite’s lighting masks are logically combined using an AND operation, and the result is a nonzero number.\n\nTable 1 describes the different kinds of effects that can be generated by a light, based on which mask is being tested on the sprite.\n\nTable 1 Lighting effects\n\nSprite Node Mask\n\n\t\n\nEffect\n\n\n\n\nlightingBitMask\n\n\t\n\nThe sprite is lit by the light with specular, diffuse, and ambient lighting.\n\n\n\n\nshadowCastBitMask\n\n\t\n\nWhen the light casts a ray that intersects the sprite, a shadow is projected past the sprite, rendered on top of any content that is below the sprite.\n\n\n\n\nshadowedBitMask\n\n\t\n\nIf the sprite is inside a shadow cast by a light and the sprite has a lower z position than the light, the shadow affects how the sprite is lit.\n\nIf any of the criteria are not met, the sprite is considered unlit and is rendered using the default behavior.\n\nTopics\nFirst Steps\nLighting a Sprite with Light Nodes\nAdd lighting and shadows to your scene with light nodes.\nDetermining Whether a Light Node Is Active\nvar isEnabled: Bool\nA Boolean value that indicates whether the node is casting light.\nvar categoryBitMask: UInt32\nA mask that defines which categories this light belongs to.\nConfiguring the Lighting Properties\nvar ambientColor: UIColor\nThe ambient color of the light.\nvar lightColor: UIColor\nThe diffuse and specular color of the light source.\nvar shadowColor: UIColor\nThe color of any shadow cast by a sprite.\nvar falloff: CGFloat\nThe exponent for the rate of decay of the light source.\nRelationships\nInherits From\nSKNode\nSee Also\nNodes for Environmental Effects\nclass SKAudioNode\nA node that plays audio.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes."
  },
  {
    "title": "SKEmitterNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skemitternode",
    "html": "Overview\n\nA SKEmitterNode object is a node that automatically creates and renders small particle sprites. Particles are privately owned by SpriteKit—your game cannot access the generated sprites. For example, you cannot add physics shapes to particles. Emitter nodes are often used to create smoke, fire, sparks, and other particle effects. A particle is similar to an SKSpriteNode object; it renders a textured or untextured image that is sized, colorized, and blended into the scene. However, particles differ from sprites in two important ways:\n\nA particle’s texture is always stretched uniformly.\n\nParticles are not represented by objects in SpriteKit. This means you cannot perform node-related tasks on particles, nor can you associate physics bodies with particles to make them interact with other content. Although there is no visible class representing particles added by the emitter node, you can think of a particle as having properties like any other object.\n\nParticles are purely visual objects, and their behavior is entirely defined by the emitter node that created them. The emitter node contains many properties to control the behavior of the particles it generates, including:\n\nThe birth rate and lifetime of the particle. You can also specify the order in which the particles are rendered and the maximum number of particles that are created before the emitter turns itself off.\n\nThe starting values of the particle, including its position, orientation, color, and size. You can choose to have these starting values randomized.\n\nThe changes to apply to the particle over its lifetime. Typically, these are specified as a rate of change over time. For example, you might specify that a particle rotates at a particular rate, in radians per second. The emitter automatically updates the particle data for each frame. In most cases, you can also create more sophisticated behaviors using keyframe sequences. For example, you might specify a keyframe sequence for a particle so that it starts out small, scales up to a larger size, then shrinks before dying.\n\nTopics\nFirst Steps\nCreating Particle Effects\nAdd particle effects to your app by creating repeatable particles in Xcode's editor, or in code.\nChoosing Which Node in the Scene Emits Particles\nChoose which node in the scene emits particles.\nChanging the Location of Particles in Your Scene\nSet a target node from which SpriteKit creates particles.\nvar targetNode: SKNode?\nThe target node that renders the emitter’s particles.\nControlling When Particles Are Created\nfunc advanceSimulationTime(TimeInterval)\nAdvances the emitter particle simulation.\nfunc resetSimulation()\nRemoves all existing particles and restarts the simulation.\nvar particleBirthRate: CGFloat\nThe rate at which new particles are created.\nvar numParticlesToEmit: Int\nThe number of particles the emitter should emit before stopping.\nControlling the Rendering Order of an Emitter's Particles\nvar particleRenderOrder: SKParticleRenderOrder\nThe order in which the emitter’s particles are rendered.\nenum SKParticleRenderOrder\nThe order to use when the emitter’s particles are rendered.\nControlling Particle Lifetime\nvar particleLifetime: CGFloat\nThe average lifetime of a particle, in seconds.\nvar particleLifetimeRange: CGFloat\nThe range of allowed random values for a particle’s lifetime.\nControlling Particle Position\nvar particlePosition: CGPoint\nThe average starting position for a particle.\nvar particlePositionRange: CGVector\nThe range of allowed random values for a particle’s position.\nvar particleZPosition: CGFloat\nThe average starting depth of a particle.\nvar particleZPositionRange: CGFloat\nThe range of allowed random values for a particle’s depth.\nControlling Particle Velocity and Acceleration\nvar particleSpeed: CGFloat\nThe average initial speed of a new particle, in points per second.\nvar particleSpeedRange: CGFloat\nThe range of allowed random values for a particle’s initial speed.\nvar emissionAngle: CGFloat\nThe average initial direction of a particle, expressed as an angle in radians.\nvar emissionAngleRange: CGFloat\nThe range of allowed random values for a particle’s initial direction, expressed as an angle in radians.\nvar xAcceleration: CGFloat\nThe acceleration to apply to a particle’s horizontal velocity.\nvar yAcceleration: CGFloat\nThe acceleration to apply to a particle’s vertical velocity.\nvar particleZPositionSpeed: CGFloat\nThe speed at which the particle’s depth changes.\nAdjusting a Particle’s Rotation\nvar particleRotation: CGFloat\nThe average initial rotation of a particle, expressed as an angle in radians.\nvar particleRotationRange: CGFloat\nThe range of allowed random values for a particle’s initial rotation, expressed as an angle in radians.\nvar particleRotationSpeed: CGFloat\nThe speed at which a particle rotates, expressed in radians per second.\nScaling Particles by a Factor\nvar particleScale: CGFloat\nThe average initial scale factor of a particle.\nvar particleScaleRange: CGFloat\nThe range of allowed random values for a particle’s initial scale.\nvar particleScaleSpeed: CGFloat\nThe rate at which a particle’s scale factor changes per second.\nvar particleScaleSequence: SKKeyframeSequence?\nThe sequence used to specify the scale factor of a particle over its lifetime.\nChanging a Particle's Source Image and Size\nvar particleTexture: SKTexture?\nThe texture to use to render a particle.\nvar particleSize: CGSize\nThe starting size of each particle.\nConfiguring Particle Color\nvar particleColorSequence: SKKeyframeSequence?\nThe sequence used to specify the color components of a particle over its lifetime.\nvar particleColor: UIColor\nThe average initial color for a particle.\nvar particleColorAlphaRange: CGFloat\nThe range of allowed random values for the alpha component of a particle’s initial color.\nvar particleColorBlueRange: CGFloat\nThe range of allowed random values for the blue component of a particle’s initial color.\nvar particleColorGreenRange: CGFloat\nThe range of allowed random values for the green component of a particle’s initial color.\nvar particleColorRedRange: CGFloat\nThe range of allowed random values for the red component of a particle’s initial color.\nvar particleColorAlphaSpeed: CGFloat\nThe rate at which the alpha component of a particle’s color changes per second.\nvar particleColorBlueSpeed: CGFloat\nThe rate at which the blue component of a particle’s color changes per second.\nvar particleColorGreenSpeed: CGFloat\nThe rate at which the green component of a particle’s color changes per second.\nvar particleColorRedSpeed: CGFloat\nThe rate at which the red component of a particle’s color changes per second.\nControlling How the Texture is Blended with Particle Color\nvar particleColorBlendFactorSequence: SKKeyframeSequence?\nThe sequence used to specify the color blend factor of a particle over its lifetime.\nvar particleColorBlendFactor: CGFloat\nThe average starting value for the color blend factor.\nvar particleColorBlendFactorRange: CGFloat\nThe range of allowed random values for a particle’s starting color blend factor.\nvar particleColorBlendFactorSpeed: CGFloat\nThe rate at which the color blend factor changes per second.\nBlending Particles with the Framebuffer\nChange how an emitter uses an alpha value, such as additive blending, that results in the emitter being brighter than it was before.\nvar particleBlendMode: SKBlendMode\nThe blending mode used to blend particles into the framebuffer.\nvar particleAlphaSequence: SKKeyframeSequence?\nThe sequence used to specify the alpha value of a particle over its lifetime.\nvar particleAlpha: CGFloat\nThe average starting alpha value for a particle.\nvar particleAlphaRange: CGFloat\nThe range of allowed random values for a particle’s starting alpha value.\nvar particleAlphaSpeed: CGFloat\nThe rate at which the alpha value of a particle changes per second.\nAnimating Particles\nChange particles over time using actions or keyframe sequences.\nAnimating Particle Properties Across Disparate Values\nSupply keyframe sequences to do linear or nonlinear particle animations.\nvar particleAction: SKAction?\nAn action executed by new particles.\nApplying Physics Fields to the Particles\nvar fieldBitMask: UInt32\nA mask that defines which categories of physics fields can exert forces on the particles.\nTaking Full Control of Particle Drawing with a Shader\nGetting Started with Particle Shaders\nProvide custom shader code to alter a particle's look.\nvar shader: SKShader?\nA custom shader used to determine how particles are rendered.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nGets the value of a shader attribute.\nMaximizing Particle Run-Time Performance\nOptimizing Emitter Node Performance\nUse proven methods to rapidly create and play back performant particle effects.\nRelationships\nInherits From\nSKNode\nSee Also\nNodes that Draw\nMaximizing Node Drawing Performance\nStructure your nodes for maximum performance.\nclass SKSpriteNode\nAn image or solid color.\nclass SKShapeNode\nA mathematical shape that can be stroked or filled.\nclass SKLabelNode\nA graphical element that draws text.\nclass SKVideoNode\nA graphical element that plays video content.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SK3DNode\n3D SceneKit content drawn as a flattened sprite."
  },
  {
    "title": "dragField() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520225-dragfield",
    "html": "Return Value\n\nA new drag field node.\n\nDiscussion\n\nThe force is applied in the opposite direction of the physics body’s velocity property and has a magnitude proportional to the field’s strength property and the physics body’s speed. This field models Stoke’s Law.\n\nSee Also\nCreating Field Nodes\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "SKAudioNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skaudionode",
    "html": "Overview\n\nA SKAudioNode object is used to add an audio to a scene. The sounds are played automatically using AVFoundation, and the node can optionally add 3D spatial audio effects to the audio when it is played.\n\nThe currently presented SKScene object mixes the audio from nodes in the scene based on parameters defined in the AVAudio3DMixing protocol. A scene’s audioEngine property allows overall control of volume and playback.\n\nBy default, SKAudioNode objects are positional, i.e. their isPositional property is set to true. If you add an audio node to a scene with a listener set, SpriteKit will set the stereo balance and the volume based on the relative positions of the two nodes.\n\nYou can explicitly set the volume or stereo balance to an audio node by running actions on it.\n\nSpriteKit includes actions that reduce an audio node’s volume by changing either its occlusion or obstruction. The difference between these actions is that occlusion affects both the direct and reverb paths of the sound while obstruction only affects the direct path. The change volume action offers absolute control over an audio node’s volume.\n\nYou can manually set the stereo balance of an audio node with a stereo pan action.\n\nSpecial effects, such as speeding up or slowing down audio by changing the playback rate and adding reverb are also available as audio actions.\n\nTo learn more about audio actions, see Controlling the Audio of a Node.\n\nTopics\nFirst Steps\n\nUsing Audio Nodes with the Scene's Listener\nAdd audio to your scene, and optionally give it 2D-positional mixing characteristics.\nInitializing Audio Nodes\ninit(avAudioNode: AVAudioNode?)\nInitializes an audio node from an AVFoundation audio node.\ninit(fileNamed: String)\nInitializes an audio node from an audio asset with the specified filename.\ninit(url: URL)\nInitializes an audio node from an audio asset with the specified URL.\ninit?(coder: NSCoder)\nTells you when to initialize an audio node that has been unarchived.\nConfiguring Audio Nodes\nvar avAudioNode: AVAudioNode?\nThe audio node’s current audio asset.\nvar isPositional: Bool\nA Boolean property that indicates whether the node’s audio is altered based on the position of the node.\nvar autoplayLooped: Bool\nA Boolean value that indicates whether the audio should play in a loop when the node is added to the scene.\nRelationships\nInherits From\nSKNode\nConforms To\nNSSecureCoding\nSee Also\nNodes for Environmental Effects\nclass SKLightNode\nA node that lights surrounding nodes.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes."
  },
  {
    "title": "SK3DNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sk3dnode",
    "html": "Overview\n\nUse SK3DNode objects to incorporate 3D SceneKit content into a SpriteKit-based game. When SpriteKit renders the node, the SceneKit scene is animated and rendered first. Then this rendered image is composited into the SpriteKit scene. Use the scnScene property to specify the SceneKit scene to be rendered.\n\nTopics\nGetting Started with 3D Node\nDisplaying 3D Content in a SpriteKit Scene\nDraw SceneKit content in a SpriteKit scene by using a 3D node.\nCreating 3D Nodes\ninit(viewportSize: CGSize)\nInitializes a new 3D node.\ninit?(coder: NSCoder)\nTells you when to initialize a 3D node that has been unarchived.\nConfiguring a 3D Node\nvar viewportSize: CGSize\nThe size of the image rendered by the node.\nvar scnScene: SCNScene?\nThe SceneKit scene to render.\nvar pointOfView: SCNNode?\nThe Scene Kit node from which the scene’s contents are viewed when rendered.\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether Scene Kit automatically adds lights to a scene.\nAnimating a 3D Node’s Content in Scene Kit\nvar isPlaying: Bool\nA Boolean value that determines whether the scene is playing.\nvar loops: Bool\nA Boolean value that determines whether Scene Kit restarts the scene time after all animations in the scene have played.\nvar sceneTime: TimeInterval\nThe current scene time.\nProjecting Points and Performing Hit-Testing\nfunc hitTest(CGPoint, options: [String : Any]?) -> [SCNHitTestResult]\nSearches the Scene Kit scene for objects corresponding to a point in the rendered image.\nfunc projectPoint(vector_float3) -> vector_float3\nProjects a point from the 3D world coordinate system of the SceneKit scene to the 2D viewport coordinate system of the SpriteKit node.\nfunc unprojectPoint(vector_float3) -> vector_float3\nUnprojects a point from the SpriteKit node’s 2D viewport coordinate system to the 3D world coordinate system of the SceneKit scene.\nRelationships\nInherits From\nSKNode\nSee Also\nNodes that Draw\nMaximizing Node Drawing Performance\nStructure your nodes for maximum performance.\nclass SKSpriteNode\nAn image or solid color.\nclass SKShapeNode\nA mathematical shape that can be stroked or filled.\nclass SKEmitterNode\nA source of various particle effects.\nclass SKLabelNode\nA graphical element that draws text.\nclass SKVideoNode\nA graphical element that plays video content.\nclass SKTileMapNode\nA two-dimensional array of images."
  },
  {
    "title": "SKVideoNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skvideonode",
    "html": "Overview\n\nThis class renders a video at a given size and location in your scene with no exposed player controls.\n\nTopics\nGetting Started with Video\nAdding a Video to a Scene\nPlay video in your scene by adding a video node.\nCreating a Video Node\ninit(avPlayer: AVPlayer)\nInitializes a video node using an existing AVPlayer object.\ninit(fileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(url: URL)\nInitializes a video node using a URL.\ninit?(coder: NSCoder)\nTells you when to initialize a video node that was created from an archive.\ninit(videoFileNamed: String)\nInitializes a video node using a video file stored in the app bundle.\ninit(videoURL: URL)\nInitializes a video node using a URL that points to a video file.\nSetting the Video Node’s Visual Properties\nvar anchorPoint: CGPoint\nThe point in the sprite that corresponds to the node’s position.\nvar size: CGSize\nThe dimensions of the video node, in points.\nControlling Video Playback\nfunc play()\nStarts video playback.\nfunc pause()\nPauses video playback.\nRelationships\nInherits From\nSKNode\nSee Also\nNodes that Draw\nMaximizing Node Drawing Performance\nStructure your nodes for maximum performance.\nclass SKSpriteNode\nAn image or solid color.\nclass SKShapeNode\nA mathematical shape that can be stroked or filled.\nclass SKEmitterNode\nA source of various particle effects.\nclass SKLabelNode\nA graphical element that draws text.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SK3DNode\n3D SceneKit content drawn as a flattened sprite."
  },
  {
    "title": "SKLabelNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sklabelnode",
    "html": "Overview\n\nSKLabelNode allows you to render text in your scene. You can define a custom style using properties such as fontName and fontColor, or configure the look of your text with an NSAttributedString.\n\nTopics\nGetting Started with Labels\nAdding Text to a Scene\nDraw text in your scene, such as a health indicator or a \"Game Over\" banner, by using a label node.\nCreating a Label\ninit(fontNamed: String?)\nInitializes a new label object with a specified font.\ninit(text: String?)\nInitializes a new label object with a text string.\ninit(attributedText: NSAttributedString?)\nInitializes a new label object with an attributed text string.\nSetting a Label's Text\nvar text: String?\nThe string that the label node displays.\nvar attributedText: NSAttributedString?\nThe attributed string displayed by the label.\nSpecifying a Label's Font\nvar fontColor: UIColor?\nThe color of the label.\nvar fontName: String?\nThe font used for the text in the label.\nvar fontSize: CGFloat\nThe size of the font used in the label.\nControlling a Label's Alignment\nvar verticalAlignmentMode: SKLabelVerticalAlignmentMode\nThe vertical position of the text within the node.\nenum SKLabelVerticalAlignmentMode\nOptions for aligning text vertically.\nvar horizontalAlignmentMode: SKLabelHorizontalAlignmentMode\nThe horizontal position of the text within the node.\nenum SKLabelHorizontalAlignmentMode\nOptions for aligning text horizontally.\nDefining a Label's Line-Breaking Behavior\nConfigure these properties to control line-breaking behavior.\nvar preferredMaxLayoutWidth: CGFloat\nThe width, in screen points, after which line-break mode should be applied.\nvar lineBreakMode: NSLineBreakMode\nDetermines the line-break mode for multiple lines.\nvar numberOfLines: Int\nDetermines the number of lines to draw.\nColorizing a Label\nvar color: UIColor?\nAn alternative to the font color that can be used for animations.\nvar colorBlendFactor: CGFloat\nA floating-point value that describes how the color is blended with the font color.\nConfiguring Alpha Blending\nChange how a label uses an alpha value, such as additive blending, that results in the label being brighter than it was before.\nvar blendMode: SKBlendMode\nThe blend mode used to draw the label into the parent’s framebuffer.\nRelationships\nInherits From\nSKNode\nSee Also\nNodes that Draw\nMaximizing Node Drawing Performance\nStructure your nodes for maximum performance.\nclass SKSpriteNode\nAn image or solid color.\nclass SKShapeNode\nA mathematical shape that can be stroked or filled.\nclass SKEmitterNode\nA source of various particle effects.\nclass SKVideoNode\nA graphical element that plays video content.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SK3DNode\n3D SceneKit content drawn as a flattened sprite."
  },
  {
    "title": "SKSpriteNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skspritenode",
    "html": "Overview\n\nSKSpriteNode is an onscreen graphical element that can be initialized from an image or a solid color. SpriteKit adds functionality to its ability to display images using the functions discussed below.\n\nTopics\nCreating a Sprite from an Image Filename\nStart with the basic ways to configure and use a sprite node.\nGetting Started with Sprite Nodes\nLearn the basics about using images, also known as sprites, with SpriteKit.\ninit(imageNamed: String)\nInitializes a textured sprite using an image file.\ninit(imageNamed: String, normalMapped: Bool)\nInitializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting.\nCreating a Sprite from a Texture\nReuse a texture across multiple sprite nodes using initializers or the setter.\ninit(texture: SKTexture?)\nInitializes a textured sprite using an existing texture object.\ninit(texture: SKTexture?, color: UIColor, size: CGSize)\nInitializes a textured sprite in color using an existing texture object.\ninit(texture: SKTexture?, size: CGSize)\nInitializes a textured sprite using an existing texture object but with a specified size.\ninit(texture: SKTexture?, normalMap: SKTexture?)\nInitializes a textured sprite with a normal map to simulate 3D lighting.\nvar texture: SKTexture?\nThe texture used to draw the sprite.\nCreating a Solid-Color Sprite\nCreate a colored block of any size that's also useful for visual debugging.\ninit(color: UIColor, size: CGSize)\nInitializes a single-color sprite node.\nInitializing a Sprite from an Archive\ninit?(coder: NSCoder)\nTells you when to initialize a sprite from an archive.\nSetting a Sprite's Size and Position\nControl a sprite's onscreen placement and size.\nUsing the Anchor Point to Move a Sprite\nLearn how the anchor point affects a sprite's position.\nvar size: CGSize\nThe dimensions of the sprite, in points.\nfunc scale(to: CGSize)\nScales the sprite node to a specified size.\nvar anchorPoint: CGPoint\nDefines the point in the sprite that corresponds to the node’s position.\nScaling a Sprite in Nine Parts\nResize a sprite in nine parts by defining a center rectangle.\nResizing a Sprite in Nine Parts\nScale a sprite using nine-part algorithm.\nvar centerRect: CGRect\nEnable nine-part stretching of the sprite's texture.\nTinting a Sprite\nCombine color and blend factor properties to colorize a textured sprite.\nTinting a Sprite\nProvide a color and blend factor to additively color your sprite.\nvar color: UIColor\nThe sprite’s color.\nvar colorBlendFactor: CGFloat\nA floating-point value that describes how the color is blended with the sprite’s texture.\nConfiguring Alpha Blendling\nDetermine how a sprite uses an alpha value, such as additive blending, that results in the sprite being brighter than it was before.\nBlending a Sprite with Different Interpretations of Alpha\nReinterpret a sprite's alpha property to react differently to the objects below it.\nvar blendMode: SKBlendMode\nThe blend mode used to draw the sprite into the parent’s framebuffer.\nenum SKBlendMode\nThe modes that describe how the source and destination pixel colors are used to calculate the new destination color.\nLighting a Sprite\nConfigure how a sprite is lit when it's near a light node.\nLighting a Sprite with Light Nodes\nAdd lighting and shadows to your scene with light nodes.\nvar lightingBitMask: UInt32\nA mask that defines how this sprite is lit by light nodes in the scene.\nvar shadowedBitMask: UInt32\nA mask that defines which lights add shadows to the sprite.\nvar shadowCastBitMask: UInt32\nA mask that defines which lights are occluded by this sprite.\nvar normalTexture: SKTexture?\nA texture that specifies the normal map for the sprite.\nAdding a Custom Shader to a Sprite\nSupply a code file that does custom per-pixel rendering or colorization of a sprite.\nApplying Shaders to a Sprite\nWrite custom GLSL code that modifies the look of your sprite.\nvar shader: SKShader?\nA text file that defines code that does custom per-pixel drawing or colorization.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader.\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nSets the value of a shader attribute.\nAnimating a Sprite by Changing its Texture\nAnimating a Sprite by Changing its Texture\nLoad a sequence of images and play them back at a rate you define, while optionally looping the resulting animation.\nInstance Properties\nvar customPlaygroundQuickLook: PlaygroundQuickLook\nA custom playground quick look for this instance.\nDeprecated\nRelationships\nInherits From\nSKNode\nConforms To\nSKWarpable\nSee Also\nNodes that Draw\nMaximizing Node Drawing Performance\nStructure your nodes for maximum performance.\nclass SKShapeNode\nA mathematical shape that can be stroked or filled.\nclass SKEmitterNode\nA source of various particle effects.\nclass SKLabelNode\nA graphical element that draws text.\nclass SKVideoNode\nA graphical element that plays video content.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SK3DNode\n3D SceneKit content drawn as a flattened sprite."
  },
  {
    "title": "SKPhysicsBody | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody",
    "html": "Overview\n\nAssign a SKPhysicsBody object to the physicsBody property of the SKNode object to add physics simulation to the node. When a scene processes a new frame, it performs physics calculations on physics bodies attached to nodes in the scene. These calculations include gravity, friction, and collisions with other bodies. You can also apply your own forces and impulses to a body. After the scene completes these calculations, it updates the positions and orientations of the node objects.\n\nImportant\n\nA physics body must be associated with a node before you apply forces or impulses to it.\n\nSpriteKit supports two kinds of physics bodies, volume-based bodies and edge-based bodies. When you create a physics body, its kind, size, and shape are determined by the constructor method you call. An edge-based body does not have mass or volume and is unaffected by forces or impulses in the system. Edge-based bodies are used to represent volumeless boundaries or hollow spaces in your physics simulation. In contrast, volume-based bodies are used to represent objects with mass and volume. The isDynamic property controls whether a volume-based body is affected by gravity, friction, collisions with other objects, and forces or impulses you directly apply to it.\n\nThe SKPhysicsBody class defines the physical characteristics for the body when it is simulated by the scene. For volume-based bodies, the most important property is the mass property. A volume-based body is assumed to have a uniform density. You can either set the mass property directly, or you can set the body’s density property and let the physics body calculate its own mass. All values in Sprite Kit are specified using the International System of Units (SI units). The actual forces and mass values are not important so long as your game uses consistent values.\n\nWhen you design a game that uses physics, you define the different categories of physics objects that appear in the scene. You define up to 32 different categories of physics bodies, and a body can be assigned to as many of these categories as you want. In addition to declaring its own categories, a physics body also declares which categories of bodies it interacts with. See Working with Collisions and Contacts. You use a similar mechanism to declare which physics field nodes (SKFieldNode) can affect the physics body.\n\nFor a volume-based body, you can dynamically control how the body is affected by forces or collisions. See Defining How Forces Affect a Physics Body.\n\nTopics\nFirst Steps\nGetting Started with Physics Bodies\nCreate and assign a physics body to enable physics.\nCreating a Body from a Shape\ninit(circleOfRadius: CGFloat)\nCreates a circular physics body centered on the owning node’s origin.\ninit(circleOfRadius: CGFloat, center: CGPoint)\nCreates a circular physics body centered on an arbitrary point.\ninit(rectangleOf: CGSize)\nCreates a rectangular physics body centered on the owning node’s origin.\ninit(rectangleOf: CGSize, center: CGPoint)\nCreates a rectangular physics body centered on an arbitrary point.\ninit(polygonFrom: CGPath)\nCreates a polygonal physics body.\nCreating a Body from a Texture\nShaping a Physics Body to Match a Node's Graphics\nShape a physics body to your graphics for the right blend of collision accuracy and performance.\ninit(texture: SKTexture, size: CGSize)\nCreates a physics body from the contents of a texture.\ninit(texture: SKTexture, alphaThreshold: Float, size: CGSize)\nCreates a physics body from the contents of a texture, capturing only the texels that exceed a specified transparency value.\nCreating a Body from a Collection of Bodies\ninit(bodies: [SKPhysicsBody])\nCreates a physics body that's shaped like a union of the argument physics bodies.\nCreating an Edge-Based Physics Body\nCreating an Edge Loop Around a Scene\nBorder your scene with an obstacle that physics bodies cannot penetrate.\ninit(edgeLoopFrom: CGRect)\nCreates an edge loop from a rectangle.\ninit(edgeFrom: CGPoint, to: CGPoint)\nCreates an edge between two points.\ninit(edgeLoopFrom: CGPath)\nCreates an edge loop from a path.\ninit(edgeChainFrom: CGPath)\nCreates an edge chain from a path.\nDefining How Forces Affect a Physics Body\nvar affectedByGravity: Bool\nA Boolean value that indicates whether this physics body is affected by the physics world’s gravity.\nvar allowsRotation: Bool\nA Boolean value that indicates whether the physics body is affected by angular forces and impulses applied to it.\nvar isDynamic: Bool\nA Boolean value that indicates whether the physics body is moved by the physics simulation.\nDefining a Physics Body’s Physical Properties\nConfiguring a Physics Body\nMove a physics body, and make it collide with other objects, by setting its physical properties once or changing them dynamically.\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar density: CGFloat\nThe density of the object, in kilograms per square meter.\nvar area: CGFloat\nThe area covered by the body.\nvar friction: CGFloat\nThe roughness of the surface of the physics body.\nvar restitution: CGFloat\nThe bounciness of the physics body.\nvar linearDamping: CGFloat\nA property that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA property that reduces the body’s rotational velocity.\nWorking with Collisions and Contacts\nAbout Collisions and Contacts\nLearn how to set up nodes for collision detection.\nvar categoryBitMask: UInt32\nA mask that defines which categories this physics body belongs to.\nvar collisionBitMask: UInt32\nA mask that defines which categories of physics bodies can collide with this physics body.\nvar usesPreciseCollisionDetection: Bool\nA Boolean value that determines whether the physics world uses an iterative collision detection algorithm.\nvar contactTestBitMask: UInt32\nA mask that defines which categories of physics bodies cause intersection notifications with this physics body.\nfunc allContactedBodies() -> [SKPhysicsBody]\nThe physics bodies that this physics body is in contact with.\nApplying Forces and Impulses to a Physics Body\nMaking Physics Bodies Move\nMove a body using various physics properties, like velocity, gravity or impulses.\nfunc applyForce(CGVector)\nApplies a force to the center of gravity of a physics body.\nfunc applyTorque(CGFloat)\nApplies torque to an object.\nfunc applyForce(CGVector, at: CGPoint)\nApplies a force to a specific point of a physics body.\nfunc applyImpulse(CGVector)\nApplies an impulse to the center of gravity of a physics body.\nfunc applyAngularImpulse(CGFloat)\nApplies an impulse that imparts angular momentum to an object.\nfunc applyImpulse(CGVector, at: CGPoint)\nApplies an impulse to a specific point of a physics body.\nInspecting a Physics Body’s Position and Velocity\nvar velocity: CGVector\nThe physics body’s velocity vector, measured in meters per second.\nvar angularVelocity: CGFloat\nThe physics body’s angular speed.\nvar isResting: Bool\nA Boolean property that indicates whether the object is at rest within the physics simulation.\nReading a Physics Body’s Node\nvar node: SKNode?\nThe node that this body is connected to.\nDetermining Which Joints Are Connected to a Physics Body\nvar joints: [SKPhysicsJoint]\nThe joints connected to this physics body.\nInteracting with Physics Fields\nvar fieldBitMask: UInt32\nA mask that defines which categories of physics fields can exert forces on this physics body.\nvar charge: CGFloat\nThe electrical charge of the physics body.\nPinning a Physics Body to a Node’s Parent\nPinning and Rotating Physics Bodies\nPin a node so it's free to rotate about a certain point on its parent node.\nvar pinned: Bool\nA Boolean value that indicates whether the physics body’s node is pinned to its parent node.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nPhysics Simulation\nGetting Started with Physics\nSimulate gravity, acceleration, collision detection, or joints.\nclass SKPhysicsWorld\nThe driver of the physics engine in a scene; it exposes the ability for you to configure and query the physics system.\nclass SKPhysicsContact\nA description of the contact between two physics bodies.\nprotocol SKPhysicsContactDelegate\nMethods your app can implement to respond when physics bodies come into contact.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes."
  },
  {
    "title": "SKReferenceNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreferencenode",
    "html": "Overview\n\nSKReferenceNode is used within an archived .sks file to refer to node defined in another .sks file without duplicating its definition. This way, a change to the referenced node propagates to all the references in other files.\n\nNote\n\nSKReferenceNode is mostly used in conjunction with Xcode's SpriteKit Scene editor, but it's possible to instantiate it yourself and use the resolve() function as a handy way to restore a node's appearance.\n\nAs an example, you might want to share an enemy ship across two different levels, Scene1.sks and Scene2.sks, in a level-based game. Reference nodes allow you to do that without creating copies of the shared node and its properties.\n\nTo use a reference node:\n\nCreate the shared content in a separate archive\n\nAdd references to the shared archive within your scene archives\n\nWhen each scene is loaded, the reference nodes are resolved dynamically, and therefore you only need to configure a shared object in one place.\n\nTopics\nInitializers\ninit(url: URL)\nCreates a reference node from a URL.\ninit(url: URL?)\nInitializes a reference node from a URL.\ninit(fileNamed: String)\nCreates a reference node from a file in the app’s main bundle.\ninit(fileNamed: String?)\nInitializes a reference node from a file in the app’s main bundle.\ninit?(coder: NSCoder)\nA method that initializes a reference node from an archive.\nRegenerating\nLoad a reference nodes contents freshly from the archive again.\nfunc resolve()\nLoads the reference node’s content and adds it as a new child node.\nLoading Callback\nfunc didLoad(SKNode?)\nA method called by SpriteKit after the reference node’s contents are loaded.\nRelationships\nInherits From\nSKNode\nSee Also\nBase Nodes\nUsing Base Nodes to Lay Out SpriteKit Content\nUse nonvisual nodes to define the layout of a scene.\nclass SKNode\nThe base class of all SpriteKit nodes.\nclass SKCameraNode\nA node that determines which parts of the scene are visible within a view."
  },
  {
    "title": "SKPhysicsWorld | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsworld",
    "html": "Overview\n\nSKPhysicsWorld runs the physics engine of a scene and is the place that contact detection occurs. Do not create a SKPhysicsWorld directly; the system creates a physics world and adds it to the scene's physicsWorld property.\n\nThe physics world allows you to:\n\nSet important properties like gravity\n\nJoin two physics bodies using an SKPhysicsJoint\n\nRespond to collision between two physics bodies using contactDelegate\n\nDo custom collisions detection or hit testing\n\nTopics\nConfiguring the Physics World\nvar gravity: CGVector\nA vector that specifies the gravitational acceleration applied to physics bodies in the physics world.\nvar speed: CGFloat\nThe rate at which the simulation executes.\nJoining Physics Bodies with Joints\nfunc add(SKPhysicsJoint)\nAdds a joint to the physics world.\nfunc removeAllJoints()\nRemoves all joints from the physics world.\nfunc remove(SKPhysicsJoint)\nRemoves a specific joint from the physics world.\nDetecting Collisions\nvar contactDelegate: SKPhysicsContactDelegate?\nA delegate that is called when two physics bodies come in contact with each other.\nSearching the Scene for Physics Bodies\nSearching the World for Physics Bodies\nCast a ray to find the physics bodies in the scene that intersect it.\nfunc body(alongRayStart: CGPoint, end: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that intersects a ray.\nfunc body(at: CGPoint) -> SKPhysicsBody?\nSearches for the first physics body that contains a point.\nfunc body(in: CGRect) -> SKPhysicsBody?\nSearches for the first physics body that intersects the specified rectangle.\nfunc enumerateBodies(alongRayStart: CGPoint, end: CGPoint, using: (SKPhysicsBody, CGPoint, CGVector, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect a ray.\nfunc enumerateBodies(at: CGPoint, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that contain a point.\nfunc enumerateBodies(in: CGRect, using: (SKPhysicsBody, UnsafeMutablePointer<ObjCBool>) -> Void)\nEnumerates all the physics bodies in the scene that intersect the specified rectangle.\nSampling Physics Fields\nfunc sampleFields(at: vector_float3) -> vector_float3\nSamples all of the field nodes in the scene and returns the summation of their forces at that point.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nPhysics Simulation\nGetting Started with Physics\nSimulate gravity, acceleration, collision detection, or joints.\nclass SKPhysicsBody\nAn object that adds physics simulation to a node.\nclass SKPhysicsContact\nA description of the contact between two physics bodies.\nprotocol SKPhysicsContactDelegate\nMethods your app can implement to respond when physics bodies come into contact.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes."
  },
  {
    "title": "SKNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sknode",
    "html": "Overview\n\nSKNode provides base properties for its subclasses and it can be used as a container or layout tool for other nodes. For example, you might add a collection of nodes as children to an SKNode that all move together within the scene; because nodes inherit the properties of their parent, changing the parent node's position propagates the change to its children as well.\n\nSKNode does not draw any content itself. Its visual counterparts are listed in Nodes that Draw.\n\nTopics\nFirst Steps\nGetting Started with Nodes\nLearn about the fundamental properties that provide a foundation for all other nodes.\ninit()\nInitializes a blank node.\ninit?(fileNamed: String)\nCreates a new node by loading an archive file from the game’s main bundle.\ninit?(coder: NSCoder)\nCalled when a node is initialized from an .sks file.\ninit(fileNamed: String, securelyWithClasses: Set<AnyHashable>)\nPositioning Content in a Scene\nLay out content in a scene by positioning it within its parent's coordinate system.\nvar position: CGPoint\nThe position of the node in its parent's coordinate system.\nQuerying the Content Size\nRead the location and size of a node or its children in the parent's coordinate space.\nvar frame: CGRect\nA rectangle in the parent’s coordinate system that contains the node’s content, ignoring the node’s children.\nfunc calculateAccumulatedFrame() -> CGRect\nReturns a rectangle in the parent’s coordinate system that contains the position and size of itself and all child nodes.\nConfiguring Draw Order\nAbout Node Drawing Order\nUnderstand how SpriteKit layers your scene's nodes from top to bottom.\nvar zPosition: CGFloat\nThe height of the node relative to its parent.\nScaling and Rotating\nvar zRotation: CGFloat\nThe Euler rotation about the z axis (in radians).\nfunc setScale(CGFloat)\nSets the xScale and yScale properties of the node.\nvar xScale: CGFloat\nA scaling factor that multiplies the width of a node and its children.\nvar yScale: CGFloat\nA scaling factor that multiplies the height of a node and its children.\nAccessing Related Nodes\nAbout SpriteKit Coordinate Systems\nLearn how a node conforms to its coordinate systems.\nvar scene: SKScene?\nThe scene node that contains this node.\nvar parent: SKNode?\nThe node’s parent node.\nvar children: [SKNode]\nThe node’s children.\nModifying the Node Tree\nAccessing and Modifying the Node Tree\nSee the objects and functions you use to control the node tree's composition.\nfunc addChild(SKNode)\nAdds a node to the end of the receiver’s list of child nodes.\nfunc insertChild(SKNode, at: Int)\nInserts a node into a specific position in the receiver’s list of child nodes.\nfunc isEqual(to: SKNode) -> Bool\nCompares the parameter node to the receiving node.\nfunc move(toParent: SKNode)\nMoves the node to a new parent node in the scene.\nfunc removeFromParent()\nRemoves the receiving node from its parent.\nfunc removeAllChildren()\nRemoves all of the node’s children.\nfunc removeChildren(in: [SKNode])\nRemoves a list of children from the receiving node.\nfunc inParentHierarchy(SKNode) -> Bool\nReturns a Boolean value that indicates whether the node is a descendant of the target node.\nCustomizing Nodes\nCustomizing the Behavior of a Node\nOrganize your app's logic and display code with nodes.\nPropagating Properties to Children\nAbout Node Property Propagation\nLearn which properties of a node affect its child nodes.\nAccessing Nodes by Name\nAccess nodes by name instead of instance properties.\nSearching the Node Tree\nAccess nodes by name to avoid needing an instance variable.\nvar name: String?\nThe node’s assignable name.\nfunc childNode(withName: String) -> SKNode?\nSearches the children of the receiving node for a node with a specific name.\nfunc enumerateChildNodes(withName: String, using: (SKNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nSearches the children of the receiving node to perform processing for nodes that share a name.\nsubscript(String) -> [SKNode]\nReturns an array of nodes that match the name parameter.\nAltering Node Visibility\nControl whether a node is visible or semitransparent.\nvar alpha: CGFloat\nThe transparency value applied to the node’s contents.\nvar isHidden: Bool\nA Boolean value that determines whether a node and its descendants are rendered.\nRunning Actions\nRun actions on a node and control their timing.\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nfunc run(SKAction)\nAdds an action to the list of actions executed by the node.\nfunc run(SKAction, completion: () -> Void)\nAdds an action to the list of actions executed by the node and schedules the argument block to be run upon completion of the action.\nfunc run(SKAction, withKey: String)\nAdds an identifiable action to the list of actions executed by the node.\nvar speed: CGFloat\nA speed modifier applied to all actions executed by a node and its descendants.\nvar isPaused: Bool\nA Boolean value that determines whether actions on the node and its descendants are processed.\nfunc action(forKey: String) -> SKAction?\nReturns an action associated with a specific key.\nfunc hasActions() -> Bool\nReturns a Boolean value that indicates whether the node is executing actions.\nfunc removeAllActions()\nEnds and removes all actions from the node.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key.\nAdding Physics Behaviors\nEnable physics behaviors by adding a body.\nGetting Started with Physics Bodies\nCreate and assign a physics body to enable physics.\nvar physicsBody: SKPhysicsBody?\nThe physics body associated with the node.\nConstraining Node Position or Rotation\nDefine positional contraints relating to other nodes in the scene.\nvar constraints: [SKConstraint]?\nA list of constraints to apply to the node.\nvar reachConstraints: SKReachConstraints?\nThe reach constraints to apply to the node when executing a reach action.\nDetecting Collisions Manually\nAs an alternative to SKPhysicsContactDelegate, manually check if two nodes overlap.\nfunc intersects(SKNode) -> Bool\nReturns a Boolean value that indicates whether this node intersects the specified node.\nAdding GameplayKit Behaviors\nEnable GameplayKit behaviors by defining an entity and its obstacles in a scene.\nvar entity: GKEntity?\nThe GameplayKit entity this node represents.\nclass func obstacles(fromNodeBounds: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming its bounds into the scene’s coordinate system.\nclass func obstacles(fromNodePhysicsBodies: [SKNode]) -> [GKPolygonObstacle]\nConverts each node into an obstacle by transforming the node’s physics body shape into the scene’s coordinate system.\nclass func obstacles(fromSpriteTextures: [SKNode], accuracy: Float) -> [GKPolygonObstacle]\nTurns each node into an obstacle by changing the node’s texture into a physics shape and converting it into the scene’s coordinate system.\nHandling User Input\nEnable user interaction to allow a node to respond to user input.\nControlling User Interaction on Nodes\nEnable your node to respond to user input, like touches or mouse clicks.\nvar isUserInteractionEnabled: Bool\nA Boolean value that indicates whether the node receives touch events.\nvar focusBehavior: SKNodeFocusBehavior\nThe focus behavior for a node.\nHit Testing\nUnderstanding Hit-Testing\nLearn how find child nodes at a given point by using hit-testing.\nfunc contains(CGPoint) -> Bool\nReturns a Boolean value that indicates whether a point lies inside the parent’s coordinate system.\nfunc atPoint(CGPoint) -> SKNode\nReturns the deepest visible descendant that intersects a point.\nfunc nodes(at: CGPoint) -> [SKNode]\nReturns an array of all visible descendants that intersect a point.\nConverting Between Coordinate Systems of Different Nodes\nConverting Coordinate Spaces\nConvert positions across the various coordinate spaces in a scene.\nfunc convert(CGPoint, from: SKNode) -> CGPoint\nConverts a point from the coordinate system of another node in the node tree to the coordinate system of this node.\nfunc convert(CGPoint, to: SKNode) -> CGPoint\nConverts a point in this node’s coordinate system to the coordinate system of another node in the node tree.\nAdding Custom Data Without Subclassing\nQuickly add data to a node without having to subclass it.\nvar userData: NSMutableDictionary?\nA dictionary containing arbitrary data.\nProviding Accessibility\nExtend your app's usability by exposing certain nodes in your scene as Accessibility user interface elements.\nvar accessibilityChildren: [Any]?\nAn array of user interface elements that represent children of this element.\nvar accessibilityFrame: CGRect\nThe size of this user interface element, in screen points.\nvar accessibilityHelp: String?\nThe help description of this user interface element; for example, the text shown in a tooltip.\nvar accessibilityLabel: String?\nA short description of this user interface element.\nvar accessibilityParent: AnyObject?\nThe user interface element that contains this element.\nvar accessibilityRole: String?\nA string value describing the user interface element type; for example, a button.\nvar accessibilityRoleDescription: String?\nA string value describing the user interface element name and type; for example, the Buy button.\nvar accessibilitySubrole: String?\nA string that defines this user interface element's subrole; for example, a full-screen button.\nvar isAccessibilityElement: Bool\nA toggle you implement to indicate to the system whether this user interface element should be exposed to the user.\nvar isAccessibilityEnabled: Bool\nA toggle you implement to indicate to the system whether this user interface element should respond to user input.\nfunc accessibilityHitTest(CGPoint) -> Any?\nReturns the frontmost user interface element in the element hierarchy.\nSetting a Node's Unique Attributes for a Shader\nSet the values that make a node unique to a shader.\nvar attributeValues: [String : SKAttributeValue]\nThe values of each attribute associated with the node's attached shader.\nDeprecated\nfunc setValue(SKAttributeValue, forAttribute: String)\nSets an attribute value for an attached shader\nDeprecated\nfunc value(forAttributeNamed: String) -> SKAttributeValue?\nThe value of a shader attribute.\nDeprecated\nRelationships\nInherits From\nNSObject\nNSResponder\nUIResponder\nConforms To\nNSCopying\nNSSecureCoding\nUIFocusItem\nSee Also\nBase Nodes\nUsing Base Nodes to Lay Out SpriteKit Content\nUse nonvisual nodes to define the layout of a scene.\nclass SKCameraNode\nA node that determines which parts of the scene are visible within a view.\nclass SKReferenceNode\nA node that's defined in an archived .sks file."
  },
  {
    "title": "SKRegion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skregion",
    "html": "Overview\n\nAn SKRegion object defines a mathematical shape and is typically used to determine whether a particular point lies inside this area. For example, regions are used to define the area that a physics field can affect. Regions are defined using paths and mathematical shapes and can also be combined using constructive solid geometry.\n\nTopics\nCreating and Initializing Region Objects\nclass func infinite() -> Self\nReturns a region that defines a region that includes all points.\ninit(size: CGSize)\nInitializes a new region with a rectangular area.\ninit(radius: Float)\nInitializes a new region with a circular area.\ninit(path: CGPath)\nInitializes a new region using a Core Graphics path.\nfunc inverse() -> Self\nReturns a new region that is the mathematical inverse of an existing region.\nfunc byDifference(from: SKRegion) -> Self\nReturns a new region created by subtracting the contents of another region from this region.\nfunc byIntersection(with: SKRegion) -> Self\nReturns a new region created by intersecting the contents of this region with another region.\nfunc byUnion(with: SKRegion) -> Self\nReturns a new region created by combining the contents of this region with another region.\nInteracting with a Region\nvar path: CGPath?\nReturns a Core Graphics path that defines the region.\nfunc contains(CGPoint) -> Bool\nReturns a Boolean value that indicates whether a particular point is contained in the region.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nMathematical Tools\nclass SKKeyframeSequence\nAn object that performs interpolation between values specified at different times (keyframes).\nclass SKRange\nA definition of a range of floating-point values."
  },
  {
    "title": "SKCameraNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skcameranode",
    "html": "Overview\n\nIf you don't use a camera in your scene, you control the visible portion of a scene using its anchorPoint property.\n\nTopics\nFirst Steps\nGetting Started with a Camera\nLearn the semantics of using a camera in your scene.\nNode Visibility\nCheck whether a particular node is onscreen.\nfunc containedNodeSet() -> Set<SKNode>\nFinds nodes that are visible in the camera's viewport.\nfunc contains(SKNode) -> Bool\nChecks to see if a node is visible in the camera’s viewport.\nRelationships\nInherits From\nSKNode\nSee Also\nBase Nodes\nUsing Base Nodes to Lay Out SpriteKit Content\nUse nonvisual nodes to define the layout of a scene.\nclass SKNode\nThe base class of all SpriteKit nodes.\nclass SKReferenceNode\nA node that's defined in an archived .sks file."
  },
  {
    "title": "lowerAngleLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreachconstraints/1519923-loweranglelimit",
    "html": "See Also\nWorking with Reach Constraints\ninit(lowerAngleLimit: CGFloat, upperAngleLimit: CGFloat)\nInitializes a new reach constraint object.\nvar upperAngleLimit: CGFloat\nThe maximum angle that the node can have after it is rotated by a reach event."
  },
  {
    "title": "Using Base Nodes to Lay Out SpriteKit Content | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/nodes_for_scene_building/using_base_nodes_to_lay_out_spritekit_content",
    "html": "Overview\n\nEach onscreen element in SpriteKit is referred to as a node. Nodes are either visual elements or containers of other nodes. You set up the appearance of a SpriteKit scene by adding nodes alongside and on top of each other in a hierarchical form. Collectively, this structure is referred to as the node tree or the node hierarchy.\n\nThese are the basic nonvisual nodes in SpriteKit:\n\nSKNode is a container node. It doesn't render any content of its own, but works as a layout tool for its child nodes.\n\nSKReferenceNode doesn't define content of its own, but refers to another node or archived file that does.\n\nSKCameraNode defines point of view within a scene. Its inverse scale is applied to all nodes in the hierarchy except for its children. Use the children of SKCameraNode for UI elements that should be unaffected by zoom level.\n\nFor a list of visual elements, see Nodes that Draw, which also includes some examples of using visual nodes.\n\nSee Also\nBase Nodes\nclass SKNode\nThe base class of all SpriteKit nodes.\nclass SKCameraNode\nA node that determines which parts of the scene are visible within a view.\nclass SKReferenceNode\nA node that's defined in an archived .sks file."
  },
  {
    "title": "init(lowerAngleLimit:upperAngleLimit:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreachconstraints/1520170-init",
    "html": "Parameters\nlowerAngleLimit\n\nThe minimum angle that the node can have when it is rotated by a reach event.\n\nupperAngleLimit\n\nThe maximum angle that the node can have when it is rotated by a reach event.\n\nReturn Value\n\nA newly initialized reach constraint.\n\nDiscussion\n\nWhen a reach action is executed, a node’s zRotation property may be changed by the action to satisfy the reach action. Any value calculated by the reach action for a node is always inside the range specified by the reach constraint attached to the node’s reachConstraints property.\n\nSee Also\nWorking with Reach Constraints\nvar lowerAngleLimit: CGFloat\nThe minimum angle that the node can have after it is rotated by a reach event.\nvar upperAngleLimit: CGFloat\nThe maximum angle that the node can have after it is rotated by a reach event.\nRelated Documentation\nSpriteKit Programming Guide"
  },
  {
    "title": "texture(from:crop:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1519994-texture",
    "html": "Parameters\nnode\n\nThe node object that is the root node of the tree you want to render to the texture.\n\ncrop\n\nA rectangle in the node’s coordinate system that describes the area to be rendered.\n\nReturn Value\n\nA SpriteKit texture that holds the rendered image.\n\nDiscussion\n\nThe node being rendered does not need to appear in the view’s presented scene. The new texture is created with a size equal to the size of the crop rectangle. If the node is not a scene node, it is rendered with a clear background color ([SKColor clear]).\n\nSee Also\nSnapshotting Nodes to a Texture\nfunc texture(from: SKNode) -> SKTexture?\nRenders the contents of a node tree and returns the rendered image as a texture.\nCreating a New Node By Rendering To a Texture\nRender a portion of the node tree into a new texture."
  },
  {
    "title": "texture(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview/1520114-texture",
    "html": "Parameters\nnode\n\nThe node object that is the root node of the tree you want to render to the texture.\n\nReturn Value\n\nA SpriteKit texture that holds the rendered image.\n\nDiscussion\n\nThe node being rendered does not need to appear in the view’s presented scene. The new texture is created with a size equal to the rectangle returned by the node’s calculateAccumulatedFrame() method. If the node is not a scene node, it is rendered with a clear background color ([SKColor clear]).\n\nSee Also\nSnapshotting Nodes to a Texture\nfunc texture(from: SKNode, crop: CGRect) -> SKTexture?\nRenders a portion of a node’s contents and returns the rendered image as a texture.\nCreating a New Node By Rendering To a Texture\nRender a portion of the node tree into a new texture."
  },
  {
    "title": "SKRenderer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrenderer",
    "html": "Overview\n\nSKRenderer allows an app to mix SpriteKit and Metal content by rendering an SKScene into a Metal command buffer. The reasons an app may do this instead of displaying a scene in SKView are:\n\nApps that are built in Metal can mix in SpriteKit content. While it's possible to add SKView as a subview to a Metal view, plugging SKRenderer into their Metal pipeline allows layering SpriteKit content at a specific z-position.\n\nYou might be writing a SpriteKit app and decide later to take full control over some portion of renderering by implementing it with Metal, yet continue to use SpriteKit for the rest of the app. For example, you might write the environmental effects layer of your app that does fog, clouds, and rain, with custom Metal shaders, and continue to layer content below and above that with SpriteKit.\n\nTopics\nFirst Steps\nCreate a renderer by specifying a GPU and then set its scene.\ninit(device: MTLDevice)\nInitializes with a specific GPU to render into.\nvar scene: SKScene?\nThe scene this renderer will draw into the Metal command buffer.\nRendering the Scene\nDraw the renderer's scene into a custom Metal rendering pipeline.\nfunc render(withViewport: CGRect, commandBuffer: MTLCommandBuffer, renderPassDescriptor: MTLRenderPassDescriptor)\nfunc render(withViewport: CGRect, renderCommandEncoder: MTLRenderCommandEncoder, renderPassDescriptor: MTLRenderPassDescriptor, commandQueue: MTLCommandQueue)\nDriving the Scene's Update Cycle\nControl when the scene's delegate functions are called.\nfunc update(atTime: TimeInterval)\nConfiguring Performance Related Toggles\nControl hints that have performance implications which are unique to your app.\nvar ignoresSiblingOrder: Bool\nvar shouldCullNonVisibleNodes: Bool\nEnabling Visual Statistics for Debugging\nDisplay metrics in the bottom corner of the scene's frame for debugging purposes.\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene.\nRelationships\nInherits From\nNSObject\nSee Also\nScene Renderers\nChoosing a SpriteKit Scene Renderer\nCompare the different ways to display a SpriteKit scene.\nclass SKView\nA view subclass that renders a SpriteKit scene.\nclass WKInterfaceSKScene\nA visual WatchKit element that displays a SpriteKit scene."
  },
  {
    "title": "Loading and Using Textures | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture/loading_and_using_textures",
    "html": "Overview\n\nUse the init(imageNamed:) method to create an SKTexture. When the texture is initialized using an image file, SpriteKit must perform two steps before it can use the texture to render sprites. First, it must load the texture data from the file. Second, it must prepare the texture data to be used by the graphics hardware. Both of these steps can be expensive compared to other SpriteKit operations. In particular, loading a texture from a file is very expensive. SpriteKit defers loading and preparing the texture as long as possible and provides methods you can use to control these steps.\n\nThe texture data is loaded when:\n\nThe size() method on the texture object is called.\n\nAnother method is called that requires the texture’s size, such as creating a new SKSpriteNode object that uses the texture object.\n\nOne of the preload methods is called (see Preloading a Texture for Performance)\n\nThe texture data is prepared for rendering when a sprite or particle that uses the texture is part of a node tree that is being rendered. Once the SKTexture object is ready for rendering, it stays ready until all strong references to the texture object are removed.\n\nTexture objects can be created from data generated at runtime. For example, you can create the texture from a Quartz 2D image, from raw pixel data, or by applying a Core Image filter to an existing texture. You can also call the texture(from:) method to render a node tree into a texture. In this case, preloading isn't necessary because the texture's image data is already in memory when the texture is created. However, the texture must still be prepared by SpriteKit before it can be used for rendering.\n\nTo create textures that can be updated at runtime, see the SKMutableTexture class.\n\nSee Also\nFirst Steps\nTexture Initializers\nSee the various ways to create and use textures in SpriteKit."
  },
  {
    "title": "SKScene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skscene",
    "html": "Overview\n\nAn SKScene object represents a scene of content in SpriteKit. A scene is the root node in a tree of SpriteKit nodes (SKNode). These nodes provide content that the scene animates and renders for display. To display a scene, you present it from an SKView, SKRenderer, or WKInterfaceSKScene.\n\nSKScene is a subclass of SKEffectNode and enables certain effects to apply to the entire scene. Though applying effects to an entire scene can be an expensive operation, creativity, and ingenuity may help you find some interesting ways to use effects.\n\nTopics\nCreating a Scene from a File\nCreating a Scene from a File\nLoad a scene that you configure in Xcode's scene editor.\nCreating a Scene Programmatically\nUse code to manually create a scene and configure its properties.\ninit(size: CGSize)\nInitializes a new scene object.\nvar size: CGSize\nThe dimensions of the scene, in points.\nStretching Content to Fit the View\nScaling a Scene's Content to Fit the View\nConfigure the scale mode to determine how a scene is sized to fit its view.\nvar scaleMode: SKSceneScaleMode\nA setting that defines how the scene is mapped to the view that presents it.\nenum SKSceneScaleMode\nThe modes that determine how the scene’s area is mapped to the view that presents it.\nConfiguring the Viewport\nDefine which portion of the scene is visible at a given time.\nPositioning a Scene's Origin Within its View\nTry the different ways to configure the scene's origin inside its view.\nvar camera: SKCameraNode?\nThe camera node in the scene that determines what part of the scene’s coordinate space is visible in the view.\nvar anchorPoint: CGPoint\nThe point in the view’s frame that corresponds to the scene’s origin.\nResponding to Loading and Resizing Events\nOverride these functions to be notified when a scene is loaded or presented, or changes size.\nfunc sceneDidLoad()\nTells you when the scene is presented.\nfunc didChangeSize(CGSize)\nTells you when the scene’s size has changed.\nfunc willMove(from: SKView)\nTells you when the scene is about to be removed from a view.\nfunc didMove(to: SKView)\nTells you when the scene is presented by a view.\nResponding to Frame-Cycle Events\nCallbacks occur every frame, telling you when to perform app logic.\nResponding to Frame-Cycle Events\nImplement per-frame app logic, such as the scene's update function that's called every frame.\nfunc update(TimeInterval)\nTells your app to perform any app-specific logic to update your scene.\nfunc didEvaluateActions()\nTells your app to peform any necessary logic after scene actions are evaluated.\nfunc didSimulatePhysics()\nTells your app to peform any necessary logic after physics simulations are performed.\nfunc didApplyConstraints()\nTells your app to peform any necessary logic after constraints are applied.\nfunc didFinishUpdate()\nTells your app to peform any necessary logic after the scene has finished all of the steps required to process animations.\nConfiguring a Delegate\nInstead of subclassing a scene to respond to update life-cycle events, assign a delegate to field them.\nSubclassing Scenes Versus Assigning a Delegate\nUse a scene delegate to share app logic across various scenes.\nvar delegate: SKSceneDelegate?\nA delegate to be called during the animation loop.\nprotocol SKSceneDelegate\nMethods that, when implemented, allow any class to participate in the SpriteKit render loop callbacks.\nSetting the Background Appearance\nAdjust content that's under a scene.\nCreating a Scene with a Transparent Background\nSet a transparent background color to show the content of the views below.\nvar view: SKView?\nThe view that is currently presenting the scene.\nvar backgroundColor: UIColor\nThe background color of the scene.\nConfiguring Physics Properties\nvar physicsWorld: SKPhysicsWorld\nThe physics simulation associated with the scene.\nAdding Positional Audio\nEnable positional audio by defining a listener.\n\nUsing Audio Nodes with the Scene's Listener\nAdd audio to your scene, and optionally give it 2D-positional mixing characteristics.\nvar listener: SKNode?\nA node used to determine the position of the listener for positional audio in the scene.\nvar audioEngine: AVAudioEngine\nThe AVFoundation audio engine used to play audio from audio nodes contained in the scene.\nConverting Between Coordinate Systems\nfunc convertPoint(fromView: CGPoint) -> CGPoint\nConverts a point from view coordinates to scene coordinates.\nfunc convertPoint(toView: CGPoint) -> CGPoint\nConverts a point from scene coordinates to view coordinates.\nRelationships\nInherits From\nSKEffectNode\nConforms To\nGKSceneRootNodeType\nSee Also\nEssentials\nDrawing SpriteKit Content in a View\nDisplay visual content using SpriteKit.\nNodes for Scene Building\nDefine the appearance or layout of scene content."
  },
  {
    "title": "SpriteKit Constants | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spritekit_constants",
    "html": "Topics\nConstants\nvar PHYSICSKIT_MINUS_GL_IMPORTS: Int32"
  },
  {
    "title": "SKTransformNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktransformnode",
    "html": "Overview\n\nSKTranformNode adds the ability to rotate nodes across the x and y axes. When combined with SKNode's zRotation property, nodes added as children to a transform node have the ability to rotate in 3D.\n\nTopics\nRotating Child Nodes\nvar xRotation: CGFloat\nvar yRotation: CGFloat\nfunc setEulerAngles(vector_float3)\nfunc setQuaternion(simd_quatf)\nfunc setRotationMatrix(matrix_float3x3)\nReading the Current Rotation\nfunc eulerAngles() -> vector_float3\nfunc quaternion() -> simd_quatf\nfunc rotationMatrix() -> matrix_float3x3\nRelationships\nInherits From\nSKNode\nSee Also\nNodes that Modify Drawing\nclass SKEffectNode\nA node that renders its children into a separate buffer, optionally applying an effect, before drawing the final result.\nclass SKCropNode\nA node that masks pixels drawn by its children so that only some pixels are seen."
  },
  {
    "title": "SpriteKit Enumerations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/spritekit_enumerations",
    "html": "Topics\nEnumerations\nenum SKActionTimingMode\nThe modes that an action can use to adjust the apparent timing of the action.\nenum SKAttributeType\nOptions that specify an attribute's data type.\nenum SKBlendMode\nThe modes that describe how the source and destination pixel colors are used to calculate the new destination color.\nenum SKInterpolationMode\nThe modes used to interpolate between keyframes in the sequence.\nenum SKLabelHorizontalAlignmentMode\nOptions for aligning text horizontally.\nenum SKLabelVerticalAlignmentMode\nOptions for aligning text vertically.\nenum SKParticleRenderOrder\nThe order to use when the emitter’s particles are rendered.\nenum SKRepeatMode\nThe modes used to determine how the sequence repeats.\nenum SKSceneScaleMode\nThe modes that determine how the scene’s area is mapped to the view that presents it.\nenum SKTextureFilteringMode\nTexture filtering modes to use when the texture is drawn in a size other than its native size.\nenum SKTileDefinitionRotation\nThe allowed rotations for a given tile.\nenum SKTileSetType\nAn enumeration defining how tiles are arranged.\nenum SKTransitionDirection\nFor some transitions, the direction in which the transition is performed.\nenum SKUniformType\nAn enumerated type to identify the type of a uniform object.\nenum SKNodeFocusBehavior\nOptions for the focusable states of a SpriteKit node."
  },
  {
    "title": "SKUniform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skuniform",
    "html": "Overview\n\nAn SKUniform object is used to hold uniform data for a custom OpenGL or OpenGL ES shader. The uniform data is accessible from all shaders that include the uniform.To use a uniform variable in your shader, create the SKUniform object and set its initial value. Once its value is specified, the uniformType property changes to match the type of the initial value you provided and can never change afterward. To use the uniform object, add it to an SKShader object that needs to access the uniform variable. To update the uniform variable’s value, choose the appropriate property on the uniform object based on the data type it encapsulates.\n\nTopics\nCreating and Initializing Uniform Objects\ninit(name: String)\nInitializes a new uniform object.\ninit(name: String, float: Float)\nInitializes a new uniform object that holds a floating-point number.\ninit(name: String, float: GLKVector2)\nInitializes a new uniform object that holds a vector of two floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector3)\nCreates and initializes a new uniform object that holds a vector of three floating-point numbers.\nDeprecated\ninit(name: String, float: GLKVector4)\nInitializes a new uniform object that holds a vector of four floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix2)\nInitializes a new uniform object that holds a 2 x 2 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix3)\nInitializes a new uniform object that holds a 3 x 3 matrix of floating-point numbers.\nDeprecated\ninit(name: String, float: GLKMatrix4)\nInitializes a new uniform object that holds a 4 x 4 matrix of floating-point numbers.\nDeprecated\ninit(name: String, texture: SKTexture?)\nInitializes a new uniform object that holds a reference to a texture.\nReading Information About a Uniform\nvar name: String\nThe uniform’s name.\nvar uniformType: SKUniformType\nThe uniform object’s data type.\nReading and Writing an Uniform Object’s Value\nYou should only read or write the property type that matches the type of the uniform object; it is a programming error to use any of the other properties.\nvar floatValue: Float\nThe receiver’s value as a floating-point value.\nvar floatVector2Value: GLKVector2\nThe receiver’s value as a vector of two floating-point values.\nDeprecated\nvar floatVector3Value: GLKVector3\nThe receiver’s value as a vector of three floating-point values.\nDeprecated\nvar floatVector4Value: GLKVector4\nThe receiver’s value as a vector of four floating-point values.\nDeprecated\nvar floatMatrix2Value: GLKMatrix2\nThe receiver’s value as a 2 x 2 matrix of floating-point values.\nDeprecated\nvar floatMatrix3Value: GLKMatrix3\nThe receiver’s value as a 3 x 3 matrix of floating-point values.\nDeprecated\nvar floatMatrix4Value: GLKMatrix4\nThe receiver’s value as a 4 x 4 matrix of floating-point values.\nDeprecated\nvar textureValue: SKTexture?\nThe receiver’s value as a SpriteKit texture.\nConstants\nenum SKUniformType\nAn enumerated type to identify the type of a uniform object.\nInitializers\ninit(name: String, matrixFloat2x2: matrix_float2x2)\ninit(name: String, matrixFloat3x3: matrix_float3x3)\ninit(name: String, matrixFloat4x4: matrix_float4x4)\ninit(name: String, vectorFloat2: vector_float2)\ninit(name: String, vectorFloat3: vector_float3)\ninit(name: String, vectorFloat4: vector_float4)\nInstance Properties\nvar matrixFloat2x2Value: matrix_float2x2\nvar matrixFloat3x3Value: matrix_float3x3\nvar matrixFloat4x4Value: matrix_float4x4\nvar vectorFloat2Value: vector_float2\nvar vectorFloat3Value: vector_float3\nvar vectorFloat4Value: vector_float4\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nShaders\nclass SKShader\nAn object that allows you to apply a custom fragment shader.\nclass SKAttribute\nA specification for dynamic per-node data used with a custom shader.\nclass SKAttributeValue\nA container for dynamic shader data associated with a node."
  },
  {
    "title": "SKWarpGeometryGrid | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpgeometrygrid",
    "html": "Overview\n\nAn SKWarpGeometryGrid exposes a 2D array of source positions, and set of destination positions with matching size, that allow you to define which sections of a node should be translated from the source positions to the destination positions. Conceptually, this forms two grids—a source grid and a destination grid—where the visual warping is accomplished by stretching or shrinking each section of the node as the source positions of the grid interpolate to their corresponding destination positions.\n\nTopics\nCreating a Warp Geometry Grid\ninit(columns: Int, rows: Int)\nCreates a warp geometry grid of a specified size.\ninit(columns: Int, rows: Int, sourcePositions: [SIMD2<Float>], destinationPositions: [SIMD2<Float>])\nCreates a warp geometry grid of a specific size and warp translation, in point arrays.\ninit?(coder: NSCoder)\nTells you when to intialize a grid that was loaded from an archive.\nAnimating Warping\nAnimate the Warping of a Sprite\nInterpolate warping from source to destination warp geometry grids.\nAccessing or Setting Warp Geometry Grid Size\nvar numberOfColumns: Int\nThe object's number of columns.\nvar numberOfRows: Int\nThe object's number of rows.\nvar vertexCount: Int\nThe object's total number of vertices.\nAccessing or Setting Grid Vertices\nGet or set float2 values that correspond to individual vertices of the grid.\nfunc destPosition(at: Int) -> vector_float2\nReturns the destination position of a vertex.\nfunc replacingByDestinationPositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument destination positions.\nfunc replacingBySourcePositions(positions: [SIMD2<Float>]) -> SKWarpGeometryGrid\nReturns a copy of this grid, updated with the argument source positions.\nfunc sourcePosition(at: Int) -> vector_float2\nReturns the source position of a vertex.\nRelationships\nInherits From\nSKWarpGeometry\nConforms To\nNSSecureCoding\nSee Also\nWarping\nclass SKWarpGeometry\nA definition for a deformation of nodes that conform to SKWarpable.\nprotocol SKWarpable\nA protocol for objects that can be warped and animated by an SKWarpGeometry."
  },
  {
    "title": "SKWarpable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skwarpable",
    "html": "Topics\nInstance Properties\nvar subdivisionLevels: Int\nThe maximum number of subdivision iterations used to generate the final vertices.\n\nRequired\n\nvar warpGeometry: SKWarpGeometry?\nThe warp geometry used to define the distortion.\n\nRequired\n\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nSKEffectNode\nSKSpriteNode\nSee Also\nWarping\nclass SKWarpGeometry\nA definition for a deformation of nodes that conform to SKWarpable.\nclass SKWarpGeometryGrid\nA definition for a grid-based deformation of nodes that conform to SKWarpable."
  },
  {
    "title": "SKAttributeValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skattributevalue",
    "html": "Overview\n\nSpriteKit nodes that are rendered with a custom shader can use SKAttributeValue objects to pass dynamic values which can change without requiring that shader to be recompiled. An attribute value is passed to a shader using a node’s setValue(_:forAttribute:) method using the relevant attribute’s name. For example, given a shader with a SKAttributeType.float attribute named a_radius:\n\nListing 1 Creating an attribute\nlet attribute = SKAttribute(name: \"a_radius\", \n                            type: SKAttributeType.float)\n\n\nThe following code sets the value of this attribute to 10 and passes it to a SKSpriteNode object’s shader:\n\nListing 2 Setting an attribute value\nnode.setValue(SKAttributeValue(float: 10), \n              forAttribute: \"a_radius\")\n\n\nThe attribute, a_radius, is available as a global floating-point variable within the shader code.\n\nUsing this technique, a single shader can be shared across many nodes and each nodes can supply its own attributes. This approach is an alternative to using SKUniform objects which would require a recompilation for each distinct set of parameters.\n\nTopics\nInitializers\ninit()\nCreates and initializes a new attribute value object\ninit(float: Float)\nCreates and initializes a new attribute value object that holds a floating point number.\ninit(vectorFloat2: vector_float2)\nCreates and initializes a new attribute value object that holds a vector of two floating point numbers.\ninit(vectorFloat3: vector_float3)\nCreates and initializes a new attribute value object that holds a vector of three floating point numbers.\ninit(vectorFloat4: vector_float4)\nCreates and initializes a new attribute value object that holds a vector of four floating point numbers.\nInstance Properties\nvar floatValue: Float\nThe receiver’s floating point value.\nvar vectorFloat2Value: vector_float2\nThe receiver’s value as a vector of two floating-point numbers.\nvar vectorFloat3Value: vector_float3\nThe receiver’s value as a vector of three floating point numbers.\nvar vectorFloat4Value: vector_float4\nThe receiver’s value as a vector of four floating point numbers.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nShaders\nclass SKShader\nAn object that allows you to apply a custom fragment shader.\nclass SKAttribute\nA specification for dynamic per-node data used with a custom shader.\nclass SKUniform\nA container for uniform shader data."
  },
  {
    "title": "SKTileSet | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktileset",
    "html": "Overview\n\nAn SKTileSet object contains an array of tile groups that define which tile definitions are available for use in a tile map.\n\nTile sets also define the arrangement of tiles within a tile map. In addition to the default rectangular grid layout, tile sets can also define hexagonal and isometric layouts.\n\nTopics\nCreating a Tile Set from a File\ninit?(named: String)\nInitializes a tile set by searching the app bundle for an archived .sks file by name.\ninit?(from: URL)\nInitializes a tile set from a URL to an archived .sks file.\nCreating a Tile Set Programmatically\nCreate a tile set by passing in the various groups that make up the set.\ninit(tileGroups: [SKTileGroup])\nInitializes a new tile set with an array of tile groups and rectangular grid layout.\ninit(tileGroups: [SKTileGroup], tileSetType: SKTileSetType)\nInitializes a new tile set with an array of tile groups and specified layout.\nAccessing or Reading a Tile Set's Properties\nvar defaultTileGroup: SKTileGroup?\nThe tile set's default tile group.\nvar defaultTileSize: CGSize\nThe tile set's default tile size.\nvar name: String?\nA name associated with the tile set.\nvar tileGroups: [SKTileGroup]\nThe tile set's array of tile group objects.\nvar type: SKTileSetType\nThe tile set's type.\nenum SKTileSetType\nAn enumeration defining how tiles are arranged.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nTiling\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SKTileDefinition\nA single tile that can be repeated in a tile map.\nclass SKTileGroup\nA set of tiles that collectively define one type of terrain.\nclass SKTileGroupRule\nRules that describe how various tiles should be placed in a map."
  },
  {
    "title": "SKTileGroupRule | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktilegrouprule",
    "html": "Overview\n\nWhen a tile is filled in a tile map, the tile group rule defines how neighboring tiles are populated based on adjacency rules. A rule with multiple definitions uses the placement weights of the definitions to randomly select which to use.\n\nTopics\nCreating a Tile Group Rule\ninit(adjacency: SKTileAdjacencyMask, tileDefinitions: [SKTileDefinition])\nInitializes a new tile group rule with adjacency rules and tile definitions.\nAccessing or Setting Tile Group Rule Properties\nvar adjacency: SKTileAdjacencyMask\nThe adjacency requirement for this rule.\nstruct SKTileAdjacencyMask\nAn enumeration defining how neighboring tiles are automatically placed next to each other.\nvar name: String?\nA name associated with the tile group rule.\nvar tileDefinitions: [SKTileDefinition]\nThe tile definitions used for this rule.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nTiling\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SKTileDefinition\nA single tile that can be repeated in a tile map.\nclass SKTileGroup\nA set of tiles that collectively define one type of terrain.\nclass SKTileSet\nA container for related tile groups."
  },
  {
    "title": "SKPhysicsJointSpring | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointspring",
    "html": "Overview\n\nAn SKPhysicsJointSpring object simulates connecting two physics bodies together with a spring. The farther the two objects move from each other, the more force is applied to bring the two bodies back together.\n\nTopics\nFirst Steps\nGetting Started with Spring Joints\nConnect two physics bodies with a spring joint.\nCreating a Spring Joint\nclass func joint(withBodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchorA: CGPoint, anchorB: CGPoint) -> SKPhysicsJointSpring\nCreates a new spring joint.\nConfiguring a Spring Joint\nvar damping: CGFloat\nDefines how the spring’s motion should be damped due to the forces of friction.\nvar frequency: CGFloat\nDefines the frequency or stiffness characteristics of the spring.\nRelationships\nInherits From\nSKPhysicsJoint\nSee Also\nPhysics Joints\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass SKPhysicsJoint\nThe abstract superclass for objects that connect physics bodies.\nclass SKPhysicsJointFixed\nA joint that fuses two physics bodies together at a reference point.\nclass SKPhysicsJointLimit\nA joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\nclass SKPhysicsJointPin\nA joint that pins together two physics bodies, allowing independent rotation.\nclass SKPhysicsJointSliding\nA joint that allows two physics bodies to slide along an axis."
  },
  {
    "title": "SKPhysicsJointSliding | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointsliding",
    "html": "Overview\n\nAn SKPhysicsJointSliding object allows the anchor points of the two physics bodies to slide along a chosen axis. The joint can be configured to limit the distance that the two objects are allowed to slide along the axis.\n\nTopics\nCreating a Sliding Joint\nclass func joint(withBodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchor: CGPoint, axis: CGVector) -> SKPhysicsJointSliding\nCreates a new sliding joint.\nConfiguring a Sliding Joint\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the sliding joint is restricted so that the objects may only slide a finite distance from the initial anchor point.\nvar lowerDistanceLimit: CGFloat\nThe smallest distance allowed for the sliding joint.\nvar upperDistanceLimit: CGFloat\nThe largest distance allowed for the sliding joint.\nRelationships\nInherits From\nSKPhysicsJoint\nSee Also\nPhysics Joints\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass SKPhysicsJoint\nThe abstract superclass for objects that connect physics bodies.\nclass SKPhysicsJointFixed\nA joint that fuses two physics bodies together at a reference point.\nclass SKPhysicsJointLimit\nA joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\nclass SKPhysicsJointPin\nA joint that pins together two physics bodies, allowing independent rotation.\nclass SKPhysicsJointSpring\nA joint that simulates a spring connecting two physics bodies."
  },
  {
    "title": "SKPhysicsJointPin | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointpin",
    "html": "Overview\n\nAn SKPhysicsJointPin object allows two physics bodies to independently rotate around the anchor point as if pinned together. You can configure how far the two objects may rotate and the resistance to rotation.\n\nTopics\nCreating a Pin Joint\nclass func joint(withBodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchor: CGPoint) -> SKPhysicsJointPin\nCreates a new pin joint.\nConfiguring a Pin Joint\nvar rotationSpeed: CGFloat\nThe speed, in radians per second, at which the physics bodies are driven around the pin joint.\nvar shouldEnableLimits: Bool\nA Boolean value that indicates whether the pin joint’s rotation is limited to a specific range of values.\nvar lowerAngleLimit: CGFloat\nThe smallest angle allowed for the pin joint, in radians.\nvar upperAngleLimit: CGFloat\nThe largest angle allowed for the pin joint, in radians.\nvar frictionTorque: CGFloat\nThe resistance applied by the pin joint to spinning around the anchor point.\nRelationships\nInherits From\nSKPhysicsJoint\nSee Also\nPhysics Joints\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass SKPhysicsJoint\nThe abstract superclass for objects that connect physics bodies.\nclass SKPhysicsJointFixed\nA joint that fuses two physics bodies together at a reference point.\nclass SKPhysicsJointLimit\nA joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\nclass SKPhysicsJointSliding\nA joint that allows two physics bodies to slide along an axis.\nclass SKPhysicsJointSpring\nA joint that simulates a spring connecting two physics bodies."
  },
  {
    "title": "Working with Inverse Kinematics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/working_with_inverse_kinematics",
    "html": "Overview\n\nInverse kinematics (IK) is the use of equations to drive a system of connected components so that an end effector can reach a desired position. Imagine a robot arm formed of a series of sections hinged together. With traditional animation techniques, if you wanted the hand of the arm to reach to a specified position, you would have to code the rotations for each of the joints, which is a complex and time-consuming task. With IK, you simply need to specify the required position of the hand (which would be the end effector), and each individual joint is rotated to achieve the final position. In SpriteKit, complex IK animations can be generated with very little code.\n\nSet Up the Joints and Constraints\n\nSpriteKit's IK relies on two classes:\n\nSKAction object reach methods that solve an IK system (that run the system to make the end effector reach a specified position).\n\nSKConstraint objects that constrain the position or orientation of nodes.\n\nListing 1 creates a simple robot arm consisting of a fixed shoulder node and upperArm, midArm, and lowerArm sections that are joined by elbow and wrist nodes. At the end of the wrist is an endEffector node. The nodes are progressively children of each other.\n\nThe shoulder node is fixed to the scene with a constraint, and the other joints are offset in the y direction by the length of each section.\n\nlet sectionLength: CGFloat = 100\nlet sectionRect = CGRect(x: -10, y: -sectionLength,\n                         width: 20, height: sectionLength)\n   \nlet upperArm = SKShapeNode(rect: sectionRect)\nlet midArm = SKShapeNode(rect: sectionRect)\nlet lowerArm = SKShapeNode(rect: sectionRect)\nlet shoulder = SKShapeNode(circleOfRadius: 5)\nlet elbow = SKShapeNode(circleOfRadius: 5)\nlet wrist = SKShapeNode(circleOfRadius: 5)\nlet endEffector = SKShapeNode(circleOfRadius: 5)\n   \nscene.addChild(shoulder)\nshoulder.addChild(upperArm)\nupperArm.addChild(elbow)\nelbow.addChild(midArm)\nmidArm.addChild(wrist)\nwrist.addChild(lowerArm)\nlowerArm.addChild(endEffector)\n    \nshoulder.constraints = [SKConstraint.positionX(SKRange(constantValue: 320),\n                                               y: SKRange(constantValue: 320))]\n    \nlet positionConstraint = SKConstraint.positionY(SKRange(constantValue: -sectionLength))\nelbow.constraints =  [ positionConstraint ]\nwrist.constraints = [ positionConstraint ]\nendEffector.constraints = [ positionConstraint ]\n\n\nIn its default position, the code above creates a node tree that looks like this (the shoulder is at the top, in blue, and the end effector is at the bottom, in yellow).\n\nRun the Solver\n\nTo run the IK solver, you create an action passing it the desired location.\n\nlet reachAction = SKAction.reach(to: location,\n                                 rootNode: shoulder,\n                                 duration: 1.0)\n     \nendEffector.run(reachAction)\n\n\nGiven a location to the left of and slightly below the shoulder, the action finishes with the node tree looking like the following:\n\nSee Also\nPhysics Joints\nclass SKPhysicsJoint\nThe abstract superclass for objects that connect physics bodies.\nclass SKPhysicsJointFixed\nA joint that fuses two physics bodies together at a reference point.\nclass SKPhysicsJointLimit\nA joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\nclass SKPhysicsJointPin\nA joint that pins together two physics bodies, allowing independent rotation.\nclass SKPhysicsJointSliding\nA joint that allows two physics bodies to slide along an axis.\nclass SKPhysicsJointSpring\nA joint that simulates a spring connecting two physics bodies."
  },
  {
    "title": "SKPhysicsJoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjoint",
    "html": "Overview\n\nAn SKPhysicsJoint object connects two physics bodies so that they are simulated together by the physics world. You never instantiate objects of this class directly; instead, you instantiate one of the subclasses that defines the kind of joint you want to make.\n\nTopics\nConnecting Bodies with Joints\nConnecting Bodies with Joints\nAdd joints to nodes in your scene.\nDisconnecting Bodies from Joints\nDisconnecting Bodies from Joints\nDisconnect joints from nodes in your scene.\nAccessing or Setting a Joint's Bodies\nvar bodyA: SKPhysicsBody\nThe first body connected by the joint.\nvar bodyB: SKPhysicsBody\nThe second body connected by the joint.\nReading the Stress and Speed that Are Currently Applied to a Joint\nvar reactionForce: CGVector\nThe instantaneous reaction force, in newtons, currently being directed at the anchor point.\nvar reactionTorque: CGFloat\nInstantaneous reaction torque, in newton-meters, currently being directed at the anchor point.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nPhysics Joints\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass SKPhysicsJointFixed\nA joint that fuses two physics bodies together at a reference point.\nclass SKPhysicsJointLimit\nA joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\nclass SKPhysicsJointPin\nA joint that pins together two physics bodies, allowing independent rotation.\nclass SKPhysicsJointSliding\nA joint that allows two physics bodies to slide along an axis.\nclass SKPhysicsJointSpring\nA joint that simulates a spring connecting two physics bodies."
  },
  {
    "title": "SKPhysicsJointLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointlimit",
    "html": "Topics\nCreating a Limit Joint\nclass func joint(withBodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchorA: CGPoint, anchorB: CGPoint) -> SKPhysicsJointLimit\nCreates a new limit joint.\nConfiguring a Limit Joint\nvar maxLength: CGFloat\nThe maximum distance allowed between the two physics bodies connected by the limit joint.\nRelationships\nInherits From\nSKPhysicsJoint\nSee Also\nPhysics Joints\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass SKPhysicsJoint\nThe abstract superclass for objects that connect physics bodies.\nclass SKPhysicsJointFixed\nA joint that fuses two physics bodies together at a reference point.\nclass SKPhysicsJointPin\nA joint that pins together two physics bodies, allowing independent rotation.\nclass SKPhysicsJointSliding\nA joint that allows two physics bodies to slide along an axis.\nclass SKPhysicsJointSpring\nA joint that simulates a spring connecting two physics bodies."
  },
  {
    "title": "SKPhysicsJointFixed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsjointfixed",
    "html": "Overview\n\nAn SKPhysicsJointFixed object fuses two physics bodies together at a reference point. Fixed joints are useful for creating complex shapes that can be broken apart later.\n\nTopics\nCreating a Fixed Joint\nclass func joint(withBodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchor: CGPoint) -> SKPhysicsJointFixed\nCreates a new fixed joint.\nRelationships\nInherits From\nSKPhysicsJoint\nSee Also\nPhysics Joints\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass SKPhysicsJoint\nThe abstract superclass for objects that connect physics bodies.\nclass SKPhysicsJointLimit\nA joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\nclass SKPhysicsJointPin\nA joint that pins together two physics bodies, allowing independent rotation.\nclass SKPhysicsJointSliding\nA joint that allows two physics bodies to slide along an axis.\nclass SKPhysicsJointSpring\nA joint that simulates a spring connecting two physics bodies."
  },
  {
    "title": "SKPhysicsContact | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontact",
    "html": "Overview\n\nAn SKPhysicsContact object is created automatically by SpriteKit to describe a contact between two physical bodies in a physics world.To receive contact messages, read the physicsWorld property of an SKScene object you are interested in, and assign its contactDelegate property to point to an object that implements the SKPhysicsContactDelegate protocol. Then, for each physics body in your scene, set the categoryBitMask and contactTestBitMask properties to define which interactions should generate contact messages.\n\nTopics\nInspecting the Contact Properties\nvar bodyA: SKPhysicsBody\nThe first body in the contact.\nvar bodyB: SKPhysicsBody\nThe second body in the contact.\nvar contactPoint: CGPoint\nThe contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe impulse that specifies how hard these two bodies struck each other in Newton-seconds.\nvar contactNormal: CGVector\nThe normal vector specifying the direction of the collision.\nRelationships\nInherits From\nNSObject\nSee Also\nPhysics Simulation\nGetting Started with Physics\nSimulate gravity, acceleration, collision detection, or joints.\nclass SKPhysicsWorld\nThe driver of the physics engine in a scene; it exposes the ability for you to configure and query the physics system.\nclass SKPhysicsBody\nAn object that adds physics simulation to a node.\nprotocol SKPhysicsContactDelegate\nMethods your app can implement to respond when physics bodies come into contact.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes."
  },
  {
    "title": "SKPhysicsContactDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicscontactdelegate",
    "html": "Overview\n\nAn object that implements the SKPhysicsContactDelegate protocol can respond when two physics bodies with overlapping contactTestBitMask values are in contact with each other in a physics world. To receive contact messages, you set the contactDelegate property of a SKPhysicsWorld object. The delegate is called when a contact starts or ends.\n\nImportant\n\nThe physics contact delegate methods are called during the physics simulation step. During that time, the physics world can't be modified and the behavior of any changes to the physics bodies in the simulation is undefined. If you need to make such changes, set a flag inside didBegin(_:) or didEnd(_:) and make changes in response to that flag in the update(_:for:) method in a SKSceneDelegate.\n\nYou can use the contact delegate to play a sound or execute game logic, such as increasing a player’s score, when a contact event occurs. The following code shows how to display a shockwave effect when two nodes with the name ball come into contact. The code only creates the effect when the collision impulse is above a specified threshold:\n\nListing 1 Creating a shockwave effect when objects come into contact\nlet shockWaveAction: SKAction = {\n    let growAndFadeAction = SKAction.group([SKAction.scale(to: 50, duration: 0.5),\n                                            SKAction.fadeOut(withDuration: 0.5)])\n    \n    let sequence = SKAction.sequence([growAndFadeAction,\n                                      SKAction.removeFromParent()])\n    \n    return sequence\n}()\n\n\nfunc didBegin(_ contact: SKPhysicsContact) {\n    if contact.collisionImpulse > 5 &&\n        contact.bodyA.node?.name == \"ball\" &&\n        contact.bodyB.node?.name == \"ball\" {\n        \n        let shockwave = SKShapeNode(circleOfRadius: 1)\n\n\n        shockwave.position = contact.contactPoint\n        scene.addChild(shockwave)\n        \n        shockwave.run(shockWaveAction)\n    }\n}\n\n\nTopics\nResponding to Contact Events\nfunc didBegin(SKPhysicsContact)\nCalled when two bodies first contact each other.\nfunc didEnd(SKPhysicsContact)\nCalled when the contact ends between two physics bodies.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nPhysics Simulation\nGetting Started with Physics\nSimulate gravity, acceleration, collision detection, or joints.\nclass SKPhysicsWorld\nThe driver of the physics engine in a scene; it exposes the ability for you to configure and query the physics system.\nclass SKPhysicsBody\nAn object that adds physics simulation to a node.\nclass SKPhysicsContact\nA description of the contact between two physics bodies.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes."
  },
  {
    "title": "animationSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1519822-animationspeed",
    "html": "Discussion\n\nA value of 0.0 means that the field should not animate at all.\n\nSee Also\nConfiguring Other Field Properties\nvar smoothness: Float\nThe smoothness of the noise used to generate the forces.\nvar direction: vector_float3\nThe direction of a velocity field node.\nvar texture: SKTexture?\nA normal texture that specifies the velocities at different points in a velocity field node.\nRelated Documentation\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies."
  },
  {
    "title": "smoothness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520273-smoothness",
    "html": "Discussion\n\nThis parameter should be a value between 0.0 and 1.0, where 1.0 represents a uniform smoothness.\n\nSee Also\nConfiguring Other Field Properties\nvar animationSpeed: Float\nThe rate at which a noise or turbulence field node changes.\nvar direction: vector_float3\nThe direction of a velocity field node.\nvar texture: SKTexture?\nA normal texture that specifies the velocities at different points in a velocity field node.\nRelated Documentation\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies."
  },
  {
    "title": "strength | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520152-strength",
    "html": "Discussion\n\nThe default value is 1.0. There’s no specific unit of measurement for this property because the actual effect is dependent on the kind of field node being created. In practice, the best approach is to experiment with different field strengths and use them to determine the proper value empirically.\n\nSee Also\nConfiguring the Strength of the Field\nvar falloff: Float\nThe exponent that defines the rate of decay for the strength of the field as the distance increases between the node and the physics body being affected."
  },
  {
    "title": "fieldBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skphysicsbody/1520280-fieldbitmask",
    "html": "Discussion\n\nWhen a physics body is inside the region of an SKFieldNode object, that field node’s categoryBitMask property is compared to this physics body’s fieldBitMask property by performing a logical AND operation. If the result is a nonzero value, the field node’s effect is applied to the physics body.\n\nThe default value is 0xFFFFFFFF (all bits set).\n\nSee Also\nInteracting with Physics Fields\nvar charge: CGFloat\nThe electrical charge of the physics body."
  },
  {
    "title": "falloff | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode/1520445-falloff",
    "html": "Discussion\n\nWhen the force of a field node is calculated, the force is multiplied by pow(distance - minRadius, -falloff). The default falloff value is 0, which indicates that no attenuation takes place. Some types of field nodes ignore the falloff parameter entirely, while others change the default value to something that is more logical for that type of field node.\n\nSee Also\nConfiguring the Strength of the Field\nvar strength: Float\nThe strength of the field."
  },
  {
    "title": "SKKeyframeSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skkeyframesequence",
    "html": "Overview\n\nThe primary use for an SKKeyframeSequence object is to animate properties on particles emitted by an SKEmitterNode object, but it can also be used for your general interpolation needs across a discrete set of inputs.\n\nWhen a keyframe sequence is used with an emitter node, particles determine their values by sampling the keyframe sequence. The sequence replaces the normal simulation performed by the emitter node.\n\nTopics\nFirst Steps\nUsing Keyframe Sequence to effect Custom Interpolation\nSee a few examples of what keyframe sequence can do.\ninit(keyframeValues: [Any], times: [NSNumber])\nInitializes a keyframe sequence with an initial set of values and times.\ninit(capacity: Int)\nInitializes a new keyframe sequence.\ninit?(coder: NSCoder)\nSequence Building\nDefine the composition of the keyframe sequence.\nfunc addKeyframeValue(Any, time: CGFloat)\nAdds a keyframe to the sequence.\nfunc removeKeyframe(at: Int)\nRemoves a keyframe from the sequence.\nfunc removeLastKeyframe()\nRemoves the last value in the sequence.\nfunc setKeyframeTime(CGFloat, for: Int)\nChanges the time for a specific keyframe.\nfunc setKeyframeValue(Any, for: Int)\nChanges the value for a specific keyframe.\nfunc setKeyframeValue(Any, time: CGFloat, for: Int)\nReplaces a keyframe in the sequence with a new keyframe.\nSequence Running\nYou run the sequence by sampling its output at a given time.\nfunc sample(atTime: CGFloat) -> Any?\nCalculates the sample at a particular time.\nSequence Information\nfunc count() -> Int\nThe number of keyframes in the sequence.\nfunc getKeyframeTime(for: Int) -> CGFloat\nGets the time for a keyframe in the sequence.\nfunc getKeyframeValue(for: Int) -> Any\nGets the value for a keyframe in the sequence.\nInterpolation Modifiers\nModify sample output by defining a mode or repeat options.\nvar interpolationMode: SKInterpolationMode\nThe mode used to determine how values for times between the keyframes are calculated.\nvar repeatMode: SKRepeatMode\nThe mode used to determine how the keyframe sequence repeats.\nConstants\nenum SKInterpolationMode\nThe modes used to interpolate between keyframes in the sequence.\nenum SKRepeatMode\nThe modes used to determine how the sequence repeats.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nMathematical Tools\nclass SKRange\nA definition of a range of floating-point values.\nclass SKRegion\nThe definition of an arbitrary area."
  },
  {
    "title": "SKRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skrange",
    "html": "Overview\n\nYou typically use a SKRange to clamp a value so that it is within the specified range.\n\nTopics\nCreating a Range Object\ninit(value: CGFloat, variance: CGFloat)\nCreates and initializes a new range object using a value and a maximum distance from that value.\nclass func withNoLimits() -> Self\nCreates and initializes a new range object that encompasses all possible values.\ninit(lowerLimit: CGFloat)\nCreates and initializes a new range object that specifies only a minimum value.\ninit(upperLimit: CGFloat)\nCreates and initializes a new range object that specifies only a maximum value.\ninit(constantValue: CGFloat)\nCreates and initializes a new range object that specifies a constant value.\ninit(lowerLimit: CGFloat, upperLimit: CGFloat)\nInitializes a new range object.\nInspecting a Range Object’s Limits\nvar lowerLimit: CGFloat\nThe minimum possible value.\nvar upperLimit: CGFloat\nThe maximum possible value.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nMathematical Tools\nclass SKKeyframeSequence\nAn object that performs interpolation between values specified at different times (keyframes).\nclass SKRegion\nThe definition of an arbitrary area."
  },
  {
    "title": "Getting Started with Physics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/getting_started_with_physics",
    "html": "Overview\n\nAlthough you can control the exact position of every node in a scene, often you want these nodes to interact with each other, colliding with each other and imparting velocity changes in the process. You might also want to do things that are not handled by the action system, such as simulating gravity and other forces. To do this, you create physics bodies (SKPhysicsBody) and attach them to nodes in your scene.\n\nSpriteKit uses the International System of Units, also known as SI, or the meter-kilogram-second system. Where necessary, you may need to consult other reference materials online to learn more about the physics equations used by SpriteKit.\n\nCustomize Physics by Configuring Bodies\n\nA physics body uses its node’s position and orientation to place itself in the simulation. Every physics body has other characteristics that define how the simulation operates on it. These include innate properties of the physical object, such as its mass and density, and properties imposed on it, such as its velocity. These characteristics define how a body moves, how it is affected by forces in the simulation, and how it responds to collisions with other physics bodies.\n\nInteract with Position and Velocity\n\nEach time a scene computes a new frame of animation, it simulates the effects of forces and collisions on physics bodies connected to the node tree. It computes a final position, orientation, and velocity for each physics body. Then, the scene updates the position and rotation of each corresponding node. Other forces can be applied automatically to multiple physics bodies by adding SKFieldNode objects to the scene. You can also directly affect a specific field body by modifying its velocity directly or by applying forces or impulses directly to it. The acceleration and velocity of each body is computed and the bodies collide with each other. Then, after the simulation is complete, the positions and rotations of the corresponding nodes are updated.\n\nControl the Behavior of Individual Bodies\n\nYou have precise control over which physics effects interact with each other. For example, you can specify that a particular physics field node only affects a subset of the physics bodies in the scene. You also decide which physics bodies can collide with each other and separately decide which interactions cause your app to be called. You use these callbacks to add game logic. For example, your game might destroy a node when its physics body is struck by another physics body.\n\nDecide on Physics Behaviors\n\nTo use physics in your game, you need to:\n\nAttach physics bodies to nodes in the node tree and configure their physical properties. See SKPhysicsBody.\n\nDefine global characteristics of the scene’s physics simulation, such as gravity. See SKPhysicsWorld.\n\nWhere necessary to support your gameplay, set the velocity of physics bodies in the scene or apply forces or impulses to them. See SKFieldNode and SKPhysicsBody.\n\nDecide whether physics bodies in the scene should be connected with each other. See SKPhysicsJoint and the pinned property on SKPhysicsBody.\n\nDefine how the physics bodies in the scene interact when they come in contact with each other. See SKPhysicsContactDelegate.\n\nOptimize your physics simulation to limit the number of calculations it must perform.\n\nSee Also\nPhysics Simulation\nclass SKPhysicsWorld\nThe driver of the physics engine in a scene; it exposes the ability for you to configure and query the physics system.\nclass SKPhysicsBody\nAn object that adds physics simulation to a node.\nclass SKPhysicsContact\nA description of the contact between two physics bodies.\nprotocol SKPhysicsContactDelegate\nMethods your app can implement to respond when physics bodies come into contact.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes."
  },
  {
    "title": "Getting Started with Actions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/getting_started_with_actions",
    "html": "Overview\n\nYou tell nodes to run an instance of SKAction when you want to animate contents of your scene. When the scene processes frames of animation, the actions are executed. Some actions are completed in a single frame of animation, while other actions apply changes over multiple frames of animation before completing. The most common use for actions is to animate changes to a node’s properties. For example, you can create actions that move a node, scale or rotate it, or fade its transparency. However, actions can also change the node tree, play sounds, or even execute custom code.\n\nCreate and Run an Action\n\nDo the following:\n\nCreate an action by calling the desired factory method; for example, fade(withDuration:).\n\nOptionally configure additional properties, like speed or timingFunction.\n\nPass the action as an argument to a node's run(_:) function to execute it.\n\nControl Action Timing\n\nWhen you run(_:) an action, SpriteKit manages the interpolation. That means that SpriteKit changes the properties of the node over more than one frame rendered by the scene automatically for you. As a result, you control the timing of the animation by configuring:\n\nduration, which states how long that action takes to complete in seconds\n\ntimingMode, which defines the rate at which the animation executes\n\nspeed, which allows you to adjust the timing of the animation by increasing or decreasing its playback speed.\n\nCreate a Reverse Action\n\nMany actions can be reversed, allowing you to create another action object that reverses the effect of that action. For example, if an action object moves a node 20 points to the right of its current position, the reversed action moves the node 20 points to the left. To create a reversed action object, call an action object’s reversed() method.\n\nRun Code when an Action Completes\n\nThe run(_:completion:) method is identical to the run(_:) method, but after the action completes, your block is called, but only if the action runs to completion. If the action is removed before it completes, the completion handler is never called. The following code fades out a sprite by running a fadeOut(withDuration:) action on it and, after the action completes, presents a new scene:\n\nlet fadeOut = SKAction.fadeOut(withDuration:2)\nnode.run(fadeOut) {\n    skView.presentScene(newScene)\n}\n\n\nReuse Actions\n\nAfter you create an action, its type cannot be changed, and you have a limited ability to change its properties. SpriteKit takes advantage of this immutable nature to execute the actions efficiently. Because actions are effectively immutable objects, you can run the same action safely on multiple nodes in the tree at the same time. For this reason, if you have an action that is used repeatedly in your game, create a single instance of the action and then reuse it whenever you need a node to execute it.\n\nDrive Game Logic\n\nBecause actions can be chained and can wrap custom code, it's possible to drive most of your app's logic using a complex system of actions. But where actions leave more sophisticated behavior to be desired, you might need to override the SKSceneDelegate callbacks and drive node behavior from there. For example, if a node needs to be moved in a wholly custom manner, you can adjust its position in update(_:) instead of using an action to do so.\n\nSee Also\nAnimation\nclass SKAction\nAn object that is run by a node to change its structure or content."
  },
  {
    "title": "SKMutableTexture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skmutabletexture",
    "html": "Overview\n\nNormally, SpriteKit textures (SKTexture objects) are static, meaning that once created, their contents cannot be changed. This is important because a static image can be more efficiently managed inside the graphics hardware. However, sometimes you need to be able to update the contents of a texture dynamically. In this case, you should use a mutable texture. Because there is a performance penalty for updating the texture’s contents, consider other options first. For example, you can render a texture in hardware using the texture(from:) method and a node tree.\n\nTo use this class, create a mutable texture using either one of its creation methods or those of its superclass. Then, when you need to update the mutable texture object’s contents, call the modifyPixelData(_:) method. Your block is called with the location of the texture in memory. Your block should update this texture and then return.\n\nTopics\nCreating an Empty Mutable Texture\ninit(size: CGSize, pixelFormat: Int32)\nInitializes an empty texture with a specific size and format.\ninit(size: CGSize)\nInitializes an empty texture with a specific size.\nModifying a Mutable Texture’s Contents\nfunc modifyPixelData((UnsafeMutableRawPointer?, Int) -> Void)\nModifies the contents of a mutable texture.\nRelationships\nInherits From\nSKTexture\nSee Also\nTextures\nMaximizing Texture Performance\nSpeed up image display and enable more images to be displayed at one time.\nclass SKTexture\nAn image, decoded on the GPU, that can be used to render various SpriteKit objects.\nclass SKTextureAtlas\nA collection of textures optimized for storage and drawing performance."
  },
  {
    "title": "SKTextureAtlas | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktextureatlas",
    "html": "Overview\n\nAn SKTextureAtlas is a collection of textures that were either created from an .atlas folder in the app bundle, or created at runtime. Texture atlases improve memory usage and rendering performance by reducing draw calls. Whenever you have textures that are always used together, store them in an atlas for best results.\n\nSpriteKit implicitly loads an atlas when one of the atlas's textures is accessed. Use textureNamed(_:) when you want to explicitly access a texture atlas’s contents.\n\nThe preferred place to create a texture atlas is within an asset catalog (see Creating a Sprite Atlas), but you can also put your source textures in an .atlas folder in the app bundle.\n\nTopics\nFirst Steps\nAbout Texture Atlases\nLearn about the benefits of having a texture atlas, and the process for using it.\nAccessing Textures\nRetrieve textures from an atlas by the textures' filenames.\nfunc textureNamed(String) -> SKTexture\nCreates a texture from data stored in the texture atlas.\nCreating a Texture Atlas Programmatically\nCreate an atlas in code.\ninit(named: String)\nCreates a texture atlas from data stored in the app bundle.\ninit(dictionary: [String : Any])\nCreates a texture atlas from a set of image files.\nPreloading Textures\nGain fine-tuned control over when an atlas is decoded.\nfunc preload(completionHandler: () -> Void)\nLoads an atlas object’s textures into memory, calling a completion handler after the task completes.\nclass func preloadTextureAtlases([SKTextureAtlas], withCompletionHandler: () -> Void)\nLoads the textures of multiple atlas objects into memory, calling a completion handler after the task completes.\nclass func preloadTextureAtlasesNamed([String], withCompletionHandler: (Error?, [SKTextureAtlas]) -> Void)\nLoads the textures of multiple atlases into memory, calling a completion handler after the task completes.\nReading Source Image Filenames\nDetermine whether an atlas contains a particular source image.\nvar textureNames: [String]\nThe names of the texture images stored in the atlas.\nInstance Properties\nvar customPlaygroundQuickLook: PlaygroundQuickLook\nA custom playground quick look for this instance.\nDeprecated\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nTextures\nMaximizing Texture Performance\nSpeed up image display and enable more images to be displayed at one time.\nclass SKTexture\nAn image, decoded on the GPU, that can be used to render various SpriteKit objects.\nclass SKMutableTexture\nA texture whose contents can be dynamically updated."
  },
  {
    "title": "SKTexture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/sktexture",
    "html": "Overview\n\nAn SKTexture object is an image that can be applied to SKSpriteNode and SKShapeNode objects, particles created by an SKEmitterNode object, or tiles used in an SKTileMapNode. A texture object manages the texture data and graphics resources that are needed to render the image. Most texture objects are created from source images stored in your app bundle—your game’s artwork. Once created, a texture object’s contents are immutable. Multiple sprites can share the same texture object, sharing a single resource.\n\nDeallocating a Texture\n\nAfter a texture is loaded into the graphics hardware memory, it stays in memory until the referencing SKTexture object is deleted. This means that between levels (or in a dynamic game), you may need to make sure a texture object is deleted. Delete a SKTexture object by removing any strong references to it, including:\n\nAll texture references from SKSpriteNode and SKEffectNode objects in your game\n\nAny strong references to the texture in your own code\n\nAn SKTextureAtlas object that was used to create the texture object\n\nTopics\nFirst Steps\nCreate texture objects from images on disk or in memory.\nLoading and Using Textures\nLearn the basics about using textures in SpriteKit.\nTexture Initializers\nSee the various ways to create and use textures in SpriteKit.\nReading a Texture's Size and Optional Source Location\nRead the texture's size or optional cropping rectangle.\nfunc size() -> CGSize\nGets the size of the texture.\nfunc textureRect() -> CGRect\nGets a rectangle that defines the portion of the texture used to render its image.\nConfiguring a Texture's Behavior for Scaling\nDefine the texture's behavior at different scales.\nvar filteringMode: SKTextureFilteringMode\nThe filtering mode used when the size of a sprite drawn with the texture is not drawn at the texture’s native size.\nenum SKTextureFilteringMode\nTexture filtering modes to use when the texture is drawn in a size other than its native size.\nvar usesMipmaps: Bool\nA Boolean value that indicates whether the texture attempts to generate mipmaps.\nGetting a Texture's Underlying Image\nfunc cgImage() -> CGImage\nReturns the texture’s image data as a Quartz 2D image.\nPreloading a Texture for Performance\nGain fine-tuned control over when a texture is decoded.\nPreloading Textures into Memory\nDecompress images ahead of time to avoid performance issues during gameplay.\nfunc preload(completionHandler: () -> Void)\nLoad texture data into memory, calling a completion handler after the task completes.\nclass func preload([SKTexture], withCompletionHandler: () -> Void)\nLoad the data of multiple textures into memory.\nInstance Properties\nvar customPlaygroundQuickLook: PlaygroundQuickLook\nDeprecated\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nTextures\nMaximizing Texture Performance\nSpeed up image display and enable more images to be displayed at one time.\nclass SKTextureAtlas\nA collection of textures optimized for storage and drawing performance.\nclass SKMutableTexture\nA texture whose contents can be dynamically updated."
  },
  {
    "title": "SKView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skview",
    "html": "Overview\n\nYou present a scene by calling the view’s presentScene(_:) method. When a scene is presented by the view, it alternates between running its simulation (which animates the content) and rendering the content for display. You can pause the scene by setting the view’s isPaused property to true.\n\nTopics\nDisplaying a Scene\nPresent a scene to display content on the screen.\nvar scene: SKScene?\nThe scene currently presented by this view.\nfunc presentScene(SKScene?)\nPresents a scene.\nfunc presentScene(SKScene, transition: SKTransition)\nTransitions from the current scene to a new scene.\nclass SKTransition\nAn object used to perform an animated transition to a new scene.\nControlling the Timing of a Scene's Rendering\nControl the timing of the view's screen updates.\nvar isPaused: Bool\nA Boolean value that indicates whether the view’s scene animations are paused.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar delegate: SKViewDelegate?\nA delegate that allows dynamic control of the view's render rate.\nprotocol SKViewDelegate\nMethods to take custom control over the view's render rate.\nvar frameInterval: Int\nThe number of frames that must pass before the scene is called to update its contents.\nDeprecated\nvar preferredFrameRate: Float\nDeprecated\nConfiguring Performance Related Toggles\nControl hints that have performance implications which are unique to your app.\nvar ignoresSiblingOrder: Bool\nA Boolean value that indicates whether parent-child and sibling relationships affect the rendering order of nodes in the scene.\nvar shouldCullNonVisibleNodes: Bool\nA Boolean value that indicates whether the view automatically culls non-visible nodes from the rendering tree.\nvar allowsTransparency: Bool\nA Boolean property that indicates whether the view is rendered using transparency.\nvar isAsynchronous: Bool\nA Boolean value that indicates whether the content is rendered asynchronously.\nEnabling Visual Statistics for Debugging\nDisplay metrics in the bottom corner of the view for debugging purposes.\nvar showsFPS: Bool\nA Boolean value that indicates whether the view displays a frame rate indicator.\nvar showsNodeCount: Bool\nA Boolean value that indicates whether the view displays an overlay that shows physics bodies that are visible in the scene.\nvar showsDrawCount: Bool\nA Boolean value that indicates whether the view displays the number of drawing passes it needed to render the view.\nvar showsQuadCount: Bool\nA Boolean value that indicates whether the view displays the number of rectangles used to render the scene.\nvar showsPhysics: Bool\nA Boolean value that indicates whether the view displays physics-related debugging information.\nvar showsFields: Bool\nA Boolean value that indicates whether the view displays information about physics fields in the scene.\nConverting Between View and Scene Coordinates\nConvert to or from scene and view coordinates which is a common task for touch or mouse input.\nfunc convert(CGPoint, from: SKScene) -> CGPoint\nConverts a point from scene coordinates to view coordinates.\nfunc convert(CGPoint, to: SKScene) -> CGPoint\nConverts a point from view coordinates to scene coordinates.\nSnapshotting Nodes to a Texture\nCreate a texture that is a flattened or cropped portion of the node heirarchy.\nfunc texture(from: SKNode, crop: CGRect) -> SKTexture?\nRenders a portion of a node’s contents and returns the rendered image as a texture.\nfunc texture(from: SKNode) -> SKTexture?\nRenders the contents of a node tree and returns the rendered image as a texture.\nCreating a New Node By Rendering To a Texture\nRender a portion of the node tree into a new texture.\nSwitching Renderers\nRequesting the OpenGL Renderer\nSwitch to the legacy renderer temporarily for debugging purposes.\nInstance Properties\nvar disableDepthStencilBuffer: Bool\nRelationships\nInherits From\nNSView\nUIView\nConforms To\nNSSecureCoding\nSee Also\nScene Renderers\nChoosing a SpriteKit Scene Renderer\nCompare the different ways to display a SpriteKit scene.\nclass SKRenderer\nAn object that renders a scene into a custom Metal rendering pipeline and drives the scene update cycle.\nclass WKInterfaceSKScene\nA visual WatchKit element that displays a SpriteKit scene."
  },
  {
    "title": "Maximizing Texture Performance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/maximizing_texture_performance",
    "html": "Overview\n\nYou use textures and atlases to hold your app's image data, but need to follow recommended practices for the best performance. Because image data can consume much video memory, you should preload textures ahead of time and reuse them where possible. In addition, grouping related textures into an atlas enables them to draw faster. See SKTexture and SKTextureAtlas class references for more information.\n\nRepeat Images with Textures\n\nTextures, represented as SKTexture objects, are shared images used to render sprites. Always use textures whenever you need to apply the same image to multiple sprites. Usually you create textures by loading image files stored in your app bundle. However, SpriteKit can also create textures for you at runtime from other sources, including Core Graphics images, or even by rendering a node tree into a texture.\n\nPreload Textures\n\nSpriteKit simplifies texture management by handling the lower-level code required to load textures and make them available to the graphics hardware. Texture management is automatically managed by SpriteKit. However, if your game uses a large number of images, you can improve its performance by taking control of parts of the process. Primarily, you do this by telling SpriteKit explicitly to load a texture using SKTexture preload(_:withCompletionHandler:) or SKTextureAtlas preload(completionHandler:).\n\nGroup Similar Textures in an Atlas\n\nA texture atlas is a group of related textures that are used together in your game. For example, you might use a texture atlas to store all of the textures needed to animate a character or all of the tiles needed to render the background of a gameplay level. SpriteKit uses texture atlases to improve rendering performance.\n\nSee Also\nTextures\nclass SKTexture\nAn image, decoded on the GPU, that can be used to render various SpriteKit objects.\nclass SKTextureAtlas\nA collection of textures optimized for storage and drawing performance.\nclass SKMutableTexture\nA texture whose contents can be dynamically updated."
  },
  {
    "title": "Choosing a SpriteKit Scene Renderer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/choosing_a_spritekit_scene_renderer",
    "html": "Overview\n\nTo display SpriteKit content in a watch app, you use WKInterfaceSKScene, whereas on iOS, macOS, and tvOS, you use SKView to display a SpriteKit scene. If you need to mix SpriteKit with any custom Metal content, use SKRenderer.\n\nImportant\n\nSKRenderer is not available on watchOS.\n\nOn iOS, tvOS, and macOS, Draw Using a View or a Renderer\n\nChoose from the options below to display SpriteKit content on iOS, tvOS, or macOS.\n\nDraw Using a View\n\nTo draw SpriteKit content the most common way, set up an SKView and set its scene property. See Drawing SpriteKit Content in a View for an example of using SKView.\n\nDraw Using a Renderer\n\nWhen you want to mix SpriteKit content with your own Metal content, use SKRenderer to draw your SKScene. You might use SKRenderer to replace specific portions of a SpriteKit app with custom Metal code, or vice versa. SKRenderer combines the full control of Metal with the ease of use of SpriteKit and its library of useful objects.\n\nFor example, to take full control of just your game's tiled background while using SpriteKit to draw the rest, use an SKRenderer and MTLView combination instead of SKView, and then write the tiled background code yourself in Metal.When you're ready to mix the SpriteKit content with the Metal content, you call SKRenderer's render(withViewport:commandBuffer:renderPassDescriptor:). Finally, call present(_:) on a Metal view when you're ready to present a frame.\n\nOn watchOS, Draw Using an Interface Scene\n\nTo display SpriteKit content on Apple Watch, you create a WKInterfaceSKScene and then set its scene property. WKInterfaceSKScene functions much like SKView, but without the debugging visualization options.\n\nSee Also\nScene Renderers\nclass SKView\nA view subclass that renders a SpriteKit scene.\nclass SKRenderer\nAn object that renders a scene into a custom Metal rendering pipeline and drives the scene update cycle.\nclass WKInterfaceSKScene\nA visual WatchKit element that displays a SpriteKit scene."
  },
  {
    "title": "Nodes for Scene Building | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/nodes_for_scene_building",
    "html": "Topics\nBase Nodes\nProvide a reference, point of view, or foundation to all things displayed in a scene.\nUsing Base Nodes to Lay Out SpriteKit Content\nUse nonvisual nodes to define the layout of a scene.\nclass SKNode\nThe base class of all SpriteKit nodes.\nclass SKCameraNode\nA node that determines which parts of the scene are visible within a view.\nclass SKReferenceNode\nA node that's defined in an archived .sks file.\nNodes that Draw\nDisplay images, shapes, particles, text, video, tiles, or even 3D content.\nMaximizing Node Drawing Performance\nStructure your nodes for maximum performance.\nclass SKSpriteNode\nAn image or solid color.\nclass SKShapeNode\nA mathematical shape that can be stroked or filled.\nclass SKEmitterNode\nA source of various particle effects.\nclass SKLabelNode\nA graphical element that draws text.\nclass SKVideoNode\nA graphical element that plays video content.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SK3DNode\n3D SceneKit content drawn as a flattened sprite.\nNodes for Environmental Effects\nProvide environmental effects to your scene, such as audio, lighting, or areas with specific physics characteristics.\nclass SKAudioNode\nA node that plays audio.\nclass SKLightNode\nA node that lights surrounding nodes.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes.\nNodes that Modify Drawing\nModify the rendering of child nodes by cropping, applying Core Image filters, or performing 3D transformations.\nclass SKEffectNode\nA node that renders its children into a separate buffer, optionally applying an effect, before drawing the final result.\nclass SKCropNode\nA node that masks pixels drawn by its children so that only some pixels are seen.\nclass SKTransformNode\nA node that allows its children to rotate in 3D.\nSee Also\nEssentials\nDrawing SpriteKit Content in a View\nDisplay visual content using SpriteKit.\nclass SKScene\nAn object that organizes all of the active SpriteKit content."
  },
  {
    "title": "Drawing SpriteKit Content in a View | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/drawing_spritekit_content_in_a_view",
    "html": "Overview\n\nDisplay SpriteKit content on the screen by configuring a SpriteKit renderer, its scene, and the visual objects you lay out on top of the scene. SpriteKit provides objects that are designed specifically for various types of content (see Nodes for Scene Building), but for simplicity, this article displays an image in a view.\n\nNote\n\nThere are other ways to draw SpriteKit content besides using a view. See Choosing a SpriteKit Scene Renderer for options.\n\nFigure 1 An image displayed in a SpriteKit view\n\nBecause the code in this article sets up a view, you put the lines from each of the following code listings into a view controller's viewDidLoad() function.\n\nCreate the Scene\n\nEverything displayed with SpriteKit is done through a scene object, which is an instance of SKScene. Use the following code to set up a basic scene:\n\nlet scene = SKScene(size: skView.bounds.size)\n\n\n// Set the scene coordinates (0, 0) to the center of the screen.\nscene.anchorPoint = CGPoint(x: 0.5, y: 0.5)\n\n\nWhen you pass the size of the view's bounds to the scene initializer, you size the scene to the view's size. When you set the scene's anchorPoint to (0.5, 0.5), you determine that the coordinates (0, 0) map to the center of the view.\n\nFor further discussion about how setting the anchorPoint changes an object's position in the view, see Using the Anchor Point to Move the Sprite’s Frame.\n\nLay Out Visual Content on Top of the Scene\n\nYou use node objects to display graphics in a SpriteKit view. SpriteKit provides different nodes depending on the content (see Nodes that Draw). In this case, use an SKSpriteNode to display an image in the view:\n\nlet image = SKSpriteNode(imageNamed: \"myImage.png\")\n\n\n// Add the image to the scene.\nscene.addChild(image)\n\n\n\n\nThe functions to lay out content in a scene are covered in more detail in Accessing and Modifying the Node Tree.\n\nPresent the Scene Inside a View\n\nAfter you set up the scene, you display it in the view by calling presentScene(_:):\n\nif let skView = self.view as? SKView { \n    skView.presentScene(scene)\n}\n\n\n\n\nBecause the code in this article sets up a view, you add it to your view controller's viewDidLoad() function.\n\nSee Also\nEssentials\nclass SKScene\nAn object that organizes all of the active SpriteKit content.\nNodes for Scene Building\nDefine the appearance or layout of scene content."
  },
  {
    "title": "SKFieldNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skfieldnode",
    "html": "Overview\n\nThere are many different kinds of field nodes that can be created, each with different effects. The Creating Field Nodes section lists the field types you can create using SpriteKit, including a type that allows you to apply custom forces to physics bodies. Instantiate the appropriate kind of field node and then add it to the scene’s node tree.\n\nWhen the scene simulates physics effects, a field node applies its effect to a physics body so long as the following are true:\n\nThe field node is in the scene’s node tree.\n\nThe field node’s isEnabled property is true.\n\nThe physics body is attached to a node that is in the scene’s node tree.\n\nThe physics body is located inside the field node’s region (see region).\n\nThe physics body is not located inside the region of another field node whose isExclusive property is set to true.\n\nA logical AND operation between the field node’s categoryBitMask property and the physics body’s fieldBitMask property results in a nonzero value.\n\nTip\n\nWhile it is useful to know that SpriteKit measures items in the International System of Units, the precise numbers are not that important. It doesn’t matter much whether your rocket ship weights 1 kilogram or 1,000,000 kilograms, as long as the mass is consistent with other physics values used in the game. Often, proportions are more important than the actual values being used.\n\nTopics\nGetting Started with Field Nodes\nAdding Physics Fields to a Scene\nCreate effects that interact with your scene's physics bodies, such as magnetism, repulsion, friction, or a vortex.\nCreating Field Nodes\nclass func dragField() -> SKFieldNode\nCreates a field node that applies a force that resists the motion of physics bodies.\nclass func electricField() -> SKFieldNode\nCreates a field node that applies an electrical force proportional to the electrical charge of physics bodies.\nclass func linearGravityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that accelerates physics bodies in a specific direction.\nclass func magneticField() -> SKFieldNode\nCreates a field node that applies a magnetic force based on the velocity and electrical charge of the physics bodies.\nclass func noiseField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func radialGravityField() -> SKFieldNode\nCreates a field node that accelerates physics bodies toward the field node.\nclass func springField() -> SKFieldNode\nCreates a field node that applies a spring-like force that pulls physics bodies toward the field node.\nclass func turbulenceField(withSmoothness: CGFloat, animationSpeed: CGFloat) -> SKFieldNode\nCreates a field node that applies a randomized acceleration to physics bodies.\nclass func velocityField(with: SKTexture) -> SKFieldNode\nCreates a field node that sets the velocity of physics bodies that enter the node’s area based on the pixel values of a texture.\nclass func velocityField(withVector: vector_float3) -> SKFieldNode\nCreates a field node that gives physics bodies a constant velocity.\nclass func vortexField() -> SKFieldNode\nCreates a field node that applies a perpendicular force to physics bodies.\nclass func customField(evaluationBlock: SKFieldForceEvaluator) -> SKFieldNode\nCreates a field node that calculates and applies a custom force to the physics body.\ntypealias SKFieldForceEvaluator\nThe definition for a custom block that processes a single physics body’s interaction with the field.\nDetermining Which Physics Bodies Are Affected by the Field\nvar isEnabled: Bool\nA Boolean value that indicates whether the field is active.\nvar isExclusive: Bool\nA Boolean value that indicates whether the field node should override all other field nodes that might otherwise affect physics bodies.\nvar region: SKRegion?\nThe area (relative to the node’s origin) that the field affects.\nvar minimumRadius: Float\nThe minimum value for distance-based effects.\nvar categoryBitMask: UInt32\nA mask that defines which categories this field belongs to.\nConfiguring the Strength of the Field\nvar strength: Float\nThe strength of the field.\nvar falloff: Float\nThe exponent that defines the rate of decay for the strength of the field as the distance increases between the node and the physics body being affected.\nConfiguring Other Field Properties\nThese properties are associated with specific types of field nodes.\nvar animationSpeed: Float\nThe rate at which a noise or turbulence field node changes.\nvar smoothness: Float\nThe smoothness of the noise used to generate the forces.\nvar direction: vector_float3\nThe direction of a velocity field node.\nvar texture: SKTexture?\nA normal texture that specifies the velocities at different points in a velocity field node.\nRelationships\nInherits From\nSKNode\nSee Also\nPhysics Simulation\nGetting Started with Physics\nSimulate gravity, acceleration, collision detection, or joints.\nclass SKPhysicsWorld\nThe driver of the physics engine in a scene; it exposes the ability for you to configure and query the physics system.\nclass SKPhysicsBody\nAn object that adds physics simulation to a node.\nclass SKPhysicsContact\nA description of the contact between two physics bodies.\nprotocol SKPhysicsContactDelegate\nMethods your app can implement to respond when physics bodies come into contact."
  },
  {
    "title": "SKReachConstraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit/skreachconstraints",
    "html": "Overview\n\nAn SKReachConstraints object is used to describe the range of motion for an SKNode object whenever an inverse kinematic (IK) action is executed. To use reach constraints, create an SKReachConstraints object and assign it to a node’s reachConstraints property. For more information on using reach actions to perform IK animations, see the SKAction class.\n\nTopics\nWorking with Reach Constraints\ninit(lowerAngleLimit: CGFloat, upperAngleLimit: CGFloat)\nInitializes a new reach constraint object.\nvar lowerAngleLimit: CGFloat\nThe minimum angle that the node can have after it is rotated by a reach event.\nvar upperAngleLimit: CGFloat\nThe maximum angle that the node can have after it is rotated by a reach event.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nConstraints\nclass SKConstraint\nA specification for constraining a node’s position or rotation."
  },
  {
    "title": "SpriteKit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/spritekit",
    "html": "Overview\n\nSpriteKit is a general-purpose framework for drawing shapes, particles, text, images, and video in two dimensions. It leverages Metal to achieve high-performance rendering, while offering a simple programming interface to make it easy to create games and other graphics-intensive apps. Using a rich set of animations and physics behaviors, you can quickly add life to your visual elements and gracefully transition between screens.\n\nSpriteKit is supported in iOS, macOS, tvOS, and watchOS, and it integrates well with frameworks such as GameplayKit and SceneKit. You can use SpriteKit in a compatible iPhone or iPad app running in visionOS, but don’t use it in apps you create specifically for visionOS.\n\nTopics\nEssentials\nDrawing SpriteKit Content in a View\nDisplay visual content using SpriteKit.\nclass SKScene\nAn object that organizes all of the active SpriteKit content.\nNodes for Scene Building\nDefine the appearance or layout of scene content.\nScene Renderers\nDraw a SpriteKit scene using a rendering object.\nChoosing a SpriteKit Scene Renderer\nCompare the different ways to display a SpriteKit scene.\nclass SKView\nA view subclass that renders a SpriteKit scene.\nclass SKRenderer\nAn object that renders a scene into a custom Metal rendering pipeline and drives the scene update cycle.\nclass WKInterfaceSKScene\nA visual WatchKit element that displays a SpriteKit scene.\nTextures\n\nLoad graphics from various sources, or use an atlas to maximize rendering performance.\n\nMaximizing Texture Performance\nSpeed up image display and enable more images to be displayed at one time.\nclass SKTexture\nAn image, decoded on the GPU, that can be used to render various SpriteKit objects.\nclass SKTextureAtlas\nA collection of textures optimized for storage and drawing performance.\nclass SKMutableTexture\nA texture whose contents can be dynamically updated.\nAnimation\nAnimate nodes by using a suite of provided actions, or create custom actions.\nGetting Started with Actions\nCreate, configure, and run actions in SpriteKit.\nclass SKAction\nAn object that is run by a node to change its structure or content.\nConstraints\n\nConstrain the position or orientation of nodes.\n\nclass SKConstraint\nA specification for constraining a node’s position or rotation.\nclass SKReachConstraints\nA specification of the degree of freedom when solving inverse kinematics.\nMathematical Tools\nMultipurpose mathematical objects you use to facilitate other graphical work.\nclass SKKeyframeSequence\nAn object that performs interpolation between values specified at different times (keyframes).\nclass SKRange\nA definition of a range of floating-point values.\nclass SKRegion\nThe definition of an arbitrary area.\nPhysics Simulation\nAdd physics behaviors to nodes in your scene.\n\nGetting Started with Physics\nSimulate gravity, acceleration, collision detection, or joints.\nclass SKPhysicsWorld\nThe driver of the physics engine in a scene; it exposes the ability for you to configure and query the physics system.\nclass SKPhysicsBody\nAn object that adds physics simulation to a node.\nclass SKPhysicsContact\nA description of the contact between two physics bodies.\nprotocol SKPhysicsContactDelegate\nMethods your app can implement to respond when physics bodies come into contact.\nclass SKFieldNode\nA node that applies physics effects to nearby nodes.\nPhysics Joints\nConnect physics bodies by using conceptual tools like pins, sliding joints, and spring joints.\nWorking with Inverse Kinematics\nGain fine-tuned control of objects that are connected by joints.\nclass SKPhysicsJoint\nThe abstract superclass for objects that connect physics bodies.\nclass SKPhysicsJointFixed\nA joint that fuses two physics bodies together at a reference point.\nclass SKPhysicsJointLimit\nA joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\nclass SKPhysicsJointPin\nA joint that pins together two physics bodies, allowing independent rotation.\nclass SKPhysicsJointSliding\nA joint that allows two physics bodies to slide along an axis.\nclass SKPhysicsJointSpring\nA joint that simulates a spring connecting two physics bodies.\nTiling\nConfigure the images or autotiling behavior of a tile map node.\nclass SKTileMapNode\nA two-dimensional array of images.\nclass SKTileDefinition\nA single tile that can be repeated in a tile map.\nclass SKTileGroup\nA set of tiles that collectively define one type of terrain.\nclass SKTileGroupRule\nRules that describe how various tiles should be placed in a map.\nclass SKTileSet\nA container for related tile groups.\nShaders\nCustomize node drawing by augmenting the node's color or shape.\nclass SKShader\nAn object that allows you to apply a custom fragment shader.\nclass SKAttribute\nA specification for dynamic per-node data used with a custom shader.\nclass SKAttributeValue\nA container for dynamic shader data associated with a node.\nclass SKUniform\nA container for uniform shader data.\nWarping\nDistort a node by supplying vertices and their transformations.\nclass SKWarpGeometry\nA definition for a deformation of nodes that conform to SKWarpable.\nclass SKWarpGeometryGrid\nA definition for a grid-based deformation of nodes that conform to SKWarpable.\nprotocol SKWarpable\nA protocol for objects that can be warped and animated by an SKWarpGeometry.\nReference\nSpriteKit Enumerations\nEnumerations used across SpriteKit.\nSpriteKit Data Types\nData types used across SpriteKit.\nSpriteKit Constants\nConstants used across SpriteKit.\nSpriteKit Type Aliases\nType aliases used across SpriteKit.\nStructures\nstruct SpriteView\nA SwiftUI view that renders a SpriteKit scene."
  }
]
